{
  "snippets": [
    {
      "id": "c8923430-a6ec-4916-986a-f1616dcdafd5",
      "code": "class Solution:\n  def twoSum(self, nums: list[int], target: int) -> list[int]:\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      if target - num in numToIndex:\n        return numToIndex[target - num], i\n      numToIndex[num] = i",
      "title": "1. Two Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16d34534-7f19-4908-bc89-cb98653c659d",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n\n    while carry or l1 or l2:\n      if l1:\n        carry += l1.val\n        l1 = l1.next\n      if l2:\n        carry += l2.val\n        l2 = l2.next\n      curr.next = ListNode(carry % 10)\n      carry //= 10\n      curr = curr.next\n\n    return dummy.next",
      "title": "2. Add Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "905a6566-7280-4194-9f50-9df18cd24392",
      "code": "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    # The substring s[j + 1..i] has no repeating characters.\n    j = -1\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      # Update j to lastSeen[c], so the window must start from j + 1.\n      j = max(j, lastSeen.get(c, -1))\n      ans = max(ans, i - j)\n      lastSeen[c] = i\n\n    return ans",
      "title": "3. Longest Substring Without Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "684ef73e-07d9-4b24-b63d-f1300da22da5",
      "code": "class Solution:\n  def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1",
      "title": "4. Median of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbc7b855-a85e-4a5a-922f-56940f1bf048",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    t = '#'.join('@' + s + '$')\n    p = self._manacher(t)\n    maxPalindromeLength, bestCenter = max((extend, i)\n                                          for i, extend in enumerate(p))\n    l = (bestCenter - maxPalindromeLength) // 2\n    r = (bestCenter + maxPalindromeLength) // 2\n    return s[l:r]\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p",
      "title": "5. Longest Palindromic Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c5f077-f1c1-448b-b155-b19d642fc959",
      "code": "class Solution:\n  def convert(self, s: str, numRows: int) -> str:\n    rows = [''] * numRows\n    k = 0\n    direction = (numRows == 1) - 1\n\n    for c in s:\n      rows[k] += c\n      if k == 0 or k == numRows - 1:\n        direction *= -1\n      k += direction\n\n    return ''.join(rows)",
      "title": "6. ZigZag Conversion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e7fb2d7-16ef-4d82-bc19-5f436886ebeb",
      "code": "class Solution:\n  def reverse(self, x: int) -> int:\n    ans = 0\n    sign = -1 if x < 0 else 1\n    x *= sign\n\n    while x:\n      ans = ans * 10 + x % 10\n      x //= 10\n\n    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans",
      "title": "7. Reverse Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2adf6148-f8d9-4061-8aef-c959ea631910",
      "code": "class Solution:\n  def myAtoi(self, s: str) -> int:\n    s = s.strip()\n    if not s:\n      return 0\n\n    sign = -1 if s[0] == '-' else 1\n    if s[0] in {'-', '+'}:\n      s = s[1:]\n\n    num = 0\n\n    for c in s:\n      if not c.isdigit():\n        break\n      num = num * 10 + int(c)\n      if sign * num <= -2**31:\n        return -2**31\n      if sign * num >= 2**31 - 1:\n        return 2**31 - 1\n\n    return sign * num",
      "title": "8. String to Integer (atoi)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8babab3d-d186-4a50-8b97-f4ece70f48a6",
      "code": "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n    if x < 0:\n      return False\n\n    rev = 0\n    y = x\n\n    while y:\n      rev = rev * 10 + y % 10\n      y //= 10\n\n    return rev == x",
      "title": "9. Palindrome Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aafe057a-c56d-4dc9-b2ac-e735f029bb64",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          # The minimum index of '*' is 1.\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "10. Regular Expression Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4d45aa6-01b8-4c7c-ac3e-d97a288896b2",
      "code": "class Solution:\n  def maxArea(self, height: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(height) - 1\n\n    while l < r:\n      minHeight = min(height[l], height[r])\n      ans = max(ans, minHeight * (r - l))\n      if height[l] < height[r]:\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "11. Container With Most Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6926928-9f78-4dfe-8d1f-c4ba41a3d554",
      "code": "class Solution:\n  def intToRoman(self, num: int) -> str:\n    valueSymbols = [(1000, 'M'), (900, 'CM'),\n                    (500, 'D'), (400, 'CD'),\n                    (100, 'C'), (90, 'XC'),\n                    (50, 'L'), (40, 'XL'),\n                    (10, 'X'), (9, 'IX'),\n                    (5, 'V'), (4, 'IV'),\n                    (1, 'I')]\n    ans = []\n\n    for value, symbol in valueSymbols:\n      if num == 0:\n        break\n      count, num = divmod(num, value)\n      ans.append(symbol * count)\n\n    return ''.join(ans)",
      "title": "12. Integer to Roman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9797413-8bc0-498b-a8b3-c5192b5bd721",
      "code": "class Solution:\n  def romanToInt(self, s: str) -> int:\n    ans = 0\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n             'C': 100, 'D': 500, 'M': 1000}\n\n    for a, b in zip(s, s[1:]):\n      if roman[a] < roman[b]:\n        ans -= roman[a]\n      else:\n        ans += roman[a]\n\n    return ans + roman[s[-1]]",
      "title": "13. Roman to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91665961-0357-405a-a947-7d6b4e953182",
      "code": "class Solution:\n  def longestCommonPrefix(self, strs: list[str]) -> str:\n    if not strs:\n      return ''\n\n    for i in range(len(strs[0])):\n      for j in range(1, len(strs)):\n        if i == len(strs[j]) or strs[j][i] != strs[0][i]:\n          return strs[0][:i]\n\n    return strs[0]",
      "title": "14. Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2349aea5-e1c2-40ce-9b06-e5fd49ff8f5f",
      "code": "class Solution:\n  def threeSum(self, nums: list[int]) -> list[list[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "15. 3Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "873f5322-6eb1-4e53-ac01-f1cae1f7e918",
      "code": "class Solution:\n  def threeSumClosest(self, nums: list[int], target: int) -> int:\n    ans = nums[0] + nums[1] + nums[2]\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == target:\n          return summ\n        if abs(summ - target) < abs(ans - target):\n          ans = summ\n        if summ < target:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "16. 3Sum Closest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e46c95e6-c764-4ef1-b992-5ef46875523a",
      "code": "class Solution:\n  def letterCombinations(self, digits: str) -> list[str]:\n    if not digits:\n      return []\n\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(digits):\n        ans.append(''.join(path))\n        return\n\n      for letter in digitToLetters[int(digits[i])]:\n        path.append(letter)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return ans",
      "title": "17. Letter Combinations of a Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64b369e4-decd-44aa-a142-0fe8b87b01a9",
      "code": "class Solution:\n  def fourSum(self, nums: list[int], target: int):\n    ans = []\n\n    def nSum(\n            l: int, r: int, target: int, n: int, path: list[int],\n            ans: list[list[int]]) -> None:\n      \"\"\"Finds n numbers that add up to the target in [l, r].\"\"\"\n      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:\n        return\n      if n == 2:\n        while l < r:\n          summ = nums[l] + nums[r]\n          if summ == target:\n            ans.append(path + [nums[l], nums[r]])\n            l += 1\n            while nums[l] == nums[l - 1] and l < r:\n              l += 1\n          elif summ < target:\n            l += 1\n          else:\n            r -= 1\n        return\n\n      for i in range(l, r + 1):\n        if i > l and nums[i] == nums[i - 1]:\n          continue\n\n        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)\n\n    nums.sort()\n    nSum(0, len(nums) - 1, target, 4, [], ans)\n    return ans",
      "title": "18. 4Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f178635c-ac14-484b-b8fb-a58fa727aab5",
      "code": "class Solution:\n  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    slow = head\n    fast = head\n\n    for _ in range(n):\n      fast = fast.next\n    if not fast:\n      return head.next\n\n    while fast.next:\n      slow = slow.next\n      fast = fast.next\n    slow.next = slow.next.next\n\n    return head",
      "title": "19. Remove Nth Node From End of List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d73916d-b595-4e55-8ac5-aeb22bb8bc7a",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == '(':\n        stack.append(')')\n      elif c == '{':\n        stack.append('}')\n      elif c == '[':\n        stack.append(']')\n      elif not stack or stack.pop() != c:\n        return False\n\n    return not stack",
      "title": "20. Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44c7ebdf-682b-44eb-b8bd-131f6c5915a7",
      "code": "class Solution:\n  def mergeTwoLists(\n      self,\n      list1: ListNode | None,\n      list2: ListNode | None,\n  ) -> ListNode | None:\n    if not list1 or not list2:\n      return list1 if list1 else list2\n    if list1.val > list2.val:\n      list1, list2 = list2, list1\n    list1.next = self.mergeTwoLists(list1.next, list2)\n    return list1",
      "title": "21. Merge Two Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98093fae-880a-4207-b2b5-3831ca053bf4",
      "code": "class Solution:\n  def generateParenthesis(self, n):\n    ans = []\n\n    def dfs(l: int, r: int, s: list[str]) -> None:\n      if l == 0 and r == 0:\n        ans.append(''.join(s))\n      if l > 0:\n        s.append('(')\n        dfs(l - 1, r, s)\n        s.pop()\n      if l < r:\n        s.append(')')\n        dfs(l, r - 1, s)\n        s.pop()\n\n    dfs(n, n, [])\n    return ans",
      "title": "22. Generate Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80357d96-7ba5-4bc6-8a71-04a033c36bbb",
      "code": "from queue import PriorityQueue\n\n\nclass Solution:\n  def mergeKLists(self, lists: list[ListNode]) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    pq = PriorityQueue()\n\n    for i, lst in enumerate(lists):\n      if lst:\n        pq.put((lst.val, i, lst))\n\n    while not pq.empty():\n      _, i, minNode = pq.get()\n      if minNode.next:\n        pq.put((minNode.next.val, i, minNode.next))\n      curr.next = minNode\n      curr = curr.next\n\n    return dummy.next",
      "title": "23. Merge k Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1750cfc8-f88b-4748-8236-2b8ea1e58523",
      "code": "class Solution:\n  def swapPairs(self, head: ListNode) -> ListNode:\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // 2):\n      next = curr.next\n      curr.next = next.next\n      next.next = prev.next\n      prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next",
      "title": "24. Swap Nodes in Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ac7fd7-7a7b-45f0-a81d-b8833a12e2a9",
      "code": "class Solution:\n  def reverseKGroup(self, head: ListNode | None, k: int) -> ListNode | None:\n    if not head:\n      return None\n\n    tail = head\n\n    for _ in range(k):\n      # There are less than k nodes in the list, do nothing.\n      if not tail:\n        return head\n      tail = tail.next\n\n    newHead = self._reverse(head, tail)\n    head.next = self.reverseKGroup(tail, k)\n    return newHead\n\n  def _reverse(\n      self,\n      head: ListNode | None,\n      tail: ListNode | None,\n  ) -> ListNode | None:\n    \"\"\"Reverses [head, tail).\"\"\"\n    prev = None\n    curr = head\n    while curr != tail:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n    return prev",
      "title": "25. Reverse Nodes in k-Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b21e18c3-366e-4b35-b31a-a404cd276c60",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 1 or num > nums[i - 1]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "26. Remove Duplicates from Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a4bd36-9371-42ba-9dcf-3f19b49788d0",
      "code": "class Solution:\n  def removeElement(self, nums: list[int], val: int) -> int:\n    i = 0\n\n    for num in nums:\n      if num != val:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "27. Remove Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a232df0f-72ac-4a03-a845-3249d9f52d62",
      "code": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n    m = len(haystack)\n    n = len(needle)\n\n    for i in range(m - n + 1):\n      if haystack[i:i + n] == needle:\n        return i\n\n    return -1",
      "title": "28. Implement strStr()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e24e2be-ed78-4232-8e0e-75c29549559c",
      "code": "class Solution:\n  def divide(self, dividend: int, divisor: int) -> int:\n    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.\n    if dividend == -2**31 and divisor == -1:\n      return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n    ans = 0\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n\n    while dvd >= dvs:\n      k = 1\n      while k * 2 * dvs <= dvd:\n        k <<= 1\n      dvd -= k * dvs\n      ans += k\n\n    return sign * ans",
      "title": "29. Divide Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e5b006e-76ae-4867-a9ba-e30170e24869",
      "code": "class Solution:\n  def findSubstring(self, s: str, words: list[str]) -> list[int]:\n    if len(s) == 0 or words == []:\n      return []\n\n    k = len(words)\n    n = len(words[0])\n    ans = []\n    count = collections.Counter(words)\n\n    for i in range(len(s) - k * n + 1):\n      seen = collections.defaultdict(int)\n      j = 0\n      while j < k:\n        word = s[i + j * n: i + j * n + n]\n        seen[word] += 1\n        if seen[word] > count[word]:\n          break\n        j += 1\n      if j == k:\n        ans.append(i)\n\n    return ans",
      "title": "30. Substring with Concatenation of All Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e94ec310-8968-4f81-9ab5-f7ab23ebaca4",
      "code": "class Solution:\n  def nextPermutation(self, nums: list[int]) -> None:\n    n = len(nums)\n\n    # From back to front, find the first number < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From back to front, find the first number > nums[i], swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums: list[int], l: int, r: int) -> None:\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)",
      "title": "31. Next Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c19689d0-3fcf-47e8-884b-e3480ffa04f7",
      "code": "class Solution:\n  def longestValidParentheses(self, s: str) -> int:\n    s2 = ')' + s\n    # dp[i] := the length of the longest valid parentheses in the substring\n    # s2[1..i]\n    dp = [0] * len(s2)\n\n    for i in range(1, len(s2)):\n      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\n\n    return max(dp)",
      "title": "32. Longest Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8949e4f-150d-45f5-bffc-79e19b8f25de",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[l] <= nums[m]:  # nums[l..m] are sorted.\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted.\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return -1",
      "title": "33. Search in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0528df72-dfff-46ee-adae-1e4ada91cd3f",
      "code": "class Solution:\n  def searchRange(self, nums: list[int], target: int) -> list[int]:\n    l = bisect_left(nums, target)\n    if l == len(nums) or nums[l] != target:\n      return -1, -1\n    r = bisect_right(nums, target) - 1\n    return l, r",
      "title": "34. Find First and Last Position of Element in Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e46cfa9-16b9-478c-8980-8977aaae6a4d",
      "code": "class Solution:\n  def searchInsert(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[m] < target:\n        l = m + 1\n      else:\n        r = m\n\n    return l",
      "title": "35. Search Insert Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33e64c2f-5aef-49d4-83d3-ffed120c45a7",
      "code": "class Solution:\n  def isValidSudoku(self, board: list[list[str]]) -> bool:\n    seen = set()\n\n    for i in range(9):\n      for j in range(9):\n        c = board[i][j]\n        if c == '.':\n          continue\n        if (c + '@row ' + str(i) in seen or\n            c + '@col ' + str(j) in seen or\n                c + '@box ' + str(i // 3) + str(j // 3) in seen):\n          return False\n        seen.add(c + '@row ' + str(i))\n        seen.add(c + '@col ' + str(j))\n        seen.add(c + '@box ' + str(i // 3) + str(j // 3))\n\n    return True",
      "title": "36. Valid Sudoku",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8555029a-12fd-42a7-b63f-ad52eb29403b",
      "code": "class Solution:\n  def solveSudoku(self, board: list[list[str]]) -> None:\n    def isValid(row: int, col: int, c: str) -> bool:\n      for i in range(9):\n        if (board[i][col] == c or\n            board[row][i] == c or\n                board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c):\n          return False\n      return True\n\n    def solve(s: int) -> bool:\n      if s == 81:\n        return True\n\n      i = s // 9\n      j = s % 9\n\n      if board[i][j] != '.':\n        return solve(s + 1)\n\n      for c in string.digits[1:]:\n        if isValid(i, j, c):\n          board[i][j] = c\n          if solve(s + 1):\n            return True\n          board[i][j] = '.'\n\n      return False\n\n    solve(0)",
      "title": "37. Sudoku Solver",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b431edb2-07df-473a-a188-8c23f23a7ee4",
      "code": "class Solution:\n  def countAndSay(self, n: int) -> str:\n    ans = '1'\n\n    for _ in range(n - 1):\n      nxt = ''\n      i = 0\n      while i < len(ans):\n        count = 1\n        while i + 1 < len(ans) and ans[i] == ans[i + 1]:\n          count += 1\n          i += 1\n        nxt += str(count) + ans[i]\n        i += 1\n      ans = nxt\n\n    return ans",
      "title": "38. Count and Say",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5389f234-c415-415e-bb74-5abb9d8c28f6",
      "code": "class Solution:\n  def combinationSum(self, candidates: list[int],\n                     target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.clone())\n        return\n\n      for i in range(s, len(candidates)):\n        path.append(candidates[i])\n        dfs(i, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "39. Combination Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91b75fa7-ed34-4cb4-87e6-f7e2261e872f",
      "code": "class Solution:\n  def combinationSum2(self, candidates: list[int],\n                      target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, len(candidates)):\n        if i > s and candidates[i] == candidates[i - 1]:\n          continue\n        path.append(candidates[i])\n        dfs(i + 1, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "40. Combination Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5fbff2d6-e2ea-4fc8-a2a0-fa177ee81328",
      "code": "class Solution:\n  def firstMissingPositive(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    # Correct slot:\n    # nums[i] = i + 1\n    # nums[i] - 1 = i\n    # nums[nums[i] - 1] = nums[i]\n    for i in range(n):\n      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i, num in enumerate(nums):\n      if num != i + 1:\n        return i + 1\n\n    return n + 1",
      "title": "41. First Missing Positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60f3a2d4-8b3e-41d8-b9dc-ca37c4fc0b85",
      "code": "class Solution:\n  def trap(self, height: list[int]) -> int:\n    n = len(height)\n    l = [0] * n  # l[i] := max(height[0..i])\n    r = [0] * n  # r[i] := max(height[i..n))\n\n    for i, h in enumerate(height):\n      l[i] = h if i == 0 else max(h, l[i - 1])\n\n    for i, h in reversed(list(enumerate(height))):\n      r[i] = h if i == n - 1 else max(h, r[i + 1])\n\n    return sum(min(l[i], r[i]) - h\n               for i, h in enumerate(height))",
      "title": "42. Trapping Rain Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9acb55b8-cc34-484e-9a33-b5bb8b421078",
      "code": "class Solution:\n  def multiply(self, num1: str, num2: str) -> str:\n    s = [0] * (len(num1) + len(num2))\n\n    for i in reversed(range(len(num1))):\n      for j in reversed(range(len(num2))):\n        mult = int(num1[i]) * int(num2[j])\n        summ = mult + s[i + j + 1]\n        s[i + j] += summ // 10\n        s[i + j + 1] = summ % 10\n\n    for i, c in enumerate(s):\n      if c != 0:\n        break\n\n    return ''.join(map(str, s[i:]))",
      "title": "43. Multiply Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf02fbf9-0623-4a7d-b1b6-2ff623f083f5",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "44. Wildcard Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5692ed16-e095-48a8-a911-6781e317c096",
      "code": "class Solution:\n  def jump(self, nums: list[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Start an implicit BFS.\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level.\n        ans += 1        # Increment the level.\n        end = farthest  # Make the queue size for the next level.\n\n    return ans",
      "title": "45. Jump Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e650c94-2600-41cb-bdc2-4ae1b02d042a",
      "code": "class Solution:\n  def permute(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    dfs([])\n    return ans",
      "title": "46. Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8445a67-3bce-428a-9077-38e9117cf3b2",
      "code": "class Solution:\n  def permuteUnique(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "47. Permutations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e82a135-cb46-4761-b742-f1e973e38fbb",
      "code": "class Solution:\n  def rotate(self, matrix: list[list[int]]) -> None:\n    for mn in range(len(matrix) // 2):\n      mx = len(matrix) - mn - 1\n      for i in range(mn, mx):\n        offset = i - mn\n        top = matrix[mn][i]\n        matrix[mn][i] = matrix[mx - offset][mn]\n        matrix[mx - offset][mn] = matrix[mx][mx - offset]\n        matrix[mx][mx - offset] = matrix[i][mx]\n        matrix[i][mx] = top",
      "title": "48. Rotate Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dedbed0b-12dc-4d7f-9a84-1d6574b1de84",
      "code": "class Solution:\n  def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n    dict = collections.defaultdict(list)\n\n    for str in strs:\n      key = ''.join(sorted(str))\n      dict[key].append(str)\n\n    return dict.values()",
      "title": "49. Group Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3201cc6-1e51-4c80-a7b8-8adc757694f5",
      "code": "class Solution:\n  def myPow(self, x: float, n: int) -> float:\n    if n == 0:\n      return 1\n    if n < 0:\n      return 1 / self.myPow(x, -n)\n    if n % 2 == 1:\n      return x * self.myPow(x, n - 1)\n    return self.myPow(x * x, n // 2)",
      "title": "50. Pow(x, n)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3da9f614-6630-472b-9d74-d93bdc527276",
      "code": "class Solution:\n  def solveNQueens(self, n: int) -> list[list[str]]:\n    ans = []\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int, board: list[int]) -> None:\n      if i == n:\n        ans.append(board)\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0, [])\n    return ans",
      "title": "51. N-Queens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f217628a-f213-4730-be32-fe1a76532fbc",
      "code": "class Solution:\n  def totalNQueens(self, n: int) -> int:\n    ans = 0\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int) -> None:\n      nonlocal ans\n      if i == n:\n        ans += 1\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1)\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0)\n    return ans",
      "title": "52. N-Queens II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7133437f-946d-4819-8e4f-68091a8b703c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  # the sum of the subarray starting from the first number\n  maxSubarraySumLeft: int\n  # the sum of the subarray ending in the last number\n  maxSubarraySumRight: int\n  maxSubarraySum: int\n\n\nclass Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    def divideAndConquer(l: int, r: int) -> T:\n      if l == r:\n        return T(nums[l], nums[l], nums[l], nums[l])\n      m = (l + r) // 2\n      left = divideAndConquer(l, m)\n      right = divideAndConquer(m + 1, r)\n      maxSubarraySumLeft = max(left.maxSubarraySumLeft,\n                               left.summ + right.maxSubarraySumLeft)\n      maxSubarraySumRight = max(\n          left.maxSubarraySumRight + right.summ, right.maxSubarraySumRight)\n      maxSubarraySum = max(left.maxSubarraySumRight + right.maxSubarraySumLeft,\n                           left.maxSubarraySum, right.maxSubarraySum)\n      summ = left.summ + right.summ\n      return T(summ, maxSubarraySumLeft, maxSubarraySumRight, maxSubarraySum)\n\n    return divideAndConquer(0, len(nums) - 1).maxSubarraySum",
      "title": "53. Maximum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cf609bf-64b3-426b-bd4e-d6fcf6247b2d",
      "code": "class Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    # dp[i] := the maximum sum subarray ending in i\n    dp = [0] * len(nums)\n\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n      dp[i] = max(nums[i], dp[i - 1] + nums[i])\n\n    return max(dp)",
      "title": "53. Maximum Subarray_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "025604ee-4fdb-4ffc-8f8b-5c0e0148c89b",
      "code": "class Solution:\n  def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    # Repeatedly add matrix[r1..r2][c1..c2] to `ans`.\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans",
      "title": "54. Spiral Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca79a031-717f-445d-947c-0634b855c640",
      "code": "class Solution:\n  def canJump(self, nums: list[int]) -> bool:\n    i = 0\n    reach = 0\n\n    while i < len(nums) and i <= reach:\n      reach = max(reach, i + nums[i])\n      i += 1\n\n    return i == len(nums)",
      "title": "55. Jump Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f08c3f77-1f9c-408d-8ba6-646e85b02ca2",
      "code": "class Solution:\n  def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    for interval in sorted(intervals):\n      if not ans or ans[-1][1] < interval[0]:\n        ans.append(interval)\n      else:\n        ans[-1][1] = max(ans[-1][1], interval[1])\n\n    return ans",
      "title": "56. Merge Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaebc446-14d2-47b0-945b-02769d8deb3f",
      "code": "class Solution:\n  def insert(self, intervals: list[list[int]],\n             newInterval: list[int]) -> list[list[int]]:\n    n = len(intervals)\n    ans = []\n    i = 0\n\n    while i < n and intervals[i][1] < newInterval[0]:\n      ans.append(intervals[i])\n      i += 1\n\n    # Merge overlapping intervals.\n    while i < n and intervals[i][0] <= newInterval[1]:\n      newInterval[0] = min(newInterval[0], intervals[i][0])\n      newInterval[1] = max(newInterval[1], intervals[i][1])\n      i += 1\n\n    ans.append(newInterval)\n\n    while i < n:\n      ans.append(intervals[i])\n      i += 1\n\n    return ans",
      "title": "57. Insert Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eb7c3f2-6902-4e01-9bff-d7827e8377ed",
      "code": "class Solution:\n  def lengthOfLastWord(self, s: str) -> int:\n    i = len(s) - 1\n\n    while i >= 0 and s[i] == ' ':\n      i -= 1\n    lastIndex = i\n    while i >= 0 and s[i] != ' ':\n      i -= 1\n\n    return lastIndex - i",
      "title": "58. Length of Last Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7737d8ee-86ac-4bcf-9d4d-30d3c4dcc902",
      "code": "class Solution:\n  def generateMatrix(self, n: int) -> list[list[int]]:\n    ans = [[0] * n for _ in range(n)]\n    count = 1\n\n    for mn in range(n // 2):\n      mx = n - mn - 1\n      for i in range(mn, mx):\n        ans[mn][i] = count\n        count += 1\n      for i in range(mn, mx):\n        ans[i][mx] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[mx][i] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[i][mn] = count\n        count += 1\n\n    if n % 2 == 1:\n      ans[n // 2][n // 2] = count\n\n    return ans",
      "title": "59. Spiral Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "201ac450-b100-4572-8ae6-08290d45c6a6",
      "code": "class Solution:\n  def getPermutation(self, n: int, k: int) -> str:\n    ans = ''\n    nums = [i + 1 for i in range(n)]\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = fact[i - 1] * i\n\n    k -= 1  # 0-indexed\n\n    for i in reversed(range(n)):\n      j = k // fact[i]\n      k %= fact[i]\n      ans += str(nums[j])\n      nums.pop(j)\n\n    return ans",
      "title": "60. Permutation Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2853fd00-e3f6-47a9-9c7d-5cfebae4a9b5",
      "code": "class Solution:\n  def rotateRight(self, head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n      return head\n\n    tail = head\n    length = 1\n    while tail.next:\n      tail = tail.next\n      length += 1\n    tail.next = head  # Circle the list.\n\n    t = length - k % length\n    for _ in range(t):\n      tail = tail.next\n    newHead = tail.next\n    tail.next = None\n\n    return newHead",
      "title": "61. Rotate List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20d078d6-51c0-4a58-9aa7-4e9dc52af104",
      "code": "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]",
      "title": "62. Unique Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11855ed8-1a5c-435e-8b15-db8dbd271e29",
      "code": "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1  # Can also set dp[1][0] = 1.\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if obstacleGrid[i - 1][j - 1] == 0:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m][n]",
      "title": "63. Unique Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5623df2-7825-4bbb-98b4-06d5542996e0",
      "code": "class Solution:\n  def minPathSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if i > 0 and j > 0:\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        elif i > 0:\n          grid[i][0] += grid[i - 1][0]\n        elif j > 0:\n          grid[0][j] += grid[0][j - 1]\n\n    return grid[m - 1][n - 1]",
      "title": "64. Minimum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e29469dc-6238-4837-a9f8-7d60bb9daf51",
      "code": "class Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum",
      "title": "65. Valid Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1560bd2a-d12d-47cb-9500-5f94ecf15775",
      "code": "class Solution:\n  def plusOne(self, digits: list[int]) -> list[int]:\n    for i, d in reversed(list(enumerate(digits))):\n      if d < 9:\n        digits[i] += 1\n        return digits\n      digits[i] = 0\n\n    return [1] + digits",
      "title": "66. Plus One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9be81057-50b8-485c-bc34-0ab167e0c36b",
      "code": "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    ans = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      ans.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(reversed(ans))",
      "title": "67. Add Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b519032-d8f3-4479-b46b-27afc4d593a2",
      "code": "class Solution:\n  def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\n    ans = []\n    row = []\n    rowLetters = 0\n\n    for word in words:\n      # If we place the word in this row, it will exceed the maximum width.\n      # Therefore, we cannot put the word in this row and have to pad spaces\n      # for each word in this row.\n      if rowLetters + len(word) + len(row) > maxWidth:\n        for i in range(maxWidth - rowLetters):\n          row[i % (len(row) - 1 or 1)] += ' '\n        ans.append(''.join(row))\n        row = []\n        rowLetters = 0\n      row.append(word)\n      rowLetters += len(word)\n\n    return ans + [' '.join(row).ljust(maxWidth)]",
      "title": "68. Text Justification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29c67f1c-8b12-47f7-8acd-7e89f715b05a",
      "code": "class Solution:\n  def mySqrt(self, x: int) -> int:\n    return bisect.bisect_right(range(x + 1), x,\n                               key=lambda m: m * m) - 1",
      "title": "69. Sqrt(x)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fdb09a2-229d-4540-bd3c-9fac28876530",
      "code": "class Solution:\n  def climbStairs(self, n: int) -> int:\n    # dp[i] := the number of ways to climb to the i-th stair\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]",
      "title": "70. Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "423f9cda-c3ab-45bd-81af-d80b96e7ad6c",
      "code": "class Solution:\n  def simplifyPath(self, path: str) -> str:\n    stack = []\n\n    for str in path.split('/'):\n      if str in ('', '.'):\n        continue\n      if str == '..':\n        if stack:\n          stack.pop()\n      else:\n        stack.append(str)\n\n    return '/' + '/'.join(stack)",
      "title": "71. Simplify Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32b9c009-0b23-45ee-8c9c-0491d33578e2",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := the minimum number of operations to convert word1[0..i) to\n    # word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]",
      "title": "72. Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b46f7a6-d236-40d2-98df-510685b544ea",
      "code": "class Solution:\n  def setZeroes(self, matrix: list[list[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    # Store the information in the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    # Fill 0s for the matrix except the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    # Fill 0s for the first row if needed.\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    # Fill 0s for the first column if needed.\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0",
      "title": "73. Set Matrix Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8ed40a6-73a4-47d8-bf60-c7a7518f9e8f",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    if not matrix:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n    l = 0\n    r = m * n\n\n    while l < r:\n      mid = (l + r) // 2\n      i = mid // n\n      j = mid % n\n      if matrix[i][j] == target:\n        return True\n      if matrix[i][j] < target:\n        l = mid + 1\n      else:\n        r = mid\n\n    return False",
      "title": "74. Search a 2D Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0365c57-8240-4f95-a7e0-bf1c8be344b1",
      "code": "class Solution:\n  def sortColors(self, nums: list[int]) -> None:\n    l = 0  # The next 0 should be placed in l.\n    r = len(nums) - 1  # THe next 2 should be placed in r.\n\n    i = 0\n    while i <= r:\n      if nums[i] == 0:\n        nums[i], nums[l] = nums[l], nums[i]\n        i += 1\n        l += 1\n      elif nums[i] == 1:\n        i += 1\n      else:\n        # We may swap a 0 to index i, but we're still not sure whether this 0\n        # is placed in the correct index, so we can't move pointer i.\n        nums[i], nums[r] = nums[r], nums[i]\n        r -= 1",
      "title": "75. Sort Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f045b26e-7d64-4e42-a0cd-22f790af100b",
      "code": "class Solution:\n  def minWindow(self, s: str, t: str) -> str:\n    count = collections.Counter(t)\n    required = len(t)\n    bestLeft = -1\n    minLength = len(s) + 1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        count[s[l]] += 1\n        if count[s[l]] > 0:\n          required += 1\n        l += 1\n\n    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]",
      "title": "76. Minimum Window Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14c32f9c-7ff0-475b-9cdb-6ff3aa42a9a5",
      "code": "class Solution:\n  def combine(self, n: int, k: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) == k:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        path.append(i)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(1, [])\n    return ans",
      "title": "77. Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2e2bb2c-bca8-4f49-a34e-0e8b8e497d6d",
      "code": "class Solution:\n  def subsets(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n\n      for i in range(s, len(nums)):\n        dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "78. Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8f1a3fa-b88f-4177-b1ed-f940e88c74bb",
      "code": "class Solution:\n  def exist(self, board: list[list[str]], word: str) -> bool:\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int, s: int) -> bool:\n      if i < 0 or i == m or j < 0 or j == n:\n        return False\n      if board[i][j] != word[s] or board[i][j] == '*':\n        return False\n      if s == len(word) - 1:\n        return True\n\n      cache = board[i][j]\n      board[i][j] = '*'\n      isExist = (dfs(i + 1, j, s + 1) or\n                 dfs(i - 1, j, s + 1) or\n                 dfs(i, j + 1, s + 1) or\n                 dfs(i, j - 1, s + 1))\n      board[i][j] = cache\n\n      return isExist\n\n    return any(dfs(i, j, 0)\n               for i in range(m)\n               for j in range(n))",
      "title": "79. Word Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a8c1f30-f9d1-4bcf-9128-ce89109400a9",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 2 or num != nums[i - 2]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "80. Remove Duplicates from Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "430795e4-fd48-4da0-bfb2-55725510d7c4",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> bool:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return True\n      if nums[l] == nums[m] == nums[r]:\n        l += 1\n        r -= 1\n      elif nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return False",
      "title": "81. Search in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "517229d0-6b6a-44b1-9983-ceab153ee21f",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      while head.next and head.val == head.next.val:\n        head = head.next\n      if prev.next == head:\n        prev = prev.next\n      else:\n        prev.next = head.next\n      head = head.next\n\n    return dummy.next",
      "title": "82. Remove Duplicates from Sorted List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44f4edf1-1a94-4fce-a90b-18ca26cd874b",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    curr = head\n\n    while curr:\n      while curr.next and curr.val == curr.next.val:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return head",
      "title": "83. Remove Duplicates from Sorted List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1ca28ac-f52c-4c03-a554-5f57f296c381",
      "code": "class Solution:\n  def largestRectangleArea(self, heights: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(heights) + 1):\n      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n        h = heights[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans",
      "title": "84. Largest Rectangle in Histogram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6d42e00-fc27-447d-95d9-2af67fe4f41c",
      "code": "class Solution:\n  def maximalRectangle(self, matrix: list[list[str]]) -> int:\n    if not matrix:\n      return 0\n\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    def largestRectangleArea(heights: list[int]) -> int:\n      ans = 0\n      stack = []\n\n      for i in range(len(heights) + 1):\n        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n          h = heights[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n\n      return ans\n\n    for row in matrix:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == '0' else hist[i] + 1\n      ans = max(ans, largestRectangleArea(hist))\n\n    return ans",
      "title": "85. Maximal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d8394d0-5398-45e1-aa7d-f43558c12696",
      "code": "class Solution:\n  def partition(self, head: ListNode, x: int) -> ListNode:\n    beforeHead = ListNode(0)\n    afterHead = ListNode(0)\n    before = beforeHead\n    after = afterHead\n\n    while head:\n      if head.val < x:\n        before.next = head\n        before = head\n      else:\n        after.next = head\n        after = head\n      head = head.next\n\n    after.next = None\n    before.next = afterHead.next\n\n    return beforeHead.next",
      "title": "86. Partition List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68d59170-1843-465f-b068-c6b4a5b5dfe2",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def isScramble(self, s1: str, s2: str) -> bool:\n    if s1 == s2:\n      return True\n    if collections.Counter(s1) != collections.Counter(s2):\n      return False\n\n    for i in range(1, len(s1)):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if (self.isScramble(s1[:i], s2[len(s2) - i:]) and\n              self.isScramble(s1[i:], s2[: len(s2) - i])):\n        return True\n\n    return False",
      "title": "87. Scramble String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b172384d-b629-4dd3-b3af-4fefdf3f22d7",
      "code": "class Solution:\n  def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i = m - 1  # nums1's index (the actual nums)\n    j = n - 1  # nums2's index\n    k = m + n - 1  # nums1's index (the next filled position)\n\n    while j >= 0:\n      if i >= 0 and nums1[i] > nums2[j]:\n        nums1[k] = nums1[i]\n        k -= 1\n        i -= 1\n      else:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1",
      "title": "88. Merge Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09157de-8516-4049-a12e-bc7721bfb4c5",
      "code": "class Solution:\n  def grayCode(self, n: int) -> list[int]:\n    ans = [0]\n\n    for i in range(n):\n      for j in reversed(range(len(ans))):\n        ans.append(ans[j] | 1 << i)\n\n    return ans",
      "title": "89. Gray Code",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83695e87-8952-4e2f-9cf8-81ec8db2d999",
      "code": "class Solution:\n  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans",
      "title": "90. Subsets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e934a89f-caf0-4a29-aa56-01a74107db5a",
      "code": "class Solution:\n  def numDecodings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the number of ways to decode s[i..n)\n    dp = [0] * n + [1]\n\n    def isValid(a: str, b=None) -> bool:\n      if b:\n        return a == '1' or a == '2' and b < '7'\n      return a != '0'\n\n    if isValid(s[-1]):\n      dp[n - 1] = 1\n\n    for i in reversed(range(n - 1)):\n      if isValid(s[i]):\n        dp[i] += dp[i + 1]\n      if isValid(s[i], s[i + 1]):\n        dp[i] += dp[i + 2]\n\n    return dp[0]",
      "title": "91. Decode Ways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "906a5e5b-ff19-4056-a95d-3b019faa7797",
      "code": "class Solution:\n  def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n    if not head and m == n:\n      return head\n\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    for _ in range(m - 1):\n      prev = prev.next  # Point to the node before the sublist [m, n].\n\n    tail = prev.next  # Be the tail of the sublist [m, n].\n\n    # Reverse the sublist [m, n] one by one.\n    for _ in range(n - m):\n      cache = tail.next\n      tail.next = cache.next\n      cache.next = prev.next\n      prev.next = cache\n\n    return dummy.next",
      "title": "92. Reverse Linked List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdc4c12b-02cb-43b9-9163-2c764237f76a",
      "code": "class Solution:\n  def restoreIpAddresses(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(start: int, path: list[int]) -> None:\n      if len(path) == 4 and start == len(s):\n        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])\n        return\n      if len(path) == 4 or start == len(s):\n        return\n\n      for length in range(1, 4):\n        if start + length > len(s):\n          return  # out-of-bounds\n        if length > 1 and s[start] == '0':\n          return  # leading '0'\n        num = s[start: start + length]\n        if int(num) > 255:\n          return\n        dfs(start + length, path + [num])\n\n    dfs(0, [])\n    return ans",
      "title": "93. Restore IP Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07feb6b6-b68e-4f00-947c-a8bbd174f3ca",
      "code": "class Solution:\n  def inorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      ans.append(root.val)\n      root = root.right\n\n    return ans",
      "title": "94. Binary Tree Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd00940b-a1ab-4693-8988-fb8c0aeb6296",
      "code": "class Solution:\n  def generateTrees(self, n: int) -> list[TreeNode]:\n    if n == 0:\n      return []\n\n    def generateTrees(mn: int, mx: int) -> list[int | None]:\n      if mn > mx:\n        return [None]\n\n      ans = []\n\n      for i in range(mn, mx + 1):\n        for left in generateTrees(mn, i - 1):\n          for right in generateTrees(i + 1, mx):\n            ans.append(TreeNode(i))\n            ans[-1].left = left\n            ans[-1].right = right\n\n      return ans\n\n    return generateTrees(1, n)",
      "title": "95. Unique Binary Search Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79c12aac-9e73-45fd-abba-5febef02e0de",
      "code": "class Solution:\n  def numTrees(self, n: int) -> int:\n    # dp[i] := the number of unique BST's that store values 1..i\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]",
      "title": "96. Unique Binary Search Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50754af-6e86-4ac9-8ee6-21a13fd7040e",
      "code": "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    # s1[0..i) and s2[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or\n                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]",
      "title": "97. Interleaving String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43809cf7-d7bc-40ce-92f7-c509d288d342",
      "code": "class Solution:\n  def isValidBST(self, root: TreeNode | None) -> bool:\n    def isValidBST(root: TreeNode | None,\n                   minNode: TreeNode | None, maxNode: TreeNode | None) -> bool:\n      if not root:\n        return True\n      if minNode and root.val <= minNode.val:\n        return False\n      if maxNode and root.val >= maxNode.val:\n        return False\n\n      return (isValidBST(root.left, minNode, root) and\n              isValidBST(root.right, root, maxNode))\n\n    return isValidBST(root, None, None)",
      "title": "98. Validate Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18213318-9f9d-4e9f-a99e-e667fd78a814",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    pred = None\n    x = None  # the first wrong node\n    y = None  # the second wrong node\n\n    def findPredecessor(root: TreeNode | None) -> TreeNode | None:\n      pred = root.left\n      while pred.right and pred.right != root:\n        pred = pred.right\n      return pred\n\n    while root:\n      if root.left:\n        morrisPred = findPredecessor(root)\n        if morrisPred.right:\n          # The node has already been connected before.\n          # Start the main logic.\n          if pred and root.val < pred.val:\n            y = root\n            if not x:\n              x = pred\n          pred = root\n          # End of the main logic\n          morrisPred.right = None  # Break the connection.\n          root = root.right\n        else:\n          morrisPred.right = root  # Connect it.\n          root = root.left\n      else:\n        # Start the main logic.\n        if pred and root.val < pred.val:\n          y = root\n          if not x:\n            x = pred\n        pred = root\n        # End of the main logic.\n        root = root.right\n\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    swap(x, y)",
      "title": "99. Recover Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed939708-8332-47c8-87c8-dda8bb4c8dae",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n\n      if self.pred and root.val < self.pred.val:\n        self.y = root\n        if not self.x:\n          self.x = self.pred\n        else:\n          return\n      self.pred = root\n\n      inorder(root.right)\n\n    inorder(root)\n    swap(self.x, self.y)\n\n  pred = None\n  x = None  # the first wrong node\n  y = None  # the second wrong node",
      "title": "99. Recover Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "367a9e07-74e1-4d66-8b2c-5ffd5001df5d",
      "code": "class Solution:\n  def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\n    if not p or not q:\n      return p == q\n    return (p.val == q.val and\n            self.isSameTree(p.left, q.left) and\n            self.isSameTree(p.right, q.right))",
      "title": "100. Same Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87349fa4-bd1c-49a9-bf4a-ad06a6a6b2b6",
      "code": "class Solution:\n  def isSymmetric(self, root: TreeNode | None) -> bool:\n    def isSymmetric(p: TreeNode | None, q: TreeNode | None) -> bool:\n      if not p or not q:\n        return p == q\n      return (p.val == q.val and\n              isSymmetric(p.left, q.right) and\n              isSymmetric(p.right, q.left))\n\n    return isSymmetric(root, root)",
      "title": "101. Symmetric Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2de4d881-2557-4ee3-85e9-73dd2a2d9c83",
      "code": "class Solution:\n  def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans",
      "title": "102. Binary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d350ae27-63a7-4988-8d8d-5cbce6b7b3e8",
      "code": "class Solution:\n  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    dq = collections.deque([root])\n    isLeftToRight = True\n\n    while dq:\n      currLevel = []\n      for _ in range(len(dq)):\n        if isLeftToRight:\n          node = dq.popleft()\n          currLevel.append(node.val)\n          if node.left:\n            dq.append(node.left)\n          if node.right:\n            dq.append(node.right)\n        else:\n          node = dq.pop()\n          currLevel.append(node.val)\n          if node.right:\n            dq.appendleft(node.right)\n          if node.left:\n            dq.appendleft(node.left)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans",
      "title": "103. Binary Tree Zigzag Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47ee9aa1-4b1d-4bc6-8506-72db36204d21",
      "code": "class Solution:\n  def maxDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
      "title": "104. Maximum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7cf13a5-e044-4190-9a38-557c6a279563",
      "code": "class Solution:\n  def buildTree(\n      self,\n      preorder: list[int],\n      inorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        preStart: int,\n        preEnd: int,\n        inStart: int,\n        inEnd: int,\n    ) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n\n      rootVal = preorder[preStart]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        inStart, rootInIndex - 1)\n      root.right = build(preStart + leftSize + 1,\n                         preEnd, rootInIndex + 1, inEnd)\n      return root\n\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
      "title": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2aac25b-3aed-42eb-b922-84408d8f758c",
      "code": "class Solution:\n  def buildTree(\n      self,\n      inorder: list[int],\n      postorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        inStart: int,\n        inEnd: int,\n        postStart: int,\n        postEnd: int,\n    ) -> TreeNode | None:\n      if inStart > inEnd:\n        return None\n\n      rootVal = postorder[postEnd]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(inStart, rootInIndex - 1,  postStart,\n                        postStart + leftSize - 1)\n      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,\n                         postEnd - 1)\n      return root\n\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)",
      "title": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598e6b6d-6bd7-4e65-9c6c-b00fe02c73bd",
      "code": "class Solution:\n  def levelOrderBottom(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans[::-1]",
      "title": "107. Binary Tree Level Order Traversal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c815dfaa-eab4-49f8-93f3-24d437d58ebb",
      "code": "class Solution:\n  def sortedArrayToBST(self, nums: list[int]) -> TreeNode | None:\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "108. Convert Sorted Array to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f2c2812-cfde-4d8c-af45-ef8889a1c53d",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\n    def helper(l: int, r: int) -> TreeNode | None:\n      nonlocal head\n      if l > r:\n        return None\n\n      m = (l + r) // 2\n\n      # Simulate inorder traversal: recursively form the left half.\n      left = helper(l, m - 1)\n\n      # Once the left half is traversed, process the current node.\n      root = TreeNode(head.val)\n      root.left = left\n\n      # Maintain the invariance.\n      head = head.next\n\n      # Simulate inorder traversal: recursively form the right half.\n      root.right = helper(m + 1, r)\n      return root\n\n    return helper(0, self._getLength(head) - 1)\n\n  def _getLength(self, head: ListNode | None) -> int:\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n    return length",
      "title": "109. Convert Sorted List to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a49157f-7c60-4813-b8c3-878e3590f3af",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n    def findMid(head: ListNode) -> ListNode:\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    if not head:\n      return None\n    if not head.next:\n      return TreeNode(head.val)\n\n    mid = findMid(head)\n    root = TreeNode(mid.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(mid.next)\n    return root",
      "title": "109. Convert Sorted List to Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caa3402e-330e-4f27-99e5-2f3fb04c8a54",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    def maxDepth(root: TreeNode | None) -> int:\n      \"\"\"Returns the height of root if root is balanced; otherwise, returns -1.\"\"\"\n      if not root:\n        return 0\n\n      left = maxDepth(root.left)\n      if left == -1:\n        return -1\n      right = maxDepth(root.right)\n      if right == -1:\n        return -1\n      if abs(left - right) > 1:\n        return -1\n\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return maxDepth(root) != -1",
      "title": "110. Balanced Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53bba931-d3f6-4a0b-a229-6828e8e5f36d",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n\n    def maxDepth(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return (abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and\n            self.isBalanced(root.left) and\n            self.isBalanced(root.right))",
      "title": "110. Balanced Binary Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43d1cad2-1ee5-49ed-a9d7-0710bd9a5b9a",
      "code": "class Solution:\n  def minDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    q = collections.deque([root])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        node = q.popleft()\n        if not node.left and not node.right:\n          return step\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      step += 1",
      "title": "111. Minimum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15426c86-41bd-4f16-8637-c35b3346baea",
      "code": "class Solution:\n  def hasPathSum(self, root: TreeNode, summ: int) -> bool:\n    if not root:\n      return False\n    if root.val == summ and not root.left and not root.right:\n      return True\n    return (self.hasPathSum(root.left, summ - root.val) or\n            self.hasPathSum(root.right, summ - root.val))",
      "title": "112. Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eeddc1b5-956c-430b-88df-e59fef09264c",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(root: TreeNode, summ: int, path: list[int]) -> None:\n      if not root:\n        return\n      if root.val == summ and not root.left and not root.right:\n        ans.append(path + [root.val])\n        return\n\n      dfs(root.left, summ - root.val, path + [root.val])\n      dfs(root.right, summ - root.val, path + [root.val])\n\n    dfs(root, summ, [])\n    return ans",
      "title": "113. Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "803f808b-83bf-4861-88b0-6304570d4f25",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb70b9ed-157e-4a61-b55f-23329009675c",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4a95f49-9933-47b3-8fbb-dffbf627aa86",
      "code": "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n      dp[i][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]",
      "title": "115. Distinct Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9c074bb-0ee8-4ae1-b8fb-09568d4e642c",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node and node.left:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        needle.next = node.left\n        needle = needle.next\n        needle.next = node.right\n        needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "116. Populating Next Right Pointers in Each Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4997c447-5ec1-46c6-8540-9aa34aa03dc8",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        if node.left:  # Needle the left child.\n          needle.next = node.left\n          needle = needle.next\n        if node.right:  # Needle the right child.\n          needle.next = node.right\n          needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "117. Populating Next Right Pointers in Each Node II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "392068ec-509e-475c-a33d-4278fb793a8c",
      "code": "class Solution:\n  def generate(self, numRows: int) -> list[list[int]]:\n    ans = []\n\n    for i in range(numRows):\n      ans.append([1] * (i + 1))\n\n    for i in range(2, numRows):\n      for j in range(1, len(ans[i]) - 1):\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]\n\n    return ans",
      "title": "118. Pascal's Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1918292b-eb43-45d4-950d-97bff75aaaf8",
      "code": "class Solution:\n  def getRow(self, rowIndex: int) -> list[int]:\n    ans = [1] * (rowIndex + 1)\n\n    for i in range(2, rowIndex + 1):\n      for j in range(1, i):\n        ans[i - j] += ans[i - j - 1]\n\n    return ans",
      "title": "119. Pascal's Triangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "840751f8-836b-46fc-bdb6-a98b9608a16f",
      "code": "class Solution:\n  def minimumTotal(self, triangle: list[list[int]]) -> int:\n    for i in range(len(triangle) - 2, -1, -1):\n      for j in range(i + 1):\n        triangle[i][j] += min(triangle[i + 1][j],\n                              triangle[i + 1][j + 1])\n\n    return triangle[0][0]",
      "title": "120. Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d81f099f-b961-4d11-8f0c-10ea0cf96af7",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellOne",
      "title": "121. Best Time to Buy and Sell Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e7e64f9-33c5-46be-acbd-49e67b709856",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price)\n\n    return sell",
      "title": "122. Best Time to Buy and Sell Stock II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3b2c9e8-9152-4191-908e-e21573c2e590",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellTwo = 0\n    holdTwo = -math.inf\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellTwo = max(sellTwo, holdTwo + price)\n      holdTwo = max(holdTwo, sellOne - price)\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellTwo",
      "title": "123. Best Time to Buy and Sell Stock III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80518463-6df2-42ca-9ba0-627c58324913",
      "code": "class Solution:\n  def maxPathSum(self, root: TreeNode | None) -> int:\n    ans = -math.inf\n\n    def maxPathSumDownFrom(root: TreeNode | None) -> int:\n      \"\"\"\n      Returns the maximum path sum starting from the current root, where\n      root.val is always included.\n      \"\"\"\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = max(0, maxPathSumDownFrom(root.left))\n      r = max(0, maxPathSumDownFrom(root.right))\n      ans = max(ans, root.val + l + r)\n      return root.val + max(l, r)\n\n    maxPathSumDownFrom(root)\n    return ans",
      "title": "124. Binary Tree Maximum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e30e933-8130-46dc-9ac4-372b969e2c27",
      "code": "class Solution:\n  def isPalindrome(self, s: str) -> bool:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and not s[l].isalnum():\n        l += 1\n      while l < r and not s[r].isalnum():\n        r -= 1\n      if s[l].lower() != s[r].lower():\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "125. Valid Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1397ae60-84c6-4235-b55f-93953d8bc572",
      "code": "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: dict[str, list[str]] = collections.defaultdict(list)\n\n    # Build the graph from the beginWord to the endWord.\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordSet: set[str],\n      graph: dict[str, list[str]],\n  ) -> bool:\n    q1 = {beginWord}\n    q2 = {endWord}\n    backward = False\n\n    while q1 and q2:\n      for word in q1:\n        wordSet.discard(word)\n      for word in q2:\n        wordSet.discard(word)\n      # Always expand the smaller queue.\n      if len(q1) > len(q2):\n        q1, q2 = q2, q1\n        backward = not backward\n      q = set()\n      reachEndWord = False\n      for parent in q1:\n        for child in self._getChildren(parent, wordSet, q2):\n          if child in wordSet or child in q2:\n            q.add(child)\n            if backward:\n              graph[child].append(parent)\n            else:\n              graph[parent].append(child)\n          if child in q2:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      q1 = q\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: set[str], q2) -> list[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet or child in q2:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(\n      self,\n      graph: dict[str, list[str]],\n      word: str,\n      endWord: str,\n      path: list[str],\n      ans: list[list[str]],\n  ) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()",
      "title": "126. Word Ladder II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a8ef7f9-d826-48f9-b753-8d6eefdbe483",
      "code": "class Solution:\n  def ladderLength(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordList: list[str],\n  ) -> int:\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n      return 0\n\n    q = collections.deque([beginWord])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for i, cache in enumerate(wordList):\n          for c in string.ascii_lowercase:\n            wordList[i] = c\n            word = ''.join(wordList)\n            if word == endWord:\n              return step + 1\n            if word in wordSet:\n              q.append(word)\n              wordSet.remove(word)\n          wordList[i] = cache\n      step += 1\n\n    return 0",
      "title": "127. Word Ladder",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2516a5b-2520-4f3e-9a4d-9016a8831131",
      "code": "class Solution:\n  def longestConsecutive(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set(nums)\n\n    for num in seen:\n      # `num` is the start of a sequence.\n      if num - 1 in seen:\n        continue\n      length = 0\n      while num in seen:\n        num += 1\n        length += 1\n      ans = max(ans, length)\n\n    return ans",
      "title": "128. Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02e238b0-f986-4a4f-a639-0f415d0df5c8",
      "code": "class Solution:\n  def sumNumbers(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans += path * 10 + root.val\n        return\n\n      dfs(root.left, path * 10 + root.val)\n      dfs(root.right, path * 10 + root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "129. Sum Root to Leaf Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dcd7f2c-92e0-4e49-87d2-0750e89f5d02",
      "code": "class Solution:\n  def solve(self, board: list[list[str]]) -> None:\n    if not board:\n      return\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark the grids that stretch from the four sides with '*'.\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'",
      "title": "130. Surrounded Regions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ee5986a-b573-4090-b3da-fd0ee1ebb7f6",
      "code": "class Solution:\n  def partition(self, s: str) -> list[list[str]]:\n    ans = []\n\n    def isPalindrome(s: str) -> bool:\n      return s == s[::-1]\n\n    def dfs(s: str, j: int, path: list[str], ans: list[list[str]]) -> None:\n      if j == len(s):\n        ans.append(path)\n        return\n\n      for i in range(j, len(s)):\n        if isPalindrome(s[j: i + 1]):\n          dfs(s, i + 1, path + [s[j: i + 1]], ans)\n\n    dfs(s, 0, [], ans)\n    return ans",
      "title": "131. Palindrome Partitioning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92dcc061-a978-4026-ac51-1bc9e4127226",
      "code": "class Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    # isPalindrome[i][j] := True if s[i..j] is a palindrome\n    isPalindrome = [[True] * n for _ in range(n)]\n    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      # Try all the possible partitions.\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]",
      "title": "132. Palindrome Partitioning II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41c060cd-8ddd-44fe-bb99-1949b0c63ace",
      "code": "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n\n    q = collections.deque([node])\n    map = {node: Node(node.val)}\n\n    while q:\n      u = q.popleft()\n      for v in u.neighbors:\n        if v not in map:\n          map[v] = Node(v.val)\n          q.append(v)\n        map[u].neighbors.append(map[v])\n\n    return map[node]",
      "title": "133. Clone Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4df4983c-9bf3-4c84-a50a-6afdbeb8e086",
      "code": "class Solution:\n  def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n    ans = 0\n    net = 0\n    summ = 0\n\n    # Try to start from each index.\n    for i in range(len(gas)):\n      net += gas[i] - cost[i]\n      summ += gas[i] - cost[i]\n      if summ < 0:\n        summ = 0\n        ans = i + 1  # Start from the next index.\n\n    return -1 if net < 0 else ans",
      "title": "134. Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e824aed6-f1f8-49ac-ae5a-9f0bcaa7bb9d",
      "code": "class Solution:\n  def candy(self, ratings: list[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans",
      "title": "135. Candy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "427522a0-3bf3-4e86-ab9d-489068b2167d",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums, 0)",
      "title": "136. Single Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5d4c655-3060-4720-9859-a2fbfae4c81a",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= (num & ~twos)\n      twos ^= (num & ~ones)\n\n    return ones",
      "title": "137. Single Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fe5f3a1-22fa-4823-9bb9-86d0c5d272e3",
      "code": "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}",
      "title": "138. Copy List with Random Pointer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56161786-0c19-4f0c-8e98-b4d60bb48955",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a7c2501-8f6a-45c5-8d17-8ea3a82ebaf1",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29d4a2bf-09a1-497a-bf68-14cfd42cd5ab",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> bool:\n      \"\"\"Returns True if s can be segmented.\"\"\"\n      if s in wordSet:\n        return True\n      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))\n\n    return wordBreak(s)",
      "title": "139. Word Break_3",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9992c4e-cc4f-4a78-8720-82a765b8edd4",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> list[str]:\n      ans = []\n\n      # 1 <= len(prefix) < len(s)\n      for i in range(1, len(s)):\n        prefix = s[:i]\n        suffix = s[i:]\n        if prefix in wordSet:\n          for word in wordBreak(suffix):\n            ans.append(prefix + ' ' + word)\n\n      # `wordSet` contains the whole string s, so don't add any space.\n      if s in wordSet:\n        ans.append(s)\n\n      return ans\n\n    return wordBreak(s)",
      "title": "140. Word Break II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c776fbb2-33c6-48ff-abe3-c3b124f9fcc8",
      "code": "class Solution:\n  def hasCycle(self, head: ListNode) -> bool:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        return True\n\n    return False",
      "title": "141. Linked List Cycle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35163b6c-b435-4c70-8f0f-0eedca34a157",
      "code": "class Solution:\n  def detectCycle(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        slow = head\n        while slow != fast:\n          slow = slow.next\n          fast = fast.next\n        return slow\n\n    return None",
      "title": "142. Linked List Cycle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e7c251-3787-4fb3-8153-612ab0efefae",
      "code": "class Solution:\n  def reorderList(self, head: ListNode) -> None:\n    def findMid(head: ListNode):\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    def reverse(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    def merge(l1: ListNode, l2: ListNode) -> None:\n      while l2:\n        next = l1.next\n        l1.next = l2\n        l1 = l2\n        l2 = next\n\n    if not head or not head.next:\n      return\n\n    mid = findMid(head)\n    reversed = reverse(mid)\n    merge(head, reversed)",
      "title": "143. Reorder List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6946f0bd-189f-4afa-b9fa-e6a674b7a5dd",
      "code": "class Solution:\n  def preorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.right:\n        stack.append(node.right)\n      if node.left:\n        stack.append(node.left)\n\n    return ans",
      "title": "144. Binary Tree Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "215817d6-3f45-460a-a48a-da3ae5fcc8bf",
      "code": "class Solution:\n  def postorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.left:\n        stack.append(node.left)\n      if node.right:\n        stack.append(node.right)\n\n    return ans[::-1]",
      "title": "145. Binary Tree Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9190cf30-1ec9-4130-8ad6-28826a627dcd",
      "code": "class Solution:\n  def insertionSortList(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0)\n    prev = dummy  # the last and thus largest of the sorted list\n\n    while head:  # the current inserting node\n      next = head.next  # Cache the next inserting node.\n      if prev.val >= head.val:\n        prev = dummy  # Move `prev` to the front.\n      while prev.next and prev.next.val < head.val:\n        prev = prev.next\n      head.next = prev.next\n      prev.next = head\n      head = next  # Update the current inserting node.\n\n    return dummy.next",
      "title": "147. Insertion Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed6125a8-cfce-4ed1-b54c-f19d8c8cb9de",
      "code": "class Solution:\n  def sortList(self, head: ListNode) -> ListNode:\n    def split(head: ListNode, k: int) -> ListNode:\n      while k > 1 and head:\n        head = head.next\n        k -= 1\n      rest = head.next if head else None\n      if head:\n        head.next = None\n      return rest\n\n    def merge(l1: ListNode, l2: ListNode) -> tuple:\n      dummy = ListNode(0)\n      tail = dummy\n\n      while l1 and l2:\n        if l1.val > l2.val:\n          l1, l2 = l2, l1\n        tail.next = l1\n        l1 = l1.next\n        tail = tail.next\n      tail.next = l1 if l1 else l2\n      while tail.next:\n        tail = tail.next\n\n      return dummy.next, tail\n\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n\n    dummy = ListNode(0, head)\n\n    k = 1\n    while k < length:\n      curr = dummy.next\n      tail = dummy\n      while curr:\n        l = curr\n        r = split(l, k)\n        curr = split(r, k)\n        mergedHead, mergedTail = merge(l, r)\n        tail.next = mergedHead\n        tail = mergedTail\n      k *= 2\n\n    return dummy.next",
      "title": "148. Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bcdf89d-c08a-4a70-9545-591051af4a80",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i, p in enumerate(points):\n      slopeCount = collections.defaultdict(int)\n      samePoints = 1\n      maxPoints = 0  # the maximum number of points with the same slope\n      for j in range(i + 1, len(points)):\n        q = points[j]\n        if p == q:\n          samePoints += 1\n        else:\n          slope = getSlope(p, q)\n          slopeCount[slope] += 1\n          maxPoints = max(maxPoints, slopeCount[slope])\n      ans = max(ans, samePoints + maxPoints)\n\n    return ans",
      "title": "149. Max Points on a Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3118b47-7c2f-496f-bad2-228d238e8d77",
      "code": "class Solution:\n  def evalRPN(self, tokens: list[str]) -> int:\n    stack = []\n    op = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n      if token in op:\n        b = stack.pop()\n        a = stack.pop()\n        stack.append(op[token](a, b))\n      else:\n        stack.append(int(token))\n\n    return stack.pop()",
      "title": "150. Evaluate Reverse Polish Notation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2103d048-2a86-4a16-835a-ec934fb67ff1",
      "code": "class Solution:\n  def reverseWords(self, s: str) -> str:\n    return ' '.join(reversed(s.split()))",
      "title": "151. Reverse Words in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75486c12-405d-4870-8796-aa37a4d03c29",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    ans = nums[0]\n    dpMin = nums[0]  # the minimum so far\n    dpMax = nums[0]  # the maximum so far\n\n    for i in range(1, len(nums)):\n      num = nums[i]\n      prevMin = dpMin  # dpMin[i - 1]\n      prevMax = dpMax  # dpMax[i - 1]\n      if num < 0:\n        dpMin = min(prevMax * num, num)\n        dpMax = max(prevMin * num, num)\n      else:\n        dpMin = min(prevMin * num, num)\n        dpMax = max(prevMax * num, num)\n\n      ans = max(ans, dpMax)\n\n    return ans",
      "title": "152. Maximum Product Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58a927dc-0e2a-4b9b-b720-5b7d57ca7289",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "153. Find Minimum in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e553e538-3422-4995-a98a-47b40fde777d",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == nums[r]:\n        r -= 1\n      elif nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "154. Find Minimum in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9797d966-54a5-4e43-b389-d9100b48227a",
      "code": "class Solution:\n  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    prevRoot = None\n    prevRightChild = None\n\n    while root:\n      nextRoot = root.left  # Cache the next root.\n      root.left = prevRightChild\n      prevRightChild = root.right\n      root.right = prevRoot\n      prevRoot = root  # Record the previous root.\n      root = nextRoot  # Update the root.\n\n    return prevRoot",
      "title": "156. Binary Tree Upside Down",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf5643a-2599-4baa-8cd3-f486d856d001",
      "code": "\"\"\"\nThe read4 API is already defined for you.\n  def read4(buf4: list[str]) -> int:\n\n# Below is an example of how the read4 API can be called.\nfile = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # Read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # Read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # Read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\n\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    buf4 = [' '] * 4\n    i4 = 0  # buf4's index\n    n4 = 0  # buf4's size\n    i = 0  # buf's index\n\n    while i < n:\n      if i4 == n4:  # All the characters in the buf4 are consumed.\n        i4 = 0  # Reset the buf4's index.\n        n4 = read4(buf4)  # Read <= 4 characters from the file to the buf4.\n        if n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = buf4[i4]\n      i += 1\n      i4 += 1\n\n    return i",
      "title": "157. Read N Characters Given Read4",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73d51f47-2dd2-4e4d-9d9f-394879647ec5",
      "code": "# The read4 API is already defined for you.\n# Def read4(buf4: list[str]) -> int:\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    i = 0  # buf's index\n\n    while i < n:\n      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.\n        self.i4 = 0  # Reset the buf4's index.\n        # Read <= 4 characters from the file to the buf4.\n        self.n4 = read4(self.buf4)\n        if self.n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = self.buf4[self.i4]\n      i += 1\n      self.i4 += 1\n\n    return i\n\n  buf4 = [' '] * 4\n  i4 = 0  # buf4's index\n  n4 = 0  # buf4's size",
      "title": "158. Read N Characters Given Read4 II - Call multiple times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4e1a8f6-83aa-42f4-8a83-6e18c9b3aacc",
      "code": "class Solution:\n  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n    ans = 0\n    distinct = 0\n    count = [0] * 128\n\n    l = 0\n    for r, c in enumerate(s):\n      count[ord(c)] += 1\n      if count[ord(c)] == 1:\n        distinct += 1\n      while distinct == 3:\n        count[ord(s[l])] -= 1\n        if count[ord(s[l])] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "159. Longest Substring with At Most Two Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce642b58-e4f7-4ced-bdd0-1c199efcf156",
      "code": "class Solution:\n  def getIntersectionNode(\n      self,\n      headA: ListNode,\n      headB: ListNode,\n  ) -> ListNode | None:\n    a = headA\n    b = headB\n\n    while a != b:\n      a = a.next if a else headB\n      b = b.next if b else headA\n\n    return a",
      "title": "160. Intersection of Two Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "106aa79b-78ff-425b-b8f4-ab87b55e4c15",
      "code": "class Solution:\n  def isOneEditDistance(self, s: str, t: str) -> bool:\n    m = len(s)\n    n = len(t)\n    if m > n:  # Make sure that |s| <= |t|.\n      return self.isOneEditDistance(t, s)\n\n    for i in range(m):\n      if s[i] != t[i]:\n        if m == n:\n          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].\n        return s[i:] == t[i + 1:]  # Delete t[i].\n\n    return m + 1 == n  # Delete t[-1].",
      "title": "161. One Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6762dce-6ef1-48aa-9753-e2064927d66f",
      "code": "class Solution:\n  def findPeakElement(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] >= nums[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "162. Find Peak Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1533615e-079e-4e11-8f11-c038ef81b472",
      "code": "class Solution:\n  def findMissingRanges(\n      self,\n      nums: list[int],\n      lower: int,\n      upper: int,\n  ) -> list[list[int]]:\n    def getRange(lo: int, hi: int) -> list[int]:\n      if lo == hi:\n        return [lo, lo]\n      return [lo, hi]\n\n    if not nums:\n      return [getRange(lower, upper)]\n\n    ans = []\n\n    if nums[0] > lower:\n      ans.append(getRange(lower, nums[0] - 1))\n\n    for prev, curr in zip(nums, nums[1:]):\n      if curr > prev + 1:\n        ans.append(getRange(prev + 1, curr - 1))\n\n    if nums[-1] < upper:\n      ans.append(getRange(nums[-1] + 1, upper))\n\n    return ans",
      "title": "163. Missing Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50670932-2a7e-4393-bbe3-3070c6f1f8ea",
      "code": "class Bucket:\n  def __init__(self, mn: int, mx: int):\n    self.mn = mn\n    self.mx = mx\n\n\nclass Solution:\n  def maximumGap(self, nums: list[int]) -> int:\n    if len(nums) < 2:\n      return 0\n\n    mn = min(nums)\n    mx = max(nums)\n    if mn == mx:\n      return 0\n\n    gap = math.ceil((mx - mn) / (len(nums) - 1))\n    bucketSize = (mx - mn) // gap + 1\n    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]\n\n    for num in nums:\n      i = (num - mn) // gap\n      buckets[i].mn = min(buckets[i].mn, num)\n      buckets[i].mx = max(buckets[i].mx, num)\n\n    ans = 0\n    prevMax = mn\n\n    for bucket in buckets:\n      if bucket.mn == math.inf:\n        continue  # empty bucket\n      ans = max(ans, bucket.mn - prevMax)\n      prevMax = bucket.mx\n\n    return ans",
      "title": "164. Maximum Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97cb9bb3-dfa6-4343-bae0-b1769ddb89da",
      "code": "class Solution:\n  def compareVersion(self, version1: str, version2: str) -> int:\n    levels1 = version1.split('.')\n    levels2 = version2.split('.')\n    length = max(len(levels1), len(levels2))\n\n    for i in range(length):\n      v1 = int(levels1[i]) if i < len(levels1) else 0\n      v2 = int(levels2[i]) if i < len(levels2) else 0\n      if v1 < v2:\n        return -1\n      if v1 > v2:\n        return 1\n\n    return 0",
      "title": "165. Compare Version Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a2b72f6-6dd3-482f-a317-8d8a5fde8184",
      "code": "class Solution:\n  def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n    if numerator == 0:\n      return '0'\n\n    ans = ''\n\n    if (numerator < 0) ^ (denominator < 0):\n      ans += '-'\n\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    ans += str(numerator // denominator)\n\n    if numerator % denominator == 0:\n      return ans\n\n    ans += '.'\n    dict = {}\n\n    remainder = numerator % denominator\n    while remainder:\n      if remainder in dict:\n        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'\n        break\n      dict[remainder] = len(ans)\n      remainder *= 10\n      ans += str(remainder // denominator)\n      remainder %= denominator\n\n    return ans",
      "title": "166. Fraction to Recurring Decimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eab41ae4-6829-4df4-8ed1-af2536b3a962",
      "code": "class Solution:\n  def twoSum(self, numbers: list[int], target: int) -> list[int]:\n    l = 0\n    r = len(numbers) - 1\n\n    while l < r:\n      summ = numbers[l] + numbers[r]\n      if summ == target:\n        return [l + 1, r + 1]\n      if summ < target:\n        l += 1\n      else:\n        r -= 1",
      "title": "167. Two Sum II - Input array is sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66c6d61b-01ab-4c34-a80f-2d686999812f",
      "code": "class Solution:\n  def convertToTitle(self, n: int) -> str:\n    return (self.convertToTitle((n - 1) // 26) + chr(ord('A') + (n - 1) % 26)\n            if n\n            else '')",
      "title": "168. Excel Sheet Column Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34de4c09-7c26-4471-a09b-0256d717482f",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> int:\n    ans = None\n    count = 0\n\n    for num in nums:\n      if count == 0:\n        ans = num\n      count += (1 if num == ans else -1)\n\n    return ans",
      "title": "169. Majority Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a7c3f53-308f-4089-bd73-f301f450fc6c",
      "code": "class Solution:\n  def titleToNumber(self, columnTitle: str) -> int:\n    return functools.reduce(lambda subtotal, c:\n                            subtotal * 26 + ord(c) - ord('@'), columnTitle, 0)",
      "title": "171. Excel Sheet Column Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "422f9cfa-5ef6-4036-ba68-1ad9124b0ea0",
      "code": "class Solution:\n  def trailingZeroes(self, n: int) -> int:\n    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)",
      "title": "172. Factorial Trailing Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09d83126-1d3a-478a-a7f9-dc23a556cdf5",
      "code": "class Solution:\n  def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:\n    m = len(dungeon)\n    n = len(dungeon[0])\n    dp = [math.inf] * (n + 1)\n    dp[n - 1] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]\n        dp[j] = max(dp[j], 1)\n\n    return dp[0]",
      "title": "174. Dungeon Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcb5c90c-553f-400e-b3b3-06f8a5de544f",
      "code": "class LargerStrKey(str):\n  def __lt__(x: str, y: str) -> bool:\n    return x + y > y + x\n\n\nclass Solution:\n  def largestNumber(self, nums: list[int]) -> str:\n    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'",
      "title": "179. Largest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4287b91-cac5-48f1-862f-1223edcdf390",
      "code": "class Solution:\n  def reverseWords(self, s: list[str]) -> None:\n    def reverse(l: int, r: int) -> None:\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    def reverseWords(n: int) -> None:\n      i = 0\n      j = 0\n\n      while i < n:\n        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.\n          i += 1\n        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.\n          j += 1\n        reverse(i, j - 1)  # Reverse the word.\n\n    reverse(0, len(s) - 1)  # Reverse the whole string.\n    reverseWords(len(s))  # Reverse each word.",
      "title": "186. Reverse Words in a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c714d52-a46c-457d-aca5-62c40685ac0b",
      "code": "class Solution:\n  def findRepeatedDnaSequences(self, s: str) -> list[str]:\n    ans = set()\n    seen = set()\n\n    for i in range(len(s) - 9):\n      seq = s[i:i + 10]\n      if seq in seen:\n        ans.add(seq)\n      seen.add(seq)\n\n    return list(ans)",
      "title": "187. Repeated DNA Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbf6fe46-ad6e-4de1-b948-15adddd65cda",
      "code": "class Solution:\n  def maxProfit(self, k: int, prices: list[int]) -> int:\n    if k >= len(prices) // 2:\n      sell = 0\n      hold = -math.inf\n\n      for price in prices:\n        sell = max(sell, hold + price)\n        hold = max(hold, sell - price)\n\n      return sell\n\n    sell = [0] * (k + 1)\n    hold = [-math.inf] * (k + 1)\n\n    for price in prices:\n      for i in range(k, 0, -1):\n        sell[i] = max(sell[i], hold[i] + price)\n        hold[i] = max(hold[i], sell[i - 1] - price)\n\n    return sell[k]",
      "title": "188. Best Time to Buy and Sell Stock IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76fa8afc-cb61-4b50-a60e-6e5dc9a765cd",
      "code": "class Solution:\n  def rotate(self, nums: list[int], k: int) -> None:\n    k %= len(nums)\n    self.reverse(nums, 0, len(nums) - 1)\n    self.reverse(nums, 0, k - 1)\n    self.reverse(nums, k, len(nums) - 1)\n\n  def reverse(self, nums: list[int], l: int, r: int) -> None:\n    while l < r:\n      nums[l], nums[r] = nums[r], nums[l]\n      l += 1\n      r -= 1",
      "title": "189. Rotate Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "664f5f70-bc87-4fa2-a351-ab652e435d8f",
      "code": "class Solution:\n  def reverseBits(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if n >> i & 1:\n        ans |= 1 << 31 - i\n\n    return ans",
      "title": "190. Reverse Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddfa0763-d7dd-494d-804d-42f26a1729e3",
      "code": "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if (n >> i) & 1:\n        ans += 1\n\n    return ans",
      "title": "191. Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945e8531-ae2e-4bd9-b741-9ac0e19727ca",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) == 1:\n      return nums[0]\n\n    # dp[i]:= max money of robbing nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]",
      "title": "198. House Robber",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6a94c50-bf9d-4b38-af70-11c205487dc2",
      "code": "class Solution:\n  def rightSideView(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      size = len(q)\n      for i in range(size):\n        root = q.popleft()\n        if i == size - 1:\n          ans.append(root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n\n    return ans",
      "title": "199. Binary Tree Right Side View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d0dd5e-9fc3-4bd7-9330-cf6f16bff2f8",
      "code": "class Solution:\n  def numIslands(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def bfs(r, c):\n      q = collections.deque([(r, c)])\n      grid[r][c] = '2'  # Mark '2' as visited.\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] != '1':\n            continue\n          q.append((x, y))\n          grid[x][y] = '2'  # Mark '2' as visited.\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          bfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "200. Number of Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2402336-f166-4e13-9d5a-5a68fd36c952",
      "code": "class Solution:\n  def rangeBitwiseAnd(self, m: int, n: int) -> int:\n    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m",
      "title": "201. Bitwise AND of Numbers Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dd011e1-c8e1-4091-95d1-e15e7e5ecb6a",
      "code": "class Solution:\n  def isHappy(self, n: int) -> bool:\n    def squaredSum(n: int) -> bool:\n      summ = 0\n      while n > 0:\n        summ += pow(n % 10, 2)\n        n //= 10\n      return summ\n\n    slow = squaredSum(n)\n    fast = squaredSum(squaredSum(n))\n\n    while slow != fast:\n      slow = squaredSum(slow)\n      fast = squaredSum(squaredSum(fast))\n\n    return slow == 1",
      "title": "202. Happy Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dc07bf9-2e37-4d27-bac3-d220c46d1738",
      "code": "class Solution:\n  def removeElements(self, head: ListNode, val: int) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      if head.val != val:\n        prev.next = head\n        prev = prev.next\n      head = head.next\n    prev.next = None\n\n    return dummy.next",
      "title": "203. Remove Linked List Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea26c7ef-09dd-4210-835e-e194b82f06dc",
      "code": "class Solution:\n  def countPrimes(self, n: int) -> int:\n    if n <= 2:\n      return 0\n    return sum(self._sieveEratosthenes(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "204. Count Primes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "288f98fa-c6b6-4ff9-966a-30d2926679ab",
      "code": "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    return [*map(s.index, s)] == [*map(t.index, t)]",
      "title": "205. Isomorphic Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c1c4672-4e3f-41eb-829d-3b45bea547fe",
      "code": "class Solution:\n  def reverseList(self, head: ListNode | None) -> ListNode | None:\n    if not head or not head.next:\n      return head\n\n    newHead = self.reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return newHead",
      "title": "206. Reverse Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f3c0a6-0c2d-484f-bbfa-ed4b2da2966e",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not any(hasCycle(i) for i in range(numCourses))",
      "title": "207. Course Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9883339b-f5d6-44e0-976d-5bc72e219e1a",
      "code": "class Solution:\n  def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n    ans = math.inf\n    summ = 0\n    j = 0\n\n    for i, num in enumerate(nums):\n      summ += num\n      while summ >= target:\n        ans = min(ans, i - j + 1)\n        summ -= nums[j]\n        j += 1\n\n    return 0 if ans == math.inf else ans",
      "title": "209. Minimum Size Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b78c11f-8a02-4fb9-95d4-d82253bfed49",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def findOrder(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      ans.append(u)\n      return False\n\n    if any(hasCycle(i) for i in range(numCourses)):\n      return []\n\n    return ans[::-1]",
      "title": "210. Course Schedule II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fa99481-1383-45ef-b47e-76fc2d767f95",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n    m = len(board)\n    n = len(board[0])\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    for word in words:\n      insert(word)\n\n    def dfs(i: int, j: int, node: TrieNode) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] == '*':\n        return\n\n      c = board[i][j]\n      if c not in node.children:\n        return\n\n      child = node.children[c]\n      if child.word:\n        ans.append(child.word)\n        child.word = None\n\n      board[i][j] = '*'\n      dfs(i + 1, j, child)\n      dfs(i - 1, j, child)\n      dfs(i, j + 1, child)\n      dfs(i, j - 1, child)\n      board[i][j] = c\n\n    for i in range(m):\n      for j in range(n):\n        dfs(i, j, root)\n\n    return ans",
      "title": "212. Word Search II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f034317b-0f94-4756-9967-7a221085eb9b",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) < 2:\n      return nums[0]\n\n    def rob(l: int, r: int) -> int:\n      dp1 = 0\n      dp2 = 0\n\n      for i in range(l, r + 1):\n        temp = dp1\n        dp1 = max(dp1, dp2 + nums[i])\n        dp2 = temp\n\n      return dp1\n\n    return max(rob(0, len(nums) - 2),\n               rob(1, len(nums) - 1))",
      "title": "213. House Robber II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45fb8d2b-bcea-4f41-81b4-8fac3c03dc23",
      "code": "class Solution:\n  def shortestPalindrome(self, s: str) -> str:\n    t = s[::-1]\n\n    for i in range(len(t)):\n      if s.startswith(t[i:]):\n        return t[:i] + s\n\n    return t + s",
      "title": "214. Shortest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b72f869-9fe2-4ed5-bb86-b1d5dcc120f3",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "215. Kth Largest Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4221326d-6b9c-4420-9678-5fa838bf0b09",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, num)\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return minHeap[0]",
      "title": "215. Kth Largest Element in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "695c0525-4e14-4cf3-b48f-58469de8586a",
      "code": "class Solution:\n  def combinationSum3(self, k: int, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(k: int, n: int, s: int, path: list[int]) -> None:\n      if k == 0 and n == 0:\n        ans.append(path)\n        return\n      if k == 0 or n < 0:\n        return\n\n      for i in range(s, 10):\n        dfs(k - 1, n - i, i + 1, path + [i])\n\n    dfs(k, n, 1, [])\n    return ans",
      "title": "216. Combination Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2d79fcc-ce05-4681-87b3-77bd9a0761cf",
      "code": "class Solution:\n  def containsDuplicate(self, nums: list[int]) -> bool:\n    return len(nums) != len(set(nums))",
      "title": "217. Contains Duplicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad2fd495-1fd8-4c2e-a5bc-ba5f15223a90",
      "code": "class Solution:\n  def getSkyline(self, buildings: list[list[int]]) -> list[list[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: list[list[int]],\n             right: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # left's index\n    j = 0  # right's index\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      # Choose the powith smaller x\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]  # Update the ongoing `leftY`.\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]  # Update the ongoing `rightY`.\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: list[list[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])",
      "title": "218. The Skyline Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b14ab39f-a88a-4e05-84f0-2c0a62e0b21b",
      "code": "class Solution:\n  def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n    seen = set()\n\n    for i, num in enumerate(nums):\n      if i > k:\n        seen.remove(nums[i - k - 1])\n      if num in seen:\n        return True\n      seen.add(num)\n\n    return False",
      "title": "219. Contains Duplicate II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35656e97-e0e9-4bd5-9c6f-1a70a83f31a8",
      "code": "class Solution:\n  def containsNearbyAlmostDuplicate(\n      self,\n      nums: list[int],\n      indexDiff: int,\n      valueDiff: int,\n  ) -> bool:\n    if not nums or indexDiff <= 0 or valueDiff < 0:\n      return False\n\n    mn = min(nums)\n    diff = valueDiff + 1  # In case that `valueDiff` equals 0.\n    bucket = {}\n\n    def getKey(num: int) -> int:\n      return (num - mn) // diff\n\n    for i, num in enumerate(nums):\n      key = getKey(num)\n      if key in bucket:  # the current bucket\n        return True\n      # the left adjacent bucket\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\n        return True\n      # the right adjacent bucket\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\n        return True\n      bucket[key] = num\n      if i >= indexDiff:\n        del bucket[getKey(nums[i - indexDiff])]\n\n    return False",
      "title": "220. Contains Duplicate III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1696c6db-34b2-4431-9b86-35a8228596f4",
      "code": "class Solution:\n  def maximalSquare(self, matrix: list[list[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [0] * n\n    maxLength = 0\n    prev = 0  # dp[i - 1][j - 1]\n\n    for i in range(m):\n      for j in range(n):\n        cache = dp[j]\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[j] = min([prev, dp[j], dp[j - 1]]) + 1\n        maxLength = max(maxLength, dp[j])\n        prev = cache\n\n    return maxLength * maxLength",
      "title": "221. Maximal Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5103a98c-80d3-41e0-bb8a-cbccd1972e95",
      "code": "class Solution:\n  def countNodes(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    left = root\n    right = root\n    heightL = 0\n    heightR = 0\n\n    while left:\n      heightL += 1\n      left = left.left\n\n    while right:\n      heightR += 1\n      right = right.right\n\n    if heightL == heightR:  # `root` is a complete tree.\n      return pow(2, heightL) - 1\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)",
      "title": "222. Count Complete Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eaa45aeb-534a-415d-9bf1-3f98c69d0422",
      "code": "class Solution:\n  def computeArea(self,\n                  A: int, B: int, C: int, D: int,\n                  E: int, F: int, G: int, H: int) -> int:\n    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0\n    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y",
      "title": "223. Rectangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b2065cb-dff1-4119-9fa7-ed9e716725c3",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: the current environment's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + int(c)\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num",
      "title": "224. Basic Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d02b0ae-82f3-4a0b-a1a2-7d1030bc5d1a",
      "code": "class Solution:\n  def invertTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n\n    left = root.left\n    right = root.right\n    root.left = self.invertTree(right)\n    root.right = self.invertTree(left)\n    return root",
      "title": "226. Invert Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8024d60f-e364-4607-98a9-fe83e9dbfc98",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum",
      "title": "227. Basic Calculator II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57da6135-3073-444e-a268-b247847a0364",
      "code": "class Solution:\n  def summaryRanges(self, nums: list[int]) -> list[str]:\n    ans = []\n\n    i = 0\n    while i < len(nums):\n      begin = nums[i]\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n        i += 1\n      end = nums[i]\n      if begin == end:\n        ans.append(str(begin))\n      else:\n        ans.append(str(begin) + \"->\" + str(end))\n      i += 1\n\n    return ans",
      "title": "228. Summary Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c525ada7-6032-4426-8ccb-aa7ceed93fb0",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> list[int]:\n    ans1 = 0\n    ans2 = 1\n    count1 = 0\n    count2 = 0\n\n    for num in nums:\n      if num == ans1:\n        count1 += 1\n      elif num == ans2:\n        count2 += 1\n      elif count1 == 0:\n        ans1 = num\n        count1 = 1\n      elif count2 == 0:\n        ans2 = num\n        count2 = 1\n      else:\n        count1 -= 1\n        count2 -= 1\n\n    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]",
      "title": "229. Majority Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99edc922-069e-440c-8502-77ee27e9dc8f",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3df74e34-1006-4737-ac20-5e507f691f65",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a1d4bff-116c-40b4-8bb1-e8246912236c",
      "code": "class Solution:\n  def isPowerOfTwo(self, n: int) -> bool:\n    return n >= 0 and n.bit_count() == 1",
      "title": "231. Power of Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e3eb18-12b2-4888-ba02-2bcffa78f516",
      "code": "class Solution:\n  def countDigitOne(self, n: int) -> int:\n    ans = 0\n\n    pow10 = 1\n    while pow10 <= n:\n      divisor = pow10 * 10\n      quotient = n // divisor\n      remainder = n % divisor\n      if quotient > 0:\n        ans += quotient * pow10\n      if remainder >= pow10:\n        ans += min(remainder - pow10 + 1, pow10)\n      pow10 *= 10\n\n    return ans",
      "title": "233. Number of Digit One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "279bf1ed-2c41-45f4-8277-b7e51a250b5f",
      "code": "class Solution:\n  def isPalindrome(self, head: ListNode) -> bool:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n      return prev\n\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    if fast:\n      slow = slow.next\n    slow = reverseList(slow)\n\n    while slow:\n      if slow.val != head.val:\n        return False\n      slow = slow.next\n      head = head.next\n\n    return True",
      "title": "234. Palindrome Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afb4db38-d920-49f1-a42a-e4b12652e12e",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    if root.val > max(p.val, q.val):\n      return self.lowestCommonAncestor(root.left, p, q)\n    if root.val < min(p.val, q.val):\n      return self.lowestCommonAncestor(root.right, p, q)\n    return root",
      "title": "235. Lowest Common Ancestor of a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e188cf9-5928-4be0-872c-ce4ed53481b7",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n      q: TreeNode | None,\n  ) -> TreeNode | None:\n    q_ = collections.deque([root])\n    parent = {root: None}\n    ancestors = set()  # p's ancestors\n\n    # Iterate until we find both p and q.\n    while p not in parent or q not in parent:\n      root = q_.popleft()\n      if root.left:\n        parent[root.left] = root\n        q_.append(root.left)\n      if root.right:\n        parent[root.right] = root\n        q_.append(root.right)\n\n    # Insert all the p's ancestors.\n    while p:\n      ancestors.add(p)\n      p = parent[p]  # `p` becomes None in the end.\n\n    # Go up from q until we meet any of p's ancestors.\n    while q not in ancestors:\n      q = parent[q]\n\n    return q",
      "title": "236. Lowest Common Ancestor of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c2ae697-eb5a-4ab7-b856-8cf6e2fc7705",
      "code": "class Solution:\n  def deleteNode(self, node):\n    node.val = node.next.val\n    node.next = node.next.next",
      "title": "237. Delete Node in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bff05e85-1cf9-4173-a051-f447476c01fc",
      "code": "class Solution:\n  def productExceptSelf(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    prefix = [1] * n  # prefix product\n    suffix = [1] * n  # suffix product\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] * nums[i - 1]\n\n    for i in reversed(range(n - 1)):\n      suffix[i] = suffix[i + 1] * nums[i + 1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]",
      "title": "238. Product of Array Except Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "233e6514-699e-43d5-92d0-15e8d2773b66",
      "code": "class Solution:\n  def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    maxQ = collections.deque()\n\n    for i, num in enumerate(nums):\n      while maxQ and maxQ[-1] < num:\n        maxQ.pop()\n      maxQ.append(num)\n      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds\n        maxQ.popleft()\n      if i >= k - 1:\n        ans.append(maxQ[0])\n\n    return ans",
      "title": "239. Sliding Window Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c27d36ec-e669-4920-b256-7d2991e633a9",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    r = 0\n    c = len(matrix[0]) - 1\n\n    while r < len(matrix) and c >= 0:\n      if matrix[r][c] == target:\n        return True\n      if target < matrix[r][c]:\n        c -= 1\n      else:\n        r += 1\n\n    return False",
      "title": "240. Search a 2D Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce9f8a27-a84c-476c-87d1-c76bee5c2c6f",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def diffWaysToCompute(self, expression: str) -> list[int]:\n    ans = []\n\n    for i, c in enumerate(expression):\n      if c in '+-*':\n        for a in self.diffWaysToCompute(expression[:i]):\n          for b in self.diffWaysToCompute(expression[i + 1:]):\n            ans.append(eval(str(a) + c + str(b)))\n\n    return ans or [int(expression)]",
      "title": "241. Different Ways to Add Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb004fc2-edbc-47ec-9c0a-bc6e0edaf1a4",
      "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return all(freq == 0 for freq in count.values())",
      "title": "242. Valid Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "437a0a6a-90be-4876-8e74-59965d95ba6e",
      "code": "class Solution:\n  def shortestDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    ans = len(wordsDict)\n    index1 = -1  # wordsdict[index1] == word1\n    index2 = -1  # wordsdict[index2] == word2\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        index1 = i\n        if index2 != -1:\n          ans = min(ans, index1 - index2)\n      if word == word2:\n        index2 = i\n        if index1 != -1:\n          ans = min(ans, index2 - index1)\n\n    return ans",
      "title": "243. Shortest Word Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae76f03-18f8-42be-bd77-8335921e5d99",
      "code": "class Solution:\n  def shortestWordDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    isSame = word1 == word2\n    ans = math.inf\n    # If word1 == word2, index1 is the newest index.\n    index1 = len(wordsDict)\n    # If word1 == word2, index2 is the previous index.\n    index2 = -len(wordsDict)\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        if isSame:\n          index2 = index1\n        index1 = i\n      elif word == word2:\n        index2 = i\n      ans = min(ans, abs(index1 - index2))\n\n    return ans",
      "title": "245. Shortest Word Distance III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9845f677-2658-4e65-9251-9ad8cfa008eb",
      "code": "class Solution:\n  def isStrobogrammatic(self, num: str) -> bool:\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    l = 0\n    r = len(num) - 1\n\n    while l <= r:\n      if num[r] not in rotated:\n        return False\n      if num[l] != rotated[num[r]]:\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "246. Strobogrammatic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c73eb70-554c-4484-97d8-aaf0df1b4442",
      "code": "class Solution:\n  def findStrobogrammatic(self, n: int) -> list[str]:\n    def helper(n: int, k: int) -> list[str]:\n      if n == 0:\n        return ['']\n      if n == 1:\n        return ['0', '1', '8']\n\n      ans = []\n\n      for inner in helper(n - 2, k):\n        if n < k:\n          ans.append('0' + inner + '0')\n        ans.append('1' + inner + '1')\n        ans.append('6' + inner + '9')\n        ans.append('8' + inner + '8')\n        ans.append('9' + inner + '6')\n\n      return ans\n\n    return helper(n, n)",
      "title": "247. Strobogrammatic Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c67a9835-59a5-4eee-bb3d-74cabeb14d6f",
      "code": "class Solution:\n  def strobogrammaticInRange(self, low: str, high: str) -> int:\n    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]\n    ans = 0\n\n    def dfs(s: list[str], l: int, r: int) -> None:\n      nonlocal ans\n      if l > r:\n        if len(s) == len(low) and ''.join(s) < low:\n          return\n        if len(s) == len(high) and ''.join(s) > high:\n          return\n        ans += 1\n        return\n\n      for leftDigit, rightDigit in pairs:\n        if l == r and leftDigit != rightDigit:\n          continue\n        s[l] = leftDigit\n        s[r] = rightDigit\n        if len(s) > 1 and s[0] == '0':\n          continue\n        dfs(s, l + 1, r - 1)\n\n    for n in range(len(low), len(high) + 1):\n      dfs([' '] * n, 0, n - 1)\n\n    return ans",
      "title": "248. Strobogrammatic Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15c9167c-b2ca-4b14-be92-60aa8e0ee059",
      "code": "class Solution:\n  def groupStrings(self, strings: list[str]) -> list[list[str]]:\n    keyToStrings = collections.defaultdict(list)\n\n    def getKey(s: str) -> str:\n      \"\"\"\n      Returns the key of 's' by pairwise calculation of differences.\n      e.g. getKey(\"abc\") -> \"1,1\" because diff(a, b) = 1 and diff(b, c) = 1.\n      \"\"\"\n      diffs = []\n\n      for i in range(1, len(s)):\n        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26\n        diffs.append(str(diff))\n\n      return ','.join(diffs)\n\n    for s in strings:\n      keyToStrings[getKey(s)].append(s)\n\n    return keyToStrings.values()",
      "title": "249. Group Shifted Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50a22a84-11c2-4b05-94a4-0d488bcc874e",
      "code": "class Solution:\n  def countUnivalSubtrees(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def isUnival(root: TreeNode | None, val: int) -> bool:\n      nonlocal ans\n      if not root:\n        return True\n\n      if isUnival(root.left, root.val) & isUnival(root.right, root.val):\n        ans += 1\n        return root.val == val\n\n      return False\n\n    isUnival(root, math.inf)\n    return ans",
      "title": "250. Count Univalue Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bbead22-67cd-49f6-ac1e-aeaa8a16860d",
      "code": "class Solution:\n  def canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n      if intervals[i - 1][1] > intervals[i][0]:\n        return False\n\n    return True",
      "title": "252. Meeting Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7effda12-ef3f-4dcc-aefe-3c331d60f7e1",
      "code": "class Solution:\n  def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n    n = len(intervals)\n    ans = 0\n    starts = []\n    ends = []\n\n    for start, end in intervals:\n      starts.append(start)\n      ends.append(end)\n\n    starts.sort()\n    ends.sort()\n\n    j = 0\n    for i in range(n):\n      if starts[i] < ends[j]:\n        ans += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "253. Meeting Rooms II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0278197f-6431-42af-8906-cc3882a8b267",
      "code": "class Solution:\n  def getFactors(self, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(n: int, s: int, path: list[int]) -> None:\n      if n <= 1:\n        if len(path) > 1:\n          ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        if n % i == 0:\n          path.append(i)\n          dfs(n // i, i, path)\n          path.pop()\n\n    dfs(n, 2, [])  # The minimum factor is 2.\n    return ans",
      "title": "254. Factor Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2b2c8fd-1c68-4ca8-9b88-e384d87048f6",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f778186e-0aa1-45bc-8547-ff58573c5f20",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7de7baa-bb1e-441e-aedc-2d4c373e2c9d",
      "code": "class Solution:\n  def minCost(self, costs: list[list[int]]) -> list[list[int]]:\n    for i in range(1, len(costs)):\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n    return min(costs[-1])",
      "title": "256. Paint House",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a074e863-b12a-4967-bb68-0882063190db",
      "code": "class Solution:\n  def binaryTreePaths(self, root: TreeNode | None) -> list[str]:\n    ans = []\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans.append(''.join(path) + str(root.val))\n        return\n\n      path.append(str(root.val) + '->')\n      dfs(root.left, path)\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(root, [])\n    return ans",
      "title": "257. Binary Tree Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f87a94bb-bf27-4040-a5cc-b572d1824bf3",
      "code": "class Solution:\n  def addDigits(self, num: int) -> int:\n    return 0 if num == 0 else 1 + (num - 1) % 9",
      "title": "258. Add Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "712c44f9-071f-482f-a877-283da4a18274",
      "code": "class Solution:\n  def threeSumSmaller(self, nums: list[int], target: int) -> int:\n    if len(nums) < 3:\n      return 0\n\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        if nums[i] + nums[l] + nums[r] < target:\n          # (nums[i], nums[l], nums[r])\n          # (nums[i], nums[l], nums[r - 1])\n          # ...,\n          # (nums[i], nums[l], nums[l + 1])\n          ans += r - l\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "259. 3Sum Smaller",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06e2e02f-20da-4715-83e8-f8c3c8221dc0",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> list[int]:\n    xors = functools.reduce(operator.xor, nums)\n    lowbit = xors & -xors\n    ans = [0, 0]\n\n    # Seperate `nums` into two groups by `lowbit`.\n    for num in nums:\n      if num & lowbit:\n        ans[0] ^= num\n      else:\n        ans[1] ^= num\n\n    return ans",
      "title": "260. Single Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16284fe3-f3c4-446c-af29-7248327fb1b6",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validTree(self, n: int, edges: list[list[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count == 1",
      "title": "261. Graph Valid Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ed154fa-d1de-4eaf-859d-db802805e1d2",
      "code": "class Solution:\n  def isUgly(self, n: int) -> bool:\n    if n == 0:\n      return False\n\n    for prime in 2, 3, 5:\n      while n % prime == 0:\n        n //= prime\n\n    return n == 1",
      "title": "263. Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbe65846-de0f-47b8-8096-7e2e92c84bd8",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int) -> int:\n    nums = [1]\n    i2 = 0\n    i3 = 0\n    i5 = 0\n\n    while len(nums) < n:\n      next2 = nums[i2] * 2\n      next3 = nums[i3] * 3\n      next5 = nums[i5] * 5\n      next = min(next2, next3, next5)\n      if next == next2:\n        i2 += 1\n      if next == next3:\n        i3 += 1\n      if next == next5:\n        i5 += 1\n      nums.append(next)\n\n    return nums[-1]",
      "title": "264. Ugly Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36c4fb34-3625-408b-84d2-3711be39709d",
      "code": "class Solution:\n  def minCostII(self, costs: list[list[int]]) -> int:\n    prevIndex = -1  # the previous minimum index\n    prevMin1 = 0  # the minimum cost so far\n    prevMin2 = 0  # the second minimum cost so far\n\n    for cost in costs:  # O(n)\n      # the painted index that will achieve the minimum cost after painting the\n      # current house\n      index = -1\n      # the minimum cost after painting the current house\n      min1 = math.inf\n      # the second minimum cost after painting the current house\n      min2 = math.inf\n      for i, cst in enumerate(cost):   # O(k)\n        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)\n        if theCost < min1:\n          index = i\n          min2 = min1\n          min1 = theCost\n        elif theCost < min2:  # min1 <= theCost < min2\n          min2 = theCost\n\n      prevIndex = index\n      prevMin1 = min1\n      prevMin2 = min2\n\n    return prevMin1",
      "title": "265. Paint House II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64adc4a2-31bd-40f4-83a6-22ba8dd634ab",
      "code": "class Solution:\n  def canPermutePalindrome(self, s: str) -> bool:\n    seen = set()\n\n    for c in s:\n      if c in seen:\n        seen.remove(c)\n      else:\n        seen.add(c)\n\n    return len(seen) <= 1",
      "title": "266. Palindrome Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e67d4e13-4de4-40b1-8272-7d8fb8ffb7c9",
      "code": "class Solution:\n  def generatePalindromes(self, s: str) -> list[str]:\n    count = collections.Counter(s)\n\n    # Count odd ones.\n    odd = sum(value & 1 for value in count.values())\n\n    # Can't form any palindrome.\n    if odd > 1:\n      return []\n\n    ans = []\n    candidates = []\n    mid = ''\n\n    # Get the mid and the candidates characters.\n    for key, value in count.items():\n      if value % 2 == 1:\n        mid += key\n      for _ in range(value // 2):\n        candidates.append(key)\n\n    def dfs(used: list[bool], path: list[str]) -> None:\n      \"\"\"Generates all the unique palindromes from the candidates.\"\"\"\n      if len(path) == len(candidates):\n        ans.append(''.join(path) + mid + ''.join(reversed(path)))\n        return\n\n      for i, candidate in enumerate(candidates):\n        if used[i]:\n          continue\n        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(candidate)\n        dfs(used, path)\n        path.pop()\n        used[i] = False\n\n    # Backtrack to generate the ans strings.\n    dfs([False] * len(candidates), [])\n    return ans",
      "title": "267. Palindrome Permutation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70a692cf-8d03-4c4a-af0a-d797dfa3984f",
      "code": "class Solution:\n  def missingNumber(self, nums: list[int]) -> int:\n    ans = len(nums)\n\n    for i, num in enumerate(nums):\n      ans ^= i ^ num\n\n    return ans",
      "title": "268. Missing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "767aae46-2901-463e-b0c1-60cee8b5d792",
      "code": "class Solution:\n  def alienOrder(self, words: list[str]) -> str:\n    graph = {}\n    inDegrees = [0] * 26\n\n    self._buildGraph(graph, words, inDegrees)\n    return self._topology(graph, inDegrees)\n\n  def _buildGraph(\n      self,\n      graph: dict[str, set[str]],\n      words: list[str],\n      inDegrees: list[int],\n  ) -> None:\n    # Create a node for each character in each word.\n    for word in words:\n      for c in word:\n        if c not in graph:\n          graph[c] = set()\n\n    for first, second in zip(words, words[1:]):\n      length = min(len(first), len(second))\n      for j in range(length):\n        u = first[j]\n        v = second[j]\n        if u != v:\n          if v not in graph[u]:\n            graph[u].add(v)\n            inDegrees[ord(v) - ord('a')] += 1\n          break  # The order of characters after this are meaningless.\n        # First = 'ab', second = 'a' . invalid\n        if j == length - 1 and len(first) > len(second):\n          graph.clear()\n          return\n\n  def _topology(self, graph: dict[str, set[str]], inDegrees: list[int]) -> str:\n    s = ''\n    q = collections.deque()\n\n    for c in graph:\n      if inDegrees[ord(c) - ord('a')] == 0:\n        q.append(c)\n\n    while q:\n      u = q.pop()\n      s += u\n      for v in graph[u]:\n        inDegrees[ord(v) - ord('a')] -= 1\n        if inDegrees[ord(v) - ord('a')] == 0:\n          q.append(v)\n\n    # Words = ['z', 'x', 'y', 'x']\n    return s if len(s) == len(graph) else ''",
      "title": "269. Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93829a64-3b89-49b5-b69f-d580e9295ecd",
      "code": "class Solution:\n  def closestValue(self, root: TreeNode | None, target: float) -> int:\n    # If target < root.val, search the left subtree.\n    if target < root.val and root.left:\n      left = self.closestValue(root.left, target)\n      if abs(left - target) <= abs(root.val - target):\n        return left\n\n    # If target > root.val, search the right subtree.\n    if target > root.val and root.right:\n      right = self.closestValue(root.right, target)\n      if abs(right - target) < abs(root.val - target):\n        return right\n\n    return root.val",
      "title": "270. Closest Binary Search Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "913c5428-3ec9-4ab8-96a0-70bf349cbc30",
      "code": "class Solution:\n  def closestKValues(\n      self,\n      root: TreeNode | None,\n      target: float,\n      k: int,\n  ) -> list[int]:\n    dq = collections.deque()\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      dq.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    while len(dq) > k:\n      if abs(dq[0] - target) > abs(dq[-1] - target):\n        dq.popleft()\n      else:\n        dq.pop()\n\n    return list(dq)",
      "title": "272. Closest Binary Search Tree Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8470a994-da90-4893-a331-579efa8a8999",
      "code": "class Solution:\n  def numberToWords(self, num: int) -> str:\n    if num == 0:\n      return 'Zero'\n\n    belowTwenty = ['',        'One',       'Two',      'Three',\n                   'Four',    'Five',      'Six',      'Seven',\n                   'Eight',   'Nine',      'Ten',      'Eleven',\n                   'Twelve',  'Thirteen',  'Fourteen', 'Fifteen',\n                   'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n    tens = ['',      'Ten',   'Twenty',  'Thirty', 'Forty',\n            'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n\n    def helper(num: int) -> str:\n      if num < 20:\n        s = belowTwenty[num]\n      elif num < 100:\n        s = tens[num // 10] + ' ' + belowTwenty[num % 10]\n      elif num < 1000:\n        s = helper(num // 100) + ' Hundred ' + helper(num % 100)\n      elif num < 1000000:\n        s = helper(num // 1000) + ' Thousand ' + helper(num % 1000)\n      elif num < 1000000000:\n        s = helper(num // 1000000) + ' Million ' + helper(num % 1000000)\n      else:\n        s = helper(num // 1000000000) + ' Billion ' + helper(num % 1000000000)\n      return s.strip()\n\n    return helper(num)",
      "title": "273. Integer to English Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76c93dd1-dc92-4df3-a975-d17c239df8e7",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    accumulate = 0\n    count = [0] * (n + 1)\n\n    for citation in citations:\n      count[min(citation, n)] += 1\n\n    # To find the maximum h-index, loop from the back to the front.\n    # i := the candidate's h-index\n    for i, c in reversed(list(enumerate(count))):\n      accumulate += c\n      if accumulate >= i:\n        return i",
      "title": "274. H-Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a114f353-250c-4142-92bc-1d19005bd502",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    return n - bisect.bisect_left(range(n), n,\n                                  key=lambda m: citations[m] + m)",
      "title": "275. H-Index II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5b733cb-eb51-4c19-8f2b-68e137e1c0e6",
      "code": "class Solution:\n  def numWays(self, n: int, k: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return k\n    if n == 2:\n      return k * k\n\n    # dp[i] := the number of ways to pan posts with k colors\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]",
      "title": "276. Paint Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af650ea7-467e-4b4b-ac00-9862277eb779",
      "code": "# The knows API is already defined for you.\n# Returns a bool, whether a knows b\n# Def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n  def findCelebrity(self, n: int) -> int:\n    candidate = 0\n\n    # Everyone knows the celebrity.\n    for i in range(1, n):\n      if knows(candidate, i):\n        candidate = i\n\n    # The candidate knows nobody and everyone knows the celebrity.\n    for i in range(n):\n      if i < candidate and knows(candidate, i) or not knows(i, candidate):\n        return -1\n      if i > candidate and not knows(i, candidate):\n        return -1\n\n    return candidate",
      "title": "277. Find the Celebrity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52878086-6d33-4861-af43-310e7691a9e4",
      "code": "class Solution:\n  def firstBadVersion(self, n: int) -> int:\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r) >> 1\n      if isBadVersion(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "278. First Bad Version",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c231ef8a-35f5-4989-992f-3dec996cf5a4",
      "code": "class Solution:\n  def numSquares(self, n: int) -> int:\n    dp = [n] * (n + 1)  # 1^2 x n\n    dp[0] = 0  # no way\n    dp[1] = 1  # 1^2\n\n    for i in range(2, n + 1):\n      j = 1\n      while j * j <= i:\n        dp[i] = min(dp[i], dp[i - j * j] + 1)\n        j += 1\n\n    return dp[n]",
      "title": "279. Perfect Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f5f6759-5fb7-47c7-a714-df8beea42d0a",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    # 1. If i is even, then nums[i] <= nums[i - 1].\n    # 2. If i is odd, then nums[i] >= nums[i - 1].\n    for i in range(1, len(nums)):\n      if (i % 2 == 0 and nums[i] > nums[i - 1] or\n              i % 2 == 1 and nums[i] < nums[i - 1]):\n        nums[i], nums[i - 1] = nums[i - 1], nums[i]",
      "title": "280. Wiggle Sort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17ff9b90-fb00-4844-8acb-777da9f17841",
      "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> list[str]:\n    ans = []\n\n    def dfs(start: int, prev: int, eval: int, path: list[str]) -> None:\n      if start == len(num):\n        if eval == target:\n          ans.append(''.join(path))\n        return\n\n      for i in range(start, len(num)):\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    dfs(0, 0, 0, [])\n    return ans",
      "title": "282. Expression Add Operators",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86c8a4e8-29e7-40c4-af3f-4535eeca770b",
      "code": "class Solution:\n  def moveZeroes(self, nums: list[int]) -> None:\n    j = 0\n    for num in nums:\n      if num != 0:\n        nums[j] = num\n        j += 1\n\n    for i in range(j, len(nums)):\n      nums[i] = 0",
      "title": "283. Move Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce718833-ce38-496a-aee6-c92e0053df4e",
      "code": "class Solution:\n  def inorderSuccessor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val <= p.val:\n      return self.inorderSuccessor(root.right, p)\n    return self.inorderSuccessor(root.left, p) or root",
      "title": "285. Inorder Successor in BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba27fa50-8e12-4038-9d45-54f574a960d1",
      "code": "class Solution:\n  def wallsAndGates(self, rooms: list[list[int]]) -> None:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    INF = 2**31 - 1\n    m = len(rooms)\n    n = len(rooms[0])\n    q = collections.deque((i, j)\n                          for i in range(m)\n                          for j in range(n)\n                          if rooms[i][j] == 0)\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if rooms[x][y] != INF:\n          continue\n        rooms[x][y] = rooms[i][j] + 1\n        q.append((x, y))",
      "title": "286. Walls and Gates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b2e9b5a-999f-47d4-be69-0b2368423b0d",
      "code": "class Solution:\n  def findDuplicate(self, nums: list[int]) -> int:\n    slow = nums[nums[0]]\n    fast = nums[nums[nums[0]]]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[nums[fast]]\n\n    slow = nums[0]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[fast]\n\n    return slow",
      "title": "287. Find the Duplicate Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51a24e4a-8738-49d7-bd19-048c1275a2ee",
      "code": "class Solution:\n  def gameOfLife(self, board: list[list[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n        # Any live cell with two or three live neighbors lives on to the next\n        # generation.\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n        # Any dead cell with exactly three live neighbors becomes a live cell,\n        # as if by reproduction.\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1",
      "title": "289. Game of Life",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd1bc09-e433-44aa-8450-df0c7f9cc2ca",
      "code": "class Solution:\n  def wordPattern(self, pattern: str, str: str) -> bool:\n    t = str.split()\n    return [*map(pattern.index, pattern)] == [*map(t.index, t)]",
      "title": "290. Word Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd93f10-7444-4d86-bfad-0da6278409b2",
      "code": "class Solution:\n  def wordPatternMatch(self, pattern: str, s: str) -> bool:\n    def isMatch(\n            i: int, j: int, charToString: dict[str, str],\n            seen: set[str]) -> bool:\n      if i == len(pattern) and j == len(s):\n        return True\n      if i == len(pattern) or j == len(s):\n        return False\n\n      c = pattern[i]\n\n      if c in charToString:\n        t = charToString[c]\n        # See if we can match t with s[j..n).\n        if t not in s[j:]:\n          return False\n\n        # If there's a match, continue to match the rest.\n        return isMatch(i + 1, j + len(t), charToString, seen)\n\n      for k in range(j, len(s)):\n        t = s[j:k + 1]\n\n        # This string is mapped by another character.\n        if t in seen:\n          continue\n\n        charToString[c] = t\n        seen.add(t)\n\n        if isMatch(i + 1, k + 1, charToString, seen):\n          return True\n\n        # Backtrack.\n        del charToString[c]\n        seen.remove(t)\n\n      return False\n\n    return isMatch(0, 0, {}, set())",
      "title": "291. Word Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84e7be0a-bd56-4af3-b3e6-f483e8fcace1",
      "code": "class Solution:\n  def canWinNim(self, n: int) -> bool:\n    return n % 4 != 0",
      "title": "292. Nim Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bae97c0-1108-44e2-b763-03672ce9875b",
      "code": "class Solution:\n  def generatePossibleNextMoves(self, currentState: str) -> list[str]:\n    return [currentState[:i] + '--' + currentState[i + 2:]\n            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n            if a == '+' and b == '+']",
      "title": "293. Flip Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c21d8ee1-1534-47b8-86ff-566cf907ee01",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def canWin(self, currentState: str) -> bool:\n    # If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    # changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win.\n    return any(True\n               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n               if a == '+' and b == '+' and\n               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))",
      "title": "294. Flip Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1b1d303-9178-46c4-87a1-2e29b82ffc2b",
      "code": "class Solution:\n  def minTotalDistance(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # i indices s.t. grid[i][j] == 1\n    I = [i for i in range(m) for j in range(n) if grid[i][j]]\n    # j indices s.t. grid[i][j] == 1\n    J = [j for j in range(n) for i in range(m) if grid[i][j]]\n\n    def minTotalDistance(grid: list[int]) -> int:\n      summ = 0\n      i = 0\n      j = len(grid) - 1\n      while i < j:\n        summ += grid[j] - grid[i]\n        i += 1\n        j -= 1\n      return summ\n\n    # sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J)",
      "title": "296. Best Meeting Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ac267c2-0497-480b-8d89-7c2e5d0537a1",
      "code": "class Solution:\n  def longestConsecutive(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode | None, target: int, length: int, maxLength: int) -> int:\n      if not root:\n        return maxLength\n      if root.val == target:\n        length += 1\n        maxLength = max(maxLength, length)\n      else:\n        length = 1\n      return max(dfs(root.left, root.val + 1, length, maxLength),\n                 dfs(root.right, root.val + 1, length, maxLength))\n\n    return dfs(root, root.val, 0, 0)",
      "title": "298. Binary Tree Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d5e58b4-9bff-4241-9132-86fc5400b897",
      "code": "class Solution:\n  def getHint(self, secret: str, guess: str) -> str:\n    bulls = sum(map(operator.eq, secret, guess))\n    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\n    return '%dA%dB' % (bulls, bovine - bulls)",
      "title": "299. Bulls and Cows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03871deb-ea23-4ce6-ba7d-f349044043a8",
      "code": "class Solution:\n  def lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n\n    return len(tails)",
      "title": "300. Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8622ac09-0db9-46e2-a139-6f979eaec0be",
      "code": "class Solution:\n  def removeInvalidParentheses(self, s: str) -> list[str]:\n    # Similar to 921. Minimum Add to Make Parentheses Valid\n    def getLeftAndRightCounts(s: str) -> tuple[int, int]:\n      \"\"\"Returns how many '(' and ')' need to be deleted.\"\"\"\n      l = 0\n      r = 0\n\n      for c in s:\n        if c == '(':\n          l += 1\n        elif c == ')':\n          if l == 0:\n            r += 1\n          else:\n            l -= 1\n\n      return l, r\n\n    def isValid(s: str):\n      opened = 0  # the number of '(' - # of ')'\n      for c in s:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened < 0:\n          return False\n      return True  # opened == 0\n\n    ans = []\n\n    def dfs(s: str, start: int, l: int, r: int) -> None:\n      if l == 0 and r == 0 and isValid(s):\n        ans.append(s)\n        return\n\n      for i in range(start, len(s)):\n        if i > start and s[i] == s[i - 1]:\n          continue\n        if r > 0 and s[i] == ')':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\n        elif l > 0 and s[i] == '(':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\n\n    l, r = getLeftAndRightCounts(s)\n    dfs(s, 0, l, r)\n    return ans",
      "title": "301. Remove Invalid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d21f5a5a-ac63-4919-bfdb-337885caa341",
      "code": "class Solution:\n  def minArea(self, image: list[list[str]], x: int, y: int) -> int:\n    def firstAnyOne(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          l = m + 1\n        else:\n          r = m\n      return l\n\n    def firstAllZeros(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def colAllZeros(colIndex: int) -> bool:\n      return all(pixel == '0' for pixel in list(zip(*image))[colIndex])\n\n    def rowAllZeros(rowIndex: int) -> bool:\n      return all(pixel == '0' for pixel in image[rowIndex])\n\n    x1 = firstAnyOne(0, x, rowAllZeros)\n    x2 = firstAllZeros(x + 1, len(image), rowAllZeros)\n    y1 = firstAnyOne(0, y, colAllZeros)\n    y2 = firstAllZeros(y + 1, len(image[0]), colAllZeros)\n    return (x2 - x1) * (y2 - y1)",
      "title": "302. Smallest Rectangle Enclosing Black Pixels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8de16525-0571-4a6a-97a8-405363c14298",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = [-1] * n\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numIslands2(\n      self,\n      m: int,\n      n: int,\n      positions: list[list[int]],\n  ) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    seen = [[False] * n for _ in range(m)]\n    uf = UnionFind(m * n)\n    count = 0\n\n    def getId(i: int, j: int, n: int) -> int:\n      return i * n + j\n\n    for i, j in positions:\n      if seen[i][j]:\n        ans.append(count)\n        continue\n      seen[i][j] = True\n      id = getId(i, j, n)\n      uf.id[id] = id\n      count += 1\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        neighborId = getId(x, y, n)\n        if uf.id[neighborId] == -1:  # water\n          continue\n        currentParent = uf.find(id)\n        neighborParent = uf.find(neighborId)\n        if currentParent != neighborParent:\n          uf.unionByRank(currentParent, neighborParent)\n          count -= 1\n      ans.append(count)\n\n    return ans",
      "title": "305. Number of Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b427b90-a6bb-4697-b7bc-602b6d4c6a87",
      "code": "class Solution:\n  def isAdditiveNumber(self, num: str) -> bool:\n    n = len(num)\n\n    def dfs(firstNum: int, secondNum: int, s: int) -> bool:\n      if s == len(num):\n        return True\n\n      thirdNum = firstNum + secondNum\n      thirdNumStr = str(thirdNum)\n\n      return (num.find(thirdNumStr, s) == s and\n              dfs(secondNum, thirdNum, s + len(thirdNumStr)))\n\n    # num[0..i] = firstNum\n    for i in range(n // 2):\n      if i > 0 and num[0] == '0':\n        return False\n      firstNum = int(num[:i + 1])\n      # num[i + 1..j] = secondNum\n      # |thirdNum| >= max(|firstNum|, |secondNum|)\n      j = i + 1\n      while max(i, j - i) < n - j:\n        if j > i + 1 and num[i + 1] == '0':\n          break\n        secondNum = int(num[i + 1:j + 1])\n        if dfs(firstNum, secondNum, j + 1):\n          return True\n        j += 1\n\n    return False",
      "title": "306. Additive Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd02907f-cfa5-40e6-acfa-ce10a573f800",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n    prev = 0\n\n    for price in prices:\n      cache = sell\n      sell = max(sell, hold + price)\n      hold = max(hold, prev - price)\n      prev = cache\n\n    return sell",
      "title": "309. Best Time to Buy and Sell Stock with Cooldown",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4af3e9a-cead-4b14-8136-456fb99bd9f4",
      "code": "class Solution:\n  def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans",
      "title": "310. Minimum Height Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eafaf276-db88-4237-91f6-7a9595cf8422",
      "code": "class Solution:\n  def multiply(self, mat1: list[list[int]],\n               mat2: list[list[int]]) -> list[list[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n    nonZeroColIndicesInMat2 = [\n        [j for j, a in enumerate(row) if a]\n        for row in mat2\n    ]\n\n    for i in range(m):\n      for j, a in enumerate(mat1[i]):\n        if a == 0:\n          continue\n        # mat1s j-th column matches mat2's j-th row\n        for colIndex in nonZeroColIndicesInMat2[j]:\n          ans[i][colIndex] += a * mat2[j][colIndex]\n\n    return ans",
      "title": "311. Sparse Matrix Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cde2fff3-d91e-4845-9851-c221c2831d54",
      "code": "class Solution:\n  def maxCoins(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i][j] := maxCoins(nums[i..j])\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    nums = [1] + nums + [1]\n\n    for d in range(n):\n      for i in range(1, n - d + 1):\n        j = i + d\n        for k in range(i, j + 1):\n          dp[i][j] = max(\n              dp[i][j],\n              dp[i][k - 1] +\n              dp[k + 1][j] +\n              nums[i - 1] * nums[k] * nums[j + 1])\n\n    return dp[1][n]",
      "title": "312. Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33f07df1-d7e8-45be-929a-a670dbcaf183",
      "code": "class UglyNum:\n  def __init__(self, prime: int, index: int, value: int):\n    self.prime = prime\n    self.index = index  # Point the next index of uglyNums.\n    self.value = value  # prime * uglyNums[index]\n\n\nclass Solution:\n  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n    minHeap = []  # (value, prime, index)\n    uglyNums = [1]\n\n    for prime in primes:\n      heapq.heappush(minHeap, (prime * uglyNums[0], prime, 1))\n\n    while len(uglyNums) < n:\n      uglyNums.append(minHeap[0][0])\n      while minHeap[0][0] == uglyNums[-1]:\n        _, prime, index = heapq.heappop(minHeap)\n        heapq.heappush(minHeap, (prime * uglyNums[index], prime, index + 1))\n\n    return uglyNums[-1]",
      "title": "313. Super Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae29c815-7853-4949-b38c-1c40e4d2e36b",
      "code": "class Solution:\n  def verticalOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    range_ = [0] * 2\n\n    def getRange(root: TreeNode | None, x: int) -> None:\n      if not root:\n        return\n\n      range_[0] = min(range_[0], x)\n      range_[1] = max(range_[1], x)\n\n      getRange(root.left, x - 1)\n      getRange(root.right, x + 1)\n\n    getRange(root, 0)  # Get the leftmost and the rightmost x index.\n\n    ans = [[] for _ in range(range_[1] - range_[0] + 1)]\n    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)\n\n    while q:\n      node, x = q.popleft()\n      ans[x].append(node.val)\n      if node.left:\n        q.append((node.left, x - 1))\n      if node.right:\n        q.append((node.right, x + 1))\n\n    return ans",
      "title": "314. Binary Tree Vertical Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f92d137-5f82-4a98-ab5e-4088dcf36d71",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Item:\n  num: int = 0\n  index: int = 0\n\n\nclass Solution:\n  def countSmaller(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    items = [Item(num, i) for i, num in enumerate(nums)]\n\n    self._mergeSort(items, 0, n - 1, ans)\n    return ans\n\n  def _mergeSort(\n      self,\n      items: list[Item],\n      l: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(items, l, m, ans)\n    self._mergeSort(items, m + 1, r, ans)\n    self._merge(items, l, m, r, ans)\n\n  def _merge(\n      self,\n      items: list[Item],\n      l: int,\n      m: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    sorted = [Item()] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n    rightCount = 0  # the number of numbers < items[i].num\n\n    while i <= m and j <= r:\n      if items[i].num > items[j].num:\n        rightCount += 1\n        sorted[k] = items[j]\n        k += 1\n        j += 1\n      else:\n        ans[items[i].index] += rightCount\n        sorted[k] = items[i]\n        k += 1\n        i += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      ans[items[i].index] += rightCount\n      sorted[k] = items[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = items[j]\n      k += 1\n      j += 1\n\n    items[l:l + len(sorted)] = sorted",
      "title": "315. Count of Smaller Numbers After Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1310ef03-6b91-428e-9647-1506287125e5",
      "code": "class Solution:\n  def removeDuplicateLetters(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    used = [False] * 26\n\n    for c in s:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "316. Remove Duplicate Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f978847-0711-4d99-a678-54c46e1809a1",
      "code": "class Solution:\n  def shortestDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nBuildings = sum(a == 1 for row in grid for a in row)\n    ans = math.inf\n    # dist[i][j] := the total distance of grid[i][j] (0) to reach all the\n    # buildings (1)\n    dist = [[0] * n for _ in range(m)]\n    # reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach\n    reachCount = [[0] * n for _ in range(m)]\n\n    def bfs(row: int, col: int) -> bool:\n      q = collections.deque([(row, col)])\n      seen = {(row, col)}\n      seenBuildings = 1\n\n      step = 1\n      while q:\n        for _ in range(len(q)):\n          i, j = q.popleft()\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x == m or y < 0 or y == n:\n              continue\n            if (x, y) in seen:\n              continue\n            seen.add((x, y))\n            if not grid[x][y]:\n              dist[x][y] += step\n              reachCount[x][y] += 1\n              q.append((x, y))\n            elif grid[x][y] == 1:\n              seenBuildings += 1\n        step += 1\n\n      # True if all the buildings (1) are connected\n      return seenBuildings == nBuildings\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:  # BFS from this building.\n          if not bfs(i, j):\n            return -1\n\n    for i in range(m):\n      for j in range(n):\n        if reachCount[i][j] == nBuildings:\n          ans = min(ans, dist[i][j])\n\n    return -1 if ans == math.inf else ans",
      "title": "317. Shortest Distance from All Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33432b81-ed31-4970-ba45-eb5d4748f0c2",
      "code": "class Solution:\n  def maxProduct(self, words: list[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(words)):\n      for j in range(i):\n        if not (masks[i] & masks[j]):\n          ans = max(ans, len(words[i]) * len(words[j]))\n\n    return ans",
      "title": "318. Maximum Product of Word Lengths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff71c02c-11aa-4053-81f7-69f65f108d2c",
      "code": "class Solution:\n  def bulbSwitch(self, n: int) -> int:\n    # The k-th bulb can only be switched when k % i == 0.\n    # So, we can rephrase the problem:\n    # To find number of numbers <= n that have odd factors.\n    # Obviously, only square numbers have odd factor(s).\n    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return math.isqrt(n)",
      "title": "319. Bulb Switcher",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e7be37e-f86b-490a-a6ed-92147ff47f5e",
      "code": "class Solution:\n  def generateAbbreviations(self, word: str) -> list[str]:\n    ans = []\n\n    def getCountString(count: int) -> str:\n      return str(count) if count > 0 else ''\n\n    def dfs(i: int, count: int, path: list[str]) -> None:\n      if i == len(word):\n        ans.append(''.join(path) + getCountString(count))\n        return\n\n      # Abbreviate the word[i].\n      dfs(i + 1, count + 1, path)\n      # Keep the word[i], so consume the count as a string.\n      path.append(getCountString(count) + word[i])\n      # Reset the count to 0.\n      dfs(i + 1, 0, path)\n      path.pop()\n\n    dfs(0, 0, [])\n    return ans",
      "title": "320. Generalized Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d9f3a0-6b18-4825-8ba8-060f5f4f7141",
      "code": "class Solution:\n  def maxNumber(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    def maxArray(nums: list[int], k: int) -> list[int]:\n      res = []\n      toTop = len(nums) - k\n      for num in nums:\n        while res and res[-1] < num and toTop > 0:\n          res.pop()\n          toTop -= 1\n        res.append(num)\n      return res[:k]\n\n    def merge(nums1: list[int], nums2: list[int]) -> list[int]:\n      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))",
      "title": "321. Create Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "815b9ff9-d849-493a-84b8-18a847756e30",
      "code": "class Solution:\n  def coinChange(self, coins: list[int], amount: int) -> int:\n    # dp[i] := the minimum number Of coins to make up i\n    dp = [0] + [amount + 1] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return -1 if dp[amount] == amount + 1 else dp[amount]",
      "title": "322. Coin Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b3f579d-c426-42a6-a69f-bbffc3125f5c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count",
      "title": "323. Number of Connected Components in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a405d45c-0e9c-4a5c-8243-d9fc7317f4f3",
      "code": "class Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(node: int, seen: set[int]) -> None:\n      q = collections.deque([node])\n      seen.add(node)\n\n      while q:\n        u = q.pop()\n        for v in graph[u]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for i in range(n):\n      if i not in seen:\n        bfs(i, seen)\n        ans += 1\n\n    return ans",
      "title": "323. Number of Connected Components in an Undirected Graph_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57d3c739-0b5b-41dd-a58f-66903f59012a",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    n = len(nums)\n    median = self._findKthLargest(nums, (n + 1) // 2)\n\n    def A(i: int):\n      return (1 + 2 * i) % (n | 1)\n\n    i = 0\n    j = 0\n    k = n - 1\n\n    while i <= k:\n      if nums[A(i)] > median:\n        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]\n        i, j = i + 1, j + 1\n      elif nums[A(i)] < median:\n        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]\n        k -= 1\n      else:\n        i += 1\n\n  # Same as 215. Kth Largest Element in an Array\n  def _findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "324. Wiggle Sort II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "509ae45f-c9f6-4a61-8c4a-f2bcd49c2b87",
      "code": "class Solution:\n  def maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        ans = max(ans, i - prefixToIndex[target])\n      if prefix not in prefixToIndex:\n        prefixToIndex[prefix] = i\n\n    return ans",
      "title": "325. Maximum Size Subarray Sum Equals k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7f9600a-7899-4950-8610-48cdca1e9ae6",
      "code": "class Solution:\n  def isPowerOfThree(self, n: int) -> bool:\n    return n > 0 and 3**19 % n == 0",
      "title": "326. Power of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0216cdb5-2ddb-4440-a3e3-ffa5a54fa274",
      "code": "class Solution:\n  def countRangeSum(self, nums: list[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(\n      self,\n      prefix: list[int],\n      l: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(\n      self,\n      prefix: list[int],\n      l: int,\n      m: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    lo = m + 1  # the first index s.t. prefix[lo] - prefix[i] >= lower\n    hi = m + 1  # the first index s.t. prefix[hi] - prefix[i] > upper\n\n    # For each index i in range [l, m], add hi - lo to `ans`.\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted",
      "title": "327. Count of Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2116cf48-6955-49ef-b777-d3b044da1ae1",
      "code": "class Solution:\n  def oddEvenList(self, head: ListNode) -> ListNode:\n    oddHead = ListNode(0)\n    evenHead = ListNode(0)\n    odd = oddHead\n    even = evenHead\n    isOdd = True\n\n    while head:\n      if isOdd:\n        odd.next = head\n        odd = head\n      else:\n        even.next = head\n        even = head\n      head = head.next\n      isOdd = not isOdd\n\n    even.next = None\n    odd.next = evenHead.next\n    return oddHead.next",
      "title": "328. Odd Even Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26b055de-2e14-4452-9d98-4f15a9be4720",
      "code": "class Solution:\n  def longestIncreasingPath(self, matrix: list[list[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, prev: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 0\n      if matrix[i][j] <= prev:\n        return 0\n\n      curr = matrix[i][j]\n      return 1 + max(dfs(i + 1, j, curr),\n                     dfs(i - 1, j, curr),\n                     dfs(i, j + 1, curr),\n                     dfs(i, j - 1, curr))\n\n    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))",
      "title": "329. Longest Increasing Path in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d7c10a9-d570-4dc8-9e23-d8da08c1cbe9",
      "code": "class Solution:\n  def minPatches(self, nums: list[int], n: int) -> int:\n    ans = 0\n    i = 0  # nums' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    while miss <= n:\n      if i < len(nums) and nums[i] <= miss:\n        miss += nums[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "330. Patching Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75929170-b098-412e-bf77-ddba67371a9c",
      "code": "class Solution:\n  def isValidSerialization(self, preorder: str) -> bool:\n    degree = 1  # out-degree (children) - in-degree (parent)\n\n    for node in preorder.split(','):\n      degree -= 1\n      if degree < 0:\n        return False\n      if node != '#':\n        degree += 2\n\n    return degree == 0",
      "title": "331. Verify Preorder Serialization of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9666fb5f-e560-4a40-9da6-ac9156e5d9b5",
      "code": "class Solution:\n  def findItinerary(self, tickets: list[list[str]]) -> list[str]:\n    ans = []\n    graph = collections.defaultdict(list)\n\n    for a, b in reversed(sorted(tickets)):\n      graph[a].append(b)\n\n    def dfs(u: str) -> None:\n      while u in graph and graph[u]:\n        dfs(graph[u].pop())\n      ans.append(u)\n\n    dfs('JFK')\n    return ans[::-1]",
      "title": "332. Reconstruct Itinerary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75061a8e-b366-467c-b38a-aaed23a9515a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  mn: int  # the minimum value in the subtree\n  mx: int  # the maximum value in the subtree\n  size: int  # the size of the subtree\n\n\nclass Solution:\n  def largestBSTSubtree(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(math.inf, -math.inf, 0)\n\n      l = dfs(root.left)\n      r = dfs(root.right)\n\n      if l.mx < root.val < r.mn:\n        return T(min(l.mn, root.val), max(r.mx, root.val), 1 + l.size + r.size)\n\n      # Mark one as invalid, but still record the size of children.\n      # Return (-inf, inf) because no node will be > inf or < -inf.\n      return T(-math.inf, math.inf, max(l.size, r.size))\n\n    return dfs(root).size",
      "title": "333. Largest BST Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa3ab6e9-056b-47ff-a677-894ce9922516",
      "code": "class Solution:\n  def increasingTriplet(self, nums: list[int]) -> bool:\n    first = math.inf\n    second = math.inf\n\n    for num in nums:\n      if num <= first:\n        first = num\n      elif num <= second:  # first < num <= second\n        second = num\n      else:\n        return True  # first < second < num (third)\n\n    return False",
      "title": "334. Increasing Triplet Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9acf62c-ad12-42f4-a714-da0c902aa68e",
      "code": "class Solution:\n  def isSelfCrossing(self, x: list[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False",
      "title": "335. Self Crossing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "866e797c-a3e9-430b-965c-be4b98563b0c",
      "code": "class Solution:\n  def palindromePairs(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans",
      "title": "336. Palindrome Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34850518-b251-4cf6-9127-a6e392130c69",
      "code": "class Solution:\n  def rob(self, root: TreeNode | None) -> int:\n    def robOrNot(root: TreeNode | None) -> tuple:\n      if not root:\n        return (0, 0)\n\n      robLeft, notRobLeft = robOrNot(root.left)\n      robRight, notRobRight = robOrNot(root.right)\n\n      return (root.val + notRobLeft + notRobRight,\n              max(robLeft, notRobLeft) + max(robRight, notRobRight))\n\n    return max(robOrNot(root))",
      "title": "337. House Robber III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01c9bac3-23cd-4030-90bc-fdd9fb260e3d",
      "code": "class Solution:\n  def countBits(self, n: int) -> list[int]:\n    # f(i) := i's number of 1s in bitmask\n    # f(i) = f(i / 2) + i % 2\n    ans = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      ans[i] = ans[i // 2] + (i & 1)\n\n    return ans",
      "title": "338. Counting Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "869311d1-d07c-4be5-9084-1a87e26c8d89",
      "code": "class Solution:\n  def depthSum(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    depth = 0\n    q = collections.deque()\n\n    def addIntegers(nestedList: list[NestedInteger]) -> None:\n      for ni in nestedList:\n        q.append(ni)\n\n    addIntegers(nestedList)\n\n    while q:\n      depth += 1\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          addIntegers(ni.getList())\n\n    return ans",
      "title": "339. Nested List Weight Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0baff14-d284-4ba9-abe4-86f57c0bd594",
      "code": "class Solution:\n  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n    ans = 0\n    distinct = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        distinct += 1\n      while distinct == k + 1:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "340. Longest Substring with At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65cb4f36-3605-4f9e-99a2-e32c022f840b",
      "code": "class Solution:\n  def isPowerOfFour(self, n: int) -> bool:\n    # Why (4^n - 1) % 3 == 0?\n    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    # three consecutive numbers; among one of them, there must be a multiple\n    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    # Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0",
      "title": "342. Power of Four",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43f8a006-d47a-4c03-a3b1-dc2d8cd92792",
      "code": "class Solution:\n  def integerBreak(self, n: int) -> int:\n    # If an optimal product contains a factor f >= 4, then we can replace it\n    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    # (and 1 is wasteful).\n    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if n == 2:  # 1 * 1\n      return 1\n    if n == 3:  # 1 * 2\n      return 2\n\n    ans = 1\n\n    while n > 4:\n      n -= 3\n      ans *= 3\n    ans *= n\n\n    return ans",
      "title": "343. Integer Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "539e9648-2975-40fe-9042-c2fece28521a",
      "code": "class Solution:\n  def reverseString(self, s: list[str]) -> None:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      s[l], s[r] = s[r], s[l]\n      l += 1\n      r -= 1",
      "title": "344. Reverse String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86b1e0be-c808-4aeb-bedc-ce3a2a3e0761",
      "code": "class Solution:\n  def reverseVowels(self, s: str) -> str:\n    chars = list(s)\n    VOWELS = 'aeiouAEIOU'\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and chars[l] not in VOWELS:\n        l += 1\n      while l < r and chars[r] not in VOWELS:\n        r -= 1\n      chars[l], chars[r] = chars[r], chars[l]\n      l += 1\n      r -= 1\n\n    return ''.join(chars)",
      "title": "345. Reverse Vowels of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3669ee11-c8b2-4ccc-9926-ed04e72a854c",
      "code": "class Solution:\n  def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    bucket = [[] for _ in range(len(nums) + 1)]\n\n    for num, freq in collections.Counter(nums).items():\n      bucket[freq].append(num)\n\n    for b in reversed(bucket):\n      ans += b\n      if len(ans) == k:\n        return ans",
      "title": "347. Top K Frequent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32ba3412-bfcc-4223-a6c4-1d17f79501f6",
      "code": "class Solution:\n  def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    ans = []\n    nums1 = set(nums1)\n\n    for num in nums2:\n      if num in nums1:\n        ans.append(num)\n        nums1.remove(num)\n\n    return ans",
      "title": "349. Intersection of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f659d11-a14a-4a76-81f4-4e2c823056c9",
      "code": "class Solution:\n  def intersect(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    if len(nums1) > len(nums2):\n      return self.intersect(nums2, nums1)\n\n    ans = []\n    count = collections.Counter(nums1)\n\n    for num in nums2:\n      if count[num] > 0:\n        ans.append(num)\n        count[num] -= 1\n\n    return ans",
      "title": "350. Intersection of Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53fadc96-3520-42cf-902d-df00d13c6679",
      "code": "class Solution:\n  def numberOfPatterns(self, m: int, n: int) -> int:\n    seen = set()\n    accross = [[0] * 10 for _ in range(10)]\n\n    accross[1][3] = accross[3][1] = 2\n    accross[1][7] = accross[7][1] = 4\n    accross[3][9] = accross[9][3] = 6\n    accross[7][9] = accross[9][7] = 8\n    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \\\n        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5\n\n    def dfs(u: int, depth: int) -> int:\n      if depth > n:\n        return 0\n\n      seen.add(u)\n      ans = 1 if depth >= m else 0\n\n      for v in range(1, 10):\n        if v == u or v in seen:\n          continue\n        accrossed = accross[u][v]\n        if not accrossed or accrossed in seen:\n          ans += dfs(v, depth + 1)\n\n      seen.remove(u)\n      return ans\n\n    # 1, 3, 7, 9 are symmetric\n    # 2, 4, 6, 8 are symmetric\n    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)",
      "title": "351. Android Unlock Patterns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4a109e4-f4a5-4368-adbe-b6bc60a9dfeb",
      "code": "class Solution:\n  def maxEnvelopes(self, envelopes: list[list[int]]) -> int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    return self._lengthOfLIS(envelopes)\n\n  def _lengthOfLIS(self, envelopes: list[list[int]]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for _, h in envelopes:\n      if not tails or h > tails[-1]:\n        tails.append(h)\n      else:\n        tails[bisect.bisect_left(tails, h)] = h\n\n    return len(tails)",
      "title": "354. Russian Doll Envelopes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35661974-d9de-42b6-9b1c-8efe1027785e",
      "code": "class Solution:\n  def isReflected(self, points: list[list[int]]) -> bool:\n    minX = math.inf\n    maxX = -math.inf\n    seen = set()\n\n    for x, y in points:\n      minX = min(minX, x)\n      maxX = max(maxX, x)\n      seen.add((x, y))\n\n    summ = minX + maxX\n    # (leftX + rightX) / 2 = (minX + maxX) / 2\n    #  leftX = minX + maxX - rightX\n    # rightX = minX + maxX - leftX\n\n    return all((summ - x, y) in seen for x, y in points)",
      "title": "356. Line Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "028e3118-4b12-44a0-91ab-b6e4694b0a4a",
      "code": "class Solution:\n  def countNumbersWithUniqueDigits(self, n: int) -> int:\n    if n == 0:\n      return 1\n\n    ans = 10\n    uniqueDigits = 9\n    availableNum = 9\n\n    while n > 1 and availableNum > 0:\n      uniqueDigits *= availableNum\n      ans += uniqueDigits\n      n -= 1\n      availableNum -= 1\n\n    return ans",
      "title": "357. Count Numbers with Unique Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "104457f8-645b-4364-8683-5e8fa855828d",
      "code": "class Solution:\n  def rearrangeString(self, s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    count = collections.Counter(s)\n    # valid[i] := the leftmost index i can appear\n    valid = collections.Counter()\n\n    def getBestLetter(index: int) -> str:\n      \"\"\"Returns the valid letter that has the most count.\"\"\"\n      maxCount = -1\n      bestLetter = '*'\n\n      for c in string.ascii_lowercase:\n        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:\n          bestLetter = c\n          maxCount = count[c]\n\n      return bestLetter\n\n    for i in range(n):\n      c = getBestLetter(i)\n      if c == '*':\n        return ''\n      ans.append(c)\n      count[c] -= 1\n      valid[c] = i + k\n\n    return ''.join(ans)",
      "title": "358. Rearrange String k Distance Apart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c6f7d8-97c3-4980-b5d1-6369da49f20f",
      "code": "class Solution:\n  def sortTransformedArray(\n      self,\n      nums: list[int],\n      a: int,\n      b: int,\n      c: int,\n  ) -> list[int]:\n    n = len(nums)\n    upward = a > 0\n    ans = [0] * n\n\n    # The concavity of f only depends on a's sign.\n    def f(x: int, a: int, b: int, c: int) -> int:\n      return (a * x + b) * x + c\n\n    quad = [f(num, a, b, c) for num in nums]\n\n    i = n - 1 if upward else 0\n    l = 0\n    r = n - 1\n    while l <= r:\n      if upward:  # is the maximum in the both ends\n        if quad[l] > quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i -= 1\n      else:  # is the minimum in the both ends\n        if quad[l] < quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i += 1\n\n    return ans",
      "title": "360. Sort Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c1ad4ef-9bfd-4d2e-9145-9b05444c7a8b",
      "code": "class Solution:\n  def maxKilledEnemies(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    enemyCount = 0\n    # dp[i][j] := the maximum enemies grid[i][j] can kill\n    dp = [[0] * n for _ in range(m)]\n\n    def update(i: int, j: int) -> None:\n      nonlocal enemyCount\n      if grid[i][j] == '0':\n        dp[i][j] += enemyCount\n      elif grid[i][j] == 'E':\n        enemyCount += 1\n      else:  # grid[i][j] == 'W'\n        enemyCount = 0\n\n    # Extend the four directions, if meet 'W', need to start over from 0.\n    for i in range(m):\n      enemyCount = 0\n      for j in range(n):\n        update(i, j)\n      enemyCount = 0\n      for j in reversed(range(n)):\n        update(i, j)\n\n    for j in range(n):\n      enemyCount = 0\n      for i in range(m):\n        update(i, j)\n      enemyCount = 0\n      for i in reversed(range(m)):\n        update(i, j)\n\n    # Returns sum(map(sum, dp))\n    return max(map(max, dp))",
      "title": "361. Bomb Enemy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b8d1ee7-1c1b-476e-82b5-92dd7753eb8d",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = -math.inf\n\n    for baseCol in range(n):\n      # sums[i] := sum(matrix[i][baseCol..j])\n      sums = [0] * m\n      for j in range(baseCol, n):\n        for i in range(m):\n          sums[i] += matrix[i][j]\n        # Find the maximum sum <= k of all the subarrays.\n        accumulate = SortedList([0])\n        prefix = 0\n        for summ in sums:\n          prefix += summ\n          it = accumulate.bisect_left(prefix - k)\n          if it != len(accumulate):\n            ans = max(ans, prefix - accumulate[it])\n          accumulate.add(prefix)\n\n    return ans",
      "title": "363. Max Sum of Rectangle No Larger Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d47187b-2308-4092-897d-09a4453440f4",
      "code": "class Solution:\n  def depthSumInverse(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    prevSum = 0\n    q = collections.deque(nestedList)\n\n    while q:\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          prevSum += ni.getInteger()\n        else:\n          for nextNi in ni.getList():\n            q.append(nextNi)\n      ans += prevSum\n\n    return ans",
      "title": "364. Nested List Weight Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99763dea-ef74-4373-aebd-522c1c7ccd3e",
      "code": "class Solution:\n  def canMeasureWater(\n      self,\n      jug1Capacity: int,\n      jug2Capacity: int,\n      targetCapacity: int,\n  ) -> bool:\n    return (targetCapacity == 0 or\n            jug1Capacity + jug2Capacity >= targetCapacity and\n            targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0)",
      "title": "365. Water and Jug Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0926d17f-0813-4d67-a58a-f2d037c58893",
      "code": "class Solution:\n  def findLeaves(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n\n    def depth(root: TreeNode | None) -> int:\n      \"\"\"Returns the depth of the root (0-indexed).\"\"\"\n      if not root:\n        return -1\n\n      l = depth(root.left)\n      r = depth(root.right)\n      h = 1 + max(l, r)\n\n      if len(ans) == h:  # Meet a leaf\n        ans.append([])\n\n      ans[h].append(root.val)\n      return h\n\n    depth(root)\n    return ans",
      "title": "366. Find Leaves of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e1e94f8-5868-4a49-8960-0477386e214b",
      "code": "class Solution:\n  def isPerfectSquare(self, num: int) -> bool:\n    l = bisect.bisect_left(range(num), num, key=lambda m: m * m)\n    return l**2 == num",
      "title": "367. Valid Perfect Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4229fd05-b6d3-4db3-b6a0-15e3542793c4",
      "code": "class Solution:\n  def largestDivisibleSubset(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = []\n    count = [1] * n\n    prevIndex = [-1] * n\n    maxCount = 0\n    index = -1\n\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      for j in reversed(range(i)):\n        if num % nums[j] == 0 and count[i] < count[j] + 1:\n          count[i] = count[j] + 1\n          prevIndex[i] = j\n      if count[i] > maxCount:\n        maxCount = count[i]\n        index = i\n\n    while index != -1:\n      ans.append(nums[index])\n      index = prevIndex[index]\n\n    return ans",
      "title": "368. Largest Divisible Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e196c81c-7e6a-4b16-b8d5-405e79003902",
      "code": "class Solution:\n  def plusOne(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    dummy.next = head\n\n    while head:\n      if head.val != 9:\n        curr = head\n      head = head.next\n    # `curr` now points to the rightmost non-9 node.\n\n    curr.val += 1\n    while curr.next:\n      curr.next.val = 0\n      curr = curr.next\n\n    return dummy.next if dummy.val == 0 else dummy",
      "title": "369. Plus One Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "725c2fd8-029d-455a-b12f-fc6c7c8eb1af",
      "code": "class Solution:\n  def getModifiedArray(\n      self,\n      length: int,\n      updates: list[list[int]],\n  ) -> list[int]:\n    line = [0] * length\n\n    for start, end, inc in updates:\n      line[start] += inc\n      if end + 1 < length:\n        line[end + 1] -= inc\n\n    return itertools.accumulate(line)",
      "title": "370. Range Addition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7d4b710-4366-4baa-98a3-daa670ac8999",
      "code": "class Solution:\n  def getSum(self, a: int, b: int) -> int:\n    mask = 0xFFFFFFFF\n    MAX = 2000\n\n    while b != 0:\n      a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n\n    return a if a < MAX else ~(a ^ mask)",
      "title": "371. Sum of Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef21722f-2a84-4e91-baf2-8e1c067c6c1c",
      "code": "class Solution:\n  def superPow(self, a: int, b: list[int]) -> int:\n    MOD = 1337\n    ans = 1\n\n    for i in b:\n      ans = pow(ans, 10, MOD) * pow(a, i, MOD)\n\n    return ans % MOD",
      "title": "372. Super Pow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97d7079b-e6c5-4ad8-9bd6-343199610817",
      "code": "class Solution:\n  def kSmallestPairs(self, nums1: list[int],\n                     nums2: list[int],\n                     k: int) -> list[list[int]]:\n    minHeap = []\n\n    for i in range(min(k, len(nums1))):\n      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))\n\n    ans = []\n    while minHeap and len(ans) < k:\n      _, i, j = heapq.heappop(minHeap)\n      ans.append([nums1[i], nums2[j]])\n      if j + 1 < len(nums2):\n        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return ans",
      "title": "373. Find K Pairs with Smallest Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d316a97e-5db1-4e5b-acbc-b687d90a7a44",
      "code": "# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -> int:\n\nclass Solution:\n  def guessNumber(self, n: int) -> int:\n    l = 1\n    r = n\n\n    # Find the first guess number that >= the target number\n    while l < r:\n      m = (l + r) // 2\n      if guess(m) <= 0:  # -1, 0\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "374. Guess Number Higher or Lower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b5610e7-8bab-463d-b983-059fe0b24261",
      "code": "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    # dp[i][j] := the minimum money you need to guarantee a win of picking i..j\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    for d in range(1, n + 1):\n      for i in range(1, n - d + 1):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j + 1):\n          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k)\n\n    return dp[1][n]",
      "title": "375. Guess Number Higher or Lower II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42b27d5a-175c-4886-a280-f35ebd5318ed",
      "code": "class Solution:\n  def wiggleMaxLength(self, nums: list[int]) -> int:\n    increasing = 1\n    decreasing = 1\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing = decreasing + 1\n      elif b < a:\n        decreasing = increasing + 1\n\n    return max(increasing, decreasing)",
      "title": "376. Wiggle Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4ff85d1-db7d-4af2-96e3-3d5401e8b685",
      "code": "class Solution:\n  def combinationSum4(self, nums: list[int], target: int) -> int:\n    dp = [1] + [-1] * target\n\n    def dfs(target: int) -> int:\n      if target < 0:\n        return 0\n      if dp[target] != -1:\n        return dp[target]\n\n      dp[target] = sum(dfs(target - num) for num in nums)\n      return dp[target]\n\n    return dfs(target)",
      "title": "377. Combination Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0b46e43-a74e-41eb-ae92-af7797f110dc",
      "code": "class Solution:\n  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:\n    def numsNoGreaterThan(m: int) -> int:\n      count = 0\n      j = len(matrix[0]) - 1\n      # For each row, find the first index j s.t. row[j] <= m s.t. the number of\n      # numbers <= m for this row will be j + 1.\n      for row in matrix:\n        while j >= 0 and row[j] > m:\n          j -= 1\n        count += j + 1\n      return count\n\n    l = matrix[0][0]\n    r = matrix[-1][-1]\n    return bisect.bisect_left(range(l, r), k, key=numsNoGreaterThan) + l",
      "title": "378. Kth Smallest Element in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7151d269-ab27-453a-b290-edd6af11e05c",
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#   def __init__(self, val=0, next=None):\n#     self.val = val\n#     self.next = next\n\nclass Solution:\n  def __init__(self, head: ListNode | None):\n    self.head = head\n\n  def getRandom(self) -> int:\n    res = -1\n    i = 1\n    curr = self.head\n\n    while curr:\n      if random.randint(0, i - 1) == 0:\n        res = curr.val\n      curr = curr.next\n      i += 1\n\n    return res",
      "title": "382. Linked List Random Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c95bec20-8769-4a8f-bf7f-d16a9a395afd",
      "code": "class Solution:\n  def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n    count1 = collections.Counter(ransomNote)\n    count2 = collections.Counter(magazine)\n    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)",
      "title": "383. Ransom Note",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8b1c729-fb95-4c56-9769-275723744ebe",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def reset(self) -> list[int]:\n    return self.nums\n\n  def shuffle(self) -> list[int]:\n    arr = self.nums.copy()\n    for i in range(len(arr) - 1, 0, -1):\n      j = random.randint(0, i)\n      arr[i], arr[j] = arr[j], arr[i]\n    return arr",
      "title": "384. Shuffle an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e4c670a-42ab-4c3c-b791-5805ae23f3c0",
      "code": "class Solution:\n  def deserialize(self, s: str) -> NestedInteger:\n    if s[0] != '[':\n      return NestedInteger(int(s))\n\n    stack = []\n\n    for i, c in enumerate(s):\n      if c == '[':\n        stack.append(NestedInteger())\n        start = i + 1\n      elif c == ',':\n        if i > start:\n          num = int(s[start:i])\n          stack[-1].add(NestedInteger(num))\n        start = i + 1\n      elif c == ']':\n        popped = stack.pop()\n        if i > start:\n          num = int(s[start:i])\n          popped.add(NestedInteger(num))\n        if stack:\n          stack[-1].add(popped)\n        else:\n          return popped\n        start = i + 1",
      "title": "385. Mini Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eda6ee5c-dda6-4ee8-97b5-8dcb03fc6615",
      "code": "class Solution:\n  def lexicalOrder(self, n: int) -> list[int]:\n    ans = []\n    curr = 1\n\n    while len(ans) < n:\n      ans.append(curr)\n      if curr * 10 <= n:\n        curr *= 10\n      else:\n        while curr % 10 == 9 or curr == n:\n          curr //= 10\n        curr += 1\n\n    return ans",
      "title": "386. Lexicographical Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2b661d4-1d79-431a-9315-86b650bcfbe2",
      "code": "class Solution:\n  def firstUniqChar(self, s: str) -> int:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(s):\n      if count[c] == 1:\n        return i\n\n    return -1",
      "title": "387. First Unique Character in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a009a57-1ed9-4015-a502-b0cfea8e42d6",
      "code": "class Solution:\n  def lengthLongestPath(self, input: str) -> int:\n    ans = 0\n    stack = [(-1, 0)]  # placeholder\n\n    for token in input.split('\\n'):\n      depth = token.count('\\t')\n      token = token.replace('\\t', '')\n      while depth <= stack[-1][0]:\n        stack.pop()\n      if '.' in token:  # `token` is file.\n        ans = max(ans, stack[-1][1] + len(token))\n      else:  # directory + '/'\n        stack.append((depth, stack[-1][1] + len(token) + 1))\n\n    return ans",
      "title": "388. Longest Absolute File Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9340e2b-efe1-46b4-9f61-276212e6f225",
      "code": "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    sXors = chr(functools.reduce(operator.xor, map(ord, s), 0))\n    tXors = chr(functools.reduce(operator.xor, map(ord, t), 0))\n    return chr(ord(sXors) ^ ord(tXors))",
      "title": "389. Find the Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff1ffe6f-9479-4e1e-b4ba-426578b96dbb",
      "code": "class Solution:\n  def lastRemaining(self, n: int) -> int:\n    return 1 if n == 1 else 2 * (1 + n // 2 - self.lastRemaining(n // 2))",
      "title": "390. Elimination Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23cc7064-ed4e-4ce2-9cd4-6f4d307eaf55",
      "code": "class Solution:\n  def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: set[tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      # the four points of the current rectangle\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if ((x1, y1) not in corners or\n        (x1, y2) not in corners or\n        (x2, y1) not in corners or\n            (x2, y2) not in corners):\n      return False\n    return area == (x2 - x1) * (y2 - y1)",
      "title": "391. Perfect Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b01337d2-f2d3-45e0-8b21-0ee4e6b23d87",
      "code": "class Solution:\n  def isSubsequence(self, s: str, t: str) -> bool:\n    if not s:\n      return True\n\n    i = 0\n    for c in t:\n      if s[i] == c:\n        i += 1\n        if i == len(s):\n          return True\n\n    return False",
      "title": "392. Is Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b13bef8-b588-4980-bed8-2f5494e65a9f",
      "code": "class Solution:\n  def validUtf8(self, data: list[int]) -> bool:\n    followedBytes = 0\n\n    for d in data:\n      if followedBytes == 0:\n        if (d >> 3) == 0b11110:\n          followedBytes = 3\n        elif (d >> 4) == 0b1110:\n          followedBytes = 2\n        elif (d >> 5) == 0b110:\n          followedBytes = 1\n        elif (d >> 7) == 0b0:\n          followedBytes = 0\n        else:\n          return False\n      else:\n        if (d >> 6) != 0b10:\n          return False\n        followedBytes -= 1\n\n    return followedBytes == 0",
      "title": "393. UTF-8 Validation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b922d7bd-1e44-4c65-a8f6-99036b311962",
      "code": "class Solution:\n  def decodeString(self, s: str) -> str:\n    ans = ''\n\n    while self.i < len(s) and s[self.i] != ']':\n      if s[self.i].isdigit():\n        k = 0\n        while self.i < len(s) and s[self.i].isdigit():\n          k = k * 10 + int(s[self.i])\n          self.i += 1\n        self.i += 1  # '['\n        decodedString = self.decodeString(s)\n        self.i += 1  # ']'\n        ans += k * decodedString\n      else:\n        ans += s[self.i]\n        self.i += 1\n\n    return ans\n\n  i = 0",
      "title": "394. Decode String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b16c516d-e57d-422d-b868-bddd7185518c",
      "code": "class Solution:\n  def longestSubstring(self, s: str, k: int) -> int:\n    def longestSubstringWithNUniqueLetters(n: int) -> int:\n      res = 0\n      uniqueLetters = 0  # the number of unique letters\n      lettersHavingKFreq = 0  # the number of letters having frequency >= k\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == k:\n          lettersHavingKFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == k:\n            lettersHavingKFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having frequency >= k are equal to n, this is a valid window.\n        if lettersHavingKFreq == n:  # Implicit: uniqueLetters == n\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(longestSubstringWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "395. Longest Substring with At Least K Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21941c64-c8cd-4301-819b-c058578f6ff5",
      "code": "class Solution:\n  def maxRotateFunction(self, nums: list[int]) -> int:\n    f = sum(i * num for i, num in enumerate(nums))\n    ans = f\n    summ = sum(nums)\n\n    for a in reversed(nums):\n      f += summ - len(nums) * a\n      ans = max(ans, f)\n\n    return ans",
      "title": "396. Rotate Function",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc38c35f-0215-4949-ada9-980420e4c76a",
      "code": "class Solution:\n  def integerReplacement(self, n: int) -> int:\n    ans = 0\n\n    while n > 1:\n      if n % 2 == 0:  # `n` ends in 0.\n        n >>= 1\n      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.\n        n -= 1\n      else:  # `n` ends in 0b11.\n        n += 1\n      ans += 1\n\n    return ans",
      "title": "397. Integer Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85176e5c-b790-440b-8649-4216405c154d",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def pick(self, target: int) -> int:\n    ans = -1\n    rng = 0\n    for i, num in enumerate(self.nums):\n      if num == target:\n        rng += 1\n        if random.randint(0, rng - 1) == 0:\n          ans = i\n    return ans",
      "title": "398. Random Pick Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a30c162-d7d4-445c-a44c-2dee1f606e55",
      "code": "class Solution:\n  def calcEquation(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n      queries: list[list[str]],\n  ) -> list[float]:\n    ans = []\n    # graph[A][B] := A / B\n    graph = collections.defaultdict(dict)\n\n    for (A, B), value in zip(equations, values):\n      graph[A][B] = value\n      graph[B][A] = 1 / value\n\n    def devide(A: str, C: str, seen: set[str]) -> float:\n      \"\"\"Returns A / C.\"\"\"\n      if A == C:\n        return 1.0\n\n      seen.add(A)\n\n      # value := A / B\n      for B, value in graph[A].items():\n        if B in seen:\n          continue\n        res = devide(B, C, seen)  # B / C\n        if res > 0:  # valid result\n          return value * res  # (A / B) * (B / C) = A / C\n\n      return -1.0  # invalid result\n\n    for A, C in queries:\n      if A not in graph or C not in graph:\n        ans.append(-1.0)\n      else:\n        ans.append(devide(A, C, set()))\n\n    return ans",
      "title": "399. Evaluate Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7234781-5d26-41bd-9205-9b45d16d2f18",
      "code": "class Solution:\n  def findNthDigit(self, n: int) -> int:\n    def getDigit(num: int, pos: int, digitSize: int):\n      if pos == 0:\n        return num % 10\n      for _ in range(digitSize - pos):\n        num //= 10\n      return num % 10\n\n    digitSize = 1\n    startNum = 1\n    count = 9\n\n    while digitSize * count < n:\n      n -= digitSize * count\n      digitSize += 1\n      startNum *= 10\n      count *= 10\n\n    targetNum = startNum + (n - 1) // digitSize\n    pos = n % digitSize\n\n    return getDigit(targetNum, pos, digitSize)",
      "title": "400. Nth Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851bd650-1d36-4d96-99e2-32476bc0e62f",
      "code": "class Solution:\n  def readBinaryWatch(self, turnedOn: int) -> list[str]:\n    ans = []\n    hours = [1, 2, 4, 8]\n    minutes = [1, 2, 4, 8, 16, 32]\n\n    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:\n      if turnedOn == 0:\n        time = str(h) + \":\" + (str(m).zfill(2))\n        ans.append(time)\n        return\n\n      for i in range(s, len(hours) + len(minutes)):\n        if i < 4 and h + hours[i] < 12:\n          dfs(turnedOn - 1, i + 1, h + hours[i], m)\n        elif i >= 4 and m + minutes[i - 4] < 60:\n          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])\n\n    dfs(turnedOn, 0, 0, 0)\n    return ans",
      "title": "401. Binary Watch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad0de9b3-1c9e-48a2-bdc1-e91c2d70d1fc",
      "code": "class Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'",
      "title": "402. Remove K Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e43a2d3e-dbd2-465b-acd2-6c8d6a86f3f8",
      "code": "class Solution:\n  def canCross(self, stones: list[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump to stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][0] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k > n:\n          continue\n        for x in (k - 1, k, k + 1):\n          if 0 <= x <= n:\n            dp[i][k] |= dp[j][x]\n\n    return any(dp[-1])",
      "title": "403. Frog Jump",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eabc24b-389a-41c2-9125-8297c2f8202b",
      "code": "class Solution:\n  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    ans = 0\n    stack = [root]\n\n    while stack:\n      root = stack.pop()\n      if root.left:\n        if not root.left.left and not root.left.right:\n          ans += root.left.val\n        else:\n          stack.append(root.left)\n      if root.right:\n        stack.append(root.right)\n\n    return ans",
      "title": "404. Sum of Left Leaves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94579be2-a7ab-4600-bc23-c92a891c95f1",
      "code": "class Solution:\n  def toHex(self, num: int) -> str:\n    if num == 0:\n      return '0'\n\n    hex = '0123456789abcdef'\n    ans = []\n\n    # Handling negative numbers by using 32-bit unsigned representation Python's\n    # bitwise operation works on signed numbers, so we convert to 32-bit\n    # unsigned for negative numbers.\n    if num < 0:\n      num += 2**32\n\n    while num > 0:\n      ans.append(hex[num & 0xF])\n      num >>= 4\n\n    return ''.join(reversed(ans))",
      "title": "405. Convert a Number to Hexadecimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0bc3db1-608a-47bb-808f-1fafceb21935",
      "code": "class Solution:\n  def reconstructQueue(self, people: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for person in people:\n      ans.insert(person[1], person)\n\n    return ans",
      "title": "406. Queue Reconstruction by Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0407a86-a99b-4137-be30-135ecb68097d",
      "code": "class Solution:\n  def trapRainWater(self, heightMap: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          # Fill water in grid[x][y].\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans",
      "title": "407. Trapping Rain Water II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7a25b7c-d3d6-460e-a8f3-53b7ba068f74",
      "code": "class Solution:\n  def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n    i = 0  # word's index\n    j = 0  # abbr's index\n\n    while i < len(word) and j < len(abbr):\n      if word[i] == abbr[j]:\n        i += 1\n        j += 1\n        continue\n      if not abbr[j].isdigit() or abbr[j] == '0':\n        return False\n      num = 0\n      while j < len(abbr) and abbr[j].isdigit():\n        num = num * 10 + int(abbr[j])\n        j += 1\n      i += num\n\n    return i == len(word) and j == len(abbr)",
      "title": "408. Valid Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2ad7956-d366-4d65-bf4c-d8a4bb514964",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n\n    for c in count.values():\n      ans += c if c % 2 == 0 else c - 1\n\n    hasOddCount = any(c % 2 == 1 for c in count.values())\n    return ans + hasOddCount",
      "title": "409. Longest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc337d4e-6c14-4839-b518-c78acbcc932d",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # dp[i][k] := the minimum of the maximum sum to split the first i numbers\n    # into k groups\n    dp = [[math.inf] * (k + 1) for _ in range(n + 1)]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n + 1):\n      dp[i][1] = prefix[i]\n\n    for l in range(2, k + 1):\n      for i in range(l, n + 1):\n        for j in range(l - 1, i):\n          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]))\n\n    return dp[n][k]",
      "title": "410. Split Array Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d3b4c2-ba12-4f7e-864b-b7cb323d5e72",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum of the maximum sum to split the first i numbers into\n      k groups.\n      \"\"\"\n      if k == 1:\n        return prefix[i]\n      return min(max(dp(j, k - 1), prefix[i] - prefix[j])\n                 for j in range(k - 1, i))\n\n    return dp(len(nums), k)",
      "title": "410. Split Array Largest Sum_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f3c35f2-430c-4491-afb4-992247b17f4d",
      "code": "class Solution:\n  def minAbbreviation(self, target: str, dictionary: list[str]) -> str:\n    m = len(target)\n\n    def getMask(word: str) -> int:\n      # mask[i] = 0 := target[i] == word[i]\n      # mask[i] = 1 := target[i] != word[i]\n      # e.g. target = \"apple\"\n      #        word = \"blade\"\n      #        mask =  11110\n      mask = 0\n      for i, c in enumerate(word):\n        if c != target[i]:\n          mask |= 1 << m - 1 - i\n      return mask\n\n    masks = [getMask(word) for word in dictionary if len(word) == m]\n    if not masks:\n      return str(m)\n\n    abbrs = []\n\n    def getAbbr(cand: int) -> str:\n      abbr = []\n      replacedCount = 0\n      for i, c in enumerate(target):\n        if cand >> m - 1 - i & 1:\n          # If cand[i] = 1, `abbr` should show the original character.\n          if replacedCount:\n            abbr += str(replacedCount)\n          abbr.append(c)\n          replacedCount = 0\n        else:\n          # If cand[i] = 0, `abbr` can be replaced.\n          replacedCount += 1\n      if replacedCount:\n        abbr.append(str(replacedCount))\n      return ''.join(abbr)\n\n    # all the candidate representation of the target\n    for cand in range(2**m):\n      # All the masks have at lease one bit different from the candidate.\n      if all(cand & mask for mask in masks):\n        abbr = getAbbr(cand)\n        abbrs.append(abbr)\n\n    def getAbbrLen(abbr: str) -> int:\n      abbrLen = 0\n      i = 0\n      j = 0\n      while i < len(abbr):\n        if abbr[j].isalpha():\n          j += 1\n        else:\n          while j < len(abbr) and abbr[j].isdigit():\n            j += 1\n        abbrLen += 1\n        i = j\n      return abbrLen\n\n    return min(abbrs, key=lambda x: getAbbrLen(x))",
      "title": "411. Minimum Unique Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31b52f83-7349-478e-9bbd-64517a13ab89",
      "code": "class Solution:\n  def fizzBuzz(self, n: int) -> list[str]:\n    d = {3: 'Fizz', 5: 'Buzz'}\n    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]",
      "title": "412. Fizz Buzz",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4672130b-ff37-4c46-9cfd-3847437c43f1",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return 0\n\n    dp = [0] * n  # dp[i] := the number of arithmetic slices ending in index i\n\n    for i in range(2, len(nums)):\n      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n        dp[i] = dp[i - 1] + 1\n\n    return sum(dp)",
      "title": "413. Arithmetic Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8db4799d-95b7-4057-8995-c16221d86011",
      "code": "class Solution:\n  def thirdMax(self, nums: list[int]) -> int:\n    max1 = -math.inf  # the maximum\n    max2 = -math.inf  # the second maximum\n    max3 = -math.inf  # the third maximum\n\n    for num in nums:\n      if num > max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif max1 > num and num > max2:\n        max3 = max2\n        max2 = num\n      elif max2 > num and num > max3:\n        max3 = num\n\n    return max1 if max3 == -math.inf else max3",
      "title": "414. Third Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca7564bd-e4a0-49d7-9246-de1fdc8deea8",
      "code": "class Solution:\n  def addStrings(self, num1: str, num2: str) -> str:\n    ans = []\n    carry = 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(num1[i])\n      if j >= 0:\n        carry += int(num2[j])\n      ans.append(str(carry % 10))\n      carry //= 10\n      i -= 1\n      j -= 1\n\n    return ''.join(reversed(ans))",
      "title": "415. Add Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8e1315e-2ee8-48bd-a058-792882e2558f",
      "code": "class Solution:\n  def canPartition(self, nums: list[int]) -> bool:\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:\n    n = len(nums)\n    # dp[i][j] := True if j can be formed by nums[0..i)\n    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(subsetSum + 1):\n        if j < num:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]\n\n    return dp[n][subsetSum]",
      "title": "416. Partition Equal Subset Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41bd9738-3cf2-496a-a101-f0380fbe8ece",
      "code": "class Solution:\n  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: deque, seen: list[list[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    return [[i, j] for i in range(m) for j in range(n) if seenP[i][j] and seenA[i][j]]",
      "title": "417. Pacific Atlantic Water Flow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78fea63b-ef84-4938-8cfe-da987ee79abe",
      "code": "class Solution:\n  def wordsTyping(self, sentence: list[str], rows: int, cols: int) -> int:\n    combined = ' '.join(sentence) + ' '\n    n = len(combined)\n    i = 0\n\n    for _ in range(rows):\n      i += cols\n      if combined[i % n] == ' ':\n        i += 1\n      else:\n        while i > 0 and combined[(i - 1) % n] != ' ':\n          i -= 1\n\n    return i // n",
      "title": "418. Sentence Screen Fitting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f5e9123-57d3-476c-a5eb-a09829cdb7ad",
      "code": "class Solution:\n  def countBattleships(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i, row in enumerate(board):\n      for j, cell in enumerate(row):\n        if cell == '.':\n          continue\n        if i > 0 and board[i - 1][j] == 'X':\n          continue\n        if j > 0 and board[i][j - 1] == 'X':\n          continue\n        ans += 1\n\n    return ans",
      "title": "419. Battleships in a Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3335b42e-80fa-44ce-a4dd-a1d4932ed37f",
      "code": "class Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    # the number of replacements to deal with 3 repeating characters\n    replaces = 0\n    # the number of sequences that can be substituted with 1 deletions,\n    # (3k)-seqs\n    oneSeq = 0\n    # the number of sequences that can be substituted with 2 deletions,\n    # (3k + 1)-seqs\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2  # the length of the repeating password\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3  # 'aaaaaaa' -> 'aaxaaxa'\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    # Each replacement in (3k)-seqs can be substituted with 1 deletions.\n    replaces -= min(oneSeq, deletes)\n    # Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    # Each replacement in other seqs can be substituted with 3 deletions.\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return (3\n            - any(c.isupper() for c in password)\n            - any(c.islower() for c in password)\n            - any(c.isdigit() for c in password))",
      "title": "420. Strong Password Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d49f2100-18bb-46bc-bbb2-adff11d8eb3f",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def findMaximumXOR(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      ans = max(ans, bitTrie.getMaxXor(num))\n      bitTrie.insert(num)\n\n    return ans",
      "title": "421. Maximum XOR of Two Numbers in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f31b9962-acaa-4529-9f80-518503605be0",
      "code": "class Solution:\n  def validWordSquare(self, words: list[str]) -> bool:\n    for i, word in enumerate(words):\n      for j, c in enumerate(word):\n        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds\n          return False\n        if c != words[j][i]:\n          return False\n    return True",
      "title": "422. Valid Word Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7b47f37-3ddc-4c43-98e3-51615afcc0f4",
      "code": "class Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count)\n                   for _ in range(c))",
      "title": "423. Reconstruct Original Digits from English",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0e7b102-b2ac-4aae-a10b-c31daab2e2e3",
      "code": "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    maxCount = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n\n    return r - l + 1",
      "title": "424. Longest Repeating Character Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "176b00d3-b8c0-4c82-8d53-3fe8a0a12560",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.startsWith: list[str] = []\n\n\nclass Trie:\n  def __init__(self, words: list[str]):\n    self.root = TrieNode()\n    for word in words:\n      self._insert(word)\n\n  def findBy(self, prefix: str) -> list[str]:\n    node = self.root\n    for c in prefix:\n      if c not in node.children:\n        return []\n      node = node.children[c]\n    return node.startsWith\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n      node.startsWith.append(word)\n\n\nclass Solution:\n  def wordSquares(self, words: list[str]) -> list[list[str]]:\n    if not words:\n      return []\n\n    n = len(words[0])\n    ans = []\n    path = []\n    trie = Trie(words)\n\n    for word in words:\n      path.append(word)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n    return ans\n\n  def _dfs(self, trie: Trie, n: int, path: list[str], ans: list[list[str]]):\n    if len(path) == n:\n      ans.append(path.copy())\n      return\n\n    prefix = self._getPrefix(path)\n\n    for s in trie.findBy(prefix):\n      path.append(s)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n  def _getPrefix(self, path: list[str]) -> str:\n    \"\"\"\n    e.g. path = [\"wall\",\n                 \"area\"]\n       prefix =  \"le..\"\n    \"\"\"\n    prefix = []\n    index = len(path)\n    for s in path:\n      prefix.append(s[index])\n    return ''.join(prefix)",
      "title": "425. Word Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d819cbd-6df1-4324-89ce-cf31a6a990e3",
      "code": "class Solution:\n  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n    leftHead = self.treeToDoublyList(root.left)\n    rightHead = self.treeToDoublyList(root.right)\n    root.left = root\n    root.right = root\n    return self._connect(self._connect(leftHead, root), rightHead)\n\n  def _connect(self, node1: 'Node | None', node2: 'Node | None') -> 'Node | None':\n    if not node1:\n      return node2\n    if not node2:\n      return node1\n\n    tail1 = node1.left\n    tail2 = node2.left\n\n    # Connect node1's tail with node2.\n    tail1.right = node2\n    node2.left = tail1\n\n    # Connect node2's tail with node1.\n    tail2.right = node1\n    node1.left = tail2\n    return node1",
      "title": "426. Convert Binary Search Tree to Sorted Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "757aecd4-6189-4154-8ebc-14ea08813fa7",
      "code": "class Solution:\n  def construct(self, grid: list[list[int]]) -> 'Node':\n    return self._helper(grid, 0, 0, len(grid))\n\n  def _helper(self, grid: list[list[int]], i: int, j: int, w: int) -> 'Node':\n    if self._allSame(grid, i, j, w):\n      return Node(grid[i][j] == 1, True)\n    half = w // 2\n    return Node(True, False,\n                self._helper(grid, i, j, half),\n                self._helper(grid, i, j + half, half),\n                self._helper(grid, i + half, j, half),\n                self._helper(grid, i + half, j + half, half))\n\n  def _allSame(self, grid: list[list[int]], i: int, j: int, w: int) -> bool:\n    return all(grid[x][y] == grid[i][j]\n               for x in range(i, i + w)\n               for y in range(j, j + w))",
      "title": "427. Construct Quad Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a43e0367-705d-400e-a2a0-0e8a3a92094c",
      "code": "class Solution:\n  def levelOrder(self, root: 'Node') -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        for child in node.children:\n          q.append(child)\n      ans.append(currLevel)\n\n    return ans",
      "title": "429. N-ary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9377dff3-2b01-4554-ab1b-21aa4ee30181",
      "code": "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    curr = head\n\n    while curr:\n      if curr.child:\n        cachedNext = curr.next\n        curr.next = curr.child\n        curr.child.prev = curr\n        curr.child = None\n        tail = curr.next\n        while tail.next:\n          tail = tail.next\n        tail.next = cachedNext\n        if cachedNext:\n          cachedNext.prev = tail\n      curr = curr.next\n\n    return head",
      "title": "430. Flatten a Multilevel Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5655b329-8008-40fd-b69b-480ccb3c04c2",
      "code": "class Solution:\n  def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:\n    bankSet = set(bank)\n    if endGene not in bankSet:\n      return -1\n\n    GENES = 'ACGT'\n    q = collections.deque([startGene])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for j, cache in enumerate(wordList):\n          for c in GENES:\n            wordList[j] = c\n            word = ''.join(wordList)\n            if word == endGene:\n              return step\n            if word in bankSet:\n              bankSet.remove(word)\n              q.append(word)\n          wordList[j] = cache\n      step += 1\n\n    return -1",
      "title": "433. Minimum Genetic Mutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16d9576-893e-423e-bca9-5a9682a264b1",
      "code": "class Solution:\n  def countSegments(self, s: str) -> int:\n    return len(s.split())",
      "title": "434. Number of Segments in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d488210-4128-4769-be2c-f5e59f90c288",
      "code": "class Solution:\n  def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans",
      "title": "435. Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "beba2b18-f894-4d42-b34d-54c88e747260",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def findRightInterval(self, intervals: list[list[int]]) -> list[int]:\n    ans = []\n    startToIndex = SortedDict()\n\n    for i, (start, end) in enumerate(intervals):\n      startToIndex[start] = i\n\n    for start, end in intervals:\n      i = startToIndex.bisect_left(end)\n      ans.append(-1 if i == len(startToIndex) else startToIndex.peekitem(i)[1])\n\n    return ans",
      "title": "436. Find Right Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "218ab973-b3f1-4c54-b3ad-ec3c9c812367",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode | None, summ: int) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode, summ: int) -> int:\n      if not root:\n        return 0\n      return (int(summ == root.val) +\n              dfs(root.left, summ - root.val) +\n              dfs(root.right, summ - root.val))\n\n    return (dfs(root, summ) +\n            self.pathSum(root.left, summ) +\n            self.pathSum(root.right, summ))",
      "title": "437. Path Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16d3e722-d58f-42e8-8f94-b4c947ec4408",
      "code": "class Solution:\n  def findAnagrams(self, s: str, p: str) -> list[int]:\n    ans = []\n    count = collections.Counter(p)\n    required = len(p)\n\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(p):\n        count[s[r - len(p)]] += 1\n        if count[s[r - len(p)]] > 0:\n          required += 1\n      if required == 0:\n        ans.append(r - len(p) + 1)\n\n    return ans",
      "title": "438. Find All Anagrams in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84530e0c-273c-4d3a-a07e-d44a729fb73d",
      "code": "class Solution:\n  def parseTernary(self, expression: str) -> str:\n    c = expression[self.i]\n\n    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':\n      self.i += 2\n      return str(c)\n\n    self.i += 2\n    first = self.parseTernary(expression)\n    second = self.parseTernary(expression)\n\n    return first if c == 'T' else second\n\n  i = 0",
      "title": "439. Ternary Expression Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fb7868e-ff57-474f-8d8e-bbd83f03096d",
      "code": "class Solution:\n  def findKthNumber(self, n: int, k: int) -> int:\n    ans = 1\n\n    i = 1\n    while i < k:\n      gap = self._getGap(ans, ans + 1, n)\n      if i + gap <= k:\n        i += gap\n        ans += 1\n      else:\n        i += 1\n        ans *= 10\n\n    return ans\n\n  def _getGap(self, a: int, b: int, n: int) -> int:\n    gap = 0\n    while a <= n:\n      gap += min(n + 1, b) - a\n      a *= 10\n      b *= 10\n    return gap",
      "title": "440. K-th Smallest in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "883a7286-a55c-4945-ad52-3547bdd40061",
      "code": "class Solution:\n  def arrangeCoins(self, n: int) -> int:\n    return int((-1 + math.sqrt(8 * n + 1)) // 2)",
      "title": "441. Arranging Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bcc0e78-d02c-482c-af60-d539caff073f",
      "code": "class Solution:\n  def findDuplicates(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      nums[abs(num) - 1] *= -1\n      if nums[abs(num) - 1] > 0:\n        ans.append(abs(num))\n\n    return ans",
      "title": "442. Find All Duplicates in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87dc8d49-ac98-42ed-a873-0e13575b34ba",
      "code": "class Solution:\n  def compress(self, chars: list[str]) -> int:\n    ans = 0\n    i = 0\n\n    while i < len(chars):\n      letter = chars[i]\n      count = 0\n      while i < len(chars) and chars[i] == letter:\n        count += 1\n        i += 1\n      chars[ans] = letter\n      ans += 1\n      if count > 1:\n        for c in str(count):\n          chars[ans] = c\n          ans += 1\n\n    return ans",
      "title": "443. String Compression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2e72968-4828-4336-a159-8888c00d669f",
      "code": "class Solution:\n  def sequenceReconstruction(\n      self,\n      org: list[int],\n      seqs: list[list[int]],\n  ) -> bool:\n    if not seqs:\n      return False\n\n    n = len(org)\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for seq in seqs:\n      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:\n        return False\n      for u, v in zip(seq, seq[1:]):\n        if u < 1 or u > n or v < 1 or v > n:\n          return False\n        graph[u - 1].append(v - 1)\n        inDegrees[v - 1] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n    i = 0  # org's index\n\n    while q:\n      if len(q) > 1:\n        return False\n      u = q.popleft()\n      if u != org[i] - 1:\n        return False\n      i += 1\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return i == n",
      "title": "444. Sequence Reconstruction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29ba11ee-df60-4e93-a05c-741cb43674e3",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    stack1 = []\n    stack2 = []\n\n    while l1:\n      stack1.append(l1)\n      l1 = l1.next\n\n    while l2:\n      stack2.append(l2)\n      l2 = l2.next\n\n    head = None\n    carry = 0\n\n    while carry or stack1 or stack2:\n      if stack1:\n        carry += stack1.pop().val\n      if stack2:\n        carry += stack2.pop().val\n      node = ListNode(carry % 10)\n      node.next = head\n      head = node\n      carry //= 10\n\n    return head",
      "title": "445. Add Two Numbers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e039a0eb-92c3-4695-a9cb-345b10df1aa2",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][j] := the number of subsequences end in nums[j] nums[i]\n    dp = [[0] * n for _ in range(n)]\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for i in range(n):\n      for j in range(i):\n        target = nums[j] * 2 - nums[i]\n        if target in numToIndices:\n          for k in numToIndices[target]:\n            if k < j:\n              dp[i][j] += dp[j][k] + 1\n        ans += dp[i][j]\n\n    return ans",
      "title": "446. Arithmetic Slices II - Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d772fd-674f-435d-a134-ed389160a3e3",
      "code": "class Solution:\n  def numberOfBoomerangs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.Counter()\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans",
      "title": "447. Number of Boomerangs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06a9551b-1842-44cc-a085-db6e1dde25dc",
      "code": "class Solution:\n  def findDisappearedNumbers(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      index = abs(num) - 1\n      nums[index] = -abs(nums[index])\n\n    return [i + 1 for i, num in enumerate(nums) if num > 0]",
      "title": "448. Find All Numbers Disappeared in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96a5d4d9-6d9e-4d75-a1e4-6ee03eebd562",
      "code": "class Solution:\n  def deleteNode(self, root: TreeNode | None, key: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == key:\n      if not root.left:\n        return root.right\n      if not root.right:\n        return root.left\n      minNode = self._getMin(root.right)\n      root.right = self.deleteNode(root.right, minNode.val)\n      minNode.left = root.left\n      minNode.right = root.right\n      root = minNode\n    elif root.val < key:\n      root.right = self.deleteNode(root.right, key)\n    else:  # root.val > key\n      root.left = self.deleteNode(root.left, key)\n    return root\n\n  def _getMin(self, node: TreeNode | None) -> TreeNode | None:\n    while node.left:\n      node = node.left\n    return node",
      "title": "450. Delete Node in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b746f17c-b6b0-47e1-a401-257dd88d873f",
      "code": "class Solution:\n  def frequencySort(self, s: str) -> str:\n    ans = []\n    buckets = [[] for _ in range(len(s) + 1)]\n\n    for c, freq in collections.Counter(s).items():\n      buckets[freq].append(c)\n\n    for freq in reversed(range(len(buckets))):\n      for c in buckets[freq]:\n        ans.append(c * freq)\n\n    return ''.join(ans)",
      "title": "451. Sort Characters By Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "775b84bc-49ad-4274-b85f-28a385ae525a",
      "code": "class Solution:\n  def findMinArrowShots(self, points: list[list[int]]) -> int:\n    ans = 0\n    arrowX = -math.inf\n\n    for point in sorted(points, key=lambda x: x[1]):\n      if point[0] > arrowX:\n        ans += 1\n        arrowX = point[1]\n\n    return ans",
      "title": "452. Minimum Number of Arrows to Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db2a657a-148c-4760-9e72-eaac14e110ff",
      "code": "class Solution:\n  def minMoves(self, nums: list[int]) -> int:\n    mn = min(nums)\n    return sum(num - mn for num in nums)",
      "title": "453. Minimum Moves to Equal Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f033ca6-3a75-4f1c-9e2e-1633c441a5c0",
      "code": "class Solution:\n  def fourSumCount(self, nums1: list[int], nums2: list[int],\n                   nums3: list[int], nums4: list[int]) -> int:\n    count = collections.Counter(a + b for a in nums1 for b in nums2)\n    return sum(count[-c - d] for c in nums3 for d in nums4)",
      "title": "454. 4Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45b16b13-5595-4a0b-810d-24a120a1dc90",
      "code": "class Solution:\n  def findContentChildren(self, g: list[int], s: list[int]) -> int:\n    g.sort()\n    s.sort()\n\n    i = 0\n    for cookie in s:\n      if i < len(g) and g[i] <= cookie:\n        i += 1\n\n    return i",
      "title": "455. Assign Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7449137-20f4-44b6-913d-1cba97103d37",
      "code": "class Solution:\n  def find132pattern(self, nums: list[int]) -> bool:\n    stack = []  # a decreasing stack\n    ak = -math.inf  # Find a seq, where ai < ak < aj.\n\n    for num in reversed(nums):\n      # If ai < ak, done because ai must < aj.\n      if num < ak:\n        return True\n      while stack and stack[-1] < num:\n        ak = stack[-1]\n        stack.pop()\n      stack.append(num)  # `nums[i]` is a candidate of aj.\n\n    return False",
      "title": "456. 132 Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39651bc8-b483-4945-80fb-22e2aa3c678b",
      "code": "class Solution:\n  def circularArrayLoop(self, nums: list[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False",
      "title": "457. Circular Array Loop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdf79d88-f9c8-46b5-9a86-e066b10a2961",
      "code": "class Solution:\n  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    base = minutesToTest // minutesToDie + 1\n    ans = 0\n    x = 1\n    while x < buckets:\n      ans += 1\n      x *= base\n    return ans",
      "title": "458. Poor Pigs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e68ca7de-4c4d-44b3-b772-245516c13c15",
      "code": "class Solution:\n  def repeatedSubstringPattern(self, s: str) -> bool:\n    return s in (s + s)[1:-1]",
      "title": "459. Repeated Substring Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ced195-b7fa-4850-8ac5-7366251c7552",
      "code": "class Solution:\n  def hammingDistance(self, x: int, y: int) -> int:\n    ans = 0\n\n    while x > 0 or y > 0:\n      ans += (x & 1) ^ (y & 1)\n      x >>= 1\n      y >>= 1\n\n    return ans",
      "title": "461. Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ad84836-6389-4e44-86c1-23b35014bd1a",
      "code": "import statistics\n\n\nclass Solution:\n  def minMoves2(self, nums: list[int]) -> int:\n    median = int(statistics.median(nums))\n    return sum(abs(num - median) for num in nums)",
      "title": "462. Minimum Moves to Equal Array Elements II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "692c22f6-bf94-42dc-b564-7d89856eff9e",
      "code": "class Solution:\n  def islandPerimeter(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    islands = 0\n    neighbors = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          islands += 1\n          if i + 1 < m and grid[i + 1][j] == 1:\n            neighbors += 1\n          if j + 1 < n and grid[i][j + 1] == 1:\n            neighbors += 1\n\n    return islands * 4 - neighbors * 2",
      "title": "463. Island Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfc764b2-41a1-4434-9e1a-a898a17f33b9",
      "code": "class Solution:\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n    if desiredTotal <= 0:\n      return True\n\n    totalSum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n    if totalSum < desiredTotal:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(total: int, used: int) -> bool:\n      \"\"\"\n      Returns true if the first player can we, where `used` represents the use\n      numbers.\n      \"\"\"\n      if total <= 0:\n        return False\n      return any((used >> i & 1) == 0\n                 and not dp(total - i, used | 1 << i)\n                 for i in range(1, maxChoosableInteger + 1))\n\n    return dp(desiredTotal, 0)",
      "title": "464. Can I Win",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cab11f1c-c647-4ac0-aa96-ff504f9eba5d",
      "code": "class Solution:\n  def minTransfers(self, transactions: list[list[int]]) -> int:\n    balance = [0] * 21\n\n    for u, v, amount in transactions:\n      balance[u] -= amount\n      balance[v] += amount\n\n    debts = [b for b in balance if b]\n\n    def dfs(s: int) -> int:\n      while s < len(debts) and not debts[s]:\n        s += 1\n      if s == len(debts):\n        return 0\n\n      ans = math.inf\n\n      for i in range(s + 1, len(debts)):\n        if debts[i] * debts[s] < 0:\n          debts[i] += debts[s]  # `debts[s]` is settled.\n          ans = min(ans, 1 + dfs(s + 1))\n          debts[i] -= debts[s]  # Backtrack.\n\n      return ans\n\n    return dfs(0)",
      "title": "465. Optimal Account Balancing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2827b4b4-6fff-4586-8a28-f15a593ec143",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Record:\n  count: int\n  nextIndex: int\n\n\nclass Solution:\n  def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n    # records[i].count := the number of times that s2 starting from index i has\n    # been fully matched with s1\n    # records[i].nextIndex := the next index in s2 to be matched after\n    # completing a full match starting from index i\n    records = []\n\n    for nextIndex in range(len(s2)):\n      count = 0\n      for c in s1:\n        if s2[nextIndex] == c:\n          nextIndex += 1\n          if nextIndex == len(s2):  # There's a match.\n            count += 1\n            nextIndex = 0\n      records.append(Record(count, nextIndex))\n\n    matches = 0  # the number of matches between `s1` x n1 and `s2`\n    i = 0  # the index in `s2` to start matching\n\n    for _ in range(n1):\n      matches += records[i].count\n      i = records[i].nextIndex\n\n    return matches // n2",
      "title": "466. Count The Repetitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3afd19a-fe37-4ec9-8fa3-742614943326",
      "code": "class Solution:\n  def findSubstringInWraproundString(self, s: str) -> int:\n    maxLength = 1\n    # count[i] := the number of substrings ending in ('a' + i)\n    count = [0] * 26\n\n    for i in range(len(s)):\n      if i > 0 and (ord(s[i]) - ord(s[i - 1]) == 1\n                    or ord(s[i - 1]) - ord(s[i]) == 25):\n        maxLength += 1\n      else:\n        maxLength = 1\n      index = ord(s[i]) - ord('a')\n      count[index] = max(count[index], maxLength)\n\n    return sum(count)",
      "title": "467. Unique Substrings in Wraparound String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b92c372-5216-43c8-89ba-f46fcc9629d9",
      "code": "class Solution:\n  def validIPAddress(self, queryIP: str) -> str:\n    if queryIP.count('.') == 3:\n      parts = queryIP.split('.')\n      if len(parts) == 4 and all(self._isIPv4(part) for part in parts):\n        return 'IPv4'\n\n    if queryIP.count(':') == 7:\n      parts = queryIP.split(':')\n      if len(parts) == 8 and all(self._isIPv6(part) for part in parts):\n        return 'IPv6'\n\n    return 'Neither'\n\n  def _isIPv4(self, digit: str) -> bool:\n    if not digit or len(digit) > 3:\n      return False\n    if len(digit) > 1 and digit[0] == '0':\n      return False\n    if not all(c.isdigit() for c in digit):\n      return False\n    num = int(digit)\n    return 0 <= num <= 255\n\n  def _isIPv6(self, digit: str) -> bool:\n    if not digit or len(digit) > 4:\n      return False\n    validChars = set('0123456789abcdefABCDEF')\n    return all(c in validChars for c in digit)",
      "title": "468. Validate IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2d62e64-a0c4-404e-82b3-ae6db17c16c5",
      "code": "class Solution:\n  def isConvex(self, points: list[list[int]]) -> bool:\n    def getCross(p: list[int], q: list[int], r: list[int]):\n      \"\"\"Returns pq x qr.\"\"\"\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    sign = 0\n    for i in range(len(points)):\n      cross = getCross(points[i - 2], points[i - 1], points[i])\n      if cross == 0:  # p, q, r are collinear.\n        continue\n      if sign == 0:  # Find the first cross that's not 0.\n        sign = cross\n      elif cross * sign < 0:\n        return False\n\n    return True",
      "title": "469. Convex Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "febf4395-5435-4a8b-a291-11d0e88cb57a",
      "code": "# The rand7() API is already defined for you.\n# def rand7():\n# @return a random integer in the range 1 to 7\n\nclass Solution:\n  def rand10(self) -> int:\n    num = 40\n    while num >= 40:\n      num = (rand7() - 1) * 7 + (rand7() - 1)\n    return num % 10 + 1",
      "title": "470. Implement Rand10() Using Rand7()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe907a4d-3495-4959-ab51-000726acf89a",
      "code": "class Solution:\n  def encode(self, s: str) -> str:\n    n = len(s)\n    # dp[i][j] := the shortest encoded string of s[i..j]\n    dp = [[''] * n for _ in range(n)]\n\n    for d in range(n):\n      for i in range(n - d):\n        j = i + d\n        curr = s[i:j + 1]\n        dp[i][j] = curr\n\n        if len(dp[i][j]) < 5:\n          continue\n\n        # Try all the possible partitions.\n        for k in range(i, j):\n          if len(dp[i][k]) + len(dp[k + 1][j]) < len(dp[i][j]):\n            dp[i][j] = dp[i][k] + dp[k + 1][j]\n\n        # Try to compress the string.\n        # e.g. s = aabaabaab -> 3[aab]\n        for k in range(i, j):\n          pattern = s[i:k + 1]\n          if len(curr) % len(pattern) == 0 and pattern * (len(curr) //\n                                                          len(pattern)) == curr:\n            candidate = f\"{len(curr) // len(pattern)}[{dp[i][k]}]\"\n            if len(candidate) < len(dp[i][j]):\n              dp[i][j] = candidate\n\n    return dp[0][n - 1]",
      "title": "471. Encode String with Shortest Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73ca9b31-ca6a-4d98-9be5-30e00c4de6af",
      "code": "class Solution:\n  def findAllConcatenatedWordsInADict(self, words: list[str]) -> list[str]:\n    wordSet = set(words)\n\n    @functools.lru_cache(None)\n    def isConcat(word: str) -> bool:\n      for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\n          return True\n\n      return False\n\n    return [word for word in words if isConcat(word)]",
      "title": "472. Concatenated Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41775672-2dc6-47d5-9d15-06bfface2659",
      "code": "class Solution:\n  def makesquare(self, matchsticks: list[int]) -> bool:\n    if len(matchsticks) < 4:\n      return False\n\n    perimeter = sum(matchsticks)\n    if perimeter % 4 != 0:\n      return False\n\n    A = sorted(matchsticks)[::-1]\n\n    def dfs(selected: int, edges: list[int]) -> bool:\n      if selected == len(A):\n        return all(edge == edges[0] for edge in edges)\n\n      for i, edge in enumerate(edges):\n        if A[selected] > edge:\n          continue\n        edges[i] -= A[selected]\n        if dfs(selected + 1, edges):\n          return True\n        edges[i] += A[selected]\n\n      return False\n\n    return dfs(0, [perimeter // 4] * 4)",
      "title": "473. Matchsticks to Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c6eb761-4f46-4ffe-807a-2641e6702ae7",
      "code": "class Solution:\n  def findMaxForm(self, strs: list[str], m: int, n: int) -> int:\n    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are\n    # available\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n      zeros = s.count('0')\n      ones = len(s) - zeros\n      for i in range(m, zeros - 1, -1):\n        for j in range(n, ones - 1, -1):\n          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    return dp[m][n]",
      "title": "474. Ones and Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63f55b33-8ade-4fe4-8533-690c47b05ea6",
      "code": "class Solution:\n  def totalHammingDistance(self, nums: list[int]) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      ones = sum(num & (1 << i) > 0 for num in nums)\n      zeros = len(nums) - ones\n      ans += ones * zeros\n\n    return ans",
      "title": "477. Total Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d949a67-98b6-4015-b41c-c99e4e733607",
      "code": "class Solution:\n  def __init__(self, radius: float, x_center: float, y_center: float):\n    self.radius = radius\n    self.x_center = x_center\n    self.y_center = y_center\n\n  def randPoint(self) -> list[float]:\n    length = math.sqrt(random.uniform(0, 1)) * self.radius\n    degree = random.uniform(0, 1) * 2 * math.pi\n    x = self.x_center + length * math.cos(degree)\n    y = self.y_center + length * math.sin(degree)\n    return [x, y]",
      "title": "478. Generate Random Point in a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89dccdb8-988e-4c59-afae-c352e9fd7941",
      "code": "class Solution:\n  def largestPalindrome(self, n: int) -> int:\n    if n == 1:\n      return 9\n\n    MOD = 1337\n    upper = pow(10, n) - 1\n    lower = pow(10, n - 1) - 1\n\n    for i in range(upper, lower, -1):\n      cand = int(str(i) + str(i)[::-1])\n      j = upper\n      while j * j >= cand:\n        if cand % j == 0:\n          return cand % MOD\n        j -= 1",
      "title": "479. Largest Palindrome Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b673700-f08d-4d1e-96a7-46a26c714d90",
      "code": "class Solution:\n  def magicalString(self, n: int) -> int:\n    s = [' ', '1', '2', '2']\n\n    for i in range(3, n + 1):\n      if i % 2 == 1:\n        s.extend(['1'] * (int(s[i])))\n      else:\n        s.extend(['2'] * (int(s[i])))\n\n    return sum(1 for c in s[:n + 1] if c == '1')",
      "title": "481. Magical String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13d981b9-b83d-46b6-a511-323a9154a292",
      "code": "class Solution:\n  def licenseKeyFormatting(self, s: str, k: int) -> str:\n    ans = []\n    length = 0\n\n    for i in reversed(range(len(s))):\n      if s[i] == '-':\n        continue\n      if length > 0 and length % k == 0:\n        ans += '-'\n      ans += s[i].upper()\n      length += 1\n\n    return ''.join(reversed(ans))",
      "title": "482. License Key Formatting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f196c632-0d0b-4404-83f7-80ebd4c7d9e2",
      "code": "class Solution:\n  def smallestGoodBase(self, n: str) -> str:\n    n = int(n)\n\n    for m in range(int(math.log(n, 2)), 1, -1):\n      k = int(n**m**-1)\n      if (k**(m + 1) - 1) // (k - 1) == n:\n        return str(k)\n\n    return str(n - 1)",
      "title": "483. Smallest Good Base",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6878fc-bf9d-4ecf-988c-40bc548f3399",
      "code": "class Solution:\n  def findPermutation(self, s: str) -> list[int]:\n    ans = [i for i in range(1, len(s) + 2)]\n\n    # For each D* group (s[i..j]), reverse ans[i..j + 1].\n    i = -1\n    j = -1\n\n    def getNextIndex(c: str, start: int) -> int:\n      for i in range(start, len(s)):\n        if s[i] == c:\n          return i\n      return len(s)\n\n    while True:\n      i = getNextIndex('D', j + 1)\n      if i == len(s):\n        break\n      j = getNextIndex('I', i + 1)\n      ans[i:j + 1] = ans[i:j + 1][::-1]\n\n    return ans",
      "title": "484. Find Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fd84bdc-53b6-4420-a823-89f2a18db7dc",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    summ = 0\n\n    for num in nums:\n      if num == 0:\n        summ = 0\n      else:\n        summ += num\n        ans = max(ans, summ)\n\n    return ans",
      "title": "485. Max Consecutive Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "358a6414-baa8-481f-87e1-581f520809e0",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    maxZeros = 1\n    ans = 0\n    q = collections.deque()  # Store indices of zero.\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        q.append(r)\n      if len(q) > maxZeros:\n        l = q.popleft() + 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f6bd8b9-22bc-48ba-9a00-cbab9f93e511",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3bd843b-5556-4dee-b8d4-3437d86629ea",
      "code": "class Solution:\n  def findMinStep(self, board: str, hand: str) -> int:\n    def deDup(board):\n      start = 0  # the start index of a color sequenece\n      for i, c in enumerate(board):\n        if c != board[start]:\n          if i - start >= 3:\n            return deDup(board[:start] + board[i:])\n          start = i  # Meet a new sequence.\n      return board\n\n    @functools.lru_cache(None)\n    def dfs(board: str, hand: str):\n      board = deDup(board)\n      if board == '#':\n        return 0\n\n      boardSet = set(board)\n      # hand that is in board\n      hand = ''.join(h for h in hand if h in boardSet)\n      if not hand:  # infeasible\n        return math.inf\n\n      ans = math.inf\n\n      for i in range(len(board)):\n        for j, h in enumerate(hand):\n          # Place hs[j] in board[i].\n          newHand = hand[:j] + hand[j + 1:]\n          newBoard = board[:i] + h + board[i:]\n          ans = min(ans, 1 + dfs(newBoard, newHand))\n\n      return ans\n\n    ans = dfs(board + '#', hand)\n    return -1 if ans == math.inf else ans",
      "title": "488. Zuma Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e139044e-9d1d-45db-a01d-c471eeee655d",
      "code": "class Solution:\n  def hasPath(\n      self,\n      maze: list[list[int]],\n      start: list[int],\n      destination: list[int],\n  ) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(start[0], start[1])])\n    seen = {(start[0], start[1])}\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i\n        y = j\n        while isValid(x + dx, y + dy):\n          x += dx\n          y += dy\n        if [x, y] == destination:\n          return True\n        if (x, y) in seen:\n          continue\n        q.append((x, y))\n        seen.add((x, y))\n\n    return False",
      "title": "490. The Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c864ce3f-ee2d-4638-a26c-389c917f0d32",
      "code": "class Solution:\n  def findSubsequences(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) > 1:\n        ans.append(path)\n\n      used = set()\n\n      for i in range(s, len(nums)):\n        if nums[i] in used:\n          continue\n        if not path or nums[i] >= path[-1]:\n          used.add(nums[i])\n          dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "491. Increasing Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3e25371-ede4-4074-9722-a3ad604f0b9a",
      "code": "class Solution:\n  def findTargetSumWays(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) % 2 == 1:\n      return 0\n\n    def knapsack(nums: list[int], target: int) -> int:\n      # dp[i] := the number of ways to sum to i by nums so far\n      dp = [0] * (target + 1)\n      dp[0] = 1\n\n      for num in nums:\n        for i in range(target, num - 1, -1):\n          dp[i] += dp[i - num]\n\n      return dp[target]\n\n    return knapsack(nums, (summ + target) // 2)",
      "title": "494. Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56df8569-9d39-4c5a-aaf0-9492218737ce",
      "code": "class Solution:\n  def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\n    if duration == 0:\n      return 0\n\n    ans = 0\n\n    for i in range(0, len(timeSeries) - 1):\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration)\n\n    return ans + duration",
      "title": "495. Teemo Attacking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6080e12-f871-4b78-a824-7775087144d3",
      "code": "class Solution:\n  def nextGreaterElement(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToNextGreater = {}\n    stack = []  # a decreasing stack\n\n    for num in nums2:\n      while stack and stack[-1] < num:\n        numToNextGreater[stack.pop()] = num\n      stack.append(num)\n\n    return [numToNextGreater.get(num, -1) for num in nums1]",
      "title": "496. Next Greater Element I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f213564-cc93-45f1-b5e7-eb359518a881",
      "code": "class Solution:\n  def __init__(self, rects: list[list[int]]):\n    self.rects = rects\n    self.areas = list(itertools.accumulate(\n        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))\n\n  def pick(self) -> list[int]:\n    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))\n    x1, y1, x2, y2 = self.rects[index]\n    return [random.randint(x1, x2), random.randint(y1, y2)]",
      "title": "497. Random Point in Non-overlapping Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e906b040-691d-49e7-90a4-2ac609936766",
      "code": "class Solution:\n  def findShortestWay(\n      self,\n      maze: list[list[int]],\n      ball: list[int],\n      hole: list[int],\n  ) -> str:\n    ans = 'impossible'\n    minSteps = math.inf\n\n    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):\n      nonlocal ans\n      nonlocal minSteps\n      if steps >= minSteps:\n        return\n\n      if dx != 0 or dy != 0:  # Both are zeros for the initial ball position.\n        while (0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and\n               maze[i + dx][j + dy] != 1):\n          i += dx\n          j += dy\n          steps += 1\n          if i == hole[0] and j == hole[1] and steps < minSteps:\n            minSteps = steps\n            ans = path\n\n      if maze[i][j] == 0 or steps + 2 < maze[i][j]:\n        maze[i][j] = steps + 2  # +2 because maze[i][j] == 0 || 1.\n        if dx == 0:\n          dfs(i, j, 1, 0, steps, path + 'd')\n        if dy == 0:\n          dfs(i, j, 0, -1, steps, path + 'l')\n        if dy == 0:\n          dfs(i, j, 0, 1, steps, path + 'r')\n        if dx == 0:\n          dfs(i, j, -1, 0, steps, path + 'u')\n\n    dfs(ball[0], ball[1], 0, 0, 0, '')\n    return ans",
      "title": "499. The Maze III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a7c5fdb-973c-47df-b01b-6dfc76f9cf9e",
      "code": "class Solution:\n  def findWords(self, words: list[str]) -> list[str]:\n    ans = []\n    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n\n    for word in words:\n      lowerWord = set(word.lower())\n      if any(lowerWord <= row for row in rows):\n        ans.append(word)\n\n    return ans",
      "title": "500. Keyboard Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7d3a8ca-c278-48b0-9fb8-04ab0f4272ab",
      "code": "class Solution:\n  def findMode(self, root: TreeNode | None) -> list[int]:\n    self.ans = []\n    self.pred = None\n    self.count = 0\n    self.maxCount = 0\n\n    def updateCount(root: TreeNode | None) -> None:\n      if self.pred and self.pred.val == root.val:\n        self.count += 1\n      else:\n        self.count = 1\n\n      if self.count > self.maxCount:\n        self.maxCount = self.count\n        self.ans = [root.val]\n      elif self.count == self.maxCount:\n        self.ans.append(root.val)\n\n      self.pred = root\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      updateCount(root)\n      inorder(root.right)\n\n    inorder(root)\n    return self.ans",
      "title": "501. Find Mode in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54519651-cd43-463f-a7dc-766549b9d0c6",
      "code": "class Solution:\n  def nextGreaterElements(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [-1] * n\n    stack = []  # a decreasing stack storing indices\n\n    for i in range(n * 2):\n      num = nums[i % n]\n      while stack and nums[stack[-1]] < num:\n        ans[stack.pop()] = num\n      if i < n:\n        stack.append(i)\n\n    return ans",
      "title": "503. Next Greater Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48d5d268-0e26-4ae2-ad5c-14cf99c24b0a",
      "code": "class Solution:\n  def checkPerfectNumber(self, num: int) -> bool:\n    return num in {6, 28, 496, 8128, 33550336}",
      "title": "507. Perfect Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c821786-deaf-41b6-9a41-df37b687c9c7",
      "code": "class Solution:\n  def findFrequentTreeSum(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    count = collections.Counter()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      count[summ] += 1\n      return summ\n\n    dfs(root)\n    maxFreq = max(count.values())\n    return [summ for summ in count if count[summ] == maxFreq]",
      "title": "508. Most Frequent Subtree Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b68f20a-df80-4ea0-a3b1-406428ad001d",
      "code": "class Solution:\n  def fib(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 0, 1]\n\n    for i in range(2, n + 1):\n      dp[0] = dp[1]\n      dp[1] = dp[2]\n      dp[2] = dp[0] + dp[1]\n\n    return dp[2]",
      "title": "509. Fibonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7a40fae-f03b-40e6-93ec-cab9592751b8",
      "code": "class Solution:\n  def findBottomLeftValue(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxDepth = 0\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      nonlocal ans\n      nonlocal maxDepth\n      if not root:\n        return\n      if depth > maxDepth:\n        maxDepth = depth\n        ans = root.val\n\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 1)\n    return ans",
      "title": "513. Find Bottom Left Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffc09968-80c4-45b6-be37-11884b45d0ba",
      "code": "class Solution:\n  def findRotateSteps(self, ring: str, key: str) -> int:\n    @functools.lru_cache(None)\n    def dfs(ring: str, index: int) -> int:\n      \"\"\"Returns the number of rotates of ring to match key[index..n).\"\"\"\n      if index == len(key):\n        return 0\n\n      ans = math.inf\n\n      # For each ring[i] == key[index], we rotate the ring to match the ring[i]\n      # with the key[index], then recursively match the newRing with the\n      # key[index + 1..n).\n      for i, r in enumerate(ring):\n        if r == key[index]:\n          minRotates = min(i, len(ring) - i)\n          newRing = ring[i:] + ring[:i]\n          remainingRotates = dfs(newRing, index + 1)\n          ans = min(ans, minRotates + remainingRotates)\n\n      return ans\n\n    return dfs(ring, 0) + len(key)",
      "title": "514. Freedom Trail",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc9b86f6-c104-4ccf-b0a8-80092d663709",
      "code": "class Solution:\n  def largestValues(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      mx = -math.inf\n      for _ in range(len(q)):\n        root = q.popleft()\n        mx = max(mx, root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n      ans.append(mx)\n\n    return ans",
      "title": "515. Find Largest Value in Each Tree Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16b8bd0-fc29-481f-b605-3ce070f1cc57",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "516. Longest Palindromic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20e9bb60-3d3b-4a5b-99e3-82aeca499f00",
      "code": "class Solution:\n  def findMinMoves(self, machines: list[int]) -> int:\n    dresses = sum(machines)\n\n    if dresses % len(machines) != 0:\n      return -1\n\n    ans = 0\n    average = dresses // len(machines)\n    inout = 0\n\n    for dress in machines:\n      inout += dress - average\n      ans = max(ans, abs(inout), dress - average)\n\n    return ans",
      "title": "517. Super Washing Machines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b85bad6-c774-4016-bbf6-ef38ed7377b5",
      "code": "class Solution:\n  def change(self, amount: int, coins: list[int]) -> int:\n    dp = [1] + [0] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] += dp[i - coin]\n\n    return dp[amount]",
      "title": "518. Coin Change 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a56e475-6629-4479-9d4d-f498e3c9a502",
      "code": "class Solution:\n  def detectCapitalUse(self, word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()",
      "title": "520. Detect Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bf6e182-341f-41ac-9cca-c2f22d26a92a",
      "code": "class Solution:\n  def findLUSlength(self, a: str, b: str) -> int:\n    return -1 if a == b else max(len(a), len(b))",
      "title": "521. Longest Uncommon Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0272cd12-9e54-4808-b1b7-81da2572d3a5",
      "code": "class Solution:\n  def findLUSlength(self, strs: list[str]) -> int:\n    def isSubsequence(a: str, b: str) -> bool:\n      i = 0\n      j = 0\n\n      while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n          i += 1\n        j += 1\n\n      return i == len(a)\n\n    seen = set()\n    duplicates = set()\n\n    for s in strs:\n      if s in seen:\n        duplicates.add(s)\n      seen.add(s)\n\n    strs.sort(key=lambda x: -len(x))\n\n    for i in range(len(strs)):\n      if strs[i] in duplicates:\n        continue\n      isASubsequence = False\n      for j in range(i):\n        isASubsequence |= isSubsequence(strs[i], strs[j])\n      if not isASubsequence:\n        return len(strs[i])\n\n    return -1",
      "title": "522. Longest Uncommon Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b4a1a3a-7e98-4794-b483-e7a70a352a63",
      "code": "class Solution:\n  def checkSubarraySum(self, nums: list[int], k: int) -> bool:\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      if k != 0:\n        prefix %= k\n      if prefix in prefixToIndex:\n        if i - prefixToIndex[prefix] > 1:\n          return True\n      else:\n        # Set a new key if it's absent because the previous index is better.\n        prefixToIndex[prefix] = i\n\n    return False",
      "title": "523. Continuous Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "037fed65-8151-4527-8912-f65545372424",
      "code": "class Solution:\n  def findLongestWord(self, s: str, d: list[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans",
      "title": "524. Longest Word in Dictionary through Deleting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f173bf13-5c40-4c60-be11-f2fd0dc2f101",
      "code": "class Solution:\n  def findMaxLength(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += 1 if num else -1\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "525. Contiguous Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dca5a1e0-90c1-4348-9f07-29b517439621",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedWord:\n  word: str\n  index: int\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n    ans = [''] * n\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    abbrevToIndexedWords = collections.defaultdict(list)\n\n    for i, word in enumerate(words):\n      abbrev = getAbbrev(word, 0)\n      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))\n\n    def insertWord(root: TrieNode | None, word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    def firstUniqueIndex(root: TrieNode | None, word: str) -> None:\n      node = root\n      for i, c in enumerate(word):\n        node = node.children[c]\n        if node.count == 1:\n          return i\n      return len(word)\n\n    for indexedWords in abbrevToIndexedWords.values():\n      root = TrieNode()\n      for iw in indexedWords:\n        insertWord(root, iw.word)\n      for iw in indexedWords:\n        index = firstUniqueIndex(root, iw.word)\n        ans[iw.index] = getAbbrev(iw.word, index)\n\n    return ans",
      "title": "527. Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58361010-7d28-4839-9716-fe614541a311",
      "code": "class Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    ans = [getAbbrev(word, 0) for word in words]\n    # prefix[i] := ans[i] takes words[i][0..prefix[i]]\n    prefix = [0] * n\n\n    for i in range(n):\n      while True:\n        dupeIndices = []\n        for j in range(i + 1, n):\n          if ans[i] == ans[j]:\n            dupeIndices.append(j)\n        if not dupeIndices:\n          break\n        dupeIndices.append(i)\n        for index in dupeIndices:\n          prefix[index] += 1\n          ans[index] = getAbbrev(words[index], prefix[index])\n\n    return ans",
      "title": "527. Word Abbreviation_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8991cb8-a41e-4e60-9c08-c19f186ac544",
      "code": "class Solution:\n  def __init__(self, w: list[int]):\n    self.prefix = list(itertools.accumulate(w))\n\n  def pickIndex(self) -> int:\n    target = random.randint(0, self.prefix[-1] - 1)\n    return bisect.bisect_right(range(len(self.prefix)), target,\n                               key=lambda m: self.prefix[m])",
      "title": "528. Random Pick with Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caac6c0d-45cc-47b9-b8dd-d678ad140c71",
      "code": "class Solution:\n  def updateBoard(self, board: list[list[str]],\n                  click: list[int]) -> list[list[str]]:\n    i, j = click\n    if board[i][j] == 'M':\n      board[i][j] = 'X'\n      return board\n\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    def getMinesCount(i: int, j: int) -> int:\n      minesCount = 0\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):\n          continue\n        if board[x][y] == 'M':\n          minesCount += 1\n      return minesCount\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(board) or j < 0 or j == len(board[0]):\n        return\n      if board[i][j] != 'E':\n        return\n\n      minesCount = getMinesCount(i, j)\n      board[i][j] = 'B' if minesCount == 0 else str(minesCount)\n\n      if minesCount == 0:\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy)\n\n    dfs(i, j)\n    return board",
      "title": "529. Minesweeper",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36bef5f1-d19f-4f64-ae9d-0ea6c3be2162",
      "code": "class Solution:\n  def findLonelyPixel(self, picture: list[list[str]]) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [0] * m  # rows[i] := the number of B's in rows i\n    cols = [0] * n  # cols[i] := the number of B's in cols i\n\n    for i in range(m):\n      for j in range(n):\n        if picture[i][j] == 'B':\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.\n        for j in range(n):\n          # After meeting a 'B' in this rows, break and search the next row.\n          if picture[i][j] == 'B':\n            if cols[j] == 1:\n              ans += 1\n            break\n\n    return ans",
      "title": "531. Lonely Pixel I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab5b9bca-ee80-4621-bfbf-fa7c33175043",
      "code": "class Solution:\n  def findPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for i, num in enumerate(nums):\n      target = num + k\n      if target in numToIndex and numToIndex[target] != i:\n        ans += 1\n        del numToIndex[target]\n\n    return ans",
      "title": "532. K-diff Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "520ac19d-8d7c-45f0-9292-fc545f711624",
      "code": "class Solution:\n  def findBlackPixel(self, picture: list[list[str]], target: int) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [row.count('B') for row in picture]\n    cols = [col.count('B') for col in zip(*picture)]\n    rowStrings = [''.join(row) for row in picture]\n    countRowStrings = collections.Counter(rowStrings)\n\n    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):\n      if row == target and countRowStrings[stringRow] == target:\n        for j, col in enumerate(cols):\n          if picture[i][j] == 'B' and col == target:\n            ans += 1\n\n    return ans",
      "title": "533. Lonely Pixel II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d53dd0cc-ca24-481e-817a-ebb28a88cd21",
      "code": "class Solution:\n  def complexNumberMultiply(self, num1: str, num2: str) -> str:\n    a0, a1 = self._getReala0ndImag(num1)\n    b0, b1 = self._getReala0ndImag(num2)\n    return str(a0 * b0 - a1 * b1) + '+' + str(a0 * b1 + a1 * b0) + 'i'\n\n  def _getReala0ndImag(self, s: str) -> tuple:\n    return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])",
      "title": "537. Complex Number Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b2f2541-c2fd-42e7-b8f3-e52fe5fe14ac",
      "code": "class Solution:\n  def convertBST(self, root: TreeNode | None) -> TreeNode | None:\n    prefix = 0\n\n    def reversedInorder(root: TreeNode | None) -> None:\n      nonlocal prefix\n      if not root:\n        return\n\n      reversedInorder(root.right)\n      prefix += root.val\n      root.val = prefix\n      reversedInorder(root.left)\n\n    reversedInorder(root)\n    return root",
      "title": "538. Convert BST to Greater Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58f381e2-b6f4-42ef-8575-7cb85b12b9d7",
      "code": "class Solution:\n  def findMinDifference(self, timePoints: list[str]) -> int:\n    ans = 24 * 60\n    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])\n                   for timePoint in timePoints])\n\n    for a, b in zip(nums, nums[1:]):\n      ans = min(ans, b - a)\n\n    return min(ans, 24 * 60 - nums[-1] + nums[0])",
      "title": "539. Minimum Time Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2efb1a19-fc53-4380-8593-90fdf55f877d",
      "code": "class Solution:\n  def singleNonDuplicate(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if m % 2 == 1:\n        m -= 1\n      if nums[m] == nums[m + 1]:\n        l = m + 2\n      else:\n        r = m\n\n    return nums[l]",
      "title": "540. Single Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a49c42d-487c-4366-a7c0-997578309ad9",
      "code": "class Solution:\n  def reverseStr(self, s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2 * k] + self.reverseStr(s[2 * k:], k) if s else \"\"",
      "title": "541. Reverse String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e44dd46d-f708-4b7e-8ab2-0e60c2b65d0d",
      "code": "class Solution:\n  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat",
      "title": "542. 01 Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "becaf76f-f5b5-43fd-ba4c-32619505bf16",
      "code": "class Solution:\n  def diameterOfBinaryTree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def maxDepth(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = maxDepth(root.left)\n      r = maxDepth(root.right)\n      ans = max(ans, l + r)\n      return 1 + max(l, r)\n\n    maxDepth(root)\n    return ans",
      "title": "543. Diameter of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60355be9-cc1a-4f28-b27a-12bc0c9c359c",
      "code": "class Solution:\n  def findContestMatch(self, n: int) -> str:\n    def generateMatches(matches: list[str]) -> str:\n      if len(matches) == 1:\n        return matches[0]\n\n      nextMatches = []\n\n      for i in range(len(matches) // 2):\n        nextMatches.append(\n            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')\n\n      return generateMatches(nextMatches)\n\n    return generateMatches([str(i + 1) for i in range(n)])",
      "title": "544. Output Contest Matches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5efd69b8-cffb-4da6-a612-c51d215cd56e",
      "code": "class Solution:\n  def boundaryOfBinaryTree(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = [root.val]\n\n    def dfs(root: TreeNode | None, lb: bool, rb: bool):\n      \"\"\"\n      1. root.left is left boundary if root is left boundary.\n         root.right if left boundary if root.left is None.\n      2. Same applys for right boundary.\n      3. If root is left boundary, add it before 2 children - preorder.\n         If root is right boundary, add it after 2 children - postorder.\n      4. A leaf that is neighter left/right boundary belongs to the bottom.\n      \"\"\"\n      if not root:\n        return\n      if lb:\n        ans.append(root.val)\n      if not lb and not rb and not root.left and not root.right:\n        ans.append(root.val)\n\n      dfs(root.left, lb, rb and not root.right)\n      dfs(root.right, lb and not root.left, rb)\n      if rb:\n        ans.append(root.val)\n\n    dfs(root.left, True, False)\n    dfs(root.right, False, True)\n    return ans",
      "title": "545. Boundary of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8a18525-9ec4-42de-8c1f-941e88a70ca2",
      "code": "class Solution:\n  def removeBoxes(self, boxes: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].\n      \"\"\"\n      if i > j:\n        return 0\n\n      r = j\n      sameBoxes = k + 1\n      while r > 0 and boxes[r - 1] == boxes[r]:\n        r -= 1\n        sameBoxes += 1\n      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes\n\n      for p in range(i, r):\n        if boxes[p] == boxes[r]:\n          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))\n\n      return res\n\n    return dp(0, len(boxes) - 1, 0)",
      "title": "546. Remove Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce3e7d5-168e-45ba-b860-21731744e06c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: list[list[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count",
      "title": "547. Friend Circles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5db17a15-ba13-4dfd-94b3-32395c333a77",
      "code": "class Solution:\n  def checkRecord(self, s: str) -> bool:\n    return s.count('A') <= 1 and 'LLL' not in s",
      "title": "551. Student Attendance Record I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5120e2b-fc1d-4bf1-8779-2726f216fd14",
      "code": "class Solution:\n  def checkRecord(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the length so far with i A's and the last letters are j L's\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1\n\n    for _ in range(n):\n      prev = [A[:] for A in dp]\n\n      # Append a P.\n      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % MOD\n\n      # Append an L.\n      dp[0][1] = prev[0][0]\n\n      # Append an L.\n      dp[0][2] = prev[0][1]\n\n      # Append an A or append a P.\n      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +\n                  prev[1][0] + prev[1][1] + prev[1][2]) % MOD\n\n      # Append an L.\n      dp[1][1] = prev[1][0]\n\n      # Append an L.\n      dp[1][2] = prev[1][1]\n\n    return (sum(dp[0]) + sum(dp[1])) % MOD",
      "title": "552. Student Attendance Record II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fed631e9-f8dc-46c1-815f-744f64c917cd",
      "code": "class Solution:\n  def optimalDivision(self, nums: list[int]) -> str:\n    ans = str(nums[0])\n\n    if len(nums) == 1:\n      return ans\n    if len(nums) == 2:\n      return ans + '/' + str(nums[1])\n\n    ans += '/(' + str(nums[1])\n    for i in range(2, len(nums)):\n      ans += '/' + str(nums[i])\n    ans += ')'\n    return ans",
      "title": "553. Optimal Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "341d74c4-dc9f-4a76-beba-4bf02aa7b859",
      "code": "class Solution:\n  def leastBricks(self, wall: list[list[int]]) -> int:\n    maxFreq = 0\n    count = collections.defaultdict(int)\n\n    for row in wall:\n      prefix = 0\n      for i in range(len(row) - 1):\n        prefix += row[i]\n        count[prefix] += 1\n        maxFreq = max(maxFreq, count[prefix])\n\n    return len(wall) - maxFreq",
      "title": "554. Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bdf6dc-0ee8-4a48-9d16-a88936663c05",
      "code": "class Solution:\n  def splitLoopedString(self, strs: list[str]) -> str:\n    ans = ''\n    sortedStrs = [max(s, s[::-1]) for s in strs]\n\n    for i, sortedStr in enumerate(sortedStrs):\n      for s in (sortedStr, sortedStr[::-1]):\n        for j in range(len(s) + 1):\n          ans = max(\n              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])\n\n    return ans",
      "title": "555. Split Concatenated Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "145617e8-a200-4947-a71c-aba22b43f846",
      "code": "class Solution:\n  def nextGreaterElement(self, n: int) -> int:\n    def nextPermutation(s: list[str]) -> str:\n      i = len(s) - 2\n      while i >= 0:\n        if s[i] < s[i + 1]:\n          break\n        i -= 1\n\n      if i >= 0:\n        for j in range(len(s) - 1, i, -1):\n          if s[j] > s[i]:\n            break\n        s[i], s[j] = s[j], s[i]\n\n      reverse(s, i + 1, len(s) - 1)\n      return ''.join(s)\n\n    def reverse(s: list[str], l: int, r: int):\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    s = nextPermutation(list(str(n)))\n    ans = int(s)\n    return -1 if ans > 2**31 - 1 or ans <= n else ans",
      "title": "556. Next Greater Element III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aacab23-e831-4c41-a774-acfce58ae47c",
      "code": "class Solution:\n  def maxDepth(self, root: 'Node') -> int:\n    if not root:\n      return 0\n    if not root.children:\n      return 1\n    return 1 + max(self.maxDepth(child) for child in root.children)",
      "title": "559. Maximum Depth of N-ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0915ccee-593c-4312-9bbb-2ce58b384f1f",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix += num\n      ans += count[prefix - k]\n      count[prefix] += 1\n\n    return ans",
      "title": "560. Subarray Sum Equals K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "023ef533-10db-4357-b228-ea16ebf1c9a4",
      "code": "class Solution:\n  def arrayPairSum(self, nums: list[int]) -> int:\n    return sum(sorted(nums)[::2])",
      "title": "561. Array Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93d66a90-fb12-4344-8ef0-8abd24a63c0e",
      "code": "class Solution:\n  def longestLine(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    # dp[i][j][0] := horizontal\n    # dp[i][j][1] := vertical\n    # dp[i][j][2] := diagonal\n    # dp[i][j][3] := anti-diagonal\n    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1\n          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1\n          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1\n          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1\n          ans = max(ans, max(dp[i][j]))\n\n    return ans",
      "title": "562. Longest Line of Consecutive One in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dbd633b-a77c-4416-a673-82534e1cb2ea",
      "code": "class Solution:\n  def findTilt(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def summ(root: TreeNode | None) -> None:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = summ(root.left)\n      r = summ(root.right)\n      ans += abs(l - r)\n      return root.val + l + r\n\n    summ(root)\n    return ans",
      "title": "563. Binary Tree Tilt",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "369abe30-1fe5-45ba-9f35-545b1769c13f",
      "code": "class Solution:\n  def nearestPalindromic(self, n: str) -> str:\n    prevPalindrome, nextPalindrome = self._getPalindromes(n)\n    return (str(prevPalindrome)\n            if abs(prevPalindrome - int(n)) <= abs(nextPalindrome - int(n))\n            else str(nextPalindrome))\n\n  def _getPalindromes(self, s: str) -> tuple[str, str]:\n    \"\"\"Returns the two closest palindromes to the given number.\"\"\"\n    num = int(s)\n    sz = len(s)\n    palindromes = []\n    half = s[0:(sz + 1) // 2]\n    reversedHalf = half[:sz // 2][::-1]\n    candidate = int(half + reversedHalf)\n\n    if candidate < num:\n      palindromes.append(candidate)\n    else:\n      prevHalf = str(int(half) - 1)\n      reversedPrevHalf = prevHalf[:sz // 2][::-1]\n      if sz % 2 == 0 and int(prevHalf) == 0:\n        palindromes.append(9)\n      elif sz % 2 == 0 and prevHalf == '9':\n        palindromes.append(int(prevHalf + '9' + reversedPrevHalf))\n      else:\n        palindromes.append(int(prevHalf + reversedPrevHalf))\n\n    if candidate > num:\n      palindromes.append(candidate)\n    else:\n      nextHalf = str(int(half) + 1)\n      reversedNextHalf = nextHalf[:sz // 2][::-1]\n      palindromes.append(int(nextHalf + reversedNextHalf))\n\n    return palindromes",
      "title": "564. Find the Closest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6f987ba-ba86-492b-838b-c8eb6061382d",
      "code": "class Solution:\n  def arrayNesting(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if num == -1:\n        continue\n      index = num\n      count = 0\n      while nums[index] != -1:\n        cache = index\n        index = nums[index]\n        nums[cache] = -1\n        count += 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "565. Array Nesting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}