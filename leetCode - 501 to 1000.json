{
  "snippets": [
    {
      "id": "e49bd92a-d1a1-4562-9567-e2e951342adf",
      "code": "class Solution:\n  def matrixReshape(self, nums: list[list[int]],\n                    r: int, c: int) -> list[list[int]]:\n    if nums == [] or r * c != len(nums) * len(nums[0]):\n      return nums\n\n    ans = [[0 for j in range(c)] for i in range(r)]\n    k = 0\n\n    for row in nums:\n      for num in row:\n        ans[k // c][k % c] = num\n        k += 1\n\n    return ans",
      "title": "566. Reshape the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07d99d2d-23c1-401f-bc1d-efafa7ac309a",
      "code": "class Solution:\n  def checkInclusion(self, s1: str, s2: str) -> bool:\n    count = collections.Counter(s1)\n    required = len(s1)\n\n    for r, c in enumerate(s2):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(s1):  # The window is oversized.\n        count[s2[r - len(s1)]] += 1\n        if count[s2[r - len(s1)]] > 0:\n          required += 1\n      if required == 0:\n        return True\n\n    return False",
      "title": "567. Permutation in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fb4947d-05da-4ca8-97ae-1c5be3d4c95d",
      "code": "class Solution:\n  def minDistance(\n      self,\n      height: int,\n      width: int,\n      tree: list[int],\n      squirrel: list[int],\n      nuts: list[list[int]],\n  ) -> int:\n    def dist(a: list[int], b: list[int]) -> int:\n      return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    totDist = sum(dist(nut, tree) for nut in nuts) * 2\n    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)\n    return totDist - maxSave",
      "title": "573. Squirrel Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c49d4a6-6a93-4ec2-8dd0-aad3caf823cf",
      "code": "class Solution:\n  def distributeCandies(self, candies: list[int]) -> int:\n    return min(len(candies) // 2, len(set(candies)))",
      "title": "575. Distribute Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "286b93aa-6430-4715-bef1-0c43f62425bc",
      "code": "class Solution:\n  def findPaths(\n      self,\n      m: int,\n      n: int,\n      maxMove: int,\n      startRow: int,\n      startColumn: int,\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n\n    for _ in range(maxMove):\n      newDp = [[0] * n for _ in range(m)]\n      for i in range(m):\n        for j in range(n):\n          if dp[i][j] > 0:\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                ans = (ans + dp[i][j]) % MOD\n              else:\n                newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return ans",
      "title": "576. Out of Boundary Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60999680-23e2-4d2e-a856-d74eea199de3",
      "code": "class Solution:\n  def findUnsortedSubarray(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mn = min(mn, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        mx = max(mx, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mn:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < mx:\n        break\n\n    return 0 if l >= r else r - l + 1",
      "title": "581. Shortest Unsorted Continuous Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d98e88ca-8ccf-48c1-a0bb-b65bbff93c1d",
      "code": "class Solution:\n  def killProcess(\n      self,\n      pid: list[int],\n      ppid: list[int],\n      kill: int,\n  ) -> list[int]:\n    ans = []\n    tree = collections.defaultdict(list)\n\n    for v, u in zip(pid, ppid):\n      if u == 0:\n        continue\n      tree[u].append(v)\n\n    def dfs(u: int) -> None:\n      ans.append(u)\n      for v in tree.get(u, []):\n        dfs(v)\n\n    dfs(kill)\n    return ans",
      "title": "582. Kill Process",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdebc36e-e3e3-43f2-b0a9-56960c04069c",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    k = self._lcs(word1, word2)\n    return (len(word1) - k) + (len(word2) - k)\n\n  def _lcs(self, a: str, b: str) -> int:\n    m = len(a)\n    n = len(b)\n    # dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if a[i - 1] == b[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]",
      "title": "583. Delete Operation for Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6de03e59-5f1c-4fa7-a072-a857bc16ecd9",
      "code": "class Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\n    hull = []\n\n    trees.sort(key=lambda x: (x[0], x[1]))\n\n    def cross(p: list[int], q: list[int], r: list[int]) -> int:\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\n    # Build the lower hull: left-to-right scan.\n    for tree in trees:\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n    hull.pop()\n\n    # Build the upper hull: right-to-left scan.\n    for tree in reversed(trees):\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n\n    # Remove the redundant elements from the stack.\n    return list(set(hull))",
      "title": "587. Erect the Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5173a7f5-692a-4aee-9364-41d074797d45",
      "code": "class Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        # It's inside a tag, so check if it's a cdata.\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':  # the end tag\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 2: closeIndex],\n                  True):\n            return False\n        else:  # the start tag\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 1: closeIndex],\n                  False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag",
      "title": "591. Tag Validator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58170964-1e0b-4908-8b61-5f1df6c45646",
      "code": "class Solution:\n  def fractionAddition(self, expression: str) -> str:\n    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))\n    A = 0\n    B = 1\n\n    for a, b in zip(ints[::2], ints[1::2]):\n      A = A * b + a * B\n      B *= b\n      g = math.gcd(A, B)\n      A //= g\n      B //= g\n\n    return str(A) + '/' + str(B)",
      "title": "592. Fraction Addition and Subtraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48efa6e7-004d-4dd9-aa16-6a2042f0d17b",
      "code": "class Solution:\n  def validSquare(\n      self,\n      p1: list[int],\n      p2: list[int],\n      p3: list[int],\n      p4: list[int],\n  ) -> bool:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    distSet = set([dist(*pair)\n                   for pair in list(\n                       itertools.combinations([p1, p2, p3, p4], 2))])\n    return 0 not in distSet and len(distSet) == 2",
      "title": "593. Valid Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b33ba733-e863-4c0d-a9a1-83ad5fb1e880",
      "code": "class Solution:\n  def findLHS(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num + 1 in count:\n        ans = max(ans, freq + count[num + 1])\n\n    return ans",
      "title": "594. Longest Harmonious Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05f59df5-3a8a-428c-b0fd-e5d16c29422d",
      "code": "class Solution:\n  def maxCount(self, m: int, n: int, ops: list[list[int]]) -> int:\n    minY = m\n    minX = n\n\n    for y, x in ops:\n      minY = min(minY, y)\n      minX = min(minX, x)\n\n    return minX * minY",
      "title": "598. Range Addition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50382cff-97ed-4937-9c26-230252ec0581",
      "code": "class Solution:\n  def findRestaurant(self, list1: list[str], list2: list[str]) -> list[str]:\n    ans = []\n    restaurantToIndex = {restaurant: i for i,\n                         restaurant in enumerate(list1)}\n    minSum = math.inf\n\n    for i, restaurant in enumerate(list2):\n      if restaurant in restaurantToIndex:\n        summ = restaurantToIndex[restaurant] + i\n        if summ < minSum:\n          ans.clear()\n        if summ <= minSum:\n          ans.append(restaurant)\n          minSum = summ\n\n    return ans",
      "title": "599. Minimum Index Sum of Two Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c0a2292-0335-42fe-9831-51c1dac7d9e2",
      "code": "class Solution:\n  def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:\n    for i, flower in enumerate(flowerbed):\n      if flower == 0 and (\n              i == 0 or flowerbed[i - 1] == 0) and (\n              i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n        flowerbed[i] = 1\n        n -= 1\n      if n <= 0:\n        return True\n\n    return False",
      "title": "605. Can Place Flowers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff76b674-a7c3-45a2-acc3-3867741dfd28",
      "code": "class Solution:\n  def tree2str(self, t: TreeNode | None) -> str:\n    def dfs(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n      if root.right:\n        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'\n      if root.left:\n        return str(root.val) + '(' + dfs(root.left) + ')'\n      return str(root.val)\n    return dfs(t)",
      "title": "606. Construct String from Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a9ea4c5-299d-457e-b288-5c894628a236",
      "code": "class Solution:\n  def findDuplicate(self, paths: list[str]) -> list[list[str]]:\n    contentToPathFiles = collections.defaultdict(list)\n\n    for path in paths:\n      words = path.split(' ')\n      rootPath = words[0]  # \"root/d1/d2/.../dm\"\n      for fileAndContent in words[1:]:  # \"fn.txt(fn_content)\"\n        l = fileAndContent.find('(')\n        r = fileAndContent.find(')')\n        # \"fn.txt\"\n        file = fileAndContent[:l]\n        # \"fn_content\"\n        content = fileAndContent[l + 1:r]\n        # \"root/d1/d2/.../dm/fn.txt\"\n        filePath = rootPath + '/' + file\n        contentToPathFiles[content].append(filePath)\n\n    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]",
      "title": "609. Find Duplicate File in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92a9b80c-5829-4348-89c6-930e1bbd3609",
      "code": "class Solution:\n  def triangleNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for k in range(len(nums) - 1, 1, -1):\n      i = 0\n      j = k - 1\n      while i < j:\n        if nums[i] + nums[j] > nums[k]:\n          ans += j - i\n          j -= 1\n        else:\n          i += 1\n\n    return ans",
      "title": "611. Valid Triangle Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9348b1f-2024-4cfd-8369-c5f57c0b895b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def addBoldTag(self, s: str, words: list[str]) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        if s[j] not in node.children:\n          node.children[s[j]] = TrieNode()\n        node = node.children[s[j]]\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "616. Add Bold Tag in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23533340-b770-4c32-88f9-6bf5192a0d1f",
      "code": "class Solution:\n  def mergeTrees(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root1 and not root2:\n      return None\n    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)\n    root = TreeNode(val)\n    root.left = self.mergeTrees(root1.left if root1 else None,\n                                root2.left if root2 else None)\n    root.right = self.mergeTrees(root1.right if root1 else None,\n                                 root2.right if root2 else None)\n    return root",
      "title": "617. Merge Two Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f9210da-b42d-4a3f-a586-8db7f7c37c68",
      "code": "class Solution:\n  def leastInterval(self, tasks: list[str], n: int) -> int:\n    count = collections.Counter(tasks)\n    maxFreq = max(count.values())\n    # Put the most frequent task in the slot first.\n    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)\n    # Get the number of tasks with same frequency as maxFreq, we'll append them after the\n    # `maxFreqTaskOccupy`.\n    nMaxFreq = sum(value == maxFreq for value in count.values())\n    # max(\n    #   the most frequent task is frequent enough to force some idle slots,\n    #   the most frequent task is not frequent enough to force idle slots\n    # )\n    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))",
      "title": "621. Task Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "076a7311-f99d-4d16-96ea-5e824fef6a35",
      "code": "class Solution:\n  def maxDistance(self, arrays: list[list[int]]) -> int:\n    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))\n    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))\n    if index_min1 != index_max1:\n      return max1 - min1\n\n    min2, index_min2 = min((A[0], i)\n                           for i, A in enumerate(arrays) if i != index_min1)\n    max2, index_min2 = max((A[-1], i)\n                           for i, A in enumerate(arrays) if i != index_max1)\n    return max(max1 - min2, max2 - min1)",
      "title": "624. Maximum Distance in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "785f87a8-f733-4c7c-85af-124f475f78d5",
      "code": "class Solution:\n  def smallestFactorization(self, num: int) -> int:\n    if num == 1:\n      return 1\n\n    ans = 0\n    base = 1\n\n    for i in range(9, 1, -1):\n      while num % i == 0:\n        num //= i\n        ans = base * i + ans\n        base *= 10\n\n    return ans if num == 1 and ans < 2**31 - 1 else 0",
      "title": "625. Minimum Factorization",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cf8898a-1be3-4d96-a6e8-a9a649917423",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int]) -> int:\n    min1 = inf   # the minimum\n    min2 = inf   # the second minimum\n    max1 = -inf  # the maximum\n    max2 = -inf  # the second maximum\n    max3 = -inf  # the third maximum\n\n    for num in nums:\n      if num <= min1:\n        min2 = min1\n        min1 = num\n      elif num <= min2:\n        min2 = num\n\n      if num >= max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif num >= max2:\n        max3 = max2\n        max2 = num\n      elif num >= max3:\n        max3 = num\n\n    return max(max1 * min1 * min2, max1 * max2 * max3)",
      "title": "628. Maximum Product of Three Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3310d34-b558-4742-8252-ee6977ae8ac7",
      "code": "class Solution:\n  def kInversePairs(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # If there's no inverse pair, the permutation is unique '123..i'\n    for i in range(n + 1):\n      dp[i][0] = 1\n\n    for i in range(1, n + 1):\n      for j in range(1, k + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n        if j - i >= 0:\n          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n\n    return dp[n][k]",
      "title": "629. K Inverse Pairs Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a688286a-4cef-4e7e-ba4f-074f9ccc3cdb",
      "code": "class Solution:\n  def scheduleCourse(self, courses: list[list[int]]) -> int:\n    time = 0\n    maxHeap = []\n\n    for duration, lastDay in sorted(courses, key=lambda x: x[1]):\n      heapq.heappush(maxHeap, -duration)\n      time += duration\n      # If the current course cannot be taken, check if it can be swapped with\n      # a previously taken course that has a larger duration to increase the\n      # time available to take upcoming courses.\n      if time > lastDay:\n        time += heapq.heappop(maxHeap)\n\n    return len(maxHeap)",
      "title": "630. Course Schedule III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da4099ef-859b-4cc6-b238-2fd6b79eba43",
      "code": "class Solution:\n  def smallestRange(self, nums: list[list[int]]) -> list[int]:\n    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    maxRange = max(row[0] for row in nums)\n    minRange = heapq.nsmallest(1, minHeap)[0][0]\n    ans = [minRange, maxRange]\n\n    while len(minHeap) == len(nums):\n      num, r, c = heapq.heappop(minHeap)\n      if c + 1 < len(nums[r]):\n        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))\n        maxRange = max(maxRange, nums[r][c + 1])\n        minRange = heapq.nsmallest(1, minHeap)[0][0]\n        if maxRange - minRange < ans[1] - ans[0]:\n          ans[0], ans[1] = minRange, maxRange\n\n    return ans",
      "title": "632. Smallest Range Covering Elements from K Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17f6808c-f085-48be-afd4-b20c1248d412",
      "code": "class Solution:\n  def judgeSquareSum(self, c: int) -> bool:\n    l = 0\n    r = math.isqrt(c)\n\n    while l <= r:\n      summ = l * l + r * r\n      if summ == c:\n        return True\n      if summ < c:\n        l += 1\n      else:\n        r -= 1\n\n    return False",
      "title": "633. Sum of Square Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d0a1915-a50b-4848-a6ad-b138addccf38",
      "code": "class Solution:\n  def findDerangement(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      if i == 0:\n        return 1\n      if i == 1:\n        return 0\n      return (i - 1) * (dp(i - 1) + dp(i - 2)) % MOD\n\n    return dp(n)",
      "title": "634. Find the Derangement of An Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d52b6f4-a2fd-4df7-8e43-e10437e1f8af",
      "code": "class Solution:\n  def shoppingOffers(\n      self,\n      price: list[int],\n      special: list[list[int]],\n      needs: list[int]\n  ) -> int:\n    def dfs(s: int) -> int:\n      ans = 0\n      for i, need in enumerate(needs):\n        ans += need * price[i]\n\n      for i in range(s, len(special)):\n        offer = special[i]\n        if all(offer[j] <= need for j, need in enumerate(needs)):\n          # Use the special[i].\n          for j in range(len(needs)):\n            needs[j] -= offer[j]\n          ans = min(ans, offer[-1] + dfs(i))\n          # Unuse the special[i] (backtracking).\n          for j in range(len(needs)):\n            needs[j] += offer[j]\n\n      return ans\n\n    return dfs(0)",
      "title": "638. Shopping Offers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02f3fccd-6ccf-4e07-a4a9-c7aa399d9b76",
      "code": "class Solution:\n  def solveEquation(self, equation: str) -> str:\n    def calculate(s: str) -> tuple:\n      coefficient = 0\n      constant = 0\n      num = 0\n      sign = 1\n\n      for i, c in enumerate(s):\n        if c.isdigit():\n          num = num * 10 + int(c)\n        elif c in '+-':\n          constant += sign * num\n          sign = 1 if c == '+' else -1\n          num = 0\n        else:\n          if i > 0 and num == 0 and s[i - 1] == '0':\n            continue\n          coefficient += sign if num == 0 else sign * num\n          num = 0\n\n      return coefficient, constant + sign * num\n\n    lhsEquation, rhsEquation = equation.split('=')\n    lhsCoefficient, lhsConstant = calculate(lhsEquation)\n    rhsCoefficient, rhsConstant = calculate(rhsEquation)\n    coefficient = lhsCoefficient - rhsCoefficient\n    constant = rhsConstant - lhsConstant\n\n    if coefficient == 0 and constant == 0:\n      return \"Infinite solutions\"\n    if coefficient == 0 and constant != 0:\n      return \"No solution\"\n    return \"x=\" + str(constant // coefficient)",
      "title": "640. Solve the Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "540f4ab8-ed83-4112-9bc7-14abf7b0090c",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    summ = sum(nums[:k])\n    ans = summ\n\n    for i in range(k, len(nums)):\n      summ += nums[i] - nums[i - k]\n      ans = max(ans, summ)\n\n    return ans / k",
      "title": "643. Maximum Average Subarray I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "622a7ed4-7048-4dc0-8e72-056eabbdc6a4",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    ERR = 1e-5\n    l = min(nums)\n    r = max(nums)\n\n    def check(m: float) -> bool:\n      \"\"\"\n      Returns True if there's a subarray, where its length >= k and its average\n      sum >= m.\n      \"\"\"\n      summ = 0\n      prevSum = 0\n      minPrevSum = 0\n\n      for i, num in enumerate(nums):\n        # Need to substract m for each `num` so that we can check if the sum of\n        # the subarray >= 0.\n        summ += num - m\n        if i >= k:\n          prevSum += nums[i - k] - m\n          minPrevSum = min(minPrevSum, prevSum)\n        if i + 1 >= k and summ >= minPrevSum:\n          return True\n\n      return False\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if check(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "644. Maximum Average Subarray II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c0ceb74-44e9-4e41-8352-83e195a92381",
      "code": "class Solution:\n  def findErrorNums(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      if nums[abs(num) - 1] < 0:\n        duplicate = abs(num)\n      else:\n        nums[abs(num) - 1] *= -1\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        return [duplicate, i + 1]",
      "title": "645. Set Mismatch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7eda17e7-1c93-4497-80a6-7f3013542f3c",
      "code": "class Solution:\n  def findLongestChain(self, pairs: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = -math.inf\n\n    for s, e in sorted(pairs, key=lambda x: x[1]):\n      if s > prevEnd:\n        ans += 1\n        prevEnd = e\n\n    return ans",
      "title": "646. Maximum Length of Pair Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50d84774-d33b-4661-92c1-2fd23dfef3ad",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    def extendPalindromes(l: int, r: int) -> int:\n      count = 0\n\n      while l >= 0 and r < len(s) and s[l] == s[r]:\n        count += 1\n        l -= 1\n        r += 1\n\n      return count\n\n    ans = 0\n\n    for i in range(len(s)):\n      ans += extendPalindromes(i, i)\n      ans += extendPalindromes(i, i + 1)\n\n    return ans",
      "title": "647. Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9e10de1-8ba7-453b-b88f-2d51b1721268",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])",
      "title": "648. Replace Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7f7a374-d0bb-42b2-a764-01166c77a58b",
      "code": "class Solution:\n  def minSteps(self, n: int) -> int:\n    if n <= 1:\n      return 0\n\n    # dp[i] := the minimum steps to get i 'A's\n    # Copy 'A', then paste 'A' i - 1 times.\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n      for j in range(i // 2, 2, -1):\n        if i % j == 0:\n          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.\n          break\n\n    return dp[n]",
      "title": "650. 2 Keys Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33d1a9a9-0b25-48bb-af14-7f2f814b8502",
      "code": "class Solution:\n  def findDuplicateSubtrees(self, root: TreeNode | None) -> list[TreeNode | None]:\n    ans = []\n    count = collections.Counter()\n\n    def encode(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n\n      encoded = (str(root.val) + '#' +\n                 encode(root.left) + '#' +\n                 encode(root.right))\n      count[encoded] += 1\n      if count[encoded] == 2:\n        ans.append(root)\n      return encoded\n\n    encode(root)\n    return ans",
      "title": "652. Find Duplicate Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7ac0b37-6acf-49d1-97d9-7c6580989c9a",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def findTarget(self, root: TreeNode | None, k: int) -> bool:\n    if not root:\n      return False\n\n    left = BSTIterator(root, True)\n    right = BSTIterator(root, False)\n\n    l = left.next()\n    r = right.next()\n    while l < r:\n      summ = l + r\n      if summ == k:\n        return True\n      if summ < k:\n        l = left.next()\n      else:\n        r = right.next()\n\n    return False",
      "title": "653. Two Sum IV - Input is a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5c948fa-d046-49c2-a3f0-442bb04117f4",
      "code": "class Solution:\n  def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode | None:\n    def build(i: int, j: int) -> TreeNode | None:\n      if i > j:\n        return None\n\n      maxNum = max(nums[i:j + 1])\n      maxIndex = nums.index(maxNum)\n\n      root = TreeNode(maxNum)\n      root.left = build(i, maxIndex - 1)\n      root.right = build(maxIndex + 1, j)\n      return root\n\n    return build(0, len(nums) - 1)",
      "title": "654. Maximum Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9806564-4669-4d94-a301-2fb7f9f2b614",
      "code": "class Solution:\n  def printTree(self, root: TreeNode | None) -> list[list[str]]:\n    def maxHeight(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxHeight(root.left), maxHeight(root.right))\n\n    def dfs(root: TreeNode | None, row: int, left: int, right: int) -> None:\n      if not root:\n        return\n\n      mid = (left + right) // 2\n      ans[row][mid] = str(root.val)\n      dfs(root.left, row + 1, left, mid - 1)\n      dfs(root.right, row + 1, mid + 1, right)\n\n    m = maxHeight(root)\n    n = pow(2, m) - 1\n    ans = [[''] * n for _ in range(m)]\n    dfs(root, 0, 0, len(ans[0]) - 1)\n    return ans",
      "title": "655. Print Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92fd84e2-2fe6-4c8c-8674-5153641e98c2",
      "code": "class Solution:\n  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:\n    if coins[-1] == -1:\n      return []\n\n    n = len(coins)\n    # dp[i] := the minimum cost to jump from i to n - 1\n    dp = [math.inf] * n\n    next = [-1] * n\n\n    def cheapestJump(i: int) -> int:\n      if i == len(coins) - 1:\n        dp[i] = coins[i]\n        return dp[i]\n      if dp[i] < math.inf:\n        return dp[i]\n      if coins[i] == -1:\n        return math.inf\n\n      for j in range(i + 1, min(i + maxJump + 1, n)):\n        res = cheapestJump(j)\n        if res == math.inf:\n          continue\n        cost = coins[i] + res\n        if cost < dp[i]:\n          dp[i] = cost\n          next[i] = j\n\n      return dp[i]\n\n    cheapestJump(0)\n    if dp[0] == math.inf:\n      return []\n    return self._constructPath(next, 0)\n\n  def _constructPath(self, next: list[int], i: int) -> list[int]:\n    ans = []\n    while i != -1:\n      ans.append(i + 1)  # 1-indexed\n      i = next[i]\n    return ans",
      "title": "656. Coin Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d741e1b3-13c7-4d75-bf6d-76d3535d643a",
      "code": "class Solution:\n  def judgeCircle(self, moves: str) -> bool:\n    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')",
      "title": "657. Robot Return to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4e31751-a806-4d20-a941-a5b9159ae158",
      "code": "class Solution:\n  def findClosestElements(self, arr: list[int], k: int, x: int) -> list[int]:\n    l = 0\n    r = len(arr) - k\n\n    while l < r:\n      m = (l + r) // 2\n      if x - arr[m] <= arr[m + k] - x:\n        r = m\n      else:\n        l = m + 1\n\n    return arr[l:l + k]",
      "title": "658. Find K Closest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b37df8f-24cc-4e1b-91aa-7983f0fb62a8",
      "code": "class Solution:\n  def newInteger(self, n: int) -> int:\n    ans = []\n    while n:\n      ans.append(str(n % 9))\n      n //= 9\n    return ''.join(reversed(ans))",
      "title": "660. Remove 9",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2c741de-bbd5-4b05-bcc7-35c949a06b31",
      "code": "class Solution:\n  def imageSmoother(self, M: list[list[int]]) -> list[list[int]]:\n    m = len(M)\n    n = len(M[0])\n    ans = [[0 for j in range(n)] for i in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        count = 0\n        for y in range(max(0, i - 1), min(m, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            ones += M[y][x]\n            count += 1\n        ans[i][j] = ones // count\n\n    return ans",
      "title": "661. Image Smoother",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d532afa3-154a-4aa1-ace7-23a06b2c6b1a",
      "code": "class Solution:\n  def checkEqualTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n\n    seen = set()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      seen.add(summ)\n      return summ\n\n    summ = root.val + dfs(root.left) + dfs(root.right)\n    return summ % 2 == 0 and summ // 2 in seen",
      "title": "663. Equal Tree Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "140c924c-dc0d-4ae1-94f7-8f366a1cd508",
      "code": "class Solution:\n  def checkPossibility(self, nums: list[int]) -> bool:\n    j = None\n\n    for i in range(len(nums) - 1):\n      if nums[i] > nums[i + 1]:\n        if j is not None:\n          return False\n        j = i\n\n    return (j is None or j == 0 or j == len(nums) - 2 or\n            nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2])",
      "title": "665. Non-decreasing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25ed6db7-0a2c-49e9-a10a-dea64411ab82",
      "code": "class Solution:\n  def pathSum(self, nums: list[int]) -> int:\n    ans = 0\n    tree = [[-1] * 8 for _ in range(4)]\n\n    for num in nums:\n      d = num // 100 - 1\n      p = (num % 100) // 10 - 1\n      v = num % 10\n      tree[d][p] = v\n\n    def dfs(i: int, j: int, path: int) -> None:\n      nonlocal ans\n      if tree[i][j] == -1:\n        return\n      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:\n        ans += path + tree[i][j]\n        return\n\n      dfs(i + 1, j * 2, path + tree[i][j])\n      dfs(i + 1, j * 2 + 1, path + tree[i][j])\n\n    dfs(0, 0, 0)\n    return ans",
      "title": "666. Path Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afe86381-0ce6-4ab4-b2e8-23405f4b3fda",
      "code": "class Solution:\n  def constructArray(self, n: int, k: int) -> list[int]:\n    ans = list(range(1, n - k + 1))\n\n    for i in range(k):\n      if i % 2 == 0:\n        ans.append(n - i // 2)\n      else:\n        ans.append(n - k + (i + 1) // 2)\n\n    return ans",
      "title": "667. Beautiful Arrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d5e7789-732e-4792-afaf-7bf64a404d58",
      "code": "class Solution:\n  def maximumSwap(self, num: int) -> int:\n    s = list(str(num))\n    dict = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n      for digit in reversed(string.digits):\n        if digit <= c:\n          break\n        if digit in dict and dict[digit] > i:\n          s[i], s[dict[digit]] = digit, s[i]\n          return int(''.join(s))\n\n    return num",
      "title": "670. Maximum Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2c1f655-c30b-43c4-b73a-e921e6c0c2bd",
      "code": "class Solution:\n  def flipLights(self, n: int, m: int) -> int:\n    n = min(n, 3)\n\n    if m == 0:\n      return 1\n    if m == 1:\n      return [2, 3, 4][n - 1]\n    if m == 2:\n      return [2, 4, 7][n - 1]\n\n    return [2, 4, 8][n - 1]",
      "title": "672. Bulb Switcher II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80515791-29a1-4950-823a-605322ddd230",
      "code": "class Solution:\n  def findNumberOfLIS(self, nums: list[int]) -> int:\n    ans = 0\n    maxLength = 0\n    # length[i] := the length of the LIS ending in nums[i]\n    length = [1] * len(nums)\n    # count[i] := the number of LIS's ending in nums[i]\n    count = [1] * len(nums)\n\n    # Calculate the `length` and `count` arrays.\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    # Get the number of LIS.\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans",
      "title": "673. Number of Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "835dc97c-cb96-449f-a641-0c3d3915f756",
      "code": "class Solution:\n  def findLengthOfLCIS(self, nums: list[int]) -> int:\n    ans = 0\n    j = 0\n\n    for i in range(len(nums)):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        j = i\n      ans = max(ans, i - j + 1)\n\n    return ans",
      "title": "674. Longest Continuous Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa97ddb6-f9fb-4ba2-959f-ff08a024b12e",
      "code": "class Solution:\n  def checkValidString(self, s: str) -> bool:\n    low = 0\n    high = 0\n\n    for c in s:\n      if c == '(':\n        low += 1\n        high += 1\n      elif c == ')':\n        if low > 0:\n          low -= 1\n        high -= 1\n      else:\n        if low > 0:\n          low -= 1\n        high += 1\n      if high < 0:\n        return False\n\n    return low == 0",
      "title": "678. Valid Parenthesis String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ef48962-04b1-4bbf-be4a-0b115bb0aae4",
      "code": "class Solution:\n  def judgePoint24(self, nums: list[int]) -> bool:\n    def generate(a: float, b: float) -> list[float]:\n      return [a * b,\n              math.inf if b == 0 else a / b,\n              math.inf if a == 0 else b / a,\n              a + b, a - b, b - a]\n\n    def dfs(nums: list[float]) -> bool:\n      if len(nums) == 1:\n        return abs(nums[0] - 24.0) < 0.001\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        for num in generate(nums[i], nums[j]):\n          nextRound = [num]\n          for k in range(len(nums)):\n            if k == i or k == j:\n              continue\n            nextRound.append(nums[k])\n          if dfs(nextRound):\n            return True\n\n      return False\n\n    return dfs(nums)",
      "title": "679. 24 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "421501b6-7591-49bc-9565-da10c3b0cf32",
      "code": "class Solution:\n  def validPalindrome(self, s: str) -> bool:\n    def validPalindrome(l: int, r: int) -> bool:\n      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))\n\n    n = len(s)\n\n    for i in range(n // 2):\n      if s[i] != s[~i]:\n        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)\n\n    return True",
      "title": "680. Valid Palindrome II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30ff385d-d703-4817-947d-740d0cf73287",
      "code": "class Solution:\n  def nextClosestTime(self, time: str) -> str:\n    ans = list(time)\n    digits = sorted(ans)\n\n    def nextClosest(digit: str, limit: str) -> str:\n      next = bisect_right(digits, digit)\n      return digits[0] if next == 4 or digits[next] > limit else digits[next]\n\n    ans[4] = nextClosest(ans[4], '9')\n    if time[4] < ans[4]:\n      return ''.join(ans)\n\n    ans[3] = nextClosest(ans[3], '5')\n    if time[3] < ans[3]:\n      return ''.join(ans)\n\n    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')\n    if time[1] < ans[1]:\n      return ''.join(ans)\n\n    ans[0] = nextClosest(ans[0], '2')\n    return ''.join(ans)",
      "title": "681. Next Closest Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2c973ad-8e92-4a52-a08c-7d1edcf24193",
      "code": "class Solution:\n  def calPoints(self, operations: list[str]) -> int:\n    scores = []\n\n    for operation in operations:\n      match operation:\n        case '+':\n          scores.append(scores[-1] + scores[-2])\n        case 'D':\n          scores.append(scores[-1] * 2)\n        case 'C':\n          scores.pop()\n        case default:\n          scores.append(int(operation))\n\n    return sum(scores)",
      "title": "682. Baseball Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a84ea65-301f-4b97-831e-325d6a519e51",
      "code": "class Solution:\n  def kEmptySlots(self, bulbs: list[int], k: int) -> int:\n    n = len(bulbs)\n    ans = math.inf\n    # day[i] := the day when bulbs[i] is turned on\n    day = [0] * n\n\n    for i, bulb in enumerate(bulbs):\n      day[bulb - 1] = i + 1\n\n    # Find a subarray of day[l..r], where its length is k + 2.\n    # For each l < i < r, day[i] > max(day[l], day[r]).\n    l = 0\n    r = l + k + 1\n    i = 1\n    while r < n:\n      if i == r:\n        ans = min(ans, max(day[l], day[r]))\n        l = i\n        r = i + k + 1\n      elif day[i] < max(day[l], day[r]):\n        l = i\n        r = i + k + 1\n      i += 1\n\n    return -1 if ans == math.inf else ans",
      "title": "683. K Empty Slots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9acc9905-502b-4a77-9017-75d5b5ce891e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge",
      "title": "684. Redundant Connection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ff3d0c9-78b9-4fbf-948a-58edfe73f229",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(\n      self, edges: list[list[int]],\n  ) -> list[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> list[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    # If there is no edge with two ids, don't skip any edge.\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        # Try to delete the edges[i].\n        if not findRedundantDirectedConnection(i):\n          return edges[i]",
      "title": "685. Redundant Connection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26e5ba3d-d2f5-4c34-8376-a05085e19f88",
      "code": "class Solution:\n  def repeatedStringMatch(self, a: str, b: str) -> int:\n    n = math.ceil(len(b) / len(a))\n    s = a * n\n    if b in s:\n      return n\n    if b in s + a:\n      return n + 1\n    return -1",
      "title": "686. Repeated String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10e59268-c8fc-4996-8a18-b7e4fd388c6f",
      "code": "class Solution:\n  def longestUnivaluePath(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def longestUnivaluePathDownFrom(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = longestUnivaluePathDownFrom(root.left)\n      r = longestUnivaluePathDownFrom(root.right)\n      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0\n      arrowRight = r + 1 if root.right and root.right.val == root.val else 0\n      ans = max(ans, arrowLeft + arrowRight)\n      return max(arrowLeft, arrowRight)\n\n    longestUnivaluePathDownFrom(root)\n    return ans",
      "title": "687. Longest Univalue Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d7dcb53-daee-4c0a-a5c0-8caa94e62dca",
      "code": "class Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    # dp[i][j] := the probability to stand on (i, j)\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k",
      "title": "688. Knight Probability in Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb832811-f44b-4c39-b673-a35f01d862b6",
      "code": "class Solution:\n  def maxSumOfThreeSubarrays(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums) - k + 1\n    # sums[i] := sum(nums[i..i + k))\n    sums = [0] * n\n    # l[i] := the index in [0..i] that has the maximum sums[i]\n    l = [0] * n\n    # r[i] := the index in [i..n) that has the maximum sums[i]\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if (ans[0] == -1 or\n          sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <\n              sums[l[i - k]] + sums[i] + sums[r[i + k]]):\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans",
      "title": "689. Maximum Sum of 3 Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "414dcb86-42f4-4f08-9ce4-1fa0d5a4c917",
      "code": "class Solution:\n  def getImportance(self, employees: list['Employee'], id: int) -> int:\n    idToEmployee = {employee.id: employee for employee in employees}\n\n    def dfs(id: int) -> int:\n      values = idToEmployee[id].importance\n      for subId in idToEmployee[id].subordinates:\n        values += dfs(subId)\n      return values\n\n    return dfs(id)",
      "title": "690. Employee Importance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ed8a219-4553-4222-854c-289a0cbd1d35",
      "code": "class Solution:\n  def minStickers(self, stickers: list[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    # dp[i] := the minimum number of stickers to spell out i, where i is the\n    # bit mask of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      # Try to expand from `mask` by using each sticker.\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            # Try to apply it on a missing letter.\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "691. Stickers to Spell Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "575eeec7-704c-43a0-a408-28885c1d467f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  word: str\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.word > other.word\n    return self.freq < other.freq\n\n\nclass Solution:\n  def topKFrequent(self, words: list[str], k: int) -> list[str]:\n    ans = []\n    heap = []\n\n    for word, freq in collections.Counter(words).items():\n      heapq.heappush(heap, T(word, freq))\n      if len(heap) > k:\n        heapq.heappop(heap)\n\n    while heap:\n      ans.append(heapq.heappop(heap).word)\n\n    return ans[::-1]",
      "title": "692. Top K Frequent Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da0c84d1-baf8-464b-8a97-f606016d7583",
      "code": "class Solution:\n  def hasAlternatingBits(self, n: int) -> bool:\n    #            n = 0b010101\n    #       n >> 2 = 0b000101\n    # n ^ (n >> 2) = 0b010000 = a\n    #        a - 1 = 0b001111\n    #  a & (a - 1) = 0\n    a = n ^ (n >> 2)\n    return (a & (a - 1)) == 0",
      "title": "693. Binary Number with Alternating Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "931fd463-f8e6-45ac-b3fa-fe273522827c",
      "code": "class Solution:\n  def numDistinctIslands(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int, i0: int, j0: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i - i0, j - j0))\n      dfs(i + 1, j, i0, j0)\n      dfs(i - 1, j, i0, j0)\n      dfs(i, j + 1, i0, j0)\n      dfs(i, j - 1, i0, j0)\n\n    islands = set()  # all the different islands\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j, i, j)\n        if island:\n          islands.add(frozenset(island))\n\n    return len(islands)",
      "title": "694. Number of Distinct Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cce4530e-8a0c-4e5c-9440-ada4132789dd",
      "code": "class Solution:\n  def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != 1:\n        return 0\n\n      grid[i][j] = 2\n\n      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n\n    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))",
      "title": "695. Max Area of Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90e72956-68de-4e5d-bb67-a8bf78c0c22a",
      "code": "class Solution:\n  def countBinarySubstrings(self, s: str) -> int:\n    ans = 0\n    prevCount = 0\n    equals = 1\n\n    for i in range(len(s) - 1):\n      if s[i] == s[i + 1]:\n        equals += 1\n      else:\n        ans += min(prevCount, equals)\n        prevCount = equals\n        equals = 1\n\n    return ans + min(prevCount, equals)",
      "title": "696. Count Binary Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46d855b2-30e9-4a22-855a-5ad8e4159426",
      "code": "class Solution:\n  def findShortestSubArray(self, nums: list[int]) -> int:\n    ans = 0\n    degree = 0\n    debut = {}\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      debut.setdefault(num, i)\n      count[num] += 1\n      if count[num] > degree:\n        degree = count[num]\n        ans = i - debut[num] + 1\n      elif count[num] == degree:\n        ans = min(ans, i - debut[num] + 1)\n\n    return ans",
      "title": "697. Degree of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff923470-dfb2-466f-b130-ca4c9f827bde",
      "code": "class Solution:\n  def canPartitionKSubsets(self, nums: list[int], k: int) -> bool:\n    summ = sum(nums)\n    if summ % k != 0:\n      return False\n\n    target = summ // k  # the target sum of each subset\n    if any(num > target for num in nums):\n      return False\n\n    def dfs(s: int, remainingGroups: int, currSum: int, used: int) -> bool:\n      if remainingGroups == 0:\n        return True\n      if currSum > target:\n        return False\n      if currSum == target:  # Find a valid group, so fresh start.\n        return dfs(0, remainingGroups - 1, 0, used)\n\n      for i in range(s, len(nums)):\n        if used >> i & 1:\n          continue\n        if dfs(i + 1, remainingGroups, currSum + nums[i], used | 1 << i):\n          return True\n\n      return False\n\n    nums.sort(reverse=True)\n    return dfs(0, k, 0, 0)",
      "title": "698. Partition to K Equal Sum Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df012010-c386-4da9-b839-aaf0ce1c24df",
      "code": "class Solution:\n  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == val:\n      return root\n    if root.val > val:\n      return self.searchBST(root.left, val)\n    return self.searchBST(root.right, val)",
      "title": "700. Search in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25bdad60-379a-4ac6-95eb-9f923c05c248",
      "code": "class Solution:\n  def insertIntoBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return TreeNode(val)\n    if root.val > val:\n      root.left = self.insertIntoBST(root.left, val)\n    else:\n      root.right = self.insertIntoBST(root.right, val)\n    return root",
      "title": "701. Insert into a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a8eb1b5-6764-480a-8cee-1fc25ab39f2e",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class ArrayReader:\n#   def get(self, index: int) -> int:\n\nclass Solution:\n  def search(self, reader: 'ArrayReader', target: int) -> int:\n    l = bisect.bisect_left(range(10**4), target,\n                           key=lambda m: reader.get(m))\n    return l if reader.get(l) == target else -1",
      "title": "702. Search in a Sorted Array of Unknown Size",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71c21e5c-f4e7-4c77-8bd9-78b6ec465afa",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    i = bisect.bisect_left(nums, target)\n    return -1 if i == len(nums) or nums[i] != target else i",
      "title": "704. Binary Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b40da5a5-2a89-401e-a22f-07f1838ce576",
      "code": "class Solution:\n  def toLowerCase(self, str: str) -> str:\n    return ''.join(chr(ord(c) + 32) if 'A' <= c <= 'Z' else c for c in str)",
      "title": "709. To Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2d48667-aa05-4e2e-9114-febd7b0ffb2d",
      "code": "class Solution:\n  def __init__(self, n: int, blacklist: list[int]):\n    self.validRange = n - len(blacklist)\n    self.dict = {}\n\n    maxAvailable = n - 1\n\n    for b in blacklist:\n      self.dict[b] = -1\n\n    for b in blacklist:\n      if b < self.validRange:\n        # Find the slot that haven't been used.\n        while maxAvailable in self.dict:\n          maxAvailable -= 1\n        self.dict[b] = maxAvailable\n        maxAvailable -= 1\n\n  def pick(self) -> int:\n    value = random.randint(0, self.validRange - 1)\n\n    if value in self.dict:\n      return self.dict[value]\n\n    return value",
      "title": "710. Random Pick with Blacklist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43b256fe-6d64-4f65-94d6-2d11422fa6d9",
      "code": "class Solution:\n  def numDistinctIslands2(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i, j))\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    def normalize(island: list[tuple]) -> list[tuple]:\n      # points[i] := 8 different rotations/reflections of an island\n      points = [[] for _ in range(8)]\n\n      for i, j in island:\n        points[0].append((i, j))\n        points[1].append((i, -j))\n        points[2].append((-i, j))\n        points[3].append((-i, -j))\n        points[4].append((j, i))\n        points[5].append((j, -i))\n        points[6].append((-j, i))\n        points[7].append((-j, -i))\n\n      points = [sorted(p) for p in points]\n\n      # Normalize each p by substracting p[1..7] with p[0].\n      for p in points:\n        for i in range(1, len(island)):\n          p[i] = (p[i][0] - p[0][0],\n                  p[i][1] - p[0][1])\n        p[0] = (0, 0)\n\n      return sorted(points)[0]\n\n    islands = set()  # all the islands with different shapes\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j)\n        if island:\n          islands.add(frozenset(normalize(island)))\n\n    return len(islands)",
      "title": "711. Number of Distinct Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33880945-25db-4601-aac3-f3d18e023c72",
      "code": "class Solution:\n  def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n    if k <= 1:\n      return 0\n\n    ans = 0\n    prod = 1\n\n    j = 0\n    for i, num in enumerate(nums):\n      prod *= num\n      while prod >= k:\n        prod /= nums[j]\n        j += 1\n      ans += i - j + 1\n\n    return ans",
      "title": "713. Subarray Product Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "744d557e-b5c9-490c-9c84-5ed7767ecfbd",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int], fee: int) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price - fee)\n\n    return sell",
      "title": "714. Best Time to Buy and Sell Stock with Transaction Fee",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4f2526c-80b0-45a6-9319-5b8699320196",
      "code": "class Solution:\n  def isOneBitCharacter(self, bits: list[int]) -> bool:\n    i = 0\n    while i < len(bits) - 1:\n      i += bits[i] + 1\n\n    return i == len(bits) - 1",
      "title": "717. 1-bit and 2-bit Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a0965bb-4653-450c-a1d8-777ea5806149",
      "code": "class Solution:\n  def findLength(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    ans = 0\n    # dp[i][j] := the maximum length of a subarray that appears in both\n    # nums1[i..m) and nums2[j..n)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        if nums1[i] == nums2[j]:\n          dp[i][j] = dp[i + 1][j + 1] + 1\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "718. Maximum Length of Repeated Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e21e6daa-81cd-4788-8d04-6399f08c3f46",
      "code": "class Solution:\n  def smallestDistancePair(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    def numPairDistancesNoGreaterThan(m: int) -> int:\n      count = 0\n      j = 1\n      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,\n      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.\n      for i, num in enumerate(nums):\n        while j < len(nums) and nums[j] <= num + m:\n          j += 1\n        count += j - i - 1\n      return count\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), k,\n                              key=numPairDistancesNoGreaterThan)",
      "title": "719. Find K-th Smallest Pair Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7c7db79-f653-4502-bcd9-f3663dffc142",
      "code": "class Solution:\n  def longestWord(self, words: list[str]) -> str:\n    root = {}\n\n    for word in words:\n      node = root\n      for c in word:\n        if c not in node:\n          node[c] = {}\n        node = node[c]\n      node['word'] = word\n\n    def dfs(node: dict) -> str:\n      ans = node['word'] if 'word' in node else ''\n\n      for child in node:\n        if 'word' in node[child] and len(node[child]['word']) > 0:\n          childWord = dfs(node[child])\n          if len(childWord) > len(ans) or (\n                  len(childWord) == len(ans) and childWord < ans):\n            ans = childWord\n\n      return ans\n\n    return dfs(root)",
      "title": "720. Longest Word in Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "553eed3a-54b8-4188-843b-37ea80127762",
      "code": "class Solution:\n  def removeComments(self, source: list[str]) -> list[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans",
      "title": "722. Remove Comments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3185e053-e180-4781-a8c7-7a89cffa809d",
      "code": "class Solution:\n  def pivotIndex(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      if prefix == summ - prefix - num:\n        return i\n      prefix += num\n\n    return -1",
      "title": "724. Find Pivot Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c626343e-0598-4ed4-8923-7b56d92a5e29",
      "code": "class Solution:\n  def splitListToParts(self, root: ListNode, k: int) -> list[ListNode]:\n    ans = [[] for _ in range(k)]\n    length = 0\n    curr = root\n    while curr:\n      length += 1\n      curr = curr.next\n    subLength = length // k\n    remainder = length % k\n\n    prev = None\n    head = root\n\n    for i in range(k):\n      ans[i] = head\n      for j in range(subLength + (1 if remainder > 0 else 0)):\n        prev = head\n        head = head.next\n      if prev:\n        prev.next = None\n      remainder -= 1\n\n    return ans",
      "title": "725. Split Linked List in Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a63c2a55-13ba-4224-a182-b06d8285615a",
      "code": "class Solution:\n  def countOfAtoms(self, formula: str) -> str:\n    def parse() -> dict:\n      ans = collections.defaultdict(int)\n\n      nonlocal i\n      while i < n:\n        if formula[i] == '(':\n          i += 1\n          for elem, freq in parse().items():\n            ans[elem] += freq\n        elif formula[i] == ')':\n          i += 1\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          factor = int(formula[numStart:i])\n          for elem, freq in ans.items():\n            ans[elem] *= factor\n          return ans\n        elif formula[i].isupper():\n          elemStart = i\n          i += 1\n          while i < n and formula[i].islower():\n            i += 1\n          elem = formula[elemStart:i]\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          num = 1 if i == numStart else int(\n              formula[numStart:i])\n          ans[elem] += num\n\n      return ans\n\n    n = len(formula)\n\n    ans = \"\"\n    i = 0\n    count = parse()\n\n    for elem in sorted(count.keys()):\n      ans += elem\n      if count[elem] > 1:\n        ans += str(count[elem])\n\n    return ans",
      "title": "726. Number of Atoms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de0b5379-36f9-4cae-ac2f-ef442bdf845d",
      "code": "class Solution:\n  def selfDividingNumbers(self, left: int, right: int) -> list[int]:\n    return [num for num in range(left, right + 1) if all(n != 0 and num % n == 0 for n in map(int, str(num)))]",
      "title": "728. Self Dividing Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3ca1eba-f536-46bd-a6d9-f55c82423871",
      "code": "class Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    # dp[i][j] := the number of different non-empty palindromic subsequences in\n    # s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]",
      "title": "730. Count Different Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22ab73c1-b959-4cfd-987c-37ddbd13aa7d",
      "code": "class Solution:\n  def floodFill(self, image: list[list[int]],\n                sr: int, sc: int, newColor: int) -> list[list[int]]:\n    startColor = image[sr][sc]\n    seen = set()\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):\n        return\n      if image[i][j] != startColor or (i, j) in seen:\n        return\n\n      image[i][j] = newColor\n      seen.add((i, j))\n\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    dfs(sr, sc)\n    return image",
      "title": "733. Flood Fill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e67d8027-83d8-465b-ab16-5c4683925b08",
      "code": "class Solution:\n  def areSentencesSimilar(\n      self,\n      sentence1: list[str],\n      sentence2: list[str],\n      similarPairs: list[list[str]],\n  ) -> bool:\n    if len(sentence1) != len(sentence2):\n      return False\n\n    # map[key] := all the similar words of key\n    map = collections.defaultdict(set)\n\n    for a, b in similarPairs:\n      map[a].add(b)\n      map[b].add(a)\n\n    for word1, word2 in zip(sentence1, sentence2):\n      if word1 == word2:\n        continue\n      if word1 not in map:\n        return False\n      if word2 not in map[word1]:\n        return False\n\n    return True",
      "title": "734. Sentence Similarity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b56eafca-f96b-4379-a097-881f2a123606",
      "code": "class Solution:\n  def asteroidCollision(self, asteroids: list[int]) -> list[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:  # a < 0\n        # Destroy the previous positive one(s).\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()  # Both asteroids explode.\n        else:  # stack[-1] > the current asteroid.\n          pass  # Destroy the current asteroid, so do nothing.\n\n    return stack",
      "title": "735. Asteroid Collision",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a78e566-8dd6-4aea-9c18-86b24f4f4fb6",
      "code": "class Solution:\n  def evaluate(self, expression: str) -> int:\n    def evaluate(e: str, prevScope: dict) -> int:\n      if e[0].isdigit() or e[0] == '-':\n        return int(e)\n      if e in prevScope:\n        return prevScope[e]\n\n      scope = prevScope.copy()\n      nextExpression = e[e.index(' ') + 1:-1]\n      tokens = parse(nextExpression)\n\n      if e[1] == 'm':  # 'mult'\n        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\n      if e[1] == 'a':  # 'add'\n        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\n\n      # 'let'\n      for i in range(0, len(tokens) - 2, 2):\n        scope[tokens[i]] = evaluate(tokens[i + 1], scope)\n\n      return evaluate(tokens[-1], scope)\n\n    def parse(e: str):\n      tokens = []\n      s = ''\n      opened = 0\n\n      for c in e:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened == 0 and c == ' ':\n          tokens.append(s)\n          s = ''\n        else:\n          s += c\n\n      if len(s) > 0:\n        tokens.append(s)\n      return tokens\n\n    return evaluate(expression, {})",
      "title": "736. Parse Lisp Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bcac646-e91b-4900-9212-3851340dd905",
      "code": "class Solution:\n  def areSentencesSimilarTwo(\n      self,\n      words1: list[str],\n      words2: list[str],\n      pairs: list[list[str]],\n  ) -> bool:\n    if len(words1) != len(words2):\n      return False\n\n    # graph[key] := all the similar words of key\n    graph = collections.defaultdict(set)\n\n    for a, b in pairs:\n      graph[a].add(b)\n      graph[b].add(a)\n\n    def dfs(word1: str, word2: str, seen: set) -> bool:\n      if word1 in graph[word2]:\n        return True\n\n      seen.add(word1)\n\n      for child in graph[word1]:\n        if child in seen:\n          continue\n        if dfs(child, word2, seen):\n          return True\n\n      return False\n\n    for word1, word2 in zip(words1, words2):\n      if word1 == word2:\n        continue\n      if word1 not in graph:\n        return False\n      if not dfs(word1, word2, set()):\n        return False\n\n    return True",
      "title": "737. Sentence Similarity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3b7b3e3-c109-4579-991e-152c62cc5055",
      "code": "class Solution:\n  def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n    ans = [0] * len(temperatures)\n    stack = []  # a decreasing stack\n\n    for i, temperature in enumerate(temperatures):\n      while stack and temperature > temperatures[stack[-1]]:\n        index = stack.pop()\n        ans[index] = i - index\n      stack.append(i)\n\n    return ans",
      "title": "739. Daily Temperatures",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2632ed4-bfb6-4d2f-a41a-60c4f1044ecb",
      "code": "class Solution:\n  def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: list[list[tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1",
      "title": "743. Network Delay Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "798c80b6-3746-4a2c-89d6-38cb30b2a4d6",
      "code": "class Solution:\n  def nextGreatestLetter(self, letters: list[str], target: str) -> str:\n    l = bisect.bisect_right(range(len(letters)), target,\n                            key=lambda m: letters[m])\n    return letters[l % len(letters)]",
      "title": "744. Find Smallest Letter Greater Than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fd43b9d-162d-406f-8853-8b1a55c6b602",
      "code": "class Solution:\n  def minCostClimbingStairs(self, cost: list[int]) -> int:\n    cost.append(0)\n\n    for i in range(2, len(cost)):\n      cost[i] += min(cost[i - 1], cost[i - 2])\n\n    return cost[-1]",
      "title": "746. Min Cost Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8ab5749-a597-4c82-95ab-797aef8af80a",
      "code": "class Solution:\n  def dominantIndex(self, nums: list[int]) -> int:\n    mx = 0\n    secondMax = 0\n\n    for i, num in enumerate(nums):\n      if num > mx:\n        secondMax = mx\n        mx = num\n        ans = i\n      elif num > secondMax:\n        secondMax = num\n\n    return ans if mx >= 2 * secondMax else -1",
      "title": "747. Largest Number At Least Twice of Others",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cc09fbd-49f2-47e1-ac28-00e1364114fd",
      "code": "class Solution:\n  def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n    def isMatch(word: str) -> bool:\n      wordCount = collections.Counter(word)\n      return False if any(\n          wordCount[i] < count[i] for i in string.ascii_letters) else True\n\n    ans = '*' * 16\n    count = collections.defaultdict(int)\n\n    for c in licensePlate:\n      if c.isalpha():\n        count[c.lower()] += 1\n\n    for word in words:\n      if len(word) < len(ans) and isMatch(word):\n        ans = word\n\n    return ans",
      "title": "748. Shortest Completing Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7da83ea-5074-4543-96ea-a98b0554c896",
      "code": "class Solution:\n  def ipToCIDR(self, ip: str, n: int) -> list[str]:\n    ans = []\n    num = self._getNum(ip.split('.'))\n\n    while n > 0:\n      lowbit = num & -num\n      count = self._maxLow(n) if lowbit == 0 else self._firstFit(lowbit, n)\n      ans.append(self._getCIDR(num, self._getPrefix(count)))\n      n -= count\n      num += count\n\n    return ans\n\n  def _getNum(self, x: list[str]) -> int:\n    num = 0\n    for i in range(4):\n      num = num * 256 + int(x[i])\n    return num\n\n  def _maxLow(self, n: int) -> int | None:\n    \"\"\"Returns the maximum i s.t. 2^i < n.\"\"\"\n    for i in range(32):\n      if 1 << i + 1 > n:\n        return 1 << i\n\n  def _firstFit(self, lowbit: int, n: int) -> int:\n    while lowbit > n:\n      lowbit >>= 1\n    return lowbit\n\n  def _getCIDR(self, num: int, prefix: int) -> str:\n    d = num & 255\n    num >>= 8\n    c = num & 255\n    num >>= 8\n    b = num & 255\n    num >>= 8\n    a = num & 255\n    return '.'.join([str(s) for s in [a, b, c, d]]) + '/' + str(prefix)\n\n  def _getPrefix(self, count: int) -> int | None:\n    \"\"\"\n    e.g. count = 8 = 2^3 . prefix = 32 - 3 = 29\n         count = 1 = 2^0 . prefix = 32 - 0 = 32\n    \"\"\"\n    for i in range(32):\n      if count == 1 << i:\n        return 32 - i",
      "title": "751. IP to CIDR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e391ef08-8bbf-4c25-b806-b37d1a0669ee",
      "code": "class Solution:\n  def crackSafe(self, n: int, k: int) -> str:\n    passwordSize = k**n\n    path = '0' * n\n    seen = set()\n    seen.add(path)\n\n    def dfs(path: str) -> str:\n      if len(seen) == passwordSize:\n        return path\n\n      for c in map(str, range(k)):\n        node = path[-n + 1:] + c if n > 1 else c\n        if node not in seen:\n          seen.add(node)\n          res = dfs(path + c)\n          if res:\n            return res\n          seen.remove(node)\n\n    return dfs(path)",
      "title": "753. Cracking the Safe",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f50d5c7a-fc93-4c5d-80a1-7c130528594d",
      "code": "class Solution:\n  def reachNumber(self, target: int) -> int:\n    ans = 0\n    pos = 0\n    target = abs(target)\n\n    while pos < target:\n      ans += 1\n      pos += ans\n\n    while (pos - target) % 2 == 1:\n      ans += 1\n      pos += ans\n\n    return ans",
      "title": "754. Reach a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47da6f39-d940-4ec4-9d0e-6b0250e6828a",
      "code": "class Solution:\n  def pourWater(self, heights: list[int], volume: int, k: int) -> list[int]:\n    i = k\n\n    while volume > 0:\n      volume -= 1\n      while i > 0 and heights[i] >= heights[i - 1]:\n        i -= 1\n      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:\n        i += 1\n      while i > k and heights[i] == heights[i - 1]:\n        i -= 1\n      heights[i] += 1\n\n    return heights",
      "title": "755. Pour Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42508d3c-45f1-413b-b649-d8cfd6075af2",
      "code": "class Solution:\n  def pyramidTransition(self, bottom: str, allowed: list[str]) -> bool:\n    prefixToBlocks = collections.defaultdict(list)\n\n    for a in allowed:\n      prefixToBlocks[a[:2]].append(a[2])\n\n    def dfs(row: str, nextRow: str, i: int) -> bool:\n      if len(row) == 1:\n        return True\n      if len(nextRow) + 1 == len(row):\n        return dfs(nextRow, '', 0)\n\n      for c in prefixToBlocks[row[i:i + 2]]:\n        if dfs(row, nextRow + c, i + 1):\n          return True\n\n      return False\n\n    return dfs(bottom, '', 0)",
      "title": "756. Pyramid Transition Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b03ebad-acd0-46c1-b9e0-9d075277ddb3",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def boldWords(self, words: list[str], s: str) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node.children:\n          node.children[c] = TrieNode()\n        node = node.children[c]\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        node = node.children.setdefault(s[j], TrieNode())\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "758. Bold Words in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63e73990-fb01-4a40-b19f-375286969dc2",
      "code": "class Solution:\n  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':\n    ans = []\n    intervals = []\n\n    for s in schedule:\n      intervals.extend(s)\n\n    intervals.sort(key=lambda x: x.start)\n\n    prevEnd = intervals[0].end\n\n    for interval in intervals:\n      if interval.start > prevEnd:\n        ans.append(Interval(prevEnd, interval.start))\n      prevEnd = max(prevEnd, interval.end)\n\n    return ans",
      "title": "759. Employee Free Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e3caa4f-a7bd-461f-b97a-0b391349df16",
      "code": "class Solution:\n  def anagramMappings(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums2):\n      numToIndices[num].append(i)\n\n    return [numToIndices[num].pop() for num in nums1]",
      "title": "760. Find Anagram Mappings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "589b4842-709f-42ea-b286-57080ac2d465",
      "code": "class Solution:\n  def makeLargestSpecial(self, s: str) -> str:\n    specials = []\n    count = 0\n\n    i = 0\n    for j, c in enumerate(s):\n      count += 1 if c == '1' else -1\n      if count == 0:\n        specials.append(\n            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')\n        i = j + 1\n\n    return ''.join(sorted(specials)[::-1])",
      "title": "761. Special Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "462a6789-4d4d-4d97-82f9-d510be477f55",
      "code": "class Solution:\n  def partitionLabels(self, s: str) -> list[int]:\n    ans = []\n    letterToRightmostIndex = {c: i for i, c in enumerate(s)}\n\n    l = 0  # the leftmost index of the current running string\n    r = 0  # the rightmost index of the current running string\n\n    for i, c in enumerate(s):\n      r = max(r, letterToRightmostIndex[c])\n      if i == r:\n        ans.append(r - l + 1)\n        l = r + 1\n\n    return ans",
      "title": "763. Partition Labels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b14f121-6410-48b5-bff0-0ef0b496fff5",
      "code": "class Solution:\n  def isToeplitzMatrix(self, matrix: list[list[int]]) -> bool:\n    for i in range(len(matrix) - 1):\n      for j in range(len(matrix[0]) - 1):\n        if matrix[i][j] != matrix[i + 1][j + 1]:\n          return False\n\n    return True",
      "title": "766. Toeplitz Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8262d77-0833-46b6-ac07-aead43828998",
      "code": "class Solution:\n  def reorganizeString(self, s: str) -> str:\n    count = collections.Counter(s)\n    if max(count.values()) > (len(s) + 1) // 2:\n      return ''\n\n    ans = []\n    maxHeap = [(-freq, c) for c, freq in count.items()]\n    heapq.heapify(maxHeap)\n    prevFreq = 0\n    prevChar = '@'\n\n    while maxHeap:\n      # Get the letter with the maximum frequency.\n      freq, c = heapq.heappop(maxHeap)\n      ans.append(c)\n      # Add the previous letter back s.t. any two adjacent characters are not\n      # the same.\n      if prevFreq < 0:\n        heapq.heappush(maxHeap, (prevFreq, prevChar))\n      prevFreq = freq + 1\n      prevChar = c\n\n    return ''.join(ans)",
      "title": "767. Reorganize String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fbedca0-bd2b-4f4d-a49c-a7b1ab29cf43",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    mx = -math.inf\n    mn = [arr[-1]] * n\n\n    for i in reversed(range(n - 1)):\n      mn[i] = min(mn[i + 1], arr[i])\n\n    for i in range(n - 1):\n      mx = max(mx, arr[i])\n      if mx <= mn[i + 1]:\n        ans += 1\n\n    return ans + 1",
      "title": "768. Max Chunks To Make Sorted II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "124cb55c-4f4b-416d-8cb5-c7a2f96a99fb",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    ans = 0\n    mx = -math.inf\n\n    for i, a in enumerate(arr):\n      mx = max(mx, a)\n      if mx == i:\n        ans += 1\n\n    return ans",
      "title": "769. Max Chunks To Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37eb4d52-e3bf-46ed-a163-433647293866",
      "code": "class Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  # Def __str__(self):\n  #   res = []\n  #   for term, coef in self.terms.items():\n  #     res.append(term + ': ' + str(coef))\n  #   return '{' + ', '.join(res) + '}'\n\n  def toList(self) -> list[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      # the minimum degree is the last\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      # the maximum degree is the first\n      # Break ties by their lexicographic orders.\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0  # A's index\n    j = 0  # B's index\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(\n      self,\n      expression: str,\n      evalvars: list[str],\n      evalints: list[int],\n  ) -> list[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: list[str]) -> list[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':  # isOperator(token)\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:  # isOperand(token)\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: list[str]) -> Poly:\n    polys: list[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:  # token == '*'\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]",
      "title": "770. Basic Calculator IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a507032-0850-4606-96e9-5253fd346ac4",
      "code": "class Solution:\n  def numJewelsInStones(self, jewels: str, stones: str) -> int:\n    jewelsSet = set(jewels)\n    return sum(stone in jewelsSet for stone in stones)",
      "title": "771. Jewels and Stones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77cc058b-f6cc-4b28-bd51-3fd57d6ad87d",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    nums = []\n    ops = []\n\n    def calc():\n      b = nums.pop()\n      a = nums.pop()\n      op = ops.pop()\n      if op == '+':\n        nums.append(a + b)\n      elif op == '-':\n        nums.append(a - b)\n      elif op == '*':\n        nums.append(a * b)\n      else:  # op == '/'\n        nums.append(int(a / b))\n\n    def precedes(prev: str, curr: str) -> bool:\n      \"\"\"\n      Returns True if the previous character is a operator and the priority of\n      the previous operator >= the priority of the current character (operator).\n      \"\"\"\n      if prev == '(':\n        return False\n      return prev in '*/' or curr in '+-'\n\n    i = 0\n    hasPrevNum = False\n\n    while i < len(s):\n      c = s[i]\n      if c.isdigit():\n        num = int(c)\n        while i + 1 < len(s) and s[i + 1].isdigit():\n          num = num * 10 + int(s[i + 1])\n          i += 1\n        nums.append(num)\n        hasPrevNum = True\n      elif c == '(':\n        ops.append('(')\n        hasPrevNum = False\n      elif c == ')':\n        while ops[-1] != '(':\n          calc()\n        ops.pop()  # Pop '('\n      elif c in '+-*/':\n        if not hasPrevNum:  # Handle input like \"-1-(-1)\"\n          num.append(0)\n        while ops and precedes(ops[-1], c):\n          calc()\n        ops.append(c)\n      i += 1\n\n    while ops:\n      calc()\n\n    return nums.pop()",
      "title": "772. Basic Calculator III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff8d1d07-41cc-44c7-b207-ea65938c5406",
      "code": "class Solution:\n  def minmaxGasDist(self, stations: list[int], k: int) -> float:\n    ERR = 1e-6\n    l = 0\n    r = stations[-1] - stations[0]\n\n    def possible(k: int, m: float) -> bool:\n      \"\"\"\n      Returns True if can use <= k gas stations to ensure that each adjacent\n      distance between gas stations <= m.\n      \"\"\"\n      for a, b in zip(stations, stations[1:]):\n        diff = b - a\n        if diff > m:\n          k -= math.ceil(diff / m) - 1\n          if k < 0:\n            return False\n      return True\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if possible(k, m):\n        r = m\n      else:\n        l = m\n\n    return l",
      "title": "774. Minimize Max Distance to Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38a862c7-7054-4c9d-83e3-56db1e56c33e",
      "code": "class Solution:\n  def isIdealPermutation(self, nums: list[int]) -> bool:\n    mx = -1  # the number that is most likely > nums[i + 2]\n\n    for i in range(len(nums) - 2):\n      mx = max(mx, nums[i])\n      if mx > nums[i + 2]:\n        return False\n\n    return True",
      "title": "775. Global and Local Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd1baa31-e3a6-4f71-b239-c16f015cd28f",
      "code": "class Solution:\n  def splitBST(self, root: TreeNode | None, target: int) -> list[TreeNode | None]:\n    if not root:\n      return None, None\n    if root.val > target:\n      left, right = self.splitBST(root.left, target)\n      root.left = right\n      return left, root\n    else:  # root.val <= target\n      left, right = self.splitBST(root.right, target)\n      root.right = left\n      return root, right",
      "title": "776. Split BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10cb7fcd-4bd2-4f76-9dea-32b68d13abe5",
      "code": "class Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0  # start's index\n    j = 0  # end's index\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      # L can only move to left.\n      if start[i] == 'L' and i < j:\n        return False\n      # R can only move to right.\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "777. Swap Adjacent in LR String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fba16500-0891-4108-9021-0263757e35a6",
      "code": "class Solution:\n  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n    while sx < tx and sy < ty:\n      tx, ty = tx % ty, ty % tx\n\n    return (sx == tx and sy <= ty and (ty - sy) % tx == 0 or\n            sy == ty and sx <= tx and (tx - sx) % ty == 0)",
      "title": "780. Reaching Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fd05728-9599-46e8-a706-2282c19992d1",
      "code": "class Solution:\n  def numRabbits(self, answers: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for answer in answers:\n      if count[answer] % (answer + 1) == 0:\n        ans += answer + 1\n      count[answer] += 1\n\n    return ans",
      "title": "781. Rabbits in Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26d3e3ef-c31b-4b33-a2c3-7b819ce1079a",
      "code": "class Solution:\n  def movesToChessboard(self, board: list[list[int]]) -> int:\n    n = len(board)\n\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]\n           for i in range(n) for j in range(n)):\n      return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n % 2 == 1:\n      if rowSwaps % 2 == 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps % 2 == 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2",
      "title": "782. Transform to Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "753f43d0-e6f8-4a0a-9337-a63072796849",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def isBipartite(self, graph: list[list[int]]) -> bool:\n    colors = [Color.WHITE] * len(graph)\n\n    for i in range(len(graph)):\n      # This node has been colored, so do nothing.\n      if colors[i] != Color.WHITE:\n        continue\n      # Always paint red for a white node.\n      colors[i] = Color.RED\n      # BFS.\n      q = collections.deque([i])\n      while q:\n        for _ in range(len(q)):\n          u = q.popleft()\n          for v in graph[u]:\n            if colors[v] == colors[u]:\n              return False\n            if colors[v] == Color.WHITE:\n              colors[v] = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n              q.append(v)\n\n    return True",
      "title": "785. Is Graph Bipartite?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98d6eae2-0483-435c-8dbc-266425a712e3",
      "code": "class Solution:\n  def kthSmallestPrimeFraction(self, arr: list[int], k: int) -> list[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans",
      "title": "786. K-th Smallest Prime Fraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6060792-6554-42fd-98a5-b2fd46e021d7",
      "code": "class Solution:\n  def findCheapestPrice(\n      self,\n      n: int,\n      flights: list[list[int]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf] * (k + 2) for _ in range(len(graph))]\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]  # (d, u, stops)\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1",
      "title": "787. Cheapest Flights Within K Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "199739bc-42c2-4c4a-beda-e8b11525b9d3",
      "code": "class Solution:\n  def rotatedDigits(self, n: int) -> int:\n    def isGoodNumber(i: int) -> bool:\n      isRotated = False\n\n      for c in str(i):\n        if c == '0' or c == '1' or c == '8':\n          continue\n        if c == '2' or c == '5' or c == '6' or c == '9':\n          isRotated = True\n        else:\n          return False\n\n      return isRotated\n\n    return sum(isGoodNumber(i) for i in range(1, n + 1))",
      "title": "788. Rotated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ffc6980-2d09-441c-adf1-5525e77c7276",
      "code": "class Solution:\n  def escapeGhosts(self, ghosts: list[list[int]], target: list[int]) -> bool:\n    ghostSteps = min(abs(x - target[0]) +\n                     abs(y - target[1]) for x, y in ghosts)\n\n    return abs(target[0]) + abs(target[1]) < ghostSteps",
      "title": "789. Escape The Ghosts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ec35038-bf72-498b-b1d3-07fca9482799",
      "code": "class Solution:\n  def numTilings(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = [0, 1, 2, 5] + [0] * 997\n\n    for i in range(4, n + 1):\n      dp[i] = 2 * dp[i - 1] + dp[i - 3]\n\n    return dp[n] % MOD",
      "title": "790. Domino and Tromino Tiling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4076b44-a427-4fe8-a860-d58553971e15",
      "code": "class Solution:\n  def customSortString(self, order: str, s: str) -> str:\n    ans = \"\"\n    count = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in order:\n      while count[ord(c) - ord('a')] > 0:\n        ans += c\n        count[ord(c) - ord('a')] -= 1\n\n    for c in string.ascii_lowercase:\n      for _ in range(count[ord(c) - ord('a')]):\n        ans += c\n\n    return ans",
      "title": "791. Custom Sort String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7c05621-3c63-4816-a81b-a588e6d7ae12",
      "code": "class Solution:\n  def numMatchingSubseq(self, s: str, words: list[str]) -> int:\n    ans = 0\n    # [(i, j)] := words[i] and the letter words[i][j] is waiting for\n    bucket = [[] for _ in range(26)]\n\n    # For each word, it's waiting for word[0].\n    for i, word in enumerate(words):\n      bucket[ord(word[0]) - ord('a')].append((i, 0))\n\n    for c in s:\n      # Let prevBucket = bucket[c] and clear bucket[c].\n      index = ord(c) - ord('a')\n      prevBucket = bucket[index]\n      bucket[index] = []\n      for i, j in prevBucket:\n        j += 1\n        if j == len(words[i]):  # All the letters in words[i] are matched.\n          ans += 1\n        else:\n          bucket[ord(words[i][j]) - ord('a')].append((i, j))\n\n    return ans",
      "title": "792. Number of Matching Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34a26443-b1bd-44fe-992e-0072f3333f09",
      "code": "class Solution:\n  def validTicTacToe(self, board: list[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return (any(row.count(c) == 3 for row in board) or\n              any(row.count(c) == 3 for row in list(zip(*board))) or\n              all(board[i][i] == c for i in range(3)) or\n              all(board[i][2 - i] == c for i in range(3)))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True",
      "title": "794. Valid Tic-Tac-Toe State",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "500ccd1a-aaae-4d3a-8bd7-073aaa93834f",
      "code": "class Solution:\n  def numSubarrayBoundedMax(\n      self,\n      nums: list[int],\n      left: int,\n      right: int,\n  ) -> int:\n    ans = 0\n    l = -1\n    r = -1\n\n    for i, num in enumerate(nums):\n      if num > right:  # Handle the reset value.\n        l = i\n      if num >= left:  # Handle the reset and the needed value.\n        r = i\n      ans += r - l\n\n    return ans",
      "title": "795. Number of Subarrays with Bounded Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e589750f-2e94-469e-9994-19d598e38833",
      "code": "class Solution:\n  def rotateString(self, s: str, goal: str) -> bool:\n    return len(s) == len(goal) and goal in s + s",
      "title": "796. Rotate String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70a09496-7936-4d29-9378-9d238e73ee43",
      "code": "class Solution:\n  def allPathsSourceTarget(self, graph: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(u: int, path: list[int]) -> None:\n      if u == len(graph) - 1:\n        ans.append(path)\n        return\n\n      for v in graph[u]:\n        dfs(v, path + [v])\n\n    dfs(0, [0])\n    return ans",
      "title": "797. All Paths From Source to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df1278ad-6df3-44b8-9c49-1a1eda81d28a",
      "code": "class Solution:\n  def similarRGB(self, color: str) -> str:\n    SHORTHANDS = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',\n                  'aa', 'bb', 'cc', 'dd', 'ee', 'ff']\n    ans = ['#']\n\n    for i in range(1, len(color), 2):\n      currValue = int(color[i:i + 2], 16)\n      closestShorthand = min(SHORTHANDS,\n                             key=lambda x: (currValue - int(x, 16))**2)\n      ans.append(closestShorthand)\n\n    return ''.join(ans)",
      "title": "800. Similar RGB Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0930e40a-7df8-43e2-8864-4ce3642a0a8c",
      "code": "class Solution:\n  def minSwap(self, nums1: list[int], nums2: list[int]) -> int:\n    keepAt = [math.inf] * len(nums1)\n    swapAt = [math.inf] * len(nums1)\n    keepAt[0] = 0\n    swapAt[0] = 1\n\n    for i in range(1, len(nums1)):\n      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n        keepAt[i] = keepAt[i - 1]\n        swapAt[i] = swapAt[i - 1] + 1\n      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n        keepAt[i] = min(keepAt[i], swapAt[i - 1])\n        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)\n\n    return min(keepAt[-1], swapAt[-1])",
      "title": "801. Minimum Swaps To Make Sequences Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8fa339-22d2-4ce1-9fbb-6bfd6d4ca617",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return [i for i in range(len(graph)) if not hasCycle(i)]",
      "title": "802. Find Eventual Safe States",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37d2435b-105d-4182-a11c-b9de98827368",
      "code": "class Solution:\n  def uniqueMorseRepresentations(self, words: list[str]) -> int:\n    morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\",\n             \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\",\n             \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n    transformations = set()\n\n    for word in words:\n      transformation = ''.join(\n          morse[ord(c) - ord('a')] for c in word)\n      transformations.add(transformation)\n\n    return len(transformations)",
      "title": "804. Unique Morse Code Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76f5431f-f12a-4072-9425-9c668815d746",
      "code": "class Solution:\n  def splitArraySameAverage(self, nums: list[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False",
      "title": "805. Split Array With Same Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d14bbe6e-41a3-4297-9d46-6a9b81629726",
      "code": "class Solution:\n  def numberOfLines(self, widths: list[int], s: str) -> list[int]:\n    numLines = 1\n    runningWidth = 0\n\n    for c in s:\n      width = widths[ord(c) - ord('a')]\n      if runningWidth + width <= 100:\n        runningWidth += width\n      else:\n        numLines += 1\n        runningWidth = width\n\n    return [numLines, runningWidth]",
      "title": "806. Number of Lines To Write String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cbc358c-f85e-4958-a6e6-2dfaaffebb3b",
      "code": "class Solution:\n  def maxIncreaseKeepingSkyline(self, grid: list[list[int]]) -> int:\n    rowMax = list(map(max, grid))\n    colMax = list(map(max, zip(*grid)))\n    return sum(min(i, j) for i in rowMax for j in colMax) - sum(map(sum, grid))",
      "title": "807. Max Increase to Keep City Skyline",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab440c3f-6162-4f7b-b6a3-17d2957194cf",
      "code": "class Solution:\n  def soupServings(self, n: int) -> float:\n    @functools.lru_cache(None)\n    def dfs(a: int, b: int) -> float:\n      if a <= 0 and b <= 0:\n        return 0.5\n      if a <= 0:\n        return 1.0\n      if b <= 0:\n        return 0.0\n      return 0.25 * (dfs(a - 4, b) +\n                     dfs(a - 3, b - 1) +\n                     dfs(a - 2, b - 2) +\n                     dfs(a - 1, b - 3))\n\n    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)",
      "title": "808. Soup Servings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d12c3d1-d435-41b8-8e27-f5035987674e",
      "code": "class Solution:\n  def expressiveWords(self, s: str, words: list[str]) -> int:\n    def isStretchy(word: str) -> bool:\n      n = len(s)\n      m = len(word)\n\n      j = 0\n      for i in range(n):\n        if j < m and s[i] == word[j]:\n          j += 1\n        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:\n          continue\n        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:\n          continue\n        else:\n          return False\n\n      return j == m\n\n    return sum(isStretchy(word) for word in words)",
      "title": "809. Expressive Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92efed72-f2f9-4f5f-a658-93b2db2bc9dc",
      "code": "class Solution:\n  def xorGame(self, nums: list[int]) -> bool:\n    return functools.reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0",
      "title": "810. Chalkboard XOR Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f345bd03-4b4c-4f96-a35b-40e427fb3d35",
      "code": "class Solution:\n  def subdomainVisits(self, cpdomains: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    for cpdomain in cpdomains:\n      num, domains = cpdomain.split()\n      num, domains = int(num), domains.split('.')\n      for i in reversed(range(len(domains))):\n        count['.'.join(domains[i:])] += num\n\n    return [str(freq) + ' ' + domain for domain, freq in count.items()]",
      "title": "811. Subdomain Visit Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2eeae533-5e99-425a-8d8f-f41f2ad74704",
      "code": "class Solution:\n  def largestTriangleArea(self, points: list[list[int]]) -> float:\n    ans = 0\n\n    for Ax, Ay in points:\n      for Bx, By in points:\n        for Cx, Cy in points:\n          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -\n                                   (Cx - Ax) * (By - Ay)))\n\n    return ans",
      "title": "812. Largest Triangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96a69e61-42d5-4108-9eb5-d5a6c6874c0e",
      "code": "class Solution:\n  def pruneTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.pruneTree(root.left)\n    root.right = self.pruneTree(root.right)\n    if not root.left and not root.right and not root.val:\n      return None\n    return root",
      "title": "814. Binary Tree Pruning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "590a3da0-f5e5-45c6-9720-ab66ea2d6548",
      "code": "class Solution:\n  def numBusesToDestination(\n      self,\n      routes: list[list[int]],\n      source: int,\n      target: int,\n  ) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    q = collections.deque([source])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return step\n            q.append(nextRoute)\n      step += 1\n\n    return -1",
      "title": "815. Bus Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a50466d-4b12-42a7-a1fd-7fe153ce69b0",
      "code": "class Solution:\n  def ambiguousCoordinates(self, s: str) -> list[str]:\n    def splits(s: str) -> list[str]:\n      if not s or len(s) > 1 and s[0] == s[-1] == '0':\n        return []\n      if s[-1] == '0':\n        return [s]\n      if s[0] == '0':\n        return [s[0] + '.' + s[1:]]\n      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]\n\n    ans = []\n    s = s[1:-1]\n\n    for i in range(1, len(s)):\n      for x in splits(s[:i]):\n        for y in splits(s[i:]):\n          ans.append('(%s, %s)' % (x, y))\n\n    return ans",
      "title": "816. Ambiguous Coordinates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1924962-05c3-4d63-84e9-a0d995d516ae",
      "code": "class Solution:\n  def numComponents(self, head: ListNode | None, nums: list[int]) -> int:\n    ans = 0\n    numsSet = set(nums)\n\n    while head:\n      if head.val in numsSet and (\n              head.next == None or head.next.val not in numsSet):\n        ans += 1\n      head = head.next\n\n    return ans",
      "title": "817. Linked List Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aefd4699-b1c8-472b-9800-fd71117801e2",
      "code": "class Solution:\n  def mostCommonWord(self, paragraph: str, banned: list[str]) -> str:\n    banned = set(banned)\n    words = re.findall(r'\\w+', paragraph.lower())\n    return collections.Counter(\n        word for word in words if word not in banned).most_common(1)[0][0]",
      "title": "819. Most Common Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851b9f35-ca7d-47a3-b8bd-093ea3eca20c",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.depth = 0\n\n\nclass Solution:\n  def minimumLengthEncoding(self, words: list[str]) -> int:\n    root = TrieNode()\n    leaves = []\n\n    def insert(word: str) -> TrieNode:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n      node.depth = len(word)\n      return node\n\n    for word in set(words):\n      leaves.append(insert(word))\n\n    return sum(leaf.depth + 1 for leaf in leaves\n               if not len(leaf.children))",
      "title": "820. Short Encoding of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0188d272-bb14-47fe-a1ff-4de208590a01",
      "code": "class Solution:\n  def shortestToChar(self, s: str, c: str) -> list[int]:\n    n = len(s)\n    ans = [0] * n\n    prev = -n\n\n    for i in range(n):\n      if s[i] == c:\n        prev = i\n      ans[i] = i - prev\n\n    for i in range(prev - 1, -1, -1):\n      if s[i] == c:\n        prev = i\n      ans[i] = min(ans[i], prev - i)\n\n    return ans",
      "title": "821. Shortest Distance to a Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c5def75-eb81-419c-81ff-36a46cfc4d41",
      "code": "class Solution:\n  def flipgame(self, fronts: list[int], backs: list[int]) -> int:\n    same = {front\n            for front, back in zip(fronts, backs)\n            if front == back}\n    return min([num for num in fronts + backs\n                if num not in same] or [0])",
      "title": "822. Card Flipping Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c41d331-728e-4a65-81d0-1ce6033c1d99",
      "code": "class Solution:\n  def numFactoredBinaryTrees(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    # dp[i] := the number of binary trees with arr[i] as the root\n    dp = [1] * n\n    arr.sort()\n    numToIndex = {a: i for i, a in enumerate(arr)}\n\n    for i, root in enumerate(arr):  # arr[i] is the root\n      for j in range(i):\n        if root % arr[j] == 0:  # arr[j] is the left subtree\n          right = root // arr[j]\n          if right in numToIndex:\n            dp[i] += dp[j] * dp[numToIndex[right]]\n            dp[i] %= MOD\n\n    return sum(dp) % MOD",
      "title": "823. Binary Trees With Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1f38932-4b41-46f5-84ce-db5559a5cb04",
      "code": "class Solution:\n  def toGoatLatin(self, sentence: str) -> str:\n    ans = []\n    VOWELS = 'aeiouAEIOU'\n\n    i = 1\n    for word in sentence.split():\n      if i > 1:\n        ans.append(' ')\n      if word[0] in VOWELS:\n        ans.append(word)\n      else:\n        ans.append(word[1:] + word[0])\n      ans.append('ma' + 'a' * i)\n      i += 1\n\n    return ''.join(ans)",
      "title": "824. Goat Latin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d31d5bac-b371-4fe3-aa1c-5e790a490f5b",
      "code": "class Solution:\n  def numFriendRequests(self, ages: list[int]) -> int:\n    ans = 0\n    count = [0] * 121\n\n    for age in ages:\n      count[age] += 1\n\n    for i in range(15, 121):\n      ans += count[i] * (count[i] - 1)\n\n    for i in range(15, 121):\n      for j in range(i // 2 + 8, i):\n        ans += count[i] * count[j]\n\n    return ans",
      "title": "825. Friends Of Appropriate Ages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e135a46-0238-4ceb-b005-7bf6294a5581",
      "code": "class Solution:\n  def maxProfitAssignment(\n      self,\n      difficulty: list[int],\n      profit: list[int],\n      worker: list[int],\n  ) -> int:\n    ans = 0\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort(reverse=1)\n\n    i = 0\n    maxProfit = 0\n\n    for w in sorted(worker):\n      while i < len(jobs) and w >= jobs[i][0]:\n        maxProfit = max(maxProfit, jobs[i][1])\n        i += 1\n      ans += maxProfit\n\n    return ans",
      "title": "826. Most Profit Assigning Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51580c1c-71f4-4f86-91d3-98cd2702cfcd",
      "code": "class Solution:\n  def uniqueLetterString(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time ('a' + i) appeared\n    lastSeen = collections.defaultdict(lambda: -1)\n    # prevSeen[c] := the previous index of the last time ('a' + i) appeared\n    prevLastSeen = collections.defaultdict(lambda: -1)\n\n    for i, c in enumerate(s):\n      if c in lastSeen:\n        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n      prevLastSeen[c] = lastSeen[c]\n      lastSeen[c] = i\n\n    for c in string.ascii_uppercase:\n      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n\n    return ans",
      "title": "828. Count Unique Characters of All Substrings of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae27c99d-286f-47da-b5b6-fa67de0c2834",
      "code": "class Solution:\n  def consecutiveNumbersSum(self, n: int) -> int:\n    ans = 0\n    i = 1\n    triangleNum = 1\n    while triangleNum <= n:\n      if (n - triangleNum) % i == 0:\n        ans += 1\n      i += 1\n      triangleNum += i\n    return ans",
      "title": "829. Consecutive Numbers Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2d03d1e-92d2-44bf-8367-e02a39768f2c",
      "code": "class Solution:\n  def largeGroupPositions(self, s: str) -> list[list[int]]:\n    n = len(s)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      while j < n and s[j] == s[i]:\n        j += 1\n      if j - i >= 3:\n        ans.append([i, j - 1])\n      i = j\n\n    return ans",
      "title": "830. Positions of Large Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704c7da3-757d-4136-9a3a-ddaa86259aa1",
      "code": "class Solution:\n  def maskPII(self, s: str) -> str:\n    atIndex = s.find('@')\n    if atIndex != -1:\n      s = s.lower()\n      return s[0] + '*' * 5 + s[atIndex - 1:]\n\n    ans = ''.join(c for c in s if c.isdigit())\n\n    if len(ans) == 10:\n      return '***-***-' + ans[-4:]\n    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]",
      "title": "831. Masking Personal Information",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c500778-4dbf-4adb-b8d3-cba6e7b34138",
      "code": "class Solution:\n  def flipAndInvertImage(self, A: list[list[int]]) -> list[list[int]]:\n    n = len(A)\n\n    for i in range(n):\n      for j in range((n + 2) // 2):\n        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1\n\n    return A",
      "title": "832. Flipping an Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e66cee14-5132-4e94-8085-e302396d66d1",
      "code": "class Solution:\n  def findReplaceString(\n      self,\n      s: str,\n      indices: list[int],\n      sources: list[str],\n      targets: list[str]\n  ) -> str:\n    for index, source, target in sorted(zip(indices, sources, targets),\n                                        reverse=True):\n      if s[index:index + len(source)] == source:\n        s = s[:index] + target + s[index + len(source):]\n    return s",
      "title": "833. Find And Replace in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a25f8522-3594-471c-aa73-505bfb0fc2fb",
      "code": "class Solution:\n  def sumOfDistancesInTree(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    count = [1] * n\n    tree = [set() for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    def postorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        postorder(v, u)\n        count[u] += count[v]\n        ans[u] += ans[v] + count[v]\n\n    def preorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # count[v] us are 1 step closer from v than prev.\n        # (n - count[v]) us are 1 step farther from v than prev.\n        ans[v] = ans[u] - count[v] + (n - count[v])\n        preorder(v, u)\n\n    postorder(0, -1)\n    preorder(0, -1)\n    return ans",
      "title": "834. Sum of Distances in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0162753a-3e0d-441e-97b7-fc0504021e64",
      "code": "class Solution:\n  def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:\n    MAGIC = 100\n    ones1 = [(i, j)\n             for i, row in enumerate(img1)\n             for j, num in enumerate(row)\n             if num == 1]\n    ones2 = [(i, j)\n             for i, row in enumerate(img2)\n             for j, num in enumerate(row)\n             if num == 1]\n    offsetCount = collections.Counter()\n\n    for ax, ay in ones1:\n      for bx, by in ones2:\n        offsetCount[(ax - bx) * MAGIC + (ay - by)] += 1\n\n    return max(offsetCount.values()) if offsetCount else 0",
      "title": "835. Image Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd3b4625-e633-4324-9f3a-c332cded26bf",
      "code": "class Solution:\n  def isRectangleOverlap(self, rec1: list[int], rec2: list[int]) -> bool:\n    return rec1[0] < rec2[2] and rec2[0] < rec1[2] and rec1[1] < rec2[3] and rec2[1] < rec1[3]",
      "title": "836. Rectangle Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d8bb842-eb17-4056-9aad-fd4a0f8b5476",
      "code": "class Solution:\n  def new21Game(self, n: int, k: int, maxPts: int) -> float:\n    # When the game ends, the point is in [k..k - 1 maxPts].\n    #   P = 1, if n >= k - 1 + maxPts\n    #   P = 0, if n < k (note that the constraints already have k <= n)\n    if k == 0 or n >= k - 1 + maxPts:\n      return 1.0\n\n    ans = 0.0\n    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points\n    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)\n\n    for i in range(1, n + 1):\n      # The probability to get i points is\n      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts\n      dp[i] = windowSum / maxPts\n      if i < k:\n        windowSum += dp[i]\n      else:  # The game ends.\n        ans += dp[i]\n      if i - maxPts >= 0:\n        windowSum -= dp[i - maxPts]\n\n    return ans",
      "title": "837. New 21 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67d76736-0181-4cd5-aa57-f7fdf707bcbe",
      "code": "class Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)",
      "title": "838. Push Dominoes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b3c62ef-ddd0-4003-bb88-f6b3e2bec1c9",
      "code": "class Solution:\n  def numMagicSquaresInside(self, grid: list[list[int]]) -> int:\n    def isMagic(i: int, j: int) -> int:\n      s = \"\".join(str(grid[i + num // 3][j + num % 3])\n                  for num in [0, 1, 2, 5, 8, 7, 6, 3])\n      return s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2\n\n    ans = 0\n\n    for i in range(len(grid) - 2):\n      for j in range(len(grid[0]) - 2):\n        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:\n          ans += isMagic(i, j)\n\n    return ans",
      "title": "840. Magic Squares In Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9693630c-a8ec-4725-bdd4-cf27e2482801",
      "code": "class Solution:\n  def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n    seen = [False] * len(rooms)\n\n    def dfs(node: int) -> None:\n      seen[node] = True\n      for child in rooms[node]:\n        if not seen[child]:\n          dfs(child)\n\n    dfs(0)\n    return all(seen)",
      "title": "841. Keys and Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "190dff37-def0-42b9-877d-529cd39a5cf5",
      "code": "# \"\"\"\n# This is Master's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class Master:\n#   def guess(self, word: str) -> int:\n\nclass Solution:\n  def findSecretWord(self, words: list[str], master: 'Master') -> None:\n    for _ in range(10):\n      guessedWord = words[random.randint(0, len(words) - 1)]\n      matches = master.guess(guessedWord)\n      if matches == 6:\n        break\n      words = [\n          word for word in words\n          if sum(c1 == c2 for c1, c2 in zip(guessedWord, word)) == matches]",
      "title": "843. Guess the Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57ae9f06-96c2-4456-9247-6f120a19f7be",
      "code": "class Solution:\n  def backspaceCompare(self, s: str, t: str) -> bool:\n    i = len(s) - 1  # s' index\n    j = len(t) - 1  # t's index\n\n    while True:\n      # Delete characters of s if needed.\n      backspace = 0\n      while i >= 0 and (s[i] == '#' or backspace > 0):\n        backspace += 1 if s[i] == '#' else -1\n        i -= 1\n      # Delete characters of t if needed.\n      backspace = 0\n      while j >= 0 and (t[j] == '#' or backspace > 0):\n        backspace += 1 if t[j] == '#' else -1\n        j -= 1\n      if i >= 0 and j >= 0 and s[i] == t[j]:\n        i -= 1\n        j -= 1\n      else:\n        break\n\n    return i == -1 and j == -1",
      "title": "844. Backspace String Compare",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cda4885d-685b-4179-b0f8-5970f8b1780f",
      "code": "class Solution:\n  def longestMountain(self, arr: list[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans",
      "title": "845. Longest Mountain in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d401381-ff4b-497d-aa8b-9086125b94c7",
      "code": "class Solution:\n  def isNStraightHand(self, hand: list[int], groupSize: int) -> bool:\n    count = collections.Counter(hand)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + groupSize):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "846. Hand of Straights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e5bfc51-fb57-4ecc-963d-f9f0c3ed8d79",
      "code": "class Solution:\n  def shortestPathLength(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    goal = (1 << n) - 1\n    q = collections.deque()  # (u, state)\n    seen = set()\n\n    for i in range(n):\n      q.append((i, 1 << i))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, state = q.popleft()\n        if state == goal:\n          return step\n        if (u, state) in seen:\n          continue\n        seen.add((u, state))\n        for v in graph[u]:\n          q.append((v, state | 1 << v))\n      step += 1\n\n    return -1",
      "title": "847. Shortest Path Visiting All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f3c7c5b-e6cd-41b8-9fcd-6c9953719e52",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[int]) -> str:\n    ans = []\n\n    for i in reversed(range(len(shifts) - 1)):\n      shifts[i] += shifts[i + 1]\n\n    for c, shift in zip(s, shifts):\n      ans.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))\n\n    return ''.join(ans)",
      "title": "848. Shifting Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be8b7e43-1b8c-4f47-92d1-7392ebb01ce2",
      "code": "class Solution:\n  def maxDistToClosest(self, seats: list[int]) -> int:\n    n = len(seats)\n    ans = 0\n    j = -1\n\n    for i in range(n):\n      if seats[i] == 1:\n        ans = i if j == -1 else max(ans, (i - j) // 2)\n        j = i\n\n    return max(ans, n - j - 1)",
      "title": "849. Maximize Distance to Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65eae5db-b685-4432-92e2-ea2ed05e3b38",
      "code": "class Solution:\n  def rectangleArea(self, rectangles: list[list[int]]) -> int:\n    events = []\n\n    for x1, y1, x2, y2 in rectangles:\n      events.append((x1, y1, y2, 's'))\n      events.append((x2, y1, y2, 'e'))\n\n    events.sort(key=lambda x: x[0])\n\n    ans = 0\n    prevX = 0\n    yPairs = []\n\n    def getHeight(yPairs: list[tuple[int, int]]) -> int:\n      height = 0\n      prevY = 0\n\n      for y1, y2 in yPairs:\n        prevY = max(prevY, y1)\n        if y2 > prevY:\n          height += y2 - prevY\n          prevY = y2\n\n      return height\n\n    for currX, y1, y2, type in events:\n      if currX > prevX:\n        width = currX - prevX\n        ans += width * getHeight(yPairs)\n        prevX = currX\n      if type == 's':\n        yPairs.append((y1, y2))\n        yPairs.sort()\n      else:  # type == 'e'\n        yPairs.remove((y1, y2))\n\n    return ans % (10**9 + 7)",
      "title": "850. Rectangle Area II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "688075a8-c5f3-4f91-9f08-6620e10e2cf9",
      "code": "class Solution:\n  def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\n    graph = [[] for _ in range(len(quiet))]\n\n    for v, u in richer:\n      graph[u].append(v)\n\n    @functools.lru_cache(None)\n    def dfs(u: int) -> int:\n      ans = u\n\n      for v in graph[u]:\n        res = dfs(v)\n        if quiet[res] < quiet[ans]:\n          ans = res\n\n      return ans\n\n    return map(dfs, range(len(graph)))",
      "title": "851. Loud and Rich",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "169985d4-8001-4199-8218-b79ad6ba9706",
      "code": "class Solution:\n  def peakIndexInMountainArray(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] >= arr[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "852. Peak Index in a Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2119b0b-ecf5-422a-acfe-b29cd0b38e20",
      "code": "class Solution:\n  def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:\n    ans = 0\n    times = [\n        float(target - p) / s for p, s in sorted(zip(position, speed),\n                                                 reverse=True)]\n    maxTime = 0  # the time of the slowest car to reach the target\n\n    for time in times:\n      # A car needs more time to reach the target, so it becomes the slowest.\n      if time > maxTime:\n        maxTime = time\n        ans += 1\n\n    return ans",
      "title": "853. Car Fleet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c73fc7-88a9-4fe9-846f-510394f41682",
      "code": "class Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    q = collections.deque([s1])\n    seen = {s1}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return step\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      step += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> list[str]:\n    children = []\n    s = list(curr)\n    i = 0  # the first index s.t. curr[i] != target[i]\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children",
      "title": "854. K-Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d338943f-5234-4950-81ce-1d0a6402ceb1",
      "code": "class Solution:\n  def scoreOfParentheses(self, s: str) -> int:\n    ans = 0\n    layer = 0\n\n    for a, b in itertools.pairwise(s):\n      if a + b == '()':\n        ans += 1 << layer\n      layer += 1 if a == '(' else -1\n\n    return ans",
      "title": "856. Score of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a23d47f1-d571-4176-a100-2de64c378215",
      "code": "class Solution:\n  def mincostToHireWorkers(\n      self,\n      quality: list[int],\n      wage: list[int],\n      k: int,\n  ) -> float:\n    ans = math.inf\n    qualitySum = 0\n    # (wagePerQuality, quality) sorted by wagePerQuality\n    workers = sorted((w / q, q) for q, w in zip(quality, wage))\n    maxHeap = []\n\n    for wagePerQuality, q in workers:\n      heapq.heappush(maxHeap, -q)\n      qualitySum += q\n      if len(maxHeap) > k:\n        qualitySum += heapq.heappop(maxHeap)\n      if len(maxHeap) == k:\n        ans = min(ans, qualitySum * wagePerQuality)\n\n    return ans",
      "title": "857. Minimum Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02d57cfc-9419-459a-934f-d5abe84ed3f2",
      "code": "class Solution:\n  def mirrorReflection(self, p: int, q: int) -> int:\n    while p % 2 == 0 and q % 2 == 0:\n      p //= 2\n      q //= 2\n\n    if p % 2 == 0:\n      return 2\n    if q % 2 == 0:\n      return 0\n    return 1",
      "title": "858. Mirror Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e3b8bfc-a6ea-4a1a-bda6-0251d3cc3a22",
      "code": "class Solution:\n  def buddyStrings(self, s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n      return False\n    if s == goal and len(set(s)) < len(s):\n      return True\n    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))\n                   if a != b]\n    return (len(diffIndices) == 2 and\n            s[diffIndices[0]] == goal[diffIndices[1]] and\n            s[diffIndices[1]] == goal[diffIndices[0]])",
      "title": "859. Buddy Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c2a077-5a02-457d-9b29-0c6131e57f82",
      "code": "class Solution:\n  def lemonadeChange(self, bills: list[int]) -> bool:\n    fives = 0\n    tens = 0\n\n    for bill in bills:\n      if bill == 5:\n        fives += 1\n      elif bill == 10:\n        fives -= 1\n        tens += 1\n      else:  # bill == 20\n        if tens > 0:\n          tens -= 1\n          fives -= 1\n        else:\n          fives -= 3\n      if fives < 0:\n        return False\n\n    return True",
      "title": "860. Lemonade Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "684f5e9b-1fb8-4aa7-ab2a-d6d7f1f6548d",
      "code": "class Solution:\n  def matrixScore(self, grid: list[list[int]]) -> int:\n    # Flip the rows with a leading 0.\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    # Flip the columns with 1s < 0s.\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    # Add a binary number for each row.\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: list[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: list[list[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: list[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res",
      "title": "861. Score After Flipping Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09cb6622-101e-4ebc-af77-7e65fde72004",
      "code": "class Solution:\n  def shortestSubarray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = n + 1\n    dq = collections.deque()\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(n + 1):\n      while dq and prefix[i] - prefix[dq[0]] >= k:\n        ans = min(ans, i - dq.popleft())\n      while dq and prefix[i] <= prefix[dq[-1]]:\n        dq.pop()\n      dq.append(i)\n\n    return ans if ans <= n else -1",
      "title": "862. Shortest Subarray with Sum at Least K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26840404-09f9-4ad1-92ef-c3e412f22fa9",
      "code": "class Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int) -> int:\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1",
      "title": "866. Prime Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b715a11-c155-481f-8db0-0fa28d78ecfb",
      "code": "class Solution:\n  def transpose(self, A: list[list[int]]) -> list[list[int]]:\n    ans = [[0] * len(A) for _ in range(len(A[0]))]\n\n    for i in range(len(A)):\n      for j in range(len(A[0])):\n        ans[j][i] = A[i][j]\n\n    return ans",
      "title": "867. Transpose Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c417d833-916c-4418-aa7b-8c825b065b9d",
      "code": "class Solution:\n  def binaryGap(self, n: int) -> int:\n    ans = 0\n    d = -32  # the distance between any two 1s\n\n    while n:\n      if n % 2 == 1:\n        ans = max(ans, d)\n        d = 0\n      n //= 2\n      d += 1\n\n    return ans",
      "title": "868. Binary Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c075c6-e308-4171-b421-c0f60dc13e13",
      "code": "class Solution:\n  def reorderedPowerOf2(self, n: int) -> bool:\n    count = collections.Counter(str(n))\n    return any(Counter(str(1 << i)) == count for i in range(30))",
      "title": "869. Reordered Power of 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0072d1c3-016a-41ea-9d0e-088e583c6006",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def advantageCount(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    sl = SortedList(nums1)\n\n    for i, num in enumerate(nums2):\n      index = 0 if sl[-1] <= num else sl.bisect_right(num)\n      nums1[i] = sl[index]\n      del sl[index]\n\n    return nums1",
      "title": "870. Advantage Shuffle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "644f2c61-10d4-43ac-9d63-f4c699d28f0b",
      "code": "class Solution:\n  def minRefuelStops(\n      self,\n      target: int,\n      startFuel: int,\n      stations: list[list[int]],\n  ) -> int:\n    ans = 0\n    i = 0  # station's index\n    curr = startFuel\n    maxHeap = []\n\n    while curr < target:\n      # Add all the reachable stops to maxHeap\n      while i < len(stations) and stations[i][0] <= curr:\n        heapq.heappush(maxHeap, -stations[i][1])\n        i += 1\n      if not maxHeap:  # Can't be refueled.\n        return -1\n      curr -= heapq.heappop(maxHeap)  # Pop out the largest gas.\n      ans += 1  # Then, refuel once.\n\n    return ans",
      "title": "871. Minimum Number of Refueling Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82b1d2a4-80da-4077-8ea9-782c6cd310fc",
      "code": "class Solution:\n  def leafSimilar(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    def dfs(root: TreeNode | None) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        yield root.val\n        return\n\n      yield from dfs(root.left)\n      yield from dfs(root.right)\n\n    return list(dfs(root1)) == list(dfs(root2))",
      "title": "872. Leaf-Similar Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "681266b1-5053-46a0-8a36-e11d405e1ed6",
      "code": "class Solution:\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    numToIndex = {a: i for i, a in enumerate(arr)}\n    dp = [[2] * n for _ in range(n)]\n\n    for j in range(n):\n      for k in range(j + 1, n):\n        ai = arr[k] - arr[j]\n        if ai < arr[j] and ai in numToIndex:\n          i = numToIndex[ai]\n          dp[j][k] = dp[i][j] + 1\n          ans = max(ans, dp[j][k])\n\n    return ans",
      "title": "873. Length of Longest Fibonacci Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58606dc0-81e2-4752-9e6b-4495727806ee",
      "code": "class Solution:\n  def robotSim(self, commands: list[int], obstacles: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = 0\n    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west\n    x = 0  # the start x\n    y = 0  # the start y\n    obstaclesSet = {(x, y) for x, y in obstacles}\n\n    for command in commands:\n      if command == -1:\n        d = (d + 1) % 4\n      elif command == -2:\n        d = (d + 3) % 4\n      else:\n        for _ in range(command):\n          if (x + DIRS[d][0], y + DIRS[d][1]) in obstaclesSet:\n            break\n          x += DIRS[d][0]\n          y += DIRS[d][1]\n      ans = max(ans, x * x + y * y)\n\n    return ans",
      "title": "874. Walking Robot Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d54159f7-ac21-4cf4-97b8-c47ff6c89042",
      "code": "class Solution:\n  def minEatingSpeed(self, piles: list[int], h: int) -> int:\n    def eatHours(m: int) -> bool:\n      \"\"\"Returns the hours to eat all the piles with speed m.\"\"\"\n      return sum((pile - 1) // m + 1 for pile in piles)\n    l = 1\n    r = max(piles)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: eatHours(m) <= h) + l",
      "title": "875. Koko Eating Bananas",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f3ad94c-71af-4529-a422-f209a526b0a7",
      "code": "class Solution:\n  def middleNode(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    return slow",
      "title": "876. Middle of the Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "839bff5c-5f16-4dd2-aace-6935306cd8bb",
      "code": "class Solution:\n  def stoneGame(self, piles: list[int]) -> bool:\n    n = len(piles)\n    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, pile in enumerate(piles):\n      dp[i][i] = pile\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = max(piles[i] - dp[i + 1][j],\n                       piles[j] - dp[i][j - 1])\n\n    return dp[0][n - 1] > 0",
      "title": "877. Stone Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6032b462-9490-400f-b6ce-22d17905ccc9",
      "code": "class Solution:\n  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n    lcm = a * b // math.gcd(a, b)\n    l = min(a, b)\n    r = min(a, b) * n\n    ans = bisect.bisect_left(range(l, r), n,\n                             key=lambda m: m // a + m // b - m // lcm) + l\n    return ans % (10**9 + 7)",
      "title": "878. Nth Magical Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e555bb14-ebc4-4669-a538-49cb21763643",
      "code": "class Solution:\n  def decodeAtIndex(self, s: str, k: int) -> str:\n    size = 0\n\n    for c in s:\n      if c.isdigit():\n        size *= int(c)\n      else:\n        size += 1\n\n    for c in reversed(s):\n      k %= size\n      if k == 0 and c.isalpha():\n        return c\n      if c.isdigit():\n        size //= int(c)\n      else:\n        size -= 1",
      "title": "880. Decoded String at Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9302718c-9b75-4e03-aedb-78e3fec7d50a",
      "code": "class Solution:\n  def numRescueBoats(self, people: list[int], limit: int) -> int:\n    ans = 0\n    i = 0\n    j = len(people) - 1\n\n    people.sort()\n\n    while i <= j:\n      remain = limit - people[j]\n      j -= 1\n      if people[i] <= remain:\n        i += 1\n      ans += 1\n\n    return ans",
      "title": "881. Boats to Save People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b718b4e-53f4-4b11-bcca-ab712cb5ca35",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      edges: list[list[int]],\n      maxMoves: int,\n      n: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      # the number of reachable nodes of (u, v) from `u`\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      # the number of reachable nodes of (u, v) from `v`\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      maxMoves: int,\n      dist: list[int],\n  ) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      # Already took `maxMoves` to reach `u`, so can't explore anymore.\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)",
      "title": "882. Reachable Nodes In Subdivided Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69044dd1-5ea5-403b-8daa-44e0a4200d5a",
      "code": "class Solution:\n  def projectionArea(self, grid: list[list[int]]) -> int:\n    return sum(\n        a > 0 for row in grid for a in row) + sum(\n        max(row) for row in grid) + sum(\n        max(col) for col in zip(*grid))",
      "title": "883. Projection Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56936c18-3ee5-42ab-9ea8-37448c05bac8",
      "code": "class Solution:\n  def uncommonFromSentences(self, A: str, B: str) -> list[str]:\n    count = collections.Counter((A + ' ' + B).split())\n    return [word for word, freq in count.items() if freq == 1]",
      "title": "884. Uncommon Words from Two Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41d6cbd6-4ac1-45d7-a25a-cd6e94aae2ef",
      "code": "class Solution:\n  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> list[list[int]]:\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n    ans = [[rStart, cStart]]\n    i = 0\n\n    while len(ans) < rows * cols:\n      for _ in range(i // 2 + 1):\n        rStart += dy[i % 4]\n        cStart += dx[i % 4]\n        if 0 <= rStart < rows and 0 <= cStart < cols:\n          ans.append([rStart, cStart])\n      i += 1\n\n    return ans",
      "title": "885. Spiral Matrix III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eea681f3-faa7-4969-b566-9b7ef1541fbd",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def possibleBipartition(self, n: int, dislikes: list[list[int]]) -> bool:\n    graph = [[] for _ in range(n + 1)]\n    colors = [Color.WHITE] * (n + 1)\n\n    for u, v in dislikes:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Reduce to 785. Is Graph Bipartite?\n    def isValidColor(u: int, color: Color) -> bool:\n      # Always paint red for a white node.\n      if colors[u] != Color.WHITE:\n        return colors[u] == color\n\n      colors[u] = color  # Always paint the node with `color`.\n\n      # All the children should have valid colors.\n      childrenColor = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n      return all(isValidColor(v, childrenColor) for v in graph[u])\n\n    return all(colors[i] != Color.WHITE or isValidColor(i, Color.RED)\n               for i in range(1, n + 1))",
      "title": "886. Possible Bipartition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d52e7a5-f263-4abc-9e74-f88b318c2afb",
      "code": "class Solution:\n  def superEggDrop(self, k: int, n: int) -> int:\n    moves = 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    while dp[moves][k] < n:\n      moves += 1\n      for eggs in range(1, k + 1):\n        dp[moves][eggs] = (dp[moves - 1][eggs - 1] +\n                           dp[moves - 1][eggs] + 1)\n\n    return moves",
      "title": "887. Super Egg Drop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "217afad0-c506-41a5-a621-2b7232dab086",
      "code": "class Solution:\n  def fairCandySwap(\n      self,\n      aliceSizes: list[int],\n      bobSizes: list[int],\n  ) -> list[int]:\n    diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n    bobSizesSet = set(bobSizes)\n\n    for aliceSize in aliceSizes:\n      target = aliceSize - diff\n      if target in bobSizesSet:\n        return [aliceSize, target]",
      "title": "888. Fair Candy Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5645ebc-2a9f-4604-9944-9f60681d3c8f",
      "code": "class Solution:\n  def constructFromPrePost(\n      self,\n      pre: list[int],\n      post: list[int],\n  ) -> TreeNode | None:\n    postToIndex = {num: i for i, num in enumerate(post)}\n\n    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n      if preStart == preEnd:\n        return TreeNode(pre[preStart])\n\n      rootVal = pre[preStart]\n      leftRootVal = pre[preStart + 1]\n      leftRootPostIndex = postToIndex[leftRootVal]\n      leftSize = leftRootPostIndex - postStart + 1\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        postStart, leftRootPostIndex)\n      root.right = build(preStart + leftSize + 1, preEnd,\n                         leftRootPostIndex + 1, postEnd - 1)\n      return root\n\n    return build(0, len(pre) - 1, 0, len(post) - 1)",
      "title": "889. Construct Binary Tree from Preorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf13d263-fd75-414e-ac77-303cc1e87a02",
      "code": "class Solution:\n  def findAndReplacePattern(self, words: list[str], pattern: str) -> list[str]:\n    def isIsomorphic(w: str, p: str) -> bool:\n      return [*map(w.index, w)] == [*map(p.index, p)]\n    return [word for word in words if isIsomorphic(word, pattern)]",
      "title": "890. Find and Replace Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf7a0199-96da-4afb-bb92-1a146205a779",
      "code": "class Solution:\n  def sumSubseqWidths(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    exp = 1\n\n    nums.sort()\n\n    for i in range(n):\n      ans += (nums[i] - nums[n - 1 - i]) * exp\n      ans %= MOD\n      exp = exp * 2 % MOD\n\n    return ans",
      "title": "891. Sum of Subsequence Widths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23f4a6b8-8543-4de3-a555-be9a263c406c",
      "code": "class Solution:\n  def surfaceArea(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(len(grid)):\n      for j in range(len(grid)):\n        if grid[i][j]:\n          ans += grid[i][j] * 4 + 2\n        if i > 0:\n          ans -= min(grid[i][j], grid[i - 1][j]) * 2\n        if j > 0:\n          ans -= min(grid[i][j], grid[i][j - 1]) * 2\n\n    return ans",
      "title": "892. Surface Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfd5effd-d27c-484d-8d2a-466a20dc725f",
      "code": "class Solution:\n  def numSpecialEquivGroups(self, words: list[str]) -> int:\n    return len({''.join(sorted(word[::2])) + ''.join(sorted(word[1::2]))\n                for word in words})",
      "title": "893. Groups of Special-Equivalent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0635bb7-59b1-462a-9d0b-0175eb581a7e",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def allPossibleFBT(self, n: int) -> list[TreeNode | None]:\n    if n % 2 == 0:\n      return []\n    if n == 1:\n      return [TreeNode(0)]\n\n    ans = []\n\n    for leftCount in range(n):\n      rightCount = n - 1 - leftCount\n      for left in self.allPossibleFBT(leftCount):\n        for right in self.allPossibleFBT(rightCount):\n          ans.append(TreeNode(0))\n          ans[-1].left = left\n          ans[-1].right = right\n\n    return ans",
      "title": "894. All Possible Full Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16284d22-3681-404f-ae59-70e98419a23f",
      "code": "class Solution:\n  def isMonotonic(self, nums: list[int]) -> bool:\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(nums)):\n      increasing &= nums[i - 1] <= nums[i]\n      decreasing &= nums[i - 1] >= nums[i]\n\n    return increasing or decreasing",
      "title": "896. Monotonic Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9686001f-b1aa-428b-86a0-7d2e80020ef5",
      "code": "class Solution:\n  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:\n    if not root:\n      return tail\n\n    res = self.increasingBST(root.left, root)\n    root.left = None\n    root.right = self.increasingBST(root.right, tail)\n    return res",
      "title": "897. Increasing Order Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9abb68a3-3962-4429-83ed-a1a746e3d41c",
      "code": "class Solution:\n  def orderlyQueue(self, s: str, k: int) -> str:\n    return (''.join(sorted(s)) if k > 1\n            else min(s[i:] + s[:i] for i in range(len(s))))",
      "title": "899. Orderly Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2203547b-1910-43a2-8d07-846e195e105c",
      "code": "class Solution:\n  def atMostNGivenDigitSet(self, digits: list[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n\n    return ans + 1",
      "title": "902. Numbers At Most N Given Digit Set",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf529ef9-b2e4-49dd-bc61-ff9d33a0fad5",
      "code": "class Solution:\n  def totalFruit(self, fruits: list[int]) -> int:\n    ans = 0\n    count = collections.defaultdict(int)\n\n    l = 0\n    for r, fruit in enumerate(fruits):\n      count[fruit] += 1\n      while len(count) > 2:\n        count[fruits[l]] -= 1\n        if count[fruits[l]] == 0:\n          del count[fruits[l]]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "904. Fruit Into Baskets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d0651a1-004c-4c01-8aee-b00fd398c6d6",
      "code": "class Solution:\n  def sortArrayByParity(self, nums: list[int]) -> list[int]:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      if nums[l] % 2 == 1 and nums[r] % 2 == 0:\n        nums[l], nums[r] = nums[r], nums[l]\n      if nums[l] % 2 == 0:\n        l += 1\n      if nums[r] % 2 == 1:\n        r -= 1\n\n    return nums",
      "title": "905. Sort Array By Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b806506-ee93-40a1-9979-13624296efd4",
      "code": "class Solution:\n  def superpalindromesInRange(self, left: str, right: str) -> int:\n    def nextPalindrome(num: int) -> int:\n      s = str(num)\n      n = len(s)\n\n      half = s[0:(n + 1) // 2]\n      reversedHalf = half[:n // 2][::-1]\n      candidate = int(half + reversedHalf)\n      if candidate >= num:\n        return candidate\n\n      half = str(int(half) + 1)\n      reversedHalf = half[:n // 2][::-1]\n      return int(half + reversedHalf)\n\n    def isPalindrome(num: int) -> bool:\n      s = str(num)\n      l = 0\n      r = len(s) - 1\n\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n\n      return True\n\n    ans = 0\n    l = int(left)\n    r = int(right)\n    i = math.isqrt(l)\n\n    while i * i <= r:\n      palindrome = nextPalindrome(i)\n      squared = palindrome**2\n      if squared <= r and isPalindrome(squared):\n        ans += 1\n      i = palindrome + 1\n\n    return ans",
      "title": "906. Super Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2889fb2e-6c9e-47da-b1de-0d18565e8344",
      "code": "class Solution:\n  def sumSubarrayMins(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    ans = 0\n    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]\n    prevMin = [-1] * n\n    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]\n    nextMin = [n] * n\n    stack = []\n\n    for i, a in enumerate(arr):\n      while stack and arr[stack[-1]] > a:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    for i, a in enumerate(arr):\n      ans += a * (i - prevMin[i]) * (nextMin[i] - i)\n      ans %= MOD\n\n    return ans",
      "title": "907. Sum of Subarray Minimums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0361901-9be2-4bae-9b12-ccad02984ea4",
      "code": "class Solution:\n  def smallestRangeI(self, nums: list[int], k: int) -> int:\n    return max(0, max(nums) - min(nums) - 2 * k)",
      "title": "908. Smallest Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5e90b3a-a28e-4428-a3ef-2c6dc9e6e775",
      "code": "class Solution:\n  def snakesAndLadders(self, board: list[list[int]]) -> int:\n    n = len(board)\n    q = collections.deque([1])\n    seen = set()\n    arr = [0] * (1 + n * n)  # 2D -> 1D\n\n    for i in range(n):\n      for j in range(n):\n        arr[(n - 1 - i) * n + (n - j if (n - i) % 2 == 0 else j + 1)] = board[i][j]\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = arr[next] if arr[next] > 0 else next\n          if dest == n * n:\n            return step\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n      step += 1\n\n    return -1",
      "title": "909. Snakes and Ladders",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0514318b-3cc0-409f-a481-9e2c3f8f7d49",
      "code": "class Solution:\n  def smallestRangeII(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = nums[-1] - nums[0]\n    left = nums[0] + k\n    right = nums[-1] - k\n\n    for a, b in itertools.pairwise(nums):\n      mn = min(left, b - k)\n      mx = max(right, a + k)\n      ans = min(ans, mx - mn)\n\n    return ans",
      "title": "910. Smallest Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "279d83cc-ee4d-4ada-aaef-30bb63a31cbe",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfb5013d-ce2b-4592-baa5-209fa7a7292a",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96520893-b4ca-4885-98f3-eb7c8b5f18f3",
      "code": "from enum import IntEnum\n\n\nclass State(IntEnum):\n  DRAW = 0\n  MOUSE_WIN = 1\n  CAT_WIN = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    # result of (cat, mouse, move)\n    # move := 0 (mouse) // 1 (cat)\n    states = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    outDegree = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    q = collections.deque()  # (cat, mouse, move, state)\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    # Start from the states s.t. the winner can be determined.\n    for cat in range(1, n):\n      for move in range(2):\n        # Mouse is in the hole.\n        states[cat][0][move] = int(State.MOUSE_WIN)\n        q.append((cat, 0, move, int(State.MOUSE_WIN)))\n        # Cat catches mouse.\n        states[cat][cat][move] = int(State.CAT_WIN)\n        q.append((cat, cat, move, int(State.CAT_WIN)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:  # invalid\n          continue\n        prevMouse = mouse if prevMove else prev\n        # The state has been determined.\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if (prevMove == 0 and state == int(State.MOUSE_WIN) or\n                prevMove == 1 and state == int(State.CAT_WIN)):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]",
      "title": "913. Cat and Mouse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ead3ac24-a23e-4a65-8ee8-a8ac7f48be58",
      "code": "class Solution:\n  def hasGroupsSizeX(self, deck: list[int]) -> bool:\n    count = collections.Counter(deck)\n    return functools.reduce(math.gcd, count.values()) >= 2",
      "title": "914. X of a Kind in a Deck of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0a3dbae-1b0b-41c0-ac0b-d526441090a7",
      "code": "class Solution:\n  def partitionDisjoint(self, nums: list[int]) -> int:\n    n = len(nums)\n    mn = [0] * (n - 1) + [nums[-1]]\n    mx = -math.inf\n\n    for i in range(n - 2, - 1, -1):\n      mn[i] = min(mn[i + 1], nums[i])\n\n    for i, num in enumerate(nums):\n      mx = max(mx, num)\n      if mx <= mn[i + 1]:\n        return i + 1",
      "title": "915. Partition Array into Disjoint Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5211253-8d3a-47a9-8af8-df8cbccf5b77",
      "code": "class Solution:\n  def wordSubsets(self, A: list[str], B: list[str]) -> list[str]:\n    count = collections.Counter()\n\n    for b in B:\n      count = count | collections.Counter(b)\n\n    return [a for a in A if collections.Counter(a) & count == count]",
      "title": "916. Word Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4fd445a-93ab-4a97-852e-4166c6bc6c57",
      "code": "class Solution:\n  def reverseOnlyLetters(self, s: str) -> str:\n    ans = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      while i < j and not s[i].isalpha():\n        i += 1\n      while i < j and not s[j].isalpha():\n        j -= 1\n      ans[i], ans[j] = ans[j], ans[i]\n      i += 1\n      j -= 1\n\n    return ''.join(ans)",
      "title": "917. Reverse Only Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f87e44fc-d260-4f90-bd4c-e870b0024a70",
      "code": "class Solution:\n  def maxSubarraySumCircular(self, nums: list[int]) -> int:\n    totalSum = 0\n    currMaxSum = 0\n    currMinSum = 0\n    maxSum = -math.inf\n    minSum = math.inf\n\n    for num in nums:\n      totalSum += num\n      currMaxSum = max(currMaxSum + num, num)\n      currMinSum = min(currMinSum + num, num)\n      maxSum = max(maxSum, currMaxSum)\n      minSum = min(minSum, currMinSum)\n\n    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)",
      "title": "918. Maximum Sum Circular Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04d5be5d-2c6f-4e84-be8d-98a013f6a3b3",
      "code": "class Solution:\n  def minAddToMakeValid(self, s: str) -> int:\n    l = 0\n    r = 0\n\n    for c in s:\n      if c == '(':\n        l += 1\n      else:\n        if l == 0:\n          r += 1\n        else:\n          l -= 1\n\n    return l + r",
      "title": "921. Minimum Add to Make Parentheses Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1988ca4a-42bb-404c-800d-3023adf584e4",
      "code": "class Solution:\n  def sortArrayByParityII(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    i = 0\n    j = 1\n    while i < n:\n      while i < n and nums[i] % 2 == 0:\n        i += 2\n      while j < n and nums[j] % 2 == 1:\n        j += 2\n      if i < n:\n        nums[i], nums[j] = nums[j], nums[i]\n\n    return nums",
      "title": "922. Sort Array By Parity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f10b3e29-84c5-478a-b5d2-314cd7eadb32",
      "code": "class Solution:\n  def threeSumMulti(self, arr: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % MOD\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % MOD\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % MOD\n\n    return ans % MOD",
      "title": "923. 3Sum With Multiplicity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67940335-efd7-47b6-99a3-42e366520428",
      "code": "class Solution:\n  def isLongPressedName(self, name: str, typed: str) -> bool:\n    i = 0\n\n    for j, t in enumerate(typed):\n      if i < len(name) and name[i] == t:\n        i += 1\n      elif j == 0 or t != typed[j - 1]:\n        return False\n\n    return i == len(name)",
      "title": "925. Long Pressed Name",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00acddb9-0b06-4492-ab9a-bdc09a3c26c5",
      "code": "class Solution:\n  def minFlipsMonoIncr(self, s: str) -> int:\n    # the number of characters to be flilpped to make the substring so far\n    # monotone increasing\n    dp = 0\n    count1 = 0\n\n    for c in s:\n      if c == '0':\n        # 1. Flip '0'.\n        # 2. Keep '0' and flip all the previous 1s.\n        dp = min(dp + 1, count1)\n      else:\n        count1 += 1\n\n    return dp",
      "title": "926. Flip String to Monotone Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e73e91b-1b8e-4e4b-93f7-f09c53e0710f",
      "code": "class Solution:\n  def threeEqualParts(self, arr: list[int]) -> list[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]",
      "title": "927. Three Equal Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d45361f-837b-48d6-bf6a-047f025de10f",
      "code": "class Solution:\n  def numUniqueEmails(self, emails: list[str]) -> int:\n    seen = set()\n\n    for email in emails:\n      local, domain = email.split('@')\n      local = local.split('+')[0].replace('.', '')\n      seen.add(local + '@' + domain)\n\n    return len(seen)",
      "title": "929. Unique Email Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd3f3b0c-ffe8-4984-b0c7-dde537a4bfd1",
      "code": "class Solution:\n  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:\n    def numSubarraysWithSumAtMost(goal: int) -> int:\n      res = 0\n      count = 0\n      l = 0\n      r = 0\n\n      while r < len(nums):\n        count += nums[r]\n        r += 1\n        while l < r and count > goal:\n          count -= nums[l]\n          l += 1\n        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]\n        res += r - l\n\n      return res\n\n    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)",
      "title": "930. Binary Subarrays With Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4f7c916-2ec6-4480-99a8-acf9bd80fdad",
      "code": "class Solution:\n  def minFallingPathSum(self, A: list[list[int]]) -> int:\n    n = len(A)\n\n    for i in range(1, n):\n      for j in range(n):\n        mn = math.inf\n        for k in range(max(0, j - 1), min(n, j + 2)):\n          mn = min(mn, A[i - 1][k])\n        A[i][j] += mn\n\n    return min(A[-1])",
      "title": "931. Minimum Falling Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598ac813-8be4-494e-a689-8a0b614e298a",
      "code": "class Solution:\n  def beautifulArray(self, n: int) -> list[int]:\n    arr = [i for i in range(1, n + 1)]\n\n    def partition(l: int, r: int, mask: int) -> int:\n      nextSwapped = l\n      for i in range(l, r + 1):\n        if arr[i] & mask:\n          arr[i], arr[nextSwapped] = arr[nextSwapped], arr[i]\n          nextSwapped += 1\n      return nextSwapped - 1\n\n    def divide(l: int, r: int, mask: int) -> None:\n      if l >= r:\n        return\n      m = partition(l, r, mask)\n      divide(l, m, mask << 1)\n      divide(m + 1, r, mask << 1)\n\n    divide(0, n - 1, 1)\n    return arr",
      "title": "932. Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9526af0-6811-4f90-9f59-fa28b4ecf258",
      "code": "class Solution:\n  def knightDialer(self, n: int) -> int:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    MOD = 1_000_000_007\n\n    # dp[i][j] := the number of ways stand on (i, j)\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return sum(map(sum, dp)) % MOD",
      "title": "935. Knight Dialer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "560bfa21-4bb9-4bb8-aa3b-d82bd541e204",
      "code": "class Solution:\n  def movesToStamp(self, stamp: str, target: str) -> list[int]:\n    def stampify(s: int) -> int:\n      \"\"\"\n      Stamps target[i..i + |stamp|) and returns the number of newly stamped\n      characters.\n      e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\".\n      \"\"\"\n      stampified = len(stamp)\n\n      for i, st in enumerate(stamp):\n        if target[s + i] == '*':  # It's already been stamped.\n          stampified -= 1\n        elif target[s + i] != st:  # We can't stamp on the index i.\n          return 0\n\n      for i in range(s, s + len(stamp)):\n        target[i] = '*'\n\n      return stampified\n\n    ans = []\n    target = list(target)\n    # stamped[i] := True if we already stamped target by stamping on index i\n    stamped = [False] * len(target)\n    stampedCount = 0  # Our goal is to make stampedCount = |target|.\n\n    while stampedCount < len(target):\n      isStamped = False\n      # Try to stamp target[i..i + |stamp|) for each index.\n      for i in range(len(target) - len(stamp) + 1):\n        if stamped[i]:\n          continue\n        stampified = stampify(i)\n        if stampified == 0:\n          continue\n        stampedCount += stampified\n        isStamped = True\n        stamped[i] = True\n        ans.append(i)\n      # After trying to stamp on each index, we can't find a valid stamp.\n      if not isStamped:\n        return []\n\n    return ans[::-1]",
      "title": "936. Stamping The Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e7e88f3-eb6f-451b-a7eb-926edd7cf183",
      "code": "class Solution:\n  def reorderLogFiles(self, logs: list[str]) -> list[str]:\n    digitLogs = []\n    letterLogs = []\n\n    for log in logs:\n      i = log.index(' ')\n      if log[i + 1].isdigit():\n        digitLogs.append(log)\n      else:\n        letterLogs.append((log[:i], log[i + 1:]))\n\n    letterLogs.sort(key=lambda x: (x[1], x[0]))\n    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs",
      "title": "937. Reorder Data in Log Files",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce7292d9-fc7c-4735-ac36-85337a876d0d",
      "code": "class Solution:\n  def minAreaRect(self, points: list[list[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0",
      "title": "939. Minimum Area Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783f65b7-2478-4f87-b12a-78451bedb7af",
      "code": "class Solution:\n  def distinctSubseqII(self, s: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('a' + i)\n    endsIn = [0] * 26\n\n    for c in s:\n      endsIn[ord(c) - ord('a')] = (sum(endsIn) + 1) % MOD\n\n    return sum(endsIn) % MOD",
      "title": "940. Distinct Subsequences II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b2f1119-dddd-421d-8069-746a9e3379d2",
      "code": "class Solution:\n  def validMountainArray(self, arr: list[int]) -> bool:\n    if len(arr) < 3:\n      return False\n\n    l = 0\n    r = len(arr) - 1\n\n    while l + 1 < len(arr) and arr[l] < arr[l + 1]:\n      l += 1\n    while r > 0 and arr[r] < arr[r - 1]:\n      r -= 1\n\n    return l > 0 and r < len(arr) - 1 and l == r",
      "title": "941. Valid Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e43328f-60c4-4547-b069-0a5a7da8518e",
      "code": "class Solution:\n  def diStringMatch(self, s: str) -> list[int]:\n    ans = []\n    mn = 0\n    mx = len(s)\n\n    for c in s:\n      if c == 'I':\n        ans.append(mn)\n        mn += 1\n      else:\n        ans.append(mx)\n        mx -= 1\n\n    return ans + [mn]",
      "title": "942. DI String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9130e768-33b0-4006-a8f7-3c4021aa6379",
      "code": "class Solution:\n  def minDeletionSize(self, strs: list[str]) -> int:\n    ans = 0\n\n    for j in range(len(strs[0])):\n      for i in range(len(strs) - 1):\n        if strs[i][j] > strs[i + 1][j]:\n          ans += 1\n          break\n\n    return ans",
      "title": "944. Delete Columns to Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46f1f8b1-bbae-4581-82e8-c07c195df481",
      "code": "class Solution:\n  def minIncrementForUnique(self, nums: list[int]) -> int:\n    ans = 0\n    minAvailable = 0\n\n    for num in sorted(nums):\n      ans += max(minAvailable - num, 0)\n      minAvailable = max(minAvailable, num) + 1\n\n    return ans",
      "title": "945. Minimum Increment to Make Array Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05a5f6ec-47a7-47f4-a7fc-ff64a71673c1",
      "code": "class Solution:\n  def validateStackSequences(\n      self,\n      pushed: list[int],\n      popped: list[int],\n  ) -> bool:\n    stack = []\n    i = 0  # popped's index\n\n    for x in pushed:\n      stack.append(x)\n      while stack and stack[-1] == popped[i]:\n        stack.pop()\n        i += 1\n\n    return not stack",
      "title": "946. Validate Stack Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bf92bfc-585c-4832-8141-8e6f77fba721",
      "code": "class Solution:\n  def bagOfTokensScore(self, tokens: list[int], power: int) -> int:\n    ans = 0\n    score = 0\n    q = collections.deque(sorted(tokens))\n\n    while q and (power >= q[0] or score):\n      while q and power >= q[0]:\n        # Play the smallest face up.\n        power -= q.popleft()\n        score += 1\n      ans = max(ans, score)\n      if q and score:\n        # Play the largest face down.\n        power += q.pop()\n        score -= 1\n\n    return ans",
      "title": "948. Bag of Tokens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96b1a291-e4e3-4881-9990-a8e16030319f",
      "code": "class Solution:\n  def largestTimeFromDigits(self, arr: list[int]) -> str:\n    for time in itertools.permutations(sorted(arr, reverse=True)):\n      if time[:2] < (2, 4) and time[2] < 6:\n        return '%d%d:%d%d' % time\n    return ''",
      "title": "949. Largest Time for Given Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5b3c5a9-df51-4e25-98ae-8b69621aeacb",
      "code": "class Solution:\n  def deckRevealedIncreasing(self, deck: list[int]) -> list[int]:\n    dq = collections.deque()\n\n    for card in reversed(sorted(deck)):\n      dq.rotate()\n      dq.appendleft(card)\n\n    return list(dq)",
      "title": "950. Reveal Cards In Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e9f5a79-80af-479a-a852-c6dda318819f",
      "code": "class Solution:\n  def flipEquiv(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    if not root1:\n      return not root2\n    if not root2:\n      return not root1\n    if root1.val != root2.val:\n      return False\n    return (self.flipEquiv(root1.left, root2.left) and\n            self.flipEquiv(root1.right, root2.right) or\n            self.flipEquiv(root1.left, root2.right) and\n            self.flipEquiv(root1.right, root2.left))",
      "title": "951. Flip Equivalent Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2dcb99cf-e712-42bd-b486-507eeb771503",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: list[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, math.isqrt(num) + 1):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans",
      "title": "952. Largest Component Size by Common Factor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53c2806a-8394-4d9c-83ad-1ad2a5f85dfa",
      "code": "class Solution:\n  def isAlienSorted(self, words: list[str], order: str) -> bool:\n    dict = {c: i for i, c in enumerate(order)}\n    words = [[dict[c] for c in word] for word in words]\n    return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))",
      "title": "953. Verifying an Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "387f468f-5990-4c8c-aa12-2d8ff78383d6",
      "code": "class Solution:\n  def canReorderDoubled(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n\n    for key in sorted(count, key=abs):\n      if count[key] > count[2 * key]:\n        return False\n      count[2 * key] -= count[key]\n\n    return True",
      "title": "954. Array of Doubled Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74302cb0-1fd4-4503-bb1a-41c09da68def",
      "code": "class Solution:\n  def prisonAfterNDays(self, cells: list[int], n: int) -> list[int]:\n    nextDayCells = [0] * len(cells)\n    day = 0\n\n    while n > 0:\n      n -= 1\n      for i in range(1, len(cells) - 1):\n        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0\n      if day == 0:\n        firstDayCells = nextDayCells.copy()\n      elif nextDayCells == firstDayCells:\n        n %= day\n      cells = nextDayCells.copy()\n      day += 1\n\n    return cells",
      "title": "957. Prison Cells After N Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54a7045e-a9d8-4fbb-ac00-807d9dad7514",
      "code": "class Solution:\n  def repeatedNTimes(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2):\n      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:\n        return nums[i]\n    return nums[-1]",
      "title": "961. N-Repeated Element in Size 2N Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67f179d9-66a8-4426-a0fd-fcda9ec61909",
      "code": "class Solution:\n  def maxWidthRamp(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i, num in enumerate(nums):\n      if stack == [] or num <= nums[stack[-1]]:\n        stack.append(i)\n\n    for i, num in reversed(list(enumerate(nums))):\n      while stack and num >= nums[stack[-1]]:\n        ans = max(ans, i - stack.pop())\n\n    return ans",
      "title": "962. Maximum Width Ramp",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77414d7e-4180-4411-ae4e-2d903ecbea7f",
      "code": "class Solution:\n  def minAreaFreeRect(self, points: list[list[int]]) -> float:\n    ans = math.inf\n    # For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    # For all pair points \"that share the same center\".\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          # AC is perpendicular to AD.\n          # AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else math.sqrt(ans)",
      "title": "963. Minimum Area Rectangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "731de077-16e3-43bf-a74a-ac4cc7960b02",
      "code": "class Solution:\n  def leastOpsExpressTarget(self, x: int, target: int) -> int:\n    @functools.lru_cache(None)\n    def dfs(target):\n      if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n      if x == target:\n        return 0\n\n      prod = x\n      n = 0\n      while prod < target:\n        prod *= x\n        n += 1\n      if prod == target:\n        return n\n\n      ans = dfs(target - prod // x) + n\n      if prod < 2 * target:\n        ans = min(ans, dfs(prod - target) + n + 1)\n      return ans\n\n    return dfs(target)",
      "title": "964. Least Operators to Express Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8ae6055-27f1-4c7c-8c5e-9fe78bbcba08",
      "code": "class Solution:\n  def isUnivalTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n    if root.left and root.left.val != root.val:\n      return False\n    if root.right and root.right.val != root.val:\n      return False\n    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)",
      "title": "965. Univalued Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "354f2e42-4dfa-4379-a2fd-ff43937833e6",
      "code": "class Solution:\n  def spellchecker(self, wordlist: list[str], queries: list[str]) -> list[str]:\n    def lowerKey(word: str) -> str:\n      return '$' + ''.join([c.lower() for c in word])\n\n    def vowelKey(word: str) -> str:\n      return ''.join(['*' if c.lower() in 'aeiou' else c.lower() for c in word])\n\n    ans = []\n    dict = {}\n\n    for word in wordlist:\n      dict.setdefault(word, word)\n      dict.setdefault(lowerKey(word), word)\n      dict.setdefault(vowelKey(word), word)\n\n    for query in queries:\n      if query in dict:\n        ans.append(dict[query])\n      elif lowerKey(query) in dict:\n        ans.append(dict[lowerKey(query)])\n      elif vowelKey(query) in dict:\n        ans.append(dict[vowelKey(query)])\n      else:\n        ans.append('')\n\n    return ans",
      "title": "966. Vowel Spellchecker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec738521-fa1c-4e5e-81f9-8e6a1579485e",
      "code": "class Solution:\n  def pancakeSort(self, arr: list[int]) -> list[int]:\n    ans = []\n\n    for target in range(len(arr), 0, -1):\n      index = arr.index(target)\n      arr[:index + 1] = arr[:index + 1][::-1]\n      arr[:target] = arr[:target][::-1]\n      ans.append(index + 1)\n      ans.append(target)\n\n    return ans",
      "title": "969. Pancake Sorting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3fa747d-1c84-4bed-b783-52ec9844f83e",
      "code": "class Solution:\n  def powerfulIntegers(self, x: int, y: int, bound: int) -> list[int]:\n    xs = {x**i for i in range(20) if x**i < bound}\n    ys = {y**i for i in range(20) if y**i < bound}\n    return list({i + j for i in xs for j in ys if i + j <= bound})",
      "title": "970. Powerful Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7f8c546-c087-4fe6-a0ac-149daf9f5358",
      "code": "class Solution:\n  def isRationalEqual(self, s: str, t: str) -> bool:\n    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]\n\n    def valueOf(s: str) -> float:\n      if s.find('(') == -1:\n        return float(s)\n\n      # Get the indices.\n      leftParenIndex = s.find('(')\n      rightParenIndex = s.find(')')\n      dotIndex = s.find('.')\n\n      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n      integerAndNonRepeating = float(s[:leftParenIndex])\n      nonRepeatingLength = leftParenIndex - dotIndex - 1\n\n      # repeating := <RepeatingPart>\n      repeating = int(s[leftParenIndex + 1:rightParenIndex])\n      repeatingLength = rightParenIndex - leftParenIndex - 1\n      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]\n\n    return abs(valueOf(s) - valueOf(t)) < 1e-9",
      "title": "972. Equal Rational Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ae38712-1fb5-4719-8e55-4a69de94c829",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      randIndex = random.randint(0, r - l + 1) + l\n      points[randIndex], points[r] = points[r], points[randIndex]\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n\n\nclass Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]",
      "title": "973. K Closest Points to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3096d289-58eb-43ba-b0e0-ce75952e6c64",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    maxHeap = []\n\n    for x, y in points:\n      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n\n    return [pair[1] for pair in maxHeap]",
      "title": "973. K Closest Points to Origin_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16ca2796-cec8-4141-b1de-799bb0752b7e",
      "code": "class Solution:\n  def subarraysDivByK(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = [0] * k\n    count[0] = 1\n\n    for num in nums:\n      prefix = (prefix + num % k + k) % k\n      ans += count[prefix]\n      count[prefix] += 1\n\n    return ans",
      "title": "974. Subarray Sums Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "476a565d-3657-4d23-a427-6b6721335b21",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    nums = sorted(nums)\n\n    for i in range(len(nums) - 1, 1, -1):\n      if nums[i - 2] + nums[i - 1] > nums[i]:\n        return nums[i - 2] + nums[i - 1] + nums[i]\n\n    return 0",
      "title": "976. Largest Perimeter Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e02293f3-4d00-4b8b-a522-022e3153540e",
      "code": "class Solution:\n  def sortedSquares(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    l = 0\n    r = n - 1\n    ans = [0] * n\n\n    while n:\n      n -= 1\n      if abs(nums[l]) > abs(nums[r]):\n        ans[n] = nums[l] * nums[l]\n        l += 1\n      else:\n        ans[n] = nums[r] * nums[r]\n        r -= 1\n\n    return ans",
      "title": "977. Squares of a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fc62713-1493-4974-842b-d38736f081a2",
      "code": "class Solution:\n  def maxTurbulenceSize(self, arr: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(arr)):\n      if arr[i] > arr[i - 1]:\n        increasing = decreasing + 1\n        decreasing = 1\n      elif arr[i] < arr[i - 1]:\n        decreasing = increasing + 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, max(increasing, decreasing))\n\n    return ans",
      "title": "978. Longest Turbulent Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74d1acee-2db0-42f9-9aac-8cb90991608f",
      "code": "class Solution:\n  def countTriplets(self, nums: list[int]) -> int:\n    MAX = 1 << 16\n    ans = 0\n    count = [0] * MAX  # {nums[i] & nums[j]: times}\n\n    for a in nums:\n      for b in nums:\n        count[a & b] += 1\n\n    for num in nums:\n      for i in range(MAX):\n        if (num & i) == 0:\n          ans += count[i]\n\n    return ans",
      "title": "982. Triples with Bitwise AND Equal To Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48f9e0d3-39b6-44d8-9f2e-87cb62120eb2",
      "code": "class Solution:\n  def mincostTickets(self, days: list[int], costs: list[int]) -> int:\n    ans = 0\n    last7 = collections.deque()\n    last30 = collections.deque()\n\n    for day in days:\n      while last7 and last7[0][0] + 7 <= day:\n        last7.popleft()\n      while last30 and last30[0][0] + 30 <= day:\n        last30.popleft()\n      last7.append([day, ans + costs[1]])\n      last30.append([day, ans + costs[2]])\n      ans = min(ans + costs[0], last7[0][1], last30[0][1])\n\n    return ans",
      "title": "983. Minimum Cost For Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2503157-7b9d-4616-b6e1-9e50ccb1e4cf",
      "code": "class Solution:\n  def sumEvenAfterQueries(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    summ = sum(a for a in nums if a % 2 == 0)\n\n    for val, index in queries:\n      if nums[index] % 2 == 0:\n        summ -= nums[index]\n      nums[index] += val\n      if nums[index] % 2 == 0:\n        summ += nums[index]\n      ans.append(summ)\n\n    return ans",
      "title": "985. Sum of Even Numbers After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00e3b4d8-fae7-41d9-9ef0-2da8f1200b94",
      "code": "class Solution:\n  def intervalIntersection(self, firstList: list[list[int]],\n                           secondList: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0\n    j = 0\n\n    while i < len(firstList) and j < len(secondList):\n      # lo := the start of the intersection\n      # hi := the end of the intersection\n      lo = max(firstlist[i][0], secondlist[j][0])\n      hi = min(firstlist[i][1], secondlist[j][1])\n      if lo <= hi:\n        ans.append([lo, hi])\n      if firstlist[i][1] < secondlist[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "986. Interval List Intersections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86666fa9-e426-476f-87ad-17fd65e97ee6",
      "code": "class Solution:\n  def verticalTraversal(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n    xToNodes = collections.defaultdict(list)\n\n    def dfs(node: TreeNode | None, x: int, y: int) -> None:\n      if not node:\n        return\n      xToNodes[x].append((-y, node.val))\n      dfs(node.left, x - 1, y - 1)\n      dfs(node.right, x + 1, y - 1)\n\n    dfs(root, 0, 0)\n\n    for _, nodes in sorted(xToNodes.items(), key=lambda x: x[0]):\n      ans.append([val for _, val in sorted(nodes)])\n\n    return ans",
      "title": "987. Vertical Order Traversal of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edecba12-4a16-4b76-9be6-7e93f5fad950",
      "code": "class Solution:\n  def addToArrayForm(self, num: list[int], k: int) -> list[int]:\n    for i in reversed(range(len(num))):\n      k, num[i] = divmod(num[i] + k, 10)\n\n    while k > 0:\n      num = [k % 10] + num\n      k //= 10\n\n    return num",
      "title": "989. Add to Array-Form of Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dac9932-b090-4ba4-90f1-e1f065c8d35a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: list[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'),\n                 ord(y) - ord('a'))\n\n    return all(\n        uf.find(ord(x) - ord('a')) !=\n        uf.find(ord(y) - ord('a'))\n        for x, op, _, y in equations\n        if op == '!')",
      "title": "990. Satisfiability of Equality Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81ff7981-d75d-41e6-ba7e-5ede58073f5f",
      "code": "class Solution:\n  def brokenCalc(self, startValue: int, target: int) -> int:\n    ops = 0\n\n    while startValue < target:\n      if target % 2 == 0:\n        target //= 2\n      else:\n        target += 1\n      ops += 1\n\n    return ops + startValue - target",
      "title": "991. Broken Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c21c9143-03cc-40ee-9abc-bfeff774608c",
      "code": "class Solution:\n  def subarraysWithKDistinct(self, nums: list[int], k: int) -> int:\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)",
      "title": "992. Subarrays with K Different Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "135794cf-975c-48c9-9f6d-b54db6d50572",
      "code": "class Solution:\n  def minKBitFlips(self, nums: list[int], k: int) -> int:\n    ans = 0\n    flippedTime = 0\n\n    for i, num in enumerate(nums):\n      if i >= k and nums[i - k] == 2:\n        flippedTime -= 1\n      if flippedTime % 2 == num:\n        if i + k > len(nums):\n          return -1\n        ans += 1\n        flippedTime += 1\n        nums[i] = 2\n\n    return ans",
      "title": "995. Minimum Number of K Consecutive Bit Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0ce09a1-a26f-439f-b49c-db8dab651828",
      "code": "class Solution:\n  def numSquarefulPerms(self, nums: list[int]) -> int:\n    ans = 0\n    used = [False] * len(nums)\n\n    def isSquare(num: int) -> bool:\n      root = math.isqrt(num)\n      return root * root == num\n\n    def dfs(path: list[int]) -> None:\n      nonlocal ans\n      if len(path) > 1 and not isSquare(path[-1] + path[-2]):\n        return\n      if len(path) == len(nums):\n        ans += 1\n        return\n\n      for i, a in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        dfs(path + [a])\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "996. Number of Squareful Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e55866d-7ac8-49a9-af04-2ba455604ff2",
      "code": "class Solution:\n  def findJudge(self, n: int, trust: list[list[int]]) -> int:\n    count = [0] * (n + 1)\n\n    for a, b in trust:\n      count[a] -= 1\n      count[b] += 1\n\n    for i in range(1, n + 1):\n      if count[i] == n - 1:\n        return i\n\n    return -1",
      "title": "997. Find the Town Judge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcfa85ea-b5ca-49e2-b850-ca8e4901e7d8",
      "code": "class Solution:\n  def insertIntoMaxTree(\n      self,\n      root: TreeNode | None,\n      val: int,\n  ) -> TreeNode | None:\n    if root.val < val:\n      return TreeNode(val, root, None)\n    curr = root\n    while curr.right and curr.right.val > val:\n      curr = curr.right\n    inserted = TreeNode(val, curr.right, None)\n    curr.right = inserted\n    return root",
      "title": "998. Maximum Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbfcea6d-d4c3-4c2a-84aa-3126ed65ab4a",
      "code": "class Solution:\n  def numRookCaptures(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "999. Available Captures for Rook",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d027bb1c-9bc6-4552-bab0-e5250c9e3038",
      "code": "class Solution:\n  def gridIllumination(\n      self,\n      n: int,\n      lamps: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans",
      "title": "1001. Grid Illumination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff00950a-35f6-4ac0-9b10-5ccb25b40c95",
      "code": "class Solution:\n  def commonChars(self, words: list[str]) -> list[str]:\n    return functools.reduce(lambda a, b: a & b,\n                            map(collections.Counter, words)).elements()",
      "title": "1002. Find Common Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a6181f5-51da-426f-ade9-57b55ee14b32",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == 'c':\n        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n          return False\n        stack.pop()\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return not stack",
      "title": "1003. Check If Word Is Valid After Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28b43cac-8062-4b56-97e1-0bf65b9f1b0e",
      "code": "class Solution:\n  def longestOnes(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        k -= 1\n      while k < 0:\n        if nums[l] == 0:\n          k += 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1004. Max Consecutive Ones III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bce4474-e113-4f66-bec9-47dbd78b3a8d",
      "code": "class Solution:\n  def largestSumAfterKNegations(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      if num > 0 or k == 0:\n        break\n      nums[i] = -num\n      k -= 1\n\n    return sum(nums) - (k % 2) * min(nums) * 2",
      "title": "1005. Maximize Sum Of Array After K Negations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ad2a35e-00c1-46de-a541-7d1e8394b90e",
      "code": "class Solution:\n  def clumsy(self, n: int) -> int:\n    if n == 1:\n      return 1\n    if n == 2:\n      return 2\n    if n == 3:\n      return 6\n    if n == 4:\n      return 7\n    if n % 4 == 1:\n      return n + 2\n    if n % 4 == 2:\n      return n + 2\n    if n % 4 == 3:\n      return n - 1\n    return n + 1",
      "title": "1006. Clumsy Factorial",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d7178ab-9a9a-4caf-90d1-684777197f1e",
      "code": "class Solution:\n  def minDominoRotations(self, tops: list[int], bottoms: list[int]) -> int:\n    for num in range(1, 7):\n      if all(num in pair for pair in zip(tops, bottoms)):\n        return len(tops) - max(tops.count(num), bottoms.count(num))\n    return -1",
      "title": "1007. Minimum Domino Rotations For Equal Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53317cfd-1520-403a-98c3-59ae2576445a",
      "code": "class Solution:\n  def bstFromPreorder(self, preorder: list[int]) -> TreeNode | None:\n    root = TreeNode(preorder[0])\n    stack = [root]\n\n    for i in range(1, len(preorder)):\n      parent = stack[-1]\n      child = TreeNode(preorder[i])\n      # Adjust the parent.\n      while stack and stack[-1].val < child.val:\n        parent = stack.pop()\n      # Create parent-child link according to BST property.\n      if parent.val > child.val:\n        parent.left = child\n      else:\n        parent.right = child\n      stack.append(child)\n\n    return root",
      "title": "1008. Construct Binary Search Tree from Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5884bce-ec43-4224-9a3b-5aaac47338ba",
      "code": "class Solution:\n  def bitwiseComplement(self, n: int) -> int:\n    mask = 1\n    while mask < n:\n      mask = (mask << 1) + 1\n    return mask ^ n",
      "title": "1009. Complement of Base 10 Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba8d7bb-1406-49b3-b4f9-e15388e787cf",
      "code": "class Solution:\n  def numPairsDivisibleBy60(self, time: list[int]) -> int:\n    ans = 0\n    count = [0] * 60\n\n    for t in time:\n      t %= 60\n      ans += count[(60 - t) % 60]\n      count[t] += 1\n\n    return ans",
      "title": "1010. Pairs of Songs With Total Durations Divisible by 60",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89e1cc55-235e-4ca1-aaed-ada2fe284286",
      "code": "class Solution:\n  def shipWithinDays(self, weights: list[int], days: int) -> int:\n    def shipDays(shipCapacity: int) -> int:\n      shipDays = 1\n      capacity = 0\n      for weight in weights:\n        if capacity + weight > shipCapacity:\n          shipDays += 1\n          capacity = weight\n        else:\n          capacity += weight\n      return shipDays\n\n    l = max(weights)\n    r = sum(weights)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: shipDays(m) <= days) + l",
      "title": "1011. Capacity To Ship Packages Within D Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6b14194-6ea8-4518-b086-f1229ad17a96",
      "code": "class Solution:\n  def numDupDigitsAtMostN(self, n: int) -> int:\n    return n - self._countSpecialNumbers(n)\n\n  # Same as 2376. Count Special Integers\n  def _countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "1012. Numbers With Repeated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86d38fdf-e00c-40f1-948d-3c83e81d6016",
      "code": "class Solution:\n  def canThreePartsEqualSum(self, arr: list[int]) -> bool:\n    summ = sum(arr)\n    if summ % 3 != 0:\n      return False\n\n    average = summ // 3\n    partCount = 0\n    partSum = 0\n\n    for a in arr:\n      partSum += a\n      if partSum == average:\n        partCount += 1\n        partSum = 0\n\n    # edge case: arr = [0, 0, 0, 0] . partCount = 4.\n    return partCount >= 3",
      "title": "1013. Partition Array Into Three Parts With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "222f3fbd-c4f1-42c5-ac98-eae6fd20d196",
      "code": "class Solution:\n  def maxScoreSightseeingPair(self, values: list[int]) -> int:\n    ans = 0\n    bestPrev = 0\n\n    for value in values:\n      ans = max(ans, value + bestPrev)\n      bestPrev = max(bestPrev, value) - 1\n\n    return ans",
      "title": "1014. Best Sightseeing Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08f9ceda-268e-4a36-b4b9-5770c33f8a20",
      "code": "class Solution:\n  def smallestRepunitDivByK(self, k: int) -> int:\n    if k % 10 not in {1, 3, 7, 9}:\n      return -1\n\n    seen = set()\n    n = 0\n\n    for length in range(1, k + 1):\n      n = (n * 10 + 1) % k\n      if n == 0:\n        return length\n      if n in seen:\n        return -1\n      seen.add(n)\n\n    return -1",
      "title": "1015. Smallest Integer Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b07e06b6-2d98-472a-a4cf-3d6c5330ea8c",
      "code": "class Solution:\n  def queryString(self, s: str, n: int) -> bool:\n    if n > 1511:\n      return False\n\n    for i in range(n, n // 2, -1):\n      if format(i, 'b') not in s:\n        return False\n\n    return True",
      "title": "1016. Binary String With Substrings Representing 1 To N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3b0194c-37e5-4993-b2a6-9e01d8f310de",
      "code": "class Solution:\n  def baseNeg2(self, n: int) -> str:\n    ans = []\n\n    while n != 0:\n      ans.append(str(n % 2))\n      n = -(n >> 1)\n\n    return ''.join(reversed(ans)) if ans else '0'",
      "title": "1017. Convert to Base -2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f910bcf-accb-4350-95c9-5ebf96e8b0e4",
      "code": "class Solution:\n  def prefixesDivBy5(self, nums: list[int]) -> list[bool]:\n    ans = []\n    curr = 0\n\n    for num in nums:\n      curr = (curr * 2 + num) % 5\n      ans.append(curr % 5 == 0)\n\n    return ans",
      "title": "1018. Binary Prefix Divisible By 5",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d6363bf-f6d3-438c-a432-965a00e5150d",
      "code": "class Solution:\n  def nextLargerNodes(self, head: ListNode) -> list[int]:\n    ans = []\n    stack = []\n\n    while head:\n      while stack and head.val > ans[stack[-1]]:\n        index = stack.pop()\n        ans[index] = head.val\n      stack.append(len(ans))\n      ans.append(head.val)\n      head = head.next\n\n    for i in stack:\n      ans[i] = 0\n\n    return ans",
      "title": "1019. Next Greater Node In Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7e30438-0dfa-46d8-ae61-bbe8aa9e4d28",
      "code": "class Solution:\n  def removeOuterParentheses(self, s: str) -> str:\n    ans = []\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        if opened > 1:\n          ans.append(c)\n      else:  # c == ')'\n        opened -= 1\n        if opened > 0:\n          ans.append(c)\n\n    return ''.join(ans)",
      "title": "1021. Remove Outermost Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f026a8f0-3190-4559-865c-3e3a1ee417ce",
      "code": "class Solution:\n  def sumRootToLeaf(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, val: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      val = val * 2 + root.val\n      if not root.left and not root.right:\n        ans += val\n      dfs(root.left, val)\n      dfs(root.right, val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1022. Sum of Root To Leaf Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "425c6d57-b14d-4734-836e-fb8cb34169d4",
      "code": "class Solution:\n  def camelMatch(self, queries: list[str], pattern: str) -> list[bool]:\n    def isMatch(query: str) -> bool:\n      j = 0\n      for c in query:\n        if j < len(pattern) and c == pattern[j]:\n          j += 1\n        elif c.isupper():\n          return False\n      return j == len(pattern)\n\n    return [isMatch(query) for query in queries]",
      "title": "1023. Camelcase Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e458a4f0-3c95-452a-bcc2-b1ac87847164",
      "code": "class Solution:\n  def videoStitching(self, clips: list[list[int]], time: int) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    clips.sort()\n\n    i = 0\n    while farthest < time:\n      while i < len(clips) and clips[i][0] <= end:\n        farthest = max(farthest, clips[i][1])\n        i += 1\n      if end == farthest:\n        return -1\n      ans += 1\n      end = farthest\n\n    return ans",
      "title": "1024. Video Stitching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7d74320-c299-4d28-840c-564f7d9f70de",
      "code": "class Solution:\n  def divisorGame(self, n: int) -> bool:\n    return n % 2 == 0",
      "title": "1025. Divisor Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "259a911f-9a6a-4762-b003-b70f36b0db33",
      "code": "class Solution:\n  def longestArithSeqLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]\n    # with k = diff + 500\n    dp = [[0] * 1001 for _ in range(n)]\n\n    for i in range(n):\n      for j in range(i):\n        k = nums[i] - nums[j] + 500\n        dp[i][k] = max(2, dp[j][k] + 1)\n        ans = max(ans, dp[i][k])\n\n    return ans",
      "title": "1027. Longest Arithmetic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f0fc31f-3f3e-4bbf-9b02-72ecebb7e7e8",
      "code": "class Solution:\n  def recoverFromPreorder(self, traversal: str) -> TreeNode | None:\n    i = 0\n\n    def recoverFromPreorder(depth: int) -> TreeNode | None:\n      nonlocal i\n      nDashes = 0\n      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':\n        nDashes += 1\n      if nDashes != depth:\n        return None\n\n      i += depth\n      start = i\n      while i < len(traversal) and traversal[i].isdigit():\n        i += 1\n\n      return TreeNode(int(traversal[start:i]),\n                      recoverFromPreorder(depth + 1),\n                      recoverFromPreorder(depth + 1))\n\n    return recoverFromPreorder(0)",
      "title": "1028. Recover a Tree From Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "886074ab-22d0-45a0-8b58-133fb5dd0260",
      "code": "class Solution:\n  def twoCitySchedCost(self, costs: list[list[int]]) -> int:\n    n = len(costs) // 2\n\n    # How much money can we save if we fly a person to A instead of B?\n    # To save money, we should\n    #   1. Fly the person with the maximum saving to A.\n    #   2. Fly the person with the minimum saving to B.\n\n    # Sort `costs` in ascending order by the money saved if we fly a person to\n    # B instead of A.\n    costs.sort(key=lambda x: x[0] - x[1])\n    return sum(costs[i][0] + costs[i + n][1] for i in range(n))",
      "title": "1029. Two City Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c4fc7a-3757-40ac-a829-85e68c6ad0c9",
      "code": "class Solution:\n  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    q = collections.deque([(rCenter, cCenter)])\n    seen = {(rCenter, cCenter)}\n\n    while q:\n      i, j = q.popleft()\n      ans.append([i, j])\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == rows or y < 0 or y == cols:\n          continue\n        if (x, y) in seen:\n          continue\n        seen.add((x, y))\n        q.append((x, y))\n\n    return ans",
      "title": "1030. Matrix Cells in Distance Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c3e8c8-995f-4490-9aa0-ee8c7cdd2ce1",
      "code": "class Solution:\n  def maxSumTwoNoOverlap(\n      self,\n      nums: list[int],\n      firstLen: int,\n      secondLen: int,\n  ) -> int:\n    def helper(l: int, r: int) -> int:\n      n = len(nums)\n      left = [0] * n\n      summ = 0\n\n      for i in range(n):\n        summ += nums[i]\n        if i >= l:\n          summ -= nums[i - l]\n        if i >= l - 1:\n          left[i] = max(left[i - 1], summ) if i > 0 else summ\n\n      right = [0] * n\n      summ = 0\n\n      for i in reversed(range(n)):\n        summ += nums[i]\n        if i <= n - r - 1:\n          summ -= nums[i + r]\n        if i <= n - r:\n          right[i] = max(right[i + 1], summ) if i < n - 1 else summ\n\n      return max(left[i] + right[i + 1] for i in range(n - 1))\n\n    return max(helper(firstLen, secondLen), helper(secondLen, firstLen))",
      "title": "1031. Maximum Sum of Two Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d88fbceb-766d-47d0-93b8-1ee8f1736caf",
      "code": "class Solution:\n  def numMovesStones(self, a: int, b: int, c: int) -> list[int]:\n    nums = sorted([a, b, c])\n\n    if nums[2] - nums[0] == 2:\n      return [0, 0]\n    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,\n            nums[2] - nums[0] - 2]",
      "title": "1033. Moving Stones Until Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09c7e61d-9fc4-45da-a59c-d526f0c2baca",
      "code": "class Solution:\n  def colorBorder(\n      self,\n      grid: list[list[int]],\n      r0: int,\n      c0: int,\n      color: int\n  ) -> list[list[int]]:\n    def dfs(i: int, j: int, startColor: int) -> None:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] != startColor:\n        return\n\n      grid[i][j] = -startColor\n      dfs(i + 1, j, startColor)\n      dfs(i - 1, j, startColor)\n      dfs(i, j + 1, startColor)\n      dfs(i, j - 1, startColor)\n\n      # If this cell is already on the boarder, it must be painted later.\n      if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:\n        return\n\n      if (abs(grid[i + 1][j]) == startColor and\n          abs(grid[i - 1][j]) == startColor and\n          abs(grid[i][j + 1]) == startColor and\n              abs(grid[i][j - 1]) == startColor):\n        grid[i][j] = startColor\n\n    dfs(r0, c0, grid[r0][c0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num < 0:\n          grid[i][j] = color\n\n    return grid",
      "title": "1034. Coloring A Border",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0acb7367-7060-4f3b-be95-1b981142b82f",
      "code": "class Solution:\n  def maxUncrossedLines(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j - 1] + 1\n                    if nums1[i - 1] == nums2[j - 1]\n                    else max(dp[i - 1][j], dp[i][j - 1]))\n\n    return dp[m][n]",
      "title": "1035. Uncrossed Lines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eb27471-173f-4f6b-9647-1b9c67ef4720",
      "code": "class Solution:\n  def isEscapePossible(\n      self,\n      blocked: list[list[int]],\n      source: list[int],\n      target: list[int]\n  ) -> bool:\n    def dfs(i: int, j: int, target: list[int], seen: set) -> bool:\n      if i < 0 or i >= 10**6 or j < 0 or j >= 10**6:\n        return False\n      if (i, j) in blocked or (i, j) in seen:\n        return False\n      seen.add((i, j))\n      return (len(seen) > (1 + 199) * 199 // 2 or [i, j] == target or\n              dfs(i + 1, j, target, seen) or\n              dfs(i - 1, j, target, seen) or\n              dfs(i, j + 1, target, seen) or\n              dfs(i, j - 1, target, seen))\n\n    blocked = set(tuple(b) for b in blocked)\n    return (dfs(source[0], source[1], target, set()) and\n            dfs(target[0], target[1], source, set()))",
      "title": "1036. Escape a Large Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c8a7257-10d5-401d-a4c8-265ae9fc08ac",
      "code": "class Solution:\n  def isBoomerang(self, points: list[list[int]]) -> bool:\n    return ((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=\n            (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]))",
      "title": "1037. Valid Boomerang",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d0e5e3-7ae2-4c4d-85d9-91b5f64d520b",
      "code": "class Solution:\n  def minScoreTriangulation(self, values: list[int]) -> int:\n    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for j in range(2, n):\n      for i in range(j - 2, -1, -1):\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + values[i]\n                         * values[k] * values[j] + dp[k][j])\n\n    return dp[0][n - 1]",
      "title": "1039. Minimum Score Triangulation of Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e00e5e4e-8040-4ca2-98e5-ee7e24d6226b",
      "code": "class Solution:\n  def numMovesStonesII(self, stones: list[int]) -> list[int]:\n    n = len(stones)\n    minMoves = n\n\n    stones.sort()\n\n    l = 0\n    for r, stone in enumerate(stones):\n      while stone - stones[l] + 1 > n:\n        l += 1\n      alreadyStored = r - l + 1\n      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:\n        minMoves = 2\n      else:\n        minMoves = min(minMoves, n - alreadyStored)\n\n    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]",
      "title": "1040. Moving Stones Until Consecutive II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9b931ed-2617-45a9-896a-a34be0093ef0",
      "code": "class Solution:\n  def isRobotBounded(self, instructions: str) -> bool:\n    x = 0\n    y = 0\n    d = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for instruction in instructions:\n      if instruction == 'G':\n        x += directions[d][0]\n        y += directions[d][1]\n      elif instruction == 'L':\n        d = (d + 3) % 4\n      else:\n        d = (d + 1) % 4\n\n    return (x, y) == (0, 0) or d > 0",
      "title": "1041. Robot Bounded In Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a53558f2-e3a9-4109-9260-9e389e714303",
      "code": "class Solution:\n  def gardenNoAdj(self, n: int, paths: list[list[int]]) -> list[int]:\n    ans = [0] * n  # ans[i] := 1, 2, 3, or 4\n    graph = [[] for _ in range(n)]\n\n    for x, y in paths:\n      u = x - 1\n      v = y - 1\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u in range(n):\n      used = functools.reduce(operator.or_, (1 << ans[v] for v in graph[u]), 0)\n      ans[u] = next(type_\n                    for type_ in range(1, 5)\n                    if not (used >> type_ & 1))\n\n    return ans",
      "title": "1042. Flower Planting With No Adjacent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73f09d6d-d499-43a5-a035-640ce322552e",
      "code": "class Solution:\n  def maxSumAfterPartitioning(self, arr: list[int], k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      mx = -math.inf\n      for j in range(1, min(i, k) + 1):\n        mx = max(mx, arr[i - j])\n        dp[i] = max(dp[i], dp[i - j] + mx * j)\n\n    return dp[n]",
      "title": "1043. Partition Array for Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9949a5f-8778-42a1-b782-8de1338c1d6a",
      "code": "class Solution:\n  def longestDupSubstring(self, s: str) -> str:\n    BASE = 26\n    HASH = 1_000_000_007\n    bestStart = -1\n    l = 1\n    r = len(s)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    # k := the length of the substring to be hashed\n    def getStart(k: int) -> int | None:\n      maxPow = pow(BASE, k - 1, HASH)\n      hashToStart = collections.defaultdict(list)\n      h = 0\n\n      # Compute the hash value of s[:k].\n      for i in range(k):\n        h = (h * BASE + val(s[i])) % HASH\n      hashToStart[h].append(0)\n\n      # Compute the rolling hash by Rabin Karp.\n      for i in range(k, len(s)):\n        startIndex = i - k + 1\n        h = (h - maxPow * val(s[i - k])) % HASH\n        h = (h * BASE + val(s[i])) % HASH\n        if h in hashToStart:\n          currSub = s[startIndex:startIndex + k]\n          for start in hashToStart[h]:\n            if s[start:start + k] == currSub:\n              return startIndex\n        hashToStart[h].append(startIndex)\n\n    while l < r:\n      m = (l + r) // 2\n      start: int | None = getStart(m)\n      if start:\n        bestStart = start\n        l = m + 1\n      else:\n        r = m\n\n    if bestStart == -1:\n      return ''\n    if getStart(l):\n      return s[bestStart:bestStart + l]\n    return s[bestStart:bestStart + l - 1]",
      "title": "1044. Longest Duplicate Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "337099f0-b272-495e-a578-b1aefade2b06",
      "code": "class Solution:\n  def lastStoneWeight(self, stones: list[int]) -> int:\n    pq = [-stone for stone in stones]\n    heapq.heapify(pq)\n\n    while len(pq) >= 2:\n      n1 = -heapq.heappop(pq)\n      n2 = -heapq.heappop(pq)\n      if n1 != n2:\n        heapq.heappush(pq, -(n1 - n2))\n\n    return 0 if not pq else -pq[0]",
      "title": "1046. Last Stone Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cbb018c-78a9-4203-9181-0d0ebc89a32b",
      "code": "class Solution:\n  def longestStrChain(self, words: list[str]) -> int:\n    wordsSet = set(words)\n\n    @functools.lru_cache(None)\n    def dp(s: str) -> int:\n      \"\"\"Returns the longest chain where s is the last word.\"\"\"\n      ans = 1\n      for i in range(len(s)):\n        pred = s[:i] + s[i + 1:]\n        if pred in wordsSet:\n          ans = max(ans, dp(pred) + 1)\n      return ans\n\n    return max(dp(word) for word in words)",
      "title": "1048. Longest String Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f07c4d76-6ffb-4d16-ba1e-aed70b21cad6",
      "code": "class Solution:\n  def lastStoneWeightII(self, stones: list[int]) -> int:\n    summ = sum(stones)\n    s = 0\n    dp = [True] + [False] * summ\n\n    for stone in stones:\n      for w in range(summ // 2 + 1)[::-1]:\n        if w >= stone:\n          dp[w] = dp[w] or dp[w - stone]\n        if dp[w]:\n          s = max(s, w)\n\n    return summ - 2 * s",
      "title": "1049. Last Stone Weight II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df0a65be-0e37-43cd-8361-348e1810f4e2",
      "code": "class Solution:\n  def heightChecker(self, heights: list[int]) -> int:\n    ans = 0\n    currentHeight = 1\n    count = [0] * 101\n\n    for height in heights:\n      count[height] += 1\n\n    for height in heights:\n      while count[currentHeight] == 0:\n        currentHeight += 1\n      if height != currentHeight:\n        ans += 1\n      count[currentHeight] -= 1\n\n    return ans",
      "title": "1051. Height Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0d29244-b7cd-4931-8cd4-4165e4ba77dc",
      "code": "class Solution:\n  def maxSatisfied(\n      self,\n      customers: list[int],\n      grumpy: list[int],\n      X: int,\n  ) -> int:\n    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)\n    madeSatisfied = 0\n    windowSatisfied = 0\n\n    for i, customer in enumerate(customers):\n      if grumpy[i] == 1:\n        windowSatisfied += customer\n      if i >= X and grumpy[i - X] == 1:\n        windowSatisfied -= customers[i - X]\n      madeSatisfied = max(madeSatisfied, windowSatisfied)\n\n    return satisfied + madeSatisfied",
      "title": "1052. Grumpy Bookstore Owner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb003eac-f561-42a1-a438-d219337dc732",
      "code": "class Solution:\n  def prevPermOpt1(self, arr: list[int]) -> list[int]:\n    n = len(arr)\n    l = n - 2\n    r = n - 1\n\n    while l >= 0 and arr[l] <= arr[l + 1]:\n      l -= 1\n    if l < 0:\n      return arr\n    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:\n      r -= 1\n    arr[l], arr[r] = arr[r], arr[l]\n\n    return arr",
      "title": "1053. Previous Permutation With One Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7b7532f-cf22-4d6d-bb2c-b77c71f6f7c5",
      "code": "class Solution:\n  def rearrangeBarcodes(self, barcodes: list[int]) -> list[int]:\n    ans = [0] * len(barcodes)\n    count = collections.Counter(barcodes)\n    i = 0  # ans' index\n    maxNum = max(count, key=count.get)\n\n    def fillAns(num: int) -> None:\n      nonlocal i\n      while count[num]:\n        ans[i] = num\n        i = i + 2 if i + 2 < len(barcodes) else 1\n        count[num] -= 1\n\n    fillAns(maxNum)\n    for num in count.keys():\n      fillAns(num)\n\n    return ans",
      "title": "1054. Distant Barcodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1465fd2-a968-4774-9700-3372c4687e96",
      "code": "class Solution:\n  def confusingNumber(self, n: int) -> bool:\n    s = str(n)\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    rotatedNum = []\n\n    for c in s[::-1]:\n      if c not in rotated:\n        return False\n      rotatedNum.append(rotated[c])\n\n    return ''.join(rotatedNum) != s",
      "title": "1056. Confusing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f1ab56d-7921-4e12-8327-48aa928adde0",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(workers)\n    usedBikes = [False] * len(bikes)\n    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])\n    buckets = [[] for _ in range(2001)]\n\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    for i, worker in enumerate(workers):\n      for j, bike in enumerate(bikes):\n        buckets[dist(worker, bike)].append((i, j))\n\n    for k in range(2001):\n      for i, j in buckets[k]:\n        if ans[i] == -1 and not usedBikes[j]:\n          ans[i] = j\n          usedBikes[j] = True\n\n    return ans",
      "title": "1057. Campus Bikes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dcb27be-3bd7-4248-a7a8-ac8d563bcc04",
      "code": "class Solution:\n  def minimizeError(self, prices: list[str], target: int) -> str:\n    # A[i] := (costCeil - costFloor, costCeil, costFloor)\n    # The lower the costCeil - costFloor is, the cheaper to ceil it.\n    A = []\n    sumFloored = 0\n    sumCeiled = 0\n\n    for price in map(float, prices):\n      floored = math.floor(price)\n      ceiled = math.ceil(price)\n      sumFloored += floored\n      sumCeiled += ceiled\n      costFloor = price - floored\n      costCeil = ceiled - price\n      A.append((costCeil - costFloor, costCeil, costFloor))\n\n    if not sumFloored <= target <= sumCeiled:\n      return '-1'\n\n    A.sort()\n    nCeiled = target - sumFloored\n    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +\n                           sum(a[2] for a in A[nCeiled:]))",
      "title": "1058. Minimize Rounding Error to Meet Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fcb570a-cbbb-40db-b0be-aaf06d0ac517",
      "code": "class Solution:\n  def longestRepeatingSubstring(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      for j in range(i + 1, n + 1):\n        if s[i - 1] == s[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "1062. Longest Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02fadc9e-973c-4ccf-a6d6-08bdf18fee04",
      "code": "class Solution:\n  def validSubarrays(self, nums: list[int]) -> int:\n    # For each `num` in `nums`, each element x in the stack can be the leftmost\n    # element s.t. [x, num] forms a valid subarray, so the size of the stack is\n    # the number of valid subarrays ending in the current number.\n    #\n    # e.g. nums = [1, 3, 2]\n    # num = 1, stack = [1] -> valid subarray is [1]\n    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]\n    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      stack.append(num)\n      ans += len(stack)\n\n    return ans",
      "title": "1063. Number of Valid Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "488794f8-054b-4dc3-a6f0-35d12f157af3",
      "code": "class Solution:\n  def fixedPoint(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.\n    # Therefore, binary search `arr` for the first arr[i] - i = 0.\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] - m >= 0:\n        r = m\n      else:\n        l = m + 1\n\n    return l if arr[l] == l else -1",
      "title": "1064. Fixed Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6766558-bb36-42bf-a037-e49c102a366c",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def indexPairs(self, text: str, words: list[str]) -> list[list[int]]:\n    ans = []\n    root = TrieNode()\n\n    for word in words:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    # Scan each text[i..j].\n    for i in range(len(text)):\n      node: TrieNode = root\n      for j in range(i, len(text)):\n        c = text[j]\n        if c not in node.children:\n          break\n        node = node.children[c]\n        if node.isWord:\n          ans.append([i, j])\n\n    return ans",
      "title": "1065. Index Pairs of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb9cfc7f-f2d0-4f47-9402-28c7b01f16cc",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> int:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    @functools.lru_cache(None)\n    def dp(workerIndex: int, used: int) -> int:\n      \"\"\"\n      Returns the minimum Manhattan distances to assign bikes to\n      workers[workerIndex..n), where `used` is the bitmask of the used bikes.\n      \"\"\"\n      if workerIndex == len(workers):\n        return 0\n      return min(\n          (dist(workers[workerIndex],\n                bike) + dp(workerIndex + 1, used | 1 << i) for i,\n           bike in enumerate(bikes) if not used >> i & 1),\n          default=math.inf)\n\n    return dp(0, 0)",
      "title": "1066. Campus Bikes II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9329cf21-bbfc-4683-857c-96e63cfea5b3",
      "code": "class Solution:\n  def gcdOfStrings(self, str1: str, str2: str) -> str:\n    for sz in range(min(len(str1), len(str2)), 0, -1):\n      if self._isDivisible(str1, str2, sz):\n        return str1[:sz]\n    return ''\n\n  def _isDivisible(self, str1: str, str2: str, sz: int) -> bool:\n    \"\"\"Returns True if str1 and str2 are divisible by str1[0..sz).\"\"\"\n    if len(str1) % sz > 0 or len(str2) % sz > 0:\n      return False\n    gcd = str1[:sz]\n    return str1.replace(gcd, '') == '' and str2.replace(gcd, '') == ''",
      "title": "1071. Greatest Common Divisor of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c2ad796-fd28-443e-8872-5266f890f1ab",
      "code": "class Solution:\n  def maxEqualRowsAfterFlips(self, matrix: list[list[int]]) -> int:\n    patterns = [tuple(a ^ row[0] for a in row) for row in matrix]\n    return max(Counter(patterns).values())",
      "title": "1072. Flip Columns For Maximum Number of Equal Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8f60c61-2d04-43b9-b8b0-58ff8a06c339",
      "code": "class Solution:\n  def addNegabinary(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    carry = 0\n\n    while carry != 0 or arr1 or arr2:\n      if arr1:\n        carry += arr1.pop()\n      if arr2:\n        carry += arr2.pop()\n      ans.append(carry & 1)\n      carry = -(carry >> 1)\n\n    while len(ans) > 1 and ans[-1] == 0:\n      ans.pop()\n\n    return ans[::-1]",
      "title": "1073. Adding Two Negabinary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a865b969-29ff-4d97-924d-0693bfca4e50",
      "code": "class Solution:\n  def numSubmatrixSumTarget(self, matrix: list[list[int]], target: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = 0\n\n    # Transfer each row in the matrix to the prefix sum.\n    for row in matrix:\n      for i in range(1, n):\n        row[i] += row[i - 1]\n\n    for baseCol in range(n):\n      for j in range(baseCol, n):\n        prefixCount = collections.Counter({0: 1})\n        summ = 0\n        for i in range(m):\n          if baseCol > 0:\n            summ -= matrix[i][baseCol - 1]\n          summ += matrix[i][j]\n          ans += prefixCount[summ - target]\n          prefixCount[summ] += 1\n\n    return ans",
      "title": "1074. Number of Submatrices That Sum to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d416cbe3-78d6-4e98-904a-8ca9f70aa8b4",
      "code": "class Solution:\n  def findOcurrences(self, text: str, first: str, second: str) -> list[str]:\n    words = text.split()\n    return [c for a, b, c in zip(words, words[1:], words[2:]) if a == first and b == second]",
      "title": "1078. Occurrences After Bigram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52241aaa-dbb0-4272-a745-98b34398efa1",
      "code": "class Solution:\n  def numTilePossibilities(self, tiles: str) -> int:\n    count = collections.Counter(tiles)\n\n    def dfs(count: dict[int, int]) -> int:\n      possibleSequences = 0\n\n      for k, v in count.items():\n        if v == 0:\n          continue\n        # Put c in the current position. We only care about the number of possible\n        # sequences of letters but don't care about the actual combination.\n        count[k] -= 1\n        possibleSequences += 1 + dfs(count)\n        count[k] += 1\n\n      return possibleSequences\n\n    return dfs(count)",
      "title": "1079. Letter Tile Possibilities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e191b77-581a-45c0-8f17-468025b4d988",
      "code": "class Solution:\n  def sufficientSubset(\n      self,\n      root: TreeNode | None,\n      limit: int\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if not root.left and not root.right:\n      return None if root.val < limit else root\n    root.left = self.sufficientSubset(root.left, limit - root.val)\n    root.right = self.sufficientSubset(root.right, limit - root.val)\n    return None if not root.left and not root.right else root",
      "title": "1080. Insufficient Nodes in Root to Leaf Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a28f2064-e6b3-4648-8e27-73874a898e0c",
      "code": "class Solution:\n  def smallestSubsequence(self, text: str) -> str:\n    ans = []\n    count = collections.Counter(text)\n    used = [False] * 26\n\n    for c in text:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "1081. Smallest Subsequence of Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c8f0cf9-e412-4412-a83e-abc334a76e59",
      "code": "class Solution:\n  def sumOfDigits(self, nums: list[int]) -> int:\n    return sum(int(d) for d in str(min(nums))) & 1 ^ 1",
      "title": "1085. Sum of Digits in the Minimum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ed0297f-50bf-409d-96bf-90a550adb832",
      "code": "class Solution:\n  def highFive(self, items: list[list[int]]) -> list[list[int]]:\n    idToScores = collections.defaultdict(list)\n\n    for id, score in items:\n      heapq.heappush(idToScores[id], score)\n      if len(idToScores[id]) > 5:\n        heapq.heappop(idToScores[id])\n\n    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]",
      "title": "1086. High Five",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d86e89ef-9ceb-47d6-bce6-21e76a6ae1f0",
      "code": "class Solution:\n  def expand(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(s):\n        ans.append(''.join(path))\n        return\n      if s[i] == '{':\n        nextRightBraceIndex = s.find('}', i)\n        for c in s[i + 1:nextRightBraceIndex].split(','):\n          path.append(c)\n          dfs(nextRightBraceIndex + 1, path)\n          path.pop()\n      else:  # s[i] != '{'\n        path.append(s[i])\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return sorted(ans)",
      "title": "1087. Brace Expansion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30cdedf2-1921-4178-8795-67a7290c3e4e",
      "code": "class Solution:\n  def confusingNumberII(self, n: int) -> int:\n    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]\n\n    def dfs(num: int, rotatedNum: int, unit: int) -> int:\n      ans = 0 if num == rotatedNum else 1\n      # Add one more digit\n      for digit, rotated in digitToRotated:\n        if digit == 0 and num == 0:\n          continue\n        nextNum = num * 10 + digit\n        if nextNum > n:\n          break\n        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)\n      return ans\n\n    return dfs(0, 0, 1)",
      "title": "1088. Confusing Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce304a29-5496-4a0b-b156-0de73cab95c3",
      "code": "class Solution:\n  def duplicateZeros(self, arr: list[int]) -> None:\n    zeros = arr.count(0)\n    i = len(arr) - 1\n    j = len(arr) + zeros - 1\n\n    while i < j:\n      if j < len(arr):\n        arr[j] = arr[i]\n      if arr[i] == 0:\n        j -= 1\n        if j < len(arr):\n          arr[j] = arr[i]\n      i -= 1\n      j -= 1",
      "title": "1089. Duplicate Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99b598ed-b4ff-4ba2-b816-f3387fed1752",
      "code": "class Solution:\n  def sampleStats(self, count: list[int]) -> list[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(\n        list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]",
      "title": "1093. Statistics from a Large Sample",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9b4209c-b874-4123-b662-ca05ac4ca386",
      "code": "# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class MountainArray:\n#   def get(self, index: int) -> int:\n#   def length(self) -> int:\n\nclass Solution:\n  def findInMountainArray(\n      self,\n      target: int,\n      mountain_arr: 'MountainArray',\n  ) -> int:\n    n = mountain_arr.length()\n    peakIndex = self.peakIndexInMountainArray(mountain_arr, 0, n - 1)\n\n    leftIndex = self.searchLeft(mountain_arr, target, 0, peakIndex)\n    if mountain_arr.get(leftIndex) == target:\n      return leftIndex\n\n    rightIndex = self.searchRight(mountain_arr, target, peakIndex + 1, n - 1)\n    if mountain_arr.get(rightIndex) == target:\n      return rightIndex\n\n    return -1\n\n  # 852. Peak Index in a Mountain Array\n  def peakIndexInMountainArray(self, A: 'MountainArray', l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < A.get(m + 1):\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchLeft(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < target:\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchRight(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) > target:\n        l = m + 1\n      else:\n        r = m\n    return l",
      "title": "1095. Find in Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60063848-bee2-4111-b4a9-3ebc710c7b96",
      "code": "class Solution:\n  def braceExpansionII(self, expression: str) -> list[str]:\n    def merge(groups: list[list[str]], group: list[str]) -> None:\n      if not groups[-1]:\n        groups[-1] = group\n        return\n\n      groups[-1] = [word1 + word2 for word1 in groups[-1]\n                    for word2 in group]\n\n    def dfs(s: int, e: int) -> list[str]:\n      groups = [[]]\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if c == '{':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == '}':\n          layer -= 1\n          if layer == 0:\n            group = dfs(left, i - 1)\n            merge(groups, group)\n        elif c == ',' and layer == 0:\n          groups.append([])\n        elif layer == 0:\n          merge(groups, [c])\n\n      return sorted(list({word for group in groups for word in group}))\n\n    return dfs(0, len(expression) - 1)",
      "title": "1096. Brace Expansion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14268b9e-ca55-4fde-a784-8d590e92d5e5",
      "code": "class Solution:\n  def twoSumLessThanK(self, nums: list[int], k: int) -> int:\n    if len(nums) < 2:\n      return -1\n\n    ans = -1  # Note the constrathat nums[i] > 0.\n    l = 0\n    r = len(nums) - 1\n\n    nums.sort()\n\n    while l < r:\n      if nums[l] + nums[r] < k:\n        ans = max(ans, nums[l] + nums[r])\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "1099. Two Sum Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5920aef5-91ad-4263-b553-7807df58a290",
      "code": "class Solution:\n  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:\n    ans = 0\n    unique = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        unique += 1\n      if i >= k:\n        count[s[i - k]] -= 1\n        if count[s[i - k]] == 0:\n          unique -= 1\n        if unique == k:\n          ans += 1\n\n    return ans",
      "title": "1100. Find K-Length Substrings With No Repeated Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "421ad44d-88c2-4d3c-947a-76c50a7444af",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def earliestAcq(self, logs: list[list[int]], n: int) -> int:\n    uf = UnionFind(n)\n\n    # Sort `logs` by timestamp.\n    logs.sort(key=lambda x: x[0])\n\n    for timestamp, x, y in logs:\n      uf.unionByRank(x, y)\n      if uf.getCount() == 1:\n        return timestamp\n\n    return -1",
      "title": "1101. The Earliest Moment When Everyone Become Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb8604ae-565f-4983-a10c-b45cfac84082",
      "code": "class Solution:\n  def distributeCandies(self, candies: int, n: int) -> list[int]:\n    ans = [0] * n\n    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))\n    accumN = rows * (rows - 1) * n // 2\n\n    for i in range(n):\n      ans[i] = accumN + rows * (i + 1)\n\n    givenCandies = (n**2 * rows**2 + n * rows) // 2\n    candies -= givenCandies\n    lastGiven = rows * n\n    i = 0\n\n    while candies > 0:\n      lastGiven += 1\n      actualGiven = min(lastGiven, candies)\n      candies -= actualGiven\n      ans[i] += actualGiven\n      i += 1\n\n    return ans",
      "title": "1103. Distribute Candies to People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be812da6-8a4f-4960-b637-7c2830b6e45b",
      "code": "class Solution:\n  def pathInZigZagTree(self, label: int) -> list[int]:\n    def boundarySum(level: int):\n      return 2**level + 2**(level + 1) - 1\n\n    ans = []\n\n    for l in range(21):\n      if 2**l > label:\n        level = l - 1\n        break\n\n    if level % 2 == 1:\n      label = boundarySum(level) - label\n\n    for l in reversed(range(level + 1)):\n      ans.append(label if l % 2 == 0 else boundarySum(l) - label)\n      label //= 2\n\n    return ans[::-1]",
      "title": "1104. Path In Zigzag Labelled Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c3c1449-72cc-42ee-bba9-be840a18f61b",
      "code": "class Solution:\n  def minHeightShelves(self, books: list[list[int]], shelfWidth: int) -> int:\n    # dp[i] := the minimum height to place the first i books\n    dp = [0] + [math.inf] * len(books)\n\n    for i in range(len(books)):\n      sumThickness = 0\n      maxHeight = 0\n      # Place books[j..i] on a new shelf.\n      for j in range(i, -1, -1):\n        thickness, height = books[j]\n        sumThickness += thickness\n        if sumThickness > shelfWidth:\n          break\n        maxHeight = max(maxHeight, height)\n        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)\n\n    return dp[-1]",
      "title": "1105. Filling Bookcase Shelves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae7d7876-496e-49c1-82b4-8697f8659800",
      "code": "class Solution:\n  def parseBoolExpr(self, expression: str) -> bool:\n    def dfs(s: int, e: int) -> list[str]:\n      if s == e:\n        return True if expression[s] == 't' else False\n\n      exps = []\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if layer == 0 and c in '!&|':\n          op = c\n        elif c == '(':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == ')':\n          layer -= 1\n          if layer == 0:\n            exps.append(dfs(left, i - 1))\n        elif c == ',' and layer == 1:\n          exps.append(dfs(left, i - 1))\n          left = i + 1\n\n      if op == '|':\n        return functools.reduce(operator.or_, exps)\n      if op == '&':\n        return functools.reduce(operator.and_, exps)\n      if op == '!':\n        return not exps[0]\n\n    return dfs(0, len(expression) - 1)",
      "title": "1106. Parsing A Boolean Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b43ec6ff-90d0-4a68-98ee-e520eda68b3e",
      "code": "class Solution:\n  def defangIPaddr(self, address: str) -> str:\n    return address.replace('.', '[.]')",
      "title": "1108. Defanging an IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6389ac4d-321e-4988-8970-d92cbe2fd1f1",
      "code": "class Solution:\n  def corpFlightBookings(self, bookings: list[list[int]], n: int) -> list[int]:\n    ans = [0] * n\n\n    for booking in bookings:\n      ans[booking[0] - 1] += booking[2]\n      if booking[1] < n:\n        ans[booking[1]] -= booking[2]\n\n    for i in range(1, n):\n      ans[i] += ans[i - 1]\n\n    return ans",
      "title": "1109. Corporate Flight Bookings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3ec683d-7476-42bc-894f-9bfab81c9b57",
      "code": "class Solution:\n  def delNodes(self, root: TreeNode, to_delete: list[int]) -> list[TreeNode]:\n    ans = []\n    toDeleteSet = set(to_delete)\n\n    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:\n      if not root:\n        return None\n\n      deleted = root.val in toDeleteSet\n      if isRoot and not deleted:\n        ans.append(root)\n\n      # If root is deleted, both children have the possibility to be a new root\n      root.left = dfs(root.left, deleted)\n      root.right = dfs(root.right, deleted)\n      return None if deleted else root\n\n    dfs(root, True)\n    return ans",
      "title": "1110. Delete Nodes And Return Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e4126a3-b1b6-4662-9403-b814548ade38",
      "code": "class Solution:\n  def maxDepthAfterSplit(self, seq: str) -> list[int]:\n    ans = []\n    depth = 1\n\n    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.\n    for c in seq:\n      if c == '(':\n        depth += 1\n        ans.append(depth % 2)\n      else:\n        ans.append(depth % 2)\n        depth -= 1\n\n    return ans",
      "title": "1111. Maximum Nesting Depth of Two Valid Parentheses Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "deef9d35-acad-45fd-985f-45a612a66e48",
      "code": "class Solution:\n  def numberOfDays(self, year: int, month: int) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n    return 29 if month == 2 and isLeapYear(year) else days[month]",
      "title": "1118. Number of Days in a Month",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "025eb089-b9a3-48b3-9309-224acbe1f71b",
      "code": "class Solution:\n  def removeVowels(self, s: str) -> str:\n    return re.sub('a|e|i|o|u', '', s)",
      "title": "1119. Remove Vowels from a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1e821f8-20f6-44d1-91b2-18e634ea370f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n  maxAverage: int\n\n\nclass Solution:\n  def maximumAverageSubtree(self, root: TreeNode | None) -> float:\n    def maximumAverage(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0, 0)\n\n      left = maximumAverage(root.left)\n      right = maximumAverage(root.right)\n\n      summ = root.val + left.summ + right.summ\n      count = 1 + left.count + right.count\n      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)\n      return T(summ, count, maxAverage)\n\n    return maximumAverage(root).maxAverage",
      "title": "1120. Maximum Average Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53e5e473-00b3-4263-8299-6e49ecb5f379",
      "code": "class Solution:\n  def canDivideIntoSubsequences(self, nums: list[int], k: int) -> bool:\n    # Find the number with the maxFreq, we need at least maxFreq * k elements\n    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to\n    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x\n    # 3 = 6, which is impossible if len(nums) = 5\n    return len(nums) >= k * max(Counter(nums).values())",
      "title": "1121. Divide Array Into Increasing Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "787e7d51-574b-4026-9b0f-b4dbc977f040",
      "code": "class Solution:\n  def relativeSortArray(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    count = [0] * 1001\n\n    for a in arr1:\n      count[a] += 1\n\n    for a in arr2:\n      while count[a] > 0:\n        ans.append(a)\n        count[a] -= 1\n\n    for num in range(1001):\n      for _ in range(count[num]):\n        ans.append(num)\n\n    return ans",
      "title": "1122. Relative Sort Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf29bb03-17ad-4c66-9d74-6a5056aeab3a",
      "code": "class Solution:\n  def longestWPI(self, hours: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    dict = {}\n\n    for i in range(len(hours)):\n      prefix += 1 if hours[i] > 8 else -1\n      if prefix > 0:\n        ans = i + 1\n      else:\n        if prefix not in dict:\n          dict[prefix] = i\n        if prefix - 1 in dict:\n          ans = max(ans, i - dict[prefix - 1])\n\n    return ans",
      "title": "1124. Longest Well-Performing Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "372cc614-95f8-4ffc-84b1-1bc181e8ddcf",
      "code": "class Solution:\n  def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for domino in dominoes:\n      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n      ans += count[key]\n      count[key] += 1\n\n    return ans",
      "title": "1128. Number of Equivalent Domino Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e347585-4751-4c6b-956e-a4b276a4375e",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  INIT = 0\n  RED = 1\n  BLUE = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(\n      self,\n      n: int,\n      redEdges: list[list[int]],\n      blueEdges: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]  # graph[u] := [(v, edgeColor)]\n    q = collections.deque([(0, Color.INIT)])  # [(u, prevColor)]\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.RED))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.BLUE))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)  # Mark (u, v) as used.\n      step += 1\n\n    return ans",
      "title": "1129. Shortest Path with Alternating Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ff3f0c9-924c-4dd4-8790-9ec32c83860e",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7762f236-2e08-441f-83bc-4ce818b46dfb",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "297123a1-c34b-4b31-8466-3c42afee4473",
      "code": "class Solution:\n  def maxAbsValExpr(self, arr1: list[int], arr2: list[int]) -> int:\n    n = len(arr1)\n    a = [arr1[i] + arr2[i] + i for i in range(n)]\n    b = [arr1[i] + arr2[i] - i for i in range(n)]\n    c = [arr1[i] - arr2[i] + i for i in range(n)]\n    d = [arr1[i] - arr2[i] - i for i in range(n)]\n    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))",
      "title": "1131. Maximum of Absolute Value Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "899bd9b1-6f63-40b3-93ae-ad54cee4a087",
      "code": "class Solution:\n  def largestUniqueNumber(self, nums: list[int]) -> int:\n    return max([num for num, freq in collections.Counter(nums).items()\n                if freq == 1], default=-1)",
      "title": "1133. Largest Unique Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea82420e-4947-403d-b7b8-57f9ae3bffeb",
      "code": "class Solution:\n  def isArmstrong(self, n: int) -> bool:\n    s = str(n)\n    k = len(s)\n    return sum(pow(int(c), k) for c in s) == n",
      "title": "1134. Armstrong Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "383be10c-32bd-4c84-92e3-c53545f9d168",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, connections: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n + 1)\n\n    # Sort by cost.\n    connections.sort(key=lambda x: x[2])\n\n    for u, v, cost in connections:\n      if uf.find(u) == uf.find(v):\n        continue\n      uf.unionByRank(u, v)\n      ans += cost\n\n    root = uf.find(1)\n    if any(uf.find(i) != root for i in range(1, n + 1)):\n      return -1\n\n    return ans",
      "title": "1135. Connecting Cities With Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ffbb6aa-b474-4447-8066-b05f5d8e387b",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    states = [State.INIT] * n\n    depth = [1] * n\n\n    for u, v in relations:\n      graph[u - 1].append(v - 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if hasCycle(v):\n          return True\n        depth[u] = max(depth[u], 1 + depth[v])\n      states[u] = State.VISITED\n      return False\n\n    if any(hasCycle(i) for i in range(n)):\n      return -1\n    return max(depth)",
      "title": "1136. Parallel Courses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c18ce8e5-c91a-48cb-acb9-11346adc81a6",
      "code": "class Solution:\n  def tribonacci(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 1, 1]\n\n    for _ in range(3, n + 1):\n      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)\n\n    return dp[2]",
      "title": "1137. N-th Tribonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "605e9acf-29ed-42b1-969c-c352904973a9",
      "code": "class Solution:\n  def largest1BorderedSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    # leftOnes[i][j] := consecutive 1s in the left of grid[i][j]\n    leftOnes = [[0] * n for _ in range(m)]\n    # topOnes[i][j] := consecutive 1s in the top of grid[i][j]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          leftOnes[i][j] = 1 if j == 0 else 1 + leftOnes[i][j - 1]\n          topOnes[i][j] = 1 if i == 0 else 1 + topOnes[i - 1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          # If grid[i..x][j..y] has all 1s on its border.\n          if min(\n                  leftOnes[i][y],\n                  leftOnes[x][y],\n                  topOnes[x][j],\n                  topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0",
      "title": "1139. Largest 1-Bordered Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e43ddfe-97e1-42be-9692-ee7de8b12d17",
      "code": "class Solution:\n  def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n    m = len(text1)\n    n = len(text2)\n    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = (1 + dp[i][j] if text1[i] == text2[j]\n                            else max(dp[i][j + 1], dp[i + 1][j]))\n\n    return dp[m][n]",
      "title": "1143. Longest Common Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a3a04b1-d266-4f79-a9b3-9fcd91512804",
      "code": "class Solution:\n  def movesToMakeZigzag(self, nums: list[int]) -> int:\n    decreasing = [0] * 2\n\n    for i, num in enumerate(nums):\n      l = nums[i - 1] if i > 0 else 1001\n      r = nums[i + 1] if i + 1 < len(nums) else 1001\n      decreasing[i % 2] += max(0, num - min(l, r) + 1)\n\n    return min(decreasing[0], decreasing[1])",
      "title": "1144. Decrease Elements To Make Array Zigzag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af49674b-1663-4c77-85e4-972d7c5ec332",
      "code": "class Solution:\n  def isMajorityElement(self, nums: list[int], target: int) -> bool:\n    n = len(nums)\n    i = bisect.bisect_left(nums, target)\n    return i + n // 2 < n and nums[i + n // 2] == target",
      "title": "1150. Check If a Number Is Majority Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89ced44d-d3ce-4612-acc2-33dfb8895795",
      "code": "class Solution:\n  def minSwaps(self, data: list[int]) -> int:\n    k = data.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i, num in enumerate(data):\n      if i >= k and data[i - k]:\n        ones -= 1\n      if num:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "1151. Minimum Swaps to Group All 1's Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3988e5d-070f-4387-b9b8-c4fc2f70eece",
      "code": "class Solution:\n  def mostVisitedPattern(\n      self,\n      username: list[str],\n      timestamp: list[int],\n      website: list[str],\n  ) -> list[str]:\n    userToSites = collections.defaultdict(list)\n\n    # Sort websites of each user by timestamp.\n    for user, _, site in sorted(\n            zip(username, timestamp, website),\n            key=lambda x: x[1]):\n      userToSites[user].append(site)\n\n    # For each of three websites, count its frequency.\n    patternCount = collections.Counter()\n\n    for user, sites in userToSites.items():\n      patternCount.update(Counter(set(itertools.combinations(sites, 3))))\n\n    return max(sorted(patternCount), key=patternCount.get)",
      "title": "1152. Analyze User Website Visit Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b34ae85-a5f4-4cfa-b01e-a94b344040ed",
      "code": "class Solution:\n  def canConvert(self, str1: str, str2: str) -> bool:\n    if str1 == str2:\n      return True\n\n    mappings = {}\n\n    for a, b in zip(str1, str2):\n      if mappings.get(a, b) != b:\n        return False\n      mappings[a] = b\n\n    # No letter in the str1 maps to > 1 letter in the str2 and there is at\n    # lest one temporary letter can break any loops.\n    return len(set(str2)) < 26",
      "title": "1153. String Transforms Into Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f032d4f5-95b6-48fa-9908-de5bebed12e4",
      "code": "class Solution:\n  def dayOfYear(self, date: str) -> int:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    year = int(date[:4])\n    month = int(date[5:7])\n    day = int(date[8:])\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    return sum(days[:month - 1]) + day",
      "title": "1154. Day of the Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5fd03d13-30c2-4049-8316-31bf28e178ba",
      "code": "class Solution:\n  def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n    MOD = 1_000_000_007\n    dp = [1] + [0] * target\n\n    for _ in range(n):  # n dices\n      newDp = [0] * (target + 1)\n      for i in range(1, k + 1):  # numbers 1, 2, ..., f\n        for t in range(i, target + 1):  # all the possible targets\n          newDp[t] += dp[t - i]\n          newDp[t] %= MOD\n      dp = newDp\n\n    return dp[target]",
      "title": "1155. Number of Dice Rolls With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65e10a26-0f5a-487a-aa3b-e072ee72a098",
      "code": "class Solution:\n  def maxRepOpt1(self, text: str) -> int:\n    count = collections.Counter(text)\n    groups = [[c, len(list(group))]\n              for c, group in itertools.groupby(text)]\n    ans = max(min(length + 1, count[c]) for c, length in groups)\n\n    for i in range(1, len(groups) - 1):\n      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:\n        ans = max(\n            ans,\n            min(groups[i - 1][1] + groups[i + 1][1] + 1, count\n                [groups[i - 1][0]]))\n\n    return ans",
      "title": "1156. Swap For Longest Repeated Character Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30e2e275-65ee-40cc-9865-50cbabc327e9",
      "code": "class Solution:\n  def countCharacters(self, words: list[str], chars: str) -> int:\n    ans = 0\n    count = collections.Counter(chars)\n\n    for word in words:\n      tempCount = count.copy()\n      for c in word:\n        tempCount[c] -= 1\n        if tempCount[c] < 0:\n          ans -= len(word)\n          break\n      ans += len(word)\n\n    return ans",
      "title": "1160. Find Words That Can Be Formed by Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "765c5a96-74b5-4a99-bcbe-d9c1ad463086",
      "code": "class Solution:\n  def maxLevelSum(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxLevelSum = -math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum > maxLevelSum:\n        maxLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "1161. Maximum Level Sum of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fe537ef-f968-4af9-8c35-e6daa50ff07f",
      "code": "class Solution:\n  def maxDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2  # Mark as visited.\n      d += 1\n\n    return ans",
      "title": "1162. As Far from Land as Possible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dc794d2-551a-43c4-9c44-06cf309f2a3f",
      "code": "class Solution:\n  def lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "1163. Last Substring in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f03eb2c-fb29-4fc0-9cc3-70d8437d531f",
      "code": "class Solution:\n  def calculateTime(self, keyboard: str, word: str) -> int:\n    letterToIndex = {c: i for i, c in enumerate(keyboard)}\n    return (letterToIndex[word[0]] +\n            sum(abs(letterToIndex[a] - letterToIndex[b])\n            for a, b in itertools.pairwise(word)))",
      "title": "1165. Single-Row Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0274f200-db78-419a-af78-63b32cac536e",
      "code": "class Solution:\n  def connectSticks(self, sticks: list[int]) -> int:\n    ans = 0\n    heapq.heapify(sticks)\n\n    while len(sticks) > 1:\n      x = heapq.heappop(sticks)\n      y = heapq.heappop(sticks)\n      ans += x + y\n      heapq.heappush(sticks, x + y)\n\n    return ans",
      "title": "1167. Minimum Cost to Connect Sticks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc4e62fe-4b85-451a-bdf8-db6f09a1b792",
      "code": "class Solution:\n  def minCostToSupplyWater(\n      self,\n      n: int,\n      wells: list[int],\n      pipes: list[list[int]],\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n + 1)]\n    minHeap = []  # (d, u)\n\n    for u, v, w in pipes:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    # Connect virtual 0 with nodes 1 to n.\n    for i, well in enumerate(wells):\n      graph[0].append((i + 1, well))\n      heapq.heappush(minHeap, (well, i + 1))\n\n    mst = {0}\n\n    while len(mst) < n + 1:\n      d, u = heapq.heappop(minHeap)\n      if u in mst:\n        continue\n      # Add the new vertex.\n      mst.add(u)\n      ans += d\n      # Expand if possible.\n      for v, w in graph[u]:\n        if v not in mst:\n          heapq.heappush(minHeap, (w, v))\n\n    return ans",
      "title": "1168. Optimize Water Distribution in a Village",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24ec167c-57a1-4cd4-8ab3-e21a94192a7c",
      "code": "class Solution:\n  def invalidTransactions(self, transactions: list[str]) -> list[str]:\n    ans = []\n    nameToTrans = collections.defaultdict(list)\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      nameToTrans[name].append({'time': time, 'city': city})\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      if amount > 1000:\n        ans.append(t)\n      elif name in nameToTrans:\n        for sameName in nameToTrans[name]:\n          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:\n            ans.append(t)\n            break\n\n    return ans",
      "title": "1169. Invalid Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "027090ad-137b-4cc9-a1dd-a962f0e58f76",
      "code": "class Solution:\n  def numSmallerByFrequency(\n      self,\n      queries: list[str],\n      words: list[str],\n  ) -> list[int]:\n    ans = []\n    wordsFreq = sorted([word.count(min(word)) for word in words])\n\n    for q in queries:\n      count = q.count(min(q))\n      index = bisect.bisect(wordsFreq, count)\n      ans.append(len(words) - index)\n\n    return ans",
      "title": "1170. Compare Strings by Frequency of the Smallest Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29945e54-a9e1-4e00-a113-79e5e7bf72c3",
      "code": "class Solution:\n  def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prefix = 0\n    prefixToNode = {0: dummy}\n\n    while head:\n      prefix += head.val\n      prefixToNode[prefix] = head\n      head = head.next\n\n    prefix = 0\n    head = dummy\n\n    while head:\n      prefix += head.val\n      head.next = prefixToNode[prefix].next\n      head = head.next\n\n    return dummy.next",
      "title": "1171. Remove Zero Sum Consecutive Nodes from Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3306ca3-d2ac-4558-bb8c-25fed3909ff4",
      "code": "class Solution:\n  def numPrimeArrangements(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def factorial(n: int) -> int:\n      fact = 1\n      for i in range(2, n + 1):\n        fact = fact * i % MOD\n      return fact\n\n    count = self._countPrimes(n)\n    return factorial(count) * factorial(n - count) % MOD\n\n  def _countPrimes(self, n: int) -> int:\n    isPrime = [False] * 2 + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n + 1, i):\n          isPrime[j] = False\n    return sum(isPrime)",
      "title": "1175. Prime Arrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e13ed875-d12a-4b46-9d06-a70fb4af472c",
      "code": "class Solution:\n  def dietPlanPerformance(\n      self,\n      calories: list[int],\n      k: int,\n      lower: int,\n      upper: int,\n  ) -> int:\n    ans = 0\n    summ = 0\n\n    for i, calorie in enumerate(calories):\n      summ += calorie\n      if i < k - 1:\n        continue\n      if i >= k:\n        summ -= calories[i - k]\n      if summ < lower:\n        ans -= 1\n      elif summ > upper:\n        ans += 1\n\n    return ans",
      "title": "1176. Diet Plan Performance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ad4ae9b-a9a7-4353-bfc0-f6209a6aeb80",
      "code": "class Solution:\n  def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\n    dp = [0] * (len(s) + 1)\n\n    for i in range(1, len(s) + 1):\n      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')\n\n    return [\n        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k\n        for left, right, k in queries\n    ]",
      "title": "1177. Can Make Palindrome from Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a826563-2eba-4bc4-819a-10b6024f1222",
      "code": "class Solution:\n  def findNumOfValidWords(\n      self,\n      words: list[str],\n      puzzles: list[str],\n  ) -> list[int]:\n    ans = []\n    binaryCount = collections.Counter()\n\n    for word in words:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      binaryCount[mask] += 1\n\n    for puzzle in puzzles:\n      valid = 0\n      n = len(puzzle) - 1\n      for i in range(1 << n):\n        mask = 1 << ord(puzzle[0]) - ord('a')\n        for j in range(n):\n          if i >> j & 1:\n            mask |= 1 << ord(puzzle[j + 1]) - ord('a')\n        if mask in binaryCount:\n          valid += binaryCount[mask]\n      ans.append(valid)\n\n    return ans",
      "title": "1178. Number of Valid Words for Each Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97d9fada-e32c-4116-bf08-e9c77c4835ef",
      "code": "class Solution:\n  def countLetters(self, s: str) -> int:\n    ans = 0\n    dp = 0  # the length of the running letter\n    letter = '@'  # the running letter\n\n    for c in s:\n      if c == letter:\n        dp += 1\n      else:\n        dp = 1\n        letter = c\n      ans += dp  # Add the number of substrings ending in the current letter.\n\n    return ans",
      "title": "1180. Count Substrings with Only One Distinct Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d28eacb-8f61-4cb5-9173-7624a592e4a0",
      "code": "class Solution:\n  def shortestDistanceColor(\n      self,\n      colors: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    NUM_COLOR = 3\n    n = len(colors)\n    ans = []\n    # left[i][c] := the closest index of color c in index i to the left\n    left = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n    # right[i][c] := the closest index of color c in index i to the right\n    right = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # 0-indexed, -1 means N//A\n    for i, color in enumerate(colors):\n      colorToLatestIndex[color] = i\n      for c in range(1, NUM_COLOR + 1):\n        left[i][c] = colorToLatestIndex[c]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # Reset.\n    for i in range(n - 1, -1, -1):\n      colorToLatestIndex[colors[i]] = i\n      for c in range(1, NUM_COLOR + 1):\n        right[i][c] = colorToLatestIndex[c]\n\n    for i, c in queries:\n      leftDist = math.inf if left[i][c] == -1 else i - left[i][c]\n      rightDist = math.inf if right[i][c] == -1 else right[i][c] - i\n      minDist = min(leftDist, rightDist)\n      ans.append(-1 if minDist == math.inf else minDist)\n\n    return ans",
      "title": "1182. Shortest Distance to Target Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5118697-e3c3-47f6-93d6-597ec5cf9f6f",
      "code": "class Solution:\n  def maximumNumberOfOnes(\n      self,\n      width: int,\n      height: int,\n      sideLength: int,\n      maxOnes: int,\n  ) -> int:\n    subCount = []\n\n    def getCount(length: int, index: int) -> int:\n      return (length - index - 1) // sideLength + 1\n\n    for i in range(sideLength):\n      for j in range(sideLength):\n        subCount.append(getCount(width, i) * getCount(height, j))\n\n    return sum(sorted(subCount, reverse=True)[:maxOnes])",
      "title": "1183. Maximum Number of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79b576ba-8790-4f93-863b-950b69d155b6",
      "code": "class Solution:\n  def distanceBetweenBusStops(\n      self,\n      distance: list[int],\n      start: int, destination: int,\n  ) -> int:\n    clockwise = 0\n    counterclockwise = 0\n\n    if start > destination:\n      start, destination = destination, start\n\n    for i, d in enumerate(distance):\n      if i >= start and i < destination:\n        clockwise += d\n      else:\n        counterclockwise += d\n\n    return min(clockwise, counterclockwise)",
      "title": "1184. Distance Between Bus Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6ead783-eaf2-4e40-be7c-e8e14776952f",
      "code": "class Solution:\n  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    week = [\"Sunday\", \"Monday\", \"Tuesday\",\n            \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    count = 0\n\n    for i in range(1971, year):\n      count += 366 if i % 4 == 0 else 365\n    for i in range(month - 1):\n      count += days[i]\n    count += day\n\n    return week[(count + 4) % 7]",
      "title": "1185. Day of the Week",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7c3030a-a85d-48e9-9540-781156cfe7df",
      "code": "class Solution:\n  # Similar to 53. Maximum Subarray\n  def maximumSum(self, arr: list[int]) -> int:\n    # dp[0][i] := the maximum sum subarray ending in i (no deletion)\n    # dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)\n    dp = [[0] * len(arr) for _ in range(2)]\n\n    dp[0][0] = arr[0]\n    dp[1][0] = arr[0]\n    for i in range(1, len(arr)):\n      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i])\n      dp[1][i] = max(arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1])\n\n    return max(dp[1])",
      "title": "1186. Maximum Subarray Sum with One Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7065582-4d22-47e7-95c7-a1e26b9261d8",
      "code": "class Solution:\n  def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\n    # dp[i] := the minimum steps to reach i at previous round\n    dp = {-1: 0}\n\n    arr2.sort()\n\n    for a in arr1:\n      newDp = collections.defaultdict(lambda: math.inf)\n      for val, steps in dp.items():\n        # It's possible to use the value in the arr1.\n        if a > val:\n          newDp[a] = min(newDp[a], steps)\n        # Also try the value in the arr2.\n        i = bisect_right(arr2, val)\n        if i < len(arr2):\n          newDp[arr2[i]] = min(newDp[arr2[i]], steps + 1)\n      if not newDp:\n        return -1\n      dp = newDp\n\n    return min(dp.values())",
      "title": "1187. Make Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba1aaca1-50ce-4a65-8e78-a8ddf012d783",
      "code": "class Solution:\n  def maxNumberOfBalloons(self, text: str) -> int:\n    count = collections.Counter(text)\n    return min(\n        count['b'],\n        count['a'],\n        count['l'] // 2, count['o'] // 2, count['n'])",
      "title": "1189. Maximum Number of Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdf39186-992f-4e9a-8439-e3c21dd5d17a",
      "code": "class Solution:\n  def reverseParentheses(self, s: str) -> str:\n    ans = []\n    stack = []\n    pair = {}\n\n    for i, c in enumerate(s):\n      if c == '(':\n        stack.append(i)\n      elif c == ')':\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\n    i = 0\n    d = 1\n    while i < len(s):\n      if s[i] in '()':\n        i = pair[i]\n        d = -d\n      else:\n        ans.append(s[i])\n      i += d\n\n    return ''.join(ans)",
      "title": "1190. Reverse Substrings Between Each Pair of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c13b6b3-274e-4e94-ab9d-6be761d02940",
      "code": "class Solution:\n  def kConcatenationMaxSum(self, arr: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    sz = len(arr) * (1 if k == 1 else 2)\n    summ = sum(arr)\n    # The concatenated array will be [arr1, arr2, ..., arrk].\n    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.\n    # Equivalently, maxSubarraySum is from arr1 and arrk.\n    if summ > 0 and k > 2:\n      return (self._kadane(arr, sz) + summ * (k - 2)) % MOD\n    return self._kadane(arr, sz) % MOD\n\n  def _kadane(self, arr: list[int], sz: int) -> int:\n    ans = 0\n    summ = 0\n    for i in range(sz):\n      a = arr[i % len(arr)]\n      summ = max(a, summ + a)\n      ans = max(ans, summ)\n    return ans",
      "title": "1191. K-Concatenation Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f20dcb2e-fcd6-44ec-93cb-78171d73b59f",
      "code": "class Solution:\n  def maxNumberOfApples(self, weight: list[int]) -> int:\n    summ = 0\n\n    for i, w in enumerate(sorted(weight)):\n      summ += w\n      if summ > 5000:\n        return i\n\n    return len(weight)",
      "title": "1196. How Many Apples Can You Put into the Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "210f2765-23d0-4d85-85ee-11cc571f9d26",
      "code": "class Solution:\n  def smallestCommonElement(self, mat: list[list[int]]) -> int:\n    MAX = 10000\n    count = [0] * (MAX + 1)\n\n    for row in mat:\n      for a in row:\n        count[a] += 1\n        if count[a] == len(mat):\n          return a\n\n    return -1",
      "title": "1198. Find Smallest Common Element in All Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "579c025e-c4a6-4a0b-8693-7e001a800aa7",
      "code": "class Solution:\n  def minBuildTime(self, blocks: list[int], split: int) -> int:\n    minHeap = blocks.copy()\n    heapify(minHeap)\n\n    while len(minHeap) > 1:\n      heapq.heappop(minHeap)  # the minimum\n      x = heapq.heappop(minHeap)  # the second minimum\n      heapq.heappush(minHeap, x + split)\n\n    return minHeap[0]",
      "title": "1199. Minimum Time to Build Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f81577f5-e49b-45f9-9aaa-64c4529f448d",
      "code": "class Solution:\n  def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:\n    ans = []\n    mn = math.inf\n\n    arr.sort()\n\n    for a, b in itertools.pairwise(arr):\n      diff = b - a\n      if diff < mn:\n        mn = diff\n        ans = []\n      if diff == mn:\n        ans.append([a, b])\n\n    return ans",
      "title": "1200. Minimum Absolute Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c70123ab-d4f8-4220-8119-90537a668a61",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * bc // math.gcd(a, bc)\n    return bisect.bisect_left(range(2 * 10**9), n,\n                              key=lambda m: m // a + m // b + m // c\n                              - m // ab - m // ac - m // bc\n                              + m // abc)",
      "title": "1201. Ugly Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6f6fd62-cdf9-472a-91d4-ade696a70aac",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: list[list[int]]) -> str:\n    uf = UnionFind(len(s))\n    indexToLetters = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      indexToLetters[uf.find(i)].append(c)\n\n    for key in indexToLetters.keys():\n      indexToLetters[key].sort(reverse=True)\n\n    return ''.join(indexToLetters[uf.find(i)].pop()\n                   for i in range(len(s)))",
      "title": "1202. Smallest String With Swaps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a3a47db-79ed-4cfb-b18d-e3f01bb92326",
      "code": "class Solution:\n  def uniqueOccurrences(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n    occurrences = set()\n\n    for value in count.values():\n      if value in occurrences:\n        return False\n      occurrences.add(value)\n\n    return True",
      "title": "1207. Unique Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ecf628e-4835-4d18-9fc4-202a644b9209",
      "code": "class Solution:\n  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n    j = 0\n    for i in range(len(s)):\n      maxCost -= abs(ord(s[i]) - ord(t[i]))\n      if maxCost < 0:\n        maxCost += abs(ord(s[j]) - ord(t[j]))\n        j += 1\n\n    return len(s) - j",
      "title": "1208. Get Equal Substrings Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18719e4d-4ddb-4781-8fd4-187e29a0a316",
      "code": "class Solution:\n  def removeDuplicates(self, s: str, k: int) -> str:\n    stack = []\n\n    for c in s:\n      if not stack or stack[-1][0] != c:\n        stack.append([c, 1])\n      else:  # stack[-1][0] == c\n        stack[-1][1] += 1\n        if stack[-1][1] == k:\n          stack.pop()\n\n    return ''.join(c * count for c, count in stack)",
      "title": "1209. Remove All Adjacent Duplicates in String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "372dee8e-dbdf-4e56-bef7-da087e0ef090",
      "code": "from enum import IntEnum\n\n\nclass Pos(IntEnum):\n  HORIZONTAL = 0\n  VERTICAL = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # the state of (x, y, pos)\n    # pos := 0 (horizontal) / 1 (vertical)\n    q = collections.deque([(0, 0, Pos.HORIZONTAL)])\n    seen = {(0, 0, Pos.HORIZONTAL)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.HORIZONTAL:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.VERTICAL:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.HORIZONTAL and x + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x + 1][y])\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.VERTICAL and y + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x][y + 1])\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.HORIZONTAL:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.VERTICAL if pos == Pos.HORIZONTAL else Pos.HORIZONTAL\n        if ((canRotateClockwise(x, y, pos) or\n             canRotateCounterclockwise(x, y, pos)) and\n                (x, y, newPos) not in seen):\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1",
      "title": "1210. Minimum Moves to Reach Target with Rotations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61ded3ac-d619-4e37-b6b9-66181c64d3d9",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def hasNext(self) -> bool:\n    return len(self.stack) > 0\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def twoSumBSTs(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n      target: int,\n  ) -> bool:\n    bst1 = BSTIterator(root1, True)\n    bst2 = BSTIterator(root2, False)\n\n    l = bst1.next()\n    r = bst2.next()\n    while True:\n      summ = l + r\n      if summ == target:\n        return True\n      if summ < target:\n        if not bst1.hasNext():\n          return False\n        l = bst1.next()\n      else:\n        if not bst2.hasNext():\n          return False\n        r = bst2.next()",
      "title": "1214. Two Sum BSTs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e2b81f2-a5d7-48ab-b8af-f05bde1b878e",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: int, high: int) -> list[int]:\n    ans = [0] if low == 0 else []\n    q = collections.deque(list(range(1, 10)))\n\n    while q:\n      curr = q.popleft()\n      if curr > high:\n        continue\n      if curr >= low:\n        ans.append(curr)\n      lastDigit = curr % 10\n      if lastDigit > 0:\n        q.append(curr * 10 + lastDigit - 1)\n      if lastDigit < 9:\n        q.append(curr * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1215. Stepping Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fb30410-d310-47e8-8870-48a4a08195da",
      "code": "class Solution:\n  def isValidPalindrome(self, s: str, k: int) -> bool:\n    return len(s) - self._longestPalindromeSubseq(s) <= k\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1216. Valid Palindrome III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07a5e18e-e9fd-491c-b34c-9e2721fc0804",
      "code": "class Solution:\n  def minCostToMoveChips(self, position: list[int]) -> int:\n    count = [0, 0]\n    for p in position:\n      count[p % 2] += 1\n    return min(count[0], count[1])",
      "title": "1217. Play with Chips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04fd6cfa-a0cd-4a05-8078-e09271960285",
      "code": "class Solution:\n  def longestSubsequence(self, arr: list[int], difference: int) -> int:\n    ans = 0\n    lengthAt = {}\n\n    for a in arr:\n      lengthAt[a] = lengthAt.get(a - difference, 0) + 1\n      ans = max(ans, lengthAt[a])\n\n    return ans",
      "title": "1218. Longest Arithmetic Subsequence of Given Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "440a579b-f995-4074-9523-ee2dde5bc981",
      "code": "class Solution:\n  def getMaximumGold(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n\n      gold = grid[i][j]\n      grid[i][j] = 0  # Mark as visited.\n      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),\n                    dfs(i, j + 1), dfs(i, j - 1))\n      grid[i][j] = gold\n      return gold + maxPath\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "1219. Path with Maximum Gold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "057e32d9-0a2b-4c83-8ace-3b91824e693a",
      "code": "class Solution:\n  def countVowelPermutation(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}\n\n    for _ in range(n - 1):\n      newDp = {'a': dp['e'] + dp['i'] + dp['u'],\n               'e': dp['a'] + dp['i'],\n               'i': dp['e'] + dp['o'],\n               'o': dp['i'],\n               'u': dp['i'] + dp['o']}\n      dp = newDp\n\n    return sum(dp.values()) % MOD",
      "title": "1220. Count Vowels Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca263a8a-4146-4ca1-8690-688974a63989",
      "code": "class Solution:\n  def queensAttacktheKing(self, queens: list[list[int]],\n                          king: list[int]) -> list[list[int]]:\n    ans = []\n    queens = {(i, j) for i, j in queens}\n\n    for d in [\n        [-1, -1],\n        [-1, 0],\n        [-1, 1],\n        [0, -1],\n        [0, 1],\n        [1, -1],\n        [1, 0],\n            [1, 1]]:\n      i = king[0] + d[0]\n      j = king[1] + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if (i, j) in queens:\n          ans.append([i, j])\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "1222. Queens That Can Attack the King",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ecd104c-a736-47fe-9a89-c1df6de7d1d2",
      "code": "class Solution:\n  def dieSimulator(self, n: int, rollMax: list[int]) -> int:\n    MAX_ROLLS = 15\n    MOD = 1_000_000_007\n\n    dp = [[[0] * (MAX_ROLLS + 1) for j in range(6)] for i in range(n + 1)]\n\n    for num in range(6):\n      dp[1][num][1] = 1\n\n    for i in range(2, n + 1):\n      for currNum in range(6):\n        for prevNum in range(6):\n          for k in range(1, 15 + 1):\n            if prevNum != currNum:\n              dp[i][currNum][1] = (\n                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % MOD\n            elif k < rollMax[currNum]:\n              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]\n\n    ans = 0\n\n    for num in range(6):\n      for k in range(1, 15 + 1):\n        ans += dp[n][num][k]\n\n    return ans % MOD",
      "title": "1223. Dice Roll Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b3a615b-81dc-460a-b179-07c7b6d28ed0",
      "code": "class Solution:\n  def maxEqualFreq(self, nums: list[int]) -> int:\n    ans = 0\n    maxFreq = 0\n    count = collections.Counter()\n    freq = collections.Counter()\n\n    for i, num in enumerate(nums):\n      freq[count[num]] -= 1\n      count[num] += 1\n      freq[count[num]] += 1\n      maxFreq = max(maxFreq, count[num])\n      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (\n              freq[maxFreq - 1] + 1) == i:\n        ans = i + 1\n\n    return ans",
      "title": "1224. Maximum Equal Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9a7edde-d418-463e-8933-e7f893be6356",
      "code": "class Solution:\n  def nthPersonGetsNthSeat(self, n: int) -> float:\n    return 1 if n == 1 else 0.5",
      "title": "1227. Airplane Seat Assignment Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b43ea5af-b9d4-4a10-bde5-70f540813631",
      "code": "class Solution:\n  def missingNumber(self, arr: list[int]) -> int:\n    n = len(arr)\n    delta = (arr[-1] - arr[0]) // n\n    l = 0\n    r = n - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] == arr[0] + m * delta:\n        l = m + 1\n      else:\n        r = m\n\n    return arr[0] + l * delta",
      "title": "1228. Missing Number In Arithmetic Progression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f45e298-0cd2-46ed-a2fd-0848f9603035",
      "code": "class Solution:\n  def minAvailableDuration(\n      self,\n      slots1: list[list[int]],\n      slots2: list[list[int]],\n      duration: int,\n  ) -> list[int]:\n    slots1.sort()\n    slots2.sort()\n\n    i = 0  # slots1's index\n    j = 0  # slots2's index\n\n    while i < len(slots1) and j < len(slots2):\n      start = max(slots1[i][0], slots2[j][0])\n      end = min(slots1[i][1], slots2[j][1])\n      if start + duration <= end:\n        return [start, start + duration]\n      if slots1[i][1] < slots2[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return []",
      "title": "1229. Meeting Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "674aae61-536e-40e3-b867-08c02d3f191c",
      "code": "class Solution:\n  def probabilityOfHeads(self, prob: list[float], target: int) -> float:\n    # dp[i][j] := the probability of tossing the first i coins with j heads\n    dp = [[0] * (target + 1) for _ in range(len(prob) + 1)]\n    dp[0][0] = 1.0\n\n    for i in range(1, len(prob) + 1):\n      for j in range(target + 1):\n        dp[i][j] = ((dp[i - 1][j - 1] * prob[i - 1] if j > 0 else 0) +\n                    dp[i - 1][j] * (1 - prob[i - 1]))\n\n    return dp[len(prob)][target]",
      "title": "1230. Toss Strange Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "610421da-86d6-49ac-ad2f-b3da013fa465",
      "code": "class Solution:\n  def maximizeSweetness(self, sweetness: list[int], k: int) -> int:\n    l = len(sweetness) // (k + 1)\n    r = sum(sweetness) // (k + 1)\n\n    def canEat(m: int) -> bool:\n      \"\"\"\n      Returns True if can eat m sweetness (the minimum sweetness of each piece).\n      \"\"\"\n      pieces = 0\n      summ = 0  # the running sum\n      for s in sweetness:\n        summ += s\n        if summ >= m:\n          pieces += 1\n          summ = 0\n      return pieces > k\n\n    while l < r:\n      m = (l + r) // 2\n      if canEat(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l if canEat(l) else l - 1",
      "title": "1231. Divide Chocolate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f6b6110-e840-4fc0-87f3-34fba2bec0f9",
      "code": "class Solution:\n  def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\n    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]\n    dx = x1 - x0\n    dy = y1 - y0\n\n    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)",
      "title": "1232. Check If It Is a Straight Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d8c7acd-b4e7-47d9-9d53-3c15fa878919",
      "code": "class Solution:\n  def removeSubfolders(self, folder: list[str]) -> list[str]:\n    ans = []\n    prev = \"\"\n\n    folder.sort()\n\n    for f in folder:\n      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':\n        continue\n      ans.append(f)\n      prev = f\n\n    return ans",
      "title": "1233. Remove Sub-Folders from the Filesystem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5e4329b-448f-48e4-85eb-9a1d89eea935",
      "code": "class Solution:\n  def balancedString(self, s: str) -> int:\n    ans = len(s)\n    count = collections.Counter(s)\n    j = 0\n\n    for i, c in enumerate(s):\n      count[c] -= 1\n      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):\n        ans = min(ans, i - j + 1)\n        count[s[j]] += 1\n        j += 1\n\n    return ans",
      "title": "1234. Replace the Substring for Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7af21f7f-106e-4b9b-b53a-d94d9d4374d4",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    maxProfit = 0\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n    minHeap = []  # (endTime, profit)\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    for s, e, p in jobs:\n      while minHeap and s >= minHeap[0][0]:\n        maxProfit = max(maxProfit, heapq.heappop(minHeap)[1])\n      heapq.heappush(minHeap, (e, p + maxProfit))\n\n    return max(maxProfit, max(p for _, p in minHeap))",
      "title": "1235. Maximum Profit in Job Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "622d446b-ecbc-42c4-9803-f50b397326b2",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the maximum profit to schedule jobs[i..n).\"\"\"\n      if i == len(startTime):\n        return 0\n      j = bisect.bisect_left(startTime, jobs[i][1])\n      return max(jobs[i][2] + dp(j), dp(i + 1))\n\n    return dp(0)",
      "title": "1235. Maximum Profit in Job Scheduling_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8153067-6b78-4c3e-898c-326b76cfadc0",
      "code": "# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class HtmlParser(object):\n#   def getUrls(self, url: str) -> list[str]:\n\nclass Solution:\n  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> list[str]:\n    q = collections.deque([startUrl])\n    seen = {startUrl}\n    hostname = startUrl.split('/')[2]\n\n    while q:\n      currUrl = q.popleft()\n      for url in htmlParser.getUrls(currUrl):\n        if url in seen:\n          continue\n        if hostname in url:\n          q.append(url)\n          seen.add(url)\n\n    return seen",
      "title": "1236. Web Crawler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14d91842-06d4-4360-8429-8fd05ccceacc",
      "code": "class Solution:\n  def findSolution(self, customfunction: 'CustomFunction', z: int) -> list[list[int]]:\n    ans = []\n    x = 1\n    y = 1000\n\n    while x <= 1000 and y >= 1:\n      f = customfunction.f(x, y)\n      if f < z:\n        x += 1\n      elif f > z:\n        y -= 1\n      else:\n        ans.append([x, y])\n        x += 1\n        y -= 1\n\n    return ans",
      "title": "1237. Find Positive Integer Solution for a Given Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c460cbb7-83b5-4234-9fbd-33712a8da9f4",
      "code": "class Solution:\n  def circularPermutation(self, n: int, start: int) -> list[int]:\n    return [start ^ i ^ i >> 1 for i in range(1 << n)]",
      "title": "1238. Circular Permutation in Binary Representation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2036735-18ae-4c20-892a-b236e7ea311a",
      "code": "class Solution:\n  def tilingRectangle(self, n: int, m: int) -> int:\n    @functools.lru_cache(None)\n    def dp(heights: int) -> int:\n      minHeight = min(heights)\n      if minHeight == n:  # All filled.\n        return 0\n\n      ans = m * n\n      heightsList = list(heights)\n      start = heightsList.index(minHeight)\n\n      # Try to put square of different size that doesn't exceed the width/height.\n      for sz in range(1, min(m - start + 1, n - minHeight + 1)):\n        # heights[start..start + sz) must has the same height.\n        if heights[start + sz - 1] != minHeight:\n          break\n        # Put a square of size `sz` to cover heights[start..start + sz).\n        heightslist[start:start + sz] = [minHeight + sz] * sz\n        ans = min(ans, dp(tuple(heightsList)))\n\n      return 1 + ans\n\n    return dp(tuple([0] * m))",
      "title": "1240. Tiling a Rectangle with the Fewest Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2cf9625-2467-40ea-b45e-30fdf39048b8",
      "code": "class Solution:\n  def transformArray(self, arr: list[int]) -> list[int]:\n    if len(arr) < 3:\n      return arr\n\n    ans = []\n\n    while ans != arr:\n      ans = arr[:]\n      for i in range(1, len(arr) - 1):\n        if ans[i - 1] > ans[i] < ans[i + 1]:\n          arr[i] += 1\n        elif ans[i - 1] < ans[i] > ans[i + 1]:\n          arr[i] -= 1\n\n    return ans",
      "title": "1243. Array Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c425d624-6248-462d-9157-57d9ec756e14",
      "code": "class Solution:\n  def minimumMoves(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]\n    dp = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for i in range(n - 1):\n      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2\n\n    for d in range(2, n):\n      for i in range(n - d):\n        j = i + d\n        # Remove arr[i] and arr[j] within the move of removing\n        # arr[i + 1..j - 1]\n        if arr[i] == arr[j]:\n          dp[i][j] = dp[i + 1][j - 1]\n        # Try all the possible partitions.\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    return dp[0][n - 1]",
      "title": "1246. Palindrome Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4063efa5-0306-4b0e-a7e3-1e0e141a92b3",
      "code": "class Solution:\n  def minimumSwap(self, s1: str, s2: str) -> int:\n    # ('xx', 'yy') = (2 'xy's) . 1 swap\n    # ('yy', 'xx') = (2 'yx's) . 1 swap\n    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps\n    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'\n    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'\n\n    for a, b in zip(s1, s2):\n      if a == b:\n        continue\n      if a == 'x':\n        xy += 1\n      else:\n        yx += 1\n\n    if (xy + yx) % 2 == 1:\n      return -1\n    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)",
      "title": "1247. Minimum Swaps to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e54b205d-d531-4f6f-963f-43682cf23666",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int], k: int) -> int:\n    def numberOfSubarraysAtMost(k: int) -> int:\n      ans = 0\n      l = 0\n      r = 0\n\n      while r <= len(nums):\n        if k >= 0:\n          ans += r - l\n          if r == len(nums):\n            break\n          if nums[r] & 1:\n            k -= 1\n          r += 1\n        else:\n          if nums[l] & 1:\n            k += 1\n          l += 1\n      return ans\n\n    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)",
      "title": "1248. Count Number of Nice Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a10817b8-c0b4-4332-92c3-f7b7ab681e60",
      "code": "class Solution:\n  def minRemoveToMakeValid(self, s: str) -> str:\n    stack = []  # unpaired '(' indices\n    chars = list(s)\n\n    for i, c in enumerate(chars):\n      if c == '(':\n        stack.append(i)  # Record the unpaired '(' index.\n      elif c == ')':\n        if stack:\n          stack.pop()  # Find a pair\n        else:\n          chars[i] = '*'  # Mark the unpaired ')' as '*'.\n\n    # Mark the unpaired '(' as '*'.\n    while stack:\n      chars[stack.pop()] = '*'\n\n    return ''.join(chars).replace('*', '')",
      "title": "1249. Minimum Remove to Make Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dac9da97-0c80-4311-b009-841f19707ae9",
      "code": "class Solution:\n  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:\n    # rows[i] and cols[i] :=\n    #   1. True (flipped even times)\n    #   2. False (flipped odd times)\n    rows = [False] * m\n    cols = [False] * n\n\n    for r, c in indices:\n      rows[r] ^= True\n      cols[c] ^= True\n\n    oddRowsCount = rows.count(True)\n    oddColsCount = cols.count(True)\n    evenRowsCount = m - oddRowsCount\n    evenColsCount = n - oddColsCount\n    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount",
      "title": "1252. Cells with Odd Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd4e370-3b4c-4ee5-a3ad-154a3823867f",
      "code": "class Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: list[int]) -> list[list[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans",
      "title": "1253. Reconstruct a 2-Row Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "314a32a8-6adf-4d3d-b2e9-1eab0f9f49ba",
      "code": "class Solution:\n  def closedIsland(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    # Remove the lands connected to the edge.\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    # Reduce to 200. Number of Islands\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "1254. Number of Closed Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d06caa79-f4d5-4ffc-aa75-5c682bc92cbb",
      "code": "class Solution:\n  def maxScoreWords(\n      self,\n      words: list[str],\n      letters: list[str],\n      score: list[int],\n  ) -> int:\n    count = collections.Counter(letters)\n\n    def useWord(i: int) -> int:\n      isValid = True\n      earned = 0\n      for c in words[i]:\n        count[c] -= 1\n        if count[c] < 0:\n          isValid = False\n        earned += score[ord(c) - ord('a')]\n      return earned if isValid else -1\n\n    def unuseWord(i: int) -> None:\n      for c in words[i]:\n        count[c] += 1\n\n    def dfs(s: int) -> int:\n      \"\"\"Returns the maximum score you can get from words[s..n).\"\"\"\n      ans = 0\n      for i in range(s, len(words)):\n        earned = useWord(i)\n        if earned > 0:\n          ans = max(ans, earned + dfs(i + 1))\n        unuseWord(i)\n      return ans\n\n    return dfs(0)",
      "title": "1255. Maximum Score Words Formed by Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e27cbd7e-3a38-4115-9fb8-af422a3f2814",
      "code": "class Solution:\n  def encode(self, num: int) -> str:\n    return bin(num + 1)[3:]",
      "title": "1256. Encode Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b9380db-0474-488b-ad6f-87018c5fc385",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def generateSentences(\n      self,\n      synonyms: list[list[str]],\n      text: str,\n  ) -> list[str]:\n    ans = SortedSet()\n    graph = collections.defaultdict(list)\n    q = collections.deque([text])\n\n    for s, t in synonyms:\n      graph[s].append(t)\n      graph[t].append(s)\n\n    while q:\n      u = q.popleft()\n      ans.add(u)\n      words = u.split()\n      for i, word in enumerate(words):\n        for synonym in graph[word]:\n          # Replace words[i] with its synonym.\n          words[i] = synonym\n          newText = ' '.join(words)\n          if newText not in ans:\n            q.append(newText)\n\n    return list(ans)",
      "title": "1258. Synonymous Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac8ceb1c-0f52-4ebc-b486-17a1bed3bcd0",
      "code": "class Solution:\n  def numberOfWays(self, numPeople: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways i handshakes could occure s.t. none of the\n    # handshakes cross\n    dp = [1] + [0] * (numPeople // 2)\n\n    for i in range(1, numPeople // 2 + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - 1 - j]\n        dp[i] %= MOD\n\n    return dp[numPeople // 2]",
      "title": "1259. Handshakes That Don't Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d31cbd6-081e-426c-a9f4-50c50ba1f247",
      "code": "class Solution:\n  def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    k %= m * n\n\n    for i in range(m):\n      for j in range(n):\n        index = (i * n + j + k) % (m * n)\n        x = index // n\n        y = index % n\n        ans[x][y] = grid[i][j]\n\n    return ans",
      "title": "1260. Shift 2D Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2e26c12-ba24-4e85-ac40-0adef43c887a",
      "code": "class Solution:\n  def minPushBox(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 'B':\n          box = (i, j)\n        elif grid[i][j] == 'S':\n          player = (i, j)\n        elif grid[i][j] == 'T':\n          target = (i, j)\n\n    def isInvalid(playerX: int, playerY: int) -> bool:\n      return (playerX < 0 or playerX == m or playerY < 0 or playerY == n or\n              grid[playerX][playerY] == '#')\n\n    def canGoTo(\n        playerX: int,\n        playerY: int,\n        fromX: int,\n        fromY: int,\n        boxX: int,\n        boxY: int\n    ) -> bool:\n      \"\"\"Returns True if (playerX, playerY) can go to (fromX, fromY).\"\"\"\n      q = collections.deque([(playerX, playerY)])\n      seen = {(playerX, playerY)}\n\n      while q:\n        i, j = q.popleft()\n        if i == fromX and j == fromY:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if isInvalid(x, y):\n            continue\n          if (x, y) in seen:\n            continue\n          if x == boxX and y == boxY:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    # (boxX, boxY, playerX, playerY)\n    q = collections.deque([(box[0], box[1], player[0], player[1])])\n    seen = {(box[0], box[1], player[0], player[1])}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        boxX, boxY, playerX, playerY = q.popleft()\n        if boxX == target[0] and boxY == target[1]:\n          return step\n        for k, (dx, dy) in enumerate(DIRS):\n          nextBoxX = boxX + dx\n          nextBoxY = boxY + dy\n          if isInvalid(nextBoxX, nextBoxY):\n            continue\n          if (nextBoxX, nextBoxY, boxX, boxY) in seen:\n            continue\n          fromX = boxX + DIRS[(k + 2) % 4][0]\n          fromY = boxY + DIRS[(k + 2) % 4][1]\n          if isInvalid(fromX, fromY):\n            continue\n          if canGoTo(playerX, playerY, fromX, fromY, boxX, boxY):\n            q.append((nextBoxX, nextBoxY, boxX, boxY))\n            seen.add((nextBoxX, nextBoxY, boxX, boxY))\n      step += 1\n\n    return -1",
      "title": "1263. Minimum Moves to Move a Box to Their Target Location",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "243bd101-b3b8-42f1-be73-56d98b46c6e0",
      "code": "class Solution:\n  def minTimeToVisitAllPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(1, len(points)):\n      ans += max(abs(points[i][0] - points[i - 1][0]),\n                 abs(points[i][1] - points[i - 1][1]))\n\n    return ans",
      "title": "1266. Minimum Time Visiting All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4d0d582-b1a9-407b-addc-75986f77f634",
      "code": "class Solution:\n  def countServers(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans",
      "title": "1267. Count Servers that Communicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2655b9f-e547-4fa8-82d0-32e9e6a26192",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def suggestedProducts(\n      self,\n      products: list[str],\n      searchWord: str\n  ) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    def search(node: TrieNode | None) -> list[str]:\n      res: list[str] = []\n      dfs(node, res)\n      return res\n\n    def dfs(node: TrieNode | None, res: list[str]) -> None:\n      if len(res) == 3:\n        return\n      if not node:\n        return\n      if node.word:\n        res.append(node.word)\n      for c in string.ascii_lowercase:\n        if c in node.children:\n          dfs(node.children[c], res)\n\n    for product in products:\n      insert(product)\n\n    node = root\n\n    for c in searchWord:\n      if not node or c not in node.children:\n        node = None\n        ans.append([])\n        continue\n      node = node.children[c]\n      ans.append(search(node))\n\n    return ans",
      "title": "1268. Search Suggestions System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d970e52-aa51-40ce-83dd-fcd4ea10f6d9",
      "code": "class Solution:\n  def numWays(self, steps: int, arrLen: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to stay at index i\n    dp = [0] * min(steps // 2 + 1, arrLen)\n    dp[0] = 1\n\n    for _ in range(steps):\n      newDp = [0] * min(steps // 2 + 1, arrLen)\n      for i, ways in enumerate(dp):\n        if ways > 0:\n          for dx in (-1, 0, 1):\n            nextIndex = i + dx\n            if 0 <= nextIndex < len(dp):\n              newDp[nextIndex] += ways\n              newDp[nextIndex] %= MOD\n      dp = newDp\n\n    return dp[0]",
      "title": "1269. Number of Ways to Stay in the Same Place After Some Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26b654e2-ce75-4f38-a34a-d5ba704c7543",
      "code": "class Solution:\n  def toHexspeak(self, num: str) -> str:\n    s = hex(int(num)).upper()[2:].translate(str.maketrans('01', 'OI'))\n    return 'ERROR' if any(c.isdigit() for c in s) else s",
      "title": "1271. Hexspeak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0e2c7fc-a405-427d-9ef7-f93733e2d438",
      "code": "class Solution:\n  def removeInterval(self, intervals: list[list[int]],\n                     toBeRemoved: list[int]) -> list[list[int]]:\n    ans = []\n\n    for a, b in intervals:\n      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:\n        ans.append([a, b])\n      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]\n        if a < toBeRemoved[0]:\n          ans.append([a, toBeRemoved[0]])\n        if b > toBeRemoved[1]:\n          ans.append([toBeRemoved[1], b])\n\n    return ans",
      "title": "1272. Remove Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53b8057e-d401-4789-8fa7-df491d8095a6",
      "code": "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Sea(object):\n#   def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#     pass\n#\n# class Point(object):\n# def __init__(self, x: int, y: int):\n# self.x = x\n# self.y = y\n\nclass Solution(object):\n  def countShips(\n      self,\n      sea: 'Sea',\n      topRight: 'Point',\n      bottomLeft: 'Point',\n  ) -> int:\n    if topRight.x < bottomLeft.x or topRight.y < bottomLeft.y:\n      return 0\n    if not sea.hasShips(topRight, bottomLeft):\n      return 0\n\n    # sea.hashShips(topRight, bottomLeft) == True\n    if topRight.x == bottomLeft.x and topRight.y == bottomLeft.y:\n      return 1\n\n    mx = (topRight.x + bottomLeft.x) // 2\n    my = (topRight.y + bottomLeft.y) // 2\n    ans = 0\n    # the top-right\n    ans += self.countShips(sea, topRight, Point(mx + 1, my + 1))\n    # the bottom-right\n    ans += self.countShips(sea, Point(topRight.x, my),\n                           Point(mx + 1, bottomLeft.y))\n    # the top-left\n    ans += self.countShips(sea, Point(mx, topRight.y),\n                           Point(bottomLeft.x, my + 1))\n    # the bottom-left\n    ans += self.countShips(sea, Point(mx, my), bottomLeft)\n    return ans",
      "title": "1274. Number of Ships in a Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44b9a1b2-11a6-49a8-9406-fd5e2da293a4",
      "code": "class Solution:\n  def tictactoe(self, moves: list[list[int]]) -> str:\n    row = [[0] * 3 for _ in range(2)]\n    col = [[0] * 3 for _ in range(2)]\n    diag1 = [0] * 2\n    diag2 = [0] * 2\n    i = 0\n\n    for r, c in moves:\n      row[i][r] += 1\n      col[i][c] += 1\n      diag1[i] += r == c\n      diag2[i] += r + c == 2\n      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):\n        return 'A' if i == 0 else 'B'\n      i ^= 1\n\n    return 'Draw' if len(moves) == 9 else 'Pending'",
      "title": "1275. Find Winner on a Tic Tac Toe Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89ac07dc-592d-4a42-aead-20e2e7751441",
      "code": "class Solution:\n  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> list[int]:\n    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:\n      return []\n\n    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2\n\n    return [jumboBurgers, cheeseSlices - jumboBurgers]",
      "title": "1276. Number of Burgers with No Waste of Ingredients",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c8e705f-7263-4a87-8eb2-d5d2c0a2d78c",
      "code": "class Solution:\n  def countSquares(self, matrix: list[list[int]]) -> int:\n    for i in range(len(matrix)):\n      for j in range(len(matrix[0])):\n        if matrix[i][j] == 1 and i > 0 and j > 0:\n          matrix[i][j] += min(matrix[i - 1][j - 1],\n                              matrix[i - 1][j], matrix[i][j - 1])\n    return sum(map(sum, matrix))",
      "title": "1277. Count Square Submatrices with All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5107dbe-da91-481b-a4f3-f090ed50d726",
      "code": "class Solution:\n  def subtractProductAndSum(self, n: int) -> int:\n    prod = 1\n    summ = 0\n\n    while n > 0:\n      prod *= n % 10\n      summ += n % 10\n      n //= 10\n\n    return prod - summ",
      "title": "1281. Subtract the Product and Sum of Digits of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ee56427-4d0c-4d51-8e29-6de234b544da",
      "code": "class Solution:\n  def groupThePeople(self, groupSizes: list[int]) -> list[list[int]]:\n    ans = []\n    groupSizeToIndices = defaultdict(list)\n\n    for i, groupSize in enumerate(groupSizes):\n      groupSizeToIndices[groupSize].append(i)\n\n    for groupSize, indices in groupSizeToIndices.items():\n      groupIndices = []\n      for index in indices:\n        groupIndices.append(index)\n        if len(groupIndices) == groupSize:\n          ans.append(groupIndices.copy())\n          groupIndices.clear()\n\n    return ans",
      "title": "1282. Group the People Given the Group Size They Belong To",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0409f609-be42-473d-aeb8-199c8230434d",
      "code": "class Solution:\n  def smallestDivisor(self, nums: list[int], threshold: int) -> int:\n    l = 1\n    r = max(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if sum((num - 1) // m + 1 for num in nums) <= threshold:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "1283. Find the Smallest Divisor Given a Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac4907b4-c2b5-43c6-bf71-a5c39a7cfd8d",
      "code": "class Solution:\n  def minFlips(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            # Flie the four neighbors.\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: list[list[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash",
      "title": "1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c079b798-121b-4698-8471-9067b8843b96",
      "code": "class Solution:\n  def findSpecialInteger(self, arr: list[int]) -> int:\n    n = len(arr)\n    quarter = n // 4\n\n    for i in range(n - quarter):\n      if arr[i] == arr[i + quarter]:\n        return arr[i]",
      "title": "1287. Element Appearing More Than 25% In Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22ae7950-1f19-43e6-8544-451617862c82",
      "code": "class Solution:\n  def removeCoveredIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = 0\n\n    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):\n      # The current interval is not covered by the previous one.\n      if prevEnd < end:\n        prevEnd = end\n        ans += 1\n\n    return ans",
      "title": "1288. Remove Covered Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da62297b-2490-4b60-ba43-58036d3bf946",
      "code": "class Solution:\n  def minFallingPathSum(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n\n    for i in range(1, n):\n      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(\n          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]\n      for j in range(n):\n        if j == firstMinIndex:\n          grid[i][j] += secondMinNum\n        else:\n          grid[i][j] += firstMinNum\n\n    return min(grid[-1])",
      "title": "1289. Minimum Falling Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}