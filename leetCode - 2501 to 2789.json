{
  "snippets": [
    {
      "id": "21473fe0-9712-494a-b0d9-0adeee60faee",
      "code": "class Solution:\n  def minChanges(self, n: int, k: int) -> int:\n    # n needs to be a superset of k.\n    return (n ^ k).bit_count() if (n & k) == k else -1",
      "title": "3226. Number of Bit Changes to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35b05ba0-0146-4852-b55f-2d684009faef",
      "code": "class Solution:\n  def doesAliceWin(self, s: str) -> bool:\n    # Let k be the number of vowels in s.\n    # 1. If k == 0, Bob wins since Alice has no vowels to pick.\n    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.\n    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,\n    # then Bob will either pick a substring containing 0 vowels, resulting in\n    # Alice picking the remaining entire string, or Bob couldn't pick at all\n    # (the last vowel).\n    VOWELS = 'aeiou'\n    return any(c in VOWELS for c in s)",
      "title": "3227. Vowels Game in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a108eed-e8ab-4083-a86d-cd30238a6bad",
      "code": "class Solution:\n  def maxOperations(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      elif i + 1 == len(s) or s[i + 1] == '1':\n        ans += ones\n\n    return ans",
      "title": "3228. Maximum Number of Operations to Move Ones to the End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7bc8bfc-bc25-406d-9532-b38203cf4d2a",
      "code": "class Solution:\n  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array\n  def minimumOperations(self, nums: list[int], target: list[int]) -> int:\n    ans = abs(nums[0] - target[0])\n\n    for (prevNum, prevTarget), (currNum, currTarget) in (\n        itertools.pairwise(zip(nums, target))\n    ):\n      currDiff = currTarget - currNum\n      prevDiff = prevTarget - prevNum\n      if currDiff >= 0 and prevDiff >= 0:\n        ans += max(0, currDiff - prevDiff)\n      elif currDiff <= 0 and prevDiff <= 0:\n        ans += max(0, abs(currDiff) - abs(prevDiff))\n      else:\n        ans += abs(currDiff)\n\n    return ans",
      "title": "3229. Minimum Operations to Make Array Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eb9c2a1-d98f-4222-b962-31adec66a534",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return self._lengthOfLIS(nums[::-1])\n\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num >= tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_right(tails, num)] = num\n    return len(tails)",
      "title": "3231. Minimum Number of Increasing Subsequence to Be Removed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0f91c5f-2949-4b9a-941c-b75a4d232145",
      "code": "class Solution:\n  def canAliceWin(self, nums: list[int]) -> bool:\n    return sum(num if num < 10 else -num for num in nums) != 0",
      "title": "3232. Find if Digit Game Can Be Won",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f69882b2-463b-49b8-b6b9-15c9f39303e3",
      "code": "class Solution:\n  def nonSpecialCount(self, l: int, r: int) -> int:\n    maxRoot = math.isqrt(r)\n    isPrime = self._sieveEratosthenes(maxRoot + 1)\n    specialCount = 0\n\n    for num in range(2, math.isqrt(r) + 1):\n      if isPrime[num] and l <= num**2 <= r:\n        specialCount += 1\n\n    return r - l + 1 - specialCount\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3233. Find the Count of Numbers Which Are Not Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6e4faab-2b2b-42ea-8cc1-3f2d2e569de4",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    #    z^2 + z = n.\n    # => z^2 + z - n = 0.\n    # => z = (-1 + sqrt(1 + 4n)) / 2.\n    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2\n\n    # Iterate through all possible number of 0s.\n    for zero in range(int(maxZero) + 1):\n      lastInvalidPos = -1\n      count = [0, 0]\n      l = 0\n      for r, c in enumerate(s):\n        count[int(c)] += 1\n        # Try to shrink the window to maintain the \"minimum\" length of the\n        # valid substring.\n        while l < r:\n          if s[l] == '0' and count[0] > zero:\n            count[0] -= 1  # Remove an extra '0'.\n            lastInvalidPos = l\n            l += 1\n          elif s[l] == '1' and count[1] - 1 >= zero * zero:\n            count[1] -= 1  # Remove an extra '1'.\n            l += 1\n          else:\n            break  # Cannot remove more characters.\n        if count[0] == zero and count[1] >= zero * zero:\n          # Add valid substrings ending in s[r] to the answer. They are\n          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos\n\n    return ans",
      "title": "3234. Count the Number of Substrings With Dominant Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a7fd476-2e44-4c49-885b-2d6a35522ddc",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canReachCorner(self, X: int, Y: int, circles: list[list[int]]) -> bool:\n    n = len(circles)\n    # Add two virtual nodes, where node n represents (0, 0) and node n + 1\n    # represents (X, Y).\n    uf = UnionFind(n + 2)\n\n    # Iterate through each circle.\n    for i, (x, y, r) in enumerate(circles):\n      # Union the current circle with the node (0, 0) if the circle overlaps\n      # with the left or top edges.\n      if x - r <= 0 or y + r >= Y:\n        uf.unionByRank(i, n)\n      # Union the current circle with the node (X, Y) if the circle overlaps\n      # with the right or bottom edges.\n      if x + r >= X or y - r <= 0:\n        uf.unionByRank(i, n + 1)\n      # Union the current circle with previous circles if they overlap.\n      for j in range(i):\n        x2, y2, r2 = circles[j]\n        if (x - x2)**2 + (y - y2)**2 <= (r + r2)**2:\n          uf.unionByRank(i, j)\n\n    # If nodes (0, 0) and (X, Y) are in the same union set, that means there's\n    # a path of overlapping circles that connects the left or top edges to the\n    # right or bottom edges, implying that (0, 0) cannot reach (X, Y).\n    return uf.find(n) != uf.find(n + 1)",
      "title": "3235. Check if the Rectangle Corner Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bca72fae-d3c2-47bd-a613-a1b4d3ffb47d",
      "code": "class Solution:\n  def simulationResult(\n      self,\n      windows: list[int],\n      queries: list[int],\n  ) -> list[int]:\n    ans = []\n    seen = set()\n\n    for query in reversed(queries):\n      if query not in seen:\n        ans.append(query)\n        seen.add(query)\n\n    for window in windows:\n      if window not in seen:\n        ans.append(window)\n        seen.add(window)\n\n    return ans",
      "title": "3237. Alt and Tab Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd16843d-070c-4027-ac5d-7a02a40e6251",
      "code": "class Solution:\n  def winningPlayerCount(self, n: int, pick: list[list[int]]) -> int:\n    counts = [collections.Counter() for _ in range(n)]\n    for player, color in pick:\n      counts[player][color] += 1\n    return sum(max(count.values(), default=0) > i\n               for i, count in enumerate(counts))",
      "title": "3238. Find the Number of Winning Players",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18e624e6-338d-4855-a9d8-fa76cd83415c",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    rowFlips = sum(row[i] != row[-1 - i]\n                   for row in grid for i in range(len(row) // 2))\n    colFlips = sum(col[i] != col[-1 - i] for col in zip(*grid)\n                   for i in range(len(col) // 2))\n    return min(rowFlips, colFlips)",
      "title": "3239. Minimum Number of Flips to Make Binary Grid Palindromic I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74ee0203-208f-475e-8eb3-0208a0999ec8",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    middleOnes = 0\n    mismatchedPairs = 0\n\n    # Handle top-left, top-right, bottom-left, bottom-right cells.\n    for i in range(m // 2):\n      for j in range(n // 2):\n        ones = (grid[i][j] + grid[i][n - 1 - j] +\n                grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j])\n        ans += min(ones, 4 - ones)\n\n    # Handle the middle row if the number of m is odd.\n    if m % 2 == 1:\n      for j in range(n // 2):\n        leftCell = grid[m // 2][j]\n        rightCell = grid[m // 2][n - 1 - j]\n        mismatchedPairs += leftCell ^ rightCell\n        middleOnes += leftCell + rightCell\n\n    # Handle the middle column if the number of columns is odd.\n    if n % 2 == 1:\n      for i in range(m // 2):\n        topCell = grid[i][n // 2]\n        bottomCell = grid[m - 1 - i][n // 2]\n        mismatchedPairs += topCell ^ bottomCell\n        middleOnes += topCell + bottomCell\n\n    if mismatchedPairs == 0:\n      # Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.\n      if middleOnes % 4 == 2:\n        ans += 2  # Flip two 1s to 0s.\n    else:\n      # Flip every mismatched pair 01 to 00 or 11. It doesn't matter.\n      ans += mismatchedPairs\n\n    # Handle the center cell if both dimensions are odd.\n    if m % 2 == 1 and n % 2 == 1:\n      ans += grid[m // 2][n // 2]\n\n    return ans",
      "title": "3240. Minimum Number of Flips to Make Binary Grid Palindromic II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45029197-672b-4a4c-8d93-60d73f2eea86",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time taken to mark the entire subtree rooted at the node\n\n\nclass Top2:\n  def __init__(self, top1: Node = Node(), top2: Node = Node()):\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the maximum\n    self.top1 = top1\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the second maximum\n    self.top2 = top2\n\n\nclass Solution:\n  def timeTaken(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the top two direct child nodes for subtree rooted at node i,\n    # where each node contains the time taken to mark the entire subtree rooted\n    # at the node itself\n    dp = [Top2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, 0, dp, ans)\n    return ans\n\n  def _getTime(self, u: int) -> int:\n    \"\"\"Returns the time taken to mark node u.\"\"\"\n    return 2 if u % 2 == 0 else 1\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Top2]\n  ) -> int:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the top two direct\n    child nodes, where the time taken to mark the subtree rooted at each of the\n    child nodes is maximized, and returns the top child node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    top1 = Node()\n    top2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      time = self._dfs(tree, v, u, dp) + self._getTime(v)\n      if time >= top1.time:\n        top2 = top1\n        top1 = Node(v, time)\n      elif time > top2.time:\n        top2 = Node(v, time)\n    dp[u] = Top2(top1, top2)\n    return top1.time\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      maxTime: int,\n      dp: list[Top2],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `maxTime`\n    is the longest path that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = max(maxTime, dp[u].top1.time)\n\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newMaxTime = self._getTime(u) + max(\n          maxTime,\n          dp[u].top2.time if dp[u].top1.node == v else dp[u].top1.time\n      )\n      self._reroot(tree, v, u, newMaxTime, dp, ans)",
      "title": "3241. Time Taken to Mark All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "551767bb-f61f-4e60-8cfa-d15360e46825",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    dist = list(range(n))\n    graph = [[] for _ in range(n)]\n\n    for i in range(n - 1):\n      graph[i].append(i + 1)\n\n    for u, v in queries:\n      graph[u].append(v)\n      if dist[u] + 1 < dist[v]:\n        dist[v] = dist[u] + 1\n        self._bfs(graph, v, dist)\n      ans.append(dist[n - 1])\n\n    return ans\n\n  def _bfs(self, graph: list[list[int]], start: int, dist: list[int]) -> None:\n    \"\"\"\n    Performs a BFS to update the shortest distances from the given `start` node\n    to all other reachable nodes in the graph. It updates the `dist` vector\n    with the new shortest distances.\n    \"\"\"\n    q = collections.deque([start])\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if dist[u] + 1 < dist[v]:\n          dist[v] = dist[u] + 1\n          q.append(v)",
      "title": "3243. Shortest Distance After Road Addition Queries I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d1a8f14-034d-44b2-8196-8131377296c8",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    nodeToFarthestNode = {i: i + 1 for i in range(n - 1)}\n\n    for u, v in queries:\n      # If `u` exists in the map and `v` is farther than the current farthest\n      # node for `u`, we need to update the map and remove intermediate nodes.\n      if u in nodeToFarthestNode and nodeToFarthestNode[u] < v:\n        node = nodeToFarthestNode[u]\n        while node < v:\n          node = nodeToFarthestNode.pop(node)\n        nodeToFarthestNode[u] = v\n      ans.append(len(nodeToFarthestNode))\n\n    return ans",
      "title": "3244. Shortest Distance After Road Addition Queries II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd3506c-def1-4932-b854-8bd3fda5de90",
      "code": "class Solution:\n  def subsequenceCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    even = 0  # the number of subsequences with even sum\n    odd = 0  # the number of subsequences with odd sum\n\n    for num in nums:\n      if num % 2 == 0:\n        # Appending an even number to a subsequence doesn't change the parity.\n        # The even number itself is also a valid subsequence.\n        even, odd = even + even + 1, odd + odd\n      else:\n        # Appending an odd number to a subsequence changes the parity.\n        # The odd number itself is also a valid subsequence.\n        even, odd = even + odd, odd + even + 1\n\n    return odd % MOD",
      "title": "3247. Number of Subsequences with Odd Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c56b606-6c72-4b9d-970e-5845d62887bd",
      "code": "class Solution:\n  def finalPositionOfSnake(self, n: int, commands: list[str]) -> int:\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1),\n    }\n    i = 0\n    j = 0\n\n    for command in commands:\n      dx, dy = directions[command]\n      i += dx\n      j += dy\n\n    return i * n + j",
      "title": "3248. Snake in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61f09549-186e-40d9-9300-96f4cbce93c8",
      "code": "class Solution:\n  def countGoodNodes(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    ans = 0\n\n    def dfs(u: int, prev: int) -> int:\n      \"\"\"Returns the size of the subtree rooted at u.\"\"\"\n      nonlocal ans\n      size = 1\n      childrenSizes = []\n      for v in graph[u]:\n        if v == prev:\n          continue\n        child_size = dfs(v, u)\n        size += child_size\n        childrenSizes.append(child_size)\n\n      if not childrenSizes or all(s == childrenSizes[0]\n                                  for s in childrenSizes):\n        ans += 1\n\n      return size\n\n    dfs(0, -1)\n    return ans",
      "title": "3249. Count the Number of Good Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e5431e3-538a-4081-9cdb-5909431403f9",
      "code": "class Solution:\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3250. Find the Count of Monotonic Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee8b99bd-eb13-46bd-99cf-40c8b2a0d841",
      "code": "class Solution:\n  # Same as 3250. Find the Count of Monotonic Pairs I\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3251. Find the Count of Monotonic Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9951ba0-f057-440a-94e5-98ea59c3aeb3",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0:i]\n    dp = [0] + [math.inf] * n\n\n    for i in range(1, n + 1):\n      for j, (word, cost) in enumerate(zip(words, costs)):\n        if (i >= len(word) and\n            target[i - len(word):i] == word and\n                dp[i - len(word)] != math.inf):\n          dp[i] = min(dp[i], dp[i - len(word)] + cost)\n\n    return dp[n] if dp[n] != math.inf else -1",
      "title": "3253. Construct String with Minimum Cost (Easy)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48b66d45-7109-4947-a321-496cd29426a1",
      "code": "class Solution:\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3254. Find the Power of K-Size Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7450d1f1-6a60-4349-9511-d19c9c2d207e",
      "code": "class Solution:\n  # Same as 3254. Find the Power of K-Size Subarrays I\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3255. Find the Power of K-Size Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f97f2be3-74bd-47df-a3c2-e306982b7786",
      "code": "class Solution:\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3256. Maximum Value Sum by Placing Three Rooks I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e973fe-0b53-4afa-8407-0ad5f7b6e707",
      "code": "class Solution:\n  # Same as 3256. Maximum Value Sum by Placing Three Rooks I\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3257. Maximum Value Sum by Placing Three Rooks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5aa36728-7a9f-443c-a0b3-6074664a19c4",
      "code": "class Solution:\n  def countKConstraintSubstrings(self, s: str, k: int) -> int:\n    ans = 0\n    count = [0, 0]\n\n    l = 0\n    for r, c in enumerate(s):\n      count[int(c)] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "3258. Count Substrings That Satisfy K-Constraint I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f36b6c82-a3b6-4f1a-ae7b-fab15ae5d87c",
      "code": "class Solution:\n  def maxEnergyBoost(\n      self,\n      energyDrinkA: list[int],\n      energyDrinkB: list[int]\n  ) -> int:\n    dpA = 0  # the maximum energy boost if the last drink is A\n    dpB = 0  # the maximum energy boost if the last drink is B\n\n    for a, b in zip(energyDrinkA, energyDrinkB):\n      dpA, dpB = max(dpB, dpA + a), max(dpA, dpB + b)\n\n    return max(dpA, dpB)",
      "title": "3259. Maximum Energy Boost From Two Drinks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26c40cfa-c3e3-4565-8055-2c0981516255",
      "code": "class Solution:\n  def largestPalindrome(self, n: int, k: int) -> str:\n    match k:\n      case 1:\n        return '9' * n\n      case 2:\n        return '8' * n if n <= 2 else '8' + '9' * (n - 2) + '8'\n      case 3 | 9:\n        return '9' * n\n      case 4:\n        return '8' * n if n <= 4 else '88' + '9' * (n - 4) + '88'\n      case 5:\n        return '5' * n if n <= 2 else '5' + '9' * (n - 2) + '5'\n      case 6:\n        if n <= 2:\n          return '6' * n\n        elif n % 2 == 1:\n          l = n // 2 - 1\n          return '8' + '9' * l + '8' + '9' * l + '8'\n        else:\n          l = n // 2 - 2\n          return '8' + '9' * l + '77' + '9' * l + '8'\n      case 8:\n        return '8' * n if n <= 6 else '888' + '9' * (n - 6) + '888'\n      case _:\n        middle = {\n            0: '', 1: '7', 2: '77', 3: '959', 4: '9779', 5: '99799',\n            6: '999999', 7: '9994999', 8: '99944999', 9: '999969999',\n            10: '9999449999', 11: '99999499999'\n        }\n        q, r = divmod(n, 12)\n        return '999999' * q + middle[r] + '999999' * q",
      "title": "3260. Find the Largest Palindrome Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eaeebe7b-c22f-46f4-b50a-571ef0424ad3",
      "code": "class Solution:\n  def countKConstraintSubstrings(\n      self,\n      s: str,\n      k: int,\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(s)\n    ans = []\n    count = [0, 0]\n    # leftToRight[l] := the maximum right index r s.t. s[l..r] is valid\n    leftToRight = [0] * n\n    # rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid\n    rightToLeft = [0] * n\n\n    l = 0\n    for r in range(n):\n      count[int(s[r])] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      rightToLeft[r] = l\n\n    count = [0, 0]\n    r = n - 1\n    for l in reversed(range(n)):\n      count[int(s[l])] += 1\n      while min(count) > k:\n        count[int(s[r])] -= 1\n        r -= 1\n      leftToRight[l] = r\n\n    # prefix[i] := the number of valid substrings ending in [0..i - 1].\n    prefix = list(itertools.accumulate((r - l + 1\n                                       for r, l in enumerate(rightToLeft)),\n                                       initial=0))\n\n    for l, r in queries:\n      if r > leftToRight[l]:\n        # If r is beyond leftToRight[l], compute the number of valid substrings\n        # from l to leftToRight[l] and add the number of valid substrings\n        # ending in [leftToRight[l] + 1..r].\n        #\n        # prefix[r + 1] := the number of valid substrings ending in [0..r].\n        # prefix[leftToRight[l] + 1] := the number of valid substrings ending\n        # in [0..leftToRight].\n        # => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid\n        # substrings ending in [leftToRight[l] + 1..r].\n        sz = leftToRight[l] - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2 + (\n            prefix[r + 1] - prefix[leftToRight[l] + 1])\n      else:\n        # If r is within the range of leftToRight[l], compute the number of\n        # valid substrings directly from l to r.\n        sz = r - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2\n      ans.append(numValidSubstrings)\n\n    return ans",
      "title": "3261. Count Substrings That Satisfy K-Constraint II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6390184-d5a6-4a1f-83d6-820d6ff2ef3e",
      "code": "class Solution:\n  def toArray(self, head: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = head\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3263. Convert Doubly Linked List to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bf030df-4446-4fa1-92b6-c8551c6bccc8",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n\n    for num, i in minHeap:\n      ans[i] = num\n\n    return ans",
      "title": "3264. Final Array State After K Multiplication Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff3756b9-1b2e-407f-95fa-7731245b8385",
      "code": "class Solution:\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 swap.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3265. Count Almost Equal Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce371b2d-c175-4813-aae6-78dc02b2bed4",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    if multiplier == 1:\n      return nums\n\n    MOD = 1_000_000_007\n    n = len(nums)\n    maxNum = max(nums)\n    ans = [0] * n\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n\n    heapq.heapify(minHeap)\n\n    # Keep multiplying the minimum number as close as possible to the maximum\n    # number in the array. After that, stop multiplying the minimum number\n    # because it will be greater than the maximum number in the array and break\n    # the circularity.\n    while k > 0 and minHeap[0][0] * multiplier <= maxNum:\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n      k -= 1\n\n    sortedIndexedNums = sorted(minHeap)\n    multipliesPerNum, remainingK = divmod(k, n)\n\n    # Evenly distribute the remaining multiplications to each number by using\n    # fast exponentiation.\n    for index, (num, i) in enumerate(sortedIndexedNums):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] *\n          pow(multiplier, multipliesPerNum, MOD) % MOD, i)\n\n    # Distribute the remaining multiplications to the minimum `remainingK`\n    # numbers.\n    for index in range(remainingK):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] * multiplier % MOD,\n          sortedIndexedNums[index][1])\n\n    for num, i in sortedIndexedNums:\n      ans[i] = num\n\n    return ans",
      "title": "3266. Final Array State After K Multiplication Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10fd7f96-6437-4abc-acea-e3ac20e98ce9",
      "code": "class Solution:\n  # Similar to 3265. Count Almost Equal Pairs I\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 or 2 swaps.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    # Add all numbers after 1 swap.\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    # Add all numbers after 2 swaps.\n    for (i1, j1), (i2, j2) in itertools.combinations(\n            itertools.combinations(range(n), 2), 2):\n      newDigits = digits[:]\n      newDigits[i1], newDigits[j1] = newDigits[j1], newDigits[i1]\n      newDigits[i2], newDigits[j2] = newDigits[j2], newDigits[i2]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3267. Count Almost Equal Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6df2ddd6-4711-41b4-9b51-2298fa576e87",
      "code": "class Solution:\n  def minLargest(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    # dp[i][j] := the minimum largest number for the first i nums1 and the\n    # first j nums2\n    dp = [[math.inf] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n\n    def f(prev: int, num: int) -> int:\n      \"\"\"\n      Returns the next number to fill in the array based on the previous number\n      and the current number.\n      \"\"\"\n      return prev + (2 if prev % 2 == num else 1)\n\n    for i in range(m + 1):\n      for j in range(n + 1):\n        if i > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]))\n        if j > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]))\n\n    return dp[m][n]",
      "title": "3269. Constructing Two Increasing Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83f7ef21-8a96-4205-ba32-16abe95fb02c",
      "code": "class Solution:\n  def generateKey(self, num1: int, num2: int, num3: int) -> int:\n    return int(''.join(min(a, b, c)\n                       for a, b, c in zip(str(num1).zfill(4),\n                                          str(num2).zfill(4),\n                                          str(num3).zfill(4))))",
      "title": "3270. Find the Key of the Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "990da122-106e-4fc0-975e-99503a2fc694",
      "code": "class Solution:\n  def stringHash(self, s: str, k: int) -> str:\n    ans = []\n\n    for i in range(0, len(s), k):\n      sumHash = sum(string.ascii_lowercase.index(s[j])\n                    for j in range(i, i + k))\n      ans.append(string.ascii_lowercase[sumHash % 26])\n\n    return ''.join(ans)",
      "title": "3271. Hash Divided String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce57d3e-e228-48e2-a1c9-84b7d68188d0",
      "code": "class Solution:\n  def countGoodIntegers(self, n: int, k: int) -> int:\n    halfLength = (n + 1) // 2\n    minHalf = 10**(halfLength - 1)\n    maxHalf = 10**halfLength\n    ans = 0\n    seen = set()\n\n    for num in range(minHalf, maxHalf):\n      palindrome = str(num) + str(num)[::-1][n % 2:]\n      sortedDigits = ''.join(sorted(palindrome))\n      if int(palindrome) % k != 0 or sortedDigits in seen:\n        continue\n      seen.add(sortedDigits)\n      digitCount = collections.Counter(palindrome)\n      # Leading zeros are not allowed, so the first digit is special.\n      firstDigitChoices = n - digitCount['0']\n      permutations = firstDigitChoices * math.factorial(n - 1)\n      # For each repeated digit, divide by the factorial of the frequency since\n      # permutations that swap identical digits don't create a new number.\n      for freq in digitCount.values():\n        permutations //= math.factorial(freq)\n      ans += permutations\n\n    return ans",
      "title": "3272. Find the Count of Good Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40553741-c851-48ed-b73a-03ffb2a0b964",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Enemy:\n  damage: int\n  timeTakenDown: int\n\n\nclass Solution:\n  def minDamage(self, power: int, damage: list[int], health: list[int]) -> int:\n    ans = 0\n    sumDamage = sum(damage)\n    enemies = [Enemy(d, (h + power - 1) // power)\n               for d, h in zip(damage, health)]\n\n    # It's better to take down the enemy i first if the damage dealt of taking\n    # down i first is less than the damage dealt of taking down j first. So,\n    #    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <\n    #    damage[j] * t[j] + (t[i] + t[j]) * damage[i]\n    # => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <\n    #    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]\n    # => damage[j] * t[i] < damage[i] * t[j]\n    # => damage[j] / t[j] < damage[i] / t[i]\n    enemies.sort(key=lambda x: -x.damage / x.timeTakenDown)\n\n    for enemy in enemies:\n      ans += sumDamage * enemy.timeTakenDown\n      sumDamage -= enemy.damage\n\n    return ans",
      "title": "3273. Minimum Amount of Damage Dealt to Bob",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e79412d5-fb8e-4462-a6ff-be59986aa73b",
      "code": "class Solution:\n  def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n    # Same as 1812. Determine Color of a Chessboard Square\n    def squareIsWhite(coordinate: str) -> bool:\n      letter, digit = coordinate\n      return ord(letter) % 2 != int(digit) % 2\n\n    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2)",
      "title": "3274. Check if Two Chessboard Squares Have the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caf0f152-8aab-4382-9b43-ef8605146897",
      "code": "class Solution:\n  def resultsArray(self, queries: list[list[int]], k: int) -> list[int]:\n    ans = []\n    maxHeap = []\n\n    for x, y in queries:\n      heapq.heappush(maxHeap, -(abs(x) + abs(y)))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n      ans.append(-maxHeap[0] if len(maxHeap) == k else -1)\n\n    return ans",
      "title": "3275. K-th Nearest Obstacle Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e0466ba-acf4-4158-8dbe-84c2a24d6257",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    numToIndices = collections.defaultdict(set)\n    for index, row in enumerate(grid):\n      for num in row:\n        numToIndices[num].add(index)\n    numToIndices = list(numToIndices.items())\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score by selecting numbers from numToIndices[i..],\n      where `mask` is the bitmask of the used row indices.\n      \"\"\"\n      if i == len(numToIndices):\n        return 0\n      # Skip numToIndices[i][0].\n      res = dp(i + 1, mask)\n      for index in numToIndices[i][1]:\n        if (mask >> index & 1) == 0:\n          # Take numToIndices[i][0].\n          res = max(res, numToIndices[i][0] + dp(i + 1, mask | 1 << index))\n      return res\n\n    return dp(0, 0)",
      "title": "3276. Select Cells in Grid With Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "101fb735-94d6-41ee-9d08-98b0399c3316",
      "code": "class Solution:\n  def maximumSubarrayXor(\n      self,\n      nums: list[int],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(nums)\n    # xors[i][j] := the XOR score of nums[i..j]\n    xors = [[0] * n for _ in range(n)]\n    # dp[i][j] := the maximum XOR score of nums[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, num in enumerate(nums):\n      xors[i][i] = num\n      dp[i][i] = num\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j]\n        dp[i][j] = max(xors[i][j], dp[i][j - 1], dp[i + 1][j])\n\n    return [dp[l][r] for l, r in queries]",
      "title": "3277. Maximum XOR Score Subarray Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5ce86d1-9d86-4449-a29e-3dd42ed555c5",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxArea(self, height: int, positions: list[int], directions: str) -> int:\n    area = sum(positions)\n    ans = area\n    diffPerSecond = 0\n    timeToIndices: SortedDict[int, list[int]] = SortedDict()\n\n    for i, (position, direction) in enumerate(zip(positions, directions)):\n      if direction == 'U':\n        timeToIndices.setdefault(height - position, []).append(i)\n        timeToIndices.setdefault(height - position + height, []).append(i)\n        diffPerSecond += 1\n      else:\n        timeToIndices.setdefault(position, []).append(i)\n        timeToIndices.setdefault(position + height, []).append(i)\n        diffPerSecond -= 1\n\n    prevTime = 0\n    directionsList = list(directions)\n\n    for time, indices in timeToIndices.items():\n      area += (time - prevTime) * diffPerSecond\n      ans = max(ans, area)\n      prevTime = time\n      for i in indices:\n        if directionsList[i] == 'U':\n          directionsList[i] = 'D'\n          diffPerSecond -= 2\n        else:\n          directionsList[i] = 'U'\n          diffPerSecond += 2\n\n    return ans",
      "title": "3279. Maximum Total Area Occupied by Pistons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b7856e1-cd41-4752-bc25-8415c44902f4",
      "code": "class Solution:\n  def convertDateToBinary(self, date: str) -> str:\n    year, month, day = map(int, date.split('-'))\n\n    def toBinary(value: int) -> str:\n      \"\"\"Converts an integer to binary without leading zeros.\"\"\"\n      return bin(value)[2:]\n\n    return '-'.join([toBinary(year), toBinary(month), toBinary(day)])",
      "title": "3280. Convert Date to Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a501f7d4-a43c-4e34-907e-c6c733170a2c",
      "code": "class Solution:\n  def maxPossibleScore(self, start: list[int], d: int) -> int:\n    def isPossible(m: int) -> bool:\n      lastPick = start[0]\n      for i in range(1, len(start)):\n        if lastPick + m > start[i] + d:\n          return False\n        lastPick = max(lastPick + m, start[i])\n      return True\n\n    start.sort()\n\n    maxScore = (start[-1] + d) - start[0] + 1\n    l = bisect.bisect_left(range(maxScore), True,\n                           key=lambda m: not isPossible(m))\n    return l - 1",
      "title": "3281. Maximize Score of Numbers in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8c105a-80d2-4597-8e36-a1aacbc56478",
      "code": "class Solution:\n  # Similar to 3205. Maximum Array Hopping Score I\n  def findMaximumScore(self, nums: list[int]) -> int:\n    return sum(itertools.accumulate(nums[:-1], max))",
      "title": "3282. Reach End of Array With Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "586526a0-3deb-4a7c-b8ff-1df96e8cfb72",
      "code": "class Solution:\n  def __init__(self):\n    self.SIZE = 50\n    self.MAX = 1_000_000\n    self.DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n                 (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n\n  def maxMoves(self, kx: int, ky: int, positions: list[list[int]]) -> int:\n    n = len(positions)\n    positions.append([kx, ky])\n    hashedPositionToIndex = {}\n    # dist[i][j] := the minimum distance from positions[i] to positions[j]\n    dist = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i, (x, y) in enumerate(positions):\n      hashedPositionToIndex[self._hash(x, y)] = i\n\n    for sourceIndex in range(n + 1):\n      self._bfs(positions, sourceIndex, hashedPositionToIndex, dist)\n\n    MAX_MASK = 1 << (n + 1)\n    # dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to\n    # kill all pawns, where i is the current pawn, mask is the set of pawns\n    # that have been killed, and turn is the current player's turn (0 for Alice\n    # and 1 for Bob)\n    dp = [[[0, 0]\n          for _ in range(1 << (n + 1))]\n          for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      for mask in range(MAX_MASK - 1):\n        dp[i][mask] = [-self.MAX, self.MAX]\n\n    for mask in range(MAX_MASK - 2, -1, -1):\n      for i in range(n + 1):\n        for turn in range(2):\n          for j in range(n):\n            if mask >> j & 1:\n              continue\n            moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn]\n            dp[i][mask][turn] = (max(dp[i][mask][turn], moves) if turn == 0 else\n                                 min(dp[i][mask][turn], moves))\n\n    # Returns the maximum cost to kill all pawns, i.e., the original positions\n    # array without the knight (kx, ky).\n    return dp[n][1 << n][0]\n\n  def _hash(self, x: int, y: int) -> int:\n    return x * self.SIZE + y\n\n  def _bfs(\n      self,\n      positions: list[list[int]],\n      sourceIndex: int,\n      hashedPositionToIndex: dict[int, int],\n      dist: list[list[int]]\n  ) -> None:\n    \"\"\"\n    Computes the distance between positions[sourceIndex] and other positions.\n    \"\"\"\n    sx, sy = positions[sourceIndex]\n    q = collections.deque([(sx, sy)])\n    seen = {(sx, sy)}\n    seenPositions = 0\n\n    step = 0\n    while q and seenPositions < len(positions):\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        hashedPosition = self._hash(i, j)\n        if hashedPosition in hashedPositionToIndex:\n          dist[sourceIndex][hashedPositionToIndex[hashedPosition]] = step\n          seenPositions += 1\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x >= self.SIZE or y < 0 or y >= self.SIZE:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1",
      "title": "3283. Maximum Number of Moves to Kill All Pawns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcc8d6c2-2f56-483a-a10c-f865a70a868d",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    def getSum(diff: int) -> int:\n      \"\"\"Returns the sum of all subarrays with a difference of `diff`.\"\"\"\n      res = nums[0]\n      summ = nums[0]\n      count = 1\n      for prev, num in itertools.pairwise(nums):\n        if num == prev + diff:\n          count += 1\n          summ += count * num\n        else:\n          count = 1\n          summ = num\n        res += summ\n      return res\n\n    return (getSum(1) + getSum(-1) - sum(nums)) % 1_000_000_007",
      "title": "3284. Sum of Consecutive Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "311bca1e-f5e8-40c8-9293-b9ca4f280849",
      "code": "class Solution:\n  def stableMountains(self, height: list[int], threshold: int) -> list[int]:\n    return [i for i in range(1, len(height))\n            if height[i - 1] > threshold]",
      "title": "3285. Find Indices of Stable Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "670dddbd-3516-4582-ae40-3d8413ec8a77",
      "code": "class Solution:\n  def findSafeWalk(self, grid: list[list[int]], health: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    initialHealth = health - grid[0][0]\n    q = collections.deque([(0, 0, initialHealth)])\n    seen = {(0, 0, initialHealth)}\n\n    while q:\n      for _ in range(len(q)):\n        i, j, h = q.popleft()\n        if i == m - 1 and j == n - 1 and h > 0:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          nextHealth = h - grid[x][y]\n          if nextHealth <= 0 or (x, y, nextHealth) in seen:\n            continue\n          q.append((x, y, nextHealth))\n          seen.add((x, y, nextHealth))\n\n    return False",
      "title": "3286. Find a Safe Walk Through a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d9f26ba-4d7d-42a0-a0e7-a563cfcce39d",
      "code": "class Solution:\n  def maxValue(self, nums: list[int], k: int) -> int:\n    left = self._getPossibleORs(nums, k)\n    right = self._getPossibleORs(nums[::-1], k)[::-1]\n    return max(a ^ b\n               for i in range(k - 1, len(nums) - k)\n               for a in range(128 + 1)\n               for b in range(128 + 1)\n               if left[i][k][a] and right[i + 1][k][b])\n\n  def _getPossibleORs(self, nums: list[int], k: int) -> list[list[list[bool]]]:\n    dp = [[[False] * (128 + 1)\n          for _ in range(k + 1)]\n          for _ in range(len(nums))]\n\n    dp[0][1][nums[0]] = True\n\n    for i in range(len(nums)):\n      dp[i][0][0] = True\n\n    for i in range(1, len(nums)):\n      for j in range(1, k + 1):\n        for x in range(128 + 1):\n          if dp[i - 1][j][x]:\n            dp[i][j][x] = True\n          if dp[i - 1][j - 1][x]:\n            dp[i][j][nums[i] | x] = True\n\n    return dp",
      "title": "3287. Find the Maximum Sequence Value of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "962c25c9-3e06-4e7e-8999-02154b3bad4d",
      "code": "class Solution:\n  def maxPathLength(self, coordinates: list[list[int]], k: int) -> int:\n    xk, yk = coordinates[k]\n    leftCoordinates = [(x, y) for x, y in coordinates if x < xk and y < yk]\n    rightCoordinates = [(x, y) for x, y in coordinates if x > xk and y > yk]\n    return (1 +\n            self._lengthOfLIS(leftCoordinates) +\n            self._lengthOfLIS(rightCoordinates))\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, coordinates: list[tuple[int, int]]) -> int:\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    # tail[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tail = []\n    for _, y in coordinates:\n      if not tail or y > tail[-1]:\n        tail.append(y)\n      else:\n        tail[bisect.bisect_left(tail, y)] = y\n    return len(tail)",
      "title": "3288. Length of the Longest Increasing Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57a14c3b-efbb-4f9d-be74-0cd0ef642ab0",
      "code": "class Solution:\n  def getSneakyNumbers(self, nums: list[int]) -> list[int]:\n    return [num for num, freq in collections.Counter(nums).items()\n            if freq == 2]",
      "title": "3289. The Two Sneaky Numbers of Digitville",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d77397d-aede-476f-b560-34be34f33909",
      "code": "class Solution:\n  def maxScore(self, a: list[int], b: list[int]) -> int:\n    n = len(b)\n    # dp[i][j] := the maximum score by selecting 4 - i numbers from b[j..n - 1]\n    # using the corresponding numbers from a[i..3]\n    dp = [[0] * (n + 1) for _ in range(5)]\n\n    # Run out of numbers in b but still need to select numbers from a.\n    for i in range(4):\n      dp[i][n] = -math.inf\n\n    for i in reversed(range(4)):\n      for j in reversed(range(n)):\n        # Skip b[j] or pair a[i] with b[j].\n        dp[i][j] = max(dp[i][j + 1], a[i] * b[j] + dp[i + 1][j + 1])\n\n    return -1 if dp[0][0] == -math.inf else dp[0][0]",
      "title": "3290. Maximum Multiplication Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6bf6325-9f54-405b-ba48-35b657fffe1f",
      "code": "class Solution:\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3291. Minimum Number of Valid Strings to Form Target I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57333200-ef29-48d3-a30d-e161e837fcd6",
      "code": "class Solution:\n  # 3291. Minimum Number of Valid Strings to Form Target I\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3292. Minimum Number of Valid Strings to Form Target II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17228ce0-0f64-4ebc-878f-5ae4f39d4615",
      "code": "class Solution:\n  def toArray(self, node: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = node\n\n    while curr.prev:\n      curr = curr.prev\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3294. Convert Doubly Linked List to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e68b664-d884-4b81-b06b-2ad975509ed1",
      "code": "class Solution:\n  def reportSpam(self, message: list[str], bannedWords: list[str]) -> bool:\n    bannedWordsSet = set(bannedWords)\n    return sum(word in bannedWordsSet for word in message) > 1",
      "title": "3295. Report Spam Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5da0d434-a107-46be-acbe-1b5ee23ad2a2",
      "code": "class Solution:\n  def minNumberOfSeconds(\n      self,\n      mountainHeight: int,\n      workerTimes: list[int]\n  ) -> int:\n    def getReducedHeight(m: int) -> int:\n      \"\"\"Returns the total height reduced by all workers in `m` seconds.\"\"\"\n      # The height `x` that a worker with working time `w` reduces in `m`\n      # seconds.\n      # w * (1 + 2 + ... + x) <= m\n      #       (1 + x) * x / 2 <= m / w\n      #   x^2 + x - 2 * m / w <= 0\n      #                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2\n      return sum((-1 + math.sqrt(1 + 8 * m // workerTime)) // 2\n                 for workerTime in workerTimes)\n\n    l = 1\n    r = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    return bisect.bisect_left(range(l, r), mountainHeight,\n                              key=getReducedHeight) + l",
      "title": "3296. Minimum Number of Seconds to Make Mountain Height Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aeb526e-e53b-4c2f-9f11-b0544dada392",
      "code": "class Solution:\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3297. Count Substrings That Can Be Rearranged to Contain a String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54db6532-1a0f-4611-afbd-f59f06ed63be",
      "code": "class Solution:\n  # Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3298. Count Substrings That Can Be Rearranged to Contain a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ede7a230-f676-44ee-9583-45e969111b63",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getSequenceSum(nums: list[int], direction: int) -> int:\n      \"\"\"\n      Returns the sum of all sequences in the array that are in consecutive\n      increasing order if `direction` is 1, or in consecutive decreasing order\n      if `direction` is -1.\"\"\"\n      sequenceSum = 0\n      # {num: the number of subsequences ending in `num` so far}\n      prefixCount = collections.Counter()\n      # {num: the number of subsequences starting from `num` so far}\n      suffixCount = collections.Counter()\n      # prefixSubseqs[i] := the number of subsequences ending in nums[i]\n      prefixSubseqs = [0] * n\n      # suffixSubseqs[i] := the number of subsequences starting from nums[i]\n      suffixSubseqs = [0] * n\n\n      for i, num in enumerate(nums):\n        prevNum = num - direction\n        freq = prefixCount[prevNum] + 1\n        prefixSubseqs[i] = freq\n        prefixCount[num] += freq\n        prefixCount[num] %= MOD\n\n      for i, num in reversed(list(enumerate(nums))):\n        nextNum = num + direction\n        freq = suffixCount[nextNum] + 1\n        suffixSubseqs[i] = freq\n        suffixCount[num] += freq\n        suffixCount[num] %= MOD\n\n      for num, prefixSubseq, suffixSubseq in zip(\n              nums, prefixSubseqs, suffixSubseqs):\n        sequenceSum += num * prefixSubseq * suffixSubseq\n        sequenceSum %= MOD\n\n      return sequenceSum\n\n    increasingSequenceSum = getSequenceSum(nums, 1)\n    decreasingSequenceSum = getSequenceSum(nums, -1)\n    return (increasingSequenceSum + decreasingSequenceSum - sum(nums) + MOD) % MOD",
      "title": "3299. Sum of Consecutive Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0e318ef-828f-4fbf-911c-e35a27bb8273",
      "code": "class Solution:\n  def minElement(self, nums: list[int]) -> int:\n    return min(sum(map(int, str(num))) for num in nums)",
      "title": "3300. Minimum Element After Replacement With Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "479252af-c917-4f95-a121-e5d716d9faea",
      "code": "class Solution:\n  def maximumTotalSum(self, maximumHeight: list[int]) -> int:\n    ans = 0\n    mn = math.inf\n\n    for height in sorted(maximumHeight, reverse=True):\n      assigned = min(height, mn - 1)\n      if assigned == 0:\n        return -1\n      ans += assigned\n      mn = assigned\n\n    return ans",
      "title": "3301. Maximize the Total Height of Unique Towers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7632139-2723-4a70-aad9-6f5617b05470",
      "code": "class Solution:\n  def validSequence(self, word1: str, word2: str) -> list[int]:\n    ans = []\n    # last[j] := the index i of the last occurrence in word1, where\n    # word1[i] == word2[j]\n    last = [-1] * len(word2)\n\n    i = len(word1) - 1\n    j = len(word2) - 1\n    while i >= 0 and j >= 0:\n      if word1[i] == word2[j]:\n        last[j] = i\n        j -= 1\n      i -= 1\n\n    canSkip = True\n    j = 0\n    for i, c in enumerate(word1):\n      if j == len(word2):\n        break\n      if c == word2[j]:\n        ans.append(i)\n        j += 1\n      elif canSkip and (j == len(word2) - 1 or i < last[j + 1]):\n        canSkip = False\n        ans.append(i)\n        j += 1\n\n    return ans if j == len(word2) else []",
      "title": "3302. Find the Lexicographically Smallest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61fdbf54-469f-468a-985e-391b2ca37e19",
      "code": "class Solution:\n  def minStartingIndex(self, s: str, pattern: str) -> int:\n    z1 = self._zFunction(pattern + s)\n    z2 = self._zFunction(pattern[::-1] + s[::-1])\n\n    # Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and\n    # the suffix.\n    for i in range(len(s) - len(pattern) + 1):\n      if z1[len(pattern) + i] + z2[len(s) - i] >= len(pattern) - 1:\n        return i\n\n    return -1\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3303. Find the Occurrence of First Almost Equal Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf720b28-aeff-4767-b519-3a5211a5a781",
      "code": "class Solution:\n  def kthCharacter(self, k: int) -> str:\n    return string.ascii_lowercase[(k - 1).bit_count()]",
      "title": "3304. Find the K-th Character in String Game I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04cd6436-4c93-4ea2-bb8e-701e84895c7e",
      "code": "class Solution:\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k == -1:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3305. Count of Substrings Containing Every Vowel and K Consonants I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7c200bf-9d16-4c65-9b52-75c27a9c55d8",
      "code": "class Solution:\n  # Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k < 0:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3306. Count of Substrings Containing Every Vowel and K Consonants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cf59efb-cbd0-4061-9584-7e84aeaf94a5",
      "code": "class Solution:\n  def kthCharacter(self, k: int, operations: list[int]) -> str:\n    operationsCount = math.ceil(math.log2(k))\n    increases = 0\n\n    for i in range(operationsCount - 1, -1, -1):\n      halfSize = 2**i\n      if k > halfSize:\n        k -= halfSize  # Move k from the right half to the left half.\n        increases += operations[i]\n\n    return string.ascii_lowercase[increases % 26]",
      "title": "3307. Find the K-th Character in String Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e893201a-ee82-48e0-a0d0-2f8c733ab684",
      "code": "class Solution:\n  def maxGoodNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    def concat(a: int, b: int) -> int:\n      \"\"\"Returns the concatenation of the binary representations of a and b.\"\"\"\n      return (a << b.bit_length()) + b\n\n    nums.sort(key=functools.cmp_to_key(\n        lambda a, b: concat(b, a) - concat(a, b)))\n\n    for num in nums:\n      ans = concat(ans, num)\n\n    return ans",
      "title": "3309. Maximum Possible Number by Binary Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38f75a94-c826-402e-832f-10b71a4f17a5",
      "code": "class Solution:\n  def remainingMethods(\n      self,\n      n: int,\n      k: int,\n      invocations: list[list[int]]\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(n)]\n\n    for u, v in invocations:\n      graph[u].append(v)\n\n    q = collections.deque([k])\n    seen = {k}\n\n    while q:\n      for _ in range(len(q)):\n        for v in graph[q.popleft()]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for u in range(n):\n      if u in seen:\n        continue\n      for v in graph[u]:\n        if v in seen:\n          return list(range(n))\n      ans.append(u)\n\n    return ans",
      "title": "3310. Remove Methods From Project",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "937e2477-8830-40a1-96e5-e0e6a1f86642",
      "code": "class Solution:\n  def constructGridLayout(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Randomly choose a node with the minimum degree as the corner.\n    corner = min(range(len(graph)), key=lambda x: len(graph[x]))\n\n    seen = {corner}\n    firstRow = self._getFirstRow(graph, corner, seen)\n    cols = len(firstRow)\n    rows = n // cols\n\n    ans = [[0] * cols for _ in range(rows)]\n    ans[0] = firstRow\n\n    for i in range(1, rows):\n      for j in range(cols):\n        for v in graph[ans[i - 1][j]]:\n          if v not in seen:\n            ans[i][j] = v\n            seen.add(v)\n            break\n\n    return ans\n\n  def _getFirstRow(\n      self,\n      graph: list[list[int]],\n      corner: int,\n      seen: set[int]\n  ) -> list[int]:\n    cornerDegree = len(graph[corner])\n    row = [corner]\n    # Continue appending neighbors until we hit another corner.\n    while len(row) == 1 or len(graph[row[-1]]) == cornerDegree + 1:\n      # Sort neighbors by degree to prioritize smaller ones (shortest row built first).\n      graph[row[-1]].sort(key=lambda x: len(graph[x]))\n      for v in graph[row[-1]]:\n        if v not in seen and len(graph[v]) in (cornerDegree, cornerDegree + 1):\n          row.append(v)\n          seen.add(v)\n          break\n    return row",
      "title": "3311. Construct 2D Grid Matching Graph Layout",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4699adfd-84ba-4c80-8f2d-d67fdefe229f",
      "code": "class Solution:\n  def gcdValues(self, nums: list[int], queries: list[int]) -> list[int]:\n    maxNum = max(nums)\n    # countDivisor[d] := the number of `nums` having `num % d == 0`\n    countDivisor = [0] * (maxNum + 1)\n    # countGcdPair[g] := the number of pairs having gcd == g\n    countGcdPair = [0] * (maxNum + 1)\n\n    for num in nums:\n      for i in range(1, math.isqrt(num) + 1):\n        if num % i == 0:\n          countDivisor[i] += 1\n          if i != num // i:\n            countDivisor[num // i] += 1\n\n    for gcd in range(maxNum, 0, -1):\n      # There are C(countDivisor[gcd], 2) pairs that have a common divisor\n      # that's a multiple of `gcd` (including the one that equals to `gcd`).\n      # So, substract the multiples of `gcd` to have the number of pairs with a\n      # gcd that's exactly `gcd`.\n      countGcdPair[gcd] = countDivisor[gcd] * (countDivisor[gcd] - 1) // 2\n      for largerGcd in range(2 * gcd, maxNum + 1, gcd):\n        countGcdPair[gcd] -= countGcdPair[largerGcd]\n\n    # prefixCountGcdPair[g] := the number of pairs having gcd <= g\n    prefixCountGcdPair = list(itertools.accumulate(countGcdPair))\n    return [bisect.bisect_left(prefixCountGcdPair, query + 1)\n            for query in queries]",
      "title": "3312. Sorted GCD Pair Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "422e54ec-fd70-4933-b9dc-d1141e4c959e",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time it got marked\n\n\nclass Last2:\n  def __init__(self, last1: Node = Node(), last2: Node = Node()):\n    self.last1 = last1  # the last marked node\n    self.last2 = last2  # the second last marked node\n\n\nclass Solution:\n  # Similar to 3241. Time Taken to Mark All Nodes\n  def lastMarkedNodes(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the last marked two nodes for subtree rooted at node i, where\n    # each node contains the time it got marked\n    dp = [Last2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, Node(), dp, ans)\n    return ans\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Last2]\n  ) -> Node:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the last two marked\n    nodes, and returns the last marked node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    last1 = Node(u, 0)\n    last2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      child = self._dfs(tree, v, u, dp)\n      time = child.time + 1\n      if time > last1.time:\n        last2 = last1\n        last1 = Node(child.node, time)\n      elif time > last2.time:\n        last2 = Node(child.node, time)\n    dp[u] = Last2(last1, last2)\n    return last1\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      last: Node,\n      dp: list[list[int]],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `last`\n    is the last marked node that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = last.node if last.time > dp[u].last1.time else dp[u].last1.node\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newLast = Node(last.node, last.time + 1)\n      if dp[u].last1.node == dp[v].last1.node:\n        alternativeTime = 1 + dp[u].last2.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last2.node, alternativeTime)\n      else:\n        alternativeTime = 1 + dp[u].last1.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last1.node, alternativeTime)\n      self._reroot(tree, v, u, newLast, dp, ans)",
      "title": "3313. Find the Last Marked Nodes in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43868f8e-9cf6-4e51-b069-613d0957322d",
      "code": "class Solution:\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3314. Construct the Minimum Bitwise Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1e2bc48-bb22-4070-afaa-f37c0fc7286f",
      "code": "class Solution:\n  # Same as 3314. Construct the Minimum Bitwise Array I\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3315. Construct the Minimum Bitwise Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "975adbf4-3bf2-48dc-a19f-24abb4c93dd6",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9dbbb68-783d-4195-bf55-7c72ccbf4320",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e9b00fc-b0e2-45a6-9af2-67414d04ebd9",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int, y: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    @functools.lru_cache(None)\n    def stirling(n: int, k: int) -> int:\n      \"\"\"\n      Returns the number of ways to partition a set of n objects into k\n      non-empty subsets.\n\n      https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n      \"\"\"\n      if k == 0 or n < k:\n        return 0\n      if k == 1 or n == k:\n        return 1\n      return (k * stirling(n - 1, k) + stirling(n - 1, k - 1)) % MOD\n\n    # 1. Choose `k` stages from `x` stages.\n    # 2. Partition `n` performers into `k` stages.\n    # 3. Permute `k` stages.\n    # 4. Score `k` stages with score in the range [1, y], so y^k ways.\n    return sum(nCk(x, k) * stirling(n, k) * fact(k) * pow(y, k, MOD) % MOD\n               for k in range(1, min(n, x) + 1)) % MOD",
      "title": "3317. Find the Number of Possible Ways for an Event",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae35d1ca-be45-4d00-b87a-00fce3144ded",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()\n    bot = SortedList()\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up old values.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom element to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        windowSum -= t * countT\n        top.add([countB, b])\n        windowSum += b * countB\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3318. Find X-Sum of All K-Long Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2002d4d-d2d6-4cfb-b38a-b60f2762531f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  isPerfect: bool\n  sz: int\n\n\nclass Solution:\n  def kthLargestPerfectSubtree(self, root: TreeNode | None, k: int) -> int:\n    ans = []\n    self._dfs(root, ans)\n    if len(ans) < k:\n      return -1\n    return sorted(ans, reverse=True)[k - 1]\n\n  def _dfs(self, root: TreeNode, ans: list[int]) -> T:\n    if not root:\n      return T(True, 0)\n    l = self._dfs(root.left, ans)\n    r = self._dfs(root.right, ans)\n    if l.isPerfect and r.isPerfect and l.sz == r.sz:\n      sz = 1 + l.sz + r.sz\n      ans.append(sz)\n      return T(True, sz)\n    return T(False, 0)",
      "title": "3319. K-th Largest Perfect Subtree Size in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14334eaa-c1a0-417c-8472-441dcc605d18",
      "code": "class Solution:\n  def countWinningSequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int, bob: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences Bob can use to beat Alice for\n      s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the\n      number of points that Bob is having is `bob`.\n      \"\"\"\n      if i == len(s):\n        return int(bob > 0)\n\n      f = 0  # If Bob summons a Fire Dragon at i.\n      w = 0  # If Bob summons a Water Serpent at i.\n      e = 0  # If Bob summons a Earth Golem at i.\n\n      match s[i]:\n        case 'F':\n          if prev != 0:\n            f = dp(i + 1, 0, bob) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob + 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob - 1) % MOD\n        case 'W':\n          if prev != 0:\n            f = dp(i + 1, 0, bob - 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob + 1) % MOD\n        case 'E':\n          if prev != 0:\n            f = dp(i + 1, 0, bob + 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob - 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob) % MOD\n\n      return f + w + e\n\n    return (dp(0, 0, 0) + dp(0, 1, 0) + dp(0, 2, 0)) // 2 % MOD",
      "title": "3320. Count The Number of Winning Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "070b7844-98d6-40f1-b271-8ca3ab20d1c9",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  # Same as 3318. Find X-Sum of All K-Long Subarrays I\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()  # the top x elements\n    bot = SortedList()  # the rest of the elements\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up the old count.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom elements to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        top.add([countB, b])\n        windowSum += b * countB\n        windowSum -= t * countT\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3321. Find X-Sum of All K-Long Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe8bacb-4921-4d99-b4fb-e50aeafd94f3",
      "code": "class Solution:\n  def minConnectedGroups(self, intervals: list[list[int]], k: int) -> int:\n    mergedIntervals = 0\n    maxMergedIntervals = 0\n\n    intervals = self._merge(intervals)\n\n    i = 0\n    for _, end in intervals:\n      while i < len(intervals) and end + k >= intervals[i][0]:\n        mergedIntervals += 1\n        i += 1\n      mergedIntervals -= 1  # Exclude intervals[i].\n      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals)\n\n    return len(intervals) - maxMergedIntervals\n\n  # Same as 56. Merge Intervals\n  def _merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    res = []\n    for interval in sorted(intervals):\n      if not res or res[-1][1] < interval[0]:\n        res.append(interval)\n      else:\n        res[-1][1] = max(res[-1][1], interval[1])\n    return res",
      "title": "3323. Minimize Connected Groups by Inserting Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6fdbe63-7347-4ce3-ae9e-d983cda26610",
      "code": "class Solution:\n  def stringSequence(self, target: str) -> list[str]:\n    ans = []\n    s = []\n\n    for targetChar in target:\n      s.append('a')\n      ans.append(''.join(s))\n      for offset in range(ord('b'), ord(targetChar) + 1):\n        s[-1] = chr(offset)\n        ans.append(''.join(s))\n\n    return ans",
      "title": "3324. Find the Sequence of Strings Appeared on the Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "024c7a1c-eaac-442a-9504-2d8f486191e0",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3325. Count Substrings With K-Frequency Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d2bad5-8e73-44c6-a59c-cfc44e3c617a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > nums[i + 1]:\n        minDivisor = self._getMinDivisor(nums[i])\n        if minDivisor > nums[i + 1]:\n          return -1\n        nums[i] = minDivisor\n        ans += 1\n\n    return ans\n\n  def _getMinDivisor(self, num: int) -> int:\n    for divisor in range(2, math.isqrt(num) + 1):\n      if num % divisor == 0:\n        return divisor\n    return num",
      "title": "3326. Minimum Division Operations to Make Array Non Decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2491131f-50da-497f-a728-daee2a9a5a00",
      "code": "class Solution:\n  def findAnswer(self, parent: list[int], s: str) -> list[bool]:\n    n = len(parent)\n    tree = [[] for _ in parent]\n    start = [0] * n  # start[i] := the start index of `dfsStr` of node i\n    end = [0] * n  # end[i] := the end index of `dfsStr` of node i\n    dfsStr = []\n\n    for i in range(1, n):\n      tree[parent[i]].append(i)\n\n    self._dfs(tree, 0, 0, s, start, end, dfsStr)\n    t = '#'.join('@' + ''.join(dfsStr) + '$')\n    p = self._manacher(t)\n    return [self._isPalindrome(s, e, p)\n            for s, e in zip(start, end)]\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      index: int,\n      s: str,\n      start: list[int],\n      end: list[int],\n      dfsStr: list[str]\n  ) -> int:\n    \"\"\"Returns the start index of the \"DFS string\" of u's next node.\"\"\"\n    start[u] = index\n    for v in tree[u]:\n      index = self._dfs(tree, v, index, s, start, end, dfsStr)\n    end[u] = index\n    dfsStr.append(s[u])\n    return index + 1\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p\n\n  def _isPalindrome(self, s: int, e: int, p: list[int]) -> bool:\n    \"\"\"\n    Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed\n    array `p` from the Manacher's algorithm.\n\n    The precomputed array `p` is based on the string `t` with delimiters and\n    sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of\n    `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`\n    and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is\n    `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.\n    \"\"\"\n    length = e - s + 1\n    center = s + e + 2\n    return p[center] >= length",
      "title": "3327. Check if DFS Strings Are Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c6ed7a9-d823-47c5-b9b3-32bf4215c01c",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3329. Count Substrings With K-Frequency Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc2c2371-7a04-4bce-9590-f5e66e31d869",
      "code": "class Solution:\n  def possibleStringCount(self, word: str) -> int:\n    return 1 + sum(a == b\n                   for a, b in itertools.pairwise(word))",
      "title": "3330. Find the Original Typed String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e5f3fbe-2c2c-48ce-b115-b62655f9b535",
      "code": "class Solution:\n  def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:\n    n = len(parent)\n    ans = [0] * n\n    newParent = parent.copy()\n    tree = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      closest = self._findClosestAncestor(i, parent, s)\n      if closest != -1:\n        newParent[i] = closest\n\n    for i in range(1, n):\n      tree[newParent[i]].append(i)\n\n    self._dfs(tree, 0, ans)\n    return ans\n\n  def _findClosestAncestor(self, u: int, parent: list[int], s: str) -> int:\n    \"\"\"\n    Returns the closest ancestor of node `u` that has the same value as `u`.\n    \"\"\"\n    curr = parent[u]\n    while curr != -1:\n      if s[curr] == s[u]:\n        return curr\n      curr = parent[curr]\n    return -1\n\n  def _dfs(self, tree: list[list[int]], u: int, ans: list[int]) -> int:\n    sz = 1\n    for v in tree[u]:\n      sz += self._dfs(tree, v, ans)\n    ans[u] = sz\n    return sz",
      "title": "3331. Find Subtree Sizes After Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f4f1214-43ff-4454-8e96-956898c8b478",
      "code": "class Solution:\n  def maxScore(\n      self,\n      n: int,\n      k: int,\n      stayScore: list[list[int]],\n      travelScore: list[list[int]]\n  ) -> int:\n    # dp[i][j] := the maximum score after i days being at city j\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n      for dest in range(n):\n        # 1. Stay at the current city.\n        dp[i][dest] = dp[i - 1][dest] + stayScore[i - 1][dest]\n        # 2. Travel from any other city.\n        for curr in range(n):\n          if curr != dest:\n            dp[i][dest] = max(dp[i][dest],\n                              dp[i - 1][curr] + travelScore[curr][dest])\n\n    return max(dp[k])",
      "title": "3332. Maximum Points Tourist Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eec4e63-12f4-4a1f-a983-e7e84621729a",
      "code": "class Solution:\n  def possibleStringCount(self, word: str, k: int) -> int:\n    MOD = 1_000_000_007\n    groups = self._getConsecutiveLetters(word)\n    totalCombinations = functools.reduce(lambda subtotal, group:\n                                         subtotal * group % MOD, groups)\n    if k <= len(groups):\n      return totalCombinations\n\n    # dp[j] := the number of ways to form strings of length j using groups[0..i]\n    dp = [0] * k\n    dp[0] = 1  # Base case: empty string\n\n    for i, group in enumerate(groups):\n      newDp = [0] * k\n      windowSum = 0\n      for j in range(i, k):\n        newDp[j] = (newDp[j] + windowSum) % MOD\n        windowSum = (windowSum + dp[j]) % MOD\n        if j >= group:\n          windowSum = (windowSum - dp[j - group] + MOD) % MOD\n      dp = newDp\n\n    return (totalCombinations - sum(dp)) % MOD\n\n  def _getConsecutiveLetters(self, word: str) -> list[int]:\n    \"\"\"\n    Returns consecutive identical letters in the input string.\n    e.g. \"aabbbc\" -> [2, 3, 1].\n    \"\"\"\n    groups = []\n    group = 1\n    for i in range(1, len(word)):\n      if word[i] == word[i - 1]:\n        group += 1\n      else:\n        groups.append(group)\n        group = 1\n    groups.append(group)\n    return groups",
      "title": "3333. Find the Original Typed String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7693e83-9548-479e-8741-fb84baa69b2e",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixGcd[i] := GCD of nums[0..i]\n    # prefixLcm[i] := LCM of nums[0..i]\n    prefixGcd, prefixLcm = self._getPrefix(nums)\n    # suffixGcd[i] := GCD of nums[i..n - 1]\n    # suffixLcm[i] := LCM of nums[i..n - 1]\n    suffixGcd, suffixLcm = self._getSuffix(nums)\n    ans = suffixGcd[0] * suffixLcm[0]\n\n    for i in range(n):\n      gcd1 = prefixGcd[i - 1] if i > 0 else 0\n      gcd2 = suffixGcd[i + 1] if i + 1 < n else 0\n      lcm1 = prefixLcm[i - 1] if i > 0 else 1\n      lcm2 = suffixLcm[i + 1] if i + 1 < n else 1\n      score = math.gcd(gcd1, gcd2) * math.lcm(lcm1, lcm2)\n      ans = max(ans, score)\n\n    return ans\n\n  def _getPrefix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the prefix GCD and LCM arrays.\"\"\"\n    prefixGcd = []\n    prefixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in nums:\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      prefixGcd.append(currGcd)\n      prefixLcm.append(currLcm)\n    return prefixGcd, prefixLcm\n\n  def _getSuffix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the suffix GCD and LCM arrays.\"\"\"\n    suffixGcd = []\n    suffixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in reversed(nums):\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      suffixGcd.append(currGcd)\n      suffixLcm.append(currLcm)\n    return list(reversed(suffixGcd)), list(reversed(suffixLcm))",
      "title": "3334. Find the Maximum Factor Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c851c35d-2029-41e1-9c45-3d976cb93afa",
      "code": "class Solution:\n  def lengthAfterTransformations(self, s: str, t: int) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix()\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    # 'z' -> 'ab'\n    T[25][0] = 1\n    T[25][1] = 1\n    # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n    for i in range(25):\n      T[i][i + 1] = 1\n    return T",
      "title": "3335. Total Characters in String After Transformations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3cdeea4-f661-4916-94c3-86010c27ea2d",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxNum = max(nums)\n    # dp[i][x][y] := number of disjoint pairs `seq1` and `seq2` of\n    # nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y\n    dp = [[[0] * (maxNum + 1)\n          for _ in range(maxNum + 1)]\n          for _ in range(len(nums) + 1)]\n    dp[0][0][0] = 1\n\n    for i, num in enumerate(nums):\n      for x in range(maxNum + 1):\n        for y in range(maxNum + 1):\n          # 1. Skip nums[i].\n          dp[i + 1][x][y] += dp[i][x][y]\n          dp[i + 1][x][y] %= MOD\n          # 2. Pick nums[i] in the first subsequence.\n          newX = math.gcd(x, num)\n          dp[i + 1][newX][y] += dp[i][x][y]\n          dp[i + 1][newX][y] %= MOD\n          # 3. Pick nums[i] in the second subsequence.\n          newY = math.gcd(y, num)\n          dp[i + 1][x][newY] += dp[i][x][y]\n          dp[i + 1][x][newY] %= MOD\n\n    return sum(dp[-1][g][g]\n               for g in range(1, maxNum + 1)) % MOD",
      "title": "3336. Find the Number of Subsequences With Equal GCD",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ca4682-c906-4864-8960-64615d65f9de",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, x: int, y: int) -> int:\n      if i == len(nums):\n        return int(x > 0 and x == y)\n      # 1. Skip nums[i]\n      skip = dp(i + 1, x, y)\n      # 2. Pick nums[i] in the first subsequence\n      take1 = dp(i + 1, math.gcd(x, nums[i]), y)\n      # 3. Pick nums[i] in the second subsequence\n      take2 = dp(i + 1, x, math.gcd(y, nums[i]))\n      return (skip + take1 + take2) % MOD\n\n    return dp(0, 0, 0)",
      "title": "3336. Find the Number of Subsequences With Equal GCD_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85551cb3-547d-4113-a9e2-6eeb6395edc1",
      "code": "class Solution:\n  # Similar to 3335. Total Characters in String After Transformations I\n  def lengthAfterTransformations(self, s: str, t: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix(nums)\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self, nums: list[int]) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    for i, steps in enumerate(nums):\n      for step in range(1, steps + 1):\n        T[i][(i + step) % 26] += 1\n    return T",
      "title": "3337. Total Characters in String After Transformations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49b52fa8-bd70-4cd6-bb06-f9d1156950e4",
      "code": "class Solution:\n  def countOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 10**9 + 7\n    even = m // 2  # the number of even numbers in [1, m]\n    odd = m - even  # the number of odd numbers in [1, m]\n    # dp[i][j][0/1] := the number of arrays of length i with j consecutive even\n    # number pairs ending in an even number (0) or an odd number (1)\n    dp = [[[0] * 2\n          for _ in range(k + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: arrays of length 1\n    # For an array of length 1, we can't have any even number pairs yet.\n    dp[1][0][0] = even\n    dp[1][0][1] = odd\n\n    for i in range(2, n + 1):\n      for j in range(k + 1):\n        # 1. Appending an even number to an array ending in an even number\n        #    creates a new consecutive even number pair.\n        # 2. Appending an even number to an array ending in an odd number.\n        dp[i][j][0] = ((dp[i - 1][j - 1][0] if j > 0 else 0) * even +\n                       dp[i - 1][j][1] * even) % MOD\n        # 3. Appending an odd number to an array.\n        dp[i][j][1] = sum(dp[i - 1][j]) * odd % MOD\n\n    return sum(dp[n][k]) % MOD",
      "title": "3339. Find the Number of K-Even Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc158990-a58a-4b7e-bec0-bb607f8af269",
      "code": "class Solution:\n  def isBalanced(self, num: str) -> bool:\n    nums = list(map(int, num))\n    return sum(nums[::2]) == sum(nums[1::2])",
      "title": "3340. Check Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2279683c-68c1-4686-b9d8-ec79b14e9fe9",
      "code": "class Solution:\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0), (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3341. Find Minimum Time to Reach Last Room I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eadcc65b-0830-475b-a761-824ba0b28edd",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0),\n                          (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, (ux, uy))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + (i + j) % 2 + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3342. Find Minimum Time to Reach Last Room II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db024d00-02e5-47d7-ad7d-b22465a82257",
      "code": "class Solution:\n  def countBalancedPermutations(self, num: str) -> int:\n    nums = list(map(int, num))\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return 0\n\n    nums.sort(reverse=True)\n\n    @functools.lru_cache(None)\n    def dp(even: int, odd: int, evenBalance: int) -> int:\n      \"\"\"\n      Returns the number of permutations where there are `even` even indices\n      left, `odd` odd indices left, and `evenBalance` is the target sum of the\n      remaining numbers to be placed in even indices.\n      \"\"\"\n      if evenBalance < 0:\n        return 0\n      if even == 0:\n        return (evenBalance == 0) * math.factorial(odd)\n      if odd == 0:\n        return (sum(nums[-(even + odd):]) == evenBalance) * math.factorial(even)\n      return (dp(even - 1, odd, evenBalance - nums[-(odd + even)]) * even +\n              dp(even, odd - 1, evenBalance) * odd)\n\n    MOD = 1_000_000_007\n    perm = functools.reduce(lambda x, y: x * math.factorial(y),\n                            collections.Counter(nums).values(), 1)\n    return (dp(even=(len(nums) + 1) // 2,\n               odd=len(nums) // 2,\n               evenBalance=summ // 2) // perm) % MOD",
      "title": "3343. Count Number of Balanced Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93119b6a-79c7-4e49-8c52-10603d96b4a7",
      "code": "class Solution:\n  def maxSizedArray(self, s: int) -> int:\n    def getNumbersWithBitSet(n: int, i: int) -> int:\n      \"\"\"\n      Returns the number of integers in [0, n - 1] with the i-th bit set.\n\n      For the i-th bit, numbers in the range [0, n - 1] can be divided into\n      groups of 2^(i + 1) numbers. In each group, exactly half of the numbers\n      have the i-th bit set.\n      \"\"\"\n      groupSize = 1 << (i + 1)\n      halfGroupSize = 1 << i\n      fullGroups = n // groupSize\n      remaining = max(0, (n % groupSize) - halfGroupSize)\n      return fullGroups * halfGroupSize + remaining\n\n    def getArraySum(n: int) -> int:\n      \"\"\"\n      Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.\n\n        sum(i * (j OR k)), where 0 <= i, j, k < n\n      = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)\n      = (0 + 1 + ... + n - 1) * sum(j OR k)\n      = (n * (n - 1) / 2) * sum(j OR k)\n      \"\"\"\n      arithmeticSum = n * (n - 1) // 2  # 0 + 1 + ... + n - 1\n      orSum = 0  # the sum of (j OR k) values in 2D arrays of size n^2\n      for i in range(n.bit_length()):\n        numbersWithoutBit = n - getNumbersWithBitSet(n, i)\n        pairsWithBit = n**2 - numbersWithoutBit**2\n        orSum += pairsWithBit * (1 << i)  # Add contribution of this bit.\n      return arithmeticSum * orSum\n\n    if s == 0:\n      return 1\n    l = 0\n    r = 1196  # when s = 10^15, n = 1196\n    return bisect.bisect_right(range(l, r + 1), s, key=getArraySum) - 1 + l",
      "title": "3344. Maximum Sized Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2da3b650-14b4-45d7-82b4-1d49fcf1cc02",
      "code": "class Solution:\n  def smallestNumber(self, n: int, t: int) -> int:\n    return next(num for num in range(n, n + 10)\n                if self._getDigitProd(num) % t == 0)\n\n  def _getDigitProd(self, num: int) -> int:\n    digitProd = 1\n    while num > 0:\n      digitProd *= num % 10\n      num //= 10\n    return digitProd",
      "title": "3345. Smallest Divisible Digit Product I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00edc750-d514-4562-ada8-040e6f7e32bf",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3346. Maximum Frequency of an Element After Performing Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fafb75f7-79ba-4fcc-b301-2ced81aa991b",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  # Same as 3346. Maximum Frequency of an Element After Performing Operations I\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3347. Maximum Frequency of an Element After Performing Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1e3ac9a-a88a-4aaa-931e-2780b99261b7",
      "code": "FACTOR_COUNTS = {\n    0: collections.Counter(),\n    1: collections.Counter(),\n    2: collections.Counter([2]),\n    3: collections.Counter([3]),\n    4: collections.Counter([2, 2]),\n    5: collections.Counter([5]),\n    6: collections.Counter([2, 3]),\n    7: collections.Counter([7]),\n    8: collections.Counter([2, 2, 2]),\n    9: collections.Counter([3, 3]),\n}\n\n\nclass Solution:\n  def smallestNumber(self, num: str, t: int) -> str:\n    primeCount, isDivisible = self._getPrimeCount(t)\n    if not isDivisible:\n      return '-1'\n\n    factorCount = self._getFactorCount(primeCount)\n    if sum(factorCount.values()) > len(num):\n      return ''.join(factor * freq for factor, freq in factorCount.items())\n\n    primeCountPrefix = sum((FACTOR_COUNTS[int(c)]\n                            for c in num), start=collections.Counter())\n    firstZeroIndex = next((i for i, d in enumerate(num) if d == '0'), len(num))\n    if firstZeroIndex == len(num) and primeCount <= primeCountPrefix:\n      return num\n\n    for i, c in reversed(list(enumerate(num))):\n      d = int(c)\n      # Remove the current digit's factors from primeCountPrefix.\n      primeCountPrefix -= FACTOR_COUNTS[d]\n      spaceAfterThisDigit = len(num) - 1 - i\n      if i <= firstZeroIndex:\n        for biggerDigit in range(d + 1, 10):\n          # Compute the required factors after replacing with a larger digit.\n          factorsAfterReplacement = self._getFactorCount(\n              primeCount - primeCountPrefix - FACTOR_COUNTS[biggerDigit]\n          )\n          # Check if the replacement is possible within the available space.\n          if sum(factorsAfterReplacement.values()) <= spaceAfterThisDigit:\n            # Fill extra space with '1', if any, and construct the result.\n            fillOnes = spaceAfterThisDigit - sum(\n                factorsAfterReplacement.values())\n            return (\n                num[:i]  # Keep the prefix unchanged.\n                + str(biggerDigit)  # Replace the current digit.\n                + '1' * fillOnes  # Fill remaining space with '1'.\n                + ''.join(factor * freq for factor,\n                          freq in factorsAfterReplacement.items())\n            )\n\n    # No solution of the same length exists, so we need to extend the number\n    # by prepending '1's and adding the required factors.\n    factorCount = self._getFactorCount(primeCount)\n    return (\n        '1' * (len(num) + 1 - sum(factorCount.values()))\n        + ''.join(factor * freq for factor, freq in factorCount.items())\n    )\n\n  def _getPrimeCount(self, t: int) -> tuple[dict[int, int], bool]:\n    \"\"\"\n    Returns the count of prime factors of t and if t is divisible by 2, 3, 5, 7.\n    \"\"\"\n    count = collections.Counter()\n    for prime in [2, 3, 5, 7]:\n      while t % prime == 0:\n        t //= prime\n        count[prime] += 1\n    return count, t == 1\n\n  def _getFactorCount(self, count: dict[int, int]) -> dict[str, int]:\n    \"\"\"Returns the required factors to form the smallest number.\"\"\"\n    count8, remaining2 = divmod(count[2], 3)  # 2^3 = 8\n    count9, count3 = divmod(count[3], 2)  # 3^2 = 9\n    count4, count2 = divmod(remaining2, 2)  # 2^2 = 4\n    # Combine 2 and 3 to 6 if both are present.\n    count2, count3, count6 = ((0, 0, 1) if count2 == 1 and count3 == 1\n                              else (count2, count3, 0))\n    # Combine 3 and 4 to 2 and 6 if both are present.\n    count2, count6, count3, count4 = ((1, 1, 0, 0)\n                                      if count3 == 1 and count4 == 1\n                                      else (count2, count6, count3, count4))\n    return {'2': count2, '3': count3, '4': count4, '5': count[5],\n            '6': count6, '7': count[7], '8': count8, '9': count9}",
      "title": "3348. Smallest Divisible Digit Product II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3ec2651-c6eb-4df4-a9a2-3df13a2810e4",
      "code": "class Solution:\n  def hasIncreasingSubarrays(self, nums: list[int], k: int) -> bool:\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      if increasing // 2 >= k or min(prevIncreasing, increasing) >= k:\n        return True\n\n    return False",
      "title": "3349. Adjacent Increasing Subarrays Detection I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fcf0aaf-a9a8-4bd5-ac28-c7af252d9290",
      "code": "class Solution:\n  # Similar to 3349. Adjacent Increasing Subarrays Detection I\n  def maxIncreasingSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      ans = max(ans, increasing // 2)\n      ans = max(ans, min(prevIncreasing, increasing))\n\n    return ans",
      "title": "3350. Adjacent Increasing Subarrays Detection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff09cea4-3723-4c9b-b588-2c34373b9a54",
      "code": "class Solution:\n  def sumOfGoodSubsequences(self, nums: list[int]) -> int:\n    MOD = 10**9 + 7\n    maxNum = max(nums)\n    # endsIn[i] := the number of good subsequences ending in i\n    endsIn = [0] * (maxNum + 2)\n    # dp[i] := the sum of good subsequences ending in i\n    dp = [0] * (maxNum + 2)\n\n    for num in nums:\n      seqsToAppend = 1 + endsIn[num - 1] + endsIn[num + 1]\n      dp[num] = (seqsToAppend * num +\n                 (dp[num] + dp[num - 1] + dp[num + 1])) % MOD\n      endsIn[num] += seqsToAppend % MOD\n\n    return sum(dp) % MOD",
      "title": "3351. Sum of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "056601fd-09b7-45ab-9c1f-2adc2b625fc5",
      "code": "class Solution:\n  def countKReducibleNumbers(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    ops = self._getOps(s)\n\n    @functools.lru_cache(None)\n    def dp(i: int, setBits: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of positive integers less than n that are k-reducible,\n      considering the i-th digit, where `setBits` is the number of set bits in\n      the current number, and `tight` indicates if the current digit is\n      tightly bound.\n      \"\"\"\n      if i == len(s):\n        return int(ops[setBits] < k and not tight)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 1\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        res += dp(i + 1, setBits + d, nextTight)\n        res %= MOD\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n\n  def _getOps(self, s: str) -> int:\n    \"\"\"Returns the number of operations to reduce a number to 0.\"\"\"\n    ops = [0] * (len(s) + 1)\n    for num in range(2, len(s) + 1):\n      ops[num] = 1 + ops[num.bit_count()]\n    return ops",
      "title": "3352. Count K-Reducible Numbers Less Than N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "336872ba-1d09-4339-b3d2-9b7a56c59e0c",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return sum(a != b for a, b in itertools.pairwise(nums))",
      "title": "3353. Minimum Total Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a9a61ff-61ed-4f2c-b3a9-2b571abd0668",
      "code": "class Solution:\n  def countValidSelections(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        continue\n      if prefix[i] == suffix[i]:\n        ans += 2  # Go to either direction.\n      if abs(prefix[i] - suffix[i]) == 1:\n        ans += 1  # Go to the direction with the larger sum.\n\n    return ans",
      "title": "3354. Make Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83909aa4-9d58-4727-9f88-11ce715b04dc",
      "code": "class Solution:\n  def isZeroArray(self, nums: list[int], queries: list[list[int]]) -> bool:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n\n    for l, r in queries:\n      line[l] += 1\n      line[r + 1] -= 1\n\n    for i, num in enumerate(nums):\n      decrement += line[i]\n      if decrement < num:\n        return False\n\n    return True",
      "title": "3355. Zero Array Transformation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0beabeaf-99d7-48ea-ba1a-1c7cb698b749",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n    k = 0\n\n    for i, num in enumerate(nums):\n      while decrement + line[i] < num:\n        if k == len(queries):\n          return -1\n        l, r, val = queries[k]\n        k += 1\n        if r < i:\n          continue\n        line[max(l, i)] += val\n        line[r + 1] -= val\n      decrement += line[i]\n\n    return k",
      "title": "3356. Zero Array Transformation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed401cc4-e276-4796-89cb-c48fb4620033",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    maxPositiveGap = 0\n    mn = 1_000_000_000\n    mx = 0\n\n    for a, b in itertools.pairwise(nums):\n      if (a == -1) != (b == -1):\n        positive = max(a, b)\n        mn = min(mn, positive)\n        mx = max(mx, positive)\n      else:\n        maxPositiveGap = max(maxPositiveGap, abs(a - b))\n\n    l = maxPositiveGap\n    r = (mx - mn + 1) // 2\n    return bisect.bisect_left(\n        range(l, r), True,\n        key=lambda m: self._check(nums, m, mn + m, mx - m)) + l\n\n  def _check(self, nums: list[int], m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns True if it's possible have `m` as maximum absolute difference\n    between adjacent numbers, where -1s are replaced with `x` or `y`.\n    \"\"\"\n    gapLength = 0\n    prev = 0\n\n    for num in nums:\n      if num == -1:\n        gapLength += 1\n        continue\n      if prev > 0 and gapLength > 0:\n        if gapLength == 1 and not self._checkSingleGap(prev, num, m, x, y):\n          return False\n        if gapLength > 1 and not self._checkMultipleGaps(prev, num, m, x, y):\n          return False\n      prev = num\n      gapLength = 0\n\n    # Check leading gaps\n    if nums[0] == -1:\n      num = next((num for num in nums if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    # Check trailing gaps\n    if nums[-1] == -1:\n      num = next((num for num in reversed(nums) if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    return True\n\n  def _checkSingleGap(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with a single -1 between two numbers.\n    e.g. [a, -1, b] can be filled with either x or y.\n    \"\"\"\n    gapWithX = max(abs(a - x), abs(b - x))  # [a, x, b]\n    gapWithY = max(abs(a - y), abs(b - y))  # [a, y, b]\n    return min(gapWithX, gapWithY) <= m\n\n  def _checkMultipleGaps(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with multiple -1s between two numbers.\n    e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.\n    \"\"\"\n    ax = abs(a - x)\n    ay = abs(a - y)\n    bx = abs(b - x)\n    by = abs(b - y)\n    xy = abs(x - y)\n    gapAllX = max(ax, bx)  # [a, x, x, ..., x, b]\n    gapAllY = max(ay, by)  # [a, y, y, ..., y, b]\n    gapXToY = max(ax, xy, by)  # [a, x, ..., y, b]\n    gapYToX = max(ay, xy, bx)  # [a, y, ..., x, b]\n    return min(gapAllX, gapAllY, gapXToY, gapYToX) <= m\n\n  def _checkBoundaryGaps(self, a: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a boundary sequence starting or ending with -1s.\n    e.g. [a, -1, -1, ...] or [..., -1, -1, a].\n    \"\"\"\n    gapAllX = abs(a - x)  # [x, x, ..., x, a]\n    gapAllY = abs(a - y)  # [y, y, ..., y, a]\n    return min(gapAllX, gapAllY) <= m",
      "title": "3357. Minimize the Maximum Adjacent Element Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75a5728c-725a-49fd-860d-93855bc879e6",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  subarrayWidth: int\n  rowIndex: int\n  accumulatedSubmatrices: int\n\n\nclass Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # dp[i][j] := the number of valid subarrays ending in grid[i][j]\n    dp = [[0] * n for _ in range(m)]\n    # stacks[j] := the stack of valid\n    # (subarray width, row index, number of accumulated submatrices) ending in\n    # column j\n    stacks: list[T] = [[T(0, -1, 0)] for _ in range(n)]\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num > k:\n          stacks[j] = [T(0, i, 0)]\n        else:\n          dp[i][j] = 1\n          if j > 0 and row[j - 1] <= k and row[j - 1] >= row[j]:\n            # Extend the valid subarrays to the current number.\n            dp[i][j] += dp[i][j - 1]\n          width = dp[i][j]\n          # Remove subarray widths greater than the current count since they\n          # will become invalid.\n          while stacks[j] and width < stacks[j][-1].subarrayWidth:\n            stacks[j].pop()\n          height = i - stacks[j][-1].rowIndex\n          newSubmatrices = width * height\n          accumulatedSubmatrices = (stacks[j][-1].accumulatedSubmatrices +\n                                    newSubmatrices)\n          ans += accumulatedSubmatrices\n          stacks[j].append(T(width, i, accumulatedSubmatrices))\n\n    return ans",
      "title": "3359. Find Sorted Submatrices With Maximum Element at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1194d930-503c-4b52-a464-32418474a1dc",
      "code": "class Solution:\n  def canAliceWin(self, n: int) -> bool:\n    for stones in range(10, -1, -1):\n      if stones > n:\n        return stones % 2 == 1\n      n -= stones",
      "title": "3360. Stone Removal Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85ff3e23-39a9-43ec-9e33-f73670dd7b90",
      "code": "class Solution:\n  def shiftDistance(\n      self,\n      s: str,\n      t: str,\n      nextCost: list[int],\n      previousCost: list[int]\n  ) -> int:\n    ans = 0\n    # prev[i][j]: the prev cost to shift from ('a' + i) to ('a' + j)\n    prev = [[0] * 26 for _ in range(26)]\n    # next[i][j]: the next cost to shift from ('a' + i) to ('a' + j)\n    next = [[0] * 26 for _ in range(26)]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        next[i][(i + j) % 26] = cost\n        cost += nextCost[(i + j) % 26]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        prev[i][(i - j + 26) % 26] = cost\n        cost += previousCost[(i - j + 26) % 26]\n\n    for a, b in zip(s, t):\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      ans += min(next[i][j], prev[i][j])\n\n    return ans",
      "title": "3361. Shift Distance Between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6581e72e-8315-4647-a350-b689af5753f8",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:\n    q = collections.deque(sorted(queries))\n    available = SortedList()  # available `r`s\n    running = SortedList()  # running `r`s\n\n    for i, num in enumerate(nums):\n      while q and q[0][0] <= i:\n        available.add(q.popleft()[1])\n      while running and running[0] < i:\n        running.pop(0)\n      while num > len(running):\n        if not available or available[-1] < i:\n          return -1\n        running.add(available.pop())\n\n    return len(available)",
      "title": "3362. Zero Array Transformation III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7342d6d4-d2de-42c5-afe8-f248c73ea98b",
      "code": "class Solution:\n  def maxCollectedFruits(self, fruits: list[list[int]]) -> int:\n    n = len(fruits)\n\n    def getTopLeft() -> int:\n      return sum(fruits[i][i] for i in range(n))\n\n    def getTopRight() -> int:\n      # dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[0][-1] = fruits[0][-1]\n      for x in range(n):\n        for y in range(n):\n          if x >= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(1, -1), (1, 0), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if i < j < n - 1 - i:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    def getBottomLeft() -> int:\n      # dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[-1][0] = fruits[-1][0]\n      for y in range(n):\n        for x in range(n):\n          if x <= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(-1, 1), (0, 1), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if j < i < n - 1 - j:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    return getTopLeft() + getTopRight() + getBottomLeft() - 2 * fruits[-1][-1]",
      "title": "3363. Find the Maximum Number of Fruits Collected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9287ff9e-383b-4f43-8f1e-4117985efd6d",
      "code": "class Solution:\n  def minimumSumSubarray(self, nums: list[int], l: int, r: int) -> int:\n    ans = math.inf\n\n    for windowSize in range(l, r + 1):\n      windowSum = sum(nums[:windowSize])\n      if windowSum > 0:\n        ans = min(ans, windowSum)\n      for i in range(windowSize, len(nums)):\n        windowSum -= nums[i - windowSize]\n        windowSum += nums[i]\n        if windowSum > 0:\n          ans = min(ans, windowSum)\n\n    return -1 if ans == math.inf else ans",
      "title": "3364. Minimum Positive Sum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83e5d1ab-17f5-443c-bd7f-d05a014d5ca5",
      "code": "class Solution:\n  def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:\n    n = len(s)\n    return (collections.Counter(s[i:i + n // k] for i in range(0, n, n // k)) ==\n            collections.Counter(t[i:i + n // k] for i in range(0, n, n // k)))",
      "title": "3365. Rearrange K Substrings to Form Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14ba09db-80e7-437d-9f1b-ec54bb1d9110",
      "code": "class Solution:\n  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:\n    n = len(nums)\n    # dp[i][j][k] := the minimum sum of nums[i..n - 1] with j operations of op1\n    # and k operations of op2\n    dp = [[[math.inf] * (op2 + 1)\n          for _ in range(op1 + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: When index reaches the end of the array, the result is 0.\n    for i in range(op1 + 1):\n      for j in range(op2 + 1):\n        dp[n][i][j] = 0\n\n    for i in range(n - 1, -1, -1):\n      for o1 in range(op1 + 1):\n        for o2 in range(op2 + 1):\n          summ = nums[i] + dp[i + 1][o1][o2]\n          if o1 > 0:\n            summ = min(summ, (nums[i] + 1) // 2 + dp[i + 1][o1 - 1][o2])\n          if o2 > 0 and nums[i] >= k:\n            summ = min(summ, nums[i] - k + dp[i + 1][o1][o2 - 1])\n          if o1 > 0 and o2 > 0:\n            if (nums[i] + 1) // 2 >= k:\n              summ = min(summ,\n                         (nums[i] + 1) // 2 - k + dp[i + 1][o1 - 1][o2 - 1])\n            if nums[i] >= k:\n              summ = min(summ,\n                         (nums[i] - k + 1) // 2 + dp[i + 1][o1 - 1][o2 - 1])\n          dp[i][o1][o2] = summ\n\n    return dp[0][op1][op2]",
      "title": "3366. Minimum Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b441ff4-7d72-416f-829c-34a8435da190",
      "code": "class Solution:\n  def maximizeSumOfWeights(self, edges: list[list[int]], k: int) -> int:\n    graph = [[] for _ in range(len(edges) + 1)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      \"\"\"\n      Returns\n      (the weight sum of the subtree rooted at u with at most k - 1 children,\n       the weight sum of the subtree rooted at u with at most k children).\n      \"\"\"\n      weightSum = 0\n      diffs = []\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        subK1, subK = dfs(v, u)\n        weightSum += subK\n        # If picking (u, v) makes the sum larger, we should pick it.\n        diffs.append(max(0, subK1 - subK + w))\n      return (weightSum + sum(heapq.nlargest(k - 1, diffs)),\n              weightSum + sum(heapq.nlargest(k, diffs)))\n\n    return dfs(0, -1)[1]",
      "title": "3367. Maximize Sum of Weights after Edge Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d826c283-0dc5-4425-9885-a97c4cf9e980",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> int:\n    return (1 << n.bit_length()) - 1",
      "title": "3370. Smallest Number With All Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f71e20a-1925-4e4c-85c6-72406ad670d5",
      "code": "class Solution:\n  def getLargestOutlier(self, nums: list[int]) -> int:\n    ans = -math.inf\n    summ = sum(nums)\n    count = collections.Counter(nums)\n\n    for num in nums:\n      withoutNum = summ - num\n      if withoutNum % 2 == 0:\n        specialSum = withoutNum // 2  # the sum of special numbers\n        if count[specialSum] > (1 if num == specialSum else 0):\n          ans = max(ans, num)\n\n    return ans",
      "title": "3371. Identify the Largest Outlier in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a54f0a5-1925-4feb-9e6e-ea745a9fc946",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n      k: int\n  ) -> list[int]:\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    maxReachableInGraph2 = 0\n\n    if k > 0:\n      for i in range(len(edges2) + 1):\n        maxReachableInGraph2 = max(maxReachableInGraph2,\n                                   self._dfs(graph2, i, -1, k - 1))\n\n    return [maxReachableInGraph2 + self._dfs(graph1, i, -1, k)\n            for i in range(len(edges1) + 1)]\n\n  def _dfs(self, graph: list[list[int]], u: int, prev: int, k: int) -> int:\n    \"\"\"Returns the number of nodes that can be reached from u with k steps.\"\"\"\n    if k == 0:\n      return 1\n    res = 0\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, k - 1)\n    return 1 + res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3372. Maximize the Number of Target Nodes After Connecting Trees I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b73cb8a-66f1-4658-a1b3-946ebbb7ca2e",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]]\n  ) -> list[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    parity1 = [False] * n\n    parity2 = [False] * m  # placeholder (parity2 is not used)\n    even1 = self._dfs(graph1, 0, -1, parity1, True)\n    even2 = self._dfs(graph2, 0, -1, parity2, True)\n    odd1 = n - even1\n    odd2 = m - even2\n\n    # Can connect the current node in tree1 to either an even node or an odd\n    # node in tree2.\n    return [(even1 if parity1[i] else odd1) + max(even2, odd2)\n            for i in range(n)]\n\n  def _dfs(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      parity: list[bool],\n      isEven: bool\n  ) -> int:\n    \"\"\"\n    Returns the number of nodes that can be reached from u with even steps.\n    \"\"\"\n    res = 1 if isEven else 0\n    parity[u] = isEven\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, parity, not isEven)\n    return res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3373. Maximize the Number of Target Nodes After Connecting Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ba6bee3-2968-408c-afc5-4f7eab31df77",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    numsSet = set(nums)\n    mn = min(nums)\n    if mn < k:\n      return -1\n    if mn > k:\n      return len(numsSet)\n    return len(numsSet) - 1",
      "title": "3375. Minimum Operations to Make Array Values Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4f5e543-aec0-4bed-90e5-74537b34a632",
      "code": "class Solution:\n  def minOperations(self, n: int, m: int) -> int:\n    isPrime = self._sieveEratosthenes(10000)\n    if isPrime[n] or isPrime[m]:\n      return -1\n    return self._dijkstra(n, m, isPrime)\n\n  def _dijkstra(self, src: int, dst: int, isPrime: list[bool]) -> int:\n    seen = {src}\n    minHeap = [(src, src)]  # (cost, num)\n\n    while minHeap:\n      cost, curr = heapq.heappop(minHeap)\n      if curr == dst:\n        return cost\n      s = list(str(curr))\n      for i, c in enumerate(s):\n        if c < '9':\n          s[i] = str(int(c) + 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n        if c > '0' and not (i == 0 and c == '1'):\n          s[i] = str(int(c) - 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n\n    return -1\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3377. Digit Operations to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d49d6b6a-b3df-4bee-a987-8eaae90d731c",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n    self.rank = collections.Counter()\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if u not in self.id:\n      self.id[u] = u\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, nums: list[int], threshold: int) -> int:\n    uf = UnionFind()\n\n    for num in nums:\n      for multiple in range(2 * num, threshold + 1, num):\n        uf.unionByRank(num, multiple)\n\n    return len(set(uf.find(num) for num in nums))",
      "title": "3378. Count Connected Components in LCM Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a49ddc4-e18b-49b2-a569-43ca29e33ef8",
      "code": "class Solution:\n  def constructTransformedArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    return [nums[(i + num % n + n) % n]\n            for i, num in enumerate(nums)]",
      "title": "3379. Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d32b25d-336e-46dd-ad8f-a6c5cb9a34b2",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    # minPrefix[i % k] := the minimum prefix sum of the first i numbers\n    minPrefix = [math.inf] * k\n    minPrefix[k - 1] = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      ans = max(ans, prefix - minPrefix[i % k])\n      minPrefix[i % k] = min(minPrefix[i % k], prefix)\n\n    return ans",
      "title": "3381. Maximum Subarray Sum With Length Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "106da807-b220-4456-a057-02567097c206",
      "code": "class Solution:\n  def minRunesToAdd(\n      self,\n      n: int,\n      crystals: list[int],\n      flowFrom: list[int],\n      flowTo: list[int]\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v in zip(flowFrom, flowTo):\n      graph[u].append(v)\n      reversedGraph[v].append(u)\n\n    # Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm.\n    seen = set()\n    orderStack = []\n    componentIds = [-1] * n\n    componentCount = 0\n\n    for i in range(n):\n      if i not in seen:\n        self._kosaraju(graph, i, seen, orderStack)\n\n    while orderStack:\n      u = orderStack.pop()\n      if componentIds[u] == -1:\n        self._identifySCC(reversedGraph, u, componentIds, componentCount)\n        componentCount += 1\n\n    # Track crystal-containing components and inter-component edges.\n    hasCrystal = [False] * componentCount\n    hasInterComponentEdge = [False] * componentCount\n\n    for u in crystals:\n      hasCrystal[componentIds[u]] = True\n\n    for u, v in zip(flowFrom, flowTo):\n      id1 = componentIds[u]\n      id2 = componentIds[v]\n      if id1 != id2:  # Edge is inter-component.\n        hasInterComponentEdge[id2] = True\n\n    return sum(not hasCrystal[i] and not hasInterComponentEdge[i]\n               for i in range(componentCount))\n\n  def _kosaraju(\n      self,\n      graph: list[list[int]],\n      u: int,\n      seen: set[int],\n      orderStack: list\n  ) -> None:\n    \"\"\"Creates a topological order stack using Kosaraju's Algorithm.\"\"\"\n    seen.add(u)\n    for v in graph[u]:\n      if v not in seen:\n        self._kosaraju(graph, v, seen, orderStack)\n    orderStack.append(u)\n\n  def _identifySCC(\n      self,\n      reversedGraph: list[list[int]],\n      u: int,\n      componentIds: list[int],\n      componentId: int\n  ) -> None:\n    \"\"\"Assigns component IDs during SCC identification in the second DFS.\"\"\"\n    if componentIds[u] != -1:\n      return\n    componentIds[u] = componentId\n    for v in reversedGraph[u]:\n      if componentIds[v] == -1:\n        self._identifySCC(reversedGraph, v, componentIds, componentId)",
      "title": "3383. Minimum Runes to Add to Cast Spell",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11e2a109-e4cf-44d5-907c-2a2d90476ead",
      "code": "class Solution:\n  def findMinimumTime(self, strength: list[int]) -> int:\n    costs = [[(s + turn - 1) // turn\n             for s in strength]\n             for turn in range(1, len(strength) + 1)]\n    return self._hungarian(costs)[-1]\n\n  def _hungarian(self, costs):\n    \"\"\"\n    Returns an array `res` of length n (costs.length), with `res[i]` equaling\n    the minimum cost to assign the first (i + 1) turns to the first (i + 1)\n    locks using Hungarian algorithm, where costs[i][j] is the energy required\n    to break j-th lock in i-th turn.\n\n    https://en.wikipedia.org/wiki/Hungarian_algorithm\n    \"\"\"\n    numLocks = len(costs)\n    turnPotentials = [0] * numLocks\n    lockPotentials = [0] * (numLocks + 1)\n    lockAssignments = [-1] * (numLocks + 1)\n    res = []\n\n    for currentTurn in range(numLocks):\n      currentLock = numLocks\n      lockAssignments[currentLock] = currentTurn\n      minReducedCosts = [math.inf] * (numLocks + 1)\n      previousLockAssignments = [-1] * (numLocks + 1)\n      locksInOptimalPath = [False] * (numLocks + 1)\n\n      while lockAssignments[currentLock] != -1:\n        locksInOptimalPath[currentLock] = True\n        assignedTurn = lockAssignments[currentLock]\n        minCostDelta = math.inf\n        nextLock = None\n\n        for lock in range(numLocks):\n          if not locksInOptimalPath[lock]:\n            reducedCost = (\n                costs[assignedTurn][lock] -\n                turnPotentials[assignedTurn] -\n                lockPotentials[lock]\n            )\n            oldMin = minReducedCosts[lock]\n            minReducedCosts[lock] = min(oldMin, reducedCost)\n            if minReducedCosts[lock] < oldMin:\n              previousLockAssignments[lock] = currentLock\n            if minReducedCosts[lock] < minCostDelta:\n              minCostDelta = minReducedCosts[lock]\n              nextLock = lock\n\n        for lock in range(numLocks + 1):\n          if locksInOptimalPath[lock]:\n            turnPotentials[lockAssignments[lock]] += minCostDelta\n            lockPotentials[lock] -= minCostDelta\n          else:\n            minReducedCosts[lock] -= minCostDelta\n\n        currentLock = nextLock\n\n      while currentLock != numLocks:\n        lockAssignments[currentLock] = lockAssignments[previousLockAssignments[currentLock]]\n        currentLock = previousLockAssignments[currentLock]\n\n      res.append(-lockPotentials[numLocks])\n\n    return res",
      "title": "3385. Minimum Time to Break Locks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bc895a-75c7-493f-b857-ab7c84973dff",
      "code": "class Solution:\n  def buttonWithLongestTime(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxTimeTaken = 0\n    prevTime = 0\n\n    for index, time in events:\n      timeTaken = time - prevTime\n      if timeTaken > maxTimeTaken or timeTaken == maxTimeTaken and index < ans:\n        maxTimeTaken = timeTaken\n        ans = index\n      prevTime = time\n\n    return ans",
      "title": "3386. Button with Longest Push Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c327cb0-b7f8-4fe1-b0bf-31445727ee7c",
      "code": "class Solution:\n  def maxAmount(\n      self,\n      initialCurrency: str,\n      pairs1: list[list[str]],\n      rates1: list[float],\n      pairs2: list[list[str]],\n      rates2: list[float]\n  ) -> float:\n    # dp[currency] := the maximum amount of money to convert to `currency`\n    dp: dict[str, float] = collections.defaultdict(float)\n    dp[initialCurrency] = 1.0\n    self._bellman(dp, pairs1, rates1)\n    self._bellman(dp, pairs2, rates2)\n    return dp[initialCurrency]\n\n  def _bellman(\n      self,\n      dp: dict[str, float],\n      pairs: list[list[str]],\n      rates: list[float]\n  ) -> None:\n    for _ in range(len(pairs)):\n      for (start, target), rate in zip(pairs, rates):\n        dp[target] = max(dp[target], dp[start] * rate)\n        dp[start] = max(dp[start], dp[target] / rate)",
      "title": "3387. Maximize Amount After Two Days of Conversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c28f00f-90ba-4721-87d3-5640a6df0cd0",
      "code": "class Solution:\n  def beautifulSplits(self, nums: list[int]) -> int:\n    n = len(nums)\n    # z[start][i] := the z array of nums[i..n) with respect to nums[start..n)\n    z = [self._zFunction(nums, start)\n         for start in range(n)]\n    # nums1 | nums2 | nums3 = nums[0..i] | nums[i + 1..j] | nums[j + 1..n - 1]\n    return sum((j - i >= i + 1 and z[0][i + 1] >= i + 1)  # nums1 is a prefix of nums2\n               or z[i + 1][j + 1] >= j - i  # nums2 is a suffix of nums3.\n               for i in range(n - 2)\n               for j in range(i + 1, n - 1))\n\n  def _zFunction(self, nums: list[int], start: int) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    nums[i..n) which is also a prefix of nums[start..n).\n    \"\"\"\n    n = len(nums)\n    z = [0] * n\n    l = start\n    r = start\n    for i in range(1 + start, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l + start])\n      while i + z[i] < n and nums[z[i] + start] == nums[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3388. Count Beautiful Splits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59c43d06-7bb4-47b4-9203-4f15fca8a8c1",
      "code": "class Solution:\n  def makeStringGood(self, s: str) -> int:\n    count = [0] * 26\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n    return min(self._getMinOperations(count, target)\n               for target in range(1, max(count) + 1))\n\n  def _getMinOperations(self, count: list[int], target: int) -> int:\n    # dp[i] represents the minimum number of operations to make the frequency of\n    # (i..25)-th (0-indexed) letters equal to `target`.\n    dp = [0] * 27\n\n    for i in range(25, -1, -1):\n      # 1. Delete all the i-th letters.\n      deleteAllToZero = count[i]\n      # 2. Insert/delete the i-th letters to have `target` number of letters.\n      deleteOrInsertToTarget = abs(target - count[i])\n      dp[i] = min(deleteAllToZero, deleteOrInsertToTarget) + dp[i + 1]\n      if i + 1 < 26 and count[i + 1] < target:\n        nextDeficit = target - count[i + 1]\n        # Make the frequency of the i-th letter equal to the `target` or 0.\n        needToChange = count[i] if count[i] <= target else count[i] - target\n        changeToTarget = (\n            # 3. Change all the i-th letters to the next letter and then\n            # insert the remaining deficit for the next letter.\n            needToChange + (nextDeficit - needToChange) if nextDeficit > needToChange\n            # 4. Change `nextDeficit` i-th letters to the next letter and\n            # then delete the remaining i-th letters.\n            else nextDeficit + (needToChange - nextDeficit)\n        )\n        dp[i] = min(dp[i], changeToTarget + dp[i + 2])\n\n    return dp[0]",
      "title": "3389. Minimum Operations to Make Character Frequencies Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63c82b9b-6c9e-411e-a910-788d47b9fa60",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    return sum(b == (a + c) * 2\n               for a, b, c in zip(nums, nums[1:], nums[2:]))",
      "title": "3392. Count Subarrays of Length Three With a Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a30c1fb-e039-4b54-bd74-066972cb4471",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid, k):\n    MOD = 1_000_000_007\n    MAX = 15\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][xors] := the number of paths from (i, j) to (m - 1, n - 1) with\n    # XOR value `xors`\n    dp = [[[0] * (MAX + 1)\n          for _ in range(n)]\n          for _ in range(m)]\n\n    dp[-1][-1][grid[-1][-1]] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        for xors in range(MAX + 1):\n          if i - 1 >= 0:\n            newXor = xors ^ grid[i - 1][j]\n            dp[i - 1][j][newXor] += dp[i][j][xors]\n            dp[i - 1][j][newXor] %= MOD\n          if j - 1 >= 0:\n            newXor = xors ^ grid[i][j - 1]\n            dp[i][j - 1][newXor] += dp[i][j][xors]\n            dp[i][j - 1][newXor] %= MOD\n\n    return dp[0][0][k]",
      "title": "3393. Count Paths With the Given XOR Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb3e723a-b313-4fd2-a851-6c61473af460",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def count(i: int, j: int, xors: int) -> int:\n      \"\"\"\n      Return the number of paths from (i, j) to (m - 1, n - 1) with XOR value\n      `xors`.\n      \"\"\"\n      if i == m or j == n:\n        return 0\n      xors ^= grid[i][j]\n      if i == m - 1 and j == n - 1:\n        return int(xors == k)\n      right = count(i, j + 1, xors)\n      down = count(i + 1, j, xors)\n      return (right + down) % MOD\n\n    return count(0, 0, 0)",
      "title": "3393. Count Paths With the Given XOR Value_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e589407f-0b97-4048-8489-55a23bc50240",
      "code": "class Solution:\n  def checkValidCuts(self, n: int, rectangles: list[list[int]]) -> bool:\n    xs = [(startX, endX) for startX, _, endX, _ in rectangles]\n    ys = [(startY, endY) for _, startY, _, endY in rectangles]\n    return max(self._countMerged(xs),\n               self._countMerged(ys)) >= 3\n\n  def _countMerged(self, intervals: list[tuple[int, int]]) -> int:\n    count = 0\n    prevEnd = 0\n    for start, end in sorted(intervals):\n      if start < prevEnd:\n        prevEnd = max(prevEnd, end)\n      else:\n        prevEnd = end\n        count += 1\n    return count",
      "title": "3394. Check if Grid can be Cut into Sections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cd69022-ff31-4783-9568-7a2e84a9858f",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3395. Subsequences with a Unique Middle Mode I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f18c4d97-5998-469d-a987-7fa9782ab6dd",
      "code": "class Solution:\n  def __init__(self):\n    self.MOD = 1_000_000_007\n\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    left = collections.Counter()\n    right = collections.Counter()\n\n    for i in range(2):\n      left[nums[i]] += 1\n\n    for i in range(2, n):\n      right[nums[i]] += 1\n\n    for i in range(2, n - 2):\n      num = nums[i]\n      right[num] -= 1\n      if right[num] == 0:\n        del right[num]\n\n      leftCount = left[num]\n      rightCount = right[num]\n      leftOther = i - leftCount\n      rightOther = n - 1 - i - rightCount\n\n      # count[mode] = 5 -- [a a] a [a a]\n      ans += math.comb(leftCount, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 4 -- [a a] a [a ?]\n      ans += math.comb(leftCount, 2) * rightCount * rightOther\n\n      # count[mode] = 4 -- [a ?] a [a a]\n      ans += leftCount * leftOther * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a a] a [? ?]\n      ans += math.comb(leftCount, 2) * math.comb(rightOther, 2)\n\n      # count[mode] = 3 -- [? ?] a [a a]\n      ans += math.comb(leftOther, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a ?] a [a ?]\n      ans += leftCount * leftOther * rightCount * rightOther\n\n      # count[mode] = 2 -- [a ?] a [? ?]\n      ans += leftCount * self._calc(num, leftOther, rightOther, left, right)\n\n      # count[mode] = 2 -- [? ?] a [a ?]\n      ans += rightCount * self._calc(num, rightOther, leftOther, right, left)\n\n      ans %= self.MOD\n      left[num] += 1\n\n    return ans\n\n  def _calc(\n      self,\n      a: int,\n      other1: int,\n      other2: int,\n      count1: dict[int, int],\n      count2: dict[int, int]\n  ) -> int:\n    \"\"\"\n    Returns the count of subsequences that have `a` as the middle number, where\n    invalid subsequences are excluded.\n    \"\"\"\n    # [a ?] a [? ?]\n    res = (other1 * math.comb(other2, 2)) % self.MOD\n\n    for b, b1 in count1.items():\n      if b == a:\n        continue\n      b2 = count2[b]\n      # Exclude triples -- [a b] a [b b].\n      res = (res - b1 * math.comb(b2, 2)) % self.MOD\n      # Exclude doubles -- [a b] a [b ?].\n      res = (res - b1 * b2 * (other2 - b2)) % self.MOD\n\n    for b, b2 in count2.items():\n      if b == a:\n        continue\n      b1 = count1[b]\n      # Exclude doubles -- [a ?] a [b b].\n      res = (res - (other1 - b1) * math.comb(b2, 2)) % self.MOD\n\n    return (res + self.MOD) % self.MOD",
      "title": "3395. Subsequences with a Unique Middle Mode I_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce680f2-e261-45d9-9b4c-38175c557105",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    seen = set()\n    for i, num in reversed(list(enumerate(nums))):\n      if num in seen:\n        return (i + 1 + 2) // 3  # ceil((i + 1) / 3)\n      seen.add(num)\n    return 0",
      "title": "3396. Minimum Number of Operations to Make Elements in Array Distinct",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b3c32de-4fd7-40b8-9489-c8c0faabb57d",
      "code": "class Solution:\n  def maxDistinctElements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    occupied = -math.inf\n\n    for num in sorted(nums):\n      if occupied < num + k:\n        occupied = max(occupied + 1, num - k)\n        ans += 1\n\n    return ans",
      "title": "3397. Maximum Number of Distinct Elements After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58dc6785-e464-4091-9ff6-a5ea037e717c",
      "code": "class Solution:\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3398. Smallest Substring With Identical Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3569e9e5-5253-4d79-8ef5-a58010e45df7",
      "code": "class Solution:\n  # Same as 3398. Smallest Substring With Identical Characters I\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3399. Smallest Substring With Identical Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "037bd0f7-2640-4f8c-ae03-261621f2e21e",
      "code": "class Solution:\n  def maximumMatchingIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n\n    for shift in range(n):\n      matches = 0\n      for i, num2 in enumerate(nums2):\n        if nums1[(i + shift) % n] == num2:\n          matches += 1\n      ans = max(ans, matches)\n\n    return ans",
      "title": "3400. Maximum Number of Matching Indices After Right Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8270b72f-ccf5-46df-ba56-181d6f686f64",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for j in range(len(grid[0])):\n      for i in range(1, len(grid)):\n        if grid[i][j] <= grid[i - 1][j]:\n          ans += grid[i - 1][j] - grid[i][j] + 1\n          grid[i][j] = grid[i - 1][j] + 1\n\n    return ans",
      "title": "3402. Minimum Operations to Make Columns Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f814705-b63c-4350-a3d6-0890616a8dd0",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3403. Find the Lexicographically Largest String From the Box I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac966374-f583-488b-8b00-54f556fec878",
      "code": "class Solution:\n  def numberOfSubsequences(self, nums: list[int]) -> int:\n    n = len(nums)\n    mx = max(nums)\n    ans = 0\n    count = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    # nums[p] * nums[r] == nums[q] * nums[s]\n    # nums[p] / nums[q] == nums[s] / nums[r]\n    for r in range(4, n - 1 - 2 + 1):\n      q = r - 2\n      for p in range(0, q - 2 + 1):\n        g = math.gcd(nums[p], nums[q])\n        count[nums[p] // g][nums[q] // g] += 1\n      for s in range(r + 2, n):\n        g = math.gcd(nums[s], nums[r])\n        ans += count[nums[s] // g][nums[r] // g]\n\n    return ans",
      "title": "3404. Count Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0449a476-85b8-4152-8661-0b2e3890101b",
      "code": "class Solution:\n  def countGoodArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    return m * pow(m - 1, n - k - 1, MOD) * math.comb(n - 1, k) % MOD",
      "title": "3405. Count the Number of Arrays with K Matching Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5324d15e-92e6-4d4b-85cb-15a7ec25612a",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3406. Find the Lexicographically Largest String From the Box II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "635450fd-914d-472e-9d3e-32b23bbdf322",
      "code": "class Solution:\n  def hasMatch(self, s: str, p: str) -> bool:\n    prefix, suffix = p.split('*')\n    i = s.find(prefix)\n    return i != -1 and s.find(suffix, i + len(prefix)) != -1",
      "title": "3407. Substring Matching Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed1dbd0c-5a61-4041-8bc2-029d3b26d5fe",
      "code": "class Solution:\n  def longestSubsequence(self, nums: list[int]) -> int:\n    mx = max(nums)\n    # dp[num][diff] := the length of the longest subsequence ending in `num`\n    # s.t. the last absolute difference between consecutive elements is `diff`\n    dp = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    for num in nums:\n      for prev in range(1, mx + 1):\n        diff = abs(num - prev)\n        dp[num][diff] = max(dp[num][diff], dp[prev][diff] + 1)\n      # dp[num][diff] := max(dp[num][j]) for j >= diff\n      for j in range(mx - 1, -1, -1):\n        dp[num][j] = max(dp[num][j], dp[num][j + 1])\n\n    return max(map(max, dp))",
      "title": "3409. Longest Subsequence With Decreasing Adjacent Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8abd7cc-a428-447d-98b9-19d42fbb5c32",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int]) -> int:\n    ans = max(nums)\n    prefix = 0\n    minPrefix = 0\n    # the minimum prefix sum that can have a negative number removed\n    modifiedMinPrefix = 0\n    count = collections.Counter()\n    # minPrefixPlusRemoval[num] := the minimum prefix sum plus removed `num`\n    minPrefixPlusRemoval = {}\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix - modifiedMinPrefix)\n      if num < 0:\n        count[num] += 1\n        minPrefixPlusRemoval[num] = (\n            min(minPrefixPlusRemoval.get(num, 0), minPrefix) + num)\n        modifiedMinPrefix = min(modifiedMinPrefix,\n                                count[num] * num,\n                                minPrefixPlusRemoval[num])\n      minPrefix = min(minPrefix, prefix)\n      modifiedMinPrefix = min(modifiedMinPrefix, minPrefix)\n\n    return ans",
      "title": "3410. Maximize Subarray Sum After Removing All Occurrences of One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "103403d2-2a92-4ae1-954b-87eb9ab4535e",
      "code": "class Solution:\n  def maxLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n\n    for i in range(n):\n      prod = 1\n      l = 1\n      g = 0\n      for j in range(i, n):\n        prod *= nums[j]\n        l = math.lcm(l, nums[j])\n        g = math.gcd(g, nums[j])\n        if prod == l * g:\n          ans = max(ans, j - i + 1)\n\n    return ans",
      "title": "3411. Maximum Subarray With Equal Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "189e3ade-b3e5-4575-8066-66b1cb5470c7",
      "code": "class Solution:\n  def calculateScore(self, s: str) -> int:\n    ans = 0\n    indices = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      oppositeIndex = 25 - index\n      if indices[oppositeIndex]:\n        ans += i - indices[oppositeIndex].pop()\n      else:\n        indices[index].append(i)\n\n    return ans",
      "title": "3412. Find Mirror Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28f1d2b6-6a0b-4aa1-af8a-58204030fa6b",
      "code": "class Solution:\n  def maximumCoins(self, coins: list[list[int]], k: int) -> int:\n    return max(self._slide(coins, k),\n               self._slide([[-r, -l, c] for l, r, c in coins], k))\n\n  def _slide(self, coins: list[list[int]], k: int) -> int:\n    coins.sort()\n    res = 0\n    windowSum = 0\n    j = 0\n    for li, ri, ci in coins:  # Consider the number line [li..li + k).\n      rightBoundary = li + k\n\n      # [lj, rj] is fully in [li..li + k).\n      while j + 1 < len(coins) and coins[j + 1][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        windowSum += (rj - lj + 1) * cj\n        j += 1\n\n      # [lj, rj] may be partially in [l..l + k).\n      last = 0\n      if j < len(coins) and coins[j][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        last = (min(rightBoundary - 1, rj) - lj + 1) * cj\n\n      res = max(res, windowSum + last)\n      windowSum -= (ri - li + 1) * ci\n    return res",
      "title": "3413. Maximum Coins From K Consecutive Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74678733-a94f-4b3e-8d55-dc011dff235e",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  weight: int\n  selected: tuple[int]\n\n  def __iter__(self):\n    yield self.weight\n    yield self.selected\n\n\nclass Solution:\n  def maximumWeight(self, intervals: list[list[int]]) -> list[int]:\n    intervals = sorted((*interval, i) for i, interval in enumerate(intervals))\n\n    @functools.lru_cache(None)\n    def dp(i: int, quota: int) -> T:\n      \"\"\"\n      Returns the maximum weight and the selected intervals for intervals[i..n),\n      where `quota` is the number of intervals that can be selected.\n      \"\"\"\n      if i == len(intervals) or quota == 0:\n        return T(0, ())\n\n      skip = dp(i + 1, quota)\n\n      _, r, weight, originalIndex = intervals[i]\n      j = bisect.bisect_right(intervals, (r, math.inf))\n      nextRes = dp(j, quota - 1)\n      pick = T(weight + nextRes.weight,\n               sorted((originalIndex, *nextRes.selected)))\n      return (pick if (pick.weight > skip.weight or\n                       pick.weight == skip.weight and pick.selected < skip.selected)\n              else skip)\n\n    return list(dp(0, 4).selected)",
      "title": "3414. Maximum Score of Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9513aea-a69a-437f-adf0-d70d193b63c2",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  # Same as 3395. Subsequences with a Unique Middle Mode I\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3416. Subsequences with a Unique Middle Mode II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b4fb7ba-db67-4da3-86bd-c5f3f976385e",
      "code": "class Solution:\n  def zigzagTraversal(self, grid: list[list[int]]) -> list[int]:\n    zigzag = [row[::-1] if i % 2 else row for i, row in enumerate(grid)]\n    return [num for row in zigzag for num in row][::2]",
      "title": "3417. Zigzag Grid Traversal With Skip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bcd3459-575e-4098-836a-55b03f306ec4",
      "code": "class Solution:\n  def maximumAmount(self, coins: list[list[int]]) -> int:\n    m = len(coins)\n    n = len(coins[0])\n    # dp[i][j][k] := the maximum profit at position (i, j) with k remaining\n    # neutralizations\n    dp = [[[-math.inf] * 4 for _ in range(n)] for _ in range(m)]\n\n    # Base case: the robot starts at the top-left corner.\n    dp[0][0][2] = coins[0][0]\n    if coins[0][0] < 0:\n      dp[0][0][1] = 0  # Neutralize the robber.\n\n    for i in range(m):\n      for j in range(n):\n        for k in range(3):  # for each number of remaining neutralizations\n          if i > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i - 1][j][k] + coins[i][j],\n                              dp[i - 1][j][k + 1])\n          if j > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i][j - 1][k] + coins[i][j],\n                              dp[i][j - 1][k + 1])\n\n    return max(dp[-1][-1])",
      "title": "3418. Maximum Amount of Money Robot Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d721db7-2385-4528-9c18-8df1ac4edc29",
      "code": "class Solution:\n  def minMaxWeight(self, n: int, edges: list[list[int]], threshold: int) -> int:\n    MAX = 1000000\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      reversedGraph[v].append((u, w))\n\n    l = 1\n    r = MAX + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if self._dfs(reversedGraph, 0, m, set()) == n:\n        r = m\n      else:\n        l = m + 1\n\n    return -1 if l == MAX + 1 else l\n\n  def _dfs(\n      self,\n      reversedGraph: list[list[tuple]],\n      u: int,\n      maxWeight: int,\n      seen: set[int]\n  ) -> int:\n    \"\"\"Returns the number of nodes reachable from u with weight <= maxWeight.\"\"\"\n    res = 1\n    seen.add(u)\n    for v, w in reversedGraph[u]:\n      if w > maxWeight or v in seen:\n        continue\n      res += self._dfs(reversedGraph, v, maxWeight, seen)\n    return res",
      "title": "3419. Minimize the Maximum Edge Weight of Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e000bfd2-b6cd-4149-bf88-92f1e2e8600f",
      "code": "class Solution:\n  def countNonDecreasingSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    cost = 0\n    # Store (number, count) pairs in non-increasing order. The numbers in the\n    # queue represent what nums[i..j] look like after adjustments.\n    dq = collections.deque()\n\n    j = len(nums) - 1\n    for i, num in reversed(list(enumerate(nums))):\n      count = 1\n      while dq and dq[-1][0] < num:\n        nextNum, nextCount = dq.pop()\n        count += nextCount\n        cost += (num - nextNum) * nextCount  # Adjust `nextNum`s to `num`.\n      dq.append((num, count))\n      while cost > k:  # Remove the rightmost number.\n        rightmostNum, rightmostCount = dq.popleft()\n        cost -= (rightmostNum - nums[j])\n        j -= 1\n        if rightmostCount > 1:\n          dq.appendleft((rightmostNum, rightmostCount - 1))\n      ans += j - i + 1\n\n    return ans",
      "title": "3420. Count Non-Decreasing Subarrays After K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "928653b3-68a9-4b80-8698-0e0b060d397e",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    window = SortedList(nums[:k])\n    median = window[(k - 1) // 2]\n    ops = sum(abs(median - nums[j]) for j in range(k))\n    ans = ops\n\n    for i in range(k, len(nums)):\n      window.remove(nums[i - k])\n      window.add(nums[i])\n      ops -= abs(median - nums[i - k])\n      ops += abs(median - nums[i])\n      newMedian = window[(k - 1) // 2]\n      medianMultiplier = (\n          2\n          if k % 2 == 0 and median <= newMedian <= window[k // 2]\n          else k % 2)\n      ops -= abs(newMedian - median) * medianMultiplier\n      median = newMedian\n      ans = min(ans, ops)\n\n    return ans",
      "title": "3422. Minimum Operations to Make Subarray Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242736fa-880d-4eb9-aa2c-fdfaf8c29dc3",
      "code": "class Solution:\n  def maxAdjacentDistance(self, nums: list[int]) -> int:\n    return max(abs(nums[i] - nums[i - 1])\n               for i in range(len(nums)))",
      "title": "3423. Maximum Difference Between Adjacent Elements in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5c0a1c-52b3-4997-8290-af70251f0f21",
      "code": "class Solution:\n  def minCost(self, arr: list[int], brr: list[int], k: int) -> int:\n    def cost(arr: list[int], brr: list[int]) -> int:\n      return sum(abs(a - b) for a, b in zip(arr, brr))\n    return min(cost(arr, brr), cost(sorted(arr), sorted(brr)) + k)",
      "title": "3424. Minimum Cost to Make Arrays Identical",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc6fdb3-6fbd-4b39-8072-11e6b9aa4655",
      "code": "class Solution:\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: int,\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n      leftBoundary = max(leftBoundary, prevDepth)\n\n      length = prefix[-1] - prefix[leftBoundary]\n      nodes = len(prefix) - leftBoundary\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=0)\n    return [maxLength, minNodes]",
      "title": "3425. Longest Special Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2b12161-df85-4d25-8916-7e3aff6f6136",
      "code": "class Solution:\n  def distanceSum(self, m: int, n: int, k: int) -> int:\n    # For each distance d, where 1 < d < m, there are `m - d` ways to choose\n    # the two columns that the two pieces are on. For each of the two pieces,\n    # there are `n` ways to choose the row that the piece is on.\n    # Therefore, the contribution of row differences is\n    #   sum(d * (m - d) * n^2), where 1 < d <= m - 1\n    # = n^2 * sum(d * m - d^2)\n    # = n^2 * (d * m * (m - 1) / 2 - m * (m - 1) * (2m - 1) / 6)\n    # = n^2 * (m^3 - m) / 6\n    # Similarly, the contribution of column differences is\n    #   m^2 * (n^3 - n) / 6\n    MOD = 1_000_000_007\n    return (n**2 * (m**3 - m) // 6 +\n            m**2 * (n**3 - n) // 6) * math.comb(m * n - 2, k - 2) % MOD",
      "title": "3426. Manhattan Distances of All Arrangements of Pieces",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1da620cb-7ad8-49b0-bd71-60745973ae32",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int]) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n    return sum(prefix[i + 1] - prefix[max(0, i - num)]\n               for i, num in enumerate((nums)))",
      "title": "3427. Sum of Variable Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0893d478-359b-43f6-a5d5-931ddb939b06",
      "code": "class Solution:\n  def minMaxSums(self, nums: list[int], k: int) -> int:\n    # In a sorted array, nums[i] will be\n    #   1. The maximum for subsequences formed by nums[0..i].\n    #   2. The minimum for subsequences formed by nums[i..n - 1].\n    #\n    # The number of times nums[i] is the maximum is the same as the number of\n    # times nums[n - 1 - i] is the minimum, due to the symmetry in subsequences\n    # derived from the sorted order.\n    #\n    # To calculate the contribution of nums[i], we need to find the number of\n    # ways to select at most (k - 1) elements from the range of indices where\n    # nums[i] is the smallest or nums[n - 1 - i] is the largest.\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getComb(n: int, k: int) -> list[list[int]]:\n      \"\"\"C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\"\"\"\n      comb = [[0] * (k + 1) for _ in range(n + 1)]\n      for i in range(n + 1):\n        comb[i][0] = 1\n      for i in range(1, n + 1):\n        for j in range(1, k + 1):\n          comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD\n      return comb\n\n    comb = getComb(n, k - 1)\n    ans = 0\n\n    nums.sort()\n\n    # i: available numbers from the left of nums[i] or\n    #    available numbers from the right of nums[-1 - i]\n    for i in range(n):\n      count = 0\n      for j in range(k):  # selected numbers\n        count = (count + comb[i][j]) % MOD\n      ans += nums[i] * count\n      ans += nums[-1 - i] * count\n      ans %= MOD\n\n    return ans",
      "title": "3428. Maximum and Minimum Sums of at Most Size K Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c8ccab1-53d0-422c-b189-45bfbbdce792",
      "code": "class Solution:\n  def minCost(self, n: int, costs: list[list[int]]) -> int:\n    INVALID_COLOR = 3\n\n    def getValidColors(prevColor: int) -> list[int]:\n      return [color for color in range(3) if color != prevColor]\n\n    @functools.lru_cache(None)\n    def minCost(i: int, prevLeftColor: int, prevRightColor: int) -> int:\n      if i == len(costs) // 2:\n        return 0\n      res = math.inf\n      for leftColor in getValidColors(prevLeftColor):\n        for rightColor in getValidColors(prevRightColor):\n          if leftColor == rightColor:\n            continue\n          leftCost = costs[i][leftColor]\n          rightCost = costs[-1 - i][rightColor]\n          res = min(res, leftCost + rightCost +\n                    minCost(i + 1, leftColor, rightColor))\n      return res\n\n    return minCost(0, INVALID_COLOR, INVALID_COLOR)",
      "title": "3429. Paint House IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2cda09f-6c94-4c80-93e3-36242fec7954",
      "code": "class Solution:\n  # Similar to 2104. Sum of Subarray Ranges\n  def minMaxSubarraySum(self, nums: list[int], k: int) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return (self._subarraySum(nums, prevGt, nextGt, k) +\n            self._subarraySum(nums, prevLt, nextLt, k))\n\n  def _subarraySum(\n      self,\n      nums: list[int],\n      prev: list[int],\n      next: list[int],\n      k: int\n  ) -> int:\n    \"\"\"\n    Returns the sum of all subarrays with a size <= k, The `prev` and `next`\n    arrays are used to store the indices of the nearest numbers that are\n    smaller or larger than the current number, respectively.\n    \"\"\"\n    res = 0\n    for i, num in enumerate(nums):\n      l = min(i - prev[i], k)\n      r = min(next[i] - i, k)\n      extra = max(0, l + r - 1 - k)\n      res += num * (l * r - extra * (extra + 1) // 2)\n    return res\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "3430. Maximum and Minimum Sums of at Most Size K Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "498a875c-cccd-4e16-ac7d-6691c136a9aa",
      "code": "class Solution:\n  def minUnlockedIndices(self, nums: list[int], locked: list[int]) -> int:\n    first2 = next((i for i, x in enumerate(nums) if x == 2), -1)\n    first3 = next((i for i, x in enumerate(nums) if x == 3), -1)\n    last1 = next((i for i, x in reversed(list(enumerate(nums))) if x == 1), -1)\n    last2 = next((i for i, x in reversed(list(enumerate(nums))) if x == 2), -1)\n    if first3 != -1 and last1 != -1 and first3 < last1:\n      return -1\n    return (sum(locked[i] == 1 for i in range(first2, last1)\n                if first2 != -1 and last1 != -1) +\n            sum(locked[i] == 1 for i in range(first3, last2)\n                if first3 != -1 and last2 != -1))",
      "title": "3431. Minimum Unlocked Indices to Sort Nums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a395ed5-b238-48b4-89da-509e2c77bcd9",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int]) -> int:\n    # If we add the same number in the left subarray and remove it from the\n    # right subarray, then the difference remains the same parity. So, just\n    # return the number of ways to partition the array into two subarrays when\n    # the array sum is even.\n    return len(nums) - 1 if sum(nums) % 2 == 0 else 0",
      "title": "3432. Count Partitions with Even Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc8318bf-faf2-434e-ba76-6e53df1ab5c3",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass OfflineUser:\n  returnTimestamp: int\n  userId: int\n\n  def __lt__(self, other):\n    return self.returnTimestamp < other.returnTimestamp\n\n\nclass Solution:\n  def countMentions(\n      self,\n      numberOfUsers: int,\n      events: list[list[str]]\n  ) -> list[int]:\n    ans = [0] * numberOfUsers\n    online = [True] * numberOfUsers\n    offlineQueue = []  # min-heap to track users that are offline\n    allMentionsCount = 0\n\n    events.sort(key=lambda x: (int(x[1]), -ord(x[0][0])))\n\n    for eventType, t, messageContent in events:\n      timestamp = int(t)\n      # Bring users back online if their offline period has ended.\n      while offlineQueue and offlineQueue[0].returnTimestamp <= timestamp:\n        user = heapq.heappop(offlineQueue)\n        online[user.userId] = True\n      if eventType == \"MESSAGE\":\n        match messageContent:\n          case \"ALL\":\n            allMentionsCount += 1\n          case \"HERE\":\n            for userId in range(numberOfUsers):\n              if online[userId]:\n                ans[userId] += 1\n          case _:\n            for userId in [int(part[2:]) for part in messageContent.split()]:\n              ans[userId] += 1\n      elif eventType == \"OFFLINE\":\n        userId = int(messageContent)\n        online[userId] = False\n        # Add to queue to bring back online after 60 units.\n        heapq.heappush(offlineQueue, OfflineUser(timestamp + 60, userId))\n\n    # Add the \"ALL\" mentions to all users.\n    for userId in range(numberOfUsers):\n      ans[userId] += allMentionsCount\n    return ans",
      "title": "3433. Count Mentions Per User",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5d0da9f-52d5-4480-8346-6c029f821221",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    return nums.count(k) + max(self._kadane(nums, target, k)\n                               for target in range(1, 51)\n                               if target != k)\n\n  def _kadane(self, nums: list[int], target: int, k: int) -> int:\n    \"\"\"\n    Returns the maximum achievable frequency of `k` by Kakane's algorithm,\n    where each `target` in subarrays is transformed to `k`.\n    \"\"\"\n    maxSum = 0\n    sum = 0\n    for num in nums:\n      if num == target:\n        sum += 1\n      elif num == k:\n        sum -= 1\n      if sum < 0:  # Reset sum if it becomes negative (Kadane's spirit).\n        sum = 0\n      maxSum = max(maxSum, sum)\n    return maxSum",
      "title": "3434. Maximum Frequency After Subarray Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63f29945-fac5-4007-9318-c7b7eef6d3ab",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def supersequences(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    edges = [(string.ascii_lowercase.index(words[0]),\n              string.ascii_lowercase.index(words[1]))\n             for words in words]\n    nodes = sorted({u for u, _ in edges} | {v for _, v in edges})\n    letterToIndex = {letter: i for i, letter in enumerate(nodes)}\n    graph = [[] for _ in range(len(nodes))]\n\n    for u, v in edges:\n      graph[letterToIndex[u]].append(letterToIndex[v])\n\n    for doubledSubset in self._getMinimumSubsets(graph):\n      freq = [0] * 26\n      for letter in nodes:\n        freq[letter] = 1\n      for index in doubledSubset:\n        freq[nodes[index]] = 2\n      ans.append(freq)\n\n    return ans\n\n  def _getMinimumSubsets(self, graph: list[list[int]]) -> list[tuple[int]]:\n    \"\"\"\n    Returns a list of the minimum subsets of nodes that do not create a cycle\n    when skipped.\n    \"\"\"\n    n = len(graph)\n    for subsetSize in range(n + 1):\n      doubleSubsets = []\n      for doubledSubset in itertools.combinations(range(n), subsetSize):\n        if not self._hasCycleSkipping(graph, set(doubledSubset)):\n          doubleSubsets.append(doubledSubset)\n      if doubleSubsets:\n        return doubleSubsets\n    return []\n\n  def _hasCycleSkipping(\n      self,\n      graph: list[list[int]],\n      doubledSubset: set[int]\n  ) -> bool:\n    \"\"\"\n    Returns True if there is a cycle in the `graph` when skipping any edges\n    whose both endpoints are in `doubledSubset`.\n    \"\"\"\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if u not in doubledSubset:\n        for v in graph[u]:\n          if v in doubledSubset:\n            continue\n          if hasCycle(v):\n            return True\n      states[u] = State.VISITED\n      return False\n\n    return any(hasCycle(i) for i in range(len(graph)))",
      "title": "3435. Frequencies of Shortest Supersequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1042236-a4ef-44e0-aa27-39328f71c84f",
      "code": "class Solution:\n  def permute(self, n: int) -> list[list[int]]:\n    ans = []\n    used = [False] * (n + 1)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == n:\n        ans.append(path.copy())\n        return\n      for num in range(1, n + 1):\n        if used[num]:\n          continue\n        if path and path[-1] % 2 == num % 2:\n          continue\n        used[num] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[num] = False\n\n    dfs([])\n    return ans",
      "title": "3437. Permutations III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f35fa2c2-b004-47da-98c6-6f90b78640d2",
      "code": "class Solution:\n  def findValidPair(self, s: str) -> str:\n    count = collections.Counter(s)\n    return next((a + b\n                for a, b in itertools.pairwise(s)\n                if a != b and count[a] == int(a) and count[b] == int(b)), '')",
      "title": "3438. Find Valid Pair of Adjacent Digits in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4604d159-72ee-4a0b-bb3e-67be68b68b35",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      k: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    windowSum = sum(gaps[:k + 1])\n    ans = windowSum\n\n    for i in range(k + 1, len(gaps)):\n      windowSum += gaps[i] - gaps[i - k - 1]\n      ans = max(ans, windowSum)\n\n    return ans",
      "title": "3439. Reschedule Meetings for Maximum Free Time I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "549910b7-29d6-4996-9068-0d5394438496",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    n = len(startTime)\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    ans = 0\n    maxLeft = [gaps[0]] + [0] * n  # maxLeft[i] := max(gaps[0..i])\n    maxRight = [0] * n + [gaps[n]]  # maxRight[i] := max(gaps[i..n])\n\n    for i in range(1, n + 1):\n      maxLeft[i] = max(gaps[i], maxLeft[i - 1])\n\n    for i in range(n - 1, -1, -1):\n      maxRight[i] = max(gaps[i], maxRight[i + 1])\n\n    for i, (start, end) in enumerate(zip(startTime, endTime)):\n      currMeetingTime = end - start\n      adjacentGapsSum = gaps[i] + gaps[i + 1]\n      canMoveMeeting = currMeetingTime <= max(\n          maxLeft[i - 1] if i > 0 else 0,\n          maxRight[i + 2] if i + 2 < n + 1 else 0\n      )\n      ans = max(ans, adjacentGapsSum +\n                (currMeetingTime if canMoveMeeting else 0))\n\n    return ans",
      "title": "3440. Reschedule Meetings for Maximum Free Time II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83a48273-ab5e-4e83-a531-483bfef907c2",
      "code": "class Solution:\n\n  def minCostGoodCaption(self, caption: str) -> str:\n    n = len(caption)\n    if n < 3:\n      return ''\n\n    MAX_COST = 1_000_000_000\n    # dp[i][j][k] := the minimum cost of caption[i..n - 1], where j is the last\n    # letter used, and k is the count of consecutive letters\n    dp = [[[MAX_COST] * 3 for _ in range(26)] for _ in range(n)]\n\n    for c in range(26):\n      dp[-1][c][0] = abs(string.ascii_lowercase.index(caption[-1]) - c)\n\n    minCost = MAX_COST\n\n    for i in range(n - 2, -1, -1):\n      newMinCost = MAX_COST\n      for c in range(26):\n        changeCost = abs(string.ascii_lowercase.index(caption[i]) - c)\n        dp[i][c][0] = changeCost + minCost\n        dp[i][c][1] = changeCost + dp[i + 1][c][0]\n        dp[i][c][2] = changeCost + min(dp[i + 1][c][1], dp[i + 1][c][2])\n        newMinCost = min(newMinCost, dp[i][c][2])\n      minCost = newMinCost\n\n    # Reconstruct the string.\n    ans = []\n    cost = MAX_COST\n    letter = -1\n\n    # Find the initial best letter.\n    for c in range(25, -1, -1):\n      if dp[0][c][2] <= cost:\n        letter = c\n        cost = dp[0][c][2]\n\n    # Add the initial triplet.\n    cost -= self._appendLetter(caption, 0, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 1, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 2, chr(ord('a') + letter), ans)\n\n    # Build the rest of the string.\n    i = 3\n    while i < n:\n      nextLetter = self._getNextLetter(dp, i, cost)\n      if nextLetter < letter or min(dp[i][letter]) > cost:\n        letter = nextLetter\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 1, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 2, chr(ord('a') + letter), ans)\n        i += 3\n      else:\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        i += 1\n\n    return ''.join(ans)\n\n  def _getNextLetter(self, dp: list[list[list[int]]], i: int, cost: int) -> int:\n    nextLetter = 26\n    for c in range(25, -1, -1):\n      if cost == dp[i][c][2]:\n        nextLetter = c\n    return nextLetter\n\n  def _appendLetter(\n      self,\n      caption: str,\n      i: int,\n      letter: str,\n      ans: list[str]\n  ) -> int:\n    ans.append(letter)\n    return abs(ord(caption[i]) - ord(letter))",
      "title": "3441. Minimum Cost Good Caption",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f2e2c41-d3b9-46c9-9d56-7c0cf0c8e389",
      "code": "class Solution:\n  def maxDifference(self, s: str) -> int:\n    count = collections.Counter(s)\n    maxOdd = max((freq for freq in count.values()\n                  if freq % 2 == 1), default=0)\n    minEven = min((freq for freq in count.values()\n                   if freq % 2 == 0), default=len(s))\n    return maxOdd - minEven",
      "title": "3442. Maximum Difference Between Even and Odd Frequency I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f24b274e-c049-420f-ba56-48bfdac84ce8",
      "code": "class Solution:\n  def maxDistance(self, s: str, k: int) -> int:\n    return max(self._flip(s, k, 'NE'), self._flip(s, k, 'NW'),\n               self._flip(s, k, 'SE'), self._flip(s, k, 'SW'))\n\n  def _flip(self, s: str, k: int, direction: str) -> int:\n    res = 0\n    pos = 0\n    opposite = 0\n\n    for c in s:\n      if c in direction:\n        pos += 1\n      else:\n        pos -= 1\n        opposite += 1\n      res = max(res, pos + 2 * min(k, opposite))\n\n    return res",
      "title": "3443. Maximum Manhattan Distance After K Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbd13d8c-b7a2-48c4-bb74-ab3e12215c14",
      "code": "class Solution:\n  def minimumIncrements(self, nums: list[int], target: list[int]) -> int:\n    maxMask = 1 << len(target)\n    maskToLcm = {}\n\n    for mask in range(1, maxMask):\n      subset = [num for i, num in enumerate(target) if mask >> i & 1]\n      maskToLcm[mask] = functools.reduce(math.lcm, subset, 1)\n\n    # dp[mask] := the minimum number of increments to make each number in the\n    # subset of target have at least one number that is a multiple in `num`,\n    # where `mask` is the bitmask of the subset of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for num in nums:\n      # maskToCost := (mask, cost), where `mask` is the bitmask of the subset\n      # of target and `cost` is the minimum number of increments to make each\n      # number in the subset of target have at least one number that is a\n      # multiple in `num`\n      maskToCost = [\n          (mask, 0 if (remainder := num % lcm) == 0 else lcm - remainder) for mask,\n          lcm in maskToLcm.items()]\n      newDp = dp[:]\n      for prevMask in range(maxMask):\n        if dp[prevMask] == float('inf'):\n          continue\n        for mask, cost in maskToCost:\n          newMask = prevMask | mask\n          newDp[newMask] = min(newDp[newMask], dp[prevMask] + cost)\n      dp = newDp\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "3444. Minimum Increments for Target Multiples in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c90bc3c-de44-4bd1-848c-2df42b5ce52a",
      "code": "class Solution:\n  def maxDifference(self, s: str, k: int) -> int:\n    ans = -math.inf\n    permutations = [(a, b) for a in '01234' for b in '01234' if a != b]\n\n    for a, b in permutations:\n      # minDiff[(parityA, parityB)] := min(a - b) of all valid windows with\n      # parityA and parityB\n      minDiff = collections.defaultdict(lambda: math.inf)\n      prefixA = [0]  # prefixA[i] := the number of 'a's in s[0..i)\n      prefixB = [0]  # prefixB[i] := the number of 'b's in s[0..i)\n\n      l = 0\n      for r, c in enumerate(s):\n        prefixA.append(prefixA[-1] + int(c == a))\n        prefixB.append(prefixB[-1] + int(c == b))\n        while (r - l + 1 >= k and  # the window size >= k\n               prefixA[l] < prefixA[-1] and  # the number of 'a's > 0\n               prefixB[l] < prefixB[-1]):  # the number of 'b's > 0\n          paritiesKey = (prefixA[l] % 2, prefixB[l] % 2)\n          minDiff[paritiesKey] = min(minDiff[paritiesKey],\n                                     prefixA[l] - prefixB[l])\n          l += 1\n        ans = max(ans, (prefixA[-1] - prefixB[-1]) -\n                  minDiff[(1 - prefixA[-1] % 2, prefixB[-1] % 2)])\n\n    return ans",
      "title": "3445. Maximum Difference Between Even and Odd Frequency II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e3aaec2-a17d-4287-b9a2-0764fd3ba5c0",
      "code": "class Solution:\n  def sortMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * n for _ in range(n)]\n    diag = collections.defaultdict(list)\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        diag[i - j].append(num)\n\n    for key in diag:\n      diag[key].sort(reverse=key < 0)\n\n    for i in range(n):\n      for j in range(n):\n        ans[i][j] = diag[i - j].pop()\n\n    return ans",
      "title": "3446. Sort Matrix by Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3da5880-55ad-4771-88dd-f66fa672a20d",
      "code": "class Solution:\n  def assignElements(self, groups: list[int], elements: list[int]) -> list[int]:\n    ans = []\n    elementToMinIndex = {}\n\n    for i, element in enumerate(elements):\n      if element not in elementToMinIndex:\n        elementToMinIndex[element] = i\n\n    for num in groups:\n      ans.append(self._getMinIndex(num, elementToMinIndex))\n\n    return ans\n\n  def _getMinIndex(self, num: int, elementToMinIndex: dict[int, int]) -> int:\n    res = math.inf\n    i = 1\n    while i * i <= num:\n      if num % i != 0:\n        continue\n      if i in elementToMinIndex:\n        res = min(res, elementToMinIndex[i])\n      if num // i != i and (num // i) in elementToMinIndex:\n        res = min(res, elementToMinIndex[num // i])\n      i += 1\n    return -1 if res == math.inf else res",
      "title": "3447. Assign Elements to Groups with Constraints",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58831607-b627-4b1b-834f-8910713d1444",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    ans = 0\n    # dp[i][num][rem] := the number of first `i` digits of s that have a\n    # remainder of `rem` when divided by `num`\n    dp = [[[0] * 10 for _ in range(10)] for _ in range(len(s) + 1)]\n\n    for i in range(1, len(s) + 1):\n      digit = int(s[i - 1])\n      for num in range(1, 10):\n        for rem in range(num):\n          dp[i][num][(rem * 10 + digit) % num] += dp[i - 1][num][rem]\n        dp[i][num][digit % num] += 1\n      ans += dp[i][digit][0]\n\n    return ans",
      "title": "3448. Count Substrings Divisible By Last Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60c09d5f-2863-4d59-bb4d-5fdbd3168f48",
      "code": "class Solution:\n  def maxScore(self, points: list[int], m: int) -> int:\n    def isPossible(minVal: int, m: int) -> bool:\n      \"\"\"\n      Returns True if it is possible to achieve the maximum minimum value `x`\n      with `m` number of moves.\n      \"\"\"\n      moves = 0\n      prevMoves = 0  # to track remaining moves from the previous point\n      for i, point in enumerate(points):\n        required = (minVal + point - 1) // point  # ceil(minVal / point)\n        required = max(0, required - prevMoves)\n        if required > 0:\n          moves += 2 * required - 1\n          prevMoves = required - 1\n        elif i + 1 < len(points):\n          moves += 1\n          prevMoves = 0\n        if moves > m:\n          return False\n      return True\n\n    l = 0\n    r = (m + 1) // 2 * points[0] + 1\n\n    while l < r:\n      mid = (l + r + 1) // 2\n      if isPossible(mid, m):\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "3449. Maximize the Minimum Game Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5972de3d-df80-432f-a16e-962d1cb03009",
      "code": "class Solution:\n  def maxStudentsOnBench(self, students: list[list[int]]) -> int:\n    benchToStudents = collections.defaultdict(set)\n    for studentId, benchId in students:\n      benchToStudents[benchId].add(studentId)\n    return max(map(len, benchToStudents.values()), default=0)",
      "title": "3450. Maximum Students on a Single Bench",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "465ee2bf-a507-482a-8f02-44e32c00523f",
      "code": "class Solution:\n  def sumOfGoodNumbers(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if (i - k < 0 or num > nums[i - k])\n               and (i + k >= len(nums) or num > nums[i + k]))",
      "title": "3452. Sum of Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cbbee1c-bd67-4bc8-804a-c0a3f51cd624",
      "code": "class Solution:\n  def separateSquares(self, squares: list[list[int]]) -> float:\n    halfArea = sum((l**2 for _, _, l in squares)) / 2\n    events = sorted([(y, True, l) for _, y, l in squares] +\n                    [(y + l, False, l) for _, y, l in squares])\n    area = 0\n    width = 0\n    prevY = 0\n\n    for y, isStart, l in events:\n      areaGain = width * (y - prevY)\n      if area + areaGain >= halfArea:\n        return prevY + (halfArea - area) / width\n      area += areaGain\n      width += l if isStart else -l\n      prevY = y",
      "title": "3453. Separate Squares I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9640e65-a4d8-467a-b2f5-a719fb5bad89",
      "code": "class Solution:\n  def shortestMatchingSubstring(self, s: str, p: str) -> int:\n    n = len(s)\n    a, b, c = p.split('*')\n    lpsA = self._getLPS(a + '#' + s)[len(a) + 1:]\n    lpsB = self._getLPS(b + '#' + s)[len(b) + 1:]\n    lpsC = self._getLPS(c + '#' + s)[len(c) + 1:]\n    ans = math.inf\n\n    i = 0  # lpsA's index\n    j = 0  # lpsB's index\n    k = 0  # lpsC's index\n    while i + len(b) + len(c) < n:\n      while i < n and lpsA[i] != len(a):\n        i += 1\n      while j < n and (j < i + len(b) or lpsB[j] != len(b)):\n        j += 1\n      while k < n and (k < j + len(c) or lpsC[k] != len(c)):\n        k += 1\n      if k == n:\n        break\n      ans = min(ans, k - i + len(a))\n      i += 1\n\n    return -1 if ans == math.inf else ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3455. Shortest Matching Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89da81b5-21a2-496a-ab46-353d3fa326dd",
      "code": "class Solution:\n  def hasSpecialSubstring(self, s: str, k: int) -> bool:\n    return any(len(list(group)) == k for _, group in groupby(s))",
      "title": "3456. Find Special Substring of Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3140091c-aa85-4620-8a38-7dd419b04fd6",
      "code": "class Solution:\n  def maxWeight(self, pizzas: list[int]) -> int:\n    eat = len(pizzas) // 4\n    odd = math.ceil(eat / 2)\n    even = eat - odd\n    pizzas.sort(reverse=True)\n    return (sum(pizzas[:odd]) +\n            sum(pizzas[odd + 1:odd + 1 + even * 2:2]))",
      "title": "3457. Eat Pizzas!",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9988be9c-15c7-4755-bb5c-77a5d20b4d88",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str, k: int) -> bool:\n    n = len(s)\n    first = [n] * 26\n    last = [-1] * 26\n    # dp[i] := the maximum disjoint special substrings for the first i letters\n    dp = [0] * (n + 1)\n    seenOrder = []\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if first[a] == n:\n        first[a] = i\n        seenOrder.append(c)\n      last[a] = i\n\n    for c in seenOrder:\n      a = ord(c) - ord('a')\n      for j in range(first[a], last[a]):\n        b = ord(s[j]) - ord('a')\n        first[a] = min(first[a], first[b])\n        last[a] = max(last[a], last[b])\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if last[a] != i or (first[a] == 0 and i == n - 1):\n        dp[i + 1] = dp[i]\n      else:  # Start a new special substring.\n        dp[i + 1] = max(dp[i], 1 + dp[first[a]])\n\n    return dp[n] >= k",
      "title": "3458. Select K Disjoint Special Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79fad4a8-55b3-4e9b-9b2d-20ba843859dc",
      "code": "class Solution:\n  def lenOfVDiagonal(self, grid: list[list[int]]) -> int:\n    DIRS = ((-1, 1), (1, 1), (1, -1), (-1, -1))\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, turned: bool, num: int, dir: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != num:\n        return 0\n\n      nextNum = 0 if num == 2 else 2\n      dx, dy = DIRS[dir]\n      res = 1 + dfs(i + dx, j + dy, turned, nextNum, dir)\n\n      if not turned:\n        nextDir = (dir + 1) % 4\n        nextDx, nextDy = DIRS[nextDir]\n        res = max(res, 1 + dfs(i + nextDx, j + nextDy, 1, nextNum, nextDir))\n\n      return res\n\n    return max((1 + dfs(i + dx, j + dy, 0, 2, d)\n                for i, row in enumerate(grid)\n                for j, num in enumerate(row)\n                if num == 1\n                for d, (dx, dy) in enumerate(DIRS)),\n               default=0)",
      "title": "3459. Length of Longest V-Shaped Diagonal Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "006209bd-4d33-4c9c-bbc3-432cf48d3d6d",
      "code": "class Solution:\n  def longestCommonPrefix(self, s: str, t: str) -> int:\n    i = 0  # s's index\n    j = 0  # t's index\n    canSkip = True\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        i += 1\n        j += 1\n      elif canSkip:\n        i += 1\n        canSkip = False\n      else:\n        return j\n\n    return j",
      "title": "3460. Longest Common Prefix After at Most One Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a03dbdb-41d4-45dd-b738-f712f59ccea4",
      "code": "class Solution:\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3461. Check If Digits Are Equal in String After Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7760489-8735-4788-925e-fb7679ceb8b4",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]], limits: list[int], k: int) -> int:\n    minHeap = []\n\n    for row, limit in zip(grid, limits):\n      row.sort(reverse=True)\n      for i in range(limit):\n        heapq.heappush(minHeap, row[i])\n        if len(minHeap) == k + 1:\n          heapq.heappop(minHeap)\n\n    return sum(minHeap)",
      "title": "3462. Maximum Sum With at Most K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f679db2-81ae-46df-88ef-68fe1e6b8774",
      "code": "class Solution:\n  # Same as 3461. Check If Digits Are Equal in String After Operations I\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3463. Check If Digits Are Equal in String After Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66ec43af-b110-4213-8ed7-b05fe93bb9fe",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Sequence:\n  startX: int\n  startY: int\n  endX: int\n  endY: int\n  length: int\n\n  def __iter__(self):\n    yield self.startX\n    yield self.startY\n    yield self.endX\n    yield self.endY\n    yield self.length\n\n\nclass Solution:\n  def maxDistance(self, side: int, points: list[list[int]], k: int) -> int:\n    ordered = self._getOrderedPoints(side, points)\n\n    def isValidDistance(m: int) -> bool:\n      \"\"\"\n      Returns True if we can select `k` points such that the minimum Manhattan\n      distance between any two consecutive chosen points is at least `m`.\n      \"\"\"\n      dq = collections.deque([Sequence(*ordered[0], *ordered[0], 1)])\n      maxLength = 1\n\n      for i in range(1, len(ordered)):\n        x, y = ordered[i]\n        startX, startY = ordered[i]\n        length = 1\n        while dq and abs(x - dq[0].endX) + abs(y - dq[0].endY) >= m:\n          if (abs(x - dq[0].startX) + abs(y - dq[0].startY) >= m\n                  and dq[0].length + 1 >= length):\n            startX = dq[0].startX\n            startY = dq[0].startY\n            length = dq[0].length + 1\n            maxLength = max(maxLength, length)\n          dq.popleft()\n        dq.append(Sequence(startX, startY, x, y, length))\n\n      return maxLength >= k\n\n    l = 0\n    r = side\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if isValidDistance(m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _getOrderedPoints(self, side: int, points: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Returns the ordered points on the perimeter of a square of side length\n    `side`, starting from left, top, right, and bottom boundaries.\n    \"\"\"\n    left = sorted([(x, y) for x, y in points if x == 0 and y > 0])\n    top = sorted([(x, y) for x, y in points if x > 0 and y == side])\n    right = sorted([(x, y) for x, y in points if x == side and y < side],\n                   reverse=True)\n    bottom = sorted([(x, y) for x, y in points if y == 0], reverse=True)\n    return left + top + right + bottom",
      "title": "3464. Maximize the Distance Between Points on a Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242985ea-b789-49e0-a746-bd7152340866",
      "code": "class Solution:\n  def maxCoins(self, lane1: list[int], lane2: list[int]) -> int:\n    n = len(lane1)\n    # dp[i][k] := the maximum number of coins at i-th mile with k switches\n    dp = [[-math.inf] * 3 for _ in range(n)]\n    dp[0][0] = lane1[0]\n    dp[0][1] = lane2[0]\n\n    for i in range(1, n):\n      dp[i][0] = max(0, dp[i - 1][0]) + lane1[i]\n      dp[i][1] = max(0, dp[i - 1][0], dp[i - 1][1]) + lane2[i]\n      dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + lane1[i]\n\n    return max(map(max, dp))",
      "title": "3466. Maximum Coin Collection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cd01f89-43c1-40c6-8e80-57e8c80c54e7",
      "code": "class Solution:\n  def transformArray(self, nums: list[int]) -> list[int]:\n    return ([0] * sum(num % 2 == 0 for num in nums) +\n            [1] * sum(num % 2 == 1 for num in nums))",
      "title": "3467. Transform Array by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c83d60cf-0d2f-4f31-8b5e-79e2bbc12965",
      "code": "class Solution:\n  def countArrays(self, original: list[int], bounds: list[list[int]]) -> int:\n    mn, mx = bounds[0]\n\n    for i in range(1, len(original)):\n      diff = original[i] - original[i - 1]\n      mn = max(mn + diff, bounds[i][0])\n      mx = min(mx + diff, bounds[i][1])\n\n    return max(0, mx - mn + 1)",
      "title": "3468. Find the Number of Copy Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "735ac7fc-c8e7-4b99-93ef-ebd55703c564",
      "code": "class Solution:\n  def minCost(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    @functools.lru_cache(None)\n    def dp(last: int, i: int) -> int:\n      if i == n:  # Single element left.\n        return nums[last]\n      if i == n - 1:  # Two elements left.\n        return max(nums[last], nums[i])\n      a = max(nums[i], nums[i + 1]) + dp(last, i + 2)\n      b = max(nums[last], nums[i]) + dp(i + 1, i + 2)\n      c = max(nums[last], nums[i + 1]) + dp(i, i + 2)\n      return min(a, b, c)\n\n    return dp(0, 1)",
      "title": "3469. Find Minimum Cost to Remove Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcd876ec-6f4f-42ff-a894-08bd2ab4dc6d",
      "code": "class Solution:\n  def permute(self, n: int, k: int) -> list[int]:\n    ans = []\n    isLookingForEven = True\n    remainingNumbers = list(range(1, n + 1))\n\n    for turn in range(n):\n      remainingPermutations = (math.factorial((n - 1 - turn) // 2) *\n                               math.factorial((n - turn) // 2))\n      found = False\n      for index, number in enumerate(remainingNumbers):\n        if number % 2 != isLookingForEven and (turn > 0 or n % 2 == 1):\n          continue\n        if k <= remainingPermutations:\n          ans.append(remainingNumbers.pop(index))\n          isLookingForEven = ans[-1] % 2 == 0\n          found = True\n          break\n        k -= remainingPermutations\n      if not found:\n        return []\n\n    return ans",
      "title": "3470. Permutations IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b6f3129-1178-4600-a963-78ad79aaaa13",
      "code": "class Solution:\n  def largestInteger(self, nums: list[int], k: int) -> int:\n    if k == len(nums):\n      return max(nums)\n    count = collections.Counter(nums)\n    if k == 1:\n      return max([num for num in nums if count[num] == 1], default=-1)\n    return max(\n        nums[0] if count[nums[0]] == 1 else -1,\n        nums[-1] if count[nums[-1]] == 1 else -1\n    )",
      "title": "3471. Find the Largest Almost Missing Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "488b2e6d-7b7d-4a58-8c72-836e1ca1cb4d",
      "code": "class Solution:\n  # Similar to 516. Longest Palindromic Subsequence\n  def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i][j][op] := the length of LPS(s[i..j]) with at most `op` operations\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      for op in range(k + 1):\n        dp[i][i][op] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for op in range(k + 1):\n          if s[i] == s[j]:\n            dp[i][j][op] = 2 + dp[i + 1][j - 1][op]\n          else:\n            dp[i][j][op] = max(dp[i + 1][j][op], dp[i][j - 1][op])\n            cost = self._getCost(s[i], s[j])\n            if cost <= op:\n              dp[i][j][op] = max(dp[i][j][op], 2 + dp[i + 1][j - 1][op - cost])\n\n    return dp[0][n - 1][k]\n\n  def _getCost(self, a: str, b: str) -> int:\n    dist = abs(ord(a) - ord(b))\n    return min(dist, 26 - dist)",
      "title": "3472. Longest Palindromic Subsequence After at Most K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82ac9c6c-992d-4013-80b3-0e9268ca5d58",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int, m: int) -> int:\n    INF = 20_000_000\n    n = len(nums)\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    # dp[i][ongoing][r] := the maximum sum of nums[i:], with `ongoing`\n    # indicating if a subarray is currently being extended (1) or not (0),\n    # and `r` segments left to choose\n    dp = [[[-INF] * (k + 1) for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case: At the end of the array, if no segments are left, score is 0\n    dp[n][0][0] = dp[n][1][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for rem in range(k + 1):\n        # When no subarray is ongoing:\n        # 1. Skip nums[i]\n        dp[i][0][rem] = dp[i + 1][0][rem]\n        # 2. Start a new segment of length m (only if rem > 0 and there're enough elements)\n        if rem > 0 and i + m <= n:\n          dp[i][0][rem] = max(\n              dp[i][0][rem],\n              dp[i + m][1][rem - 1] + (prefix[i + m] - prefix[i]))\n        # When a subarray is ongoing:\n        # 1. End the current subarray (transition to state 0, same index i)\n        # 2. Extend the current subarray by picking nums[i] and move to i + 1\n        dp[i][1][rem] = max(dp[i][0][rem], dp[i + 1][1][rem] + nums[i])\n\n    return dp[0][0][k]",
      "title": "3473. Sum of K Subarrays With Length at Least M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fd1486f-5531-45a1-9690-f5b6cde0e69a",
      "code": "class Solution:\n  def generateString(self, str1: str, str2: str) -> str:\n    n = len(str1)\n    m = len(str2)\n    sz = n + m - 1\n    ans = [None] * sz\n    modifiable = [True] * sz\n\n    # 1. Handle all 'T' positions first.\n    for i, tf in enumerate(str1):\n      if tf == 'T':\n        for j, c in enumerate(str2):\n          pos = i + j\n          if ans[pos] and ans[pos] != c:\n            return ''\n          ans[pos] = c\n          modifiable[pos] = False\n\n    # 2. Fill all remaining positions with 'a'.\n    for i in range(sz):\n      if not ans[i]:\n        ans[i] = 'a'\n\n    # 3. Handle all 'F' positions.\n    for i in range(n):\n      if str1[i] == 'F' and self._match(ans, i, str2):\n        modifiablePos = self._lastModifiablePosition(i, m, modifiable)\n        if modifiablePos == -1:\n          return ''\n        ans[modifiablePos] = 'b'\n        modifiable[modifiablePos] = False\n\n    return ''.join(ans)\n\n  def _match(self, ans: list, i: int, s: str) -> bool:\n    \"\"\"Returns True if the substring of ans starting at `i` matches `s`.\"\"\"\n    for j, c in enumerate(s):\n      if ans[i + j] != c:\n        return False\n    return True\n\n  def _lastModifiablePosition(self, i: int, m: int, modifiable: list) -> int:\n    \"\"\"\n    Finds the last modifiable position in the substring of ans starting at `i`.\n    \"\"\"\n    modifiablePos = -1\n    for j in range(m):\n      pos = i + j\n      if modifiable[pos]:\n        modifiablePos = pos\n    return modifiablePos",
      "title": "3474. Lexicographically Smallest Generated String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e81bcb71-5b94-4cfa-8bb1-720a20cdfd2c",
      "code": "class Solution:\n  def maxProfit(self, workers: list[int], tasks: list[list[int]]) -> int:\n    totalProfit = 0\n    skillToProfits = collections.defaultdict(list)\n\n    for skill, profit in tasks:\n      skillToProfits[skill].append(profit)\n\n    for skill in skillToProfits:\n      skillToProfits[skill].sort(reverse=True)\n\n    for workerSkill in workers:\n      if workerSkill in skillToProfits and skillToProfits[workerSkill]:\n        profit = skillToProfits[workerSkill][0]\n        skillToProfits[workerSkill].pop(0)\n        totalProfit += profit\n\n    return totalProfit + max(max(profits, default=0)\n                             for profits in skillToProfits.values())",
      "title": "3476. Maximize Profit from Task Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86868cb6-785d-4831-aba6-faab17720866",
      "code": "class Solution:\n  def findMaxSum(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    ans = [0] * len(nums1)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums1)])\n    minHeap = []\n\n    firstIndex = numAndIndexes[0][1]\n    heapq.heappush(minHeap, nums2[firstIndex])\n    summ = nums2[firstIndex]\n\n    for (prevNum, prevIndex), (currNum, currIndex) in itertools.pairwise(numAndIndexes):\n      if currNum == prevNum:\n        ans[currIndex] = ans[prevIndex]\n      else:\n        ans[currIndex] = summ\n      heapq.heappush(minHeap, nums2[currIndex])\n      summ += nums2[currIndex]\n      if len(minHeap) == k + 1:\n        summ -= heapq.heappop(minHeap)\n\n    return ans",
      "title": "3478. Choose K Elements With Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9ea080f-70ce-4eca-b5f1-e2fc71713983",
      "code": "class Solution:\n  def maxSubarrays(self, n: int, conflictingPairs: list[list[int]]) -> int:\n    validSubarrays = 0\n    maxLeft = 0\n    secondMaxLeft = 0\n    # gains[i] := the number of additional valid subarrays we can gain if the\n    # restriction at index `i` is removed\n    gains = [0] * (n + 1)\n    # conflicts[r] := left endpoints that conflict with subarrays ending in r\n    conflicts = [[] for _ in range(n + 1)]\n\n    for a, b in conflictingPairs:\n      conflicts[max(a, b)].append(min(a, b))\n\n    for right in range(1, n + 1):\n      for left in conflicts[right]:\n        if left > maxLeft:\n          secondMaxLeft = maxLeft\n          maxLeft = left\n        elif left > secondMaxLeft:\n          secondMaxLeft = left\n      # Subarrays [maxLeft + 1..right],\n      #           [maxLeft + 2..right],\n      #           ...\n      #           [right..right] are valid.\n      validSubarrays += right - maxLeft\n      # If we remove `maxLeft` (the most restrictive conflict), we gain\n      # `maxLeft - secondMaxLeft` new subarrays:\n      # [secondMaxLeft + 1..right],\n      # [secondMaxLeft + 2..right],\n      # ...\n      # [maxLeft..right].\n      gains[maxLeft] += maxLeft - secondMaxLeft\n\n    return validSubarrays + max(gains)",
      "title": "3480. Maximize Subarrays After Removing One Conflicting Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed33947e-4f58-45f0-995c-3f551eb32d43",
      "code": "class Solution:\n  def applySubstitutions(self, replacements: list[list[str]], text: str) -> str:\n    replaceMap = {key: value for key, value in replacements}\n\n    def evaluate(text: str) -> str:\n      \"\"\"\n      Evaluates the text and replaces the placeholders with the values\n      from the replace_map recursively.\n      \"\"\"\n      res = []\n      i = 0\n      while i < len(text):\n        if text[i] == '%':\n          j = i + 1 + text[i + 1:].find('%')\n          key = text[i + 1:j]\n          value = replaceMap[key]\n          res.append(evaluate(value))\n          i = j + 1\n        else:\n          res.append(text[i])\n          i += 1\n      return ''.join(res)\n\n    return evaluate(text)",
      "title": "3481. Apply Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d15b70f0-10df-4b79-888b-5409f3fb0512",
      "code": "class Solution:\n  def totalNumbers(self, digits: list[int]) -> int:\n    nums = set()\n\n    for a, b, c in itertools.permutations(digits, 3):\n      if a != 0 and c % 2 == 0:\n        nums.add(a * 100 + b * 10 + c)\n\n    return len(nums)",
      "title": "3483. Unique 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c05f8e47-c4bc-4054-97c1-c43451bde2df",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self, k: int):\n    self.k = k\n    self.root = TrieNode()\n    self.prefixLengthsCount = collections.Counter()\n    self.prefixLengths = SortedList()\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children.setdefault(c, TrieNode())\n      node.count += 1\n      if node.count >= self.k:\n        self.prefixLengthsCount[sz] += 1\n        if self.prefixLengthsCount[sz] == 1:\n          self.prefixLengths.add(-sz)\n\n  def erase(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children[c]\n      if node.count == self.k:\n        self.prefixLengthsCount[sz] -= 1\n        if self.prefixLengthsCount[sz] == 0:\n          self.prefixLengths.remove(-sz)\n      node.count -= 1\n\n  def getLongestCommonPrefix(self) -> int:\n    return 0 if not self.prefixLengths else -self.prefixLengths[0]\n\n\nclass Solution:\n  def longestCommonPrefix(self, words: list[str], k: int) -> list[int]:\n    ans = []\n    trie = Trie(k)\n\n    for word in words:\n      trie.insert(word)\n\n    for word in words:\n      trie.erase(word)\n      ans.append(trie.getLongestCommonPrefix())\n      trie.insert(word)\n\n    return ans",
      "title": "3485. Longest Common Prefix of K Strings After Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c05fbf67-0429-40f1-843b-61235b29179e",
      "code": "class Solution:\n  # Similar to 3425. Longest Special Path\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: list[int],\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n\n      if prevDepth != 0:\n        leftBoundary = sorted(leftBoundary + [prevDepth])[-2:]\n\n      length = prefix[-1] - prefix[leftBoundary[0]]\n      nodes = len(prefix) - leftBoundary[0]\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=[0, 0])\n    return [maxLength, minNodes]",
      "title": "3486. Longest Special Path II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad6a54a1-0b7e-4d04-ae0c-adc730fc60f2",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    mx = max(nums)\n    if mx <= 0:\n      return mx\n    return sum(max(0, num) for num in set(nums))",
      "title": "3487. Maximum Unique Subarray Sum After Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e8335f3-3c02-4c50-ae9e-236bea3c6157",
      "code": "class Solution:\n  def solveQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    # minDist[i] := the minimum distance between nums[i], and any other index j\n    # in the circular array, where nums[j] == nums[i]\n    minDist = [n] * n\n    lastSeen = {}\n\n    for i in range(n * 2):\n      index = i % n\n      num = nums[index]\n      if num in lastSeen:\n        prevIndex = lastSeen[num] % n\n        d = i - prevIndex\n        minDist[index] = min(minDist[index], d)\n        minDist[prevIndex] = min(minDist[prevIndex], d)\n      lastSeen[num] = i\n\n    return [-1 if minDist[query] == n\n            else minDist[query]\n            for query in queries]",
      "title": "3488. Closest Equal Element Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ade89177-dbbf-45a9-b189-a8e767dc2eb9",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    if all(num == 0 for num in nums):\n      return 0\n\n    n = len(nums)\n    subsetSums = [{0} for _ in range(n)]\n\n    for k, (l, r, val) in enumerate(queries):\n      for i in range(l, r + 1):\n        newSums = {subsetSum + val for subsetSum in subsetSums[i]}\n        subsetSums[i].update(newSums)\n      if all(nums[i] in subsetSums[i] for i in range(n)):\n        return k + 1\n\n    return -1",
      "title": "3489. Zero Array Transformation IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eef1908-3301-4082-816d-33df6d818feb",
      "code": "class Solution:\n  def beautifulNumbers(self, l: int, r: int) -> int:\n    @functools.lru_cache(None)\n    def dp(\n        s: str,\n        i: int,\n        tight: bool,\n        isLeadingZero: bool,\n        hasZero: bool,\n        sum: int,\n        prod: int,\n    ) -> int:\n      if i == len(s):\n        if isLeadingZero:\n          return 0\n        return 1 if hasZero or prod % sum == 0 else 0\n      if not isLeadingZero and hasZero and not tight:\n        return 10 ** (len(s) - i)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        nextIsLeadingZero = isLeadingZero and d == 0\n        nextHasZero = not nextIsLeadingZero and d == 0\n        nextProd = 1 if nextIsLeadingZero else prod * d\n        res += dp(s, i + 1, nextTight, nextIsLeadingZero,\n                  nextHasZero, sum + d, nextProd)\n\n      return res\n\n    return (dp(str(r), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1) -\n            dp(str(l - 1), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1))",
      "title": "3490. Count Beautiful Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29bdecf9-7abd-457c-b3a2-7036906d4319",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, number: str) -> None:\n    node: TrieNode = self.root\n    for d in number:\n      node = node.children.setdefault(d, TrieNode())\n    node.isWord = True\n\n  def search(self, number: str) -> bool:\n    \"\"\"\n    Returns True if the number is a prefix of any number in the trie or any\n    number in the trie is a prefix of the number.\n    \"\"\"\n    node: TrieNode = self.root\n    for d in number:\n      if d not in node.children:\n        return False\n      node = node.children[d]\n      if node.isWord:\n        return True\n    return True  # The number is a prefix of some number in the trie.\n\n\nclass Solution:\n  def phonePrefix(self, numbers: list[str]) -> bool:\n    trie = Trie()\n\n    for number in numbers:\n      if trie.search(number):\n        return False\n      trie.insert(number)\n\n    return True",
      "title": "3491. Phone Number Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3517627f-db6e-41d4-981a-0917af448f3b",
      "code": "class Solution:\n  def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n    return min(n * n, maxWeight // w)",
      "title": "3492. Maximum Containers on a Ship",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec5d5712-30bf-4de7-92bd-bd32b7e432fa",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numberOfComponents(self, properties: list[list[int]], k: int) -> int:\n    n = len(properties)\n    uf = UnionFind(n)\n    propertySets = [set(property) for property in properties]\n\n    for i, j in itertools.combinations(range(n), 2):\n      if len(propertySets[i] & propertySets[j]) >= k:\n        uf.unionByRank(i, j)\n\n    return uf.getCount()",
      "title": "3493. Properties Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783490b2-acc5-4555-a315-e9e2655eb3f0",
      "code": "class Solution:\n  def minTime(self, skill: list[int], mana: list[int]) -> int:\n    sumSkill = sum(skill)\n    prevWizardDone = sumSkill * mana[0]\n\n    for j in range(1, len(mana)):\n      prevPotionDone = prevWizardDone\n      for i in range(len(skill) - 2, -1, -1):\n        # start time for wizard i brewing potion j\n        # = max(end time for wizard i brewing potion j - 1,\n        #       the earliest start time for wizard i + 1 brewing potion j\n        #       (coming from previous iteration)\n        #       - time for wizard i brewing potion j)\n        prevPotionDone -= skill[i + 1] * mana[j - 1]\n        prevWizardDone = max(prevPotionDone,\n                             prevWizardDone - skill[i] * mana[j])\n      prevWizardDone += sumSkill * mana[j]\n\n    return prevWizardDone",
      "title": "3494. Find the Minimum Amount of Time to Brew Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1a02d89-2463-4db5-9f7f-77a4c49a8c86",
      "code": "class Solution:\n  def minOperations(self, queries: list[list[int]]) -> int:\n    return sum((self._getOperations(r) - self._getOperations(l - 1) + 1) // 2\n               for l, r in queries)\n\n  def _getOperations(self, n: int) -> int:\n    \"\"\"Returns the number of operations required for [1, n].\"\"\"\n    res = 0\n    ops = 0\n    powerOfFour = 1\n    while powerOfFour <= n:\n      l = powerOfFour\n      r = min(n, powerOfFour * 4 - 1)\n      ops += 1\n      res += (r - l + 1) * ops\n      powerOfFour *= 4\n    return res",
      "title": "3495. Minimum Operations to Make Array Elements Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d54605-9c42-447c-b397-9e2eb86cb41e",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    if len(nums) % 2 == 1:\n      return summ - min(nums)\n    return summ - min(a + b for a, b in itertools.pairwise(nums))",
      "title": "3496. Maximize Score After Pair Deletions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f03e3d35-e74a-4773-91ae-5a9ed3b6c289",
      "code": "class Solution:\n  def reverseDegree(self, s: str) -> int:\n    return sum((26 - (ord(c) - ord('a'))) * (i + 1)\n               for i, c in enumerate(s))",
      "title": "3498. Reverse Degree of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58016790-71ff-4ec6-9f93-9bd97dc82ac9",
      "code": "class Solution:\n  def maxActiveSectionsAfterTrade(self, s: str) -> int:\n    zeroGroups = [len(list(g)) for c, g in itertools.groupby(s) if c == '0']\n    return s.count('1') + max(map(sum, pairwise(zeroGroups)), default=0)",
      "title": "3499. Maximize Active Section with Trade I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fa6d316-475c-49ef-921d-39c09fac9a6c",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int], cost: list[int], k: int) -> int:\n    n = len(nums)\n    prefixNums = list(itertools.accumulate(nums, initial=0))\n    prefixCost = list(itertools.accumulate(cost, initial=0))\n    # dp[i] := the minimum cost to divide nums[i..n - 1] into subarrays\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i],\n                    prefixNums[j + 1] * (prefixCost[j + 1] - prefixCost[i]) +\n                    k * (prefixCost[n] - prefixCost[i]) + dp[j + 1])\n\n    return dp[0]",
      "title": "3500. Minimum Cost to Divide Array Into Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b4ad275-a663-4d2e-892d-94307b978e7b",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Group:\n  start: int\n  length: int\n\n\nclass SparseTable:\n  def __init__(self, nums: list[int]):\n    self.n = len(nums)\n    # st[i][j] := max(nums[j..j + 2^i - 1])\n    self.st = [[0] * (self.n + 1) for _ in range(self.n.bit_length() + 1)]\n    self.st[0] = nums.copy()\n    for i in range(1, self.n.bit_length() + 1):\n      for j in range(self.n - (1 << i) + 1):\n        self.st[i][j] = max(\n            self.st[i - 1][j],\n            self.st[i - 1][j + (1 << (i - 1))])\n\n  def query(self, l: int, r: int) -> int:\n    \"\"\"Returns max(nums[l..r]).\"\"\"\n    i = (r - l + 1).bit_length() - 1\n    return max(self.st[i][l], self.st[i][r - (1 << i) + 1])\n\n\nclass Solution:\n  def maxActiveSectionsAfterTrade(\n      self,\n      s: str,\n      queries: list[list[int]]\n  ) -> list[int]:\n    ones = s.count('1')\n    zeroGroups, zeroGroupIndex = self._getZeroGroups(s)\n    if not zeroGroups:\n      return [ones] * len(queries)\n\n    st = SparseTable(self._getZeroMergeLengths(zeroGroups))\n\n    def getMaxActiveSections(l: int, r: int) -> int:\n      left = (-1 if zeroGroupIndex[l] == -1\n              else (zeroGroups[zeroGroupIndex[l]].length -\n                    (l - zeroGroups[zeroGroupIndex[l]].start)))\n      right = (-1 if zeroGroupIndex[r] == -1\n               else (r - zeroGroups[zeroGroupIndex[r]].start + 1))\n      startAdjacentGroupIndex, endAdjacentGroupIndex = self._mapToAdjacentGroupIndices(\n          zeroGroupIndex[l] + 1, zeroGroupIndex[r] if s[r] == '1' else zeroGroupIndex[r] - 1)\n      activeSections = ones\n      if (s[l] == '0' and s[r] == '0' and\n              zeroGroupIndex[l] + 1 == zeroGroupIndex[r]):\n        activeSections = max(activeSections, ones + left + right)\n      elif startAdjacentGroupIndex <= endAdjacentGroupIndex:\n        activeSections = max(\n            activeSections,\n            ones + st.query(startAdjacentGroupIndex, endAdjacentGroupIndex))\n      if (s[l] == '0' and\n          zeroGroupIndex[l] + 1 <= (zeroGroupIndex[r]\n                                    if s[r] == '1' else zeroGroupIndex[r] - 1)):\n        activeSections = max(activeSections, ones + left +\n                             zeroGroups[zeroGroupIndex[l] + 1].length)\n      if (s[r] == '0' and zeroGroupIndex[l] < zeroGroupIndex[r] - 1):\n        activeSections = max(activeSections, ones + right +\n                             zeroGroups[zeroGroupIndex[r] - 1].length)\n      return activeSections\n\n    return [getMaxActiveSections(l, r) for l, r in queries]\n\n  def _getZeroGroups(self, s: str) -> tuple[list[Group], list[int]]:\n    \"\"\"\n    Returns the zero groups and the index of the zero group that contains the\n    i-th character.\n    \"\"\"\n    zeroGroups = []\n    zeroGroupIndex = []\n    for i in range(len(s)):\n      if s[i] == '0':\n        if i > 0 and s[i - 1] == '0':\n          zeroGroups[-1].length += 1\n        else:\n          zeroGroups.append(Group(i, 1))\n      zeroGroupIndex.append(len(zeroGroups) - 1)\n    return zeroGroups, zeroGroupIndex\n\n  def _getZeroMergeLengths(self, zeroGroups: list[Group]) -> list[int]:\n    \"\"\"Returns the sums of the lengths of the adjacent groups.\"\"\"\n    return [a.length + b.length for a, b in itertools.pairwise(zeroGroups)]\n\n  def _mapToAdjacentGroupIndices(\n      self,\n      startGroupIndex: int,\n      endGroupIndex: int\n  ) -> tuple[int, int]:\n    \"\"\"\n    Returns the indices of the adjacent groups that contain l and r completely.\n\n    e.g.    groupIndices = [0, 1, 2, 3]\n    adjacentGroupIndices = [0 (0, 1), 1 (1, 2), 2 (2, 3)]\n    map(startGroupIndex = 1, endGroupIndex = 3) -> (1, 2)\n    \"\"\"\n    return startGroupIndex, endGroupIndex - 1",
      "title": "3501. Maximize Active Section with Trade II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63ab303f-886c-4099-84fb-133676ee5cc6",
      "code": "class Solution:\n  def minCosts(self, cost: list[int]) -> list[int]:\n    return list(itertools.accumulate(cost, min))",
      "title": "3502. Minimum Cost to Reach Every Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2586ed3b-641d-48a1-8c7f-e8db940be9fa",
      "code": "class Solution:\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3503. Longest Palindrome After Substring Concatenation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "459395ed-5cf8-4282-bb27-ffcb3180f021",
      "code": "class Solution:\n  # 3503. Longest Palindrome After Substring Concatenation I\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3504. Longest Palindrome After Substring Concatenation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc203ac5-ea5b-4bfe-b22b-73b24ca04ea7",
      "code": "class Solution:\n  def minEliminationTime(self, timeReq: list[int], splitTime: int) -> int:\n    minHeap = timeReq.copy()\n    heapq.heapify(minHeap)\n    heapq.heappop(minHeap)\n\n    while True:\n      bacterial = splitTime + heapq.heappop(minHeap)\n      if not minHeap:\n        return bacterial\n      heapq.heappushpop(minHeap, bacterial)",
      "title": "3506. Find Time Required to Eliminate Bacterial Strains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6464ffec-2c54-4965-baae-9922e5507d36",
      "code": "class Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    ans = 0\n\n    while any(x > y for x, y in itertools.pairwise(nums)):\n      pairSums = [x + y for x, y in itertools.pairwise(nums)]\n      minPairSum = min(pairSums)\n      minPairIndex = pairSums.index(minPairSum)\n      nums[minPairIndex] = minPairSum\n      nums.pop(minPairIndex + 1)\n      ans += 1\n\n    return ans",
      "title": "3507. Minimum Pair Removal to Sort Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23c6d10a-1c07-4f72-8001-6578b46bbfa8",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  FIRST = 0  # first element - add to sum and start product\n  SUBTRACT = 1  # second element - subtract from sum and multiply product\n  ADD = 2  # third element - add to sum and multiply product\n\n\nclass Solution:\n  def maxProduct(self, nums: list[int], k: int, limit: int) -> int:\n    MIN = -5000\n    if abs(k) > sum(nums):\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int, product: int, state: State, k: int) -> int:\n      if i == len(nums):\n        return (product if k == 0 and state != State.FIRST and product <= limit\n                else MIN)\n      res = dp(i + 1, product, state, k)\n      if state == State.FIRST:\n        res = max(res, dp(i + 1, nums[i], State.SUBTRACT, k - nums[i]))\n      if state == State.SUBTRACT:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.ADD, k + nums[i]))\n      if state == State.ADD:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.SUBTRACT, k - nums[i]))\n      return res\n\n    ans = dp(0, 1, State.FIRST, k)\n    return -1 if ans == MIN else ans",
      "title": "3509. Maximum Product of Subsequences With an Alternating Sum Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38e9fc91-78d5-43ab-9657-bf29bb6fb909",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    inversionsCount = sum(nums[i + 1] < nums[i] for i in range(n - 1))\n    nextIndices = [i + 1 for i in range(n)]\n    prevIndices = [i - 1 for i in range(n)]\n    pairSums = SortedList((a + b, i)\n                          for i, (a, b) in enumerate(itertools.pairwise(nums)))\n\n    while inversionsCount > 0:\n      ans += 1\n      smallestPair = pairSums.pop(0)\n      pairSum, currIndex = smallestPair\n      nextIndex = nextIndices[currIndex]\n      prevIndex = prevIndices[currIndex]\n\n      if prevIndex >= 0:\n        oldPairSum = nums[prevIndex] + nums[currIndex]\n        newPairSum = nums[prevIndex] + pairSum\n        pairSums.remove((oldPairSum, prevIndex))\n        pairSums.add((newPairSum, prevIndex))\n        if nums[prevIndex] > nums[currIndex]:\n          inversionsCount -= 1\n        if nums[prevIndex] > pairSum:\n          inversionsCount += 1\n\n      if nums[nextIndex] < nums[currIndex]:\n        inversionsCount -= 1\n\n      nextNextIndex = nextIndices[nextIndex] if nextIndex < n else n\n      if nextNextIndex < n:\n        oldPairSum = nums[nextIndex] + nums[nextNextIndex]\n        newPairSum = pairSum + nums[nextNextIndex]\n        pairSums.remove((oldPairSum, nextIndex))\n        pairSums.add((newPairSum, currIndex))\n        if nums[nextNextIndex] < nums[nextIndex]:\n          inversionsCount -= 1\n        if nums[nextNextIndex] < pairSum:\n          inversionsCount += 1\n        prevIndices[nextNextIndex] = currIndex\n\n      nextIndices[currIndex] = nextNextIndex\n      nums[currIndex] = pairSum\n\n    return ans",
      "title": "3510. Minimum Pair Removal to Sort Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6847edd4-6fd7-4a6d-9880-eb219a46d6ce",
      "code": "class Solution:\n  def makeArrayPositive(self, nums: list[int]) -> int:\n    MAX = 10**18\n    ans = 0\n    minSum = nums[0] + nums[1]\n\n    for i in range(2, len(nums)):\n      a, b, c = nums[i - 2], nums[i - 1], nums[i]\n      minSum = min(minSum + c, a + b + c)\n      if minSum <= 0:\n        nums[i] = MAX\n        minSum = MAX\n        ans += 1\n\n    return ans",
      "title": "3511. Make a Positive Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d137e77-1d1f-4c27-89a6-5cb27ef607ea",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(nums) % k",
      "title": "3512. Minimum Operations to Make Array Sum Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf9e6b37-a1d7-4886-a87d-68ff770d94b4",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return n\n    return 1 << (int(math.log2(n)) + 1)",
      "title": "3513. Number of Unique XOR Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d09bdc2-1ddb-4b75-a633-67fb2ac1c954",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n == 1:\n      return 1\n    pairs = set(nums[i] ^ nums[j]\n                for i, j in itertools.combinations(range(n), 2))\n    return len(set(pair ^ num\n                   for pair in pairs\n                   for num in nums))",
      "title": "3514. Number of Unique XOR Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36735f53-3462-46c3-b698-043919f6528f",
      "code": "class Solution:\n  def findClosest(self, x: int, y: int, z: int) -> int:\n    xz = abs(x - z)\n    yz = abs(y - z)\n    if xz == yz:\n      return 0\n    return 1 if xz < yz else 2",
      "title": "3516. Find Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57c34f9f-c1a9-4b8b-b7d6-f77f384be727",
      "code": "class Solution:\n  def smallestPalindrome(self, s: str) -> str:\n    n = len(s)\n    sortedHalf = sorted(s[:n // 2])\n    return ''.join(sortedHalf +\n                   ([s[n // 2]] if n % 2 else []) +\n                   sortedHalf[::-1])",
      "title": "3517. Smallest Palindromic Rearrangement I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "674a33f5-543b-4bc0-b388-87fa6fc22b68",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX = 10**6 + 1\n\n  def smallestPalindrome(self, s: str, k: int) -> str:\n    count = collections.Counter(s)\n    if not self._isPalindromePossible(count):\n      return ''\n\n    halfCount, midLetter = self._getHalfCountAndMidLetter(count)\n    totalPerm = self._calculateTotalPermutations(halfCount)\n    if k > totalPerm:\n      return ''\n    leftHalf = self._generateLeftHalf(halfCount, k)\n    return ''.join(leftHalf) + midLetter + ''.join(reversed(leftHalf))\n\n  def _isPalindromePossible(self, count: collections.Counter) -> bool:\n    oddCount = sum(1 for count in count.values() if count % 2 == 1)\n    return oddCount <= 1\n\n  def _getHalfCountAndMidLetter(self, count: collections.Counter) -> tuple[list[int], str]:\n    halfCount = [0] * 26\n    midLetter = ''\n    for c, freq in count.items():\n      halfCount[ord(c) - ord('a')] = freq // 2\n      if freq % 2 == 1:\n        midLetter = c\n    return halfCount, midLetter\n\n  def _calculateTotalPermutations(self, halfCount: list[int]) -> int:\n    \"\"\"Calculate the total number of possible permutations.\"\"\"\n    return self._countArrangements(halfCount)\n\n  def _generateLeftHalf(self, halfCount: list[int], k: int) -> list[str]:\n    \"\"\"Generate the left half of the palindrome based on k.\"\"\"\n    halfLen = sum(halfCount)\n    left = []\n    for _ in range(halfLen):\n      for i, freq in enumerate(halfCount):\n        if freq == 0:\n          continue\n        halfCount[i] -= 1\n        arrangements = self._countArrangements(halfCount)\n        if arrangements >= k:\n          left.append(chr(i + ord('a')))\n          break\n        else:\n          k -= arrangements\n          halfCount[i] += 1\n    return left\n\n  def _countArrangements(self, count: list[int]) -> int:\n    \"\"\"Calculate the number of possible arrangements of characters.\"\"\"\n    total = sum(count)\n    res = 1\n    for freq in count:\n      res *= self._nCk(total, freq)\n      if res >= self.MAX:\n        return self.MAX\n      total -= freq\n    return res\n\n  def _nCk(self, n: int, k: int) -> int:\n    res = 1\n    for i in range(1, min(k, n - k) + 1):\n      res = res * (n - i + 1) // i\n      if res >= self.MAX:\n        return self.MAX\n    return res",
      "title": "3518. Smallest Palindromic Rearrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4bbd7a6-c810-46c8-b685-3718d6f00cd6",
      "code": "class Solution:\n  def calculateScore(self, instructions: list[str], values: list[int]) -> int:\n    n = len(instructions)\n    ans = 0\n    i = 0\n    seen = set()\n\n    while 0 <= i < n and i not in seen:\n      seen.add(i)\n      if instructions[i] == 'add':\n        ans += values[i]\n        i += 1\n      elif instructions[i] == 'jump':\n        i += values[i]\n\n    return ans",
      "title": "3522. Calculate Score After Performing Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69101fd2-f140-44f9-94a1-da2d6c4fc4a4",
      "code": "class Solution:\n  def maximumPossibleSize(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n\n    for num in nums:\n      if num >= prev:\n        prev = num\n        ans += 1\n\n    return ans",
      "title": "3523. Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ccb307a-1eb4-47a7-b3f5-0c436f197ffc",
      "code": "class Solution:\n  def resultArray(self, nums: list[int], k: int) -> list[int]:\n    ans = [0] * k\n    # dp[r] := the number of subarrays ending at current position with\n    # product % k == r\n    dp = [0] * k\n\n    for num in nums:\n      newDp = [0] * k\n      numMod = num % k\n      # Start new subarray with only `num`\n      newDp[numMod] = 1\n      # Extend all previous subarrays\n      for i in range(k):\n        newMod = (i * numMod) % k\n        newDp[newMod] += dp[i]\n      # Accumulate counts into ans\n      for i in range(k):\n        ans[i] += newDp[i]\n      dp = newDp\n\n    return ans",
      "title": "3524. Find X Value of Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c6a1b32-7a46-4b9d-a747-dcf49734162b",
      "code": "class Solution:\n  def findCommonResponse(self, responses: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for response in responses:\n      for response in set(response):\n        count[response] += 1\n\n    maxFreq = max(count.values())\n    return min([response\n                for response, count in count.items()\n                if count == maxFreq])",
      "title": "3527. Find the Most Common Response",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09018d65-a4a6-48a0-9156-c0ce5b7f5fbf",
      "code": "class Solution:\n  def baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    n = len(conversions) + 1\n    ans = [0] * n\n    ans[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        ans[v] = (ans[u] * factor) % MOD\n        q.append(v)\n\n    return ans",
      "title": "3528. Unit Conversion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a017f50-719a-40ab-b170-63df96c6ef24",
      "code": "class Solution:\n  def countCells(self, grid: list[list[str]], pattern: str) -> int:\n    BASE = 13\n    HASH = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    def markMatchedCells(flattenedGrid: str, isHorizontal: bool) -> list[list[bool]]:\n      matchMatrix = [[False] * n for _ in range(m)]\n      matchPrefix = [0] * (len(flattenedGrid) + 1)\n      pows = [1]  # pows[i] := BASE^i % HASH\n      patternHash = 0\n      runningHash = 0\n\n      for i in range(1, len(pattern)):\n        pows.append((pows[-1] * BASE) % HASH)\n\n      for c in pattern:\n        patternHash = (patternHash * BASE + (ord(c) - ord('a'))) % HASH\n\n      for i in range(len(flattenedGrid)):\n        runningHash = (\n            runningHash * BASE + (ord(flattenedGrid[i]) - ord('a'))) % HASH\n        if i >= len(pattern) - 1:\n          if runningHash == patternHash:  # Match found.\n            matchPrefix[i - len(pattern) + 1] += 1\n            matchPrefix[i + 1] -= 1\n          # Remove the contribution of the oldest letter.\n          oldestLetterHash = (\n              pows[len(pattern) - 1] *\n              (ord(flattenedGrid[i - len(pattern) + 1]) - ord('a'))) % HASH\n          runningHash = (runningHash - oldestLetterHash + HASH) % HASH\n\n      for k in range(len(flattenedGrid)):\n        if k > 0:\n          matchPrefix[k] += matchPrefix[k - 1]\n        if matchPrefix[k] > 0:\n          i = k // n if isHorizontal else k % m\n          j = k % n if isHorizontal else k // m\n          matchMatrix[i][j] = True\n\n      return matchMatrix\n\n    # Find matching positions.\n    flattenedGridRow = ''.join(cell for row in grid for cell in row)\n    flattenedGridCol = ''.join(cell for col in zip(*grid) for cell in col)\n    horizontalMatches = markMatchedCells(flattenedGridRow, True)\n    verticalMatches = markMatchedCells(flattenedGridCol, False)\n    return sum(horizontalMatches[i][j] and verticalMatches[i][j]\n               for i in range(m)\n               for j in range(n))",
      "title": "3529. Count Cells in Overlapping Horizontal and Vertical Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5044ec8f-42ca-4386-aa47-4fe4eefce4fb",
      "code": "class Solution:\n  def maxProfit(self, n: int, edges: list[list[int]], score: list[int]) -> int:\n    # need[i] := the bitmask representing all nodes that must be placed before\n    # node i\n    need = [0] * n\n    # dp[mask] := the maximum profit achievable by placing the set of nodes\n    # represented by `mask`\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n\n    for u, v in edges:\n      need[v] |= 1 << u\n\n    # Iterate over all subsets of nodes (represented by bitmask `mask`)\n    for mask in range(1 << n):\n      if dp[mask] == -1:\n        continue\n      # Determine the position of the next node to be placed (1-based).\n      pos = mask.bit_count() + 1\n      # Try to place each node `i` that hasn't been placed yet.\n      for i in range(n):\n        if mask >> i & 1:\n          continue\n        # Check if all dependencies of node `i` are already placed.\n        if (mask & need[i]) == need[i]:\n          newMask = mask | 1 << i  # Mark node `i` as placed.\n          dp[newMask] = max(dp[newMask], dp[mask] + score[i] * pos)\n\n    return dp[-1]",
      "title": "3530. Maximum Profit from Valid Topological Order in DAG",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f744cc2-1248-4ccb-8bbe-213472646e40",
      "code": "class Solution:\n  def countCoveredBuildings(self, n: int, buildings: list[list[int]]) -> int:\n    northernmost = [math.inf] * (n + 1)\n    southernmost = [0] * (n + 1)\n    westernmost = [math.inf] * (n + 1)\n    easternmost = [0] * (n + 1)\n\n    for x, y in buildings:\n      northernmost[x] = min(northernmost[x], y)\n      southernmost[x] = max(southernmost[x], y)\n      westernmost[y] = min(westernmost[y], x)\n      easternmost[y] = max(easternmost[y], x)\n\n    return sum(northernmost[x] < y < southernmost[x]\n               and westernmost[y] < x < easternmost[y]\n               for x, y in buildings)",
      "title": "3531. Count Covered Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a21a320a-de0f-44d1-93ce-a5e785326adb",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]]\n  ) -> list[bool]:\n    uf = UnionFind(n)\n\n    for i in range(1, n):\n      if abs(nums[i] - nums[i - 1]) <= maxDiff:\n        uf.unionByRank(i, i - 1)\n\n    return [uf.find(u) == uf.find(v)\n            for u, v in queries]",
      "title": "3532. Path Existence Queries in a Graph I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cedb908b-e0c3-4070-8f85-abb7edb5b88a",
      "code": "class Solution:\n  def concatenatedDivisibility(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    lengths = [len(str(num)) for num in nums]\n    pows = [pow(10, length, k) for length in lengths]\n\n    @functools.lru_cache(None)\n    def dp(mask: int, mod: int) -> bool:\n      \"\"\"\n      Returns True if there is a way to form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      if mask == (1 << n) - 1:\n        return mod == 0\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return True\n      return False\n\n    def reconstruct(mask: int, mod: int) -> list[int]:\n      \"\"\"\n      Reconstructs the numbers that form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return [nums[i]] + reconstruct(mask | 1 << i, newMod)\n      return []\n\n    return reconstruct(0, 0) if dp(0, 0) else []",
      "title": "3533. Concatenated Divisibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9fc2309-6d94-43fb-889c-d73d596bac56",
      "code": "class Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    sortedNumAndIndexes = sorted((num, i) for i, num in enumerate(nums))\n    sortedNums = [num for num, _ in sortedNumAndIndexes]\n    indexMap = {originalIndex: sortedIndex for sortedIndex,\n                (_, originalIndex) in enumerate(sortedNumAndIndexes)}\n    maxLevel = n.bit_length() + 1\n    # jump[i][j] is the index of the j-th ancestor of i\n    jump = [[0] * maxLevel for _ in range(n)]\n\n    right = 0\n    for i in range(n):\n      while right + 1 < n and sortedNums[right + 1] - sortedNums[i] <= maxDiff:\n        right += 1\n      jump[i][0] = right\n\n    for level in range(1, maxLevel):\n      for i in range(n):\n        prevJump = jump[i][level - 1]\n        jump[i][level] = jump[prevJump][level - 1]\n\n    def minJumps(start: int, end: int, level: int) -> int:\n      \"\"\"\n      Returns the minimum number of jumps from `start` to `end` using binary\n      lifting.\n      \"\"\"\n      if start == end:\n        return 0\n      if jump[start][0] >= end:\n        return 1\n      if jump[start][level] < end:\n        return math.inf\n      for j in range(level, -1, -1):\n        if jump[start][j] < end:\n          break\n      return (1 << j) + minJumps(jump[start][j], end, j)\n\n    def minDist(u: int, v: int) -> int:\n      uIndex = indexMap[u]\n      vIndex = indexMap[v]\n      start = min(uIndex, vIndex)\n      end = max(uIndex, vIndex)\n      res = minJumps(start, end, maxLevel - 1)\n      return res if res < math.inf else -1\n\n    return [minDist(u, v) for u, v in queries]",
      "title": "3534. Path Existence Queries in a Graph II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0bc0449-5cfc-4285-8ff9-22e4f498ab4c",
      "code": "class Solution:\n  def queryConversions(\n      self,\n      conversions: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    self.MOD = 1_000_000_007\n    units = self._baseUnitConversions(conversions)\n    # By Fermat's little theorem.\n    return [units[v] * self._modPow(units[u], self.MOD - 2) % self.MOD\n            for u, v in queries]\n\n  # Same as 3528. Unit Conversion I\n  def _baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    n = len(conversions) + 1\n    res = [0] * n\n    res[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        res[v] = (res[u] * factor) % self.MOD\n        q.append(v)\n\n    return res\n\n  def _modPow(self, x: int, n: int) -> int:\n    if n == 0:\n      return 1\n    if n % 2 == 1:\n      return x * self._modPow(x, n - 1) % self.MOD\n    return self._modPow(x * x % self.MOD, n // 2)",
      "title": "3535. Unit Conversion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b75b743c-2013-449d-8d7d-9d8539ae5d70",
      "code": "class Solution:\n  def maxProduct(self, n: int) -> int:\n    s = sorted(str(n))\n    return int(s[-1]) * int(s[-2])",
      "title": "3536. Maximum Product of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19d289d0-b1cc-4542-ab19-45ff035fb874",
      "code": "class Solution:\n  def specialGrid(self, n: int) -> list[list[int]]:\n    sz = 1 << n\n    grid = [[0] * sz for _ in range(sz)]\n    count = 0\n\n    def fill(x1: int, x2: int, y1: int, y2: int) -> None:\n      nonlocal count\n      if x2 - x1 == 1:\n        grid[x1][y1] = count\n        count += 1\n        return\n      midRow = (x1 + x2) // 2\n      midCol = (y1 + y2) // 2\n      fill(x1, midRow, midCol, y2)\n      fill(midRow, x2, midCol, y2)\n      fill(midRow, x2, y1, midCol)\n      fill(x1, midRow, y1, midCol)\n\n    fill(0, sz, 0, sz)\n    return grid",
      "title": "3537. Fill a Special Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e6aed0d-8e90-4d76-a1ea-3c47b039bfac",
      "code": "class Solution:\n  def minTravelTime(\n      self,\n      l: int,\n      n: int,\n      k: int,\n      position: list[int],\n      time: list[int]\n  ) -> int:\n    prefix = list(itertools.accumulate(time))\n\n    @functools.lru_cache(None)\n    def dp(i: int, skips: int, last: int) -> int:\n      \"\"\"\n      Returns the minimum travel time to reach the last stop from i-th stop,\n      with `skips` skips remaining, and the last stop being `last`.\n      \"\"\"\n      if i == n - 1:\n        return 0 if skips == 0 else math.inf\n      res = math.inf\n      rate = prefix[i] - (prefix[last - 1] if last > 0 else 0)\n      end = min(n - 1, i + skips + 1)\n      for j in range(i + 1, end + 1):\n        distance = position[j] - position[i]\n        res = min(res, distance * rate + dp(j, skips - (j - i - 1), i + 1))\n      return res\n\n    return dp(0, k, 0)",
      "title": "3538. Merge Operations for Minimum Travel Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a26f1e85-ff40-4ff4-815a-4cd88c823d1a",
      "code": "class Solution:\n  def magicalSum(self, m: int, k: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(m: int, k: int, i: int, carry: int) -> int:\n      \"\"\"\n      Returns the number of magical sequences of length `k` that can be formed\n      from the first `i` numbers in `nums` with at most `m` elements.\n      \"\"\"\n      if m < 0 or k < 0 or (m + carry.bit_count() < k):\n        return 0\n      if m == 0:\n        return int(k == carry.bit_count())\n      if i == len(nums):\n        return 0\n      res = 0\n      for count in range(m + 1):\n        contribution = math.comb(m, count) * pow(nums[i], count, MOD) % MOD\n        newCarry = carry + count\n        res += dp(m - count, k - (newCarry % 2),\n                  i + 1, newCarry // 2) * contribution\n        res %= MOD\n      return res\n\n    return dp(m, k, 0, 0)",
      "title": "3539. Find Sum of Array Product of Magical Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "394eca6b-e3dc-49c0-89f1-0364f8732611",
      "code": "class Solution:\n  def minTotalTime(\n      self,\n      forward: list[int],\n      backward: list[int],\n      queries: list[int]\n  ) -> int:\n    summ = sum(backward)\n    ans = 0\n    pos = 0\n    prefixF = [0] + list(itertools.accumulate(forward))\n    prefixB = list(itertools.accumulate(backward)) + [0]\n\n    for q in queries:\n      r = int(q < pos) * prefixF[-1] + prefixF[q] - prefixF[pos]\n      l = int(q > pos) * summ + prefixB[pos] - prefixB[q]\n      ans += min(l, r)\n      pos = q\n\n    return ans",
      "title": "3540. Minimum Time to Visit All Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ea4e81a-3422-4d4f-9e5b-e9c7db504349",
      "code": "class Solution:\n  def maxFreqSum(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    count = collections.Counter(s)\n    maxVowel = max((count[c] for c in VOWELS if c in count), default=0)\n    maxConsonant = max((count[c] for c in count if c not in VOWELS), default=0)\n    return maxVowel + maxConsonant",
      "title": "3541. Find Most Frequent Vowel and Consonant",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9b7e11d-ddf0-48c3-8476-95972ebffb51",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    stack = [0]\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      if not stack or stack[-1] < num:\n        ans += 1\n        stack.append(num)\n\n    return ans",
      "title": "3542. Minimum Operations to Convert All Elements to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10108682-0e86-4472-81c6-def2b410aa7d",
      "code": "class Solution:\n  def maxWeight(self, n: int, edges: list[list[int]], k: int, t: int) -> int:\n    graph = [[] for _ in range(n)]\n    # dp[u][i] := the set of possible path sums ending at node u with i edges\n    dp = [defaultdict(set) for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    for u in range(n):\n      dp[u][0].add(0)  # zero edges = sum 0\n\n    for i in range(k):\n      for u in range(n):\n        for currSum in dp[u][i]:\n          for v, w in graph[u]:\n            newSum = currSum + w\n            if newSum < t:\n              dp[v][i + 1].add(newSum)\n\n    ans = -1\n\n    for u in range(n):\n      if k in dp[u]:\n        ans = max(ans, max(dp[u][k]))\n\n    return ans",
      "title": "3543. Maximum Weighted K-Edge Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "364f7860-859d-4307-a7d6-e796cb1966d7",
      "code": "class Solution:\n  def subtreeInversionSum(\n      self,\n      edges: list[list[int]],\n      nums: list[int],\n      k: int\n  ) -> int:\n    n = len(edges) + 1\n    parent = [-1] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dp(u: int, stepsSinceInversion: int, inverted: bool) -> int:\n      \"\"\"\n      Returns the maximum sum for subtree rooted at u, with\n      `stepsSinceInversion` steps of inversion and `inverted` is true if the\n      subtree is inverted.\n      \"\"\"\n      num = -nums[u] if inverted else nums[u]\n      negNum = -num\n      for v in graph[u]:\n        if v == parent[u]:\n          continue\n        parent[v] = u\n        num += dp(v, min(k, stepsSinceInversion + 1), inverted)\n        if stepsSinceInversion == k:\n          negNum += dp(v, 1, not inverted)\n      return max(num, negNum) if stepsSinceInversion == k else num\n\n    return dp(0, k, False)",
      "title": "3544. Subtree Inversion Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851fba13-1cbc-48ef-80ce-292c25fe0a0b",
      "code": "class Solution:\n  def minDeletion(self, s: str, k: int) -> int:\n    count = collections.Counter(s)\n    if len(count) <= k:\n      return 0\n    freqs = sorted(count.values())\n    return sum(freqs[:len(freqs) - k])",
      "title": "3545. Minimum Deletions for At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1600a37-ecb4-4203-9a36-2008098ce7ac",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    totalSum = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      runningSum = 0\n      for row in grid:\n        runningSum += sum(row)\n        if runningSum * 2 == totalSum:\n          return True\n      return False\n\n    return canPartition(grid) or canPartition(zip(*grid))",
      "title": "3546. Equal Sum Grid Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5817dce-8a8a-490a-a060-04e593fe5104",
      "code": "class Solution:\n  def maxScore(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    cycleSizes = []  # components where all nodes have degree 2\n    pathSizes = []  # components that are not cycleSizes\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      if i in seen:\n        continue\n      component = self._getComponent(graph, i, seen)\n      if all(len(graph[u]) == 2 for u in component):\n        cycleSizes.append(len(component))\n      elif len(component) > 1:\n        pathSizes.append(len(component))\n\n    for cycleSize in cycleSizes:\n      ans += self._calculateScore(n - cycleSize + 1, n, True)\n      n -= cycleSize\n\n    for pathSize in sorted(pathSizes, reverse=True):\n      ans += self._calculateScore(n - pathSize + 1, n, False)\n      n -= pathSize\n\n    return ans\n\n  def _getComponent(\n      self,\n      graph: list[list[int]],\n      start: int,\n      seen: set[int],\n  ) -> list[int]:\n    component = [start]\n    seen.add(start)\n    for u in component:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        component.append(v)\n        seen.add(v)\n    return component\n\n  def _calculateScore(self, left: int, right: int, isCycle: bool) -> int:\n    window = collections.deque([right, right])\n    score = 0\n    for value in range(right - 1, left - 1, -1):\n      windowValue = window.popleft()\n      score += windowValue * value\n      window.append(value)\n    return score + window[0] * window[1] * isCycle",
      "title": "3547. Maximum Sum of Edge Values in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8441111d-a8f0-4040-ba77-4346f0242e4e",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    summ = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      topSum = 0\n      seen = set()\n      for i, row in enumerate(grid):\n        topSum += sum(row)\n        botSum = summ - topSum\n        seen |= set(row)\n        if topSum - botSum in (0, grid[0][0],  grid[0][-1], row[0]):\n          return True\n        if len(grid[0]) > 1 and i > 0 and topSum - botSum in seen:\n          return True\n      return False\n\n    return (canPartition(grid) or\n            canPartition(grid[::-1]) or\n            canPartition(list(zip(*grid))[::-1]) or\n            canPartition(list(zip(*grid))))",
      "title": "3548. Equal Sum Grid Partition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67c859b5-6faf-4369-98f3-fb325d22d23c",
      "code": "from numpy import array, round\nfrom numpy.fft import fft, ifft\n\n\nclass Solution:\n  def multiply(self, poly1: list[int], poly2: list[int]) -> list[int]:\n    n1 = len(poly1)\n    n2 = len(poly2)\n    n = n1 + n2 - 1\n    sz = 1 << (n - 1).bit_length()\n    arr1 = array(poly1 + [0] * (sz - n1))\n    arr2 = array(poly2 + [0] * (sz - n2))\n    ans = ifft(fft(arr1) * fft(arr2))\n    return round(ans).astype(int).tolist()[:n]",
      "title": "3549. Multiply Two Polynomials",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "673c5398-c01e-428a-a846-459cccb1463e",
      "code": "class Solution:\n  def smallestIndex(self, nums: List[int]) -> int:\n    return next((i\n                 for i, num in enumerate(nums)\n                 if self._getDigitSum(num) == i), -1)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3550. Smallest Index With Digit Sum Equal to Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a44b6b1-1def-4d3c-b7b2-c4ff05ba6f6e",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n    sortedNums = sorted(nums, key=lambda x: (self._getDigitSum(x), x))\n    numToIndex = {num: i for i, num in enumerate(sortedNums)}\n\n    for i, num in enumerate(nums):\n      if i in seen or numToIndex[num] == i:\n        continue\n      cycleSize = 0\n      j = i\n      while j not in seen:\n        seen.add(j)\n        j = numToIndex[nums[j]]\n        cycleSize += 1\n      ans += max(cycleSize - 1, 0)\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3551. Minimum Swaps to Sort by Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1707212-9805-4c20-adb4-aefa4711dbe8",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minMoves(self, matrix: list[str]) -> int:\n    if matrix[-1][-1] == '#':\n      return -1\n\n    teleportPositions = [[] for _ in range(26)]\n\n    for i, row in enumerate(matrix):\n      for j, c in enumerate(row):\n        if c not in ('.', '#'):\n          teleportPositions[ord(c) - ord('A')].append((i, j))\n\n    return self._dijkstra(matrix, teleportPositions,\n                          (0, 0), (len(matrix) - 1, len(matrix[0]) - 1))\n\n  def _dijkstra(\n      self,\n      matrix: list[str],\n      teleportPositions: list[list[tuple[int, int]]],\n      src: tuple[int, int],\n      dst: tuple[int, int],\n  ) -> int:\n    DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    m = len(matrix)\n    n = len(matrix[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    dist[0][0] = 0\n    minHeap = [(dist[0][0], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      c = matrix[i][j]\n      if c.isupper() and c not in seen:\n        seen.add(c)\n        for x, y in teleportPositions[ord(c) - ord('A')]:\n          if d < dist[x][y]:\n            dist[x][y] = d\n            heapq.heappush(minHeap, (d, (x, y)))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if matrix[x][y] == '#':\n          continue\n        if d + 1 < dist[x][y]:\n          dist[x][y] = d + 1\n          heapq.heappush(minHeap, (d + 1, (x, y)))\n\n    return -1",
      "title": "3552. Grid Teleportation Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0e46e82-24cb-4619-bcfa-a7a173783322",
      "code": "class Solution:\n  # Similar to 2846. Minimum Edge Weight Equilibrium Queries in a Tree\n  def minimumWeight(\n      self,\n      edges: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(edges) + 1\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]  # jump[i][j] := the 2^j-th ancestor of i\n    depth = [0] * n  # depth[i] := the depth of i\n    dist = [0] * n  # dist[i] := the distance from root to i\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    self._dfs(graph, 0, -1, jump, depth, dist)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    return [(self._distance(src1, src2, jump, depth, dist) +\n             self._distance(src1, dest, jump, depth, dist) +\n             self._distance(src2, dest, jump, depth, dist)) // 2\n            for src1, src2, dest in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      dist[v] = dist[u] + w\n      self._dfs(graph, v, u, jump, depth, dist)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]\n\n  def _distance(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> int:\n    \"\"\"Returns the distance between u and v.\"\"\"\n    lca = self._getLCA(u, v, jump, depth)\n    return dist[u] + dist[v] - 2 * dist[lca]",
      "title": "3553. Minimum Weighted Subgraph With the Required Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa6ab1e3-ab91-4f8e-a081-b9fff285d805",
      "code": "class Solution:\n  def minSubarraySort(self, nums: list[int], k):\n    ans = []\n\n    for i in range(len(nums) - k + 1):\n      window = nums[i:i+k]\n      sortedWindow = sorted(window)\n      l = 0\n      r = k - 1\n      while l < k and window[l] == sortedWindow[l]:\n        l += 1\n      while r >= 0 and window[r] == sortedWindow[r]:\n        r -= 1\n      ans.append(0 if l > r else r - l + 1)\n\n    return ans",
      "title": "3555. Smallest Subarray to Sort in Every Sliding Window",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f34cc0f7-4efd-4729-9dbd-2b402549b2ee",
      "code": "class Solution:\n  def sumOfLargestPrimes(self, s: str) -> int:\n    primes = set()\n    n = len(s)\n\n    for i in range(n):\n      for j in range(i + 1, n + 1):\n        num = int(s[i:j])\n        if num not in primes and self._isPrime(num):\n          primes.add(num)\n\n    top3 = sorted(primes, reverse=True)[:3]\n    return sum(top3)\n\n  def _isPrime(self, n: int) -> bool:\n    return n > 1 and all(n % i != 0 for i in range(2, math.isqrt(n) + 1))",
      "title": "3556. Sum of Largest Prime Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54e224f9-145f-4113-9ed3-1ee27afd0e55",
      "code": "class Solution:\n  def maxSubstrings(self, word: str) -> int:\n    ans = 0\n    firstSeen = {}\n\n    for i, c in enumerate(word):\n      if c not in firstSeen:\n        firstSeen[c] = i\n      elif i - firstSeen[c] + 1 >= 4:\n        ans += 1\n        firstSeen.clear()\n\n    return ans",
      "title": "3557. Find Maximum Number of Non Intersecting Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}