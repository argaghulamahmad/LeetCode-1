{
  "snippets": [
    {
      "id": "b5203007-53de-4b8c-880d-ad521c6d6841",
      "code": "class Solution:\n  def getDecimalValue(self, head: ListNode) -> int:\n    ans = 0\n\n    while head:\n      ans = ans * 2 + head.val\n      head = head.next\n\n    return ans",
      "title": "1290. Convert Binary Number in a Linked List to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0319f28-d6c4-41ba-980d-473f3b798ddb",
      "code": "class Solution:\n  def sequentialDigits(self, low: int, high: int) -> list[int]:\n    ans = []\n    q = collections.deque([num for num in range(1, 10)])\n\n    while q:\n      num = q.popleft()\n      if num > high:\n        return ans\n      if low <= num and num <= high:\n        ans.append(num)\n      lastDigit = num % 10\n      if lastDigit < 9:\n        q.append(num * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1291. Sequential Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5dd2c02-ae0b-47a0-8e14-b8e451413ec4",
      "code": "class Solution:\n  def maxSideLength(self, mat: list[list[int]], threshold: int) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:\n      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]\n\n    for i in range(m):\n      for j in range(n):\n        for length in range(ans, min(m - i, n - j)):\n          if squareSum(i, j, i + length, j + length) > threshold:\n            break\n          ans = max(ans, length + 1)\n\n    return ans",
      "title": "1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54bb05f1-f786-41ab-bd46-7e7ee12e8cca",
      "code": "class Solution:\n  def shortestPath(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    step = 0\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return step\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1",
      "title": "1293. Shortest Path in a Grid with Obstacles Elimination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca84b43c-69c9-4fb2-b098-37a4482ea034",
      "code": "class Solution:\n  def findNumbers(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if 9 < num < 100 or 999 < num < 10000 or num == 100000:\n        ans += 1\n\n    return ans",
      "title": "1295. Find Numbers with Even Number of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94c4b7af-8e6e-4bba-bafe-2b360448bacb",
      "code": "class Solution:\n  def isPossibleDivide(self, nums: list[int], k: int) -> bool:\n    count = collections.Counter(nums)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + k):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "1296. Divide Array in Sets of K Consecutive Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4eee28dd-2f9c-41bb-a992-d1ef100cc629",
      "code": "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    # Greedily consider strings with `minSize`, so ignore `maxSize`.\n    ans = 0\n    letters = 0\n    count = collections.Counter()\n    substringCount = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        letters += 1\n      while letters > maxLetters or r - l + 1 > minSize:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          letters -= 1\n        l += 1\n      if r - l + 1 == minSize:\n        sub = s[l:l + minSize]\n        substringCount[sub] += 1\n        ans = max(ans, substringCount[sub])\n\n    return ans",
      "title": "1297. Maximum Number of Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f24e612f-f4b1-4dba-af41-9a3a9359f597",
      "code": "class Solution:\n  def maxCandies(\n      self,\n      status: list[int],\n      candies: list[int],\n      keys: list[list[int]],\n      containedBoxes: list[list[int]],\n      initialBoxes: list[int],\n  ) -> int:\n    ans = 0\n    q = collections.deque()\n    reachedClosedBoxes = [0] * len(status)\n\n    def pushBoxesIfPossible(boxes: list[int]) -> None:\n      for box in boxes:\n        if status[box]:\n          q.append(box)\n        else:\n          reachedClosedBoxes[box] = True\n\n    pushBoxesIfPossible(initialBoxes)\n\n    while q:\n      currBox = q.popleft()\n\n      # Add the candies.\n      ans += candies[currBox]\n\n      # Push `reachedClosedBoxes` by `key` obtained in this turn and change\n      # their statuses.\n      for key in keys[currBox]:\n        if not status[key] and reachedClosedBoxes[key]:\n          q.append(key)\n        status[key] = 1  # boxes[key] is now open\n\n      # Push the boxes contained in `currBox`.\n      pushBoxesIfPossible(containedBoxes[currBox])\n\n    return ans",
      "title": "1298. Maximum Candies You Can Get from Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd7cd466-1173-40f7-bb01-9b870dc3caf6",
      "code": "class Solution:\n  def replaceElements(self, arr: list[int]) -> list[int]:\n    maxOfRight = -1\n    for i in reversed(range(len(arr))):\n      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])\n    return arr",
      "title": "1299. Replace Elements with Greatest Element on Right Side",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f45b8fc7-a2cb-4f5b-813d-a0cfcabc3127",
      "code": "class Solution:\n  def findBestValue(self, arr: list[int], target: int) -> int:\n    prefix = 0\n\n    arr.sort()\n\n    for i, a in enumerate(arr):\n      ans = round((target - prefix) / (len(arr) - i))\n      if ans <= a:\n        return ans\n      prefix += a\n\n    return arr[-1]",
      "title": "1300. Sum of Mutated Array Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "438f5797-8700-4dc0-bfa0-448193f8b65c",
      "code": "class Solution:\n  def pathsWithMaxScore(self, board: list[str]) -> list[int]:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (1, 1))\n    n = len(board)\n    # dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    # count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to\n    # (i, j)\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= MOD\n\n        # If there's path(s) from 'S' to (i, j) and the cell is not 'E'.\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= MOD\n\n    return [dp[0][0], count[0][0]]",
      "title": "1301. Number of Paths with Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6d67470-6c20-4c6a-9f5f-de4610e478d4",
      "code": "class Solution:\n  def sumZero(self, n: int) -> list[int]:\n    return list(range(1 - n, n, 2))",
      "title": "1304. Find N Unique Integers Sum up to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2ec0bf-9eca-45b3-8f77-bd35d22b2f3b",
      "code": "class Solution:\n  def isSolvable(self, words: list[str], result: str) -> bool:\n    words.append(result)\n    rows = len(words)\n    cols = max(map(len, words))\n    letterToDigit = {}\n    usedDigit = [False] * 10\n\n    def dfs(row: int, col: int, summ: int) -> bool:\n      if col == cols:\n        return summ == 0\n      if row == rows:\n        return summ % 10 == 0 and dfs(0, col + 1, summ // 10)\n\n      word = words[row]\n      if col >= len(word):\n        return dfs(row + 1, col, summ)\n\n      letter = word[~col]\n      sign = -1 if row == rows - 1 else 1\n\n      if letter in letterToDigit and (\n              letterToDigit[letter] > 0 or col < len(word) - 1):\n        return dfs(row + 1, col, summ + sign * letterToDigit[letter])\n\n      for digit, used in enumerate(usedDigit):\n        if not used and (digit > 0 or col < len(word) - 1):\n          letterToDigit[letter] = digit\n          usedDigit[digit] = True\n          if dfs(row + 1, col, summ + sign * digit):\n            return True\n          usedDigit[digit] = False\n          if letter in letterToDigit:\n            del letterToDigit[letter]\n\n      return False\n\n    return dfs(0, 0, 0)",
      "title": "1307. Verbal Arithmetic Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2dfab3e7-fda8-4c96-8104-43274a046e07",
      "code": "class Solution:\n  def freqAlphabets(self, s: str) -> str:\n    ans = ''\n    i = 0\n\n    while i < len(s):\n      if i + 2 < len(s) and s[i + 2] == '#':\n        ans += chr(int(s[i:i + 2]) + ord('a') - 1)\n        i += 3\n      else:\n        ans += chr(int(s[i]) + ord('a') - 1)\n        i += 1\n\n    return ans",
      "title": "1309. Decrypt String from Alphabet to Integer Mapping",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbeee4de-00d7-46dd-b88f-9333fb68876a",
      "code": "class Solution:\n  def xorQueries(self, arr: list[int], queries: list[list[int]]) -> list[int]:\n    ans = []\n    xors = [0] * (len(arr) + 1)\n\n    for i, a in enumerate(arr):\n      xors[i + 1] = xors[i] ^ a\n\n    for left, right in queries:\n      ans.append(xors[left] ^ xors[right + 1])\n\n    return ans",
      "title": "1310. XOR Queries of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f50695de-cde9-460b-9da7-5e268ef1064f",
      "code": "class Solution:\n  def watchedVideosByFriends(\n      self,\n      watchedVideos: list[list[str]],\n      friends: list[list[int]],\n      id: int,\n      level: int,\n  ) -> list[str]:\n    seen = [False] * 100\n    seen[id] = True\n    q = collections.deque([id])\n    count = collections.Counter()\n\n    for _ in range(level):\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for friend in friends[curr]:\n          if not seen[friend]:\n            seen[friend] = True\n            q.append(friend)\n\n    for friend in q:\n      for video in watchedVideos[friend]:\n        count[video] += 1\n\n    return sorted(count, key=lambda video: (count[video], video))",
      "title": "1311. Get Watched Videos by Your Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c206f545-d07d-4628-862d-2e659c2792d0",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    return len(s) - self._longestPalindromeSubseq(s)\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1312. Minimum Insertion Steps to Make a String Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09fc2dd-3ca1-4304-9ab5-644cd08323da",
      "code": "class Solution:\n  def decompressRLElist(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for i in range(0, len(nums), 2):\n      ans += [nums[i + 1]] * nums[i]\n\n    return ans",
      "title": "1313. Decompress Run-Length Encoded List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47fedf6d-c2bf-4bc7-8661-a243b70e05cf",
      "code": "class Solution:\n  def matrixBlockSum(self, mat: list[list[int]], k: int) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    for i in range(m):\n      for j in range(n):\n        r1 = max(0, i - k) + 1\n        c1 = max(0, j - k) + 1\n        r2 = min(m - 1, i + k) + 1\n        c2 = min(n - 1, j + k) + 1\n        ans[i][j] = (prefix[r2][c2] - prefix[r2][c1 - 1] -\n                     prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1])\n\n    return ans",
      "title": "1314. Matrix Block Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c33fb49-9610-42c5-9dd2-af9dce6309d0",
      "code": "class Solution:\n  def distinctEchoSubstrings(self, text: str) -> int:\n    seen = set()\n\n    for k in range(1, len(text) // 2 + 1):  # the target length\n      same = 0\n      l = 0\n      for r in range(k, len(text)):\n        if text[l] == text[r]:\n          same += 1\n        else:\n          same = 0\n        if same == k:\n          seen.add(text[l - k + 1:l + 1])\n          # Move the window thus leaving a letter behind, so we need to\n          # decrease the counter.\n          same -= 1\n        l += 1\n\n    return len(seen)",
      "title": "1316. Distinct Echo Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e58111a6-71f9-4e74-b1e4-3a7e5663e433",
      "code": "class Solution:\n  def getNoZeroIntegers(self, n: int) -> list[int]:\n    for A in range(n):\n      B = n - A\n      if '0' not in str(A) and '0' not in str(B):\n        return A, B",
      "title": "1317. Convert Integer to the Sum of Two No-Zero Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42867e47-941a-4b5b-a3b8-d421d1b60068",
      "code": "class Solution:\n  def minFlips(self, a: int, b: int, c: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      if c >> i & 1:\n        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0\n      else:  # (c >> i & 1) == 0\n        ans += (a >> i & 1) + (b >> i & 1)\n\n    return ans",
      "title": "1318. Minimum Flips to Make a OR b Equal to c",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2afe120a-1171-42e6-b999-8ed7cadd9cc5",
      "code": "class Solution:\n  def minimumDistance(self, word: str) -> int:\n    def dist(a: int, b: int) -> int:\n      if a == 26:  # the first hovering state\n        return 0\n      x1, y1 = a // 6, a % 6\n      x2, y2 = b // 6, b % 6\n      return abs(x1 - x2) + abs(y1 - y2)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to type the `word`, where the left finger is\n      on the i-th letter, the right finger is on the j-th letter, and the\n      words[0..k) have been written.\n      \"\"\"\n      if k == len(word):\n        return 0\n      nxt = ord(word[k]) - ord('A')\n      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)\n      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)\n      return min(moveLeft, moveRight)\n\n    return dp(26, 26, 0)",
      "title": "1320. Minimum Distance to Type a Word Using Two Fingers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96578847-1c5f-435c-8664-c4ca31dced2e",
      "code": "class Solution:\n  def maximum69Number(self, num: int) -> int:\n    return int(str(num).replace('6', '9', 1))",
      "title": "1323. Maximum 69 Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a8ebdfe-26bb-430a-8eb4-3bd3bd1b203c",
      "code": "class Solution:\n  def printVertically(self, s: str) -> list[str]:\n    ans = []\n    words = s.split()\n    maxLength = max(len(word) for word in words)\n\n    for i in range(maxLength):\n      row = []\n      for word in words:\n        row.append(word[i] if i < len(word) else ' ')\n      ans.append(''.join(row).rstrip())\n\n    return ans",
      "title": "1324. Print Words Vertically",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65f2c784-b630-4f83-9525-3470e2976b1e",
      "code": "class Solution:\n  def removeLeafNodes(\n      self,\n      root: TreeNode | None,\n      target: int,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.removeLeafNodes(root.left, target)\n    root.right = self.removeLeafNodes(root.right, target)\n    return None if self._isLeaf(root) and root.val == target else root\n\n  def _isLeaf(self, root: TreeNode | None) -> bool:\n    return not root.left and not root.right",
      "title": "1325. Delete Leaves With a Given Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30f9337d-8f18-4d20-a213-f3393ccc16a6",
      "code": "class Solution:\n  def minTaps(self, n: int, ranges: list[int]) -> int:\n    nums = [0] * (n + 1)\n\n    for i, range_ in enumerate(ranges):\n      l = max(0, i - range_)\n      r = min(n, range_ + i)\n      nums[l] = max(nums[l], r - l)\n\n    ans = 0\n    end = 0\n    farthest = 0\n\n    for i in range(n):\n      farthest = max(farthest, i + nums[i])\n      if i == end:\n        ans += 1\n        end = farthest\n\n    return ans if end == n else -1",
      "title": "1326. Minimum Number of Taps to Open to Water a Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b42a074-875e-4897-a224-3e582d440d14",
      "code": "class Solution:\n  def breakPalindrome(self, palindrome: str) -> str:\n    if len(palindrome) == 1:\n      return ''\n\n    ans = list(palindrome)\n\n    for i in range(len(palindrome) // 2):\n      if palindrome[i] != 'a':\n        ans[i] = 'a'\n        return ''.join(ans)\n\n    ans[-1] = 'b'\n    return ''.join(ans)",
      "title": "1328. Break a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4519db73-ec4c-4554-b19e-d0194bbc4944",
      "code": "class Solution:\n  def diagonalSort(self, mat: list[list[int]]) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n\n    count = collections.defaultdict(list)\n\n    for i in range(m):\n      for j in range(n):\n        count[i - j].append(mat[i][j])\n\n    for value in count.values():\n      value.sort(reverse=1)\n\n    for i in range(m):\n      for j in range(n):\n        mat[i][j] = count[i - j].pop()\n\n    return mat",
      "title": "1329. Sort the Matrix Diagonally",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e517ac-57f2-4a2e-ba7f-0f87b843402b",
      "code": "class Solution:\n  def maxValueAfterReverse(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n\n    for a, b in zip(nums, nums[1:]):\n      mn = min(mn, max(a, b))\n      mx = max(mx, min(a, b))\n    diff = max(0, (mx - mn) * 2)\n\n    for a, b in zip(nums, nums[1:]):\n      headDiff = -abs(a - b) + abs(nums[0] - b)\n      tailDiff = -abs(a - b) + abs(nums[-1] - a)\n      diff = max(diff, headDiff, tailDiff)\n\n    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff",
      "title": "1330. Reverse Subarray To Maximize Array Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c795028-925f-4d4d-87c1-8e4f9ffb3e6b",
      "code": "class Solution:\n  def arrayRankTransform(self, arr: list[int]) -> list[int]:\n    rank = {}\n\n    for a in sorted(arr):\n      if a not in rank:\n        rank[a] = len(rank) + 1\n\n    return map(rank.get, arr)",
      "title": "1331. Rank Transform of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b2543b0-13ec-4335-a4dd-38f9939193b7",
      "code": "class Solution:\n  def removePalindromeSub(self, s: str) -> int:\n    return 1 if s == s[::-1] else 2",
      "title": "1332. Remove Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c9d1d82-5c9b-4525-b87f-10894a0721c3",
      "code": "class Solution:\n  def filterRestaurants(\n      self,\n      restaurants: list[list[int]],\n      veganFriendly: int,\n      maxPrice: int,\n      maxDistance: int,\n  ) -> list[int]:\n    restaurants.sort(key=lambda x: (-x[1], -x[0]))\n    return [i for i, _, v, p, d in restaurants\n            if v >= veganFriendly and p <= maxPrice and d <= maxDistance]",
      "title": "1333. Filter Restaurants by Vegan-Friendly, Price and Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7358c8ef-e031-4f38-87ec-5c0a61fc0104",
      "code": "class Solution:\n  def findTheCity(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> list[list[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist",
      "title": "1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b07f05f-96b0-42be-be32-53a5fdf040c9",
      "code": "class Solution:\n  def minDifficulty(self, jobDifficulty: list[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if d > n:\n      return -1\n\n    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days\n    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n      for k in range(1, d + 1):\n        maxDifficulty = 0  # max(job[j + 1..i])\n        for j in range(i - 1, k - 2, -1):  # 1-based\n          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)\n\n    return dp[n][d]",
      "title": "1335. Minimum Difficulty of a Job Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "841d4d31-7709-4286-954a-bca27348dea4",
      "code": "class Solution:\n  def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\n    rowSums = [(sum(row), i) for i, row in enumerate(mat)]\n    return [i for _, i in sorted(rowSums)[:k]]",
      "title": "1337. The K Weakest Rows in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78b1fd38-ba73-40e8-a931-1560884b89bd",
      "code": "class Solution:\n  def minSetSize(self, arr: list[int]) -> int:\n    count = collections.Counter(arr).most_common()\n    count.sort(key=lambda x: -x[1])\n\n    summ = 0\n    for i, (_, freq) in enumerate(count):\n      summ += freq\n      if summ >= len(arr) // 2:\n        return i + 1",
      "title": "1338. Reduce Array Size to The Half",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b74f36e9-b06d-4d30-94a3-a110159065af",
      "code": "class Solution:\n  def maxJumps(self, arr: list[int], d: int) -> int:\n    n = len(arr)\n    # dp[i] := the maximum jumps starting from arr[i]\n    dp = [1] * n\n    # a dcreasing stack that stores indices\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            # Can jump from i to j.\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            # Can jump from stack[-1] to j\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)",
      "title": "1340. Jump Game V",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6faec267-ac6e-4796-86b3-571ed1fbed96",
      "code": "class Solution:\n  def numberOfSteps(self, num: int) -> int:\n    if num == 0:\n      return 0\n    subtractSteps = num.bit_count()\n    divideSteps = num.bit_length() - 1\n    return subtractSteps + divideSteps",
      "title": "1342. Number of Steps to Reduce a Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "906fbc97-4bc7-4a5a-8d1e-5b93fa4b8b31",
      "code": "class Solution:\n  def numOfSubarrays(self, arr: list[int], k: int, threshold: int) -> int:\n    ans = 0\n    windowSum = 0\n\n    for i in range(len(arr)):\n      windowSum += arr[i]\n      if i >= k:\n        windowSum -= arr[i - k]\n      if i >= k - 1 and windowSum // k >= threshold:\n        ans += 1\n\n    return ans",
      "title": "1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2fe467c-6d84-4020-b31a-3c1f3538978f",
      "code": "class Solution:\n  def angleClock(self, hour: int, minutes: int) -> float:\n    hourAngle = (hour % 12) * 30 + minutes * 0.5\n    minuteAngle = minutes * 6\n    ans = abs(hourAngle - minuteAngle)\n\n    return min(ans, 360 - ans)",
      "title": "1344. Angle Between Hands of a Clock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "583dfa29-9e48-43a4-8cc2-18e49e0c7a7c",
      "code": "class Solution:\n  def minJumps(self, arr: list[int]) -> int:\n    n = len(arr)\n    # {num: indices}\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1",
      "title": "1345. Jump Game IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0b1b10f-00e8-4f5f-9c33-7dd82ff47fad",
      "code": "class Solution:\n  def checkIfExist(self, arr: list[int]) -> bool:\n    seen = set()\n\n    for a in arr:\n      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:\n        return True\n      seen.add(a)\n\n    return False",
      "title": "1346. Check If N and Its Double Exist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13f446f8-545f-4c61-8be3-6efa151b7d4f",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum(abs(value) for value in count.values()) // 2",
      "title": "1347. Minimum Number of Steps to Make Two Strings Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "909fe0f0-6ce3-4ecf-8b22-3b6bd7ee2639",
      "code": "class Solution:\n  def maxStudents(self, seats: list[list[str]]) -> int:\n    m = len(seats)\n    n = len(seats[0])\n    DIRS = ((-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1))\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seats[x][y] != '.' or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    def hungarian() -> int:\n      count = 0\n      for i in range(m):\n        for j in range(n):\n          if seats[i][j] == '.' and match[i][j] == -1:\n            sessionId = i * n + j\n            seen[i][j] = sessionId\n            count += dfs(i, j, sessionId)\n      return count\n\n    return sum(seats[i][j] == '.'\n               for i in range(m)\n               for j in range(n)) - hungarian()",
      "title": "1349. Maximum Students Taking Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "158254d5-1b47-4f42-a7db-dcbf4ed0a68c",
      "code": "class Solution:\n  def countNegatives(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    i = m - 1\n    j = 0\n\n    while i >= 0 and j < n:\n      if grid[i][j] < 0:\n        ans += n - j\n        i -= 1\n      else:\n        j += 1\n\n    return ans",
      "title": "1351. Count Negative Numbers in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5157e2-f631-4cdc-9002-1898c3d950ea",
      "code": "class Solution:\n  def maxEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    minHeap = []\n    i = 0  # events' index\n\n    events.sort(key=lambda x: x[0])\n\n    while minHeap or i < len(events):\n      # If no events are available to attend today, let time flies to the next\n      # available event.\n      if not minHeap:\n        d = events[i][0]\n      # All the events starting from today are newly available.\n      while i < len(events) and events[i][0] == d:\n        heapq.heappush(minHeap, events[i][1])\n        i += 1\n      # Greedily attend the event that'll end the earliest since it has higher\n      # chance can't be attended in the future.\n      heapq.heappop(minHeap)\n      ans += 1\n      d += 1\n      # Pop the events that can't be attended.\n      while minHeap and minHeap[0] < d:\n        heapq.heappop(minHeap)\n\n    return ans",
      "title": "1353. Maximum Number of Events That Can Be Attended",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8cbc8c9-03a5-4619-8132-58ccc5da8056",
      "code": "class Solution:\n  def isPossible(self, target: list[int]) -> bool:\n    if len(target) == 1:\n      return target[0] == 1\n\n    summ = sum(target)\n    maxHeap = [-num for num in target]\n    heapq.heapify(maxHeap)\n\n    while -maxHeap[0] > 1:\n      mx = -heapq.heappop(maxHeap)\n      restSum = summ - mx\n      # Only occurs if n == 2.\n      if restSum == 1:\n        return True\n      updated = mx % restSum\n      # updated == 0 (invalid) or didn't change.\n      if updated == 0 or updated == mx:\n        return False\n      heapq.heappush(maxHeap, -updated)\n      summ = summ - mx + updated\n\n    return True",
      "title": "1354. Construct Target Array With Multiple Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20e1eaf2-245b-45b4-a987-f8f89bfc3045",
      "code": "class Solution:\n  def sortByBits(self, arr: list[int]) -> list[int]:\n    return sorted(arr, key=lambda x: (x.bit_count(), x))",
      "title": "1356. Sort Integers by The Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a99817f-65f9-42f8-8b70-7b449021b199",
      "code": "class Solution:\n  # Similar to 3. Longest SubWithout Repeating Characters\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {c: -1 for c in 'abc'}\n\n    for i, c in enumerate(s):\n      lastSeen[c] = i\n      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.\n      ans += 1 + min(lastSeen.values())\n\n    return ans",
      "title": "1358. Number of Substrings Containing All Three Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53bb79e5-ee05-4255-ba0b-51aba9745614",
      "code": "class Solution:\n  def countOrders(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n\n    for i in range(1, n + 1):\n      ans = ans * i * (i * 2 - 1) % MOD\n\n    return ans",
      "title": "1359. Count All Valid Pickup and Delivery Options",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d2cc14e-7149-406d-82c4-f9c2a4b16cac",
      "code": "class Solution:\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n\n    def daysFrom1971(date: str) -> int:\n      year, month, day = map(int, date.split('-'))\n      return (365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) +\n              sum(days[:month]) + day + (month > 2 and isLeapYear(year)))\n\n    return abs(daysFrom1971(date1) - daysFrom1971(date2))",
      "title": "1360. Number of Days Between Two Dates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4db735cd-2757-4691-9768-73c3d027528f",
      "code": "class Solution:\n  def closestDivisors(self, num: int) -> list[int]:\n    for root in reversed(range(math.isqrt(num + 2) + 1)):\n      for cand in [num + 1, num + 2]:\n        if cand % root == 0:\n          return [root, cand // root]",
      "title": "1362. Closest Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e67a7a5-0910-437b-855a-47bd20014971",
      "code": "class Solution:\n  def largestMultipleOfThree(self, digits: list[int]) -> str:\n    ans = ''\n    mod1 = [1, 4, 7, 2, 5, 8]\n    mod2 = [2, 5, 8, 1, 4, 7]\n    count = collections.Counter(digits)\n    summ = sum(digits)\n\n    while summ % 3 != 0:\n      for digit in (mod1 if summ % 3 == 1 else mod2):\n        if count[digit]:\n          count[digit] -= 1\n          summ -= digit\n          break\n\n    for digit in reversed(range(10)):\n      ans += str(digit) * count[digit]\n\n    return '0' if len(ans) and ans[0] == '0' else ans",
      "title": "1363. Largest Multiple of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0143e67-5817-49bb-9c53-77d4f69fdb50",
      "code": "class Solution:\n  def smallerNumbersThanCurrent(self, nums: list[int]) -> list[int]:\n    MAX = 100\n    count = collections.Counter(nums)\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    return [0 if num == 0 else count[num - 1]\n            for num in nums]",
      "title": "1365. How Many Numbers Are Smaller Than the Current Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b54f2b4-c256-475f-a517-d9caccc1874a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Team:\n  name: str\n  rank: list[int]\n\n  def __init__(self, name: str, teamSize: int):\n    self.name = name\n    self.rank = [0] * teamSize\n\n\nclass Solution:\n  def rankTeams(self, votes: list[str]) -> str:\n    teamSize = len(votes[0])\n    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]\n\n    for vote in votes:\n      for i in range(teamSize):\n        teams[ord(vote[i]) - ord('A')].rank[i] += 1\n\n    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)\n    return ''.join(team.name for team in teams[:teamSize])",
      "title": "1366. Rank Teams by Votes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd0c2fbb-f172-4cd2-9dc8-b337dd69683d",
      "code": "class Solution:\n  def isSubPath(self, head: ListNode | None, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n    return (self._isContinuousSubPath(head, root) or\n            self.isSubPath(head, root.left) or\n            self.isSubPath(head, root.right))\n\n  def _isContinuousSubPath(\n      self,\n      head: ListNode | None,\n      root: TreeNode | None,\n  ) -> bool:\n    if not head:\n      return True\n    if not root:\n      return False\n    return (head.val == root.val and\n            (self._isContinuousSubPath(head.next, root.left) or\n             self._isContinuousSubPath(head.next, root.right)))",
      "title": "1367. Linked List in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ac9e821-cedc-406b-852e-3c3fefae65d1",
      "code": "class Solution:\n  def minCost(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    DIRS = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    dp = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    def dfs(i: int, j: int, cost: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if dp[i][j] != -1:\n        return\n      dp[i][j] = cost\n      q.append((i, j))\n      dx, dy = DIRS[grid[i][j] - 1]\n      dfs(i + dx, j + dy, cost)\n\n    dfs(0, 0, 0)\n\n    cost = 0\n    while q:\n      cost += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy, cost)\n\n    return dp[-1][-1]",
      "title": "1368. Minimum Cost to Make at Least One Valid Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba3f346d-120a-4078-9fc6-adc733d03b6c",
      "code": "class Solution:\n  def sortString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n\n    while count:\n      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):\n        ans += [c for c in chars if c in count]\n        count -= dict.fromkeys(count, 1)\n\n    return ''.join(ans)",
      "title": "1370. Increasing Decreasing String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4fad0fd-6346-40b9-9991-75f78617afba",
      "code": "class Solution:\n  def findTheLongestSubstring(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = {0: -1}\n\n    for i, c in enumerate(s):\n      index = VOWELS.find(c)\n      if index != -1:\n        prefix ^= 1 << index\n      prefixToIndex.setdefault(prefix, i)\n      ans = max(ans, i - prefixToIndex[prefix])\n\n    return ans",
      "title": "1371. Find the Longest Substring Containing Vowels in Even Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5e00931-ef42-41aa-b305-77f40f3952c0",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  leftMax: int\n  rightMax: int\n  subtreeMax: int\n\n\nclass Solution:\n  def longestZigZag(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(-1, -1, -1)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      leftZigZag = left.rightMax + 1\n      rightZigZag = right.leftMax + 1\n      subtreeMax = max(leftZigZag, rightZigZag,\n                       left.subtreeMax, right.subtreeMax)\n      return T(leftZigZag, rightZigZag, subtreeMax)\n\n    return dfs(root).subtreeMax",
      "title": "1372. Longest ZigZag Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "675e29a3-a035-46c2-a3c4-a40b0cdeea04",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass T:\n  isBST: bool | None = False\n  mx: int | None = None\n  mn: int | None = None\n  summ: int | None = None\n\n\nclass Solution:\n  def maxSumBST(self, root: TreeNode | None) -> int:\n    self.ans = 0\n\n    def traverse(root: TreeNode | None) -> T:\n      if not root:\n        return T(True, -math.inf, math.inf, 0)\n\n      left: T = traverse(root.left)\n      right: T = traverse(root.right)\n\n      if not left.isBST or not right.isBST:\n        return T()\n      if root.val <= left.mx or root.val >= right.mn:\n        return T()\n\n      # The `root` is a valid BST.\n      summ = root.val + left.summ + right.summ\n      self.ans = max(self.ans, summ)\n      return T(True, max(root.val, right.mx), min(root.val, left.mn), summ)\n\n    traverse(root)\n    return self.ans",
      "title": "1373. Maximum Sum BST in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea931063-4ccc-4dbc-ba27-77dcb3a46a41",
      "code": "class Solution:\n  def generateTheString(self, n: int) -> str:\n    s = 'a' * n\n    if n % 2 == 0:\n      s = s[:-1] + 'b'\n    return s",
      "title": "1374. Generate a String With Characters That Have Odd Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98738f68-0389-4153-9303-1c6fde78a87c",
      "code": "class Solution:\n  def numTimesAllBlue(self, flips: list[int]) -> int:\n    ans = 0\n    rightmost = 0\n\n    for i, flip in enumerate(flips):\n      rightmost = max(rightmost, flip)\n      # max(flips[0..i]) = rightmost = i + 1,\n      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.\n      if rightmost == i + 1:\n        ans += 1\n\n    return ans",
      "title": "1375. Number of Times Binary String Is Prefix-Aligned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9693159e-0d6c-4e3b-af3e-49dc1de49af8",
      "code": "class Solution:\n  def frogPosition(\n      self,\n      n: int,\n      edges: list[list[int]],\n      t: int,\n      target: int,\n  ) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]",
      "title": "1377. Frog Position After T Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dba3bd61-bd16-4308-b7e4-b85b3e284982",
      "code": "class Solution:\n  def getTargetCopy(\n      self,\n      original: TreeNode,\n      cloned: TreeNode,\n      target: TreeNode,\n  ) -> TreeNode:\n    ans = None\n\n    def dfs(original: TreeNode, cloned: TreeNode) -> None:\n      nonlocal ans\n      if ans:\n        return\n      if not original:\n        return\n      if original == target:\n        ans = cloned\n        return\n\n      dfs(original.left, cloned.left)\n      dfs(original.right, cloned.right)\n\n    dfs(original, cloned)\n    return ans",
      "title": "1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36e202e7-8a97-4196-b8bf-ab082c1dcc27",
      "code": "class Solution:\n  def luckyNumbers(self, matrix: list[list[int]]) -> list[int]:\n    for row in matrix:\n      minIndex = row.index(min(row))\n      if row[minIndex] == max(list(zip(*matrix))[minIndex]):\n        return [row[minIndex]]\n    return []",
      "title": "1380. Lucky Numbers in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63a87839-9fb3-40e7-a7b3-e3dda29e7a2d",
      "code": "class Solution:\n  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:\n    nums = []\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n      inorder(root.left)\n      nums.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    # Same as 108. Convert Sorted Array to Binary Search Tree\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "1382. Balance a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f642b0ea-61d6-474d-8c74-0eaec1fd7d76",
      "code": "class Solution:\n  # Similar to 857. Minimum Cost to Hire K Workers\n  def maxPerformance(\n      self,\n      n: int,\n      speed: list[int],\n      efficiency: list[int],\n      k: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    speedSum = 0\n    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order\n    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)\n    minHeap = []\n\n    for e, s in A:\n      heapq.heappush(minHeap, s)\n      speedSum += s\n      if len(minHeap) > k:\n        speedSum -= heapq.heappop(minHeap)\n      ans = max(ans, speedSum * e)\n\n    return ans % MOD",
      "title": "1383. Maximum Performance of a Team",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4adba10-d4c8-4ad3-9551-38ef0aa62149",
      "code": "class Solution:\n  def findTheDistanceValue(\n      self,\n      arr1: list[int],\n      arr2: list[int],\n      d: int,\n  ) -> int:\n    ans = 0\n\n    arr2.sort()\n\n    for a in arr1:\n      i = bisect.bisect_left(arr2, a)\n      if ((i == len(arr2) or arr2[i] - a > d) and\n              (i == 0 or a - arr2[i - 1] > d)):\n        ans += 1\n\n    return ans",
      "title": "1385. Find the Distance Value Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ec2179e-dc40-421b-a9e8-77b0c6d2cc73",
      "code": "class Solution:\n  def maxNumberOfFamilies(self, n: int, reservedSeats: list[list[int]]) -> int:\n    ans = 0\n    rowToSeats = collections.Counter()\n\n    for row, seat in reservedSeats:\n      rowToSeats[row] |= 1 << (seat - 1)\n\n    for seats in rowToSeats.values():\n      if (seats & 0b0111111110) == 0:\n        # Can fit 2 four-person groups.\n        ans += 2\n      elif ((seats & 0b0111100000) == 0 or\n            (seats & 0b0001111000) == 0 or\n            (seats & 0b0000011110) == 0):\n        # Can fit 1 four-person group.\n        ans += 1\n\n    # Any empty row can fit 2 four-person groups.\n    return ans + (n - len(rowToSeats)) * 2",
      "title": "1386. Cinema Seat Allocation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ce7eb24-578d-4a2a-b1db-0f311e35030f",
      "code": "class Solution:\n  def getKth(self, lo: int, hi: int, k: int) -> int:\n    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]\n\n  def _getPow(self, n: int) -> int:\n    if n == 1:\n      return 0\n    if n % 2 == 0:\n      return 1 + self._getPow(n // 2)\n    return 1 + self._getPow(n * 3 + 1)",
      "title": "1387. Sort Integers by The Power Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba37d927-131f-46a8-a022-41e12650a1a5",
      "code": "class Solution:\n  def maxSizeSlices(self, slices: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum the sum of slices if you can pick k slices from\n      slices[i..j).\n      \"\"\"\n      if k == 1:\n        return max(slices[i:j])\n      # Note that j - i is not the number of all the left slices. Since you\n      # Might have chosen not to take a slice in a previous step, there would be\n      # Leftovers outside [i:j]. If you take slices[i], one of the slices your\n      # Friends take will be outside of [i:j], so the length of [i:j] is reduced\n      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only\n      # Requires one slice).\n      if j - i < 2 * k - 1:\n        return -math.inf\n      return max(slices[i] + dp(i + 2, j, k - 1),\n                 dp(i + 1, j, k))\n\n    k = len(slices) // 3\n    return max(dp(0, len(slices) - 1, k),\n               dp(1, len(slices), k))",
      "title": "1388. Pizza With 3n Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9feca9e6-ba8a-4d4f-918e-b8647cdb3dfc",
      "code": "class Solution:\n  def createTargetArray(self, nums, index):\n    ans = []\n    for num, i in zip(nums, index):\n      ans.insert(i, num)\n    return ans",
      "title": "1389. Create Target Array in the Given Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ef3e8df-8a73-411e-9ff3-7983b7dda8c7",
      "code": "class Solution:\n  def sumFourDivisors(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      divisor = 0\n      for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n          if divisor == 0:\n            divisor = i\n          else:\n            divisor = 0\n            break\n      if divisor > 0 and divisor * divisor < num:\n        ans += 1 + num + divisor + num // divisor\n\n    return ans",
      "title": "1390. Four Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fda3105a-429b-4fed-bb93-f6468853fa2d",
      "code": "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    BASE = 26\n    HASH = 8_417_508_174_513\n    n = len(s)\n    maxLength = 0\n    pow = 1\n    prefixHash = 0  # the hash of s[0..i]\n    suffixHash = 0  # the hash of s[j..n)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    j = n - 1\n    for i in range(n - 1):\n      prefixHash = (prefixHash * BASE + val(s[i])) % HASH\n      suffixHash = (val(s[j]) * pow + suffixHash) % HASH\n      pow = pow * BASE % HASH\n      if prefixHash == suffixHash:\n        maxLength = i + 1\n      j -= 1\n\n    return s[:maxLength]",
      "title": "1392. Longest Happy Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83d44690-33b4-49b4-add0-84b00682321b",
      "code": "class Solution:\n  def findLucky(self, arr: list[int]) -> int:\n    count = [0] * (len(arr) + 1)\n\n    for a in arr:\n      if a <= len(arr):\n        count[a] += 1\n\n    for i in range(len(arr), 0, -1):\n      if count[i] == i:\n        return i\n\n    return -1",
      "title": "1394. Find Lucky Integer in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a2a6e0e-96ef-4144-a4bb-294c42e24742",
      "code": "class Solution:\n  def numTeams(self, rating: list[int]) -> int:\n    ans = 0\n\n    for i in range(1, len(rating) - 1):\n      # Calculate soldiers on the left with less//greater ratings.\n      leftLess = 0\n      leftGreater = 0\n      for j in range(i):\n        if rating[j] < rating[i]:\n          leftLess += 1\n        elif rating[j] > rating[i]:\n          leftGreater += 1\n      # Calculate soldiers on the right with less//greater ratings.\n      rightLess = 0\n      rightGreater = 0\n      for j in range(i + 1, len(rating)):\n        if rating[j] < rating[i]:\n          rightLess += 1\n        elif rating[j] > rating[i]:\n          rightGreater += 1\n      ans += leftLess * rightGreater + leftGreater * rightLess\n\n    return ans",
      "title": "1395. Count Number of Teams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3dc180ef-471f-47ca-8310-0235ac914008",
      "code": "class Solution:\n  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n    MOD = 1_000_000_007\n    evilLPS = self._getLPS(evil)\n\n    @functools.lru_cache(None)\n    def getNextMatchedEvilCount(j: int, currChar: str) -> int:\n      \"\"\"\n      Returns the number of next matched evil count, where there're j matches\n      with `evil` and the current letter is ('a' + j).\n      \"\"\"\n      while j > 0 and evil[j] != currChar:\n        j = evilLPS[j - 1]\n      return j + 1 if evil[j] == currChar else j\n\n    @functools.lru_cache(None)\n    def dp(i: int, matchedEvilCount: int, isS1Prefix: bool, isS2Prefix: bool) -> int:\n      \"\"\"\n      Returns the number of good strings for s[i..n), where there're j matches\n      with `evil`, `isS1Prefix` indicates if the current letter is tightly bound\n      for `s1` and `isS2Prefix` indicates if the current letter is tightly bound\n      for `s2`.\n      \"\"\"\n      # s[0..i) contains `evil`, so don't consider any ongoing strings.\n      if matchedEvilCount == len(evil):\n        return 0\n      # Run out of strings, so contribute one.\n      if i == n:\n        return 1\n      ans = 0\n      minCharIndex = ord(s1[i]) if isS1Prefix else ord('a')\n      maxCharIndex = ord(s2[i]) if isS2Prefix else ord('z')\n      for charIndex in range(minCharIndex, maxCharIndex + 1):\n        c = chr(charIndex)\n        nextMatchedEvilCount = getNextMatchedEvilCount(matchedEvilCount, c)\n        ans += dp(i + 1, nextMatchedEvilCount,\n                  isS1Prefix and c == s1[i],\n                  isS2Prefix and c == s2[i])\n        ans %= MOD\n      return ans\n\n    return dp(0, 0, True, True)\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "1397. Find All Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a844668-b820-4c64-a14b-b4359b8c710c",
      "code": "class Solution:\n  def countLargestGroup(self, n: int) -> int:\n    count = [0] * (9 * 4 + 1)\n    for i in range(1, n + 1):\n      count[self._getDigitSum(i)] += 1\n    return count.count(max(count))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1399. Count Largest Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c867c659-86d3-4bb2-9365-2bf5b0614195",
      "code": "class Solution:\n  def canConstruct(self, s: str, k: int) -> bool:\n    # If |s| < k, we cannot construct k strings from the s.\n    # If the number of letters that have odd counts > k, the minimum number of\n    # palindromic strings we can construct is > k.\n    return sum(freq & 1\n               for freq in collections.Counter(s).values()) <= k <= len(s)",
      "title": "1400. Construct K Palindrome Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "918c6314-8354-491d-b7a0-e9bffd34fca4",
      "code": "class Solution:\n  def maxSatisfaction(self, satisfaction: list[int]) -> int:\n    ans = 0\n    sumSatisfaction = 0\n\n    for s in sorted(satisfaction, reverse=True):\n      sumSatisfaction += s\n      if sumSatisfaction <= 0:\n        return ans\n      ans += sumSatisfaction\n\n    return ans",
      "title": "1402. Reducing Dishes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dffc300c-d653-4879-9680-0ff71ea29bad",
      "code": "class Solution:\n  def minSubsequence(self, nums: list[int]) -> list[int]:\n    ans = []\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n    half = sum(nums) // 2\n\n    while half >= 0:\n      ans.append(-maxHeap[0])\n      half += heapq.heappop(maxHeap)\n\n    return ans",
      "title": "1403. Minimum Subsequence in Non-Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47768ab3-3b30-4754-b3bc-071885fafad6",
      "code": "class Solution:\n  def numSteps(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    # All the trailing 0s can be popped by 1 step.\n    while chars[-1] == '0':\n      chars.pop()\n      ans += 1\n\n    if ''.join(chars) == '1':\n      return ans\n\n    # `s` is now odd, so add 1 to `s` and cost 1 step.\n    # All the 1s will become 0s and can be popped by 1 step.\n    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then\n    # dividing by 2).\n    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)",
      "title": "1404. Number of Steps to Reduce a Number in Binary Representation to One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c77ebd-060b-4ec3-b131-e869c3205930",
      "code": "class Solution:\n  def stoneGameIII(self, stoneValue: list[int]) -> str:\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"\n      Returns the maximum relative score Alice can make with stoneValue[i..n).\n      \"\"\"\n      if i == len(stoneValue):\n        return 0\n\n      res = -math.inf\n      summ = 0\n\n      for j in range(i, i + 3):\n        if j == len(stoneValue):\n          break\n        summ += stoneValue[j]\n        res = max(res, summ - dp(j + 1))\n\n      return res\n\n    score = dp(0)\n    if score == 0:\n      return 'Tie'\n    return 'Alice' if score > 0 else 'Bob'",
      "title": "1406. Stone Game III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "632b3a83-7f79-4ef2-8567-66d6c2c2af6d",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return True\n\n\nclass Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    trie = Trie()\n\n    for word in sorted(words, key=lambda x: -len(x)):\n      if trie.search(word):\n        ans.append(word)\n      for i in range(len(word)):\n        trie.insert(word[i:])\n\n    return ans",
      "title": "1408. String Matching in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "861a0c56-f66a-47ae-9a36-a187dc1762bd",
      "code": "class Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    for a in words:\n      for b in words:\n        if len(a) < len(b) and b.find(a) != -1:\n          ans.append(a)\n          break\n    return ans",
      "title": "1408. String Matching in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9131cc3e-897e-4109-8b52-6c5dee607999",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def processQueries(self, queries: list[int], m: int) -> list[int]:\n    ans = []\n    # Map [-m, m] to [0, 2 * m].\n    tree = FenwickTree(2 * m + 1)\n    numToIndex = {num: num + m for num in range(1, m + 1)}\n\n    for num in range(1, m + 1):\n      tree.add(num + m, 1)\n\n    nextEmptyIndex = m  # Map 0 to m.\n\n    for query in queries:\n      index = numToIndex[query]\n      ans.append(tree.get(index - 1))\n      # Move `query` from `index` to `nextEmptyIndex`.\n      tree.add(index, -1)\n      tree.add(nextEmptyIndex, 1)\n      numToIndex[query] = nextEmptyIndex\n      nextEmptyIndex -= 1\n\n    return ans",
      "title": "1409. Queries on a Permutation With Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd797673-620c-4c32-ac7a-75be51cef5f8",
      "code": "class Solution:\n  def entityParser(self, text: str) -> str:\n    entityToChar = {'&quot;': '\"', '&apos;': '\\'',\n                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}\n\n    for entity, c in entityToChar.items():\n      text = text.replace(entity, c)\n\n    # Process '&' in last.\n    return text.replace('&amp;', '&')",
      "title": "1410. HTML Entity Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "390d81b3-e86b-40e8-a446-7df9e4466205",
      "code": "class Solution:\n  def minStartValue(self, nums: list[int]) -> int:\n    summ = 0\n    minSum = 0\n\n    for num in nums:\n      summ += num\n      minSum = min(minSum, summ)\n\n    return 1 - minSum",
      "title": "1413. Minimum Value to Get Positive Step by Step Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10979169-72a1-43d1-9fe2-38a4ca51dd4c",
      "code": "class Solution:\n  def findMinFibonacciNumbers(self, k: int) -> int:\n    ans = 0\n    a = 1  # F_1\n    b = 1  # F_2\n\n    while b <= k:\n      #    a, b = F_{i + 1}, F_{i + 2}\n      # -> a, b = F_{i + 2}, F_{i + 3}\n      a, b = b, a + b\n\n    while a > 0:\n      if a <= k:\n        k -= a\n        ans += 1\n      #    a, b = F_{i + 2}, F_{i + 3}\n      # -> a, b = F_{i + 1}, F_{i + 2}\n      a, b = b - a, a\n\n    return ans",
      "title": "1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b791a131-e5dd-46e6-95a9-9fdc79da9057",
      "code": "class Solution:\n  def getHappyString(self, n: int, k: int) -> str:\n    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}\n    q = collections.deque(['a', 'b', 'c'])\n\n    while len(q[0]) != n:\n      u = q.popleft()\n      for nextLetter in nextLetters[u[-1]]:\n        q.append(u + nextLetter)\n\n    return '' if len(q) < k else q[k - 1]",
      "title": "1415. The k-th Lexicographical String of All Happy Strings of Length n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac2874e8-cd86-4369-af4e-3b2efaf4fe10",
      "code": "class Solution:\n  def reformat(self, s: str) -> str:\n    A = [c for c in s if c.isalpha()]\n    B = [c for c in s if c.isdigit()]\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)",
      "title": "1417. Reformat The String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df2492d8-2d30-4b0c-99c2-1a3526b93789",
      "code": "class Solution:\n  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n    CROAK = 'croak'\n    ans = 0\n    frogs = 0\n    count = [0] * 5\n\n    for c in croakOfFrogs:\n      count[CROAK.index(c)] += 1\n      if any(count[i] > count[i - 1] for i in range(1, 5)):\n        return -1\n      if c == 'c':\n        frogs += 1\n      elif c == 'k':\n        frogs -= 1\n      ans = max(ans, frogs)\n\n    return ans if frogs == 0 else -1",
      "title": "1419. Minimum Number of Frogs Croaking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7b5249a-1dd3-4206-8d21-b64647606214",
      "code": "class Solution:\n  def numOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of ways to build an array of length i, where j\n    # is the maximum number and k is the `search_cost`\n    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n    # prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j\n    prefix = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n\n    for j in range(1, m + 1):\n      dp[1][j][1] = 1\n      prefix[1][j][1] = j\n\n    for i in range(2, n + 1):  # for each length\n      for j in range(1, m + 1):  # for each max value\n        for cost in range(1, k + 1):  # for each cost\n          # 1. Appending any of [1, j] in the i-th position doesn't change the\n          #    maximum and cost.\n          # 2. Appending j in the i-th position makes j the new max and cost 1.\n          dp[i][j][cost] = (j * dp[i - 1][j][cost] +\n                            prefix[i - 1][j - 1][cost - 1]) % MOD\n          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % MOD\n\n    return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD",
      "title": "1420. Build Array Where You Can Find The Maximum Exactly K Comparisons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69a2cfaa-e4f9-4248-b55f-744da743c643",
      "code": "class Solution:\n  def maxScore(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n    ones = s.count('1')\n\n    for i in range(len(s) - 1):\n      if s[i] == '0':\n        zeros += 1\n      else:\n        ones -= 1\n      ans = max(ans, zeros + ones)\n\n    return ans",
      "title": "1422. Maximum Score After Splitting a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c0a362b-0020-4944-9573-60854f626a12",
      "code": "class Solution:\n  def maxScore(self, cardPoints: list[int], k: int) -> int:\n    n = len(cardPoints)\n    summ = sum(cardPoints)\n    windowSum = sum(cardPoints[:n - k])\n    ans = summ - windowSum\n\n    for i in range(k):\n      windowSum -= cardPoints[i]\n      windowSum += cardPoints[i + n - k]\n      ans = max(ans, summ - windowSum)\n\n    return ans",
      "title": "1423. Maximum Points You Can Obtain from Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "867ea0c9-cb5d-4e9f-92fa-f9c840430fc2",
      "code": "class Solution:\n  def constrainedSubsetSum(self, nums: list[int], k: int) -> int:\n    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]\n    dp = [0] * len(nums)\n    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0\n    # in decreasing order.\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if dq:\n        dp[i] = max(dq[0], 0) + num\n      else:\n        dp[i] = num\n      while dq and dq[-1] < dp[i]:\n        dq.pop()\n      dq.append(dp[i])\n      if i >= k and dp[i - k] == dq[0]:\n        dq.popleft()\n\n    return max(dp)",
      "title": "1425. Constrained Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f18c9a58-c6d7-428f-92fb-9b8f6ac72e71",
      "code": "class Solution:\n  def countElements(self, arr: list[int]) -> int:\n    count = collections.Counter(arr)\n    return sum(freq\n               for a, freq in count.items()\n               if count[a + 1] > 0)",
      "title": "1426. Counting Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f0cff10-428e-4d27-bee6-36625b788c3e",
      "code": "class Solution:\n  def stringShift(self, s: str, shift: list[list[int]]) -> str:\n    move = 0\n\n    for direction, amount in shift:\n      if direction == 0:\n        move -= amount\n      else:\n        move += amount\n\n    move %= len(s)\n    return s[-move:] + s[:-move]",
      "title": "1427. Perform String Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f320412b-bc84-4cdf-8c4a-9333f870b8c5",
      "code": "# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class BinaryMatrix(object):\n#   def get(self, row: int, col: int) -> int:\n#   def dimensions(self) -> list[int]:\n\nclass Solution:\n  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:\n    m, n = binaryMatrix.dimensions()\n    ans = -1\n    l = 0\n    r = n - 1\n\n    while l <= r:\n      mid = (l + r) // 2\n      if any(binaryMatrix.get(i, mid) for i in range(m)):\n        ans = mid\n        r = mid - 1\n      else:\n        l = mid + 1\n\n    return ans",
      "title": "1428. Leftmost Column with at Least a One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a87a91cc-4943-41d0-b168-3de786829d9c",
      "code": "class Solution:\n  def isValidSequence(self, root: TreeNode | None, arr: list[int]) -> bool:\n    def isValidSequence(root: TreeNode | None, i: int) -> bool:\n      if not root:\n        return False\n      if i == len(arr) - 1:\n        return root.val == arr[i] and not root.left and not root.right\n      return root.val == arr[i] and (\n          isValidSequence(root.left, i + 1) or\n          isValidSequence(root.right, i + 1))\n\n    return isValidSequence(root, 0)",
      "title": "1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "692d7939-a0f0-4974-8448-89fb27c74a37",
      "code": "class Solution:\n  def kidsWithCandies(\n      self,\n      candies: list[int],\n      extraCandies: int,\n  ) -> list[bool]:\n    maxCandy = max(candies)\n    return [candy + extraCandies >= maxCandy for candy in candies]",
      "title": "1431. Kids With the Greatest Number of Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b065fc3-c10f-4ef3-b478-2d3137577904",
      "code": "class Solution:\n  def maxDiff(self, num: int) -> int:\n    s = str(num)\n\n    def firstNot(s: str, t: str) -> int:\n      for i, c in enumerate(s):\n        if all(c != d for d in t):\n          return i\n      return 0\n\n    firstNot9 = firstNot(s, '9')\n    firstNot01 = firstNot(s, '01')\n    a = s.replace(s[firstNot9], '9')\n    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')\n    return int(a) - int(b)",
      "title": "1432. Max Difference You Can Get From Changing an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45a4b22d-6b5d-47b4-b9d7-9a1f15b698ed",
      "code": "class Solution:\n  def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n    count1 = collections.Counter(s1)\n    count2 = collections.Counter(s2)\n\n    def canBreak(count1: dict[str, int], count2: dict[str, int]) -> bool:\n      \"\"\"Returns True if count1 can break count2.\"\"\"\n      diff = 0\n      for c in string.ascii_lowercase:\n        diff += count2[c] - count1[c]\n        # count2 is alphabetically greater than count1.\n        if diff < 0:\n          return False\n      return True\n\n    return canBreak(count1, count2) or canBreak(count2, count1)",
      "title": "1433. Check If a String Can Break Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be084c38-c986-4141-b600-f9a1730965b7",
      "code": "class Solution:\n  def destCity(self, paths: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for a, b in paths:\n      count[a] += 1\n\n    for a, b in paths:\n      if b in count:\n        count[b] -= 1\n        if count[b] == 0:\n          del count[b]\n      else:\n        return b",
      "title": "1436. Destination City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bd35832-24de-42ac-8a6d-1d7e876de4b9",
      "code": "class Solution:\n  def kLengthApart(self, nums: list[int], k: int) -> bool:\n    if k == 0:\n      return True\n\n    n = len(nums)\n    curr = 0\n    next = 1\n\n    while curr < n and next < n:\n      if nums[next] == 1:\n        if nums[curr] == 1 and next - curr <= k:\n          return False\n        curr = next\n      next += 1\n\n    return True",
      "title": "1437. Check If All 1's Are at Least Length K Places Away",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90880113-ca20-4c38-8421-c7a9525f2968",
      "code": "class Solution:\n  def buildArray(self, target: list[int], n: int) -> list[str]:\n    ans = []\n    i = 0  # Target pointer\n    num = 1  # Curr num\n\n    while i < len(target):\n      t = target[i]\n      if t == num:\n        ans.append('Push')\n        i += 1\n      else:\n        ans.append('Push')\n        ans.append('Pop')\n      num += 1\n\n    return ans",
      "title": "1441. Build an Array With Stack Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfe21943-abaa-44c9-a721-9f9b8c78a54e",
      "code": "class Solution:\n  def countTriplets(self, arr: list[int]) -> int:\n    ans = 0\n    xors = [0]\n    prefix = 0\n\n    for i, a in enumerate(arr):\n      prefix ^= a\n      xors.append(prefix)\n\n    for j in range(1, len(arr)):\n      for i in range(0, j):\n        xors_i = xors[j] ^ xors[i]\n        for k in range(j, len(arr)):\n          xors_k = xors[k + 1] ^ xors[j]\n          if xors_i == xors_k:\n            ans += 1\n\n    return ans",
      "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "335a2c91-57ae-4c20-8924-4c04d61cddcc",
      "code": "class Solution:\n  def ways(self, pizza: list[str], k: int) -> int:\n    MOD = 1_000_000_007\n    M = len(pizza)\n    N = len(pizza[0])\n    prefix = [[0] * (N + 1) for _ in range(M + 1)]\n\n    for i in range(M):\n      for j in range(N):\n        prefix[i + 1][j + 1] = ((pizza[i][j] == 'A') + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def hasApple(row1: int, row2: int, col1: int, col2: int) -> bool:\n      \"\"\"Returns True if pizza[row1..row2)[col1..col2) has apple.\"\"\"\n      return (prefix[row2][col2] - prefix[row1][col2] -\n              prefix[row2][col1] + prefix[row1][col1]) > 0\n\n    @functools.lru_cache(None)\n    def dp(m: int, n: int, k: int) -> int:\n      \"\"\"Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.\"\"\"\n      if k == 0:\n        return 1 if hasApple(m, M, n, N) else 0\n\n      res = 0\n\n      for i in range(m + 1, M):  # Cut horizontally.\n        if hasApple(m, i, n, N) and hasApple(i, M, n, N):\n          res += dp(i, n, k - 1)\n\n      for j in range(n + 1, N):  # Cut vertically.\n        if hasApple(m, M, n, j) and hasApple(m, M, j, N):\n          res += dp(m, j, k - 1)\n\n      return res % MOD\n\n    return dp(0, 0, k - 1)",
      "title": "1444. Number of Ways of Cutting a Pizza",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0033856d-d133-46a6-af3b-d9935b740649",
      "code": "class Solution:\n  def maxPower(self, s: str) -> int:\n    ans = 1\n    count = 1\n\n    for i in range(1, len(s)):\n      count = count + 1 if s[i] == s[i - 1] else 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "1446. Consecutive Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19aac3ec-53eb-4191-a2b5-eaf831684284",
      "code": "class Solution:\n  def simplifiedFractions(self, n: int) -> list[str]:\n    ans = []\n    for denominator in range(2, n + 1):\n      for numerator in range(1, denominator):\n        if math.gcd(denominator, numerator) == 1:\n          ans.append(str(numerator) + '/' + str(denominator))\n    return ans",
      "title": "1447. Simplified Fractions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "209fcbaa-b9f2-4d81-bdea-4f226e5721a2",
      "code": "class Solution:\n  def arrangeWords(self, text: str) -> str:\n    words = text.split()\n    count = collections.defaultdict(list)\n\n    for word in words:\n      count[len(word)].append(word.lower())\n\n    c2 = OrderedDict(sorted(count.items()))\n\n    ans = []\n\n    for l in c2:\n      for word in c2[l]:\n        ans.append(word)\n\n    ans[0] = ans[0].capitalize()\n\n    return ' '.join(ans)",
      "title": "1451. Rearrange Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22b62415-ffe5-41c3-8af1-70fe7923cbf0",
      "code": "class Solution:\n  def peopleIndexes(self, favoriteCompanies: list[list[str]]) -> list[int]:\n    ans = []\n    n = len(favoriteCompanies)\n    companies = [set(comp) for comp in favoriteCompanies]\n\n    for i in range(n):\n      find = False\n      for j in range(n):\n        if i == j:\n          continue\n        if companies[i].issubset(companies[j]):\n          find = True\n          break\n      if not find:\n        ans.append(i)\n\n    return ans",
      "title": "1452. People Whose List of Favorite Companies Is Not a Subset of Another List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e91ee46a-2307-4add-9abe-f36c53f9b3cc",
      "code": "class Point:\n  def __init__(self, x: float, y: float):\n    self.x = x\n    self.y = y\n\n\nclass Solution:\n  def numPoints(self, darts: list[list[int]], r: int) -> int:\n    ERR = 1e-6\n    ans = 1\n    points = [Point(x, y) for x, y in darts]\n\n    def dist(p: Point, q: Point) -> float:\n      return ((p.x - q.x)**2 + (p.y - q.y)**2)**0.5\n\n    def getCircles(p: Point, q: Point) -> list[Point]:\n      if dist(p, q) - 2.0 * r > ERR:\n        return []\n      m = Point((p.x + q.x) / 2, (p.y + q.y) / 2)\n      distCM = (r**2 - (dist(p, q) / 2)**2)**0.5\n      alpha = math.atan2(p.y - q.y, q.x - p.x)\n      return [Point(m.x - distCM * math.sin(alpha), m.y - distCM * math.cos(alpha)),\n              Point(m.x + distCM * math.sin(alpha), m.y + distCM * math.cos(alpha))]\n\n    for i, j in itertools.combinations(points, 2):\n      for c in getCircles(i, j):\n        count = 0\n        for point in points:\n          if dist(c, point) - r <= ERR:\n            count += 1\n        ans = max(ans, count)\n\n    return ans",
      "title": "1453. Maximum Number of Darts Inside of a Circular Dartboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be1f4a89-e85f-455e-87d8-57792f61bcb3",
      "code": "class Solution:\n  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n    words = sentence.split()\n\n    for i, word in enumerate(words):\n      if word.startswith(searchWord):\n        return i + 1\n\n    return -1",
      "title": "1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "930189b7-4dc9-4962-b87b-ab7c71ef1e17",
      "code": "class Solution:\n  def maxVowels(self, s: str, k: int) -> int:\n    ans = 0\n    mx = 0\n    VOWELS = 'aeiou'\n\n    for i, c in enumerate(s):\n      if c in VOWELS:\n        mx += 1\n      if i >= k and s[i - k] in VOWELS:\n        mx -= 1\n      ans = max(ans, mx)\n\n    return ans",
      "title": "1456. Maximum Number of Vowels in a Substring of Given Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a48cfbf2-f912-41f0-a15e-84202a526a14",
      "code": "class Solution:\n  def pseudoPalindromicPaths(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        path ^= 1 << root.val\n        if path & (path - 1) == 0:\n          ans += 1\n        return\n\n      dfs(root.left, path ^ 1 << root.val)\n      dfs(root.right, path ^ 1 << root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1457. Pseudo-Palindromic Paths in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfa5fec0-11fa-45db-9b38-18331a8be50b",
      "code": "class Solution:\n  def maxDotProduct(self, A: list[int], B: list[int]) -> int:\n    m = len(A)\n    n = len(B)\n    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)\n    # and nums2[0..j)\n    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],\n                               max(0, dp[i][j]) + A[i] * B[j])\n\n    return dp[m][n]",
      "title": "1458. Max Dot Product of Two Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "190394cd-06bb-4994-b2f2-179c7610d39f",
      "code": "class Solution:\n  def canBeEqual(self, target: list[int], arr: list[int]) -> bool:\n    return collections.Counter(arr) == collections.Counter(target)",
      "title": "1460. Make Two Arrays Equal by Reversing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ab6234b-ece8-416b-9ae4-ebef031b06bf",
      "code": "class Solution:\n  def hasAllCodes(self, s: str, k: int) -> bool:\n    n = 1 << k\n    if len(s) < n:\n      return False\n\n    # used[i] := True if i is a substring of `s`\n    used = [0] * n\n\n    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)\n    for i in range(k - 1, len(s)):\n      # Include the s[i].\n      windowStr = (windowStr << 1) + int(s[i])\n      # Discard the s[i - k].\n      windowStr &= n - 1\n      used[windowStr] = True\n\n    return all(u for u in used)",
      "title": "1461. Check If a String Contains All Binary Codes of Size K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3546f81-c5b1-4c0f-8578-c50e4c042fb0",
      "code": "class Solution:\n  def checkIfPrerequisite(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    graph = [[] for _ in range(numCourses)]\n    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    # DFS from every course.\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: list[list[int]], u: int, used: list[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)",
      "title": "1462. Course Schedule IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "745246a5-d592-47b7-afac-cb30461bf960",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    max1 = 0\n    max2 = 0\n\n    for num in nums:\n      if num > max1:\n        max2, max1 = max1, num\n      elif num > max2:\n        max2 = num\n\n    return (max1 - 1) * (max2 - 1)",
      "title": "1464. Maximum Product of Two Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c11bc02-f412-4738-b212-5bb432a4e0af",
      "code": "class Solution:\n  def maxArea(\n      self,\n      h: int,\n      w: int,\n      horizontalCuts: list[int],\n      verticalCuts: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # the maximum gap of each direction\n    maxGapX = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(horizontalCuts) + [h]))\n    maxGapY = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(verticalCuts) + [w]))\n    return maxGapX * maxGapY % MOD",
      "title": "1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2da1dfa5-c670-48f7-81fa-5efd70887d58",
      "code": "from enum import Enum\n\n\nclass BoxCase(Enum):\n  EQUAL_DISTANT_BALLS = 0\n  EQUAL_BALLS = 1\n\n\nclass Solution:\n  def getProbability(self, balls: list[int]) -> float:\n    n = sum(balls) // 2\n    fact = [1, 1, 2, 6, 24, 120, 720]\n\n    def cases(\n            i: int,\n            ballsCountA: int,\n            ballsCountB: int,\n            colorsCountA: int,\n            colorsCountB,\n            boxCase: BoxCase) -> float:\n      if ballsCountA > n or ballsCountB > n:\n        return 0\n      if i == len(balls):\n        return (1 if boxCase == BoxCase.EQUAL_BALLS\n                else colorsCountA == colorsCountB)\n\n      ans = 0.0\n\n      # balls taken from A for `balls[i]`\n      for ballsTakenA in range(balls[i] + 1):\n        ballsTakenB = balls[i] - ballsTakenA\n        newcolorsCountA = colorsCountA + (ballsTakenA > 0)\n        newcolorsCountB = colorsCountB + (ballsTakenB > 0)\n        ans += (cases(i + 1,\n                      ballsCountA + ballsTakenA,\n                      ballsCountB + ballsTakenB,\n                      newcolorsCountA, newcolorsCountB, boxCase) /\n                (fact[ballsTakenA] * fact[ballsTakenB]))\n\n      return ans\n\n    return (cases(0, 0, 0, 0, 0, BoxCase.EQUAL_DISTANT_BALLS) /\n            cases(0, 0, 0, 0, 0, BoxCase.EQUAL_BALLS))",
      "title": "1467. Probability of a Two Boxes Having The Same Number of Distinct Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2679dde-1358-4909-a242-d14b85fcb96f",
      "code": "class Solution:\n  def shuffle(self, nums: list[int], n: int) -> list[int]:\n    ans = []\n    for a, b in zip(nums[:n], nums[n:]):\n      ans.append(a)\n      ans.append(b)\n    return ans",
      "title": "1470. Shuffle the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89a13472-8da8-4a4e-90b6-72e936eeaa93",
      "code": "class Solution:\n  def getStrongest(self, arr: list[int], k: int) -> list[int]:\n    arr.sort()\n\n    ans = []\n    median = arr[(len(arr) - 1) // 2]\n    l = 0\n    r = len(arr) - 1\n\n    for _ in range(k):\n      if median - arr[l] > arr[r] - median:\n        ans.append(arr[l])\n        l -= 1\n      else:\n        ans.append(arr[r])\n        r += 1\n\n    return ans",
      "title": "1471. The k Strongest Values in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb387fe8-4a7d-43e9-866a-40dc003ca69c",
      "code": "class Solution:\n  def deleteNodes(\n      self,\n      head: ListNode | None,\n      m: int,\n      n: int,\n  ) -> ListNode | None:\n    curr = head\n    prev = None  # prev.next == curr\n\n    while curr:\n      # Set the m-th node as `prev`.\n      for _ in range(m):\n        if not curr:\n          break\n        prev = curr\n        curr = curr.next\n      # Set the (m + n + 1)-th node as `curr`.\n      for _ in range(n):\n        if not curr:\n          break\n        curr = curr.next\n      # Delete the nodes [m + 1..n - 1].\n      prev.next = curr\n\n    return head",
      "title": "1474. Delete N Nodes After M Nodes of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "798eae36-d478-45cf-80db-16c698736b12",
      "code": "class Solution:\n  def finalPrices(self, prices: list[int]) -> list[int]:\n    ans = prices.copy()\n    stack = []\n\n    for i, price in enumerate(prices):\n      # stack[-1] := i in the problem description.\n      while stack and prices[stack[-1]] >= price:\n        ans[stack.pop()] -= price\n      stack.append(i)\n\n    return ans",
      "title": "1475. Final Prices With a Special Discount in a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8dfec32-1142-4b37-b2fc-87d5897b3fb2",
      "code": "class Solution:\n  def runningSum(self, nums: list[int]) -> list[int]:\n    return itertools.accumulate(nums)",
      "title": "1480. Running Sum of 1d Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ff19596-5508-4e22-b69e-ddf02a3e10fa",
      "code": "class Solution:\n  def findLeastNumOfUniqueInts(self, arr: list[int], k: int) -> int:\n    minHeap = list(collections.Counter(arr).values())\n    heapq.heapify(minHeap)\n\n    # Greedily remove the k least frequent numbers to have the least number of unique integers.\n    while k > 0:\n      k -= heapq.heappop(minHeap)\n\n    return len(minHeap) + (1 if k < 0 else 0)",
      "title": "1481. Least Number of Unique Integers after K Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a12b85-e5ba-4471-a771-5b9768015b97",
      "code": "class Solution:\n  def minDays(self, bloomDay: list[int], m: int, k: int) -> int:\n    if len(bloomDay) < m * k:\n      return -1\n\n    def getBouquetCount(waitingDays: int) -> int:\n      \"\"\"\n      Returns the number of bouquets (k flowers needed) can be made after the\n      `waitingDays`.\n      \"\"\"\n      bouquetCount = 0\n      requiredFlowers = k\n      for day in bloomDay:\n        if day > waitingDays:\n          # Reset `requiredFlowers` since there was not enough adjacent flowers.\n          requiredFlowers = k\n        else:\n          requiredFlowers -= 1\n          if requiredFlowers == 0:\n            # Use k adjacent flowers to make a bouquet.\n            bouquetCount += 1\n            requiredFlowers = k\n      return bouquetCount\n\n    l = min(bloomDay)\n    r = max(bloomDay)\n\n    while l < r:\n      mid = (l + r) // 2\n      if getBouquetCount(mid) >= m:\n        r = mid\n      else:\n        l = mid + 1\n\n    return l",
      "title": "1482. Minimum Number of Days to Make m Bouquets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "778a5dfa-9afb-4ffa-b563-f3e399ded5b1",
      "code": "class Solution:\n  def xorOperation(self, n: int, start: int) -> int:\n    return functools.reduce(operator.xor,\n                            [start + 2 * i for i in range(n)])",
      "title": "1486. XOR Operation in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea42f890-71c0-4546-ad1b-38c745cb6b41",
      "code": "class Solution:\n  def getFolderNames(self, names: list[str]) -> list[str]:\n    ans = []\n    nameToSuffix = {}\n\n    for name in names:\n      if name in nameToSuffix:\n        suffix = nameToSuffix[name] + 1\n        newName = self._getName(name, suffix)\n        while newName in nameToSuffix:\n          suffix += 1\n          newName = self._getName(name, suffix)\n        nameToSuffix[name] = suffix\n        nameToSuffix[newName] = 0\n        ans.append(newName)\n      else:\n        nameToSuffix[name] = 0\n        ans.append(name)\n\n    return ans\n\n  def _getName(self, name: str, suffix: int) -> str:\n    return name + '(' + str(suffix) + ')'",
      "title": "1487. Making File Names Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3acbbd2c-1180-4879-a10c-a4ae2ff28116",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def avoidFlood(self, rains: list[int]) -> list[int]:\n    ans = [-1] * len(rains)\n    lakeIdToFullDay = {}\n    emptyDays = SortedSet()  # indices of rains[i] == 0\n\n    for i, lakeId in enumerate(rains):\n      if lakeId == 0:\n        emptyDays.add(i)\n        continue\n        # The lake was full in a previous day. Greedily find the closest day\n        # to make the lake empty.\n      if lakeId in lakeIdToFullDay:\n        fullDay = lakeIdToFullDay[lakeId]\n        emptyDayIndex = emptyDays.bisect_right(fullDay)\n        if emptyDayIndex == len(emptyDays):  # Not found.\n          return []\n        # Empty the lake at this day.\n        emptyDay = emptyDays[emptyDayIndex]\n        ans[emptyDay] = lakeId\n        emptyDays.discard(emptyDay)\n      # The lake with `lakeId` becomes full at the day `i`.\n      lakeIdToFullDay[lakeId] = i\n\n    # Empty an arbitrary lake if there are remaining empty days.\n    for emptyDay in emptyDays:\n      ans[emptyDay] = 1\n\n    return ans",
      "title": "1488. Avoid Flood in The City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1095bf4d-b54f-4443-a6e1-6f532a395b51",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    # Record the index information, so edges[i] := (u, v, weight, index).\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    # Sort by the weight.\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(\n            firstEdge: list[int],\n            deletedEdgeIndex: int) -> int | float:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      # Deleting the `edge` increases the weight of the MST or makes the MST\n      # invalid.\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      # If an edge can be in any MST, we can always add `edge` to the edge set.\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]",
      "title": "1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ceca0c8f-e749-4856-9f59-1a94d2717f9b",
      "code": "class Solution:\n  def average(self, salary: list[int]) -> float:\n    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)",
      "title": "1491. Average Salary Excluding the Minimum and Maximum Salary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebf96408-6e25-48d5-85e4-3f0581ae081f",
      "code": "class Solution:\n  def kthFactor(self, n: int, k: int) -> int:\n    # If i is a divisor of n, then n // i is also a divisor of n. So, we can\n    # find all the divisors of n by processing the numbers <= sqrt(n).\n    factor = 1\n    i = 0  # the i-th factor\n\n    while factor < math.isqrt(n):\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return factor\n      factor += 1\n\n    factor = n // factor\n    while factor >= 1:\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return n // factor\n      factor -= 1\n\n    return -1",
      "title": "1492. The kth Factor of n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efb2d47c-67ff-45c2-a1c9-84a6112626e9",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l)\n\n    return ans",
      "title": "1493. Longest Subarray of 1's After Deleting One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28f1a0ad-796c-4690-b03c-fdafedd55e55",
      "code": "class Solution:\n  def minNumberOfSemesters(\n      self,\n      n: int,\n      relations: list[list[int]],\n      k: int,\n  ) -> int:\n    # dp[i] := the minimum number of semesters to take the courses, where i is\n    # the bitmask of the taken courses\n    dp = [n] * (1 << n)\n    # prereq[i] := bitmask of all dependencies of course i\n    prereq = [0] * n\n\n    for prevCourse, nextCourse in relations:\n      prereq[nextCourse - 1] |= 1 << prevCourse - 1\n\n    dp[0] = 0  # Don't need time to finish 0 course.\n\n    for i in range(1 << n):\n      # the bitmask of all the courses can be taken\n      coursesCanBeTaken = 0\n      # Can take the j-th course if i contains all of j's prerequisites.\n      for j in range(n):\n        if (i & prereq[j]) == prereq[j]:\n          coursesCanBeTaken |= 1 << j\n      # Don't take any course which is already taken.\n      # (i represents set of courses that are already taken)\n      coursesCanBeTaken &= ~i\n      # Enumerate every bitmask subset of `coursesCanBeTaken`.\n      s = coursesCanBeTaken\n      while s:\n        if s.bit_count() <= k:\n          # Any combination of courses (if <= k) can be taken now.\n          # i | s := combining courses taken with courses can be taken.\n          dp[i | s] = min(dp[i | s], dp[i] + 1)\n        s = (s - 1) & coursesCanBeTaken\n\n    return dp[-1]",
      "title": "1494. Parallel Courses II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6480dc0-c287-4fa7-b87e-3abddd9d7cf3",
      "code": "class Solution:\n  def canArrange(self, arr: list[int], k: int) -> bool:\n    count = [0] * k\n\n    for a in arr:\n      a %= k\n      count[a if a >= 0 else a + k] += 1\n\n    return (count[0] % 2 == 0 and\n            all(count[i] == count[k - i]\n                for i in range(1, k // 2 + 1)))",
      "title": "1497. Check If Array Pairs Are Divisible by k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1268d0a4-0a05-4621-b2c1-6ddb80c900cb",
      "code": "class Solution:\n  def numSubseq(self, nums: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    l = 0\n    r = n - 1\n    while l <= r:\n      if nums[l] + nums[r] <= target:\n        ans += pow(2, r - l, MOD)\n        l += 1\n      else:\n        r -= 1\n\n    return ans % MOD",
      "title": "1498. Number of Subsequences That Satisfy the Given Sum Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2266cd07-966a-4893-83a7-a699d4d777f0",
      "code": "class Solution:\n  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:\n    ans = -math.inf\n    maxQ = collections.deque()  # (y - x, x)\n\n    for x, y in points:\n      # Remove the invalid points, xj - xi > k\n      while maxQ and x - maxQ[0][1] > k:\n        maxQ.popleft()\n      if maxQ:\n        ans = max(ans, x + y + maxQ[0][0])\n      # Remove the points that contribute less value and have a bigger x.\n      while maxQ and y - x >= maxQ[-1][0]:\n        maxQ.pop()\n      maxQ.append((y - x, x))\n\n    return ans",
      "title": "1499. Max Value of Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76794d98-59d6-4655-ab4a-750960846cd7",
      "code": "class Solution:\n  def numSubmat(self, mat: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(mat[0])\n\n    for row in mat:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n      ans += self._count(hist)\n\n    return ans\n\n  def _count(self, hist: list[int]) -> int:\n    # submatrices[i] := the number of submatrices, where the i-th column is the\n    # right border\n    submatrices = [0] * len(hist)\n    stack = []\n\n    for i, h in enumerate(hist):\n      while stack and hist[stack[-1]] >= h:\n        stack.pop()\n      if stack:\n        prevIndex = stack[-1]\n        submatrices[i] = submatrices[prevIndex] + h * (i - prevIndex)\n      else:\n        submatrices[i] = h * (i + 1)\n      stack.append(i)\n\n    return sum(submatrices)",
      "title": "1504. Count Submatrices With All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e57e73a-d9a6-4b9c-a6f7-269ba9690566",
      "code": "class Solution:\n  def findRoot(self, tree: list['Node']) -> 'Node':\n    sum = 0\n\n    for node in tree:\n      sum ^= node.val\n      for child in node.children:\n        sum ^= child.val\n\n    for node in tree:\n      if node.val == sum:\n        return node",
      "title": "1506. Find Root of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c398bb-db0c-489a-bc99-d909ae0c415a",
      "code": "class Solution:\n  def reformatDate(self, date: str) -> str:\n    monthToNumString = {\n        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',\n        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',\n        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',\n    }\n    day, month, year = date.split()\n    day = day[:-2] if len(day) == 4 else '0' + day[:-2]\n    return f'{year}-{monthToNumString[month]}-{day}'",
      "title": "1507. Reformat Date",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33a8f35d-cb8c-45d9-8d09-8e766dd59dad",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 5:\n      return 0\n\n    ans = math.inf\n\n    nums.sort()\n\n    # 1. Change nums[0..i) to nums[i].\n    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].\n    for i in range(4):\n      ans = min(ans, nums[n - 4 + i] - nums[i])\n\n    return ans",
      "title": "1509. Minimum Difference Between Largest and Smallest Value in Three Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6810690b-b446-42b4-a75f-a94fc77c5050",
      "code": "class Solution:\n  def maxProbability(\n      self,\n      n: int,\n      edges: list[list[int]],\n      succProb: list[float],\n      start: int,\n      end: int,\n  ) -> float:\n    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}\n    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)\n    seen = [False] * n\n\n    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):\n      graph[u].append((v, prob))\n      graph[v].append((u, prob))\n\n    while maxHeap:\n      prob, u = heapq.heappop(maxHeap)\n      prob *= -1\n      if u == end:\n        return prob\n      if seen[u]:\n        continue\n      seen[u] = True\n      for nextNode, edgeProb in graph[u]:\n        if seen[nextNode]:\n          continue\n        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))\n\n    return 0",
      "title": "1514. Path with Maximum Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5a93fae-f28e-44c8-9fd8-b04dedfd9bb0",
      "code": "class Solution:\n  def getMinDistSum(self, positions: list[list[int]]) -> float:\n    def distSum(a: float, b: float) -> float:\n      return sum(math.sqrt((a - x)**2 + (b - y)**2)\n                 for x, y in positions)\n\n    ERR = 1e-6\n    currX = 50\n    currY = 50\n    ans = distSum(currX, currY)\n    step = 1\n\n    while step > ERR:\n      shouldDecreaseStep = True\n      for dx, dy in [(0, step), (0, -step), (step, 0), (-step, 0)]:\n        x = currX + dx\n        y = currY + dy\n        newDistSum = distSum(x, y)\n        if newDistSum < ans:\n          ans = newDistSum\n          currX = x\n          currY = y\n          shouldDecreaseStep = False\n      if shouldDecreaseStep:\n        step /= 10\n\n    return ans",
      "title": "1515. Best Position for a Service Centre",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ec7cef4-9d87-4685-a9a4-91e227c159e3",
      "code": "class Solution:\n  def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':\n    if p in q.children:\n      return root\n\n    # Create a dummy Node for the case when root == p\n    dummy = Node(None, [root])\n\n    # Get each parent of p and q\n    pParent = self._getParent(dummy, p)\n    qParent = self._getParent(p, q)\n\n    # Get p's original index in p's parent\n    pIndex = pParent.children.index(p)\n    pParent.children.pop(pIndex)\n\n    q.children.append(p)\n\n    # If q is in the p's subtree, qParent != None\n    if qParent:\n      qParent.children.remove(q)\n      pParent.children.insert(pIndex, q)\n\n    return dummy.children[0]\n\n  def _getParent(self, root: 'Node', target: 'Node') -> Optional['Node']:\n    for child in root.children:\n      if child == target:\n        return root\n      res = self._getParent(child, target)\n      if res:\n        return res\n    return None",
      "title": "1516. Move Sub-Tree of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65eafe9e-b9a7-471f-b83c-5473193f45ca",
      "code": "class Solution:\n  def closestToTarget(self, arr: list[int], target: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in arr:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the AND operation, the size of `dp` will be at most\n      # num.bit_count() + 1.\n      dp = {num} | {val & num for val in dp}\n      ans = min(ans, min(abs(target - val) for val in dp))\n\n    return ans",
      "title": "1521. Find a Value of a Mysterious Function Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b1c8a23-2310-418d-bdfe-563df0b5777c",
      "code": "class Solution:\n  def diameter(self, root: 'Node') -> int:\n    ans = 0\n\n    def maxDepth(root: 'Node') -> int:\n      \"\"\"Returns the maximum depth of the subtree rooted at `root`.\"\"\"\n      nonlocal ans\n      maxSubDepth1 = 0\n      maxSubDepth2 = 0\n      for child in root.children:\n        maxSubDepth = maxDepth(child)\n        if maxSubDepth > maxSubDepth1:\n          maxSubDepth2 = maxSubDepth1\n          maxSubDepth1 = maxSubDepth\n        elif maxSubDepth > maxSubDepth2:\n          maxSubDepth2 = maxSubDepth\n      ans = max(ans, maxSubDepth1 + maxSubDepth2)\n      return 1 + maxSubDepth1\n\n    maxDepth(root)\n    return ans",
      "title": "1522. Diameter of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21974f9d-74a4-4ee5-9267-b62240c7489e",
      "code": "class Solution:\n  def numSplits(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    seen = set()\n    prefix = [0] * n\n    suffix = [0] * n\n\n    for i in range(n):\n      seen.add(s[i])\n      prefix[i] = len(seen)\n\n    seen.clear()\n\n    for i in reversed(range(n)):\n      seen.add(s[i])\n      suffix[i] = len(seen)\n\n    for i in range(n - 1):\n      if prefix[i] == suffix[i + 1]:\n        ans += 1\n\n    return ans",
      "title": "1525. Number of Good Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a64dbc9-af42-475b-8d02-5e03d7f69013",
      "code": "class Solution:\n  def minNumberOperations(self, target: list[int]) -> int:\n    ans = target[0]\n\n    for a, b in zip(target, target[1:]):\n      if a < b:\n        ans += b - a\n\n    return ans",
      "title": "1526. Minimum Number of Increments on Subarrays to Form a Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb316117-b0fe-49ed-8182-cc8a15dcdb95",
      "code": "class Solution:\n  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n    def getLength(maxFreq: int) -> int:\n      \"\"\"Returns the length to compress `maxFreq`.\"\"\"\n      if maxFreq == 1:\n        return 1  # c\n      if maxFreq < 10:\n        return 2  # [1-9]c\n      if maxFreq < 100:\n        return 3  # [1-9][0-9]c\n      return 4    # [1-9][0-9][0-9]c\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the length of optimal dp of s[i..n) with at most k deletion.\"\"\"\n      if k < 0:\n        return math.inf\n      if i == len(s) or len(s) - i <= k:\n        return 0\n\n      ans = math.inf\n      maxFreq = 0  # the maximum frequency in s[i..j]\n      count = collections.Counter()\n\n      # Make letters in s[i..j] be the same.\n      # Keep the letter that has the maximum frequency in this range and remove\n      # the other letters.\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        maxFreq = max(maxFreq, count[s[j]])\n        ans = min(ans, getLength(maxFreq) +\n                  dp(j + 1, k - (j - i + 1 - maxFreq)))\n\n      return ans\n\n    return dp(0, k)",
      "title": "1531. String Compression II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37ca4ab4-5692-4cab-a88e-33779e1b693e",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# # Returns the length of the array\n#   def length(self) -> int:\n#\n\n\nclass Solution:\n  def getIndex(self, reader: 'ArrayReader') -> int:\n    l = 0\n    r = reader.length() - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if (r - l) % 2 == 0:\n        res = reader.compareSub(l, m - 1, m + 1, r)\n        if res == 0:\n          return m\n        if res == 1:\n          r = m - 1\n        else:  # res == -1\n          l = m + 1\n      else:\n        res = reader.compareSub(l, m, m + 1, r)\n        # res is either 1 or -1.\n        if res == 1:\n          r = m\n        else:  # res == -1\n          l = m + 1\n\n    return l",
      "title": "1533. Find the Index of the Large Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "852949f0-b9e8-4f38-8b84-f7f65b852645",
      "code": "class Solution:\n  def countGoodTriplets(self, arr: list[int], a: int, b: int, c: int) -> int:\n    return sum(abs(arr[i] - arr[j]) <= a and\n               abs(arr[j] - arr[k]) <= b and\n               abs(arr[i] - arr[k]) <= c\n               for i, j, k in itertools.combinations(range(len(arr)), 3))",
      "title": "1534. Count Good Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed330698-99a4-4285-9a92-7b48686dfb3b",
      "code": "class Solution:\n  def getWinner(self, arr: list[int], k: int) -> int:\n    ans = arr[0]\n    wins = 0\n\n    i = 1\n    while i < len(arr) and wins < k:\n      if arr[i] > ans:\n        ans = arr[i]\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "1535. Find the Winner of an Array Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30542790-7dc4-458a-9b36-894d3d727bb6",
      "code": "class Solution:\n  def minSwaps(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # suffixZeros[i] := the number of suffix zeros in the i-th row\n    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]\n\n    for i in range(n):\n      neededZeros = n - 1 - i\n      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).\n      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)\n      if j == -1:\n        return -1\n      # Move the rows[j] to the rows[i].\n      for k in range(j, i, -1):\n        suffixZeros[k] = suffixZeros[k - 1]\n      ans += j - i\n\n    return ans",
      "title": "1536. Minimum Swaps to Arrange a Binary Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcee416c-13fd-4b44-b399-838f8cf5aa0a",
      "code": "class Solution:\n  def maxSum(self, nums1: list[int], nums2: list[int]) -> int:\n    # Keep the running the sum of `nums1` and `nums2` before the next rendezvous.\n    # Since `nums1` and `nums2` are increasing, move forward on the smaller one\n    # to ensure we don't miss any rendezvous. When meet rendezvous, choose the\n    # better path.\n    ans = 0\n    sum1 = 0  # sum(nums1) in (the prevoious rendezvous, the next rendezvous)\n    sum2 = 0  # sum(nums2) in (the prevoious rendezvous, the next rendezvous)\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] < nums2[j]:\n        sum1 += nums1[i]\n        i += 1\n      elif nums1[i] > nums2[j]:\n        sum2 += nums2[j]\n        j += 1\n      else:  # An rendezvous happens.\n        ans += max(sum1, sum2) + nums1[i]\n        sum1 = 0\n        sum2 = 0\n        i += 1\n        j += 1\n\n    while i < len(nums1):\n      sum1 += nums1[i]\n      i += 1\n\n    while j < len(nums2):\n      sum2 += nums2[j]\n      j += 1\n\n    return (ans + max(sum1, sum2)) % (10**9 + 7)",
      "title": "1537. Get the Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ef13092-4da6-4fca-95ba-6a6b10f71220",
      "code": "# \"\"\"\n# This is the ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n#   # Compares 4 different elements in the array\n#   # Returns 4 if the values of the 4 elements are the same (0 or 1).\n#   # Returns 2 if threeelements have a valueequal to 0and oneelement has\n#   #           value equal to 1or vice versa.\n#   # Returns 0 if two element have a value equal to 0 and two elements have a\n#   #           value equal to 1.\n#   def query(self, a: int, b: int, c: int, d: int) -> int:\n#\n#   # Returns the length of the array\n#   def length(self) -> int:\n#\n\nclass Solution:\n  def guessMajority(self, reader: 'ArrayReader') -> int:\n    n = reader.length()\n    query0123 = reader.query(0, 1, 2, 3)\n    query1234 = reader.query(1, 2, 3, 4)\n    zeros = 1  # the number of numbers that are same as `nums[0]`\n    nonZeros = 0  # the number of numbers that are different from `nums[0]`\n    indexNot0 = -1  # any index i s.t. nums[i] != nums[0]\n\n    # Find which group nums[1..3] belong to.\n    for i in range(1, 4):\n      abcd = [0] + [num for num in [1, 2, 3] if num != i] + [4]\n      if reader.query(*abcd) == query1234:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    # Find which group nums[4..n) belong to.\n    for i in range(4, n):\n      if reader.query(1, 2, 3, i) == query0123:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    if zeros == nonZeros:\n      return -1\n    if zeros > nonZeros:\n      return 0\n    return indexNot0",
      "title": "1538. Guess the Majority in a Hidden Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5e8b23d-4315-4c95-87c1-eae2367ca3f3",
      "code": "class Solution:\n  def canConvertString(self, s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n      return False\n\n    # e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\n    # 1. a -> b, need 1 move.\n    # 2. a -> b, need 1 + 26 moves.\n    # 3. b -> c, need 1 + 26 * 2 moves.\n    shiftCount = [0] * 26\n\n    for a, b in zip(s, t):\n      shift = (ord(b) - ord(a) + 26) % 26\n      if shift == 0:\n        continue\n      if shift + 26 * shiftCount[shift] > k:\n        return False\n      shiftCount[shift] += 1\n\n    return True",
      "title": "1540. Can Convert String in K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3ef33b3-fea3-4152-adc1-033480e830fc",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    neededRight = 0   # Increment by 2 for each '('.\n    missingLeft = 0   # Increment by 1 for each missing '('.\n    missingRight = 0  # Increment by 1 for each missing ')'.\n\n    for c in s:\n      if c == '(':\n        if neededRight % 2 == 1:\n          # e.g. '()(...'\n          missingRight += 1\n          neededRight -= 1\n        neededRight += 2\n      else:  # c == ')'\n        neededRight -= 1\n        if neededRight < 0:\n          # e.g. '()))...'\n          missingLeft += 1\n          neededRight += 2\n\n    return neededRight + missingLeft + missingRight",
      "title": "1541. Minimum Insertions to Balance a Parentheses String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27ed7d4b-b303-4743-8c9c-0352ddff3682",
      "code": "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = [len(s)] * 1024\n    prefixToIndex[0] = -1\n\n    for i, c in enumerate(s):\n      prefix ^= 1 << int(c)\n      ans = max(ans, i - prefixToIndex[prefix])\n      for j in range(10):\n        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])\n      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)\n\n    return ans",
      "title": "1542. Find Longest Awesome Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcc361b1-ca5f-42a8-817f-020d1198d576",
      "code": "class Solution:\n  def makeGood(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if ans and self._is_bad_pair(ans[-1], c):\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)\n\n  def _is_bad_pair(self, a: str, b: str) -> bool:\n    return a != b and a.lower() == b.lower()",
      "title": "1544. Make The String Great",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3e5c3fd-6b1c-4240-ae62-894243fc7ec2",
      "code": "class Solution:\n  def findKthBit(self, n: int, k: int) -> str:\n    if n == 1:\n      return '0'\n    midIndex = pow(2, n - 1)  # 1-indexed\n    if k == midIndex:\n      return '1'\n    if k < midIndex:\n      return self.findKthBit(n - 1, k)\n    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'",
      "title": "1545. Find Kth Bit in Nth Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa905fed-bc29-4e77-ae33-c1066ee5435c",
      "code": "class Solution:\n  def maxNonOverlapping(self, nums: list[int], target: int) -> int:\n    # Ending the subarray ASAP always has a better result.\n    ans = 0\n    prefix = 0\n    prefixes = {0}\n\n    # Greedily find the subarrays that equal to the target.\n    for num in nums:\n      # Check if there is a subarray ends in here and equals to the target.\n      prefix += num\n      if prefix - target in prefixes:\n        # Find one and discard all the prefixes that have been used.\n        ans += 1\n        prefix = 0\n        prefixes = {0}\n      else:\n        prefixes.add(prefix)\n\n    return ans",
      "title": "1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5a1fec2-2c7e-4fa6-b689-73154e9c800c",
      "code": "class Solution:\n  def minCost(self, n: int, cuts: list[int]) -> int:\n    arr = sorted([0] + cuts + [n])\n\n    dp = [[0] * len(arr) for _ in range(len(arr))]\n\n    for d in range(2, len(arr)):\n      for i in range(len(arr) - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], arr[j] - arr[i] + dp[i][k] + dp[k][j])\n\n    return dp[0][len(arr) - 1]",
      "title": "1547. Minimum Cost to Cut a Stick",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fe0d41b-e983-44e3-8c03-932462511425",
      "code": "class Solution:\n  def mostSimilar(self, n: int, roads: list[list[int]], names: list[str],\n                  targetPath: list[str]) -> list[int]:\n    # cost[i][j] := the minimum cost to start from names[i] in path[j]\n    cost = [[-1] * len(targetPath) for _ in range(len(names))]\n    # next[i][j] := the best next of names[i] in path[j]\n    next = [[0] * len(targetPath) for _ in range(len(names))]\n    graph = [[] for _ in range(n)]\n\n    for u, v in roads:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    minDist = math.inf\n    start = 0\n\n    def dfs(nameIndex: int, pathIndex: int) -> int:\n      if cost[nameIndex][pathIndex] != -1:\n        return cost[nameIndex][pathIndex]\n\n      editDist = names[nameIndex] != targetPath[pathIndex]\n      if pathIndex == len(targetPath) - 1:\n        return editDist\n\n      minDist = math.inf\n\n      for v in graph[nameIndex]:\n        dist = dfs(v, pathIndex + 1)\n        if dist < minDist:\n          minDist = dist\n          next[nameIndex][pathIndex] = v\n\n      cost[nameIndex][pathIndex] = editDist + minDist\n      return editDist + minDist\n\n    for i in range(n):\n      dist = dfs(i, 0)\n      if dist < minDist:\n        minDist = dist\n        start = i\n\n    ans = []\n\n    while len(ans) < len(targetPath):\n      ans.append(start)\n      start = next[start][len(ans) - 1]\n\n    return ans",
      "title": "1548. The Most Similar Path in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f75d2b16-c6f6-46c1-879d-3cb004d90691",
      "code": "class Solution:\n  def threeConsecutiveOdds(self, arr: list[int]) -> bool:\n    count = 0\n    for a in arr:\n      count = 0 if a % 2 == 0 else count + 1\n      if count == 3:\n        return True\n    return False",
      "title": "1550. Three Consecutive Odds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "156e4f75-7e59-4790-953a-3b4708a12530",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    def arr(self, i: int) -> int:\n      \"\"\"Returns the i-th element of `arr`, where 1 <= i <= n.\"\"\"\n      return (i - 1) * 2 + 1\n\n    #     median := median of arr\n    #   diffs[i] := median - arr[i] where i <= i <= n // 2\n    #        ans := sum(diffs)\n    # e.g.\n    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n    #        ans = (4 + 2) * 2 // 2 = 6\n    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n    #        ans = (5 + 1) * 3 // 2 = 9\n    halfSize = n // 2\n    median = (arr(n) + arr(1)) // 2\n    firstDiff = median - arr(1)\n    lastDiff = median - arr(halfSize)\n    return (firstDiff + lastDiff) * halfSize // 2",
      "title": "1551. Minimum Operations to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71e6a2ac-b781-4ea8-adf7-45631841003b",
      "code": "class Solution:\n  def maxDistance(self, position: list[int], m: int) -> int:\n    position.sort()\n\n    l = 1\n    r = position[-1] - position[0]\n\n    def numBalls(force: int) -> int:\n      balls = 0\n      prevPosition = -force\n      for pos in position:\n        if pos - prevPosition >= force:\n          balls += 1\n          prevPosition = pos\n      return balls\n\n    while l < r:\n      mid = r - (r - l) // 2\n      if numBalls(mid) >= m:\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "1552. Magnetic Force Between Two Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a90b0236-e851-40b1-b61d-85b192ec23bf",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def minDays(self, n: int) -> int:\n    if n <= 1:\n      return n\n    return 1 + min(self.minDays(n // 3) + n % 3,\n                   self.minDays(n // 2) + n % 2)",
      "title": "1553. Minimum Number of Days to Eat N Oranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5955c879-6bee-49ff-90de-0a850a5be4c1",
      "code": "class Solution:\n  def differByOne(self, dict: list[str]) -> bool:\n    BASE = 26\n    HASH = 1_000_000_007\n    m = len(dict[0])\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    def getHash(s: str) -> int:\n      \"\"\"Returns the hash of `s`. Assume the length of `s` is m.\n\n      e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].\n      \"\"\"\n      hash = 0\n      for c in s:\n        hash = (hash * BASE + val(c))\n      return hash\n\n    wordToHash = [getHash(word) for word in dict]\n\n    # Compute the hash without each letter.\n    # e.g. hash of \"abc\" = 26^2 * 'a' + 26 * 'b' + 'c'\n    #   newHash of \"a*c\" = hash - 26 * 'b'\n    coefficient = 1\n    for j in range(m - 1, -1, -1):\n      newHashToIndices = collections.defaultdict(list)\n      for i, (word, hash) in enumerate(zip(dict, wordToHash)):\n        newHash = (hash - coefficient * val(word[j]) % HASH + HASH) % HASH\n        if any(word[: j] == dict[index][: j] and word[j + 1:] ==\n               dict[index][j + 1:] for index in newHashToIndices[newHash]):\n          return True\n        newHashToIndices[newHash].append(i)\n      coefficient = coefficient * BASE % HASH\n\n    return False",
      "title": "1554. Strings Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b81bfc85-7546-4ca2-84a7-998a47d9e3b7",
      "code": "class Solution:\n  def thousandSeparator(self, n: int) -> str:\n    return f'{n:,}'.replace(',', '.')",
      "title": "1556. Thousand Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62e5b928-39e0-4952-b552-f08f7d7a8842",
      "code": "class Solution:\n  def findSmallestSetOfVertices(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return [i for i, d in enumerate(inDegrees) if d == 0]",
      "title": "1557. Minimum Number of Vertices to Reach All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41a090a8-8545-438d-a8a0-3356943d723a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    mx = max(nums)\n    return (sum(num.bit_count() for num in nums) +\n            (0 if mx == 0 else mx.bit_length() - 1))",
      "title": "1558. Minimum Numbers of Function Calls to Make Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c90c6d18-79c4-491c-9eb3-5265913c0ed4",
      "code": "class Solution:\n  def mostVisited(self, n: int, rounds: list[int]) -> list[int]:\n    # 1. if start <= end, [start, end] is the most visited.\n    #\n    #      s --------- n\n    # 1 -------------- n\n    # 1 ------ e\n    #\n    # 2. if start > end, [1, end] and [start, n] are the most visited.\n    #\n    #             s -- n\n    # 1 -------------- n\n    # 1 ------ e\n    start = rounds[0]\n    end = rounds[-1]\n    if start <= end:\n      return range(start, end + 1)\n    return list(range(1, end + 1)) + list(range(start, n + 1))",
      "title": "1560. Most Visited Sector in a Circular Track",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5e8d9fb-9cc3-42ee-941d-698a004be796",
      "code": "class Solution:\n  def maxCoins(self, piles: list[int]) -> int:\n    return sum(sorted(piles)[len(piles) // 3::2])",
      "title": "1561. Maximum Number of Coins You Can Get",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddf41a4a-7362-4900-b62a-3531da470553",
      "code": "class Solution:\n  def findLatestStep(self, arr: list[int], m: int) -> int:\n    if len(arr) == m:\n      return len(arr)\n\n    ans = -1\n    step = 0\n    # sizes[i] := the size of the group starting from i or ending in i\n    # (1-indexed)\n    sizes = [0] * (len(arr) + 2)\n\n    for i in arr:\n      step += 1\n      # In the previous step, there exists a group with a size of m.\n      if sizes[i - 1] == m or sizes[i + 1] == m:\n        ans = step - 1\n      head = i - sizes[i - 1]\n      tail = i + sizes[i + 1]\n      sizes[head] = tail - head + 1\n      sizes[tail] = tail - head + 1\n\n    return ans",
      "title": "1562. Find Latest Group of Size M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45dba7a4-7d8e-4e89-a558-d57c2349218c",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    realWarehouse = [warehouse[0]]\n\n    for i in range(1, len(warehouse)):\n      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))\n\n    boxes.sort()\n    i = 0  # boxes' index\n    for height in reversed(realWarehouse):\n      if i < len(boxes) and boxes[i] <= height:\n        i += 1\n\n    return i",
      "title": "1564. Put Boxes Into the Warehouse I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "333321b4-5eba-4a41-a069-446e0a731e00",
      "code": "class Solution:\n  def containsPattern(self, arr: list[int], m: int, k: int) -> bool:\n    count = 0\n    for i in range(m, len(arr)):\n      count = count + 1 if arr[i] == arr[i - m] else 0\n      if count == m * k - m:\n        return True\n    return False",
      "title": "1566. Detect Pattern of Length M Repeated K or More Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f84c593c-49dd-4c1c-9520-c38b36f90940",
      "code": "class Solution:\n  def getMaxLen(self, nums: list[int]) -> int:\n    ans = 0\n    # the maximum length of subarrays ending in `num` with a negative product\n    neg = 0\n    # the maximum length of subarrays ending in `num` with a positive product\n    pos = 0\n\n    for num in nums:\n      pos = 0 if num == 0 else pos + 1\n      neg = 0 if num == 0 or neg == 0 else neg + 1\n      if num < 0:\n        pos, neg = neg, pos\n      ans = max(ans, pos)\n\n    return ans",
      "title": "1567. Maximum Length of Subarray With Positive Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a4ec92d-602d-408a-84df-1fc6dbaa0875",
      "code": "class Solution:\n  def minDays(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(grid: list[list[int]], i: int, j: int, seen: set[tuple[int, int]]):\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or (x, y) in seen:\n          continue\n        dfs(grid, x, y, seen)\n\n    def disconnected(grid: list[list[int]]) -> bool:\n      islandsCount = 0\n      seen = set()\n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 0 or (i, j) in seen:\n            continue\n          if islandsCount > 1:\n            return True\n          islandsCount += 1\n          dfs(grid, i, j, seen)\n      return islandsCount != 1\n\n    if disconnected(grid):\n      return 0\n\n    # Try to remove 1 land.\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          grid[i][j] = 0\n          if disconnected(grid):\n            return 1\n          grid[i][j] = 1\n\n    # Remove 2 lands.\n    return 2",
      "title": "1568. Minimum Number of Days to Disconnect Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cde699c6-4ca2-411c-ac43-e6e4dc262b60",
      "code": "class Solution:\n  def diagonalSum(self, mat: list[list[int]]) -> int:\n    n = len(mat)\n    ans = 0\n\n    for i in range(n):\n      ans += mat[i][i]\n      ans += mat[n - 1 - i][i]\n\n    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]",
      "title": "1572. Matrix Diagonal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f21e91c-7e44-4b40-9f27-98644c4b0b04",
      "code": "class Solution:\n  def numWays(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % MOD\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % MOD",
      "title": "1573. Number of Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cda523b-45e6-41df-83b8-0e1ba881ec22",
      "code": "class Solution:\n  def findLengthOfShortestSubarray(self, arr: list[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    # arr[0..l] is non-decreasing.\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    # arr[r..n - 1] is non-decreasing.\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    # Remove arr[l + 1..n - 1] or arr[0..r - 1].\n    ans = min(n - 1 - l, r)\n\n    # Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers\n    # at the rightmost indices, l and n - 1, and greedily shrink them toward\n    # the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],\n    # we ensure that `arr` becomes non-decreasing.\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans",
      "title": "1574. Shortest Subarray to be Removed to Make Array Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e8d8e84-ed6d-427d-9096-e1aca4677617",
      "code": "class Solution:\n  def countRoutes(\n      self,\n      locations: list[int],\n      start: int,\n      finish: int,\n      fuel: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(locations)\n    # dp[i][j] := the number of ways to reach the `finish` city from the i-th\n    # city with `j` fuel\n    dp = [[0] * (fuel + 1) for _ in range(n)]\n\n    for f in range(fuel + 1):\n      dp[finish][f] = 1\n\n    for f in range(fuel + 1):\n      for i in range(n):\n        for j in range(n):\n          if i == j:\n            continue\n          requiredFuel = abs(locations[i] - locations[j])\n          if requiredFuel <= f:\n            dp[i][f] += dp[j][f - requiredFuel]\n            dp[i][f] %= MOD\n\n    return dp[start][fuel]",
      "title": "1575. Count All Possible Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cfdf5bb-67ca-4911-a75c-ea38ee95fb2d",
      "code": "class Solution:\n  def modifyString(self, s: str) -> str:\n    ans = []\n\n    def nextAvailable(ans: list[int], s: str, i: int) -> str:\n      c = 'a'\n      while ((i > 0 and ans[i - 1] == c) or\n             (i + 1 < len(s) and c == s[i + 1])):\n        c = chr(ord(c) + 1)\n      return c\n\n    for i, c in enumerate(s):\n      if c == '?':\n        ans.append(nextAvailable(ans, s, i))\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "1576. Replace All ?'s to Avoid Consecutive Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f8e08f9-8c39-483e-ae78-22f1182d1676",
      "code": "class Solution:\n  def numTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    def countTriplets(A: list[int], B: list[int]):\n      \"\"\"Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].\"\"\"\n      res = 0\n      count = collections.Counter(B)\n\n      for a in A:\n        target = a * a\n        for b, freq in count.items():\n          if target % b > 0 or target // b not in count:\n            continue\n          if target // b == b:\n            res += freq * (freq - 1)\n          else:\n            res += freq * count[target // b]\n\n      return res // 2\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)",
      "title": "1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11c1b92c-8d68-4d2c-abc2-454e3cf362ef",
      "code": "class Solution:\n  def minCost(self, colors: str, neededTime: list[int]) -> int:\n    ans = 0\n    maxNeededTime = neededTime[0]\n\n    for i in range(1, len(colors)):\n      if colors[i] == colors[i - 1]:\n        ans += min(maxNeededTime, neededTime[i])\n        # For each continuous group, Bob needs to remove every balloon except\n        # the one with the maximum `neededTime`. So, he should hold the balloon\n        # with the highest `neededTime` in his hand.\n        maxNeededTime = max(maxNeededTime, neededTime[i])\n      else:\n        # If the current balloon is different from the previous one, discard\n        # the balloon from the previous group and hold the new one in hand.\n        maxNeededTime = neededTime[i]\n\n    return ans",
      "title": "1578. Minimum Time to Make Rope Colorful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bf89b77-f98a-424a-85a2-4f5fe00883b3",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    # Greedily put type 3 edges in the front.\n    for type_, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type_ == 3:  # Can be traversed by Alice and Bob.\n          # Note that we should use | instead of or because if the first\n          # expression is True, short-circuiting will skip the second\n          # expression.\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type_ == 2:  # Can be traversed by Bob.\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:  # type == 1 Can be traversed by Alice.\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    return (len(edges) - requiredEdges\n            if alice.count == 1 and bob.count == 1\n            else -1)",
      "title": "1579. Remove Max Number of Edges to Keep Graph Fully Traversable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a349ffe-096b-4d52-85ff-68d86fab3676",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    l = 0\n    r = len(warehouse) - 1\n\n    for box in sorted(boxes, reverse=True):\n      if l > r:\n        return len(warehouse)\n      if box <= warehouse[l]:\n        l += 1\n      elif box <= warehouse[r]:\n        r -= 1\n\n    return l + (len(warehouse) - r - 1)",
      "title": "1580. Put Boxes Into the Warehouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca3e7030-785c-4b21-bf7c-d4eee59f8c85",
      "code": "class Solution:\n  def numSpecial(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans",
      "title": "1582. Special Positions in a Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ac3cf54-f4ef-4821-92ec-c11aa02b571a",
      "code": "class Solution:\n  def unhappyFriends(\n      self,\n      n: int,\n      preferences: list[list[int]],\n      pairs: list[list[int]],\n  ) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans",
      "title": "1583. Count Unhappy Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3bc4613-7a01-43c5-86ac-c8031f3e61d9",
      "code": "class Solution:\n  def minCostConnectPoints(self, points: list[int]) -> int:\n    # dist[i] := the minimum distance to connect the points[i]\n    dist = [math.inf] * len(points)\n    ans = 0\n\n    for i in range(len(points) - 1):\n      for j in range(i + 1, len(points)):\n        # Try to connect the points[i] with the points[j].\n        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +\n                      abs(points[i][1] - points[j][1]))\n        # Swap the points[j] (the point with the mnimum distance) with the\n        # points[i + 1].\n        if dist[j] < dist[i + 1]:\n          points[j], points[i + 1] = points[i + 1], points[j]\n          dist[j], dist[i + 1] = dist[i + 1], dist[j]\n      ans += dist[i + 1]\n\n    return ans",
      "title": "1584. Min Cost to Connect All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09d0441-7a34-41ab-92d6-60b95d8fb4b4",
      "code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    if collections.Counter(s) != collections.Counter(t):\n      return False\n\n    positions = [collections.deque() for _ in range(10)]\n\n    for i, c in enumerate(s):\n      positions[int(c)].append(i)\n\n    # For each digit in `t`, check if we can put this digit in `s` at the same\n    # position as `t`. Ensure that all the left digits are equal to or greater\n    # than it. This is because the only operation we can perform is sorting in\n    # ascending order. If there is a digit to the left that is smaller than it,\n    # we can never move it to the same position as in `t`. However, if all the\n    # digits to its left are equal to or greater than it, we can move it one\n    # position to the left until it reaches the same position as in `t`.\n    for c in t:\n      d = int(c)\n      front = positions[d].popleft()\n      for smaller in range(d):\n        if positions[smaller] and positions[smaller][0] < front:\n          return False\n\n    return True",
      "title": "1585. Check If String Is Transformable With Substring Sort Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "742599b7-ff4c-4835-b568-946ff87c68e3",
      "code": "class Solution:\n  def sumOddLengthSubarrays(self, arr: list[int]) -> int:\n    ans = 0\n    # Maintain two sums of subarrays ending in the previous index.\n    # Each time we meet a new number, we'll consider 'how many times' it should\n    # contribute to the newly built subarrays by calculating the number of\n    # previous even/odd-length subarrays.\n    prevEvenSum = 0  # the sum of even-length subarrays\n    prevOddSum = 0  # the sum of odd-length subarrays\n\n    for i, a in enumerate(arr):\n      # (i + 1) // 2 := the number of previous odd-length subarrays.\n      currEvenSum = prevOddSum + ((i + 1) // 2) * a\n      # i // 2 + 1 := the number of previous even-length subarrays\n      # (including 0).\n      currOddSum = prevEvenSum + (i // 2 + 1) * a\n      ans += currOddSum\n      prevEvenSum = currEvenSum\n      prevOddSum = currOddSum\n\n    return ans",
      "title": "1588. Sum of All Odd Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbfb91ae-071f-4188-9528-5d2cdbcb715d",
      "code": "class Solution:\n  def maxSumRangeQuery(self, nums: list[int], requests: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # count[i] := the number of times nums[i] has been requested\n    count = [0] * len(nums)\n\n    for start, end in requests:\n      count[start] += 1\n      if end + 1 < len(nums):\n        count[end + 1] -= 1\n\n    for i in range(1, len(nums)):\n      count[i] += count[i - 1]\n\n    for num, c in zip(sorted(nums), sorted(count)):\n      ans += num * c\n      ans %= MOD\n\n    return ans",
      "title": "1589. Maximum Sum Obtained of Any Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "912b57eb-a52f-4dec-b98e-a939773c018a",
      "code": "class Solution:\n  def minSubarray(self, nums: list[int], p: int) -> int:\n    summ = sum(nums)\n    remainder = summ % p\n    if remainder == 0:\n      return 0\n\n    ans = len(nums)\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefix %= p\n      target = (prefix - remainder + p) % p\n      if target in prefixToIndex:\n        ans = min(ans, i - prefixToIndex[target])\n      prefixToIndex[prefix] = i\n\n    return -1 if ans == len(nums) else ans",
      "title": "1590. Make Sum Divisible by P",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61d613c2-e9db-4eec-9e49-93ad9d1cf27c",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: list[list[int]]) -> bool:\n    MAX_COLOR = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    # graph[u] := {v1, v2} means v1 and v2 cover u\n    graph = [set() for _ in range(MAX_COLOR + 1)]\n\n    for color in range(1, MAX_COLOR + 1):\n      # Get the rectangle of the current color.\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      # Add any color covering the current as the children.\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.INIT] * (MAX_COLOR + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not (any(hasCycle(i) for i in range(1, MAX_COLOR + 1)))",
      "title": "1591. Strange Printer II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "604e8ddb-3e9e-4659-a352-85853e2477ea",
      "code": "class Solution:\n  def connectTwoGroups(self, cost: list[list[int]]) -> int:\n    # minCosts[j] := the minimum cost of connecting group2's point j\n    minCosts = [min(col) for col in zip(*cost)]\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum cost to connect group1's points[i..n) with group2's\n      points, where `mask` is the bitmask of the connected points in group2.\n      \"\"\"\n      if i == len(cost):\n        # All the points in group 1 are connected, so greedily assign the\n        # minimum cost for the unconnected points of group2.\n        return sum(minCost for j, minCost in enumerate(minCosts)\n                   if (mask >> j & 1) == 0)\n      return min(cost[i][j] + dp(i + 1, mask | 1 << j)\n                 for j in range(len(cost[0])))\n\n    return dp(0, 0)",
      "title": "1595. Minimum Cost to Connect Two Groups of Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2b056b8-42db-4562-9fba-ea5277ad1891",
      "code": "class Solution:\n  def findNearestRightNode(\n      self,\n      root: TreeNode,\n      u: TreeNode,\n  ) -> TreeNode | None:\n    ans = None\n    targetDepth = -1\n\n    def dfs(root: TreeNode, depth: int) -> None:\n      nonlocal ans\n      nonlocal targetDepth\n      if not root:\n        return\n      if root == u:\n        targetDepth = depth\n        return\n      if depth == targetDepth and not ans:\n        ans = root\n        return\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 0)\n    return ans",
      "title": "1602. Find Nearest Right Node in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e678736-0261-4a2b-8605-1f781c685c27",
      "code": "class Solution:\n  def alertNames(self, keyName: list[str], keyTime: list[str]) -> list[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    return sorted([name for name, minutes in nameToMinutes.items()\n                   if self._hasAlert(minutes)])\n\n  def _hasAlert(self, minutes: list[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1604. Alert Using Same Key-Card Three or More Times in a One Hour Period",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "647ae3f9-b8b5-43cd-b88f-d4e6688945f1",
      "code": "class Solution:\n  def restoreMatrix(self, rowSum: list[int],\n                    colSum: list[int]) -> list[list[int]]:\n    m = len(rowSum)\n    n = len(colSum)\n    ans = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = min(rowSum[i], colSum[j])\n        rowSum[i] -= ans[i][j]\n        colSum[j] -= ans[i][j]\n\n    return ans",
      "title": "1605. Find Valid Matrix Given Row and Column Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69fd42b1-9382-4557-8370-fa5ece154b9d",
      "code": "class Solution:\n  def specialArray(self, nums: list[int]) -> int:\n    nums.sort()\n\n    if nums[0] >= len(nums):\n      return len(nums)\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      count = len(nums) - i - 1\n      if a < count and b >= count:\n        return count\n\n    return -1",
      "title": "1608. Special Array With X Elements Greater Than or Equal X",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c3fd5c8-cb2c-4f47-a328-713b96c55606",
      "code": "class Solution:\n  def isEvenOddTree(self, root: TreeNode | None) -> bool:\n    q = collections.deque([root])\n    isEven = True\n\n    while q:\n      prevVal = -math.inf if isEven else math.inf\n      for _ in range(sz):\n        node = q.popleft()\n        if isEven and (node.val % 2 == 0 or node.val <= prevVal):\n          return False  # invalid case on even level\n        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):\n          return False  # invalid case on odd level\n        prevVal = node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      isEven = not isEven\n\n    return True",
      "title": "1609. Even Odd Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "423714e2-b4bb-418d-a2ce-cfa7deb598d3",
      "code": "class Solution:\n  def visiblePoints(\n      self,\n      points: list[list[int]],\n      angle: int,\n      location: list[int],\n  ) -> int:\n    posX, posY = location\n    maxVisible = 0\n    same = 0\n    A = []\n\n    for x, y in points:\n      if x == posX and y == posY:\n        same += 1\n      else:\n        A.append(math.atan2(y - posY, x - posX))\n\n    A.sort()\n    A = A + [a + 2.0 * math.pi for a in A]\n\n    angleInRadians = math.pi * (angle / 180)\n\n    l = 0\n    for r in range(len(A)):\n      while A[r] - A[l] > angleInRadians:\n        l += 1\n      maxVisible = max(maxVisible, r - l + 1)\n\n    return maxVisible + same",
      "title": "1610. Maximum Number of Visible Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec471017-db17-4bc1-9c02-f14f9cb9a76d",
      "code": "class Solution:\n  def minimumOneBitOperations(self, n: int) -> int:\n    # Observation: e.g. n = 2^2\n    #        100 (2^2 needs 2^3 - 1 ops)\n    # op1 -> 101\n    # op2 -> 111\n    # op1 -> 110\n    # op2 -> 010 (2^1 needs 2^2 - 1 ops)\n    # op1 -> 011\n    # op2 -> 001 (2^0 needs 2^1 - 1 ops)\n    # op1 -> 000\n    #\n    # So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\n    # also takes 2^(k + 1) - 1 ops.\n\n    # e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\n    #   - If the second bit is 1, you only need to consider the cost of turning\n    #     the last 2 bits to 0.\n    #   - If the second bit is 0, you need to add up the cost of flipping the\n    #     second bit from 0 to 1.\n    # XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\n    # Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\n    if n == 0:\n      return 0\n    # x is the largest 2^k <= n.\n    # x | x >> 1 -> x >> 1 needs 1 op.\n    #     x >> 1 -> 0      needs x = 2^k - 1 ops.\n    x = 1 << n.bit_length() - 1\n    return self.minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1",
      "title": "1611. Minimum One Bit Operations to Make Integers Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5168c2d-0683-4f61-8afe-5b52f3e118b4",
      "code": "class Solution:\n  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n    count = collections.Counter()\n\n    def dfs(root: 'Node', add: int) -> None:\n      if not root:\n        return\n      if 'a' <= root.val <= 'z':\n        count[root.val] += add\n      dfs(root.left, add)\n      dfs(root.right, add)\n\n    dfs(root1, 1)\n    dfs(root2, -1)\n    return all(value == 0 for value in count.values())",
      "title": "1612. Check If Two Expression Trees are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28f46cb0-565c-46a7-8df2-f70c3cf105ac",
      "code": "class Solution:\n  def maxDepth(self, s: str) -> int:\n    ans = 0\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        ans = max(ans, opened)\n      elif c == ')':\n        opened -= 1\n\n    return ans",
      "title": "1614. Maximum Nesting Depth of the Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f575865a-e6a0-46a6-9b85-da2e630aefcc",
      "code": "class Solution:\n  def maximalNetworkRank(self, n: int, roads: list[list[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    # Find the first maximum and the second maximum degrees.\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    # There can be multiple nodes with `maxDegree1` or `maxDegree2`.\n    # Find the counts of such nodes.\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      # 1. If there is only one node with degree = `maxDegree1`, then we'll\n      # need to use the node with degree = `maxDegree2`. The answer in general\n      # will be (maxDegree1 + maxDegree2), but if the two nodes that we're\n      # considering are connected, then we'll have to subtract 1.\n      edgeCount = (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +\n                   self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1))\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      # 2. If there are more than one node with degree = `maxDegree1`, then we\n      # can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.\n      # The answer in general will be 2 * maxDegree1, but if the two nodes that\n      # we're considering are connected, then we'll have to subtract 1.\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(\n      self,\n      roads: list[list[int]],\n      degrees: list[int],\n      degreeU: int, degreeV: int,\n  ) -> int:\n    \"\"\"\n    Returns the number of edges (u, v) where degress[u] == degreeU and\n    degrees[v] == degreeV.\n    \"\"\"\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount",
      "title": "1615. Maximal Network Rank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37455ad2-fcac-4a46-a736-9ed34878db62",
      "code": "class Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        # a[0:i] + a[i..j] + b[j + 1:] or\n        # a[0:i] + b[i..j] + b[j + 1:]\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True",
      "title": "1616. Split Two Strings to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fdcfe8c-7977-4acd-82ea-0c79605a791c",
      "code": "class Solution:\n  def countSubgraphsForEachDiameter(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    # mask := the subset of the cities\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: list[list[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:  # u is not in the subset.\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:  # v is not in the subset.\n          continue\n        if dist[u][v] == 1:  # u and v are connected.\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    return maxDist if edgeCount == cityCount - 1 else 0",
      "title": "1617. Count Subtrees With Max Distance Between Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c958070b-513e-4867-8274-2337cae0769b",
      "code": "# \"\"\"\n# This is FontInfo's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class FontInfo(object):\n#   Return the width of char ch when fontSize is used.\n#   def getWidth(self, fontSize: int, ch: str) -> int:\n#     pass\n#\n#   def getHeight(self, fontSize: int) -> int:\n#     pass\nclass Solution:\n  def maxFont(\n      self,\n      text: str,\n      w: int,\n      h: int,\n      fonts: list[int],\n      fontInfo: 'FontInfo',\n  ) -> int:\n    count = collections.Counter(text)\n    l = 0\n    r = len(fonts) - 1\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if fontInfo.getHeight(\n              fonts[m]) <= h and self._getWidthSum(\n              count, fonts[m],\n              fontInfo) <= w:\n        l = m\n      else:\n        r = m - 1\n\n    return fonts[l] if self._getWidthSum(count, fonts[l], fontInfo) <= w else -1\n\n  def _getWidthSum(\n      self,\n      count: list[int],\n      font: int,\n      fontInfo: 'FontInfo',\n  ) -> int:\n    width = 0\n    for c in string.ascii_lowercase:\n      width += count[c] * fontInfo.getWidth(font, c)\n    return width",
      "title": "1618. Maximum Font to Fit a Sentence in a Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e12939b-54bd-4363-8c03-67d7b85cf7fc",
      "code": "class Solution:\n  def trimMean(self, arr: list[int]) -> float:\n    arr.sort()\n    offset = len(arr) // 20\n    return mean(arr[offset:-offset])",
      "title": "1619. Mean of Array After Removing Some Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6114297d-0043-46fa-ae00-f99ed2e72e9b",
      "code": "class Solution:\n  def bestCoordinate(self, towers: list[list[int]], radius: int) -> list[int]:\n    MAX = 50\n    n = len(towers)\n    ans = [0] * 2\n    maxQuality = 0\n\n    def dist(tower: list[int], i: int, j: int) -> float:\n      \"\"\"Returns the distance between the tower and the coordinate.\"\"\"\n      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)\n\n    for i in range(MAX + 1):\n      for j in range(MAX + 1):\n        qualitySum = 0\n        for tower in towers:\n          q = tower[2]\n          d = dist(tower, i, j)\n          if d <= radius:\n            qualitySum += int(q / (1 + d))\n        if qualitySum > maxQuality:\n          maxQuality = qualitySum\n          ans = [i, j]\n\n    return ans",
      "title": "1620. Coordinate With Maximum Network Quality",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "697f1523-29f6-4eee-8bf4-0481f58ff142",
      "code": "class Solution:\n  def numberOfSets(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, drawing: bool) -> int:\n      if k == 0:  # Find a way to draw k segments.\n        return 1\n      if i == n:  # Reach the end.\n        return 0\n      if drawing:\n        # 1. Keep drawing at i and move to i + 1.\n        # 2. Stop at i so decrease k. We can start from i for the next segment.\n        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % MOD\n      # 1. Skip i and move to i + 1.\n      # 2. Start at i and move to i + 1.\n      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % MOD\n\n    return dp(0, k, False)",
      "title": "1621. Number of Sets of K Non-Overlapping Line Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1766d88-4770-40ff-a628-d94f41529ebe",
      "code": "class Solution:\n  def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n    ans = -1\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      if c not in lastSeen:\n        lastSeen[c] = i\n      else:\n        ans = max(ans, i - lastSeen[c] - 1)\n\n    return ans",
      "title": "1624. Largest Substring Between Two Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6221b4bb-85b8-46a7-b8d6-0f6c7c940cbf",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Player:\n  age: int\n  score: int\n\n\nclass Solution:\n  def bestTeamScore(self, scores: list[int], ages: list[int]) -> int:\n    n = len(scores)\n    players = [Player(age, score) for age, score in zip(ages, scores)]\n    # dp[i] := the maximum score of choosing the players[0..i] with the\n    # players[i] being selected\n    dp = [0] * n\n\n    # Sort by age descending, then by score descending\n    players.sort(key=lambda x: (-x.age, -x.score))\n\n    for i in range(n):\n      # For each player, choose it first\n      dp[i] = players[i].score\n      # players[j].age >= players[i].age since we sort in descending order.\n      # So, we only have to check that players[j].score >= players[i].score.\n      for j in range(i):\n        if players[j].score >= players[i].score:\n          dp[i] = max(dp[i], dp[j] + players[i].score)\n\n    return max(dp)",
      "title": "1626. Best Team With No Conflicts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8de39b27-95fa-4b47-a186-d531a69d080b",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(\n      self,\n      n: int,\n      threshold: int,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]",
      "title": "1627. Graph Connectivity With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "053c97db-b9c7-48d3-b704-5e712f1a3940",
      "code": "class Solution:\n  def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:\n    ans = keysPressed[0]\n    maxDuration = releaseTimes[0]\n\n    for i in range(1, len(keysPressed)):\n      duration = releaseTimes[i] - releaseTimes[i-1]\n      if duration > maxDuration or (\n              duration == maxDuration and keysPressed[i] > ans):\n        ans = keysPressed[i]\n        maxDuration = duration\n\n    return ans",
      "title": "1629. Slowest Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1413379c-00ed-42b7-b771-a7c218beee83",
      "code": "class Solution:\n  def checkArithmeticSubarrays(\n      self,\n      nums: list[int],\n      l: list[int],\n      r: list[int],\n  ) -> list[bool]:\n    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]\n\n  def _isArithmetic(self, nums: list[int], l: int, r: int) -> bool:\n    if r - l < 2:\n      return True\n\n    numsSet = set()\n    mn = math.inf\n    mx = -math.inf\n\n    for i in range(l, r+1):\n      mn = min(mn, nums[i])\n      mx = max(mx, nums[i])\n      numsSet.add(nums[i])\n\n    if (mx - mn) % (r - l) != 0:\n      return False\n\n    interval = (mx - mn) // (r - l)\n    return all(mn + k * interval in numsSet\n               for k in range(1, r - l + 1))",
      "title": "1630. Arithmetic Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c30275e5-72af-4308-88b0-25fb793c1dd1",
      "code": "class Solution:\n  def minimumEffortPath(self, heights: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    # diff[i][j] := the maximum absolute difference to reach (i, j)\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]  # (d, i, j)\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))",
      "title": "1631. Path With Minimum Effort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91e8d4dd-606e-4d12-a686-14341e2776ab",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> dict[int, list[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    # {val: [(i, j)]}\n    valToGrids = collections.defaultdict(list)\n    # rank[i] := the maximum rank of the row or column so far\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        # Union i-th row with j-th col.\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        # Get the maximum rank of all the included rows and columns.\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          # Update all the rows and columns to maxRank + 1.\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans",
      "title": "1632. Rank Transform of a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72befa18-a2b5-406b-85ce-46e8f7671eed",
      "code": "# Definition for polynomial singly-linked list.\n# class PolyNode:\n#   def __init__(self, x=0, y=0, next=None):\n#     self.coefficient = x\n#     self.power = y\n#     self.next = next\n\nclass Solution:\n  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':\n    dummy = PolyNode()\n    curr = dummy\n    p = poly1  # poly1's pointer\n    q = poly2  # poly2's pointer\n\n    while p and q:\n      if p.power > q.power:\n        curr.next = PolyNode(p.coefficient, p.power)\n        curr = curr.next\n        p = p.next\n      elif p.power < q.power:\n        curr.next = PolyNode(q.coefficient, q.power)\n        curr = curr.next\n        q = q.next\n      else:  # p.power == q.power\n        sumCoefficient = p.coefficient + q.coefficient\n        if sumCoefficient != 0:\n          curr.next = PolyNode(sumCoefficient, p.power)\n          curr = curr.next\n        p = p.next\n        q = q.next\n\n    while p:\n      curr.next = PolyNode(p.coefficient, p.power)\n      curr = curr.next\n      p = p.next\n\n    while q:\n      curr.next = PolyNode(q.coefficient, q.power)\n      curr = curr.next\n      q = q.next\n\n    return dummy.next",
      "title": "1634. Add Two Polynomials Represented as Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc30dc86-f5bf-458c-ab29-c90cfa0cceaa",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  num: int\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.num > other.num\n    return self.freq < other.freq\n\n\nclass Solution:\n  def frequencySort(self, nums: list[int]) -> list[int]:\n    ans = []\n    heap = []\n\n    for num, freq in collections.Counter(nums).items():\n      heapq.heappush(heap, T(num, freq))\n\n    while len(heap) > 0:\n      num = heap[0].num\n      freq = heapq.heappop(heap).freq\n      ans.extend([num] * freq)\n\n    return ans",
      "title": "1636. Sort Array by Increasing Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29e0de9e-fb1a-4ad4-af1f-a2ea4b3c8ea7",
      "code": "class Solution:\n  def maxWidthOfVerticalArea(self, points: list[list[int]]) -> int:\n    xs = sorted([x for x, _ in points])\n    return max(b - a for a, b in itertools.pairwise(xs))",
      "title": "1637. Widest Vertical Area Between Two Points Containing No Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11da7193-9dbd-45b3-9c3f-52b6af4a66b7",
      "code": "class Solution:\n  def countSubstrings(self, s: str, t: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      ans += self._count(s, t, i, 0)\n\n    for j in range(1, len(t)):\n      ans += self._count(s, t, 0, j)\n\n    return ans\n\n  def _count(self, s: str, t: str, i: int, j: int) -> int:\n    \"\"\"Returns the number of substrings of s[i..n) and t[j:] that differ by one char.\"\"\"\n    res = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with zero different letter\n    dp0 = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with one different letter\n    dp1 = 0\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        dp0 += 1\n      else:\n        dp0, dp1 = 0, dp0 + 1\n      res += dp1\n      i += 1\n      j += 1\n\n    return res",
      "title": "1638. Count Substrings That Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd0f7bfa-088b-461b-a882-e8c39cbe0481",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # dp[i][j] := the number of ways to form the first i characters of the\n    # `target` using the j first characters in each word\n    dp = [[0] * (wordLength + 1) for _ in range(len(target) + 1)]\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    dp[0][0] = 1\n\n    for i in range(len(target) + 1):\n      for j in range(wordLength):\n        if i < len(target):\n          # Pick the character target[i] from word[j].\n          dp[i + 1][j + 1] = dp[i][j] * counts[j][target[i]]\n          dp[i + 1][j + 1] %= MOD\n        # Skip the word[j].\n        dp[i][j + 1] += dp[i][j]\n        dp[i][j + 1] %= MOD\n\n    return dp[len(target)][wordLength]",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "296e4f88-a45d-48c7-963b-df88dd1eea1c",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int):\n      \"\"\"Returns the number of ways to form target[i..n) using word[j..n).\"\"\"\n      if i == len(target):\n        return 1\n      if j == wordLength:\n        return 0\n      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % MOD\n\n    return dp(0, 0)",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2251b3f0-c6e9-4ca5-8a03-a92f3617321d",
      "code": "class Solution:\n  def canFormArray(self, arr: list[int], pieces: list[list[int]]) -> bool:\n    concatenated = []\n    startToPiece = {piece[0]: piece for piece in pieces}\n\n    for a in arr:\n      concatenated += startToPiece.get(a, [])\n\n    return concatenated == arr",
      "title": "1640. Check Array Formation Through Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a5f8587-f234-4c3a-ab95-85516b6da481",
      "code": "class Solution:\n  def furthestBuilding(\n      self,\n      heights: list[int],\n      bricks: int,\n      ladders: int,\n  ) -> int:\n    minHeap = []\n\n    for i, (a, b) in enumerate(itertools.pairwise(heights)):\n      diff = b - a\n      if diff <= 0:\n        continue\n      heapq.heappush(minHeap, diff)\n      # If we run out of ladders, greedily use as less bricks as possible.\n      if len(minHeap) > ladders:\n        bricks -= heapq.heappop(minHeap)\n      if bricks < 0:\n        return i\n\n    return len(heights) - 1",
      "title": "1642. Furthest Building You Can Reach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93eefd8a-1e36-4fb8-a566-10ccd7f507a8",
      "code": "class Solution:\n  def kthSmallestPath(self, destination: list[int], k: int) -> str:\n    ans = []\n    v, h = destination\n\n    for _ in range(h + v):\n      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.\n      availableRank = math.comb(h + v - 1, v)\n      if availableRank >= k:  # Should pick 'H'.\n        ans.append('H')\n        h -= 1\n      else:  # Should pick 'V'.\n        k -= availableRank\n        ans.append('V')\n        v -= 1\n\n    return ''.join(ans)",
      "title": "1643. Kth Smallest Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18068462-f639-4506-8c53-89073d7686c1",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    seenP = False\n    seenQ = False\n\n    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n      nonlocal seenP\n      nonlocal seenQ\n      if not root:\n        return None\n      # Need to traverse the entire tree to update `seenP` and `seenQ`.\n      left = getLCA(root.left, p, q)\n      right = getLCA(root.right, p, q)\n      if root == p:\n        seenP = True\n        return root\n      if root == q:\n        seenQ = True\n        return root\n      if left and right:\n        return root\n      return left or right\n\n    lca = getLCA(root, p, q)\n    return lca if seenP and seenQ else None",
      "title": "1644. Lowest Common Ancestor of a Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1520de0-7114-4739-91ee-441c3658fe6d",
      "code": "class Solution:\n  def getMaximumGenerated(self, n: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return 1\n\n    nums = [0] * (n + 1)\n    nums[1] = 1\n\n    i = 1\n    while 2 * i + 1 <= n:\n      nums[2 * i] = nums[i]\n      nums[2 * i + 1] = nums[i] + nums[i + 1]\n      i += 1\n\n    return max(nums)",
      "title": "1646. Get Maximum in Generated Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f9367cb-894d-4edf-85a9-493c4f9592b9",
      "code": "class Solution:\n  def minDeletions(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n    usedFreq = set()\n\n    for freq in count.values():\n      while freq > 0 and freq in usedFreq:\n        freq -= 1  # Delete ('a' + i).\n        ans += 1\n      usedFreq.add(freq)\n\n    return ans",
      "title": "1647. Minimum Deletions to Make Character Frequencies Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b00c0e2-f1b6-4ecf-853d-3be017d8f6ef",
      "code": "class Solution:\n  def maxProfit(self, inventory: list[int], orders: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    largestCount = 1\n\n    def trapezoid(a: int, b: int) -> int:\n      return (a + b) * (a - b + 1) // 2\n\n    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):\n      if a > b:\n        # If we are at the last inventory, or inventory[i] > inventory[i + 1].\n        # In either case, we will pick inventory[i - largestCount + 1..i].\n        pick = a - b\n        # We have run out of orders, so we need to recalculate the number of\n        # balls that we actually pick for inventory[i - largestCount + 1..i].\n        if largestCount * pick >= orders:\n          actualPick, remaining = divmod(orders, largestCount)\n          return (ans +\n                  largestCount * trapezoid(a, a - actualPick + 1) +\n                  remaining * (a - actualPick)) % MOD\n        ans += largestCount * trapezoid(a, a - pick + 1)\n        ans %= MOD\n        orders -= largestCount * pick\n      largestCount += 1",
      "title": "1648. Sell Diminishing-Valued Colored Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8b42b22-bdb7-476d-a4bd-ab11ba5dc128",
      "code": "class Solution:\n  # Same as 160. Intersection of Two Linked Lists\n  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n    a = p\n    b = q\n\n    while a != b:\n      a = a.parent if a else q\n      b = b.parent if b else p\n\n    return a",
      "title": "1650. Lowest Common Ancestor of a Binary Tree III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9001de53-d353-4f72-8034-2de7ef9be464",
      "code": "class Solution:\n  def decrypt(self, code: list[int], k: int) -> list[int]:\n    n = len(code)\n    ans = [0] * n\n    if k == 0:\n      return ans\n\n    summ = 0\n    start = 1 if k > 0 else n + k  # the start of the next k numbers\n    end = k if k > 0 else n - 1  # the end of the next k numbers\n\n    for i in range(start, end + 1):\n      summ += code[i]\n\n    for i in range(n):\n      ans[i] = summ\n      summ -= code[start % n]\n      start += 1\n      end += 1\n      summ += code[end % n]\n\n    return ans",
      "title": "1652. Defuse the Bomb",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cfa8587-f21e-4df4-a98c-f2e91d05d729",
      "code": "class Solution:\n  # Same as 926. Flip String to Monotone Increasing\n  def minimumDeletions(self, s: str) -> int:\n    dp = 0  # the number of characters to be deleted to make subso far balanced\n    countB = 0\n\n    for c in s:\n      if c == 'a':\n        # 1. Delete 'a'.\n        # 2. Keep 'a' and delete the previous 'b's.\n        dp = min(dp + 1, countB)\n      else:\n        countB += 1\n\n    return dp",
      "title": "1653. Minimum Deletions to Make String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb344b4b-2f34-45cc-8fc1-30d744ba82a4",
      "code": "from enum import Enum\n\n\nclass Direction(Enum):\n  FORWARD = 0\n  BACKWARD = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: list[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    # (direction, position)\n    q = collections.deque([(Direction.FORWARD, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.FORWARD, forward))\n        # It cannot jump backward twice in a row.\n        if dir == Direction.FORWARD and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.BACKWARD, backward))\n      ans += 1\n\n    return -1",
      "title": "1654. Minimum Jumps to Reach Home",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd397956-e54e-4428-a0e4-ed046f9a0f17",
      "code": "class Solution:\n  def canDistribute(self, nums: list[int], quantity: list[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    # validDistribution[i][j] := True if it's possible to distribute the i-th\n    # freq into a subset of quantity represented by the bitmask j\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    # dp[i][j] := true if it's possible to distribute freqs[i..n), where j is\n    # the bitmask of the selected quantity\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: list[int],\n                            quantity: list[int]) -> list[list[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: list[int], mask: int) -> int:\n    \"\"\"Returns the sum of the selected quantity represented by `mask`.\"\"\"\n    return sum(q for i, q in enumerate(quantity) if mask >> i & 1)",
      "title": "1655. Distribute Repeating Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d3c9508-4384-4e20-89d0-a0916f483976",
      "code": "class Solution:\n  def closeStrings(self, word1: str, word2: str) -> bool:\n    if len(word1) != len(word2):\n      return False\n\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    if count1.keys() != count2.keys():\n      return False\n\n    return sorted(count1.values()) == sorted(count2.values())",
      "title": "1657. Determine if Two Strings Are Close",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbc2d33f-eab1-4293-95be-26d22bf39f60",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int) -> int:\n    targetSum = sum(nums) - x\n    if targetSum == 0:\n      return len(nums)\n    maxLen = self._maxSubArrayLen(nums, targetSum)\n    return -1 if maxLen == -1 else len(nums) - maxLen\n\n  # Same as 325. Maximum Size Subarray Sum Equals k\n  def _maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    res = -1\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        res = max(res, i - prefixToIndex[target])\n      # No need to check the existence of the prefix since it's unique.\n      prefixToIndex[prefix] = i\n\n    return res",
      "title": "1658. Minimum Operations to Reduce X to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d34eb726-97e1-4dd4-af37-48ff613c0cb1",
      "code": "class Solution:\n  def getMaxGridHappiness(\n      self,\n      m: int,\n      n: int,\n      introvertsCount: int,\n      extrovertsCount: int,\n  ) -> int:\n    def getPlacementCost(\n        i: int,\n        j: int,\n        inMask: int,\n        exMask: int,\n        diff: int,\n    ) -> int:\n      \"\"\"Calculates the cost based on left and up neighbors.\n\n      The `diff` parameter represents the happiness change due to the current\n      placed person in (i, j). We add `diff` each time we encounter a neighbor\n      (left or up) who is already placed.\n\n      1. If the neighbor is an introvert, we subtract 30 from cost.\n      2. If the neighbor is an extrovert, we add 20 to from cost.\n      \"\"\"\n      cost = 0\n      if i > 0:\n        if (1 << (n - 1)) & inMask:\n          cost += diff - 30\n        if (1 << (n - 1)) & exMask:\n          cost += diff + 20\n      if j > 0:\n        if 1 & inMask:\n          cost += diff - 30\n        if 1 & exMask:\n          cost += diff + 20\n      return cost\n\n    @functools.lru_cache(None)\n    def dp(\n        pos: int, inMask: int, exMask: int, inCount: int, exCount: int\n    ) -> int:\n      # `inMask` is the placement of introvert people in the last n cells.\n      # e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means\n      #\n      # ? 1 0\n      # 1 x ? (x := current position)\n      i, j = divmod(pos, n)\n      if i == m:\n        return 0\n\n      shiftedInMask = (inMask << 1) & ((1 << n) - 1)\n      shiftedExMask = (exMask << 1) & ((1 << n) - 1)\n\n      skip = dp(pos + 1, shiftedInMask, shiftedExMask, inCount, exCount)\n      placeIntrovert = (\n          120 + getPlacementCost(i, j, inMask, exMask, -30) +\n          dp(pos + 1, shiftedInMask + 1, shiftedExMask, inCount - 1, exCount)\n          if inCount > 0\n          else -math.inf)\n      placeExtrovert = (\n          40 + getPlacementCost(i, j, inMask, exMask, 20) +\n          dp(pos + 1, shiftedInMask, shiftedExMask + 1, inCount, exCount - 1)\n          if exCount > 0\n          else -math.inf)\n      return max(skip, placeIntrovert, placeExtrovert)\n\n    return dp(0, 0, 0, introvertsCount, extrovertsCount)",
      "title": "1659. Maximize Grid Happiness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63e85f73-75a4-4aab-9b8d-62878dcad351",
      "code": "class Solution:\n  def __init__(self):\n    self.seen = set()\n\n  def correctBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    if root == None:\n      return None\n    if root.right and root.right.val in self.seen:\n      return None\n    self.seen.add(root.val)\n    root.right = self.correctBinaryTree(root.right)\n    root.left = self.correctBinaryTree(root.left)\n    return root",
      "title": "1660. Correct a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29a772ed-5fdc-4a49-84db-7b70018f040a",
      "code": "class Solution:\n  def arrayStringsAreEqual(self, word1: list[str], word2: list[str]) -> bool:\n    i = 0  # word1's index\n    j = 0  # word2's index\n    a = 0  # word1[i]'s index\n    b = 0  # word2[j]'s index\n\n    while i < len(word1) and j < len(word2):\n      if word1[i][a] != word2[j][b]:\n        return False\n      a += 1\n      if a == len(word1[i]):\n        i += 1\n        a = 0\n      b += 1\n      if b == len(word2[j]):\n        j += 1\n        b = 0\n\n    return i == len(word1) and j == len(word2)",
      "title": "1662. Check If Two String Arrays are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6df4a584-c65d-492d-8d4b-ee4cc5a53c9e",
      "code": "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n    ans = []\n\n    for i in range(n):\n      remainingLetters = n - 1 - i\n      rank = max(1, k - remainingLetters * 26)\n      ans.append(chr(ord('a') + rank - 1))\n      k -= rank\n\n    return ''.join(ans)",
      "title": "1663. Smallest String With A Given Numeric Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acee1025-af39-4065-9196-cc901c8e0746",
      "code": "class Solution:\n  def minimumEffort(self, tasks: list[list[int]]) -> int:\n    ans = 0\n    prevSaved = 0\n\n    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):\n      if prevSaved < minimum:\n        ans += minimum - prevSaved\n        prevSaved = minimum - actual\n      else:\n        prevSaved -= actual\n\n    return ans",
      "title": "1665. Minimum Initial Energy to Finish Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3f65478-097f-401f-9541-1bfe53823414",
      "code": "class Solution:\n  def maxRepeating(self, sequence: str, word: str) -> int:\n    ans = 1\n    while word * ans in sequence:\n      ans += 1\n    return ans - 1",
      "title": "1668. Maximum Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4427a578-a670-47c5-861e-c3842622ce0a",
      "code": "class Solution:\n  def mergeInBetween(\n      self,\n      list1: ListNode,\n      a: int,\n      b: int,\n      list2: ListNode,\n  ) -> ListNode:\n    nodeBeforeA = list1\n    for i in range(a - 1):\n      nodeBeforeA = nodeBeforeA.next\n\n    nodeB = nodeBeforeA.next\n    for i in range(b - a):\n      nodeB = nodeB.next\n\n    nodeBeforeA.next = list2\n    lastNodeInList2 = list2\n\n    while lastNodeInList2.next:\n      lastNodeInList2 = lastNodeInList2.next\n\n    lastNodeInList2.next = nodeB.next\n    nodeB.next = None\n    return list1",
      "title": "1669. Merge In Between Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6b629e2-e6cc-4c78-aa7d-01f0bcf15ee0",
      "code": "class Solution:\n  def minimumMountainRemovals(self, nums: list[int]) -> int:\n    left = self._lengthOfLIS(nums)\n    right = self._lengthOfLIS(nums[::-1])[::-1]\n    maxMountainSeq = 0\n\n    for l, r in zip(left, right):\n      if l > 1 and r > 1:\n        maxMountainSeq = max(maxMountainSeq, l + r - 1)\n\n    return len(nums) - maxMountainSeq\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> list[int]:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    # dp[i] := the length of LIS ending in nums[i]\n    dp = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n      dp.append(len(tails))\n    return dp",
      "title": "1671. Minimum Number of Removals to Make Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05446a3b-3b65-4699-ab37-7c77ce4e4dad",
      "code": "class Solution:\n  def maximumWealth(self, accounts: list[list[int]]) -> int:\n    return max(map(sum, accounts))",
      "title": "1672. Richest Customer Wealth",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b7e2eb5-2076-465e-8972-36e97a4e4038",
      "code": "class Solution:\n  def mostCompetitive(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n\n    for i, num in enumerate(nums):\n      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough\n      # numbers, and we can safely pop an element from ans.\n      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:\n        ans.pop()\n      if len(ans) < k:\n        ans.append(nums[i])\n\n    return ans",
      "title": "1673. Find the Most Competitive Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3dde9c8f-8189-4045-9d4c-c00989c5a14d",
      "code": "class Solution:\n  def minMoves(self, nums: list[int], limit: int) -> int:\n    n = len(nums)\n    ans = n\n    # delta[i] := the number of moves needed when target goes from i - 1 to i\n    delta = [0] * (limit * 2 + 2)\n\n    for i in range(n // 2):\n      a = nums[i]\n      b = nums[n - 1 - i]\n      delta[min(a, b) + 1] -= 1\n      delta[a + b] -= 1\n      delta[a + b + 1] += 1\n      delta[max(a, b) + limit + 1] += 1\n\n    # Initially, we need `moves` when the target is 2.\n    moves = n\n    for i in range(2, limit * 2 + 1):\n      moves += delta[i]\n      ans = min(ans, moves)\n\n    return ans",
      "title": "1674. Minimum Moves to Make Array Complementary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08b9bc8b-b67b-4a56-a85a-70863347d635",
      "code": "class Solution:\n  def minimumDeviation(self, nums: list[int]) -> int:\n    ans = math.inf\n    mn = math.inf\n    maxHeap = []\n\n    for num in nums:\n      evenNum = num if num % 2 == 0 else num * 2\n      heapq.heappush(maxHeap, -evenNum)\n      mn = min(mn, evenNum)\n\n    while maxHeap[0] % 2 == 0:\n      mx = -heapq.heappop(maxHeap)\n      ans = min(ans, mx - mn)\n      mn = min(mn, mx // 2)\n      heapq.heappush(maxHeap, -mx // 2)\n\n    return min(ans, -maxHeap[0] - mn)",
      "title": "1675. Minimize Deviation in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "349a0de1-910a-403c-90a4-991400f47761",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      nodes: 'list[TreeNode]',\n  ) -> 'TreeNode':\n    nodes = set(nodes)\n\n    def lca(root: 'TreeNode') -> 'TreeNode':\n      if not root:\n        return None\n      if root in nodes:\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    return lca(root)",
      "title": "1676. Lowest Common Ancestor of a Binary Tree IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "122f2af5-7fca-4f11-b6da-a0bab0bad5f8",
      "code": "class Solution:\n  def interpret(self, command: str) -> str:\n    return command.replace('()', 'o').replace('(al)', 'al')",
      "title": "1678. Goal Parser Interpretation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b2dc9ed-b692-43e9-b7d1-ae379231cf7e",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(min(count[num], count[k - num])\n               for num in count) // 2",
      "title": "1679. Max Number of K-Sum Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c1768af-acdb-4d22-baf4-e9cf03acd430",
      "code": "class Solution:\n  def concatenatedBinary(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    numberOfBits = 0\n\n    for i in range(1, n + 1):\n      if i.bit_count() == 1:\n        numberOfBits += 1\n      ans = ((ans << numberOfBits) + i) % MOD\n\n    return ans",
      "title": "1680. Concatenation of Consecutive Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77c27b49-7d4e-4a41-8365-25b1f5fbf431",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX_NUM = 16\n\n  def minimumIncompatibility(self, nums: list[int], k: int) -> int:\n    MAX_COMPATIBILITY = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    # dp[i] := the minimum possible sum of incompatibilities of the subset\n    # of numbers represented by the bitmask i\n    dp = [MAX_COMPATIBILITY] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      # The number of 1s in `mask` isn't a multiple of `subsetSize`.\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      # https://cp-algorithms.com/algebra/all-submasks.html\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:  # valid submask\n          dp[mask] = min(dp[mask], dp[mask - submask] +\n                         incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    return dp[-1] if dp[-1] != MAX_COMPATIBILITY else -1\n\n  def _getIncompatibilities(\n      self,\n      nums: list[int],\n      subsetSize: int,\n  ) -> list[int]:\n    \"\"\"\n    Returns an incompatibilities array where\n    * incompatibilities[i] := the incompatibility of the subset of numbers\n      represented by the bitmask i\n    * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not\n      `subsetSize`\n    \"\"\"\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: list[int], mask: int, subsetSize: int) -> bool:\n    \"\"\"Returns True if the numbers selected by `mask` are unique.\"\"\"\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: list[int], mask: int) -> int:\n    \"\"\"\n    Returns the incompatibility of the selected numbers represented by the\n    `mask`.\n    \"\"\"\n    mn = self.MAX_NUM\n    mx = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        mx = max(mx, num)\n        mn = min(mn, num)\n    return mx - mn",
      "title": "1681. Minimum Incompatibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8042d630-e583-4c33-b2e4-9e6379e5bdba",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is\n    # ('a' + k).\n    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        for k in range(27):\n          j = i + d\n          if s[i] == s[j] and s[i] != chr(ord('a') + k):\n            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2\n          else:\n            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])\n\n    return dp[0][n - 1][26]",
      "title": "1682. Longest Palindromic Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c84797ab-755e-4a62-b38d-81d3641a9819",
      "code": "class Solution:\n  def countConsistentStrings(self, allowed: str, words: list[str]) -> int:\n    return sum(all(c in allowed for c in word)\n               for word in words)",
      "title": "1684. Count the Number of Consistent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ca729b1-4ae5-45a1-bd34-69ecd658789c",
      "code": "class Solution:\n  def getSumAbsoluteDifferences(self, nums: list[int]) -> list[int]:\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)\n            for i, num in enumerate(nums)]",
      "title": "1685. Sum of Absolute Differences in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c062707a-180f-4122-980d-24f80c1d899b",
      "code": "class Solution:\n  def boxDelivering(\n      self,\n      boxes: list[list[int]],\n      portsCount: int,\n      maxBoxes: int,\n      maxWeight: int,\n  ) -> int:\n    n = len(boxes)\n    # dp[i] := the minimum trips to deliver boxes[0..i) and return to the\n    # storage\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      # The current box is different from the previous one, need to make one\n      # more trip.\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      # Loading boxes[l] in the previous turn is always no bad than loading it\n      # in this turn\n      while r - l + 1 > maxBoxes or weight > maxWeight or (\n              l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      #   min trips to deliver boxes[0..r]\n      # = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]",
      "title": "1687. Delivering Boxes from Storage to Ports",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e939e25f-65d0-4062-8f1a-e270a766d418",
      "code": "class Solution:\n  def numberOfMatches(self, n: int) -> int:\n    return n - 1",
      "title": "1688. Count of Matches in Tournament",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6b1fa4b-fb19-4aca-8fef-d597d0e69dd0",
      "code": "class Solution:\n  def minPartitions(self, n: str) -> int:\n    return int(max(n))",
      "title": "1689. Partitioning Into Minimum Number Of Deci-Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75e65732-dc27-42aa-a18d-83b07a1e532d",
      "code": "class Solution:\n  def reformatNumber(self, number: str) -> str:\n    ans = []\n\n    number = number.replace(\"-\", \"\").replace(\" \", \"\")\n\n    i = 0  # number's index\n    while i + 4 < len(number):\n      ans.append(number[i:i + 3] + '-')\n      i += 3\n\n    countFinalDigits = len(number) - i\n    if countFinalDigits < 4:\n      ans.append(number[i:])\n    else:  # countFinalDigits == 4\n      ans.append(number[i:i + 2] + '-' + number[i + 2:])\n\n    return ''.join(ans)",
      "title": "1694. Reformat Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fbefc61-c03a-43b3-8496-7c4c3efb9e03",
      "code": "class Solution:\n  def maximumUniqueSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n    seen = set()\n\n    l = 0\n    for r, num in enumerate(nums):\n      while num in seen:\n        score -= nums[l]\n        seen.remove(nums[l])\n        l += 1\n      seen.add(nums[r])\n      score += nums[r]\n      ans = max(ans, score)\n\n    return ans",
      "title": "1695. Maximum Erasure Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c0684e7-7a68-4027-8e03-f938b990b87d",
      "code": "class Solution:\n  def maxResult(self, nums: list[int], k: int) -> int:\n    # Stores dp[i] within the bounds.\n    maxQ = collections.deque([0])\n    # dp[i] := the maximum score to consider nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n      # Pop the index if it's out-of-bounds.\n      if maxQ[0] + k < i:\n        maxQ.popleft()\n      dp[i] = dp[maxQ[0]] + nums[i]\n      # Pop indices that won't be chosen in the future.\n      while maxQ and dp[maxQ[-1]] <= dp[i]:\n        maxQ.pop()\n      maxQ.append(i)\n\n    return dp[-1]",
      "title": "1696. Jump Game VI",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acfb408e-d56a-4131-9298-44f7de0c80dd",
      "code": "class Solution:\n  def countDistinct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n\n    n = len(s)\n    ans = 0\n    pow = [1] + [0] * n     # pow[i] := BASE^i\n    hashes = [0] * (n + 1)  # hashes[i] := the hash of s[0..i)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for i in range(1, n + 1):\n      pow[i] = pow[i - 1] * BASE % HASH\n      hashes[i] = (hashes[i - 1] * BASE + val(s[i - 1])) % HASH\n\n    def getHash(l: int, r: int) -> int:\n      \"\"\"Returns the hash of s[l..r).\"\"\"\n      hash = (hashes[r] - hashes[l] * pow[r - l]) % HASH\n      return hash + HASH if hash < 0 else hash\n\n    for length in range(1, n + 1):\n      seen = set()\n      for i in range(n - length + 1):\n        seen.add(getHash(i, i + length))\n      ans += len(seen)\n\n    return ans",
      "title": "1698. Number of Distinct Substrings in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43a9b083-6359-42f6-9a4c-129297620395",
      "code": "class Solution:\n  def countStudents(self, students: list[int], sandwiches: list[int]) -> int:\n    count = collections.Counter(students)\n\n    for i, sandwich in enumerate(sandwiches):\n      if count[sandwich] == 0:\n        return len(sandwiches) - i\n      count[sandwich] -= 1\n\n    return 0",
      "title": "1700. Number of Students Unable to Eat Lunch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54744c4c-5f73-4f92-96e4-b83934ab5782",
      "code": "class Solution:\n  def maximumBinaryString(self, binary: str) -> str:\n    #     e.g. binary = '100110'\n    # Do Operation 2 -> '100011'\n    # Do Operation 1 -> '111011'\n    # So, the index of the only '0' is prefixOnes + zeros - 1.\n    zeros = binary.count('0')\n    prefixOnes = binary.find('0')\n\n    # Make the entire string as 1s.\n    ans = ['1'] * len(binary)\n\n    # Make the only '0' if necessary.\n    if prefixOnes != -1:\n      ans[prefixOnes + zeros - 1] = '0'\n    return ''.join(ans)",
      "title": "1702. Maximum Binary String After Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7eabf9b-9373-4134-8083-87419cebf471",
      "code": "class Solution:\n  def halvesAreAlike(self, s: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n    aVowelsCount = sum(c in VOWELS for c in s[:len(s) // 2])\n    bVowelsCount = sum(c in VOWELS for c in s[len(s) // 2:])\n    return aVowelsCount == bVowelsCount",
      "title": "1704. Determine if String Halves Are Alike",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd3612e8-ed03-49bd-83f9-291e6635e8bc",
      "code": "class Solution:\n  def eatenApples(self, apples: list[int], days: list[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []  # (the rotten day, the number of apples)\n\n    i = 0\n    while i < n or minHeap:\n      # Remove the rotten apples.\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      # Add today's apples.\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      # Eat one apple today.\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans",
      "title": "1705. Maximum Number of Eaten Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45537fca-9306-499a-80f0-ec1a97e17963",
      "code": "class Solution:\n  def findBall(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i] := status of the i-th column\n    # -1 := empty, 0 := b0, 1 := b1, ...\n    dp = [i for i in range(n)]\n    # ans[i] := the i-th ball's final positio\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        # out-of-bounds\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if (grid[i][j] == 1 and grid[i][j + 1] == -1 or\n                grid[i][j] == -1 and grid[i][j - 1] == 1):\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans",
      "title": "1706. Where Will the Ball Fall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48996cc6-04ab-4e6d-9512-566379f1e72e",
      "code": "from dataclasses import dataclass\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  x: int\n  m: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0  # nums' index\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m)\n                                    for i, (x, m) in enumerate(queries)],\n                                   key=lambda x: x.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans",
      "title": "1707. Maximum XOR With an Element From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c62551b2-b4c2-419c-a3c6-9c16e0ae6e84",
      "code": "class Solution:\n  def largestSubarray(self, nums: list[int], k: int) -> list[int]:\n    mx = max(nums[:len(nums) - k + 1])\n    i = nums.index(mx)\n    return nums[i:i + k]",
      "title": "1708. Largest Subarray Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3405847-d49e-49c4-94d6-675e805b9bde",
      "code": "class Solution:\n  def maximumUnits(self, boxTypes: list[list[int]], truckSize: int) -> int:\n    ans = 0\n\n    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):\n      if boxes >= truckSize:\n        return ans + truckSize * units\n      ans += boxes * units\n      truckSize -= boxes\n\n    return ans",
      "title": "1710. Maximum Units on a Truck",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b4718f2-4c90-43c6-bae8-3fab7c614d63",
      "code": "class Solution:\n  def countPairs(self, deliciousness: list[int]) -> int:\n    MOD = 10**9 + 7\n    MAX_BIT = 20 + 1\n    ans = 0\n    count = collections.Counter()\n\n    for d in deliciousness:\n      for i in range(MAX_BIT + 1):\n        power = 1 << i\n        ans += count[power - d]\n        ans %= MOD\n      count[d] += 1\n\n    return ans",
      "title": "1711. Count Good Meals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea02129f-f86b-47ee-8620-74366e198011",
      "code": "class Solution:\n  def waysToSplit(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n\n    def firstGreaterEqual(i: int) -> int:\n      \"\"\"Finds the first index j s.t.\n         Mid = prefix[j] - prefix[i] >= left = prefix[i]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] >= prefix[i]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def firstGreater(i: int) -> int:\n      \"\"\"Finds the first index k s.t.\n         mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    for i in range(n - 2):\n      j = firstGreaterEqual(i)\n      if j == n - 1:\n        break\n      mid = prefix[j] - prefix[i]\n      right = prefix[-1] - prefix[j]\n      if mid > right:\n        continue\n      k = firstGreater(i)\n      ans = (ans + k - j) % MOD\n\n    return ans",
      "title": "1712. Ways to Split Array Into Three Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b4908ea-5d1a-4f0f-ad83-06da15200538",
      "code": "class Solution:\n  def minOperations(self, target: list[int], arr: list[int]) -> int:\n    indices = []\n    numToIndex = {num: i for i, num in enumerate(target)}\n\n    for a in arr:\n      if a in numToIndex:\n        indices.append(numToIndex[a])\n\n    return len(target) - self._lengthOfLIS(indices)\n\n  # Same as 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n    return len(tails)",
      "title": "1713. Minimum Operations to Make a Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37ce271e-a92a-4fb5-8c5e-e7e50283a0cc",
      "code": "class Solution:\n  def solve(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    MOD = 10**9 + 7\n    n = len(nums)\n    sqrtN = int(n**0.5)\n    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n\n    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].\n    prefix = [[num] * sqrtN for num in nums]\n\n    for x in range(n - 1, -1, -1):\n      for y in range(1, sqrtN):\n        if x + y < n:\n          prefix[x][y] += prefix[x + y][y]\n          prefix[x][y] %= MOD\n\n    return [prefix[x][y] if y < sqrtN\n            else sum(nums[x::y]) % MOD\n            for x, y in queries]",
      "title": "1714. Sum Of Special Evenly-Spaced Elements In Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b48dbcaa-d7a4-40fc-96c6-9c5e5e9177b4",
      "code": "class Solution:\n  def totalMoney(self, n: int) -> int:\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    weeks = n // 7\n    firstWeek = trapezoid(1, 7)\n    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)\n    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)\n    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays",
      "title": "1716. Calculate Money in Leetcode Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c0e892d-a55d-4f2a-912e-fb0b08c8db44",
      "code": "class Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    # The assumption that gain('ab') > gain('ba') while removing 'ba' first is\n    # optimal is contradicted. Only 'b(ab)a' satisfies the condition of\n    # preventing two 'ba' removals, but after removing 'ab', we can still\n    # remove one 'ba', resulting in a higher gain. Thus, removing 'ba' first is\n    # not optimal.\n    return (self._gain(s, 'ab', x, 'ba', y) if x > y else\n            self._gain(s, 'ba', y, 'ab', x))\n\n  # Returns the points gained by first removing sub1 ('ab' | 'ba') from s with\n  # point1, then removing sub2 ('ab' | 'ba') from s with point2.\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    # Remove 'sub1' from s with point1 gain.\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    # Remove 'sub2' from s with point2 gain.\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points",
      "title": "1717. Maximum Score From Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5488b567-5f08-4764-af2d-725b2f0ce4fa",
      "code": "class Solution:\n  def constructDistancedSequence(self, n: int) -> list[int]:\n    ans = [0] * (2 * n - 1)\n\n    def dfs(i: int, mask: int) -> bool:\n      if i == len(ans):\n        return True\n      if ans[i] > 0:\n        return dfs(i + 1, mask)\n\n      # Greedily fill in `ans` in descending order.\n      for num in range(n, 0, -1):\n        if (mask >> num & 1) == 1:\n          continue\n        if num == 1:\n          ans[i] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i] = 0\n        else:  # num in [2, n]\n          if i + num >= len(ans) or ans[i + num] > 0:\n            continue\n          ans[i] = num\n          ans[i + num] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i + num] = 0\n          ans[i] = 0\n\n      return False\n\n    dfs(0, 0)\n    return ans",
      "title": "1718. Construct the Lexicographically Largest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f94a367b-bc28-4c6c-9021-25bcb447dd27",
      "code": "class Solution:\n  def checkWays(self, pairs: list[list[int]]) -> int:\n    MAX = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * MAX\n    connected = [[False] * MAX for _ in range(MAX)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    # For each node, sort its children by degrees in descending order.\n    for _, children in graph.items():\n      children.sort(key=lambda x: -degrees[x])\n\n    # Find the root with a degree that equals to n - 1.\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n      \"\"\"\n      Returns True if each node rooted at u is connected to all of its\n      ancestors.\n      \"\"\"\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * MAX):\n      return 0\n    return 2 if hasMoreThanOneWay else 1",
      "title": "1719. Number Of Ways To Reconstruct A Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85be89ad-83b9-4e28-aeba-31bb1b121422",
      "code": "class Solution:\n  def decode(self, encoded: list[int], first: int) -> list[int]:\n    ans = [first]\n\n    for e in encoded:\n      ans.append(e ^ ans[-1])\n\n    return ans",
      "title": "1720. Decode XORed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "050d25f3-0e37-491e-9eb4-0efdfe5c0a75",
      "code": "class Solution:\n  def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\n    p = None  # Points the k-th node from the beginning.\n    q = None  # Points the k-th node from the end.\n\n    curr = head\n    while curr:\n      if q:\n        q = q.next\n      k -= 1\n      if k == 0:\n        p = curr\n        q = head\n      curr = curr.next\n\n    p.val, q.val = q.val, p.val\n    return head",
      "title": "1721. Swapping Nodes in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b564a03-318a-4a43-a2af-2dd94d6d80b9",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(\n      self,\n      source: list[int],\n      target: list[int],\n      allowedSwaps: list[list[int]],\n  ) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans",
      "title": "1722. Minimize Hamming Distance After Swap Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea677128-e4ae-41d8-baa0-87d3672af022",
      "code": "class Solution:\n  def minimumTimeRequired(self, jobs: list[int], k: int) -> int:\n    ans = sum(jobs)\n    times = [0] * k  # times[i] := accumulate time of workers[i]\n\n    # Assign the most time-consuming job first.\n    jobs.sort(reverse=True)\n\n    def dfs(s: int) -> None:\n      nonlocal ans\n      if s == len(jobs):\n        ans = min(ans, max(times))\n        return\n      for i in range(k):\n        # There is no need to explore assigning jobs[s] to workers[i] further as\n        # it would not yield better results.\n        if times[i] + jobs[s] >= ans:\n          continue\n        times[i] += jobs[s]\n        dfs(s + 1)\n        times[i] -= jobs[s]\n        # It's always non-optimal to have a worker with no jobs.\n        if times[i] == 0:\n          return\n\n    dfs(0)\n    return ans",
      "title": "1723. Find Minimum Time to Finish All Jobs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "552143df-57fd-401c-bbb6-a230f85a3386",
      "code": "class Solution:\n  def countGoodRectangles(self, rectangles: list[list[int]]) -> int:\n    minSides = [min(x, y) for x, y in rectangles]\n    return minSides.count(max(minSides))",
      "title": "1725. Number Of Rectangles That Can Form The Largest Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abeb05a4-7f1d-4959-870e-c63f40030079",
      "code": "class Solution:\n  def tupleSameProduct(self, nums: list[int]) -> int:\n    # nums of ways to arrange (a, b) = 2\n    # nums of ways to arrange (c, d) = 2\n    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8\n    ans = 0\n    count = collections.Counter()\n\n    for i in range(len(nums)):\n      for j in range(i):\n        prod = nums[i] * nums[j]\n        ans += count[prod] * 8\n        count[prod] += 1\n\n    return ans",
      "title": "1726. Tuple with Same Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "978a4377-97c9-4852-9c66-2ed03d0f10fc",
      "code": "class Solution:\n  def largestSubmatrix(self, matrix: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    for row in matrix:\n      # Accumulate the histogram if possible.\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n\n      # Get the sorted histogram.\n      sortedHist = sorted(hist)\n\n      # Greedily calculate the answer.\n      for i, h in enumerate(sortedHist):\n        ans = max(ans, h * (len(row) - i))\n\n    return ans",
      "title": "1727. Largest Submatrix With Rearrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "842dcda9-83d5-475e-90b9-f84a656906b3",
      "code": "class Solution:\n  def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nFloors = 0\n    cat = 0  # cat's position\n    mouse = 0  # mouse's position\n\n    def hash(i: int, j: int) -> int:\n      return i * n + j\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] != '#':\n          nFloors += 1\n        if grid[i][j] == 'C':\n          cat = hash(i, j)\n        elif grid[i][j] == 'M':\n          mouse = hash(i, j)\n\n    @functools.lru_cache(None)\n    def dp(cat: int, mouse: int, turn: int) -> bool:\n      \"\"\"\n      Returns True if the mouse can win, where the cat is on (i / 8, i % 8), the\n      mouse is on (j / 8, j % 8), and the turns is k.\n      \"\"\"\n      # We already search the whole touchable grid.\n      if turn == nFloors * 2:\n        return False\n\n      if turn % 2 == 0:\n        # the mouse's turn\n        i = mouse // n\n        j = mouse % n\n        for dx, dy in DIRS:\n          for jump in range(mouseJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The mouse eats the food, so the mouse wins.\n            if grid[x][y] == 'F':\n              return True\n            if dp(cat, hash(x, y), turn + 1):\n              return True\n        # The mouse can't win, so the mouse loses.\n        return False\n      else:\n        # the cat's turn\n        i = cat // n\n        j = cat % n\n        for dx, dy in DIRS:\n          for jump in range(catJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The cat eats the food, so the mouse loses.\n            if grid[x][y] == 'F':\n              return False\n            nextCat = hash(x, y)\n            # The cat catches the mouse, so the mouse loses.\n            if nextCat == mouse:\n              return False\n            if not dp(nextCat, mouse, turn + 1):\n              return False\n        # The cat can't win, so the mouse wins.\n        return True\n\n    return dp(cat, mouse, 0)",
      "title": "1728. Cat and Mouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bdaa94e-ac9d-4b33-8736-5669d09e0136",
      "code": "class Solution:\n  def getFood(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    q = collections.deque([self._getStartLocation(grid)])\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] == 'X':\n            continue\n          if grid[x][y] == '#':\n            return ans + 1\n          q.append((x, y))\n          grid[x][y] = 'X'  # Mark as visited.\n      ans += 1\n\n    return -1\n\n  def _getStartLocation(self, grid: list[list[str]]) -> tuple[int, int]:\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          return (i, j)",
      "title": "1730. Shortest Path to Get Food",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c571180-9f67-444f-826d-ebcafd7853e2",
      "code": "class Solution:\n  def largestAltitude(self, gain: list[int]) -> int:\n    ans = 0\n    currAltitude = 0\n    for g in gain:\n      currAltitude += g\n      ans = max(ans, currAltitude)\n    return ans",
      "title": "1732. Find the Highest Altitude",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e00bbc05-3bc4-47d1-9eaf-88e1e2e523c0",
      "code": "class Solution:\n  def minimumTeachings(\n      self,\n      n: int,\n      languages: list[list[int]],\n      friendships: list[list[int]],\n  ) -> int:\n    languageSets = [set(languages) for languages in languages]\n    needTeach = set()\n    languageCount = collections.Counter()\n\n    # Find friends that can't communicate.\n    for u, v in friendships:\n      if not languageSets[u - 1] & languageSets[v - 1]:\n        needTeach.add(u - 1)\n        needTeach.add(v - 1)\n\n    # Find the most popular language.\n    for u in needTeach:\n      for language in languageSets[u]:\n        languageCount[language] += 1\n\n    # Teach the most popular language to people don't understand.\n    return len(needTeach) - max(languageCount.values(), default=0)",
      "title": "1733. Minimum Number of People to Teach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d992b85-86dc-4f7f-a475-ed0e8ac92bc4",
      "code": "class Solution:\n  def decode(self, encoded: list[int]) -> list[int]:\n    # Our goal is to find the value of a1, which will allow us to decode a2, a3,\n    # ..., an. This can be achieved by performing XOR operation between each\n    # element in `encoded` and a1.\n    #\n    # e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3].\n    #               encoded = [a1^a2, a2^a3]\n    #    accumulatedEncoded = [a1^a2, a1^a3]\n    #    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)\n    #    a2 = a1^(a1^a2)\n    #    a3 = a2^(a2^a3)\n    n = len(encoded) + 1\n    nXors = functools.reduce(operator.xor, [i for i in range(1, n + 1)])\n\n    # Instead of constructing the array, we can track of the running XOR value\n    # of `accumulatedEncoded`.\n    xors = 0  # xors(accumulatedEncoded)\n\n    for encode in encoded:\n      runningXors ^= encode\n      xors ^= runningXors\n\n    ans = [xors ^ nXors]\n\n    for encode in encoded:\n      ans.append(ans[-1] ^ encode)\n\n    return ans",
      "title": "1734. Decode XORed Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cce55b2a-778c-4508-8df8-0d59c9a02300",
      "code": "class Solution:\n  def waysToFillArray(self, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX = 10_000\n    minPrimeFactors = self._sieveEratosthenes(MAX + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % MOD\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: list[int]) -> dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count",
      "title": "1735. Count Ways to Make Array With Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02f50c14-3c1f-4071-a8ec-797eddfefbd3",
      "code": "class Solution:\n  def maximumTime(self, time: str) -> str:\n    ans = list(time)\n    if time[0] == '?':\n      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'\n    if time[1] == '?':\n      ans[1] = '3' if ans[0] == '2' else '9'\n    if time[3] == '?':\n      ans[3] = '5'\n    if time[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "1736. Latest Time by Replacing Hidden Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e76c1000-da73-4539-ad0a-d78e120e2101",
      "code": "class Solution:\n  def minimumBoxes(self, n: int) -> int:\n    nBoxes = 0\n    nextTouchings = 0  # j\n    currLevelBoxes = 0  # 1 + 2 + ... + j\n\n    # Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)\n    # >= n\n    while nBoxes < n:\n      nextTouchings += 1\n      currLevelBoxes += nextTouchings\n      nBoxes += currLevelBoxes\n\n    # If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.\n    if nBoxes == n:\n      return currLevelBoxes\n\n    # Otherwise, need to remove the boxes in the current level and rebuild it.\n    nBoxes -= currLevelBoxes\n    currLevelBoxes -= nextTouchings\n    nextTouchings = 0\n\n    while nBoxes < n:\n      nextTouchings += 1\n      nBoxes += nextTouchings\n\n    return currLevelBoxes + nextTouchings",
      "title": "1739. Building Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26f2c340-fff0-4fe1-8cb8-aa5e1bbea6f9",
      "code": "class Solution:\n  def findDistance(self, root: TreeNode, p: int, q: int) -> int:\n    def getLCA(root, p, q):\n      if not root or root.val == p or root.val == q:\n        return root\n\n      l = getLCA(root.left, p, q)\n      r = getLCA(root.right, p, q)\n\n      if l and r:\n        return root\n      return l or r\n\n    def dist(lca, target):\n      if not lca:\n        return 10000\n      if lca.val == target:\n        return 0\n      return 1 + min(dist(lca.left, target), dist(lca.right, target))\n\n    lca = getLCA(root, p, q)\n    return dist(lca, p) + dist(lca, q)",
      "title": "1740. Find Distance in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dacc629-fc81-4540-9a34-6b8fb59762ea",
      "code": "class Solution:\n  def countBalls(self, lowLimit: int, highLimit: int) -> int:\n    maxDigitSum = 9 * 5  # 99999\n    ans = 0\n    count = [0] * (maxDigitSum + 1)\n\n    for num in range(lowLimit, highLimit + 1):\n      digitSum = self._getDigitSum(num)\n      count[digitSum] += 1\n      ans = max(ans, count[digitSum])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1742. Maximum Number of Balls in a Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93769c70-d3cb-4ad8-90b9-f0f2757189db",
      "code": "class Solution:\n  def restoreArray(self, adjacentPairs: list[list[int]]) -> list[int]:\n    ans = []\n    numToAdjs = collections.defaultdict(list)\n\n    for a, b in adjacentPairs:\n      numToAdjs[a].append(b)\n      numToAdjs[b].append(a)\n\n    for num, adjs in numToAdjs.items():\n      if len(adjs) == 1:\n        ans.append(num)\n        ans.append(adjs[0])\n        break\n\n    while len(ans) < len(adjacentPairs) + 1:\n      tail = ans[-1]\n      prev = ans[-2]\n      adjs = numToAdjs[tail]\n      if adjs[0] == prev:  # adjs[0] is already used\n        ans.append(adjs[1])\n      else:\n        ans.append(adjs[0])\n\n    return ans",
      "title": "1743. Restore the Array From Adjacent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36329869-5bbc-4f2c-bc2a-26309814f6cb",
      "code": "class Solution:\n  def canEat(\n      self,\n      candiesCount: list[int],\n      queries: list[list[int]]\n  ) -> list[bool]:\n    prefix = list(itertools.accumulate(candiesCount, initial=0))\n    return [prefix[t] // c <= d < prefix[t + 1] for t, d, c in queries]",
      "title": "1744. Can You Eat Your Favorite Candy on Your Favorite Day?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "431c4f07-9d1f-47df-b02a-f272eb079e31",
      "code": "class Solution:\n  def checkPartitioning(self, s: str) -> bool:\n    @functools.lru_cache(None)\n    def isPalindrome(i: int, j: int) -> bool:\n      \"\"\"Returns True if s[i..j] is a palindrome.\"\"\"\n      if i > j:\n        return True\n      if s[i] == s[j]:\n        return isPalindrome(i + 1, j - 1)\n      return False\n\n    n = len(s)\n    return any(isPalindrome(0, i) and\n               isPalindrome(i + 1, j) and\n               isPalindrome(j + 1, n - 1)\n               for i in range(n)\n               for j in range(i + 1, n - 1))",
      "title": "1745. Palindrome Partitioning IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2001f7b6-2b1f-404e-83a3-44343b0c592a",
      "code": "class Solution:\n  def maxSumAfterOperation(self, nums: list[int]) -> int:\n    ans = -math.inf\n    regular = 0\n    squared = 0\n\n    for num in nums:\n      squared = max(num**2, regular + num**2, squared + num)\n      regular = max(num, regular + num)\n      ans = max(ans, squared)\n\n    return ans",
      "title": "1746. Maximum Subarray Sum After One Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4da083fa-5f40-4563-9e7c-8ea8a5604219",
      "code": "class Solution:\n  def sumOfUnique(self, nums: list[int]) -> int:\n    return sum(num\n               for num, freq in collections.Counter(nums).items()\n               if freq == 1)",
      "title": "1748. Sum of Unique Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fad79d7-a494-4138-a0ee-24ae4d0d6800",
      "code": "class Solution:\n  def maxAbsoluteSum(self, nums):\n    ans = -math.inf\n    maxSum = 0\n    minSum = 0\n\n    for num in nums:\n      maxSum = max(num, maxSum + num)\n      minSum = min(num, minSum + num)\n      ans = max(ans, maxSum, -minSum)\n\n    return ans",
      "title": "1749. Maximum Absolute Sum of Any Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70a2503b-eb3a-43f5-949e-a88c7cdcae36",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    i = 0\n    j = len(s) - 1\n\n    while i < j and s[i] == s[j]:\n      c = s[i]\n      while i <= j and s[i] == c:\n        i += 1\n      while i <= j and s[j] == c:\n        j -= 1\n\n    return j - i + 1",
      "title": "1750. Minimum Length of String After Deleting Similar Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "845e4c55-c702-444a-a481-9af706e01a54",
      "code": "class Solution:\n  def maxValue(self, events: list[list[int]], k: int) -> int:\n    events.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum sum of values that you can receive by attending\n      events[i..n), where k is the maximum number of attendance.\n      \"\"\"\n      if k == 0 or i == len(events):\n        return 0\n\n      # Binary search `events` to find the first index j\n      # s.t. events[j][0] > events[i][1].\n      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)\n      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))\n\n    return dp(0, k)",
      "title": "1751. Maximum Number of Events That Can Be Attended II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c68f7d14-225e-449d-bac2-fabac3a1edec",
      "code": "class Solution:\n  def largestMerge(self, word1: str, word2: str) -> str:\n    if not word1:\n      return word2\n    if not word2:\n      return word1\n    if word1 > word2:\n      return word1[0] + self.largestMerge(word1[1:], word2)\n    return word2[0] + self.largestMerge(word1, word2[1:])",
      "title": "1754. Largest Merge Of Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7af3550a-6924-4c60-a28e-2912f7cf372d",
      "code": "class Solution:\n  def minAbsDifference(self, nums: list[int], goal: int) -> int:\n    n = len(nums) // 2\n    ans = math.inf\n    lSums = []\n    rSums = []\n\n    def dfs(arr: list[int], i: int, path: int, sums: list[int]) -> None:\n      if i == len(arr):\n        sums.append(path)\n        return\n      dfs(arr, i + 1, path + arr[i], sums)\n      dfs(arr, i + 1, path, sums)\n\n    dfs(nums[:n], 0, 0, lSums)\n    dfs(nums[n:], 0, 0, rSums)\n    rSums.sort()\n\n    for lSum in lSums:\n      i = bisect_left(rSums, goal - lSum)\n      if i < len(rSums):  # 2^n\n        ans = min(ans, abs(goal - lSum - rSums[i]))\n      if i > 0:\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\n\n    return ans",
      "title": "1755. Closest Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f46f99f2-56d7-45ff-9bcb-7d5aa97072b4",
      "code": "class Solution:\n  def minOperations(self, s: str) -> int:\n    # the cost to make s \"1010\"\n    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))\n    # the cost to make s \"0101\"\n    cost01 = len(s) - cost10\n    return min(cost10, cost01)",
      "title": "1758. Minimum Changes To Make Alternating Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03f93be1-11ac-49a3-8bdb-6de99a7603e0",
      "code": "class Solution:\n  def countHomogenous(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = 0\n    currentChar = '@'\n\n    for c in s:\n      count = count + 1 if c == currentChar else 1\n      currentChar = c\n      ans += count\n      ans %= MOD\n\n    return ans",
      "title": "1759. Count Number of Homogenous Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f92fd639-7d3e-4a81-b1e8-daca20a7cddb",
      "code": "class Solution:\n  def minimumSize(self, nums: list[int], maxOperations: int) -> int:\n    def numOperations(m: int) -> int:\n      \"\"\"Returns the number of operations required to make m penalty.\"\"\"\n      return sum((num - 1) // m for num in nums)\n    l = 1\n    r = max(nums)\n    return bisect.bisect_left(\n        range(l, r),\n        True, key=lambda m: numOperations(m) <= maxOperations) + l",
      "title": "1760. Minimum Limit of Balls in a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acccf737-d1ff-4809-bb61-39d4ae85ee5a",
      "code": "class Solution:\n  def minTrioDegree(self, n: int, edges: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [set() for _ in range(n)]\n    degrees = [0] * n\n\n    for u, v in edges:\n      u -= 1\n      v -= 1\n      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.\n      graph[min(u, v)].add(max(u, v))\n      degrees[u] += 1\n      degrees[v] += 1\n\n    for u in range(n):\n      for v in graph[u]:\n        for w in graph[u]:\n          if w in graph[v]:\n            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)\n\n    return -1 if ans == math.inf else ans",
      "title": "1761. Minimum Degree of a Connected Trio in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa26d8dd-9fb3-46f9-9ea7-9c9bfa14e903",
      "code": "class Solution:\n  def findBuildings(self, heights: list[int]) -> list[int]:\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        stack.pop()\n      stack.append(i)\n\n    return stack",
      "title": "1762. Buildings With an Ocean View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f63b0663-2efa-46f2-b365-de52e5fa9cc9",
      "code": "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n    if len(s) < 2:\n      return ''\n\n    seen = set(s)\n\n    for i, c in enumerate(s):\n      # If both upper and lower case letters exists in the string, keep moving,\n      # else take the erroneous character as a partition and check for its left\n      # and right parts to be nice strings.\n      if c.swapcase() not in seen:\n        prefix = self.longestNiceSubstring(s[:i])\n        suffix = self.longestNiceSubstring(s[i + 1:])\n        return max(prefix, suffix, key=len)\n\n    return s",
      "title": "1763. Longest Nice Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ee7034-7f83-4240-bddf-999c68821f87",
      "code": "class Solution:\n  def canChoose(self, groups: list[list[int]], nums: list[int]) -> bool:\n    i = 0  # groups' index\n    j = 0  # nums' index\n\n    while i < len(groups) and j < len(nums):\n      if self._isMatch(groups[i], nums, j):\n        j += len(groups[i])\n        i += 1\n      else:\n        j += 1\n\n    return i == len(groups)\n\n  # Returns True if group == nums[j..j + |group|].\n  def _isMatch(self, group: list[int], nums: list[int], j: int) -> bool:\n    if j + |group | > len(nums):\n      return False\n    for i, g in enumerate(group):\n      if g != nums[j + i]:\n        return False\n    return True",
      "title": "1764. Form Array by Concatenating Subarrays of Another Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69bc7bd1-2274-425a-9c96-1a9f6d4b8a6c",
      "code": "class Solution:\n  def highestPeak(self, isWater: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans",
      "title": "1765. Map of Highest Peak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21cbb19d-9520-4afa-ac3e-bba54e70819f",
      "code": "class Solution:\n  def getCoprimes(self, nums: list[int], edges: list[list[int]]) -> list[int]:\n    MAX = 50\n    ans = [-1] * len(nums)\n    tree = [[] for _ in range(len(nums))]\n    # stacks[i] := (node, depth)s of nodes with value i\n    stacks = [[] for _ in range(MAX + 1)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def getAncestor(u: int) -> int:\n      maxNode = -1\n      maxDepth = -1\n      for i, stack in enumerate(stacks):\n        if stack and stack[-1][1] > maxDepth and math.gcd(nums[u], i) == 1:\n          maxNode, maxDepth = stack[-1]\n      return maxNode\n\n    def dfs(u: int, prev: int, depth: int) -> int:\n      ans[u] = getAncestor(u)\n      stacks[nums[u]].append((u, depth))\n\n      for v in tree[u]:\n        if v != prev:\n          dfs(v, u, depth + 1)\n\n      stacks[nums[u]].pop()\n\n    dfs(0, -1, 0)\n    return ans",
      "title": "1766. Tree of Coprimes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "416bd7c6-acc4-4f52-a352-118f8d787518",
      "code": "class Solution:\n  def mergeAlternately(self, word1: str, word2: str) -> str:\n    return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))",
      "title": "1768. Merge Strings Alternately",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67e72453-2bca-4c41-b0ed-b1557380edd0",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], multipliers: list[int]) -> int:\n    @functools.lru_cache(2000)\n    def dp(s: int, i: int) -> int:\n      \"\"\"Returns the maximum score of nums[s..e] and multipliers[i].\"\"\"\n      if i == len(multipliers):\n        return 0\n\n      # The number of nums picked on the start side is s.\n      # The number of nums picked on the end side is i - s.\n      # So, e = n - (i - s) - 1.\n      e = len(nums) - (i - s) - 1\n      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)\n      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)\n      return max(pickStart, pickEnd)\n\n    return dp(0, 0)",
      "title": "1770. Maximum Score from Performing Multiplication Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebf549c7-ebf6-491e-8902-7561eb725368",
      "code": "class Solution:\n  def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:\n    ans = []\n    stack = []  # (pos, speed, collisionTime)\n\n    def getCollisionTime(\n            car: tuple[int, int, int],\n            pos: int, speed: int) -> float:\n      return (car[0] - pos) / (speed - car[1])\n\n    for pos, speed in reversed(cars):\n      while stack and (\n              speed <= stack[-1][1] or getCollisionTime(stack[-1],\n                                                        pos, speed) >=\n              stack[-1][2]):\n        stack.pop()\n      if stack:\n        collisionTime = getCollisionTime(stack[-1], pos, speed)\n        stack.append((pos, speed, collisionTime))\n        ans.append(collisionTime)\n      else:\n        stack.append((pos, speed, math.inf))\n        ans.append(-1)\n\n    return ans[::-1]",
      "title": "1776. Car Fleet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e739523-6753-480c-b7e4-84f6fa63d493",
      "code": "class Solution:\n  def checkPowersOfThree(self, n: int) -> bool:\n    while n > 1:\n      n, r = divmod(n, 3)\n      if r == 2:\n        return False\n    return True",
      "title": "1780. Check if Number is a Sum of Powers of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a006fc-f0ae-4ccd-8a40-91aefb9ca4b1",
      "code": "class Solution:\n  def beautySum(self, s: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      count = collections.Counter()\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        ans += max(count.values()) - min(count.values())\n\n    return ans",
      "title": "1781. Sum of Beauty of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf704dcb-524c-41a4-8f72-f5d13d4a5130",
      "code": "class Solution:\n  def countPairs(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n\n    # count[i] := the number of edges of node i\n    count = [0] * (n + 1)\n\n    # shared[i][j] := the number of edges incident to i or j, where i < j\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          # sortedCount[i] + sortedCount[j] > query\n          # sortedCount[i + 1] + sortedCount[j] > query\n          # ...\n          # sortedCount[j - 1] + sortedCount[j] > query\n          # So, there are (j - 1) - i + 1 = j - i pairs > query\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans",
      "title": "1782. Count Pairs Of Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "526e12d9-feed-4e93-990d-f2c6776ebcac",
      "code": "class Solution:\n  def checkOnesSegment(self, s: str) -> bool:\n    return '01' not in s",
      "title": "1784. Check if Binary String Has at Most One Segment of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24c02755-092a-4278-97d9-4b691de0ead9",
      "code": "class Solution:\n  def countRestrictedPaths(self, n: int, edges: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    # ways[i] := the number of restricted path from i to n\n    ways = [0] * len(graph)\n    # dist[i] := the distance to the last node of i\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= MOD\n\n    return ways[src]",
      "title": "1786. Number of Restricted Paths From First to Last Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "018546e9-9b0e-4919-a6a1-13f51182b44e",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    MAX = 1024\n    n = len(nums)\n    # counts[i] := the counter that maps at the i-th position\n    counts = [collections.Counter() for _ in range(k)]\n    # dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k - 1]) is j\n    dp = [[n] * MAX for _ in range(k)]\n\n    for i, num in enumerate(nums):\n      counts[i % k][num] += 1\n\n    def countAt(i: int) -> int:\n      return n // k + (1 if n % k > i else 0)\n\n    # Initialize the DP array.\n    for j in range(MAX):\n      dp[k - 1][j] = countAt(k - 1) - counts[k - 1][j]\n\n    for i in range(k - 2, -1, -1):\n      # The worst-case scenario is changing all the i-th position numbers to a\n      # non-existent value in the current bucket.\n      changeAll = countAt(i) + min(dp[i + 1])\n      for j in range(MAX):\n        dp[i][j] = changeAll\n        for num, freq in counts[i].items():\n          # the cost to change every number in the i-th position to `num`\n          cost = countAt(i) - freq\n          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost)\n\n    return dp[0][0]",
      "title": "1787. Make the XOR of All Segments Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1581a8b4-7009-4688-a4d2-dbd89d683b7e",
      "code": "class Solution:\n  def maximumBeauty(self, flowers: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    flowerToPrefix = collections.defaultdict(int)\n\n    for flower in flowers:\n      if flower in flowerToPrefix:\n        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)\n      prefix += max(0, flower)\n      flowerToPrefix.setdefault(flower, prefix)\n\n    return ans",
      "title": "1788. Maximize the Beauty of the Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd0eea59-81d4-41e5-8db2-7b905ed6b205",
      "code": "class Solution:\n  # Similar to 859. Buddy Strings\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    return not diffIndices or (len(diffIndices) == 2 and\n                               s1[diffIndices[0]] == s2[diffIndices[1]] and\n                               s1[diffIndices[1]] == s2[diffIndices[0]])",
      "title": "1790. Check if One String Swap Can Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd12d05b-ffe7-44b7-abfb-ced446e2fbec",
      "code": "class Solution:\n  def findCenter(self, edges: list[list[int]]) -> int:\n    if edges[0][0] in edges[1]:\n      return edges[0][0]\n    return edges[0][1]",
      "title": "1791. Find Center of Star Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bdbee85-5012-45ab-9ed3-34e4ed17aba5",
      "code": "class Solution:\n  def maxAverageRatio(\n      self,\n      classes: list[list[int]],\n      extraStudents: int,\n  ) -> float:\n    def extraPassRatio(pas: int, total: int) -> float:\n      \"\"\"Returns the extra pass ratio if a brilliant student joins.\"\"\"\n      return (pas + 1) / (total + 1) - pas / total\n\n    maxHeap = [(-extraPassRatio(pas, total), pas, total)\n               for pas, total in classes]\n    heapq.heapify(maxHeap)\n\n    for _ in range(extraStudents):\n      _, pas, total = heapq.heappop(maxHeap)\n      heapq.heappush(\n          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))\n\n    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)",
      "title": "1792. Maximum Average Pass Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87389081-2e2a-479f-bb64-8feb63d6d6b0",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = nums[k]\n    mn = nums[k]\n    i = k\n    j = k\n\n    # Greedily expand the window and decrease the minimum as slow as possible.\n    while i > 0 or j < n - 1:\n      if i == 0:\n        j += 1\n      elif j == n - 1:\n        i -= 1\n      elif nums[i - 1] < nums[j + 1]:\n        j += 1\n      else:\n        i -= 1\n      mn = min(mn, nums[i], nums[j])\n      ans = max(ans, mn * (j - i + 1))\n\n    return ans",
      "title": "1793. Maximum Score of a Good Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b67a0251-b9e1-42a9-a71d-cf4adb5b0226",
      "code": "class Solution:\n  def countQuadruples(self, s1: str, s2: str) -> int:\n    # To minimize j - a, the length of the substring should be 1. This is\n    # because for substrings with a size greater than 1, a will decrease,\n    # causing j - a to become larger.\n    ans = 0\n    diff = math.inf  # diff := j - a\n    firstJ = {}\n    lastA = {}\n\n    for j in range(len(s1) - 1, -1, -1):\n      firstJ[s1[j]] = j\n\n    for a in range(len(s2)):\n      lastA[s2[a]] = a\n\n    for c in string.ascii_lowercase:\n      if c not in firstJ or c not in lastA:\n        continue\n      if firstJ[c] - lastA[c] < diff:\n        diff = firstJ[c] - lastA[c]\n        ans = 0\n      if firstJ[c] - lastA[c] == diff:\n        ans += 1\n\n    return ans",
      "title": "1794. Count Pairs of Equal Substrings With Minimum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67c0e164-303e-45c5-b8a8-218442707dd8",
      "code": "class Solution:\n  def secondHighest(self, s: str) -> int:\n    maxDigit = -1\n    secondMaxDigit = -1\n\n    for c in s:\n      if c.isdigit():\n        d = int(c)\n        if d > maxDigit:\n          secondMaxDigit = maxDigit\n          maxDigit = d\n        elif maxDigit > d > secondMaxDigit:\n          secondMaxDigit = d\n\n    return secondMaxDigit",
      "title": "1796. Second Largest Digit in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6ef2509-4a82-4e8e-a89a-5e148cc43c0e",
      "code": "class Solution:\n  def getMaximumConsecutive(self, coins: list[int]) -> int:\n    ans = 1  # the next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
      "title": "1798. Maximum Number of Consecutive Values You Can Make",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a737466-5785-4fe7-b723-ce959bdab2eb",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n\n    @functools.lru_cache(None)\n    def dp(k: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score you can receive after performing the k to n\n      operations, where `mask` is the bitmask of the chosen numbers.\n      \"\"\"\n      if k == n + 1:\n        return 0\n\n      res = 0\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        chosenMask = 1 << i | 1 << j\n        if (mask & chosenMask) == 0:\n          res = max(res, k * math.gcd(nums[i], nums[j])\n                    + dp(k + 1, mask | chosenMask))\n\n      return res\n\n    return dp(1, 0)",
      "title": "1799. Maximize Score After N Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e44d068-1386-4192-bc05-f6dcdf85f57f",
      "code": "class Solution:\n  def maxAscendingSum(self, nums: list[int]) -> int:\n    ans = 0\n    sum = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        sum += nums[i]\n      else:\n        ans = max(ans, sum)\n        sum = nums[i]\n\n    return max(ans, sum)",
      "title": "1800. Maximum Ascending Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "262ace28-5e42-4320-8a95-885a763f9988",
      "code": "class Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    return ['0'] if index == -1 else s[index:]",
      "title": "1805. Number of Different Integers in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fa2b3eb-c142-4fec-894b-ddd91743aeba",
      "code": "class Solution:\n  def squareIsWhite(self, coordinates: str) -> bool:\n    letter, digit = coordinates\n    return ord(letter) % 2 != int(digit) % 2",
      "title": "1812. Determine Color of a Chessboard Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9804a410-1441-483c-b54f-df5da8200849",
      "code": "class Solution:\n  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n    if len(sentence1) == len(sentence2):\n      return sentence1 == sentence2\n\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n    m, n = map(len, (words1, words2))\n    if m > n:\n      return self.areSentencesSimilar(sentence2, sentence1)\n\n    i = 0  # words1's index\n    while i < m and words1[i] == words2[i]:\n      i += 1\n    while i < m and words1[i] == words2[i + n - m]:\n      i += 1\n\n    return i == m",
      "title": "1813. Sentence Similarity III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92dd96b1-05bd-4f2a-919b-21d3a4b6710d",
      "code": "class Solution:\n  def countNicePairs(self, nums: list[int]) -> int:\n    freqs = collections.Counter(num - int(str(num)[::-1]) for num in nums)\n    return sum(freq * (freq - 1) // 2 for freq in freqs.values()) % 1000000007",
      "title": "1814. Count Nice Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcb6afbf-c878-4166-8f2a-4d4445f5d965",
      "code": "class Solution:\n  def maxHappyGroups(self, batchSize: int, groups: list[int]) -> int:\n    happy = 0\n    freq = [0] * batchSize\n\n    for g in groups:\n      g %= batchSize\n      if g == 0:\n        happy += 1\n      elif freq[batchSize - g]:\n        freq[batchSize - g] -= 1\n        happy += 1\n      else:\n        freq[g] += 1\n\n    @functools.lru_cache(None)\n    def dp(freq: int, remainder: int) -> int:\n      \"\"\"Returns the maximum number of partitions can be formed.\"\"\"\n      ans = 0\n      if any(freq):\n        for i, f in enumerate(freq):\n          if f:\n            ans = max(ans, dp(freq[:i] + (f - 1,) +\n                              freq[i + 1:], (remainder + i) % batchSize))\n        if remainder == 0:\n          ans += 1\n      return ans\n\n    return happy + dp(tuple(freq), 0)",
      "title": "1815. Maximum Number of Groups Getting Fresh Donuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54aa3b15-acdc-4d9f-a284-8db737a16ec0",
      "code": "class Solution:\n  def truncateSentence(self, s: str, k: int) -> str:\n    return ' '.join(s.split()[:k])",
      "title": "1816. Truncate Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d864b34c-016f-4031-809f-3b96ea350aa1",
      "code": "class Solution:\n  def findingUsersActiveMinutes(\n      self,\n      logs: list[list[int]],\n      k: int,\n  ) -> list[int]:\n    idToTimes = collections.defaultdict(set)\n\n    for id, time in logs:\n      idToTimes[id].add(time)\n\n    c = collections.Counter(len(times) for times in idToTimes.values())\n    return [c[i] for i in range(1, k + 1)]",
      "title": "1817. Finding the Users Active Minutes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df7e0000-f290-450e-a41a-a1fd259082ab",
      "code": "class Solution:\n  def minAbsoluteSumDiff(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = math.inf\n    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]\n    sumDiff = sum(diffs)\n\n    nums1.sort()\n\n    for num, diff in zip(nums2, diffs):\n      i = bisect.bisect_left(nums1, num)\n      if i > 0:\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))\n      if i < len(nums1):\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))\n\n    return ans % 1_000_000_007",
      "title": "1818. Minimum Absolute Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f708a2e-926c-4c87-b544-ffac710f9b74",
      "code": "class Solution:\n  def maximumInvitations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    mates = [-1] * n  # mates[i] := the i-th girl's mate\n\n    def canInvite(i: int, seen: list[bool]) -> bool:\n      \"\"\"Returns True if the i-th boy can make an invitation.\"\"\"\n      # The i-th boy asks each girl.\n      for j in range(n):\n        if not grid[i][j] or seen[j]:\n          continue\n        seen[j] = True\n        if mates[j] == -1 or canInvite(mates[j], seen):\n          mates[j] = i  # Match the j-th girl with i-th boy.\n          return True\n      return False\n\n    for i in range(m):\n      seen = [False] * n\n      if canInvite(i, seen):\n        ans += 1\n\n    return ans",
      "title": "1820. Maximum Number of Accepted Invitations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1df2a39-0675-4dee-bdc1-b73009631703",
      "code": "class Solution:\n  def arraySign(self, nums: list[int]) -> int:\n    sign = 1\n\n    for num in nums:\n      if num == 0:\n        return 0\n      if num < 0:\n        sign = -sign\n\n    return sign",
      "title": "1822. Sign of the Product of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f3ee80-11c0-478e-bcfa-d02c808fc9db",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # e.g. n = 4, k = 2.\n    # By using 0-indexed notation, we have the following circle:\n    #\n    # 0 -> 1 -> 2 -> 3 -> 0\n    #      x\n    #           0 -> 1 -> 2 -> 0\n    #\n    # After the first round, 1 is removed.\n    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n    def f(n: int, k: int) -> int:\n      ans = 0  # f(1, k)\n      # Computes f(i, k) based on f(i - 1, k).\n      for i in range(2, n + 1):\n        ans = (ans + k) % i\n      return ans\n\n    # Converts back to 1-indexed.\n    return f(n, k) + 1",
      "title": "1823. Find the Winner of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a032e78e-6592-4505-b230-967cb3b25c81",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # True if i-th friend is left\n    friends = [False] * n\n\n    friendCount = n\n    fp = 0  # friends' index\n\n    while friendCount > 1:\n      for _ in range(k):\n        while friends[fp % n]:  # The friend is not there.\n          fp += 1  # Point to the next one.\n        fp += 1\n      friends[(fp - 1) % n] = True\n      friendCount -= 1\n\n    fp = 0\n    while friends[fp]:\n      fp += 1\n\n    return fp + 1",
      "title": "1823. Find the Winner of the Circular Game_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704e6c78-f7fd-4919-886e-6c76b2ab7b4e",
      "code": "class Solution:\n  def minSideJumps(self, obstacles: list[int]) -> int:\n    INF = 1e6\n    # dp[i] := the minimum jump to reach the i-th lane\n    dp = [INF, 1, 0, 1]\n\n    for obstacle in obstacles:\n      print(dp)\n      if obstacle > 0:\n        dp[obstacle] = INF\n      for i in range(1, 4):  # the current\n        if i != obstacle:\n          for j in range(1, 4):  # the previous\n            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))\n\n    return min(dp)",
      "title": "1824. Minimum Sideway Jumps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f626f578-363a-4fc5-ac83-059d7b015355",
      "code": "class Solution:\n  def badSensor(self, sensor1: list[int], sensor2: list[int]) -> int:\n    # A -> B, so B is defect\n    def canReplace(A, B):\n      i = 0  # A's index\n      j = 0  # B's index\n      droppedValue = -1\n\n      while i < len(A):\n        if A[i] == B[j]:\n          i += 1\n          j += 1\n        else:\n          droppedValue = A[i]\n          i += 1\n\n      return j == len(B) - 1 and B[-1] != droppedValue\n\n    oneDefect = canReplace(sensor2, sensor1)\n    twoDefect = canReplace(sensor1, sensor2)\n    if oneDefect and twoDefect:\n      return -1\n    if not oneDefect and not twoDefect:\n      return -1\n    return 1 if oneDefect else 2",
      "title": "1826. Faulty Sensor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a44e1eef-82a0-4349-a90d-a3c87364cbb8",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    last = 0\n\n    for num in nums:\n      ans += max(0, last - num + 1)\n      last = max(num, last + 1)\n\n    return ans",
      "title": "1827. Minimum Operations to Make the Array Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2324a57c-e85d-40ce-95c1-f7c548a7cd91",
      "code": "class Solution:\n  def countPoints(\n      self,\n      points: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    for xj, yj, rj in queries:\n      count = 0\n      for xi, yi in points:\n        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:\n          count += 1\n      ans.append(count)\n\n    return ans",
      "title": "1828. Queries on Number of Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "052310f7-4389-45a0-9e71-cc825a1af0aa",
      "code": "class Solution:\n  def getMaximumXor(self, nums: list[int], maximumBit: int) -> list[int]:\n    mx = (1 << maximumBit) - 1\n    ans = []\n    xors = 0\n\n    for num in nums:\n      xors ^= num\n      ans.append(xors ^ mx)\n\n    return ans[::-1]",
      "title": "1829. Maximum XOR for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1939883-f51b-453b-bc49-fa957d4d4cd3",
      "code": "class Solution:\n  def makeStringSorted(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = [0] * 26\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    for i, c in enumerate(reversed(s)):\n      order = ord(c) - ord('a')\n      count[order] += 1\n      # count[:order] := s[i] can be any character smaller than c\n      # fact(i) := s[i + 1..n - 1] can be any sequence of characters\n      perm = sum(count[:order]) * fact(i)\n      for j in range(26):\n        perm = perm * inv(fact(count[j])) % MOD\n      ans = (ans + perm) % MOD\n\n    return ans",
      "title": "1830. Minimum Number of Operations to Make String Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5bfea69-8c15-4e07-8b0d-c8a416870d09",
      "code": "class Solution:\n  def checkIfPangram(self, sentence: str) -> bool:\n    seen = 0\n\n    for c in sentence:\n      seen |= 1 << ord(c) - ord('a')\n\n    return seen == (1 << 26) - 1",
      "title": "1832. Check if the Sentence Is Pangram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2f01237-7fce-4c71-a8da-cb1f0269eece",
      "code": "class Solution:\n  def maxIceCream(self, costs: list[int], coins: int) -> int:\n    for i, cost in enumerate(sorted(costs)):\n      if coins >= cost:\n        coins -= cost\n      else:\n        return i\n\n    return len(costs)",
      "title": "1833. Maximum Ice Cream Bars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f167495c-ce7e-4d33-99a2-2fcbb1982131",
      "code": "class Solution:\n  def getOrder(self, tasks: list[list[int]]) -> list[int]:\n    n = len(tasks)\n    A = [[*task, i] for i, task in enumerate(tasks)]\n    ans = []\n    minHeap = []\n    i = 0  # tasks' index\n    time = 0  # the current time\n\n    A.sort()\n\n    while i < n or minHeap:\n      if not minHeap:\n        time = max(time, A[i][0])\n      while i < n and time >= A[i][0]:\n        heapq.heappush(minHeap, (A[i][1], A[i][2]))\n        i += 1\n      procTime, index = heapq.heappop(minHeap)\n      time += procTime\n      ans.append(index)\n\n    return ans",
      "title": "1834. Single-Threaded CPU",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f987b4f7-2e0b-4409-bc26-945e365dacc6",
      "code": "class Solution:\n  def getXORSum(self, arr1: list[int], arr2: list[int]) -> int:\n    return functools.reduce(\n        operator.xor, arr1) & functools.reduce(\n        operator.xor, arr2)",
      "title": "1835. Find XOR Sum of All Pairs Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d127410-b7b7-456b-adbc-fe6464f4b1d6",
      "code": "class Solution:\n  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    count = collections.Counter()\n\n    curr = head\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    curr = dummy\n\n    while curr:\n      while curr.next and curr.next.val in count and count[curr.next.val] > 1:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return dummy.next",
      "title": "1836. Remove Duplicates From an Unsorted Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb42aadb-d2a8-4a37-918e-55572c051f89",
      "code": "class Solution:\n  def sumBase(self, n: int, k: int) -> int:\n    ans = 0\n\n    while n > 0:\n      ans += n % k\n      n //= k\n\n    return ans",
      "title": "1837. Sum of Digits in Base K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e54f2edb-0831-4ac6-96ed-d1c0a5b0adeb",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    nums.sort()\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ + k < num * (r - l + 1):\n        summ -= nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1838. Frequency of the Most Frequent Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8885dcf-edaf-4779-a102-05c47482aad1",
      "code": "class Solution:\n  def longestBeautifulSubstring(self, word: str) -> int:\n    ans = 0\n    count = 1\n\n    l = 0\n    for r in range(1, len(word)):\n      curr = word[r]\n      prev = word[r - 1]\n      if curr >= prev:\n        if curr > prev:\n          count += 1\n        if count == 5:\n          ans = max(ans, r - l + 1)\n      else:\n        count = 1\n        l = r\n\n    return ans",
      "title": "1839. Longest Substring Of All Vowels in Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c1d59c9-7cb7-4299-8e82-b2add4cd5af4",
      "code": "class Solution:\n  def maxBuilding(self, n: int, restrictions: list[list[int]]) -> int:\n    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])\n\n    for i in range(len(A)):\n      dist = A[i][0] - A[i - 1][0]\n      A[i][1] = min(A[i][1], A[i - 1][1] + dist)\n\n    for i in reversed(range(len(A) - 1)):\n      dist = A[i + 1][0] - A[i][0]\n      A[i][1] = min(A[i][1], A[i + 1][1] + dist)\n\n    ans = 0\n\n    for (l, hL), (r, hR) in zip(A, A[1:]):\n      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)\n\n    return ans",
      "title": "1840. Maximum Building Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b3d0f31-8814-456b-81d6-e34367227b1e",
      "code": "class Solution:\n  def nextPalindrome(self, num: str) -> str:\n    def nextPermutation(nums: list[int]) -> bool:\n      n = len(nums)\n\n      # From the back to the front, find the first num < nums[i + 1].\n      i = n - 2\n      while i >= 0:\n        if nums[i] < nums[i + 1]:\n          break\n        i -= 1\n\n      if i < 0:\n        return False\n\n      # From the back to the front, find the first num > nums[i] and swap it\n      # with nums[i].\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n      def reverse(nums, l, r):\n        while l < r:\n          nums[l], nums[r] = nums[r], nums[l]\n          l += 1\n          r -= 1\n\n      # Reverse nums[i + 1..n - 1].\n      reverse(nums, i + 1, len(nums) - 1)\n      return True\n\n    n = len(num)\n    arr = [int(num[i]) for i in range(len(num) // 2)]\n    if not nextPermutation(arr):\n      return ''\n\n    s = ''.join([chr(ord('0') + a) for a in arr])\n    if n % 2 == 1:\n      return s + num[n // 2] + s[::-1]\n    return s + s[::-1]",
      "title": "1842. Next Palindrome Using Same Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e40c5f0a-f463-46f9-881f-7837d3ab1c69",
      "code": "class Solution:\n  def replaceDigits(self, s: str) -> str:\n    return ''.join(\n        c if i % 2 == 0 else chr(ord(s[i - 1]) + int(c))\n        for i, c in enumerate(s)\n    )",
      "title": "1844. Replace All Digits with Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f20b02cd-dff0-4451-92bd-ec4f3eb21588",
      "code": "class Solution:\n  def maximumElementAfterDecrementingAndRearranging(\n      self, arr: list[int],\n  ) -> int:\n    arr.sort()\n    arr[0] = 1\n\n    for i in range(1, len(arr)):\n      arr[i] = min(arr[i], arr[i - 1] + 1)\n\n    return arr[-1]",
      "title": "1846. Maximum Element After Decreasing and Rearranging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea465501-1646-4b78-ae00-50ade18ef822",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def closestRoom(\n      self,\n      rooms: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    qs = [[*q, i] for i, q in enumerate(queries)]\n    roomIds = SortedList()\n\n    rooms.sort(key=lambda x: -x[1])\n    qs.sort(key=lambda x: -x[1])\n\n    def searchClosestRoomId(roomIds: SortedList, preferred: int):\n      if not roomIds:\n        return -1\n\n      candIds = []\n      i = roomIds.bisect_right(preferred)\n      if i > 0:\n        candIds.append(roomIds[i - 1])\n      if i < len(roomIds):\n        candIds.append(roomIds[i])\n      return min(candIds, key=lambda x: abs(x - preferred))\n\n    i = 0  # rooms' index\n    for preferred, minSize, index in qs:\n      while i < len(rooms) and rooms[i][1] >= minSize:\n        roomIds.add(rooms[i][0])\n        i += 1\n      ans[index] = searchClosestRoomId(roomIds, preferred)\n\n    return ans",
      "title": "1847. Closest Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbfd1755-6906-4dbc-a727-7e9530ab4e68",
      "code": "class Solution:\n  def getMinDistance(self, nums: list[int], target: int, start: int) -> int:\n    ans = math.inf\n\n    for i, num in enumerate(nums):\n      if num == target:\n        ans = min(ans, abs(i - start))\n\n    return ans",
      "title": "1848. Minimum Distance to the Target Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d5a8b3b-8a05-40c9-ab03-5dd59b6d5ec2",
      "code": "class Solution:\n  def splitString(self, s: str) -> bool:\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\n      if start == len(s) and segment > 1:\n        return True\n\n      curr = 0\n      for i in range(start, len(s)):\n        curr = curr * 10 + int(s[i])\n        if curr > 9999999999:\n          return False\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\n          return True\n\n      return False\n\n    return isValid(s, 0, -1, 0)",
      "title": "1849. Splitting a String Into Descending Consecutive Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "413dc341-97e1-46eb-8257-213f32fe03da",
      "code": "class Solution:\n  def getMinSwaps(self, num: str, k: int) -> int:\n    original = [int(c) for c in num]\n    permutated = original.copy()\n\n    for _ in range(k):\n      self._nextPermutation(permutated)\n\n    return self._countSteps(original, permutated)\n\n  def _nextPermutation(self, nums: list[int]):\n    n = len(nums)\n\n    # From the back to the front, find the first num < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From the back to the front, find the first num > nums[i] and swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums, l, r):\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)\n\n  def _countSteps(self, A: list[int], B: list[int]) -> int:\n    count = 0\n\n    j = 0\n    for i in range(len(A)):\n      j = i\n      while A[i] != B[j]:\n        j += 1\n      while i < j:\n        B[j], B[j - 1] = B[j - 1], B[j]\n        j -= 1\n        count += 1\n\n    return count",
      "title": "1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f89c4680-0eaa-4c6c-b464-02146815a27e",
      "code": "class Solution:\n  def distinctNumbers(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    count = collections.Counter()\n    distinct = 0\n\n    for i, num in enumerate(nums):\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n      if i >= k - 1:\n        ans.append(distinct)\n\n    return ans",
      "title": "1852. Distinct Numbers in Each Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39a9e070-3315-4431-bb42-95f475c52074",
      "code": "class Solution:\n  def maximumPopulation(self, logs: list[list[int]]) -> int:\n    MIN_YEAR = 1950\n    MAX_YEAR = 2050\n    ans = 0\n    maxPopulation = 0\n    runningPopulation = 0\n    # population[i] := the population of year i\n    population = [0] * (MAX_YEAR + 1)\n\n    for birth, death in logs:\n      population[birth] += 1\n      population[death] -= 1\n\n    for year in range(MIN_YEAR, MAX_YEAR + 1):\n      runningPopulation += population[year]\n      if runningPopulation > maxPopulation:\n        maxPopulation = runningPopulation\n        ans = year\n\n    return ans",
      "title": "1854. Maximum Population Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c66fbee-d800-4d21-a246-71a0c781df4e",
      "code": "class Solution:\n  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    i = 0\n    j = 0\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] > nums2[j]:\n        i += 1\n      else:\n        ans = max(ans, j - i)\n        j += 1\n\n    return ans",
      "title": "1855. Maximum Distance Between a Pair of Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9c674e4-b3d6-481e-acde-bc02e7f29d70",
      "code": "class Solution:\n  def maxSumMinProduct(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        minVal = nums[stack.pop()]\n        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]\n        ans = max(ans, minVal * summ)\n      stack.append(i)\n\n    return ans % 1_000_000_007",
      "title": "1856. Maximum Subarray Min-Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20ff5c89-3983-46c3-a733-944a22637930",
      "code": "class Solution:\n  def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Vpology\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans if processed == n else -1",
      "title": "1857. Largest Color Value in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cc297b3-e98a-4fc6-bb9a-15b601a7bbba",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def longestWord(self, words: list[str]) -> str:\n    ans = ''\n\n    for word in words:\n      self.insert(word)\n\n    for word in words:\n      if not self.allPrefixed(word):\n        continue\n      if len(ans) < len(word) or (len(ans) == len(word) and ans > word):\n        ans = word\n\n    return ans\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['isWord'] = True\n\n  def allPrefixed(self, word: str) -> bool:\n    node = self.root\n    for c in word:\n      node = node[c]\n      if 'isWord' not in node:\n        return False\n    return True",
      "title": "1858. Longest Word With All Prefixes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6e04b00-87db-4b26-b26e-37d2ac1e44ce",
      "code": "class Solution:\n  def sortSentence(self, s: str) -> str:\n    return ' '.join([word[:-1]\n                     for word in sorted(s.split(), key=lambda x: x[-1])])",
      "title": "1859. Sorting the Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e07508d-318f-498e-b8e1-b1382ef7bdfe",
      "code": "class Solution:\n  def memLeak(self, memory1: int, memory2: int) -> list[int]:\n    i = 1\n\n    while memory1 >= i or memory2 >= i:\n      if memory1 >= memory2:\n        memory1 -= i\n      else:\n        memory2 -= i\n      i += 1\n\n    return [i, memory1, memory2]",
      "title": "1860. Incremental Memory Leak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3851fe4f-e744-40a0-bf47-fc219e1bca4c",
      "code": "class Solution:\n  def rotateTheBox(self, box: list[list[str]]) -> list[list[str]]:\n    m = len(box)\n    n = len(box[0])\n    rotated = [['.'] * m for _ in range(n)]\n\n    for i in range(m):\n      k = n - 1\n      for j in reversed(range(n)):\n        if box[i][j] != '.':\n          if box[i][j] == '*':\n            k = j\n          rotated[k][m - i - 1] = box[i][j]\n          k -= 1\n\n    return [''.join(row) for row in rotated]",
      "title": "1861. Rotating the Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5868887d-8023-4148-9275-0a1fa705d379",
      "code": "class Solution:\n  def sumOfFlooredPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = max(nums)\n    ans = 0\n    count = [0] * (MAX + 1)\n\n    for num in nums:\n      count[num] += 1\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    for i in range(1, MAX + 1):\n      if count[i] > count[i - 1]:\n        summ = 0\n        j = 1\n        while i * j <= MAX:\n          lo = i * j - 1\n          hi = i * (j + 1) - 1\n          summ += (count[min(hi, MAX)] - count[lo]) * j\n          j += 1\n        ans += summ * (count[i] - count[i - 1])\n        ans %= MOD\n\n    return ans",
      "title": "1862. Sum of Floored Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7dcf64ae-f7a6-4936-a55a-f232033a7936",
      "code": "class Solution:\n  def subsetXORSum(self, nums: list[int]) -> int:\n    def dfs(i: int, xors: int) -> int:\n      if i == len(nums):\n        return xors\n\n      x = dfs(i + 1, xors)\n      y = dfs(i + 1, nums[i] ^ xors)\n      return x + y\n\n    return dfs(0, 0)",
      "title": "1863. Sum of All Subset XOR Totals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c37a57d-4817-42c7-a6ac-656b97261174",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    ones = s.count('1')\n    zeros = len(s) - ones\n    if abs(ones - zeros) > 1:\n      return -1\n\n    def countSwaps(curr: str) -> int:\n      swaps = 0\n      for c in s:\n        if c != curr:\n          swaps += 1\n        curr = chr(ord(curr) ^ 1)\n      return swaps // 2\n\n    if ones > zeros:\n      return countSwaps('1')\n    if zeros > ones:\n      return countSwaps('0')\n    return min(countSwaps('1'), countSwaps('0'))",
      "title": "1864. Minimum Number of Swaps to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab48ad6b-0e71-48ac-9d41-0df91cdca7cf",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def rearrangeSticks(self, n: int, k: int) -> int:\n    if n == k:\n      return 1\n    if k == 0:\n      return 0\n    return (self.rearrangeSticks(n - 1, k - 1) +\n            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.MOD\n\n  MOD = 1_000_000_007",
      "title": "1866. Number of Ways to Rearrange Sticks With K Sticks Visible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e1991c1-876f-429f-8738-13647303096a",
      "code": "class Solution:\n  def findRLEArray(self, encoded1: list[list[int]],\n                   encoded2: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # encoded1's index\n    j = 0  # encoded2's index\n\n    while i < len(encoded1) and j < len(encoded2):\n      mult = encoded1[i][0] * encoded2[j][0]\n      minFreq = min(encoded1[i][1], encoded2[j][1])\n      if ans and mult == ans[-1][0]:\n        ans[-1][1] += minFreq\n      else:\n        ans.append([mult, minFreq])\n      encoded1[i][1] -= minFreq\n      encoded2[j][1] -= minFreq\n      if encoded1[i][1] == 0:\n        i += 1\n      if encoded2[j][1] == 0:\n        j += 1\n\n    return ans",
      "title": "1868. Product of Two Run-Length Encoded Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5175118-5745-4865-aadf-650f37d0fa67",
      "code": "class Solution:\n  def checkZeroOnes(self, s: str) -> bool:\n    longestOnes = 0\n    longestZeros = 0\n    currentOnes = 0\n    currentZeros = 0\n\n    for c in s:\n      if c == '0':\n        currentOnes = 0\n        currentZeros += 1\n        longestZeros = max(longestZeros, currentZeros)\n      else:\n        currentZeros = 0\n        currentOnes += 1\n        longestOnes = max(longestOnes, currentOnes)\n\n    return longestOnes > longestZeros",
      "title": "1869. Longer Contiguous Segments of Ones than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0754567c-d935-4861-8aba-914da9d54651",
      "code": "class Solution:\n  def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\n    ans = -1\n    l = 1\n    r = int(1e7)\n\n    def time(speed: int) -> float:\n      summ = 0\n      for i in range(len(dist) - 1):\n        summ += math.ceil(dist[i] / speed)\n      return summ + dist[-1] / speed\n\n    while l <= r:\n      m = (l + r) // 2\n      if time(m) > hour:\n        l = m + 1\n      else:\n        ans = m\n        r = m - 1\n\n    return ans",
      "title": "1870. Minimum Speed to Arrive on Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f9c2429-5821-43a8-b421-bb1546b94834",
      "code": "class Solution:\n  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n    count = 0\n    dp = [True] + [False] * (len(s) - 1)\n\n    for i in range(minJump, len(s)):\n      count += dp[i - minJump]\n      if i - maxJump > 0:\n        count -= dp[i - maxJump - 1]\n      dp[i] = count and s[i] == '0'\n\n    return dp[-1]",
      "title": "1871. Jump Game VII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f73d2d4-be00-403a-9277-7a7ca4c53a45",
      "code": "class Solution:\n  def stoneGameVIII(self, stones: list[int]) -> int:\n    n = len(stones)\n    prefix = list(itertools.accumulate(stones))\n    # dp[i] := the maximum score difference the current player can get when the\n    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    dp = [-math.inf] * n\n\n    # Must take all when there're only two stones left.\n    dp[n - 2] = prefix[-1]\n\n    for i in reversed(range(n - 2)):\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])\n\n    return dp[0]",
      "title": "1872. Stone Game VIII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1634016-1e93-4e22-91dd-6803c2df86a0",
      "code": "class Solution:\n  def minProductSum(self, nums1: list[int], nums2: list[int]) -> int:\n    return sum([a * b for a, b in zip(sorted(nums1), sorted(nums2, reverse=True))])",
      "title": "1874. Minimize Product Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5184dbd-3b0b-411d-9d28-715b8773a565",
      "code": "class Solution:\n  def countGoodSubstrings(self, s: str) -> int:\n    ans = 0\n\n    for a, b, c in zip(s, s[1:], s[2:]):\n      if a == b or a == c or b == c:\n        continue\n      ans += 1\n\n    return ans",
      "title": "1876. Substrings of Size Three with Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e94745d7-7cb1-4190-bede-599bc7aae1ec",
      "code": "class Solution:\n  def minPairSum(self, nums: list[int]) -> int:\n    nums.sort()\n    return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) // 2))",
      "title": "1877. Minimize Maximum Pair Sum in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c440b841-e3e0-4f88-9c10-d180d8513f25",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return sums\n\n  def _getSum(self, grid: list[list[int]], i: int, j: int, sz: int) -> int:\n    \"\"\"\n    Returns the sum of the rhombus, where the top grid is (i, j) and the edge\n    size is `sz`.\n    \"\"\"\n    x = i\n    y = j\n    summ = 0\n\n    # Go left down.\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right down.\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right up.\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    # Go left up.\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ",
      "title": "1878. Get Biggest Three Rhombus Sums in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98639560-73c6-4c05-b517-fdc8d62eaa6a",
      "code": "class Solution:\n  def minimumXORSum(self, nums1: list[int], nums2: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      i = mask.bit_count()\n      if i == len(nums1):\n        return 0\n      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)\n                 for j in range(len(nums2)) if not mask >> j & 1)\n    return dp(0)",
      "title": "1879. Minimum XOR Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f668bb97-df74-4f48-b1d1-1478d77613e7",
      "code": "class Solution:\n  def isSumEqual(\n      self,\n      firstWord: str,\n      secondWord: str,\n      targetWord: str,\n  ) -> bool:\n    first = self._getNumber(firstWord)\n    second = self._getNumber(secondWord)\n    target = self._getNumber(targetWord)\n    return first + second == target\n\n  def _getNumber(self, word: str) -> int:\n    num = 0\n    for c in word:\n      num = num * 10 + ord(c) - ord('a')\n    return num",
      "title": "1880. Check if Word Equals Summation of Two Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85b3cbd7-b04e-4163-ab4a-eb7bf0f16f89",
      "code": "class Solution:\n  def maxValue(self, n: str, x: int) -> str:\n    isNegative = n[0] == '-'\n\n    for i, c in enumerate(n):\n      if not isNegative and int(c) < x or isNegative and int(c) > x:\n        return n[:i] + str(x) + n[i:]\n\n    return n + str(x)",
      "title": "1881. Maximum Value after Insertion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b6d0fa6-39fb-425e-bad2-2ccdf21ffc24",
      "code": "class Solution:\n  def assignTasks(self, servers: list[int], tasks: list[int]) -> list[int]:\n    ans = []\n    free = []  # (weight, index, freeTime)\n    used = []  # (freeTime, weight, index)\n\n    for i, weight in enumerate(servers):\n      heapq.heappush(free, (weight, i, 0))\n\n    for i, executionTime in enumerate(tasks):  # i := the current time\n      # Poll all servers that'll be free at time i.\n      while used and used[0][0] <= i:\n        curr = heapq.heappop(used)\n        heapq.heappush(free, (curr[1], curr[2], curr[0]))\n      if free:\n        curr = heapq.heappop(free)\n        ans.append(curr[1])\n        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))\n      else:\n        curr = heapq.heappop(used)\n        ans.append(curr[2])\n        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))\n\n    return ans",
      "title": "1882. Process Tasks Using Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef8dea33-e909-493e-bc08-d6bfbde4132d",
      "code": "class Solution:\n  def minSkips(self, dist: list[int], speed: int, hoursBefore: int) -> int:\n    INF = 10**7\n    EPS = 1e-9\n    n = len(dist)\n    # dp[i][j] := the minimum time, where i is the number of roads we traversed\n    # so far and j is the number of skips we did\n    dp = [[INF] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i, d in enumerate(dist, 1):\n      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - EPS)\n      for j in range(1, i + 1):\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       math.ceil(dp[i - 1][j] + d / speed - EPS))\n\n    for j, time in enumerate(dp[-1]):\n      if time <= hoursBefore:\n        return j\n\n    return -1",
      "title": "1883. Minimum Skips to Arrive at Meeting On Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b5756bf-5d36-4e74-8a66-a77e66fc7fc2",
      "code": "class Solution:\n  def countPairs(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    arr = sorted([x - y for x, y in zip(nums1, nums2)])\n\n    for i, a in enumerate(arr):\n      index = bisect_left(arr, -a + 1)\n      ans += len(arr) - max(i + 1, index)\n\n    return ans",
      "title": "1885. Count Pairs in Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f8b73ec-d14d-47f3-bba0-64b7817cfec9",
      "code": "class Solution:\n  def findRotation(self, mat: list[list[int]], target: list[list[int]]) -> bool:\n    for _ in range(4):\n      if mat == target:\n        return True\n      mat = [list(x) for x in zip(*mat[::-1])]\n    return False",
      "title": "1886. Determine Whether Matrix Can Be Obtained By Rotation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d4dc5c-813c-4cac-b9db-2b3df4311954",
      "code": "class Solution:\n  def reductionOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 1, 0, -1):\n      if nums[i] != nums[i - 1]:\n        ans += len(nums) - i\n\n    return ans",
      "title": "1887. Reduction Operations to Make the Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "268b468b-8692-4f52-99ec-a4acc2577bf2",
      "code": "class Solution:\n  def minFlips(self, s: str) -> int:\n    n = len(s)\n    # count[0][0] :=  the number of '0' in the even indices\n    # count[0][1] :=  the number of '0' in the odd indices\n    # count[1][0] :=  the number of '1' in the even indices\n    # count[1][1] :=  the number of '1' in the odd indices\n    count = [[0] * 2 for _ in range(2)]\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] += 1\n\n    # min(make all 0s in the even indices + make all 1s in the odd indices,\n    #     make all 1s in the even indices + make all 0s in the odd indices)\n    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] -= 1\n      count[int(c)][(n + i) % 2] += 1\n      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    return ans",
      "title": "1888. Minimum Number of Flips to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c1ed82a-a08e-447a-a690-1bcfa4b1be7f",
      "code": "class Solution:\n  def minWastedSpace(self, packages: list[int], boxes: list[list[int]]) -> int:\n    ans = math.inf\n\n    packages.sort()\n\n    for box in boxes:\n      box.sort()\n      if box[-1] < packages[-1]:\n        continue\n      accu = 0\n      i = 0\n      for b in box:\n        j = bisect.bisect(packages, b, i)\n        accu += b * (j - i)\n        i = j\n      ans = min(ans, accu)\n\n    return -1 if ans == math.inf else (ans - sum(packages)) % 1_000_000_007",
      "title": "1889. Minimum Space Wasted From Packaging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2432b3a-0603-443a-8432-825719773e23",
      "code": "class Solution:\n  def maxLength(self, ribbons: list[int], k: int) -> int:\n    def isCutPossible(length: int) -> bool:\n      count = 0\n      for ribbon in ribbons:\n        count += ribbon // length\n      return count >= k\n\n    l = 1\n    r = sum(ribbons) // k + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if not isCutPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l - 1",
      "title": "1891. Cutting Ribbons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed9b0810-7e9a-470e-b386-ebd613862191",
      "code": "class Solution:\n  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:\n    seen = [0] * 52\n\n    for l, r in ranges:\n      seen[l] += 1\n      seen[r + 1] -= 1\n\n    for i in range(1, 52):\n      seen[i] += seen[i - 1]\n\n    return all(seen[i] for i in range(left, right + 1))",
      "title": "1893. Check if All the Integers in a Range Are Covered",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed06f17b-2a5c-4ae9-bde4-ed615c8886cb",
      "code": "class Solution:\n  def chalkReplacer(self, chalk: list[int], k: int) -> int:\n    k %= sum(chalk)\n    if k == 0:\n      return 0\n\n    for i, c in enumerate(chalk):\n      k -= c\n      if k < 0:\n        return i",
      "title": "1894. Find the Student that Will Replace the Chalk",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e738ff9f-8318-4eb2-8bf6-98e029472f37",
      "code": "class Solution:\n  def largestMagicSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # prefixRow[i][j] := the sum of the first j numbers in the i-th row\n    prefixRow = [[0] * (n + 1) for _ in range(m)]\n    # prefixCol[i][j] := the sum of the first j numbers in the i-th column\n    prefixCol = [[0] * (m + 1) for _ in range(n)]\n\n    for i in range(m):\n      for j in range(n):\n        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j]\n        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j]\n\n    def isMagicSquare(i: int, j: int, k: int) -> bool:\n      \"\"\"Returns True if grid[i..i + k)[j..j + k) is a magic square.\"\"\"\n      diag, antiDiag = 0, 0\n      for d in range(k):\n        diag += grid[i + d][j + d]\n        antiDiag += grid[i + d][j + k - 1 - d]\n      if diag != antiDiag:\n        return False\n      for d in range(k):\n        if self._getSum(prefixRow, i + d, j, j + k - 1) != diag:\n          return False\n        if self._getSum(prefixCol, j + d, i, i + k - 1) != diag:\n          return False\n      return True\n\n    def containsMagicSquare(k: int) -> bool:\n      \"\"\"Returns True if the grid contains any magic square of size k x k.\"\"\"\n      for i in range(m - k + 1):\n        for j in range(n - k + 1):\n          if isMagicSquare(i, j, k):\n            return True\n      return False\n\n    for k in range(min(m, n), 1, -1):\n      if containsMagicSquare(k):\n        return k\n\n    return 1\n\n  def _getSum(self, prefix: list[list[int]], i: int, l: int, r: int) -> int:\n    \"\"\"Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).\"\"\"\n    return prefix[i][r + 1] - prefix[i][l]",
      "title": "1895. Largest Magic Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f31a2bcf-837f-4a4e-b29a-fa359c2521c4",
      "code": "class Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []  # [(the expression, the cost to toggle the expression)]\n\n    for e in expression:\n      if e in '(&|':\n        # These aren't expressions, so the cost is meaningless.\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()  # Pop '('.\n      else:  # e == '0' or e == '1'\n        # Store the '0' or '1'. The cost to change their values is just 1,\n        # whether it's changing '0' to '1' or '1' to '0'.\n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        # Determine the cost to toggle op(a, b).\n        if op == '&':\n          if a == '0' and b == '0':\n            # Change '&' to '|' and a|b to '1'.\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          else:  # a == '1' and b == '1'\n            # Change a|b to '0'.\n            lastPair = ('1', min(costA, costB))\n        else:  # op == '|'\n          if a == '0' and b == '0':\n            # Change a|b to '1'.\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          else:  # a == '1' and b == '1'\n            # Change '|' to '&' and a|b to '0'.\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]",
      "title": "1896. Minimum Cost to Change the Final Value of Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f55bd222-8a38-40d3-b392-a948aa38ba16",
      "code": "class Solution:\n  def makeEqual(self, words: list[str]) -> bool:\n    return all(c % len(words) == 0\n               for c in collections.Counter(''.join(words)).values())",
      "title": "1897. Redistribute Characters to Make All Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7928337b-01aa-4565-b017-898d156b1028",
      "code": "class Solution:\n  def maximumRemovals(self, s: str, p: str, removable: list[int]) -> int:\n    l = 0\n    r = len(removable) + 1\n\n    def remove(k: int) -> str:\n      removed = [c for c in s]\n      for i in range(k):\n        removed[removable[i]] = '*'\n      return ''.join(removed)\n\n    def isSubsequence(p: str, s: str) -> bool:\n      i = 0\n      for j, c in enumerate(s):\n        if p[i] == s[j]:\n          i += 1\n          if i == len(p):\n            return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      removed = remove(m)\n      if isSubsequence(p, removed):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "1898. Maximum Number of Removable Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a5c39c-2f02-4e43-9bc0-4105072883f1",
      "code": "class Solution:\n  def mergeTriplets(self, triplets: list[list[int]], target: list[int]) -> bool:\n    merged = [0] * len(target)\n\n    for triplet in triplets:\n      if all(a <= b for a, b in zip(triplet, target)):\n        for i in range(3):\n          merged[i] = max(merged[i], triplet[i])\n\n    return merged == target",
      "title": "1899. Merge Triplets to Form Target Triplet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c49a0d7f-af06-43b5-a014-c47c0dd45866",
      "code": "class Solution:\n  def earliestAndLatest(self, n: int,\n                        firstPlayer: int, secondPlayer: int) -> list[int]:\n    @functools.lru_cache(None)\n    def dp(l: int, r: int, k: int) -> list[int]:\n      \"\"\"\n      Returns the (earliest, latest) pair, the first player is the l-th player\n      from the front, the second player is the r-th player from the end, and\n      there're k people.\n      \"\"\"\n      if l == r:\n        return [1, 1]\n      if l > r:\n        return dp(r, l, k)\n\n      a = math.inf\n      b = -math.inf\n\n      # Enumerate all the possible positions.\n      for i in range(1, l + 1):\n        for j in range(l - i + 1, r - i + 1):\n          if not l + r - k // 2 <= i + j <= (k + 1) // 2:\n            continue\n          x, y = dp(i, j, (k + 1) // 2)\n          a = min(a, x + 1)\n          b = max(b, y + 1)\n\n      return [a, b]\n\n    return dp(firstPlayer, n - secondPlayer + 1, n)",
      "title": "1900. The Earliest and Latest Rounds Where Players Compete",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc3b3463-b7d9-4793-9e91-001499736f43",
      "code": "class Solution:\n  def findPeakGrid(self, mat: list[list[int]]) -> list[int]:\n    l = 0\n    r = len(mat) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if max(mat[m]) >= max(mat[m + 1]):\n        r = m\n      else:\n        l = m + 1\n\n    return [l, mat[l].index(max(mat[l]))]",
      "title": "1901. Find a Peak Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4001ec69-0c3d-4c28-85c3-1c50c6e4a4b8",
      "code": "class Solution:\n  def largestOddNumber(self, num: str) -> str:\n    for i, n in reversed(list(enumerate(num))):\n      if int(n) % 2 == 1:\n        return num[:i + 1]\n    return ''",
      "title": "1903. Largest Odd Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6d1f2f9-ddf6-444e-8290-9c48b9a57720",
      "code": "class Solution:\n  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n    start = self._getMinutes(loginTime)\n    finish = self._getMinutes(logoutTime)\n    if start > finish:\n      finish += 60 * 24\n\n    return max(0, finish // 15 - (start + 14) // 15)\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1904. The Number of Full Rounds You Have Played",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0a2912d-be92-41a3-8ade-8cd075d07990",
      "code": "class Solution:\n  def countSubIslands(\n      self,\n      grid1: list[list[int]],\n      grid2: list[list[int]],\n  ) -> int:\n    m = len(grid2)\n    n = len(grid2[0])\n\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 1\n      if grid2[i][j] != 1:\n        return 1\n\n      grid2[i][j] = 2  # Mark 2 as visited.\n\n      return (dfs(i + 1, j) & dfs(i - 1, j) &\n              dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j])\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid2[i][j] == 1:\n          ans += dfs(i, j)\n\n    return ans",
      "title": "1905. Count Sub Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1860b5ab-b682-4d9f-9a22-5a41c581f4a6",
      "code": "class Solution:\n  def minDifference(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans",
      "title": "1906. Minimum Absolute Difference Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8bee80f-4ea9-4296-9d83-3b456d57e310",
      "code": "class Solution:\n  def nimGame(self, piles: list[int]) -> bool:\n    return functools.reduce(operator.xor, piles) > 0",
      "title": "1908. Game of Nim",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb5c6411-4cc9-434a-8b95-2c26a3b60379",
      "code": "class Solution:\n  def canBeIncreasing(self, nums: list[int]) -> bool:\n    removed = False\n\n    for i in range(1, len(nums)):\n      if nums[i - 1] >= nums[i]:\n        if removed:\n          return False\n        removed = True  # Remove nums[i - 1].\n        if i > 1 and nums[i - 2] >= nums[i]:\n          nums[i] = nums[i - 1]  # Remove nums[i] instead.\n\n    return True",
      "title": "1909. Remove One Element to Make the Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52f9aca7-36bc-4276-9978-a2a24275f14f",
      "code": "class Solution:\n  def removeOccurrences(self, s: str, part: str) -> str:\n    n = len(s)\n    k = len(part)\n\n    t = [' '] * n\n    j = 0  # t's index\n\n    for i, c in enumerate(s):\n      t[j] = c\n      j += 1\n      if j >= k and ''.join(t[j - k:j]) == part:\n        j -= k\n\n    return ''.join(t[:j])",
      "title": "1910. Remove All Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e50ddfa-512e-410e-b1f1-ece328c28df8",
      "code": "class Solution:\n  def maxAlternatingSum(self, nums: list[int]) -> int:\n    even = 0  # the maximum alternating sum ending in an even index\n    odd = 0  # the maximum alternating sum ending in an odd index\n\n    for num in nums:\n      even = max(even, odd + num)\n      odd = even - num\n\n    return even",
      "title": "1911. Maximum Alternating Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfbea8d4-89c1-44ee-8e5f-054eee94c7f1",
      "code": "class Solution:\n  def maxProductDifference(self, nums: list[int]) -> int:\n    max1 = -math.inf\n    max2 = -math.inf\n    min1 = math.inf\n    min2 = math.inf\n\n    for num in nums:\n      if num > max1:\n        max2 = max1\n        max1 = num\n      elif num > max2:\n        max2 = num\n      if num < min1:\n        min2 = min1\n        min1 = num\n      elif num < min2:\n        min2 = num\n\n    return max1 * max2 - min1 * min2",
      "title": "1913. Maximum Product Difference Between Two Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "853fa9ec-2670-4853-b3b4-4dc8f5e4d575",
      "code": "class Solution:\n  def rotateGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    t = 0  # the top\n    l = 0  # the left\n    b = m - 1  # the bottom\n    r = n - 1  # the right\n\n    while t < b and l < r:\n      elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4\n      netRotations = k % elementInThisLayer\n      for _ in range(netRotations):\n        topLeft = grid[t][l]\n        for j in range(l, r):\n          grid[t][j] = grid[t][j + 1]\n        for i in range(t, b):\n          grid[i][r] = grid[i + 1][r]\n        for j in range(r, l, - 1):\n          grid[b][j] = grid[b][j - 1]\n        for i in range(b, t, -1):\n          grid[i][l] = grid[i - 1][l]\n        grid[t + 1][l] = topLeft\n      t += 1\n      l += 1\n      b -= 1\n      r -= 1\n\n    return grid",
      "title": "1914. Cyclically Rotating a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9430c9be-6bc0-4f48-a92a-78cf6950fbfc",
      "code": "class Solution:\n  def wonderfulSubstrings(self, word: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    count = [0] * 1024  # the binary prefix count\n    count[0] = 1  # the empty string \"\"\n\n    for c in word:\n      prefix ^= 1 << ord(c) - ord('a')\n      # All the letters occur even number of times.\n      ans += count[prefix]\n      # `c` occurs odd number of times.\n      ans += sum(count[prefix ^ 1 << i] for i in range(10))\n      count[prefix] += 1\n\n    return ans",
      "title": "1915. Number of Wonderful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7b1d389-0e5f-412e-812f-e320447b059c",
      "code": "class Solution:\n  def waysToBuildRooms(self, prevRoom: list[int]) -> int:\n    MOD = 1_000_000_007\n    graph = collections.defaultdict(list)\n\n    for i, prev in enumerate(prevRoom):\n      graph[prev].append(i)\n\n    def dfs(node: int) -> tuple[int, int]:\n      if not graph[node]:\n        return 1, 1\n\n      ans = 1\n      l = 0\n\n      for child in graph[node]:\n        temp, r = dfs(child)\n        ans = (ans * temp * math.comb(l + r, r)) % MOD\n        l += r\n\n      return ans, l + 1\n\n    return dfs(0)[0]",
      "title": "1916. Count Ways to Build Rooms in an Ant Colony",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "766f1363-0ff8-444a-a563-bf3913aa5b21",
      "code": "class Solution:\n  def kthSmallestSubarraySum(self, nums: list[int], k: int) -> int:\n    def numSubarrayLessThan(m: int) -> int:\n      res = 0\n      summ = 0\n      l = 0\n      for r, num in enumerate(nums):\n        summ += num\n        while summ > m:\n          summ -= nums[l]\n          l += 1\n        res += r - l + 1\n      return res\n\n    return bisect.bisect_left(range(sum(nums)), k, key=numSubarrayLessThan)",
      "title": "1918. Kth Smallest Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7760b141-385b-422c-b618-3934c3e79d7c",
      "code": "class Solution:\n  def buildArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n      nums[i] += n * (nums[num] % n)\n\n    for i in range(n):\n      nums[i] //= n\n\n    return nums",
      "title": "1920. Build Array from Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c90bebf5-ccaa-49fe-ba72-bc1ceff918e5",
      "code": "class Solution:\n  def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\n    for i, arrivalTime in enumerate(\n            sorted([(d - 1) // s for d, s in zip(dist, speed)])):\n      if i > arrivalTime:\n        return i\n    return len(dist)",
      "title": "1921. Eliminate Maximum Number of Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f24fe92-fc0b-4326-9347-f1852d119d98",
      "code": "class Solution:\n  def countGoodNumbers(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % MOD",
      "title": "1922. Count Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6f7912d-b250-49e9-846c-66431cec311f",
      "code": "class Solution:\n  def __init__(self):\n    self.BASE = 165_131\n    self.HASH = 8_417_508_174_513\n\n  def longestCommonSubpath(self, n: int, paths: list[list[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: list[list[int]], m: int) -> bool:\n    \"\"\"\n    Returns True if there's a common subpath of length m for all the paths.\n    \"\"\"\n    # Calculate the hash values for subpaths of length m for every path.\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    # Check if there is a common subpath of length m.\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: list[int], m: int) -> set[int]:\n    \"\"\"Returns the hash values for subpaths of length m in the path.\"\"\"\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.BASE + num) % self.HASH\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower %\n                self.HASH + self.HASH) % self.HASH\n      else:\n        maxPower = maxPower * self.BASE % self.HASH\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes",
      "title": "1923. Longest Common Subpath",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12112560-e2fe-482a-88c5-18512a7bfb32",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Point:\n  x: float\n  y: float\n\n\n@dataclass(frozen=True)\nclass Disk:\n  center: Point\n  radius: float\n\n\nclass Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[float]:\n    points = [Point(x, y) for x, y in trees]\n    disk = self._welzl(points, 0, [])\n    return [disk.center.x, disk.center.y, disk.radius]\n\n  def _welzl(\n      self,\n      points: list[Point],\n      i: int,\n      planePoints: list[Point],\n  ) -> Disk:\n    \"\"\"Returns the smallest disk that encloses points[i..n).\n\n    https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm\n    \"\"\"\n    if i == len(points) or len(planePoints) == 3:\n      return self._trivial(planePoints)\n    disk = self._welzl(points, i + 1, planePoints)\n    if self._inside(disk, points[i]):\n      return disk\n    return self._welzl(points, i + 1, planePoints + [points[i]])\n\n  def _trivial(self, planePoints: list[Point]) -> Disk:\n    \"\"\"Returns the smallest disk that encloses `planePoints`.\"\"\"\n    if len(planePoints) == 0:\n      return Disk(Point(0, 0), 0)\n    if len(planePoints) == 1:\n      return Disk(Point(planePoints[0].x, planePoints[0].y), 0)\n    if len(planePoints) == 2:\n      return self._getDisk(planePoints[0], planePoints[1])\n\n    disk01 = self._getDisk(planePoints[0], planePoints[1])\n    if self._inside(disk01, planePoints[2]):\n      return disk01\n\n    disk02 = self._getDisk(planePoints[0], planePoints[2])\n    if self._inside(disk02, planePoints[1]):\n      return disk02\n\n    disk12 = self._getDisk(planePoints[1], planePoints[2])\n    if self._inside(disk12, planePoints[0]):\n      return disk12\n\n    return self._getDiskFromThree(\n        planePoints[0],\n        planePoints[1],\n        planePoints[2])\n\n  def _getDisk(self, A: Point, B: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A and B.\"\"\"\n    x = (A.x + B.x) / 2\n    y = (A.y + B.y) / 2\n    return Disk(Point(x, y), self._distance(A, B) / 2)\n\n  def _getDiskFromThree(self, A: Point, B: Point, C: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A, B, and C.\"\"\"\n    # Calculate midpoints.\n    mAB = Point((A.x + B.x) / 2, (A.y + B.y) / 2)\n    mBC = Point((B.x + C.x) / 2, (B.y + C.y) / 2)\n\n    # Calculate the slopes and the perpendicular slopes.\n    slopeAB = math.inf if B.x == A.x else (B.y - A.y) / (B.x - A.x)\n    slopeBC = math.inf if C.x == B.x else (C.y - B.y) / (C.x - B.x)\n    perpSlopeAB = math.inf if slopeAB == 0 else -1 / slopeAB\n    perpSlopeBC = math.inf if slopeBC == 0 else -1 / slopeBC\n\n    # Calculate the center.\n    x = (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x +\n         mAB.y - mBC.y) / (perpSlopeBC - perpSlopeAB)\n    y = perpSlopeAB * (x - mAB.x) + mAB.y\n    center = Point(x, y)\n    return Disk(center, self._distance(center, A))\n\n  def _inside(self, disk: Disk, point: Point) -> bool:\n    \"\"\"Returns True if the point is inside the disk.\"\"\"\n    return disk.radius > 0 and self._distance(disk.center, point) <= disk.radius\n\n  def _distance(self, A: Point, B: Point) -> float:\n    dx = A.x - B.x\n    dy = A.y - B.y\n    return math.sqrt(dx**2 + dy**2)",
      "title": "1924. Erect the Fence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea69d01b-04d6-4c28-a7df-e6e70266a08b",
      "code": "class Solution:\n  def countTriples(self, n: int) -> int:\n    ans = 0\n    squared = set()\n\n    for i in range(1, n + 1):\n      squared.add(i * i)\n\n    for a in squared:\n      for b in squared:\n        if a + b in squared:\n          ans += 1\n\n    return ans",
      "title": "1925. Count Square Sum Triples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "997e2e92-d0be-49db-816a-22b23cd8fb6a",
      "code": "class Solution:\n  def nearestExit(self, maze: list[list[str]], entrance: list[int]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return step\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1",
      "title": "1926. Nearest Exit from Entrance in Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2df83e94-9d94-4f9f-b403-13be0c8c1706",
      "code": "class Solution:\n  def sumGame(self, num: str) -> bool:\n    n = len(num)\n    ans = 0.0\n\n    def getExpectation(c: str) -> float:\n      return 4.5 if c == '?' else int(c)\n\n    for i in range(n // 2):\n      ans += getExpectation(num[i])\n\n    for i in range(n // 2, n):\n      ans -= getExpectation(num[i])\n\n    return ans != 0.0",
      "title": "1927. Sum Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ade0aae3-49da-40bd-9fd6-30abc6d679e4",
      "code": "class Solution:\n  def minCost(\n      self,\n      maxTime: int,\n      edges: list[list[int]],\n      passingFees: list[int],\n  ) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      maxTime: int,\n      passingFees: list[int],\n  ) -> int:\n    # cost[i] := the minimum cost to reach the i-th city\n    cost = [math.inf] * len(graph)\n    # dist[i] := the minimum time to reach the i-th city\n    dist = [maxTime + 1] * len(graph)\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]  # (cost[u], dist[u], u)\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        # Go from u -> v.\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1",
      "title": "1928. Minimum Cost to Reach Destination in Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0b93c75-a0cd-47dd-91ca-19d9818eac40",
      "code": "class Solution:\n  def getConcatenation(self, nums: list[int]) -> list[int]:\n    return nums * 2",
      "title": "1929. Concatenation of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d231d56-d89b-409b-bb3e-fc50c576c6a5",
      "code": "class Solution:\n  def countPalindromicSubsequence(self, s: str) -> int:\n    ans = 0\n    first = [len(s)] * 26\n    last = [-1] * 26\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      first[index] = min(first[index], i)\n      last[index] = i\n\n    for f, l in zip(first, last):\n      if f < l:\n        ans += len(set(s[f + 1:l]))\n\n    return ans",
      "title": "1930. Unique Length-3 Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a37332b-4275-48fb-ac3a-8066ffea0f4b",
      "code": "class Solution:\n  def colorTheGrid(self, m: int, n: int) -> int:\n    def getColor(mask: int, r: int) -> int:\n      return mask >> r * 2 & 3\n\n    def setColor(mask: int, r: int, color: int) -> int:\n      return mask | color << r * 2\n\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(r: int, c: int, prevColMask: int, currColMask: int) -> int:\n      if c == n:\n        return 1\n      if r == m:\n        return dp(0, c + 1, currColMask, 0)\n\n      ans = 0\n\n      # 1 := red, 2 := green, 3 := blue\n      for color in range(1, 4):\n        if getColor(prevColMask, r) == color:\n          continue\n        if r > 0 and getColor(currColMask, r - 1) == color:\n          continue\n        ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color))\n        ans %= MOD\n\n      return ans\n\n    return dp(0, 0, 0, 0)",
      "title": "1931. Painting a Grid With Three Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d739ceb-dca1-42e8-9ed8-72b513b05637",
      "code": "class Solution:\n  def canMerge(self, trees: list[TreeNode]) -> TreeNode | None:\n    valToNode = {}  # {val: node}\n    count = collections.Counter()  # {val: freq}\n\n    for tree in trees:\n      valToNode[tree.val] = tree\n      count[tree.val] += 1\n      if tree.left:\n        count[tree.left.val] += 1\n      if tree.right:\n        count[tree.right.val] += 1\n\n    def isValidBST(tree: TreeNode | None, minNode: TreeNode | None,\n                   maxNode: TreeNode | None) -> bool:\n      if not tree:\n        return True\n      if minNode and tree.val <= minNode.val:\n        return False\n      if maxNode and tree.val >= maxNode.val:\n        return False\n      if not tree.left and not tree.right and tree.val in valToNode:\n        val = tree.val\n        tree.left = valToNode[val].left\n        tree.right = valToNode[val].right\n        del valToNode[val]\n\n      return isValidBST(\n          tree.left, minNode, tree) and isValidBST(\n          tree.right, tree, maxNode)\n\n    for tree in trees:\n      if count[tree.val] == 1:\n        if isValidBST(tree, None, None) and len(valToNode) <= 1:\n          return tree\n        return None\n\n    return None",
      "title": "1932. Merge BSTs to Create Single BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38355e9a-8b51-4e79-9270-1d1108e10e8e",
      "code": "class Solution:\n  def isDecomposable(self, s: str) -> bool:\n    twos = 0\n\n    for _, group in itertools.groupby(s):\n      groupLength = len(list(group))\n      if groupLength % 3 == 1:\n        return False\n      if groupLength % 3 == 2:\n        twos += 1\n        if twos > 1:\n          return False\n\n    return twos == 1",
      "title": "1933. Check if String Is Decomposable Into Value-Equal Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "180adeeb-fd6e-4b85-aabb-dc1ad66159a9",
      "code": "class Solution:\n  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n    ans = 0\n    broken = set(brokenLetters)\n\n    for word in text.split():\n      ans += all(c not in broken for c in word)\n\n    return ans",
      "title": "1935. Maximum Number of Words You Can Type",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3eb5957-13dc-431f-a507-a23969c98ef2",
      "code": "class Solution:\n  def addRungs(self, rungs: list[int], dist: int) -> int:\n    ans = 0\n    prev = 0\n\n    for rung in rungs:\n      ans += (rung - prev - 1) // dist\n      prev = rung\n\n    return ans",
      "title": "1936. Add Minimum Number of Rungs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6bf3929-c9b2-4a38-9a55-77ce19c0788a",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    n = len(points[0])\n    # dp[j] := the maximum number of points you can have if points[i][j] is the\n    # most recent cell you picked\n    dp = [0] * n\n\n    for row in points:\n      leftToRight = [0] * n\n      runningMax = 0\n      for j in range(n):\n        runningMax = max(runningMax - 1, dp[j])\n        leftToRight[j] = runningMax\n\n      rightToLeft = [0] * n\n      runningMax = 0\n      for j in range(n - 1, - 1, -1):\n        runningMax = max(runningMax - 1, dp[j])\n        rightToLeft[j] = runningMax\n\n      for j in range(n):\n        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]\n\n    return max(dp)",
      "title": "1937. Maximum Number of Points with Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72492095-528f-4f15-a32c-dd1681dfbd80",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.HEIGHT = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(\n      self,\n      parents: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)  # {node: (index, val)}\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      # Answer queries for node\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans",
      "title": "1938. Maximum Genetic Difference Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "800ce8e5-ebc7-427b-bb6a-4d1b5fc63231",
      "code": "class Solution:\n  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:\n    MAX = 100\n    ans = []\n    count = [0] * (MAX + 1)\n\n    for array in arrays:\n      for a in array:\n        count[a] += 1\n        if count[a] == len(arrays):\n          ans.append(a)\n\n    return ans",
      "title": "1940. Longest Common Subsequence Between Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2f611d5-e146-43b6-aec0-1fb9d8402099",
      "code": "class Solution:\n  def areOccurrencesEqual(self, s: str) -> bool:\n    return len(set(collections.Counter(s).values())) == 1",
      "title": "1941. Check if All Characters Have Equal Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c8a5e97-989a-4ef3-9bc5-bd6cd94cc782",
      "code": "class Solution:\n  def smallestChair(self, times: list[list[int]], targetFriend: int) -> int:\n    nextUnsatChair = 0\n    emptyChairs = []\n    occupied = []  # (leaving, chair)\n\n    for i in range(len(times)):\n      times[i].append(i)\n\n    times.sort(key=lambda x: x[0])\n\n    for arrival, leaving, i in times:\n      while len(occupied) > 0 and occupied[0][0] <= arrival:\n        unsatChair = heapq.heappop(occupied)[1]\n        heapq.heappush(emptyChairs, unsatChair)\n      if i == targetFriend:\n        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair\n      if len(emptyChairs) == 0:\n        heapq.heappush(occupied, (leaving, nextUnsatChair))\n        nextUnsatChair += 1\n      else:\n        emptyChair = heapq.heappop(emptyChairs)\n        heapq.heappush(occupied, (leaving, emptyChair))",
      "title": "1942. The Number of the Smallest Unoccupied Chair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb8ca2c6-5ca0-4fb3-89f4-1981c1d5bd51",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def splitPainting(self, segments: list[list[int]]) -> list[list[int]]:\n    ans = []\n    prevIndex = 0\n    runningMix = 0\n    line = SortedDict()\n\n    for start, end, color in segments:\n      line[start] = line.get(start, 0) + color\n      line[end] = line.get(end, 0) - color\n\n    for i, mix in line.items():\n      if runningMix > 0:\n        ans.append([prevIndex, i, runningMix])\n      runningMix += mix\n      prevIndex = i\n\n    return ans",
      "title": "1943. Describe the Painting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d388ef86-18c7-41bd-ba9c-0ae98441be38",
      "code": "class Solution:\n  def canSeePersonsCount(self, heights: list[int]) -> list[int]:\n    ans = [0] * len(heights)\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        ans[stack.pop()] += 1\n      if stack:\n        ans[stack[-1]] += 1\n      stack.append(i)\n\n    return ans",
      "title": "1944. Number of Visible People in a Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58c815c0-dbe6-4d7b-aefa-e3cf8de37cee",
      "code": "class Solution:\n  def getLucky(self, s: str, k: int) -> int:\n    ans = self._convert(s)\n    for _ in range(k):\n      ans = self._getDigitSum(ans)\n    return ans\n\n  def _convert(self, s: str) -> int:\n    return int(''.join(str(ord(c) - ord('a') + 1) for c in s))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1945. Sum of Digits of String After Convert",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df06f7dc-44d0-47f5-8fde-7d999c8ec34a",
      "code": "class Solution:\n  def maximumNumber(self, num: str, change: list[int]) -> str:\n    numList = list(num)\n    mutated = False\n\n    for i, c in enumerate(numList):\n      d = int(c)\n      numlist[i] = chr(ord('0') + max(d, change[d]))\n      if mutated and d > change[d]:\n        return ''.join(numList)\n      if d < change[d]:\n        mutated = True\n\n    return ''.join(numList)",
      "title": "1946. Largest Number After Mutating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0637466-e18b-4786-aceb-f73f41c66028",
      "code": "class Solution:\n  def maxCompatibilitySum(\n      self,\n      students: list[list[int]],\n      mentors: list[list[int]],\n  ) -> int:\n    ans = 0\n\n    def dfs(i: int, scoreSum: int, used: list[bool]) -> None:\n      nonlocal ans\n      if i == len(students):\n        ans = max(ans, scoreSum)\n        return\n\n      for j, mentor in enumerate(mentors):\n        if used[j]:\n          continue\n        used[j] = True  # The `mentors[j]` is used.\n        dfs(i + 1, scoreSum + sum(s == m\n                                  for s, m in zip(students[i], mentor)), used)\n        used[j] = False\n\n    dfs(0, 0, [False] * len(students))\n    return ans",
      "title": "1947. Maximum Compatibility Score Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b790952-b326-4c9b-999a-51d4fb44da7d",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.deleted = False\n\n\nclass Solution:\n  def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n    subtreeToNodes: dict[str, list[TrieNode]] = collections.defaultdict(list)\n\n    # Construct the Trie\n    for path in sorted(paths):\n      node = root\n      for s in path:\n        node = node.children.setdefault(s, TrieNode())\n\n    # For each subtree, fill in the {subtree encoding: [root]} hash table\n    def buildSubtreeToRoots(node: TrieNode) -> str:\n      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])\n                              for s in node.children) + ')'\n      if subtree != '()':\n        subtreeToNodes[subtree].append(node)\n      return subtree\n\n    buildSubtreeToRoots(root)\n\n    # Mark nodes that should be deleted\n    for nodes in subtreeToNodes.values():\n      if len(nodes) > 1:\n        for node in nodes:\n          node.deleted = True\n\n    # Construct the answer array for nodes that haven't been deleted\n    def constructPath(node: TrieNode, path: list[str]) -> None:\n      for s, child in node.children.items():\n        if not child.deleted:\n          constructPath(child, path + [s])\n      if path:\n        ans.append(path)\n\n    constructPath(root, [])\n    return ans",
      "title": "1948. Delete Duplicate Folders in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "653d9283-3b03-4ff6-b0b9-19cdb47a1734",
      "code": "class Solution:\n  # Similar to 1950. Maximum of Minimum Values in All Subarrays\n  def findMaximums(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    # prevMin[i] := the index k s.t.\n    # nums[k] is the previous minimum in nums[0..n)\n    prevMin = [-1] * n\n    # nextMin[i] := the index k s.t.\n    # nums[k] is the next minimum innums[i + 1..n)\n    nextMin = [n] * n\n    stack = []\n\n    for i, num in enumerate(nums):\n      while stack and nums[stack[-1]] > nums[i]:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    # For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.\n    # nums[i] is the minimum in nums[l..r].\n    # So, the ans[r - l + 1] will be at least nums[i].\n    for num, l, r in zip(nums, prevMin, nextMin):\n      sz = r - l - 1\n      ans[sz - 1] = max(ans[sz - 1], num)\n\n    # ans[i] should always >= ans[i + 1..n).\n    for i in range(n - 2, -1, -1):\n      ans[i] = max(ans[i], ans[i + 1])\n\n    return ans",
      "title": "1950. Maximum of Minimum Values in All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea0b1b5d-f94c-475c-92ce-a0784e855ad4",
      "code": "class Solution:\n  def isThree(self, n: int) -> bool:\n    if n == 1:\n      return False\n    # The numbers with exactly three divisors are perfect squares of a prime\n    # number.\n    root = math.isqrt(n)\n    return (root**2 == n and\n            all(root % i != 0\n                for i in range(2, math.isqrt(root) + 1)))",
      "title": "1952. Three Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5230560a-434e-4c1e-81e4-34493eb12f96",
      "code": "class Solution:\n  def numberOfWeeks(self, milestones: list[int]) -> int:\n    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.\n    summ = sum(milestones)\n    nonMax = summ - max(milestones)\n    return min(summ, 2 * nonMax + 1)",
      "title": "1953. Maximum Number of Weeks for Which You Can Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "764e15c5-b78f-4dd6-9a17-f9c0af6780a7",
      "code": "class Solution:\n  def minimumPerimeter(self, neededApples: int) -> int:\n    def numApples(k: int) -> int:\n      \"\"\"Returns the number of apples at the k-th level.\n\n         k := the level making perimeter = 8k\n      p(k) := the number of apples at the k-th level on the perimeter\n      n(k) := the number of apples at the k-th level not no the perimeter\n\n      p(1) =             1 + 2\n      p(2) =         3 + 2 + 3 + 4\n      p(3) =     5 + 4 + 3 + 4 + 5 + 6\n      p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8\n      p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k\n          = k + 2k^2 + 2*k(k-1)//2\n          = k + 2k^2 + k^2 - k = 3k^2\n\n      n(k) = p(1) + p(2) + p(3) + ... + p(k)\n          = 3*1  + 3*4  + 3*9  + ... + 3*k^2\n          = 3 * (1 + 4 + 9 + ... + k^2)\n          = 3 * k(k+1)(2k+1)//6 = k(k+1)(2k+1)//2\n      So, the number of apples at the k-th level should be\n        k(k+1)(2k+1)//2 * 4 = 2k(k+1)(2k+1)\n      \"\"\"\n      return 2 * k * (k + 1) * (2 * k + 1)\n\n    return bisect.bisect_left(range(100_000), neededApples,\n                              key=numApples) * 8",
      "title": "1954. Minimum Garden Perimeter to Collect Enough Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08c8f110-da32-469e-b328-92d3cf3d16a6",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of increasing subsequences of the first i numbers\n    # that end in j\n    dp = [[0] * 3 for _ in range(n)]\n\n    if nums[0] == 0:\n      dp[0][0] = 1\n\n    for i in range(1, n):\n      for ending in range(3):\n        dp[i][ending] = dp[i - 1][ending]\n\n      if nums[i] == 0:\n        # 1. The number of the previous subsequences that end in 0.\n        # 2. Append a 0 to the previous subsequences that end in 0.\n        # 3. Start a new subsequence from this 0.\n        dp[i][0] = dp[i - 1][0] * 2 + 1\n      elif nums[i] == 1:\n        # 1. The number of the previous subsequences that end in 1.\n        # 2. Append a 1 to the previous subsequences that end in 1.\n        # 3. Append a 1 to the previous subsequences that end in 0.\n        dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0]\n      else:  # nums[i] == 2\n        # 1. The number of the previous subsequences that end in 2.\n        # 2. Append a 2 to the previous subsequences that end in 2.\n        # 3. Append a 2 to the previous subsequences that end in 1.\n        dp[i][2] = dp[i - 1][2] * 2 + dp[i - 1][1]\n\n      for ending in range(3):\n        dp[i][ending] %= MOD\n\n    return dp[-1][2]",
      "title": "1955. Count Number of Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a345ca3f-0bad-47d0-ae5d-5106ac01cf18",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of increasing subsequences of the first i numbers,\n      where the the previous number is j - 1.\n      \"\"\"\n      if i == len(nums):\n        return prev == 2\n\n      res = 0\n\n      # Don't include `nums[i]`.\n      res += dp(i + 1, prev)\n\n      # Include `nums[i]`.\n      if nums[i] == prev:\n        res += dp(i + 1, prev)\n      if prev == -1 and nums[i] == 0:\n        res += dp(i + 1, 0)\n      if prev == 0 and nums[i] == 1:\n        res += dp(i + 1, 1)\n      if prev == 1 and nums[i] == 2:\n        res += dp(i + 1, 2)\n\n      res %= MOD\n      return res\n\n    return dp(0, -1)",
      "title": "1955. Count Number of Special Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59e3526c-5d4e-4aba-a013-9bfe22af9352",
      "code": "class Solution:\n  def minDayskVariants(self, points: list[list[int]], k: int) -> int:\n    MAX = 100\n    ans = math.inf\n\n    for a in range(1, MAX + 1):\n      for b in range(1, MAX + 1):\n        # Stores the k minimum distances of points that can reach (a, b).\n        maxHeap = []\n        for x, y in points:\n          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))\n          if len(maxHeap) > k:\n            heapq.heappop(maxHeap)\n        ans = min(ans, -maxHeap[0])\n\n    return ans",
      "title": "1956. Minimum Time For K Virus Variants to Spread",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa905d19-c167-4b1c-956b-a66f698f6fdb",
      "code": "class Solution:\n  def makeFancyString(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "1957. Delete Characters to Make Fancy String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6823a18-8764-41d5-a6fc-255314d36bf8",
      "code": "class Solution:\n  def checkMove(\n      self,\n      board: list[list[str]],\n      rMove: int,\n      cMove: int,\n      color: str,\n  ) -> bool:\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    for dx, dy in DIRS:\n      cellsCount = 2\n      i = rMove + dx\n      j = cMove + dy\n      while 0 <= i < 8 and 0 <= j < 8:\n        # There are no free cells in between.\n        if board[i][j] == '.':\n          break\n        # Need >= 3 cells.\n        if cellsCount == 2 and board[i][j] == color:\n          break\n        # >= 3 cells.\n        if board[i][j] == color:\n          return True\n        i += dx\n        j += dy\n        cellsCount += 1\n\n    return False",
      "title": "1958. Check if Move is Legal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c13ba775-9e88-490c-97b5-352b4b76027b",
      "code": "class Solution:\n  def minSpaceWastedKResizing(self, nums: list[int], k: int) -> int:\n    MAX = 200_000_000\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum space wasted for nums[i..n) if you can resize k times.\n      \"\"\"\n      if i == len(nums):\n        return 0\n      if k == -1:\n        return MAX\n\n      res = MAX\n      summ = 0\n      maxNum = nums[i]\n\n      for j in range(i, len(nums)):\n        summ += nums[j]\n        maxNum = max(maxNum, nums[j])\n        wasted = maxNum * (j - i + 1) - summ\n        res = min(res, dp(j + 1, k - 1) + wasted)\n\n      return res\n\n    return dp(0, k)",
      "title": "1959. Minimum Total Space Wasted With K Resizing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92315239-2862-4b59-aba5-4c47c475909a",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n    n = len(s)\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hashL[i] = the hash of the first i letters of s, where hashL[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hashL = [0]\n    # hashR[i] = the hash of the last i letters of s, where hashR[i] =\n    # (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % HASH\n    hashR = [0]\n    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    maxLeft = [0] * n\n    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    maxRight = [0] * n\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for _ in range(n):\n      pows.append(pows[-1] * BASE % HASH)\n\n    for c in s:\n      hashL.append((hashL[-1] * BASE + val(c)) % HASH)\n\n    for c in reversed(s):\n      hashR.append((hashR[-1] * BASE + val(c)) % HASH)\n\n    hashR.reverse()\n\n    def getLeftRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the left rolling hash of s[l..r).\"\"\"\n      h = (hashL[r] - hashL[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def getRightRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the right rolling hash of s[l..r).\"\"\"\n      h = (hashR[l] - hashR[r] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True if s[l..r) is a palindrome.\"\"\"\n      return getLeftRollingHash(l, r) == getRightRollingHash(l, r)\n\n    maxLength = 1\n    for r in range(n):\n      l = (r - maxLength - 2) + 1\n      if l >= 0 and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxLeft[r] = maxLength\n\n    maxLength = 1\n    for l in reversed(range(n)):\n      r = (l + maxLength + 2) - 1\n      if r < n and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxRight[l] = maxLength\n\n    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))",
      "title": "1960. Maximum Product of the Length of Two Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f20b7a9-1c4f-4767-8692-8a70d345615f",
      "code": "class Solution:\n  def isPrefixString(self, s: str, words: list[str]) -> bool:\n    prefix = []\n    for word in words:\n      prefix.append(word)\n      if ''.join(prefix) == s:\n        return True\n    return False",
      "title": "1961. Check If String Is a Prefix of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bfad4d-140e-44b2-8f55-826221cc59f3",
      "code": "class Solution:\n  def minStoneSum(self, piles: list[int], k: int) -> int:\n    maxHeap = [-pile for pile in piles]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      heapq.heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)",
      "title": "1962. Remove Stones to Minimize the Total",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c67dc70-7eb4-484b-9a2a-cbae53a0792a",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.\n    # The answer is ceil(# of unmatched pairs // 2).\n    unmatched = 0\n\n    for c in s:\n      if c == '[':\n        unmatched += 1\n      elif unmatched > 0:  # c == ']' and there's a match.\n        unmatched -= 1\n\n    return (unmatched + 1) // 2",
      "title": "1963. Minimum Number of Swaps to Make the String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5593e3a-a9e7-41c8-af7a-a1a3e6a2d258",
      "code": "class Solution:\n  # Similar to 300. Longest Increasing Subsequence\n  def longestObstacleCourseAtEachPosition(\n      self, obstacles: list[int],\n  ) -> list[int]:\n    ans = []\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for obstacle in obstacles:\n      if not tails or obstacle >= tails[-1]:\n        tails.append(obstacle)\n        ans.append(len(tails))\n      else:\n        index = bisect.bisect_right(tails, obstacle)\n        tails[index] = obstacle\n        ans.append(index + 1)\n\n    return ans",
      "title": "1964. Find the Longest Valid Obstacle Course at Each Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f192aa5-c2c5-49c5-801d-d3ac5cd19b1e",
      "code": "class Solution:\n  def binarySearchableNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixMaxs[i] := max(nums[0..i))\n    prefixMaxs = [0] * n\n    # suffixMins[i] := min(nums[i + 1..n))\n    suffixMins = [0] * n\n\n    # Fill in `prefixMaxs`.\n    prefixMaxs[0] = -math.inf\n    for i in range(1, n):\n      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])\n\n    # Fill in `suffixMins`.\n    suffixMins[n - 1] = math.inf\n    for i in range(n - 2, -1, -1):\n      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])\n\n    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))",
      "title": "1966. Binary Searchable Numbers in an Unsorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7daf7933-67d9-48e7-bc7f-9d644b102d78",
      "code": "class Solution:\n  def numOfStrings(self, patterns: list[str], word: str) -> int:\n    return sum(pattern in word for pattern in patterns)",
      "title": "1967. Number of Strings That Appear as Substrings in Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be798264-ec93-481e-adb4-8cbbef59edf0",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    for i in range(1, len(nums), 2):\n      nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums",
      "title": "1968. Array With Elements Not Equal to Average of Neighbors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f4607bf-4090-45cc-9830-dd43650dff4a",
      "code": "class Solution:\n  def minNonZeroProduct(self, p: int) -> int:\n    MOD = 1_000_000_007\n    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].\n    n = 1 << p\n    halfCount = n // 2 - 1\n    return pow(n - 2, halfCount, MOD) * ((n - 1) % MOD) % MOD",
      "title": "1969. Minimum Non-Zero Product of the Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21255b3f-4fd4-4ad6-ba61-d0803c32b7b9",
      "code": "class Solution:\n  def latestDayToCross(self, row: int, col: int, cells: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def canWalk(day: int) -> bool:\n      matrix = [[0] * col for _ in range(row)]\n      for i in range(day):\n        x, y = cells[i]\n        matrix[x - 1][y - 1] = 1\n\n      q = collections.deque()\n\n      for j in range(col):\n        if matrix[0][j] == 0:\n          q.append((0, j))\n          matrix[0][j] = 1\n\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == row or y < 0 or y == col:\n            continue\n          if matrix[x][y] == 1:\n            continue\n          if x == row - 1:\n            return True\n          q.append((x, y))\n          matrix[x][y] = 1\n\n      return False\n\n    ans = 0\n    l = 1\n    r = len(cells) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if canWalk(m):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "1970. Last Day Where You Can Still Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f031f9a-6837-4669-b5b1-4c06542ecfa9",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(\n      self,\n      n: int,\n      edges: list[list[int]],\n      source: int,\n      destination: int,\n  ) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)",
      "title": "1971. Find if Path Exists in Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc3110f5-4051-4a7a-95c7-388cd7e61226",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n\n\nclass Solution:\n  def equalToDescendants(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      return T(root.val + left.summ + right.summ,\n               left.count + right.count +\n               (1 if root.val == left.summ + right.summ else 0))\n\n    return dfs(root).count",
      "title": "1973. Count Nodes Equal to Sum of Descendants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfc4b79b-31a4-4c12-a47b-3cf12fd0096c",
      "code": "class Solution:\n  def minTimeToType(self, word: str) -> int:\n    moves = 0\n    letter = 'a'\n\n    for c in word:\n      diff = abs(ord(c) - ord(letter))\n      moves += min(diff, 26 - diff)\n      letter = c\n\n    return moves + len(word)",
      "title": "1974. Minimum Time to Type Word Using Special Typewriter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed21099-bfb1-46b0-bbc9-5ccafd529dde",
      "code": "class Solution:\n  def maxMatrixSum(self, matrix: list[list[int]]) -> int:\n    absSum = 0\n    minAbs = math.inf\n    # 0 := even number of negatives\n    # 1 := odd number of negatives\n    oddNeg = 0\n\n    for row in matrix:\n      for num in row:\n        absSum += abs(num)\n        minAbs = min(minAbs, abs(num))\n        if num < 0:\n          oddNeg ^= 1\n\n    return absSum - oddNeg * minAbs * 2",
      "title": "1975. Maximum Matrix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "626cdd3a-116a-41b8-a36b-b898bc2be0b4",
      "code": "class Solution:\n  def countPaths(self, n: int, roads: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= MOD\n\n    return ways[dst]",
      "title": "1976. Number of Ways to Arrive at Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1639ae89-8ef7-4c1d-b226-2f50d02fe70b",
      "code": "class Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    MOD = 1_000_000_007\n    n = len(num)\n    # dp[i][k] := the number of possible lists of integers ending in num[i]\n    # with the length of the last number being 1..k\n    dp = [[0] * (n + 1) for _ in range(n)]\n    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= MOD\n        # The last number is num[s..i].\n        s = i - k + 1\n        if num[s] == '0':\n          # the number of possible lists of integers ending in num[i] with the\n          # length of the last number being k\n          continue\n        if s == 0:  # the whole string\n          dp[i][k] += 1\n          continue\n        if s < k:\n          # The length k is not enough, so add the number of possible lists of\n          # integers in num[0..s - 1].\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          # Have enough length k and num[s - k..s - 1] <= num[j..i].\n          dp[i][k] += dp[s - 1][k]\n        else:\n          # Have enough length k but num[s - k..s - 1] > num[j..i].\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % MOD",
      "title": "1977. Number of Ways to Separate Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "682d6112-5f9b-424d-bead-4859187fc4a0",
      "code": "class Solution:\n  def findGCD(self, nums: list[int]) -> int:\n    return math.gcd(min(nums), max(nums))",
      "title": "1979. Find Greatest Common Divisor of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45538726-6845-4b7e-bc93-3ecbc61bda9d",
      "code": "class Solution:\n  def findDifferentBinaryString(self, nums: list[str]) -> str:\n    bitSize = len(nums[0])\n    maxNum = 1 << bitSize\n    numsSet = {int(num, 2) for num in nums}\n\n    for num in range(maxNum):\n      if num not in numsSet:\n        return f'{num:0>{bitSize}b}'",
      "title": "1980. Find Unique Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "daa6f564-cd61-49d1-a46d-64320a8ffefd",
      "code": "class Solution:\n  def minimizeTheDifference(self, mat: list[list[int]], target: int) -> int:\n    minSum = sum(min(row) for row in mat)\n    if minSum >= target:  # No need to consider any larger combination.\n      return minSum - target\n\n    @functools.lru_cache(None)\n    def dp(i: int, summ: int) -> int:\n      if i == len(mat):\n        return abs(summ - target)\n      return min(dp(i + 1, summ + num) for num in mat[i])\n\n    return dp(0, 0)",
      "title": "1981. Minimize the Difference Between Target and Chosen Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a7ec069-09b2-4749-b7f0-fd4054406e3c",
      "code": "class Solution:\n  def recoverArray(self, n: int, sums: list[int]) -> list[int]:\n    def recover(sums: list[int]) -> list[int]:\n      if len(sums) == 1:\n        return []\n\n      count = collections.Counter(sums)\n      # Either num or -num must be in the final array.\n      #  num + sumsExcludingNum = sumsIncludingNum\n      # -num + sumsIncludingNum = sumsExcludingNum\n      num = sums[1] - sums[0]\n      sumsExcludingNum = []\n      sumsIncludingNum = []\n      chooseSumsExcludingNum = True\n\n      for summ in sums:\n        if count[summ] == 0:\n          continue\n        count[summ] -= 1\n        count[summ + num] -= 1\n        sumsExcludingNum.append(summ)\n        sumsIncludingNum.append(summ + num)\n        if summ + num == 0:\n          chooseSumsExcludingNum = False\n\n      # Choose `sumsExludingNum` by default since we want to gradually strip\n      # `num` from each sum in `sums` to have the final array. However, we should\n      # always choose the group of sums with 0 since it's a must-have.\n      return ([num] + recover(sumsExcludingNum) if chooseSumsExcludingNum else\n              [-num] + recover(sumsIncludingNum))\n\n    return recover(sorted(sums))",
      "title": "1982. Find Array Given Subset Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c27e2386-5e49-4d23-9cb5-fbb3edfca941",
      "code": "class Solution:\n  def widestPairOfIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      prefix += num1 - num2\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "1983. Widest Pair of Indices With Equal Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d2ed1d4-de25-4369-9768-4c00c5035b7b",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = nums[k - 1] - nums[0]\n\n    for i in range(k, len(nums)):\n      ans = min(ans, nums[i] - nums[i - k + 1])\n\n    return ans",
      "title": "1984. Minimum Difference Between Highest and Lowest of K Scores",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497c9f01-ecaa-4e51-a538-10959dfe9f27",
      "code": "class Solution:\n  # Similar to 215. Kth Largest Element in an Array\n  def kthLargestNumber(self, nums: list[str], k: int) -> str:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, int(num))\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return str(minHeap[0])",
      "title": "1985. Find the Kth Largest Integer in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54fe099f-47fd-4933-a0bd-997664b8e9fa",
      "code": "class Solution:\n  def minSessions(self, tasks: list[int], sessionTime: int) -> int:\n    # Returns True if we can assign tasks[s..n) to `sessions`. Note that `sessions`\n    # may be occupied by some tasks.\n    def dfs(s: int, sessions: list[int]) -> bool:\n      if s == len(tasks):\n        return True\n\n      for i, session in enumerate(sessions):\n        # Can't assign the tasks[s] to this session.\n        if session + tasks[s] > sessionTime:\n          continue\n        # Assign the tasks[s] to this session.\n        sessions[i] += tasks[s]\n        if dfs(s + 1, sessions):\n          return True\n        # Backtracking.\n        sessions[i] -= tasks[s]\n        # If it's the first time we assign the tasks[s] to this session, then future\n        # `session`s can't satisfy either.\n        if sessions[i] == 0:\n          return False\n\n      return False\n\n    for numSessions in range(1, len(tasks) + 1):\n      if dfs(0, [0] * numSessions):\n        return numSessions",
      "title": "1986. Minimum Number of Work Sessions to Finish the Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce77a476-81a6-414e-992e-a7976d10a699",
      "code": "class Solution:\n  # Similar to 940. Distinct Subsequences II\n  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('0' + i)\n    endsIn = {'0': 0, '1': 0}\n\n    for c in binary:\n      endsIn[c] = sum(endsIn.values()) % MOD\n      # Don't count '0' since we want to avoid the leading zeros case.\n      # However, we can always count '1'.\n      if c == '1':\n        endsIn['1'] += 1\n\n    # Count '0' in the end.\n    return (sum(endsIn.values()) + ('0' in binary)) % MOD",
      "title": "1987. Number of Unique Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3337edf8-1bc7-4479-8b30-cad4ef4dac26",
      "code": "class Solution:\n  def catchMaximumAmountofPeople(self, team: list[int], dist: int) -> int:\n    ans = 0\n    i = 0  # 0s index\n    j = 0  # 1s index\n\n    while i < len(team) and j < len(team):\n      if i + dist < j or team[i] != 0:\n        # Find the next 0 that can be caught by 1.\n        i += 1\n      elif j + dist < i or team[j] != 1:\n        # Find the next 1 that can catch 0.\n        j += 1\n      else:\n        # team[j] catches team[i], so move both.\n        ans += 1\n        i += 1\n        j += 1\n\n    return ans",
      "title": "1989. Maximum Number of People That Can Be Caught in Tag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56e226e1-9659-44fd-a9b2-aa83ffa1b6f9",
      "code": "class Solution:\n  def findMiddleIndex(self, nums: list[int]) -> int:\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      suffix -= num\n      if prefix == suffix:\n        return i\n      prefix += num\n\n    return -1",
      "title": "1991. Find the Middle Index in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df26fa86-1e93-43a4-b9dd-1e2cb7d66a78",
      "code": "class Solution:\n  def findFarmland(self, land: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(i: int, j: int, cell: list[int]) -> None:\n      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):\n        return\n      if land[i][j] != 1:\n        return\n      land[i][j] = 2  # Mark as visited.\n      cell[0] = max(cell[0], i)\n      cell[1] = max(cell[1], j)\n      dfs(i + 1, j, cell)\n      dfs(i, j + 1, cell)\n\n    for i in range(len(land)):\n      for j in range(len(land[0])):\n        if land[i][j] == 1:\n          cell = [i, j]\n          dfs(i, j, cell)\n          ans.append([i, j, *cell])\n\n    return ans",
      "title": "1992. Find All Groups of Farmland",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12e2674d-ffa6-47a7-adb7-a160c0f53440",
      "code": "class Solution:\n  def numberOfGoodSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    # dp[i] := the number of good subsets with set of primes = i bit mask\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = sum(1 << i\n                          for i, prime in enumerate(primes)\n                          if num % prime == 0)\n      for primesMask in range(n):\n        # Skip since there're commen set of primes (becomes invalid subset)\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= MOD\n\n    return (1 << count[1]) * sum(dp[1:]) % MOD",
      "title": "1994. The Number of Good Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d30c4ca-d8b3-4948-a0b0-ab6c2cb6e226",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    count = collections.Counter()\n\n    #    nums[a] + nums[b] + nums[c] == nums[d]\n    # => nums[a] + nums[b] == nums[d] - nums[c]\n    for b in range(n - 1, 0, -1):  # `b` also represents `c`.\n      for a in range(b - 1, -1, -1):\n        ans += count[nums[a] + nums[b]]\n      for d in range(n - 1, b, -1):\n        count[nums[d] - nums[b]] += 1  # b := c\n\n    return ans",
      "title": "1995. Count Special Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4804ebd1-645a-4ed1-8963-39c8aa9c14af",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    return sum(nums[a] + nums[b] + nums[c] == nums[d]\n               for a in range(n)\n               for b in range(a + 1, n)\n               for c in range(b + 1, n)\n               for d in range(c + 1, n))",
      "title": "1995. Count Special Quadruplets_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}