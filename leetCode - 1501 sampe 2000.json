{
  "snippets": [
    {
      "id": "ef098916-8349-480b-b7b8-82c766619c74",
      "code": "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans",
      "title": "1996. The Number of Weak Characters in the Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9df1b5a-8666-4212-aa83-20c674cdb190",
      "code": "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]",
      "title": "1997. First Day Where You Have Been in All the Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ad90b94-d463-459f-9528-00e357ef422a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "1998. GCD Sort of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b4562bf-bdb8-44cb-9310-d64759ce2359",
      "code": "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1",
      "title": "1999. Smallest Greater Multiple Made of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c3e45b4-084b-4436-ac92-dfe44ed4893f",
      "code": "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]",
      "title": "2000. Reverse Prefix of Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b313c13c-be02-4574-ab44-7d1c2ad40920",
      "code": "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())",
      "title": "2001. Number of Pairs of Interchangeable Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79b29bf9-374c-47fd-8f6b-c3469bb6223a",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans",
      "title": "2002. Maximum Product of the Length of Two Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fb713c8-8239-41e4-8d5c-4d3b2d3d510f",
      "code": "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans",
      "title": "2003. Smallest Missing Genetic Value in Each Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c7af4f1-da6b-450d-afe4-d050105fd188",
      "code": "class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1",
      "title": "2005. Subtree Removal Game with Fibonacci Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54894514-ee26-4b2c-8f89-bbf4bb39615e",
      "code": "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))",
      "title": "2006. Count Number of Pairs With Absolute Difference K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2175c070-0479-4a27-923e-2c361e8324be",
      "code": "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans",
      "title": "2007. Find Original Array From Doubled Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d69a4f1-ca13-40d9-a565-b06d86d5a83f",
      "code": "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]",
      "title": "2008. Maximum Earnings From Taxi",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d0564f3-be33-49ba-9221-691e4f70a365",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans",
      "title": "2009. Minimum Number of Operations to Make Array Continuous",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93b66ef5-dd07-4abd-8a24-e56492ba9781",
      "code": "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)",
      "title": "2011. Final Value of Variable After Performing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a958272c-cc31-4d62-b57e-27d20625de9c",
      "code": "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans",
      "title": "2012. Sum of Beauty in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e64ec223-ef29-4cf4-9191-f139576b12a7",
      "code": "class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans",
      "title": "2014. Longest Subsequence Repeated k Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "589b212a-8752-4c6c-bc49-401e0a513c9f",
      "code": "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans",
      "title": "2015. Average Height of Buildings in Each Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d058f62a-4a5a-4769-9e0b-94302f7c1289",
      "code": "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans",
      "title": "2016. Maximum Difference Between Increasing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71e91629-61b7-458c-9e4a-3e3b3d410874",
      "code": "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans",
      "title": "2017. Grid Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03dfec7a-8470-47e7-9721-29be5dc28414",
      "code": "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False",
      "title": "2018. Check if Word Can Be Placed In Crossword",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "560a87bd-57d1-4903-b66a-969ac5b673f4",
      "code": "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans",
      "title": "2019. The Score of Students Solving Math Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2834e333-7888-4d69-a4e8-252e5942259b",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans",
      "title": "2021. Brightest Position on Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3c0cb8d-c3fe-4069-9223-ba0325171661",
      "code": "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans",
      "title": "2022. Convert 1D Array Into 2D Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e5d4c34-5097-4375-957c-fe577ee4924b",
      "code": "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans",
      "title": "2023. Number of Pairs of Strings With Concatenation Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b68e7bf2-f256-406f-a407-9338a5d3eb61",
      "code": "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2024. Maximize the Confusion of an Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f317fa-4912-442d-8a16-e5afae0d9dbe",
      "code": "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans",
      "title": "2025. Maximum Number of Ways to Partition an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6baa86db-3ae3-4d5c-831b-8a52ccb15145",
      "code": "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans",
      "title": "2027. Minimum Moves to Convert String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50306b2-cef8-4fb9-a401-b785e1776194",
      "code": "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans",
      "title": "2028. Find Missing Observations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c6e3421-4df1-49e3-b5f6-b18d16144dc9",
      "code": "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2",
      "title": "2029. Stone Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f262a08-9c7c-4527-b335-f63eaed0b088",
      "code": "class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)",
      "title": "2030. Smallest K-Length Subsequence With Occurrences of a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "515a5e68-e45e-44ca-ae80-67c737fd50e7",
      "code": "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans",
      "title": "2031. Count Subarrays With More Ones Than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce771de1-aa45-4377-aeb6-ab0cd8f80de3",
      "code": "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]",
      "title": "2032. Two Out of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d052f1c9-8b69-4001-af5f-6d7b44b79d88",
      "code": "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans",
      "title": "2033. Minimum Operations to Make a Uni-Value Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b38e567a-0508-4084-81d6-0f3ae02ce34a",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans",
      "title": "2035. Partition Array Into Two Arrays to Minimize Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d005418-dcdd-4409-9a4c-8132aa261d44",
      "code": "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans",
      "title": "2036. Maximum Alternating Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3c276e4-03fd-4718-a738-e144428df892",
      "code": "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))",
      "title": "2037. Minimum Number of Moves to Seat Everyone",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a50c0b0-b026-4918-9a79-d30acbeece01",
      "code": "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB",
      "title": "2038. Remove Colored Pieces if Both Neighbors are the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78c81c16-d9f3-43e7-9447-a7181a7139f1",
      "code": "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1",
      "title": "2039. The Time When the Network Becomes Idle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "073a507b-561f-46f2-b075-694eb2366e24",
      "code": "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l",
      "title": "2040. Kth Smallest Product of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33d502dd-985b-4718-8cdf-406e5896fdd9",
      "code": "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True",
      "title": "2042. Check if Numbers Are Ascending in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01704bdc-0634-4066-9da6-f9b577a6603c",
      "code": "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans",
      "title": "2044. Count Number of Maximum Bitwise-OR Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c86802a-4cd1-40b8-8316-a0b25ec2badd",
      "code": "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))",
      "title": "2045. Second Minimum Time to Reach Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22cf5be5-9df1-4c95-ac15-50f42aeb74a0",
      "code": "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head",
      "title": "2046. Sort Linked List Already Sorted Using Absolute Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2190dcc-042b-44e2-b256-5857c0b4183e",
      "code": "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())",
      "title": "2047. Number of Valid Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e64115fb-b96d-45bd-80d6-f1feb68e0843",
      "code": "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n",
      "title": "2048. Next Greater Numerically Balanced Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac6a759f-7af6-4491-b45e-5ca2b6881c76",
      "code": "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans",
      "title": "2049. Count Nodes With the Highest Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "449cbd2d-2417-48e1-8051-5b63f7da334b",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)",
      "title": "2050. Parallel Courses III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a28a5d16-925c-479f-a114-54d6b0c99200",
      "code": "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])",
      "title": "2052. Minimum Cost to Separate Sentence Into Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8efe0cf-fdc5-4045-adef-a0d34262e7dc",
      "code": "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''",
      "title": "2053. Kth Distinct String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09ef80b1-cb5c-4bef-ae16-2259e0ae226e",
      "code": "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans",
      "title": "2054. Two Best Non-Overlapping Events",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ea13373-a522-414b-b85a-6409da31f76d",
      "code": "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans",
      "title": "2055. Plates Between Candles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09c861c7-b841-4d46-bd31-57a4eca365a8",
      "code": "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)",
      "title": "2056. Number of Valid Move Combinations On Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6f77c46-3d26-4445-be3b-a9ab6bcbcaa6",
      "code": "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)",
      "title": "2057. Smallest Index With Equal Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7662719-a332-430e-925c-50921f53a4fc",
      "code": "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]",
      "title": "2058. Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84d36f8c-5f1b-43e2-aeab-98c3cf97c9fa",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1",
      "title": "2059. Minimum Operations to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4acefac-e767-4628-a385-45d8582a07a6",
      "code": "class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)",
      "title": "2060. Check if an Original String Exists Given Two Encoded Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a2bba84-6e9e-4196-b116-76d765e44bb0",
      "code": "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))",
      "title": "2061. Number of Spaces Cleaning Robot Cleaned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d389aee8-cb43-434a-bb97-234476492ca7",
      "code": "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)",
      "title": "2062. Count Vowel Substrings of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c928a84-650b-4f4b-af5c-15635fd89651",
      "code": "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)",
      "title": "2063. Vowels of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f35a05d-e33a-4bc4-8c7b-f14c8a14c739",
      "code": "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2064. Minimized Maximum of Products Distributed to Any Store",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbc631a6-dc28-4110-8098-46f6955dad66",
      "code": "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans",
      "title": "2065. Maximum Path Quality of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6108e62-affa-4391-8e8b-1c7d03ed22b2",
      "code": "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans",
      "title": "2067. Number of Equal Count Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05285f44-1ab7-48a5-a194-01d68ac85050",
      "code": "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())",
      "title": "2068. Check Whether Two Strings are Almost Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0530b5aa-a6f9-41a9-922b-54570436f692",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]",
      "title": "2070. Most Beautiful Item for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "114d06ba-a472-4698-bd02-7268382020c1",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "2071. Maximum Number of Tasks You Can Assign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "873050a9-5c6b-4f85-a2c9-190fdd7af4a2",
      "code": "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans",
      "title": "2073. Time Needed to Buy Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f48a0e91-2a45-40c6-a962-9b154d56bba7",
      "code": "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next",
      "title": "2074. Reverse Nodes in Even Length Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8364449b-6773-486c-802d-81a34aa1f247",
      "code": "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()",
      "title": "2075. Decode the Slanted Ciphertext",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d257a0e-d0d4-4886-99ca-d5e21c9b2499",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans",
      "title": "2076. Process Restricted Friend Requests",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc02f1c9-b4cf-4dd6-aabf-5a71f49b679e",
      "code": "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3",
      "title": "2077. Paths in Maze That Lead to Same Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9c8a1dd-7af9-4683-815c-75f01686106c",
      "code": "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)",
      "title": "2078. Two Furthest Houses With Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d489a4bf-1e02-4dbd-a19c-77d988abd245",
      "code": "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)",
      "title": "2079. Watering Plants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c69d58b-ab1e-46d6-9d51-622c2ce1e3a4",
      "code": "class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans",
      "title": "2081. Sum of k-Mirror Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09af3711-93e9-46f8-a2e0-bdf9787692b6",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans",
      "title": "2083. Substrings That Begin and End With the Same Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65399d62-ca43-45f5-a5aa-6e08930845e5",
      "code": "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())",
      "title": "2085. Count Common Words With One Occurrence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b230e5c4-2ff1-4954-b50d-ce098015116b",
      "code": "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')",
      "title": "2086. Minimum Number of Buckets Required to Collect Rainwater from Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0492746b-6eca-4abf-a11f-f08f7fe8040c",
      "code": "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans",
      "title": "2087. Minimum Cost Homecoming of a Robot in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75c37314-8112-4198-92b2-d39e9143c4bf",
      "code": "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)",
      "title": "2088. Count Fertile Pyramids in a Land",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5efb651-4128-4adb-b535-1991f054c6f0",
      "code": "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]",
      "title": "2089. Find Target Indices After Sorting Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6419fe1a-eeb7-40cd-b71f-7ccf3375b17d",
      "code": "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans",
      "title": "2090. K Radius Subarray Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6debc861-3d0c-4b65-94cc-b22a5c34f504",
      "code": "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)",
      "title": "2091. Removing Minimum and Maximum From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cfec42d-659b-4842-b23e-3f93f2c54ef7",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]",
      "title": "2092. Find All People With Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01873c6d-fa84-467b-b30e-ba13a664b82e",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1",
      "title": "2093. Minimum Cost to Reach City With Discounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96a84494-05ec-4d94-86f2-2ae229065aaf",
      "code": "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans",
      "title": "2094. Finding 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c40e590a-2785-4533-b710-541349974058",
      "code": "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next",
      "title": "2095. Delete the Middle Node of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64566f86-fad1-4103-bbb4-30c253c46402",
      "code": "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8946bce-4329-4dc6-afab-f22922f5c82c",
      "code": "class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]",
      "title": "2097. Valid Arrangement of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbf5de12-1625-4dc2-b42f-57fbb00fda9c",
      "code": "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans",
      "title": "2098. Subsequence of Size K With the Largest Even Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2cc7973-c62d-4cbe-a199-538cd94a696f",
      "code": "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans",
      "title": "2099. Find Subsequence of Length K With the Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbfd6c47-892e-47c4-b1ff-b0759068cdbd",
      "code": "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]",
      "title": "2100. Find Good Days to Rob the Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "168cc401-38cf-44dc-a699-270ec165a6a6",
      "code": "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans",
      "title": "2101. Detonate the Maximum Bombs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "729c7a90-a587-41a4-bc49-60756b31db09",
      "code": "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)",
      "title": "2103. Rings and Rods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5149b8b1-82df-48e5-b740-27bad00e50f7",
      "code": "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "2104. Sum of Subarray Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4794836-29d7-4477-a6ea-e3b80cc270a4",
      "code": "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])",
      "title": "2105. Watering Plants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14b9f6f3-ceca-47de-a73d-f6e2efa33d04",
      "code": "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans",
      "title": "2106. Maximum Fruits Harvested After at Most K Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8d1ceb6-2047-4498-9bf2-4edb6150b04c",
      "code": "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans",
      "title": "2107. Number of Unique Flavors After Sharing K Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6de6ab8b-b23d-4809-8eda-df524e10a900",
      "code": "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')",
      "title": "2108. Find First Palindromic String in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef182e62-c93a-4d99-b2c6-c9f0f016298d",
      "code": "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)",
      "title": "2109. Adding Spaces to a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "318513bd-7394-4633-ab49-839e9624642b",
      "code": "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans",
      "title": "2110. Number of Smooth Descent Periods of a Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18d33553-7c63-497e-9178-8074ea96363f",
      "code": "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))",
      "title": "2111. Minimum Operations to Make the Array K-Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7f025f4-87e8-4648-8c8b-36970138c6bf",
      "code": "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]",
      "title": "2113. Elements in Array After Removing and Replacing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60a84db5-576e-4951-99be-0e4b2ded9793",
      "code": "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1",
      "title": "2114. Maximum Number of Words Found in Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e498e215-1b7b-4170-a569-3ee0d5ae0e4b",
      "code": "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans",
      "title": "2115. Find All Possible Recipes from Given Supplies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a14b8e59-e3ab-423e-99b6-e3d821b665e1",
      "code": "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)",
      "title": "2116. Check if a Parentheses String Can Be Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c29f6fda-3d27-4d7a-a4ad-d4c7387b462f",
      "code": "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)",
      "title": "2117. Abbreviating the Product of a Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cbde29c-9e79-4b9d-ba9e-3d18ae3b2f5f",
      "code": "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num",
      "title": "2119. A Number After a Double Reversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "975cdbb0-5316-4fbb-ae28-47d24b3ca118",
      "code": "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans",
      "title": "2120. Execution of All Suffix Instructions Staying in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edfdb930-ba6b-4652-ae5d-f6fa09ed76a4",
      "code": "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]",
      "title": "2121. Intervals Between Identical Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2df4b549-e8f9-45fc-84df-b2d143e2cd75",
      "code": "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr",
      "title": "2122. Recover the Original Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea30bfa7-8e0a-47b5-9c37-4bc02286f6ef",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans",
      "title": "2123. Minimum Operations to Remove Adjacent Ones in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4b20665-0204-4337-9763-a30d8602b393",
      "code": "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s",
      "title": "2124. Check if All A's Appears Before All B's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de01d2fc-aaba-4e6e-8a99-40eab86dbe57",
      "code": "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans",
      "title": "2125. Number of Laser Beams in a Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ab91a88-b681-49e9-9f4f-4e7c23e32c00",
      "code": "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True",
      "title": "2126. Destroying Asteroids",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9575a75e-46ed-44b2-b2f3-acd29fe3aa5f",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)",
      "title": "2127. Maximum Employees to Be Invited to a Meeting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74491883-59a2-446f-bd1e-16c09bd57308",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)",
      "title": "2128. Remove All Ones With Row and Column Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d76b0cdd-40ce-4217-a79a-cb9d3f284c72",
      "code": "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())",
      "title": "2129. Capitalize the Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b067ba9-d13d-4035-91cc-5ab00664ea83",
      "code": "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans",
      "title": "2130. Maximum Twin Sum of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7308ca8-10fa-447d-b272-12ebc5c116e7",
      "code": "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans",
      "title": "2131. Longest Palindrome by Concatenating Two Letter Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "866d64b4-7b8f-4467-9bc5-73bd6de67d6b",
      "code": "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True",
      "title": "2132. Stamping the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba33a83f-f4a2-4750-865d-02e3685f70ad",
      "code": "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))",
      "title": "2133. Check if Every Row and Column Contains All Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1160fe5-23af-44bd-bf8a-15fe4fcdcc98",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "2134. Minimum Swaps to Group All 1's Together II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b471bc0a-5391-4d76-aaef-858564e56d1f",
      "code": "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans",
      "title": "2135. Count Words Obtained After Adding a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd6b3c98-91d1-45aa-b8e5-f04e819d5d5a",
      "code": "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans",
      "title": "2136. Earliest Possible Day of Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44c693e7-78d5-49d6-8c4d-87ccb4953ecd",
      "code": "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "2137. Pour Water Between Buckets to Make Water Levels Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5f517ab-b544-4d71-9b71-4514e90e79eb",
      "code": "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]",
      "title": "2138. Divide a String Into Groups of Size k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "710edc73-892e-48da-a6de-38cf7db6c080",
      "code": "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1",
      "title": "2139. Minimum Moves to Reach Target Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2dc95ac-a8b3-494b-9caf-1cd285fb25d3",
      "code": "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]",
      "title": "2140. Solving Questions With Brainpower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a180341-21f1-4a4f-9097-89c57e238e51",
      "code": "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n",
      "title": "2141. Maximum Running Time of N Computers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4c04d22-fee8-468a-baa9-a609b99b6f7e",
      "code": "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans",
      "title": "2143. Choose Numbers From Two Arrays in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1571f466-54f9-419e-938a-6db881327a5e",
      "code": "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])",
      "title": "2144. Minimum Cost of Buying Candies With Discount",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7432894-79ab-4abf-a9c8-f1fa2b1a8747",
      "code": "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)",
      "title": "2145. Count the Hidden Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1302e12c-c5d7-402f-b7a1-7f841e651dd0",
      "code": "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans",
      "title": "2146. K Highest Ranked Items Within a Price Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1f20339-4530-40a3-ae0b-d5444aeceed8",
      "code": "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0",
      "title": "2147. Number of Ways to Divide a Long Corridor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc33d117-4ce7-4f39-b4a7-6bb6d3a92103",
      "code": "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)",
      "title": "2148. Count Elements With Strictly Smaller and Greater Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b507731-418c-494c-b14a-7b5262ecf952",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans",
      "title": "2149. Rearrange Array Elements by Sign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58f5b9be-ab62-42ba-8f21-0c042deac302",
      "code": "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]",
      "title": "2150. Find All Lonely Numbers in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f29b2c4f-13c6-4cc6-88e6-7f174fa97134",
      "code": "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans",
      "title": "2151. Maximum Good People Based on Statements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cca356c-2837-4146-9153-4d9548290edb",
      "code": "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)",
      "title": "2152. Minimum Number of Lines to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdf082c5-55c1-42bd-abc6-a8309edfda49",
      "code": "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original",
      "title": "2154. Keep Multiplying Found Values by Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b38f1c41-a03b-4d76-963b-eaeb7892af23",
      "code": "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans",
      "title": "2155. All Divisions With the Highest Score of a Binary Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37901677-da12-434f-a6b2-c5df8a0c52bb",
      "code": "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]",
      "title": "2156. Find Substring With Given Hash Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "becd6ae0-8ab7-4a26-94cd-f5bcefad6e62",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]",
      "title": "2157. Groups of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a37cda16-8bfe-456e-bdc6-09e25c4a2ab0",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans",
      "title": "2158. Amount of New Area Painted Each Day",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a31b60dd-52b3-4699-a3d9-d4470c30e733",
      "code": "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])",
      "title": "2160. Minimum Sum of Four Digit Number After Splitting Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "739e5501-2006-4293-8194-3a278f4cc6c0",
      "code": "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])",
      "title": "2161. Partition Array According to Given Pivot",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78069c9f-dc42-48f0-8ee4-6222827b9195",
      "code": "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans",
      "title": "2162. Minimum Cost to Set Cooking Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a0cb5e9-307c-426d-ac80-7c0c9db087fe",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans",
      "title": "2163. Minimum Difference in Sums After Removal of Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d2c652b-ec80-4352-8045-85dd07aa466b",
      "code": "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans",
      "title": "2164. Sort Even and Odd Indices Independently",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05fca85f-e97e-4e5b-8495-53e294fe01f9",
      "code": "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)",
      "title": "2165. Smallest Value of the Rearranged Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26a371d4-69a3-4a97-a439-2fc7fc364571",
      "code": "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)",
      "title": "2167. Minimum Time to Remove All Cars Containing Illegal Goods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18870619-3323-421b-854e-0c56339dbee8",
      "code": "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())",
      "title": "2168. Unique Substrings With Equal Digit Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fb4bf00-1ab2-45b7-8797-10eff654639f",
      "code": "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans",
      "title": "2169. Count Operations to Obtain Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa5d14c7-91d5-49cb-9dd3-ed0cd2d792ee",
      "code": "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)",
      "title": "2170. Minimum Operations to Make the Array Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4840cc42-33f6-4ec6-82c6-187be2218fab",
      "code": "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))",
      "title": "2171. Removing Minimum Number of Magic Beans",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f85eb8f5-c16c-4cc8-9cb9-53a354c34cce",
      "code": "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]",
      "title": "2172. Maximum AND Sum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98883366-7fd7-434d-a1fc-13eff4fec812",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            newMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              newMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              newMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(newMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded",
      "title": "2174. Remove All Ones With Row and Column Flips II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a437f98-17e8-461f-ab98-98d64583b8b6",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans",
      "title": "2176. Count Equal and Divisible Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5021ba90-a323-42b6-b182-fce2ccefef5d",
      "code": "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]",
      "title": "2177. Find Three Consecutive Integers That Sum to a Given Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28d851aa-3de3-4bbc-8971-f3e580f4c7bc",
      "code": "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]",
      "title": "2178. Maximum Split of Positive Even Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab658da1-df64-4502-bb6e-139e0ea4664c",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))",
      "title": "2179. Count Good Triplets in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d263f39a-5cba-49f5-8c40-4a1ab3418abe",
      "code": "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2180. Count Integers With Even Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc5bfa50-7644-46a0-bd4e-4adfcd6b5473",
      "code": "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next",
      "title": "2181. Merge Nodes in Between Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86af2198-3869-4389-8ccc-c7c05fcf7d3a",
      "code": "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '",
      "title": "2182. Construct String With Repeat Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c444e9-3d28-4c75-935a-859e2a64f1da",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans",
      "title": "2183. Count Array Pairs Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bef46fc2-0679-4e41-8b1b-bb334ef8a582",
      "code": "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)",
      "title": "2184. Number of Ways to Build Sturdy Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d856523f-3c3d-475c-b36e-506a37ae4e55",
      "code": "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)",
      "title": "2185. Counting Words With a Given Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84a40828-0a6a-4489-b56c-d62f37751d9e",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])",
      "title": "2186. Minimum Number of Steps to Make Two Strings Anagram II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28333bd6-d62c-40a8-bec1-2a3887da34ad",
      "code": "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2187. Minimum Time to Complete Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93a5f4d8-96e8-4986-aa8a-b42546e3cf6b",
      "code": "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime",
      "title": "2188. Minimum Time to Finish the Race",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8e5fc56-0def-4f46-a784-fa8ccdb94998",
      "code": "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]",
      "title": "2189. Number of Ways to Build House of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b44805d6-4fee-4b02-9b25-8d9b1a25f64b",
      "code": "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])",
      "title": "2190. Most Frequent Number Following Key In an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b1a5355-e30b-453d-bcf5-004b64b3d3bc",
      "code": "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]",
      "title": "2191. Sort the Jumbled Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae3e4c20-c7ec-4719-8e4e-30f72075dfee",
      "code": "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]",
      "title": "2192. All Ancestors of a Node in a Directed Acyclic Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc825ecb-0375-4e19-a77e-d008bf9f17fa",
      "code": "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans",
      "title": "2193. Minimum Number of Moves to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f1095d8-dcbc-4620-83fc-a01aa2ce9221",
      "code": "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans",
      "title": "2194. Cells in a Range on an Excel Sheet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee356de3-b4cb-4987-93cb-729b67f7091e",
      "code": "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans",
      "title": "2195. Append K Integers With Minimal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12d5c265-32d9-45bd-b5bc-5e25f64f733f",
      "code": "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]",
      "title": "2196. Create Binary Tree From Descriptions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60e58784-bc53-4be6-ae4b-23ad4fac93cf",
      "code": "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans",
      "title": "2197. Replace Non-Coprime Numbers in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73b3d304-799c-41e0-b8d1-73f532b7be83",
      "code": "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6",
      "title": "2198. Number of Single Divisor Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c895ea6-b771-457f-83e7-dfc97bfe4fa3",
      "code": "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans",
      "title": "2200. Find All K-Distant Indices in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54a17ac1-9373-4bda-b964-85813d3af9d5",
      "code": "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)",
      "title": "2201. Count Artifacts That Can Be Extracted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd0536ef-75bf-483d-adea-ad964117caed",
      "code": "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])",
      "title": "2202. Maximize the Topmost Element After K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04023637-304d-4617-8607-b865e805f624",
      "code": "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2203. Minimum Weighted Subgraph With the Required Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59becccf-649d-4e9c-924a-e70dbc652a91",
      "code": "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans",
      "title": "2204. Distance to a Cycle in Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ef15268-96c4-43f4-b42b-9557cbd25911",
      "code": "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())",
      "title": "2206. Divide Array Into Equal Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d10fab41-8db9-489d-bcd3-3ba12749c6c6",
      "code": "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)",
      "title": "2207. Maximize Number of Subsequences in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f19a1bc-61b2-4efd-8452-c2f6bee066b6",
      "code": "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans",
      "title": "2208. Minimum Operations to Halve Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be1a4a6d-37f7-44d1-8a14-d5b56382547a",
      "code": "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]",
      "title": "2209. Minimum White Tiles After Covering With Carpets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e545b750-cbff-4202-9bc9-a2b6c5597534",
      "code": "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans",
      "title": "2210. Count Hills and Valleys in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67cc7214-e48a-4660-86fa-76050714d276",
      "code": "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])",
      "title": "2211. Count Collisions on a Road",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05ba2fe0-2d9b-499d-9cb7-d75474aacf6a",
      "code": "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)",
      "title": "2212. Maximum Points in an Archery Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23934956-dc22-4eef-b02a-4e4bc25d6b62",
      "code": "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)",
      "title": "2214. Minimum Health to Beat Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43ca63d1-2641-491f-898c-354401f5c5ac",
      "code": "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]",
      "title": "2215. Find the Difference of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f51a6656-df61-4349-833c-61ada66afea8",
      "code": "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)",
      "title": "2216. Minimum Deletions to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf994b2c-1d41-48ef-b519-1c1fc52f14fe",
      "code": "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]",
      "title": "2217. Find Palindrome With Fixed Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4be0baa-6631-45b7-b306-d6e98b532048",
      "code": "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)",
      "title": "2218. Maximum Value of K Coins From Piles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f7b6e17-8717-4b26-a9be-704642917ba1",
      "code": "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans",
      "title": "2219. Maximum Sum Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ccb5c85-bb30-44c2-82cc-7bbfc9fedffe",
      "code": "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()",
      "title": "2220. Minimum Bit Flips to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "209b8a67-1b3d-486c-a922-05b88fcd9ef3",
      "code": "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]",
      "title": "2221. Find Triangular Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1c5b470-0f4b-4cbc-b8b4-4de0950a22c3",
      "code": "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans",
      "title": "2222. Number of Ways to Select Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f44b1394-af83-4b3a-a877-f6c56dd86599",
      "code": "class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n",
      "title": "2223. Sum of Scores of Built Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c969ac8-101b-46eb-bba4-6613875af244",
      "code": "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans",
      "title": "2224. Minimum Number of Operations to Convert Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d304e143-af20-41ba-894a-8882f7feb4a0",
      "code": "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]",
      "title": "2225. Find Players With Zero or One Losses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d13d5e79-3a7c-4c8e-b3f8-f00966872f67",
      "code": "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1",
      "title": "2226. Maximum Candies Allocated to K Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aa332e4-6bf0-44c4-b200-7891f791f882",
      "code": "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)",
      "title": "2229. Check if an Array Is Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7473189-f129-4f11-9017-542d84e285b9",
      "code": "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans",
      "title": "2231. Largest Number After Digit Swaps by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dadc8e41-e930-4860-8c6d-8bced353ed91",
      "code": "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans",
      "title": "2232. Minimize Result by Adding Parentheses to Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82bd33d2-8f8a-4d31-89b1-f29bbcc81156",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans",
      "title": "2233. Maximum Product After K Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f18ac8c-37f9-4565-8c9c-4aef73e173bc",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans",
      "title": "2234. Maximum Total Beauty of the Gardens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "adf789de-8f46-429f-a13f-0f5ad745654d",
      "code": "class Solution:\n  sum = operator.add",
      "title": "2235. Add Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0acc7b66-4676-446b-86a6-185bfed10d97",
      "code": "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val",
      "title": "2236. Root Equals Sum of Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "491a0877-12e3-4676-9e0a-3ae4dd7fb2c7",
      "code": "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans",
      "title": "2237. Count Positions on Street With Required Brightness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ee6a77f-dbd6-4b23-99d5-c9b615854d7d",
      "code": "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]",
      "title": "2239. Find Closest Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e72f56d1-656f-4a1f-a5e9-897d469d0a56",
      "code": "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1",
      "title": "2240. Number of Ways to Buy Pens and Pencils",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec2cb710-096f-4425-8e8c-1ac48eddeba7",
      "code": "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans",
      "title": "2242. Maximum Score of a Node Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d56a29bb-b7eb-4814-b43b-9401c805893b",
      "code": "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s",
      "title": "2243. Calculate Digit Sum of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aedd7287-8453-4189-8c9b-a1694cb54fb7",
      "code": "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)",
      "title": "2244. Minimum Rounds to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37f7b36e-9de4-40d9-ad63-349e4c0d39a6",
      "code": "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans",
      "title": "2245. Maximum Trailing Zeros in a Cornered Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17ba7074-be26-4d3c-862d-c39ccaf219bf",
      "code": "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans",
      "title": "2246. Longest Path With Different Adjacent Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03fcabea-55a2-4ad0-8809-71a3d4f4ab07",
      "code": "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))",
      "title": "2247. Maximum Cost of Trip With K Highways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f765de9-fc3e-4405-bd54-8a8ecc80defe",
      "code": "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]",
      "title": "2248. Intersection of Multiple Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfef317e-8f56-463e-810a-b990b1351203",
      "code": "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)",
      "title": "2249. Count Lattice Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a0d9997-b238-42b5-b9e0-1f6a5a73bbc3",
      "code": "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans",
      "title": "2250. Count Number of Rectangles Containing Each Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d6579d2-2925-47aa-a59c-a45a19bcaf09",
      "code": "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]",
      "title": "2251. Number of Flowers in Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3620c281-0150-4ad1-9c3b-b273dcf9a2b3",
      "code": "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))",
      "title": "2255. Count Prefixes of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaa1b58e-919e-45a3-84a9-3300288daa5e",
      "code": "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans",
      "title": "2256. Minimum Average Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4514387d-db7e-431a-bb1c-6cbdfd6d9f4f",
      "code": "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans",
      "title": "2257. Count Unguarded Cells in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ae59e98-1158-46f8-ac49-358318b5eef4",
      "code": "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False",
      "title": "2258. Escape the Spreading Fire",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f92934e8-b968-459b-824c-ffbef596d865",
      "code": "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans",
      "title": "2260. Minimum Consecutive Cards to Pick Up",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa0afd2d-6e7a-498a-bd98-63ac1214973b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans",
      "title": "2261. K Divisible Elements Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3b00aef-8c83-44bf-8375-ef0c8ac4c3c1",
      "code": "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans",
      "title": "2262. Total Appeal of A String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "386c913d-cc08-4dab-a511-8bc70dc85f44",
      "code": "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))",
      "title": "2263. Make Array Non-decreasing or Non-increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7318735d-7acc-4b4d-8933-c9c37189d839",
      "code": "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))",
      "title": "2264. Largest 3-Same-Digit Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb0566d9-9ee6-44de-be62-2a513ad580e6",
      "code": "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans",
      "title": "2265. Count Nodes Equal to Average of Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2594ef97-9027-4e1c-80c0-5279b3aff656",
      "code": "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]",
      "title": "2266. Count Number of Texts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "824a8ec2-0f87-465d-9f7a-457f67ee5cfd",
      "code": "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)",
      "title": "2267. Check if There Is a Valid Parentheses String Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "064e99bb-ca19-4d02-9c80-b6709914a3b6",
      "code": "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))",
      "title": "2268. Minimum Number of Keypresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44fc9fa7-a94b-4322-afed-e8b49a24e71f",
      "code": "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans",
      "title": "2269. Find the K-Beauty of a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f14387c-ab52-4afb-84ce-ba73ce91685d",
      "code": "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans",
      "title": "2270. Number of Ways to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc516439-1ed5-4cb1-b384-f6f4e1b4de92",
      "code": "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans",
      "title": "2271. Maximum White Tiles Covered by a Carpet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9e6435f-5694-4675-a0fc-6cc96dd75e82",
      "code": "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)",
      "title": "2272. Substring With Largest Variance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c60d5f3c-19b6-4c60-9237-a0acfcf9e326",
      "code": "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans",
      "title": "2273. Find Resultant Array After Removing Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d30fd8a1-9aef-4f12-92da-6b6c34533cfd",
      "code": "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])",
      "title": "2274. Maximum Consecutive Floors Without Special Floors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbc467e3-5de6-468d-ac98-e6f5b32397f3",
      "code": "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))",
      "title": "2275. Largest Combination With Bitwise AND Greater Than Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78b2ec6f-b016-44b1-ba1c-91b9c648c176",
      "code": "class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]",
      "title": "2277. Closest Node to Path in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "147287a1-cfc4-4883-94a1-b3b1178d8d16",
      "code": "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)",
      "title": "2278. Percentage of Letter in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efd431e5-0ecb-4027-b823-bcebc2a3f3ab",
      "code": "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)",
      "title": "2279. Maximum Bags With Full Capacity of Rocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6ef6681-78ff-4839-b3f2-003df8bff3d3",
      "code": "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)",
      "title": "2280. Minimum Lines to Represent a Line Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b4db765-c3af-4c68-a5c7-dcafe9099cc7",
      "code": "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD",
      "title": "2281. Sum of Total Strength of Wizards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a194c483-9a37-448f-a1c8-7adc98a0bd91",
      "code": "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans",
      "title": "2282. Number of People That Can Be Seen in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eba4f761-b09a-49cd-9185-7f4bdfda5ffc",
      "code": "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))",
      "title": "2283. Check if Number Has Equal Digit Count and Digit Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a076884-a21d-4b06-bd2e-e8a72b27adfe",
      "code": "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans",
      "title": "2284. Sender With Largest Word Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "344d52be-430a-4606-ab32-79ab8f025dc1",
      "code": "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))",
      "title": "2285. Maximum Total Importance of Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ee80d12-4995-420f-998e-7152fb6cd9e0",
      "code": "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)",
      "title": "2287. Rearrange Characters to Make Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2aac9d1d-1415-4e96-980c-f2b99157849e",
      "code": "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)",
      "title": "2288. Apply Discount to Prices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56aae194-8e74-4951-95db-8702d212d879",
      "code": "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)",
      "title": "2289. Steps to Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca61e642-ff8a-4763-b64b-d2fbfc636472",
      "code": "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]",
      "title": "2290. Minimum Obstacle Removal to Reach Corner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ccd0fe7-6c4c-4484-aac9-23d38b2ca01e",
      "code": "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]",
      "title": "2291. Maximum Profit From Trading Stocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ebfa3e5-7c3c-4fbe-b319-43080646a040",
      "code": "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)",
      "title": "2293. Min Max Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f5da448-2ccf-4da4-8089-c773e154331f",
      "code": "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans",
      "title": "2294. Partition Array Such That Maximum Difference Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2064f54-1d3b-4d56-893c-884184171304",
      "code": "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums",
      "title": "2295. Replace Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8623c83-12da-41e7-b2c4-0d5d179243ee",
      "code": "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]",
      "title": "2297. Jump Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba3182cc-3caf-48bb-99f7-113ee0e7ba10",
      "code": "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))",
      "title": "2299. Strong Password Checker II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4a066af-f767-4bd9-87c7-c38a0b4f8adc",
      "code": "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]",
      "title": "2300. Successful Pairs of Spells and Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d343bc6-3ae4-4b0a-8b52-4cc386326644",
      "code": "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True",
      "title": "2301. Match Substring After Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94276bea-bf61-418d-bdba-f761709f8f54",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2302. Count Subarrays With Score Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c298d7ff-c486-458e-88bc-85fbb79ad518",
      "code": "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans",
      "title": "2303. Calculate Amount Paid in Taxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d5ccb80-ee1d-406f-a7fd-1d0aa2db8f6a",
      "code": "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])",
      "title": "2304. Minimum Path Cost in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1cc0e5d-0cfd-46b6-be11-ed19a1015725",
      "code": "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans",
      "title": "2305. Fair Distribution of Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbe91917-814d-4aa3-abfe-7c091bcd9654",
      "code": "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i, j in itertools.combinations(range(26), 2):\n      count = len(suffixes[i] & suffixes[j])\n      ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans",
      "title": "2306. Naming a Company",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "226744ba-120d-4e48-9b81-6cf79b6d44bd",
      "code": "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False",
      "title": "2307. Check for Contradictions in Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a34d7ab-b3f7-4cf7-aa37-49978ec34433",
      "code": "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''",
      "title": "2309. Greatest English Letter in Upper and Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdd9026e-3191-444e-89f2-2574dc999112",
      "code": "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1",
      "title": "2310. Sum of Numbers With Units Digit K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3774bd13-4522-4bf6-b99e-60faffaf322f",
      "code": "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount",
      "title": "2311. Longest Binary Subsequence Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e83aae6-3181-4fe8-8a27-a79bc4b124af",
      "code": "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]",
      "title": "2312. Selling Pieces of Wood",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe57bae-5863-4486-92c8-85b6a7a32b9e",
      "code": "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)",
      "title": "2313. Minimum Flips in Binary Tree to Get Result",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d54fdb07-6acc-4b5b-8d4e-73666328ea1b",
      "code": "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans",
      "title": "2315. Count Asterisks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec33747b-4435-4791-8ed8-31225b5438e7",
      "code": "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)",
      "title": "2316. Count Unreachable Pairs of Nodes in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c1b566d-a7ca-4b7a-868d-f62fdcb16cbd",
      "code": "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)",
      "title": "2317. Maximum XOR After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b88546bd-4d69-4c56-a7c8-fd4494426031",
      "code": "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)",
      "title": "2318. Number of Distinct Roll Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f41784a8-f27e-48d4-b34b-338631dbe0fe",
      "code": "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True",
      "title": "2319. Check if Matrix Is X-Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dc9816d-0e27-47e1-a7f0-c167011d7dfd",
      "code": "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD",
      "title": "2320. Count Number of Ways to Place Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b0157ad-4b7c-4248-a56a-38958fb9819a",
      "code": "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))",
      "title": "2321. Maximum Score Of Spliced Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66bf293f-1a79-494a-b732-2ccc0b2b12cf",
      "code": "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans",
      "title": "2322. Minimum Score After Removals on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "881c48bd-8108-47f8-bc88-dd1208c1f90e",
      "code": "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans",
      "title": "2323. Find Minimum Time to Finish All Jobs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd1d71c0-cf59-4d61-8c12-83862019e73f",
      "code": "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)",
      "title": "2325. Decode the Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64c8c801-d123-49a6-b47e-d8757e0f5b74",
      "code": "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans",
      "title": "2326. Spiral Matrix IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98325ff2-57e7-4cdb-bb7d-4fcaf8c5c617",
      "code": "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD",
      "title": "2327. Number of People Aware of a Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b09dc3ae-dea7-4954-855d-f2921c955771",
      "code": "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD",
      "title": "2328. Number of Increasing Paths in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6343ff48-51ee-425b-8df8-37edcac9ba5d",
      "code": "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "2330. Valid Palindrome IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07c844a9-503c-47b5-bea6-c777495e09c5",
      "code": "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
      "title": "2331. Evaluate Boolean Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d1b4cbe-0471-4cad-bc20-3d1ec13ad59f",
      "code": "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans",
      "title": "2332. The Latest Time to Catch a Bus",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b79c8a0-4e4d-4fa7-8d29-2c0af3a98c22",
      "code": "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1",
      "title": "2334. Subarray With Elements Greater Than Varying Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7684bb5-a4f5-45aa-95b3-4c5fa8643019",
      "code": "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)",
      "title": "2335. Minimum Amount of Time to Fill Cups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ca4300c-200c-4ec0-b516-a04e2f64338d",
      "code": "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "2337. Move Pieces to Obtain a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e93b09c8-97e2-4db4-82a9-0d6800528736",
      "code": "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex",
      "title": "2340. Minimum Adjacent Swaps to Make a Valid Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3506c8a6-b61b-4531-bd32-cdd39bcce7bf",
      "code": "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans",
      "title": "2341. Maximum Number of Pairs in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21b55847-efee-4a47-9895-47ac1b3a5089",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2342. Max Sum of a Pair With Equal Sum of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26f3a47c-7f57-4d80-b95b-f3fe3e8cf50e",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1",
      "title": "2344. Minimum Deletions to Make Array Divisible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64ac74a7-961f-4ed0-a68c-fe3bcd76f4ee",
      "code": "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans",
      "title": "2345. Finding the Number of Visible Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87cdf2e0-9dd4-47ae-ab05-8bb2d130297e",
      "code": "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'",
      "title": "2347. Best Poker Hand",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f1a780c-eaaf-4319-a913-7baa3f10440b",
      "code": "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans",
      "title": "2348. Number of Zero-Filled Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc5f8924-749f-450d-bb67-8815cf4d9214",
      "code": "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans",
      "title": "2350. Shortest Impossible Sequence of Rolls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f6d38f1-045f-4073-9741-991a41f4e3d7",
      "code": "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True",
      "title": "2351. First Letter to Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6697a26d-6a17-42da-a9a0-33dab5bffa8e",
      "code": "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans",
      "title": "2352. Equal Row and Column Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de68997d-23f2-4d2f-a69c-e5033db55e6d",
      "code": "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)",
      "title": "2354. Number of Excellent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "296f21fe-2288-436e-8030-334e34b6abf5",
      "code": "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)",
      "title": "2355. Maximum Number of Books You Can Take",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ae892f-abf5-4ac4-aa5f-5adb2cab9d7d",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})",
      "title": "2357. Make Array Zero by Subtracting Equal Amounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b34d89f8-5f67-4181-9412-32c10749ff36",
      "code": "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)",
      "title": "2358. Maximum Number of Groups Entering a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43a363d2-c6d8-4e87-b1bd-3fc2c95ca503",
      "code": "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist",
      "title": "2359. Find Closest Node to Given Two Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "096d1f6a-bd87-4844-86b3-c88be36ca35b",
      "code": "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans",
      "title": "2360. Longest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f5ddc39-6ebe-465f-aeb5-3a4db8fa521b",
      "code": "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans",
      "title": "2361. Minimum Costs Using the Train Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5825be92-a352-412b-9627-7181f2be024a",
      "code": "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())",
      "title": "2363. Merge Similar Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24be3a04-0102-48af-a93e-5608d69f4967",
      "code": "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans",
      "title": "2364. Count Number of Bad Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68abe40e-ec6e-4e50-a201-fe2ceb5e3a5d",
      "code": "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans",
      "title": "2365. Task Scheduler II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97594804-642f-4657-9216-1170d5a555b2",
      "code": "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans",
      "title": "2366. Minimum Replacements to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "896da794-843b-4458-a9f5-9c8659d0c07c",
      "code": "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans",
      "title": "2367. Number of Arithmetic Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11596bd6-5a3b-45cd-b89e-3f7f285c04ac",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)",
      "title": "2368. Reachable Nodes With Restrictions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6ecdfb9-73ab-4f03-a422-fc74b23590f8",
      "code": "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]",
      "title": "2369. Check if There is a Valid Partition For The Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49326b53-c06a-480b-aa9b-a7ab11b9b4f3",
      "code": "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable",
      "title": "2370. Longest Ideal Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "467979f3-0208-491a-a957-e851346c4e63",
      "code": "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans",
      "title": "2371. Minimize Maximum Value in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d10a71f-be35-426a-bc65-d9a79ad6c9d7",
      "code": "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans",
      "title": "2373. Largest Local Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45c1999b-ac28-4b8e-b405-a9cb53f47735",
      "code": "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))",
      "title": "2374. Node With Highest Edge Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f981a18e-b3aa-4b60-b817-1bce7862dd29",
      "code": "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)",
      "title": "2375. Construct Smallest Number From DI String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35c8def4-7be5-47e4-b231-37ecca4d5be8",
      "code": "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "2376. Count Special Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18c709fe-c24a-44ff-bec8-25f5709a99de",
      "code": "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)",
      "title": "2378. Choose Edges to Maximize Score in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e29c00ff-b7d5-417e-a9d0-0ff3065de7ac",
      "code": "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB",
      "title": "2379. Minimum Recolors to Get K Consecutive Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11646077-3e0a-4f76-b2dc-243082849cba",
      "code": "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans",
      "title": "2380. Time Needed to Rearrange a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56b60828-c4ce-4c0b-b9c7-2c45f626e889",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    line = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      line[start] += diff\n      line[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + line[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)",
      "title": "2381. Shifting Letters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f88b9e22-7000-444d-898d-061330d715ae",
      "code": "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans",
      "title": "2382. Maximum Segment Sum After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c80f9cc-250b-44c1-bdff-f9824b8cec5e",
      "code": "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience",
      "title": "2383. Minimum Hours of Training to Win a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68014759-a31e-4c23-a07b-96088995a67e",
      "code": "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''",
      "title": "2384. Largest Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da6295c3-8ef3-4f28-9257-28c1f588ed88",
      "code": "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph",
      "title": "2385. Amount of Time for Binary Tree to Be Infected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe381123-8797-4206-a387-96d8d182217f",
      "code": "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum",
      "title": "2386. Find the K-Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63961744-e06d-41ce-b35a-4cc24a91231d",
      "code": "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2387. Median of a Row Wise Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b347a362-afed-4afb-9d16-6715bd3a8ec1",
      "code": "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]",
      "title": "2389. Longest Subsequence With Limited Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ecd9d94-dbe4-4a62-8c1a-58a89735c648",
      "code": "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "2390. Removing Stars From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea830ae3-8c14-4267-af48-b14494e5232c",
      "code": "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')",
      "title": "2391. Minimum Amount of Time to Collect Garbage",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a879c8-c7b2-4ac1-87a0-a94b87ce1702",
      "code": "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []",
      "title": "2392. Build a Matrix With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68694c68-9437-479e-b039-54b084fdb8e3",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans",
      "title": "2393. Count Strictly Increasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e50f0834-7bd6-498c-873f-3e1661ce673c",
      "code": "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False",
      "title": "2395. Find Subarrays With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63c259f2-4931-4eaa-a0bf-d0e99a9f7eff",
      "code": "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False",
      "title": "2396. Strictly Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c071342d-f581-4d1b-bd0c-59b7d4701956",
      "code": "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count",
      "title": "2397. Maximum Rows Covered by Columns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "676221fc-b4be-44ed-99f0-38508a75be32",
      "code": "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j",
      "title": "2398. Maximum Number of Robots Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62d3331a-b397-4f9a-82f7-6f99aaf62d1a",
      "code": "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True",
      "title": "2399. Check Distances Between Same Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f748b7a2-4bd8-416c-b0f5-9272a6d32b13",
      "code": "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]",
      "title": "2400. Number of Ways to Reach a Position After Exactly k Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f162e06a-628a-4015-90dd-e69673a507b6",
      "code": "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2401. Longest Nice Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "743fd4e0-79c7-4ec5-bcb7-420413a2afb2",
      "code": "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))",
      "title": "2402. Meeting Rooms III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cb24df7-4752-4afa-b984-81187b05b81f",
      "code": "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]",
      "title": "2403. Minimum Time to Kill All Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2aa6b6ef-f48f-4ebb-a603-9aa5cda7a930",
      "code": "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans",
      "title": "2404. Most Frequent Even Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10b887c3-783e-4a8d-ae07-beee2ffbf085",
      "code": "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans",
      "title": "2405. Optimal Partition of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "208d85e6-c6f9-47c0-af05-dfcd6a260ee8",
      "code": "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)",
      "title": "2406. Divide Intervals Into Minimum Number of Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14730f66-5038-448a-8b53-cf466cc7ba99",
      "code": "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans",
      "title": "2409. Count Days Spent Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "525d5982-adb7-4333-91e7-8c6171a1aab5",
      "code": "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans",
      "title": "2410. Maximum Matching of Players With Trainers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d73e73a-47a1-4fed-ae25-68cc657f3c4a",
      "code": "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans",
      "title": "2411. Smallest Subarrays With Maximum Bitwise OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d45a2de5-e831-41e9-a6eb-b53737d7414a",
      "code": "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans",
      "title": "2412. Minimum Money Required Before Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3cf9b54-2a0d-4bc6-989c-a87ad9bf28b5",
      "code": "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)",
      "title": "2413. Smallest Even Multiple",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbcca11a-a30a-47ed-9295-be7bbffcbc0a",
      "code": "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans",
      "title": "2414. Length of the Longest Alphabetical Continuous Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04a9772b-f518-4c77-9d6d-5d231421728a",
      "code": "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root",
      "title": "2415. Reverse Odd Levels of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b22246b-fc28-41d3-8d94-13624cf5ffa0",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]",
      "title": "2416. Sum of Prefix Scores of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31282770-68b5-405e-8244-a8c12e821090",
      "code": "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0",
      "title": "2417. Closest Fair Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8045cdca-e390-4828-a70b-6d66184c35fd",
      "code": "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]",
      "title": "2418. Sort the People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7ec4af2-8264-4464-b9f3-f55615013337",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans",
      "title": "2419. Longest Subarray With Maximum Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6e06867-95c0-44dd-8325-83c9233316fc",
      "code": "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]",
      "title": "2420. Find All Good Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76923ea9-34d6-4959-a2cb-e025e4ea132d",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans",
      "title": "2422. Merge Operations to Turn Array Into a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fa23f45-a8dc-4a6b-97ca-8c6b3a24a006",
      "code": "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False",
      "title": "2423. Remove Letter To Equalize Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a99b912-c5e1-4e44-82fb-8436b4b0c093",
      "code": "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)",
      "title": "2425. Bitwise XOR of All Pairings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61c96991-6ab7-4add-8e8c-99816cddaf0c",
      "code": "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))",
      "title": "2427. Number of Common Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc4fcc42-2616-4a57-ac61-361181f5e286",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))",
      "title": "2428. Maximum Sum of an Hourglass",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d2014f0-41ff-4fe2-bd9b-3b997d82eb00",
      "code": "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans",
      "title": "2429. Minimize XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0db52ec-0f2c-4773-a37e-57100ed49fe7",
      "code": "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]",
      "title": "2430. Maximum Deletions on a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b650cc93-884b-42fc-b6de-97165cdc13ae",
      "code": "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]",
      "title": "2431. Maximize Total Tastiness of Purchased Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6cbd15d-68e6-4858-9ded-2893eac103a8",
      "code": "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans",
      "title": "2432. The Employee That Worked on the Longest Task",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20638522-7a14-49cf-a980-73817ef44b28",
      "code": "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans",
      "title": "2433. Find The Original Array of Prefix Xor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d23361d-aa15-4e36-949d-b07dbbefc2f4",
      "code": "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'",
      "title": "2434. Using a Robot to Print the Lexicographically Smallest String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2db34a86-872e-4749-be26-7a2177229796",
      "code": "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]",
      "title": "2435. Paths in Matrix Whose Sum Is Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "485fe610-0bc7-4291-99f6-d8ae1cafb890",
      "code": "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans",
      "title": "2436. Minimum Split Into Subarrays With GCD Greater Than One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fce204c8-4f54-4eaa-8f94-19a4b7a922e4",
      "code": "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans",
      "title": "2437. Number of Valid Clock Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0beb0d72-90c2-44fb-bfaa-009b894fac54",
      "code": "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    pows = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= pows[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans",
      "title": "2438. Range Product Queries of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8a211bd-a7e6-4a6b-83d8-12028f80c98c",
      "code": "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans",
      "title": "2439. Minimize Maximum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba6350b3-7a17-49a0-adad-802401fa07b4",
      "code": "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0",
      "title": "2440. Create Components With Same Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33a80f3a-17ba-449a-8130-a02dec406579",
      "code": "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans",
      "title": "2441. Largest Positive Integer That Exists With Its Negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc6a0f7-63c9-4e78-bea9-afae0884d736",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans",
      "title": "2444. Count Subarrays With Fixed Bounds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b02b22b-faa7-4dd3-a7f8-4d8024d6f0d9",
      "code": "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)",
      "title": "2445. Number of Nodes With Value One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aefa97f-dff5-48a9-95dd-ed04160b6188",
      "code": "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans",
      "title": "2447. Number of Subarrays With GCD Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d7bdc51-b8f0-432f-95a6-077b15c8b1fb",
      "code": "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans",
      "title": "2448. Minimum Cost to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca901a18-54bf-41fc-a3ed-50d355422770",
      "code": "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4",
      "title": "2449. Minimum Number of Operations to Make Arrays Similar",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2973be1e-0446-4d4b-a441-afcd67890f4f",
      "code": "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)",
      "title": "2450. Number of Distinct Binary Strings After Applying Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c508f591-af59-4457-8a12-3285b7c4cbce",
      "code": "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word",
      "title": "2451. Odd String Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8eea484-74f1-4611-9f5c-02a0a0d1d310",
      "code": "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]",
      "title": "2452. Words Within Two Edits of Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52329d97-6c7f-4872-8051-402f26d85c00",
      "code": "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)",
      "title": "2453. Destroy Sequential Targets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "743c0fd7-1fb2-4ab8-a786-2c40bb9b2df9",
      "code": "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans",
      "title": "2454. Next Greater Element IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbad3c2b-1fc2-486a-b5b8-6be3511f6014",
      "code": "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count",
      "title": "2455. Average Value of Even Numbers That Are Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edd61d19-856e-4f48-8ec0-ea20794d7cfd",
      "code": "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans",
      "title": "2456. Most Popular Video Creator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4d0d28a-ba18-4cf3-b471-7addc96f912f",
      "code": "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans",
      "title": "2457. Minimum Addition to Make Integer Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb4a9744-62c6-498b-913d-161867994a0a",
      "code": "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]",
      "title": "2458. Height of Binary Tree After Subtree Removal Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ed935f1-ee94-4cf2-a085-568660e6f58b",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))",
      "title": "2459. Sort Array by Moving Items to Empty Space",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f721152b-a13d-46bd-8593-a0153b41234a",
      "code": "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans",
      "title": "2460. Apply Operations to an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "052b369f-870c-42b3-8727-26b7f1615bc0",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2461. Maximum Sum of Distinct Subarrays With Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bedff20b-1680-43eb-b704-d8b15f338cb8",
      "code": "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans",
      "title": "2462. Total Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a46ef9a6-5d4b-4112-8384-58c1597c9347",
      "code": "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)",
      "title": "2463. Minimum Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a907d7f6-7898-4c62-a3fd-48b3d0d632bf",
      "code": "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "2464. Minimum Subarrays in a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba72a64c-6b24-4691-bde7-0858269a4483",
      "code": "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)",
      "title": "2465. Number of Distinct Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "060b18f8-7090-4026-b11b-4ad9f0f953ea",
      "code": "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans",
      "title": "2466. Count Ways To Build Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50141010-5149-42d9-99be-31ee46264297",
      "code": "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath",
      "title": "2467. Most Profitable Path in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "914b3905-9934-46a1-88f3-47e974648113",
      "code": "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans",
      "title": "2468. Split Message Based on Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c583e8c-af35-4112-8025-bd7b6a4eaf7b",
      "code": "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]",
      "title": "2469. Convert the Temperature",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "559b2212-6263-4f39-9cd2-b181ffca7545",
      "code": "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans",
      "title": "2470. Number of Subarrays With LCM Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60c0c136-dc87-49ee-8848-5ad30eba7fb7",
      "code": "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans",
      "title": "2471. Minimum Number of Operations to Sort a Binary Tree by Level",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9429a7bd-2119-481c-9255-d21636c08da2",
      "code": "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]",
      "title": "2472. Maximum Number of Non-overlapping Palindrome Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945b70af-5afc-41a6-b8bb-10d68c466e2c",
      "code": "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans",
      "title": "2473. Minimum Cost to Buy Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80607d7d-05a3-48c7-b2f8-18d14ce1d842",
      "code": "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans",
      "title": "2475. Number of Unequal Triplets in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "670cb8ca-0fd8-4b91-abb8-284d2d489854",
      "code": "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)",
      "title": "2476. Closest Nodes Queries in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "917fb0b9-03fb-4032-8b34-7d0c45311f1a",
      "code": "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans",
      "title": "2477. Minimum Fuel Cost to Report to the Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f4d033f-c643-472d-b52d-c5315f98eada",
      "code": "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)",
      "title": "2478. Number of Beautiful Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a96cf854-976a-43ce-a4e5-29053a62a04b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans",
      "title": "2479. Maximum XOR of Two Non-Overlapping Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c843d1c-e46e-4335-b507-dbf85db43d0b",
      "code": "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n",
      "title": "2481. Minimum Cuts to Divide a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03c682bf-3872-44b6-ae76-8547ca5a8a53",
      "code": "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans",
      "title": "2482. Difference Between Ones and Zeros in Row and Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c60bbd1-8aaa-4a1a-81a1-325670509b4b",
      "code": "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans",
      "title": "2483. Minimum Penalty for a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd38ef2-f4d4-4ff1-989c-11bc054b4a8f",
      "code": "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans",
      "title": "2484. Count Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "986d6096-a249-4998-97d5-931497d9a771",
      "code": "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1",
      "title": "2485. Find the Pivot Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d3df1ab-64d2-4323-a727-03b1fb71ee06",
      "code": "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i",
      "title": "2486. Append Characters to String to Make Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e15f014-bcbb-46ee-a90c-b5eb41559d7d",
      "code": "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head",
      "title": "2487. Remove Nodes From Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5716e2c-20df-4ed4-98a6-4c1ee5581a8c",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans",
      "title": "2488. Count Subarrays With Median K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5f853a8-b9f8-4d4b-acb5-619b3e535df0",
      "code": "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2489. Number of Substrings With Fixed Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ca91616-75e0-49df-a9af-575523c3e40b",
      "code": "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]",
      "title": "2490. Circular Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46b5a29e-0402-44d4-9784-3ca164f4d758",
      "code": "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2",
      "title": "2491. Divide Players Into Teams of Equal Skill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1193590-8d0e-4214-961f-ca6f901ef35b",
      "code": "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans",
      "title": "2492. Minimum Score of a Path Between Two Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed26a425-ce5a-4495-ae8c-0d690df57609",
      "code": "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans",
      "title": "2495. Number of Subarrays Having Even Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "620efa1d-57a5-4edd-a7f6-94784ebcec61",
      "code": "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)",
      "title": "2496. Maximum Value of a String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fb0e2a1-d0b3-4845-9afb-06eeb6a53e40",
      "code": "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans",
      "title": "2497. Maximum Star Sum of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac81c41b-e437-48ea-b907-2cecd333b18d",
      "code": "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))",
      "title": "2498. Frog Jump II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5c42082-6678-4128-9504-2511f1849be1",
      "code": "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans",
      "title": "2499. Minimum Total Cost to Make Arrays Unequal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2de80995-016c-4a6b-8541-bd087cfede27",
      "code": "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))",
      "title": "2500. Delete Greatest Value in Each Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af49ae0a-fef2-413f-8504-dc5223d7e926",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans",
      "title": "2503. Maximum Number of Points From Grid Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bfe33ea-3135-4a88-82b4-11a81760f68e",
      "code": "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans",
      "title": "2505. Bitwise OR of All Subsequence Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4439bc6-1afb-43e1-95ce-ace2e1c9fcac",
      "code": "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    masks = [self._getMask(word) for word in words]\n    return sum(masks[i] == masks[j]\n               for i, j in itertools.combinations(range(len(masks)), 2))\n\n  def _getMask(self, word: str) -> int:\n    mask = 0\n    for c in word:\n      mask |= 1 << ord(c) - ord('a')\n    return mask",
      "title": "2506. Count Pairs Of Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ef0df1f-28f1-400b-975d-aa0a3c286478",
      "code": "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n",
      "title": "2507. Smallest Value After Replacing With Sum of Prime Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86787423-be0b-40c1-bc8c-eacc90865567",
      "code": "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False",
      "title": "2508. Add Edges to Make Degrees of All Nodes Even",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6908125a-5219-4e90-9b93-da299a437bea",
      "code": "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]",
      "title": "2509. Cycle Length Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f304bbd-a2a2-433e-8eac-508091e59974",
      "code": "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)",
      "title": "2510. Check if There is a Path With Equal Number of 0's And 1's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4dcc57fa-8d2a-4325-a98d-d06d7af91525",
      "code": "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans",
      "title": "2511. Maximum Enemy Forts That Can Be Captured",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c51a8c0b-accb-4eb2-8ebe-14eb96829052",
      "code": "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]",
      "title": "2512. Reward Top K Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b372462d-5e93-4da7-b232-00670a970f37",
      "code": "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2513. Minimize the Maximum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e912f1c-397a-4e74-9051-d8a453f0e59c",
      "code": "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007",
      "title": "2514. Count Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90b05810-0ed7-4c4c-bac1-462837aca6a7",
      "code": "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1",
      "title": "2515. Shortest Distance to Target String in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "924bfd14-4f67-48d5-9350-95d3aea0ef79",
      "code": "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans",
      "title": "2516. Take K of Each Character From Left and Right",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b790a6fa-930a-43be-ac60-b2342b729b29",
      "code": "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1",
      "title": "2517. Maximum Tastiness of Candy Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e317d0f4-ef10-4c01-a404-993cb8397101",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD",
      "title": "2518. Number of Great Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44a3aafe-7e5a-480d-a04e-056d065a0bec",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))",
      "title": "2519. Count the Number of K-Big Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d6a874f-71a3-4dbf-bc0d-55a6a2096861",
      "code": "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))",
      "title": "2520. Count the Digits That Divide a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a775ff3-cfa4-4610-8921-b8c21a46eac2",
      "code": "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor",
      "title": "2521. Distinct Prime Factors of Product of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43a4272c-9e29-4d96-91be-1183ac365f16",
      "code": "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans",
      "title": "2522. Partition String Into Substrings With Values at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9669977b-ac46-4e80-84cc-9bc1930beb24",
      "code": "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2523. Closest Prime Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4c5f04e-6524-49cd-b6c9-fd65c4595fc0",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ",
      "title": "2524. Maximum Frequency Score of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42226258-ab29-4b58-a6b4-ede9bf3d98b4",
      "code": "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'",
      "title": "2525. Categorize Box According to Criteria",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a3038e0-a80c-435b-9455-b6b54b840e7a",
      "code": "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)",
      "title": "2527. Find Xor-Beauty of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad5588b8-731a-4d49-aeb1-ce48bed82fd0",
      "code": "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1",
      "title": "2528. Maximize the Minimum Powered City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f9ff02f-a3c0-475a-b656-a7f0da00c6b0",
      "code": "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))",
      "title": "2529. Maximum Count of Positive Integer and Negative Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15e1b0c6-7095-48d6-9164-e8a186d67475",
      "code": "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans",
      "title": "2530. Maximal Score After Applying K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11e1dca0-6b9f-4adf-a426-8b0fb63eee72",
      "code": "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False",
      "title": "2531. Make Number of Distinct Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b982f20-7d46-4c9b-9d1b-7e79b8b3f92f",
      "code": "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans",
      "title": "2532. Time to Cross a Bridge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "687de318-8226-479f-ae00-987434837d92",
      "code": "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD",
      "title": "2533. Number of Good Binary Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "faacc7bf-6c16-4a69-bc6e-7cda0e6f50bc",
      "code": "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2535. Difference Between Element Sum and Digit Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55fb5fe4-efd3-4b6a-8184-2afff868fb73",
      "code": "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans",
      "title": "2538. Difference Between Maximum and Minimum Price Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76c243fb-fcda-413c-90ec-2361510184da",
      "code": "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans",
      "title": "2539. Count the Number of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5605f68-8b65-466b-a17b-f5478968ef41",
      "code": "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1",
      "title": "2540. Minimum Common Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0eba2ab-6f01-4fa7-a07e-a47667a6de25",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1",
      "title": "2541. Minimum Operations to Make Array Equal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8c37028-5528-4ca6-b09e-6a9a9d74c689",
      "code": "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans",
      "title": "2542. Maximum Subsequence Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4d4dde2-2981-4324-bcfa-da70de2ae4d4",
      "code": "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1",
      "title": "2543. Check if Point Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "882dd5a0-6ee0-4ac4-8c9b-57b890c07f99",
      "code": "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans",
      "title": "2544. Alternating Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a47ff56-b934-438b-8b11-4c1f274f59c3",
      "code": "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])",
      "title": "2545. Sort the Students by Their Kth Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f33d3ac8-9571-4900-9413-be63d49d5e81",
      "code": "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)",
      "title": "2546. Apply Bitwise Operations to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75e0e996-6cc4-4337-9304-50677a1836fc",
      "code": "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]",
      "title": "2547. Minimum Cost to Split an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a6594f9-7768-4a05-8e03-52af57cbb930",
      "code": "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1",
      "title": "2548. Maximum Price to Fill a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f6303b3-ecfa-4a64-9769-6ffe53739139",
      "code": "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)",
      "title": "2549. Count Distinct Numbers on Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e81e40-6fd7-4e2d-9b96-b0fcdbcbfbb3",
      "code": "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res",
      "title": "2550. Count Collisions of Monkeys on a Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60902851-3541-484d-bd86-7d5e82087b3b",
      "code": "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))",
      "title": "2551. Put Marbles in Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7303fa22-bf02-4577-9603-f103802355a9",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans",
      "title": "2552. Count Increasing Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81a44d63-514b-4f65-adbe-ae3615f9c56b",
      "code": "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]",
      "title": "2553. Separate the Digits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84a7356f-2f08-42ae-bea2-f2b3ad5b7e7d",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans",
      "title": "2554. Maximum Number of Integers to Choose From a Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae80e72f-45a5-4a8d-a677-87cf52ec01b3",
      "code": "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans",
      "title": "2555. Maximize Win From Two Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea726ab8-d2af-455b-bf6e-41bb67068b34",
      "code": "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)",
      "title": "2556. Disconnect Path in a Binary Matrix by at Most One Flip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a731ce6c-0d54-491b-a389-60c23b9a3639",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)",
      "title": "2557. Maximum Number of Integers to Choose From a Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87adee34-896a-4141-8f7a-0ea315ff00c1",
      "code": "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)",
      "title": "2558. Take Gifts From the Richest Pile",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61c168db-5cd5-46c8-9957-8f46745c5d86",
      "code": "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]",
      "title": "2559. Count Vowel Strings in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecbe5da8-1688-41a3-8889-c227f2def96b",
      "code": "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)",
      "title": "2560. House Robber IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03f879cb-c712-4154-9d38-38dd3086d6ea",
      "code": "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])",
      "title": "2561. Rearranging Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6fe9389-a371-470f-bd8d-a84e49ad59e1",
      "code": "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)",
      "title": "2563. Count the Number of Fair Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd7b9279-b9f4-4fcd-88fc-0a52a36b5da5",
      "code": "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]",
      "title": "2564. Substring XOR Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ff51b6b-09e0-4a10-b13e-90fd0a72b0d3",
      "code": "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans",
      "title": "2565. Subsequence With the Minimum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12820962-bfae-486f-a431-8cba1d83a84f",
      "code": "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0",
      "title": "2566. Maximum Difference by Remapping a Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6d71e36-9aeb-4446-9067-8ae7757fb982",
      "code": "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)",
      "title": "2567. Minimum Score by Changing Two Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60ab8734-0934-428c-adc4-cdb1050b0d80",
      "code": "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans",
      "title": "2568. Minimum Impossible OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9427a01-c823-4d45-993d-99d692111833",
      "code": "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val",
      "title": "2570. Merge Two 2D Arrays by Summing Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c012d7f-888e-41b2-8568-5cd5e04443c0",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans",
      "title": "2571. Minimum Operations to Reduce an Integer to 0",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffe14b1a-283e-4335-bf75-26cefa6ae1db",
      "code": "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD",
      "title": "2572. Count the Number of Square-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a86d7ad7-9fc7-40b7-b198-3d23fd766ebf",
      "code": "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]",
      "title": "2574. Left and Right Sum Differences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7635b26e-568c-4481-806c-378e839a00bd",
      "code": "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans",
      "title": "2575. Find the Divisibility Array of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92b3b530-e160-4536-b0c7-b62e535b1183",
      "code": "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2",
      "title": "2576. Find the Maximum Number of Marked Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}