# Day 1: Core Data Structures & Algorithms

## üéØ Focus Areas
- **Arrays & Strings**: Hash tables, two pointers, sliding window
- **Trees**: DFS/BFS, tree properties, traversal techniques
- **Basic Algorithms**: Dynamic programming fundamentals

## üìö Morning Session (4 hours): Arrays & Strings

### 1. Two Sum (Problem 1)
**Key Concept**: Hash Table
- **Approach**: Use hash table to store complements
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
- **Interview Tip**: Always ask about input constraints and return format

### 2. Valid Parentheses (Problem 20)
**Key Concept**: Stack
- **Approach**: Use stack to match opening/closing brackets
- **Time Complexity**: O(n)
- **Space Complexity**: O(n)
- **Edge Cases**: Empty string, single character, unmatched brackets

### 3. Merge Two Sorted Lists (Problem 21)
**Key Concept**: Linked List Manipulation
- **Approach**: Compare and merge nodes
- **Time Complexity**: O(n + m)
- **Space Complexity**: O(1)
- **Interview Tip**: Handle edge cases (empty lists, different lengths)

### 4. Remove Duplicates from Sorted Array (Problem 26)
**Key Concept**: Two Pointers
- **Approach**: Use slow/fast pointer technique
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Key Insight**: In-place modification

### 5. Maximum Subarray (Problem 53)
**Key Concept**: Kadane's Algorithm
- **Approach**: Keep track of current sum and maximum sum
- **Time Complexity**: O(n)
- **Space Complexity**: O(1)
- **Variation**: Can handle all negative numbers

### 6. Climbing Stairs (Problem 70)
**Key Concept**: Dynamic Programming
- **Approach**: Fibonacci sequence with DP
- **Time Complexity**: O(n)
- **Space Complexity**: O(1) with optimization
- **Pattern**: Classic DP problem

## üìö Afternoon Session (4 hours): Trees & Graphs

### 7. Validate Binary Search Tree (Problem 98)
**Key Concept**: Inorder Traversal
- **Approach**: Inorder traversal should be sorted
- **Time Complexity**: O(n)
- **Space Complexity**: O(h) - height of tree
- **Key Insight**: Use inorder traversal or range checking

### 8. Symmetric Tree (Problem 101)
**Key Concept**: Tree Traversal
- **Approach**: Compare left and right subtrees recursively
- **Time Complexity**: O(n)
- **Space Complexity**: O(h)
- **Pattern**: Mirror image comparison

### 9. Binary Tree Level Order Traversal (Problem 102)
**Key Concept**: BFS (Breadth-First Search)
- **Approach**: Use queue for level-by-level traversal
- **Time Complexity**: O(n)
- **Space Complexity**: O(w) - width of tree
- **Variation**: Can be done with DFS too

### 10. Maximum Depth of Binary Tree (Problem 104)
**Key Concept**: DFS/BFS
- **Approach**: Recursive or iterative traversal
- **Time Complexity**: O(n)
- **Space Complexity**: O(h)
- **Simple but Important**: Foundation for tree problems

### 11. Lowest Common Ancestor (Problem 235)
**Key Concept**: Tree Properties
- **Approach**: Use BST properties to navigate
- **Time Complexity**: O(h)
- **Space Complexity**: O(1)
- **Key Insight**: LCA is where paths diverge

## üéØ Key Learning Objectives for Day 1

### Data Structure Mastery
- ‚úÖ Hash tables for O(1) lookups
- ‚úÖ Stack for bracket matching and DFS
- ‚úÖ Two pointers for array manipulation
- ‚úÖ Queue for BFS traversal
- ‚úÖ Tree traversal patterns

### Algorithm Patterns
- ‚úÖ Sliding window technique
- ‚úÖ Dynamic programming basics
- ‚úÖ Recursive tree traversal
- ‚úÖ Iterative tree traversal
- ‚úÖ In-place array modification

### Interview Skills
- ‚úÖ Explain time/space complexity
- ‚úÖ Handle edge cases
- ‚úÖ Optimize step by step
- ‚úÖ Test with examples

## üìù Practice Exercises

### After Each Problem:
1. **Implement from scratch** without looking at solution
2. **Explain the algorithm** to yourself
3. **Identify edge cases** and test them
4. **Optimize the solution** if possible
5. **Practice similar problems** to reinforce patterns

### Evening Review:
- [ ] Review all 11 problems
- [ ] Identify common patterns
- [ ] Practice explaining solutions
- [ ] Note areas needing more practice
- [ ] Prepare for Day 2

## üöÄ Success Checklist for Day 1

By the end of Day 1, you should be able to:
- ‚úÖ Solve array problems using hash tables and two pointers
- ‚úÖ Implement tree traversals (DFS/BFS)
- ‚úÖ Explain dynamic programming concepts
- ‚úÖ Handle edge cases confidently
- ‚úÖ Optimize solutions when possible

**Remember**: Focus on understanding the patterns rather than memorizing solutions! 