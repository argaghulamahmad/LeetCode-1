{
  "snippets": [
    {
      "id": "c8923430-a6ec-4916-986a-f1616dcdafd5",
      "code": "class Solution:\n  def twoSum(self, nums: list[int], target: int) -> list[int]:\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      if target - num in numToIndex:\n        return numToIndex[target - num], i\n      numToIndex[num] = i",
      "title": "1. Two Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16d34534-7f19-4908-bc89-cb98653c659d",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n\n    while carry or l1 or l2:\n      if l1:\n        carry += l1.val\n        l1 = l1.next\n      if l2:\n        carry += l2.val\n        l2 = l2.next\n      curr.next = ListNode(carry % 10)\n      carry //= 10\n      curr = curr.next\n\n    return dummy.next",
      "title": "2. Add Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "905a6566-7280-4194-9f50-9df18cd24392",
      "code": "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    # The substring s[j + 1..i] has no repeating characters.\n    j = -1\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      # Update j to lastSeen[c], so the window must start from j + 1.\n      j = max(j, lastSeen.get(c, -1))\n      ans = max(ans, i - j)\n      lastSeen[c] = i\n\n    return ans",
      "title": "3. Longest Substring Without Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "684ef73e-07d9-4b24-b63d-f1300da22da5",
      "code": "class Solution:\n  def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1",
      "title": "4. Median of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbc7b855-a85e-4a5a-922f-56940f1bf048",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    t = '#'.join('@' + s + '$')\n    p = self._manacher(t)\n    maxPalindromeLength, bestCenter = max((extend, i)\n                                          for i, extend in enumerate(p))\n    l = (bestCenter - maxPalindromeLength) // 2\n    r = (bestCenter + maxPalindromeLength) // 2\n    return s[l:r]\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p",
      "title": "5. Longest Palindromic Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c5f077-f1c1-448b-b155-b19d642fc959",
      "code": "class Solution:\n  def convert(self, s: str, numRows: int) -> str:\n    rows = [''] * numRows\n    k = 0\n    direction = (numRows == 1) - 1\n\n    for c in s:\n      rows[k] += c\n      if k == 0 or k == numRows - 1:\n        direction *= -1\n      k += direction\n\n    return ''.join(rows)",
      "title": "6. ZigZag Conversion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e7fb2d7-16ef-4d82-bc19-5f436886ebeb",
      "code": "class Solution:\n  def reverse(self, x: int) -> int:\n    ans = 0\n    sign = -1 if x < 0 else 1\n    x *= sign\n\n    while x:\n      ans = ans * 10 + x % 10\n      x //= 10\n\n    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans",
      "title": "7. Reverse Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2adf6148-f8d9-4061-8aef-c959ea631910",
      "code": "class Solution:\n  def myAtoi(self, s: str) -> int:\n    s = s.strip()\n    if not s:\n      return 0\n\n    sign = -1 if s[0] == '-' else 1\n    if s[0] in {'-', '+'}:\n      s = s[1:]\n\n    num = 0\n\n    for c in s:\n      if not c.isdigit():\n        break\n      num = num * 10 + int(c)\n      if sign * num <= -2**31:\n        return -2**31\n      if sign * num >= 2**31 - 1:\n        return 2**31 - 1\n\n    return sign * num",
      "title": "8. String to Integer (atoi)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8babab3d-d186-4a50-8b97-f4ece70f48a6",
      "code": "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n    if x < 0:\n      return False\n\n    rev = 0\n    y = x\n\n    while y:\n      rev = rev * 10 + y % 10\n      y //= 10\n\n    return rev == x",
      "title": "9. Palindrome Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aafe057a-c56d-4dc9-b2ac-e735f029bb64",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          # The minimum index of '*' is 1.\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "10. Regular Expression Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4d45aa6-01b8-4c7c-ac3e-d97a288896b2",
      "code": "class Solution:\n  def maxArea(self, height: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(height) - 1\n\n    while l < r:\n      minHeight = min(height[l], height[r])\n      ans = max(ans, minHeight * (r - l))\n      if height[l] < height[r]:\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "11. Container With Most Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6926928-9f78-4dfe-8d1f-c4ba41a3d554",
      "code": "class Solution:\n  def intToRoman(self, num: int) -> str:\n    valueSymbols = [(1000, 'M'), (900, 'CM'),\n                    (500, 'D'), (400, 'CD'),\n                    (100, 'C'), (90, 'XC'),\n                    (50, 'L'), (40, 'XL'),\n                    (10, 'X'), (9, 'IX'),\n                    (5, 'V'), (4, 'IV'),\n                    (1, 'I')]\n    ans = []\n\n    for value, symbol in valueSymbols:\n      if num == 0:\n        break\n      count, num = divmod(num, value)\n      ans.append(symbol * count)\n\n    return ''.join(ans)",
      "title": "12. Integer to Roman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9797413-8bc0-498b-a8b3-c5192b5bd721",
      "code": "class Solution:\n  def romanToInt(self, s: str) -> int:\n    ans = 0\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n             'C': 100, 'D': 500, 'M': 1000}\n\n    for a, b in zip(s, s[1:]):\n      if roman[a] < roman[b]:\n        ans -= roman[a]\n      else:\n        ans += roman[a]\n\n    return ans + roman[s[-1]]",
      "title": "13. Roman to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91665961-0357-405a-a947-7d6b4e953182",
      "code": "class Solution:\n  def longestCommonPrefix(self, strs: list[str]) -> str:\n    if not strs:\n      return ''\n\n    for i in range(len(strs[0])):\n      for j in range(1, len(strs)):\n        if i == len(strs[j]) or strs[j][i] != strs[0][i]:\n          return strs[0][:i]\n\n    return strs[0]",
      "title": "14. Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2349aea5-e1c2-40ce-9b06-e5fd49ff8f5f",
      "code": "class Solution:\n  def threeSum(self, nums: list[int]) -> list[list[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "15. 3Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "873f5322-6eb1-4e53-ac01-f1cae1f7e918",
      "code": "class Solution:\n  def threeSumClosest(self, nums: list[int], target: int) -> int:\n    ans = nums[0] + nums[1] + nums[2]\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == target:\n          return summ\n        if abs(summ - target) < abs(ans - target):\n          ans = summ\n        if summ < target:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "16. 3Sum Closest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e46c95e6-c764-4ef1-b992-5ef46875523a",
      "code": "class Solution:\n  def letterCombinations(self, digits: str) -> list[str]:\n    if not digits:\n      return []\n\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(digits):\n        ans.append(''.join(path))\n        return\n\n      for letter in digitToLetters[int(digits[i])]:\n        path.append(letter)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return ans",
      "title": "17. Letter Combinations of a Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64b369e4-decd-44aa-a142-0fe8b87b01a9",
      "code": "class Solution:\n  def fourSum(self, nums: list[int], target: int):\n    ans = []\n\n    def nSum(\n            l: int, r: int, target: int, n: int, path: list[int],\n            ans: list[list[int]]) -> None:\n      \"\"\"Finds n numbers that add up to the target in [l, r].\"\"\"\n      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:\n        return\n      if n == 2:\n        while l < r:\n          summ = nums[l] + nums[r]\n          if summ == target:\n            ans.append(path + [nums[l], nums[r]])\n            l += 1\n            while nums[l] == nums[l - 1] and l < r:\n              l += 1\n          elif summ < target:\n            l += 1\n          else:\n            r -= 1\n        return\n\n      for i in range(l, r + 1):\n        if i > l and nums[i] == nums[i - 1]:\n          continue\n\n        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)\n\n    nums.sort()\n    nSum(0, len(nums) - 1, target, 4, [], ans)\n    return ans",
      "title": "18. 4Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f178635c-ac14-484b-b8fb-a58fa727aab5",
      "code": "class Solution:\n  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    slow = head\n    fast = head\n\n    for _ in range(n):\n      fast = fast.next\n    if not fast:\n      return head.next\n\n    while fast.next:\n      slow = slow.next\n      fast = fast.next\n    slow.next = slow.next.next\n\n    return head",
      "title": "19. Remove Nth Node From End of List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d73916d-b595-4e55-8ac5-aeb22bb8bc7a",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == '(':\n        stack.append(')')\n      elif c == '{':\n        stack.append('}')\n      elif c == '[':\n        stack.append(']')\n      elif not stack or stack.pop() != c:\n        return False\n\n    return not stack",
      "title": "20. Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44c7ebdf-682b-44eb-b8bd-131f6c5915a7",
      "code": "class Solution:\n  def mergeTwoLists(\n      self,\n      list1: ListNode | None,\n      list2: ListNode | None,\n  ) -> ListNode | None:\n    if not list1 or not list2:\n      return list1 if list1 else list2\n    if list1.val > list2.val:\n      list1, list2 = list2, list1\n    list1.next = self.mergeTwoLists(list1.next, list2)\n    return list1",
      "title": "21. Merge Two Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98093fae-880a-4207-b2b5-3831ca053bf4",
      "code": "class Solution:\n  def generateParenthesis(self, n):\n    ans = []\n\n    def dfs(l: int, r: int, s: list[str]) -> None:\n      if l == 0 and r == 0:\n        ans.append(''.join(s))\n      if l > 0:\n        s.append('(')\n        dfs(l - 1, r, s)\n        s.pop()\n      if l < r:\n        s.append(')')\n        dfs(l, r - 1, s)\n        s.pop()\n\n    dfs(n, n, [])\n    return ans",
      "title": "22. Generate Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80357d96-7ba5-4bc6-8a71-04a033c36bbb",
      "code": "from queue import PriorityQueue\n\n\nclass Solution:\n  def mergeKLists(self, lists: list[ListNode]) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    pq = PriorityQueue()\n\n    for i, lst in enumerate(lists):\n      if lst:\n        pq.put((lst.val, i, lst))\n\n    while not pq.empty():\n      _, i, minNode = pq.get()\n      if minNode.next:\n        pq.put((minNode.next.val, i, minNode.next))\n      curr.next = minNode\n      curr = curr.next\n\n    return dummy.next",
      "title": "23. Merge k Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1750cfc8-f88b-4748-8236-2b8ea1e58523",
      "code": "class Solution:\n  def swapPairs(self, head: ListNode) -> ListNode:\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // 2):\n      next = curr.next\n      curr.next = next.next\n      next.next = prev.next\n      prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next",
      "title": "24. Swap Nodes in Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ac7fd7-7a7b-45f0-a81d-b8833a12e2a9",
      "code": "class Solution:\n  def reverseKGroup(self, head: ListNode | None, k: int) -> ListNode | None:\n    if not head:\n      return None\n\n    tail = head\n\n    for _ in range(k):\n      # There are less than k nodes in the list, do nothing.\n      if not tail:\n        return head\n      tail = tail.next\n\n    newHead = self._reverse(head, tail)\n    head.next = self.reverseKGroup(tail, k)\n    return newHead\n\n  def _reverse(\n      self,\n      head: ListNode | None,\n      tail: ListNode | None,\n  ) -> ListNode | None:\n    \"\"\"Reverses [head, tail).\"\"\"\n    prev = None\n    curr = head\n    while curr != tail:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n    return prev",
      "title": "25. Reverse Nodes in k-Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b21e18c3-366e-4b35-b31a-a404cd276c60",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 1 or num > nums[i - 1]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "26. Remove Duplicates from Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a4bd36-9371-42ba-9dcf-3f19b49788d0",
      "code": "class Solution:\n  def removeElement(self, nums: list[int], val: int) -> int:\n    i = 0\n\n    for num in nums:\n      if num != val:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "27. Remove Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a232df0f-72ac-4a03-a845-3249d9f52d62",
      "code": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n    m = len(haystack)\n    n = len(needle)\n\n    for i in range(m - n + 1):\n      if haystack[i:i + n] == needle:\n        return i\n\n    return -1",
      "title": "28. Implement strStr()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e24e2be-ed78-4232-8e0e-75c29549559c",
      "code": "class Solution:\n  def divide(self, dividend: int, divisor: int) -> int:\n    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.\n    if dividend == -2**31 and divisor == -1:\n      return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n    ans = 0\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n\n    while dvd >= dvs:\n      k = 1\n      while k * 2 * dvs <= dvd:\n        k <<= 1\n      dvd -= k * dvs\n      ans += k\n\n    return sign * ans",
      "title": "29. Divide Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e5b006e-76ae-4867-a9ba-e30170e24869",
      "code": "class Solution:\n  def findSubstring(self, s: str, words: list[str]) -> list[int]:\n    if len(s) == 0 or words == []:\n      return []\n\n    k = len(words)\n    n = len(words[0])\n    ans = []\n    count = collections.Counter(words)\n\n    for i in range(len(s) - k * n + 1):\n      seen = collections.defaultdict(int)\n      j = 0\n      while j < k:\n        word = s[i + j * n: i + j * n + n]\n        seen[word] += 1\n        if seen[word] > count[word]:\n          break\n        j += 1\n      if j == k:\n        ans.append(i)\n\n    return ans",
      "title": "30. Substring with Concatenation of All Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e94ec310-8968-4f81-9ab5-f7ab23ebaca4",
      "code": "class Solution:\n  def nextPermutation(self, nums: list[int]) -> None:\n    n = len(nums)\n\n    # From back to front, find the first number < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From back to front, find the first number > nums[i], swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums: list[int], l: int, r: int) -> None:\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)",
      "title": "31. Next Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c19689d0-3fcf-47e8-884b-e3480ffa04f7",
      "code": "class Solution:\n  def longestValidParentheses(self, s: str) -> int:\n    s2 = ')' + s\n    # dp[i] := the length of the longest valid parentheses in the substring\n    # s2[1..i]\n    dp = [0] * len(s2)\n\n    for i in range(1, len(s2)):\n      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\n\n    return max(dp)",
      "title": "32. Longest Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8949e4f-150d-45f5-bffc-79e19b8f25de",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[l] <= nums[m]:  # nums[l..m] are sorted.\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted.\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return -1",
      "title": "33. Search in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0528df72-dfff-46ee-adae-1e4ada91cd3f",
      "code": "class Solution:\n  def searchRange(self, nums: list[int], target: int) -> list[int]:\n    l = bisect_left(nums, target)\n    if l == len(nums) or nums[l] != target:\n      return -1, -1\n    r = bisect_right(nums, target) - 1\n    return l, r",
      "title": "34. Find First and Last Position of Element in Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e46cfa9-16b9-478c-8980-8977aaae6a4d",
      "code": "class Solution:\n  def searchInsert(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[m] < target:\n        l = m + 1\n      else:\n        r = m\n\n    return l",
      "title": "35. Search Insert Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33e64c2f-5aef-49d4-83d3-ffed120c45a7",
      "code": "class Solution:\n  def isValidSudoku(self, board: list[list[str]]) -> bool:\n    seen = set()\n\n    for i in range(9):\n      for j in range(9):\n        c = board[i][j]\n        if c == '.':\n          continue\n        if (c + '@row ' + str(i) in seen or\n            c + '@col ' + str(j) in seen or\n                c + '@box ' + str(i // 3) + str(j // 3) in seen):\n          return False\n        seen.add(c + '@row ' + str(i))\n        seen.add(c + '@col ' + str(j))\n        seen.add(c + '@box ' + str(i // 3) + str(j // 3))\n\n    return True",
      "title": "36. Valid Sudoku",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8555029a-12fd-42a7-b63f-ad52eb29403b",
      "code": "class Solution:\n  def solveSudoku(self, board: list[list[str]]) -> None:\n    def isValid(row: int, col: int, c: str) -> bool:\n      for i in range(9):\n        if (board[i][col] == c or\n            board[row][i] == c or\n                board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c):\n          return False\n      return True\n\n    def solve(s: int) -> bool:\n      if s == 81:\n        return True\n\n      i = s // 9\n      j = s % 9\n\n      if board[i][j] != '.':\n        return solve(s + 1)\n\n      for c in string.digits[1:]:\n        if isValid(i, j, c):\n          board[i][j] = c\n          if solve(s + 1):\n            return True\n          board[i][j] = '.'\n\n      return False\n\n    solve(0)",
      "title": "37. Sudoku Solver",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b431edb2-07df-473a-a188-8c23f23a7ee4",
      "code": "class Solution:\n  def countAndSay(self, n: int) -> str:\n    ans = '1'\n\n    for _ in range(n - 1):\n      nxt = ''\n      i = 0\n      while i < len(ans):\n        count = 1\n        while i + 1 < len(ans) and ans[i] == ans[i + 1]:\n          count += 1\n          i += 1\n        nxt += str(count) + ans[i]\n        i += 1\n      ans = nxt\n\n    return ans",
      "title": "38. Count and Say",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5389f234-c415-415e-bb74-5abb9d8c28f6",
      "code": "class Solution:\n  def combinationSum(self, candidates: list[int],\n                     target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.clone())\n        return\n\n      for i in range(s, len(candidates)):\n        path.append(candidates[i])\n        dfs(i, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "39. Combination Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91b75fa7-ed34-4cb4-87e6-f7e2261e872f",
      "code": "class Solution:\n  def combinationSum2(self, candidates: list[int],\n                      target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, len(candidates)):\n        if i > s and candidates[i] == candidates[i - 1]:\n          continue\n        path.append(candidates[i])\n        dfs(i + 1, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "40. Combination Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5fbff2d6-e2ea-4fc8-a2a0-fa177ee81328",
      "code": "class Solution:\n  def firstMissingPositive(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    # Correct slot:\n    # nums[i] = i + 1\n    # nums[i] - 1 = i\n    # nums[nums[i] - 1] = nums[i]\n    for i in range(n):\n      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i, num in enumerate(nums):\n      if num != i + 1:\n        return i + 1\n\n    return n + 1",
      "title": "41. First Missing Positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60f3a2d4-8b3e-41d8-b9dc-ca37c4fc0b85",
      "code": "class Solution:\n  def trap(self, height: list[int]) -> int:\n    n = len(height)\n    l = [0] * n  # l[i] := max(height[0..i])\n    r = [0] * n  # r[i] := max(height[i..n))\n\n    for i, h in enumerate(height):\n      l[i] = h if i == 0 else max(h, l[i - 1])\n\n    for i, h in reversed(list(enumerate(height))):\n      r[i] = h if i == n - 1 else max(h, r[i + 1])\n\n    return sum(min(l[i], r[i]) - h\n               for i, h in enumerate(height))",
      "title": "42. Trapping Rain Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9acb55b8-cc34-484e-9a33-b5bb8b421078",
      "code": "class Solution:\n  def multiply(self, num1: str, num2: str) -> str:\n    s = [0] * (len(num1) + len(num2))\n\n    for i in reversed(range(len(num1))):\n      for j in reversed(range(len(num2))):\n        mult = int(num1[i]) * int(num2[j])\n        summ = mult + s[i + j + 1]\n        s[i + j] += summ // 10\n        s[i + j + 1] = summ % 10\n\n    for i, c in enumerate(s):\n      if c != 0:\n        break\n\n    return ''.join(map(str, s[i:]))",
      "title": "43. Multiply Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf02fbf9-0623-4a7d-b1b6-2ff623f083f5",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "44. Wildcard Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5692ed16-e095-48a8-a911-6781e317c096",
      "code": "class Solution:\n  def jump(self, nums: list[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Start an implicit BFS.\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level.\n        ans += 1        # Increment the level.\n        end = farthest  # Make the queue size for the next level.\n\n    return ans",
      "title": "45. Jump Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e650c94-2600-41cb-bdc2-4ae1b02d042a",
      "code": "class Solution:\n  def permute(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    dfs([])\n    return ans",
      "title": "46. Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8445a67-3bce-428a-9077-38e9117cf3b2",
      "code": "class Solution:\n  def permuteUnique(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "47. Permutations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e82a135-cb46-4761-b742-f1e973e38fbb",
      "code": "class Solution:\n  def rotate(self, matrix: list[list[int]]) -> None:\n    for mn in range(len(matrix) // 2):\n      mx = len(matrix) - mn - 1\n      for i in range(mn, mx):\n        offset = i - mn\n        top = matrix[mn][i]\n        matrix[mn][i] = matrix[mx - offset][mn]\n        matrix[mx - offset][mn] = matrix[mx][mx - offset]\n        matrix[mx][mx - offset] = matrix[i][mx]\n        matrix[i][mx] = top",
      "title": "48. Rotate Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dedbed0b-12dc-4d7f-9a84-1d6574b1de84",
      "code": "class Solution:\n  def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n    dict = collections.defaultdict(list)\n\n    for str in strs:\n      key = ''.join(sorted(str))\n      dict[key].append(str)\n\n    return dict.values()",
      "title": "49. Group Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3201cc6-1e51-4c80-a7b8-8adc757694f5",
      "code": "class Solution:\n  def myPow(self, x: float, n: int) -> float:\n    if n == 0:\n      return 1\n    if n < 0:\n      return 1 / self.myPow(x, -n)\n    if n % 2 == 1:\n      return x * self.myPow(x, n - 1)\n    return self.myPow(x * x, n // 2)",
      "title": "50. Pow(x, n)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3da9f614-6630-472b-9d74-d93bdc527276",
      "code": "class Solution:\n  def solveNQueens(self, n: int) -> list[list[str]]:\n    ans = []\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int, board: list[int]) -> None:\n      if i == n:\n        ans.append(board)\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0, [])\n    return ans",
      "title": "51. N-Queens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f217628a-f213-4730-be32-fe1a76532fbc",
      "code": "class Solution:\n  def totalNQueens(self, n: int) -> int:\n    ans = 0\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int) -> None:\n      nonlocal ans\n      if i == n:\n        ans += 1\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1)\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0)\n    return ans",
      "title": "52. N-Queens II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7133437f-946d-4819-8e4f-68091a8b703c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  # the sum of the subarray starting from the first number\n  maxSubarraySumLeft: int\n  # the sum of the subarray ending in the last number\n  maxSubarraySumRight: int\n  maxSubarraySum: int\n\n\nclass Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    def divideAndConquer(l: int, r: int) -> T:\n      if l == r:\n        return T(nums[l], nums[l], nums[l], nums[l])\n      m = (l + r) // 2\n      left = divideAndConquer(l, m)\n      right = divideAndConquer(m + 1, r)\n      maxSubarraySumLeft = max(left.maxSubarraySumLeft,\n                               left.summ + right.maxSubarraySumLeft)\n      maxSubarraySumRight = max(\n          left.maxSubarraySumRight + right.summ, right.maxSubarraySumRight)\n      maxSubarraySum = max(left.maxSubarraySumRight + right.maxSubarraySumLeft,\n                           left.maxSubarraySum, right.maxSubarraySum)\n      summ = left.summ + right.summ\n      return T(summ, maxSubarraySumLeft, maxSubarraySumRight, maxSubarraySum)\n\n    return divideAndConquer(0, len(nums) - 1).maxSubarraySum",
      "title": "53. Maximum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cf609bf-64b3-426b-bd4e-d6fcf6247b2d",
      "code": "class Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    # dp[i] := the maximum sum subarray ending in i\n    dp = [0] * len(nums)\n\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n      dp[i] = max(nums[i], dp[i - 1] + nums[i])\n\n    return max(dp)",
      "title": "53. Maximum Subarray_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "025604ee-4fdb-4ffc-8f8b-5c0e0148c89b",
      "code": "class Solution:\n  def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    # Repeatedly add matrix[r1..r2][c1..c2] to `ans`.\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans",
      "title": "54. Spiral Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca79a031-717f-445d-947c-0634b855c640",
      "code": "class Solution:\n  def canJump(self, nums: list[int]) -> bool:\n    i = 0\n    reach = 0\n\n    while i < len(nums) and i <= reach:\n      reach = max(reach, i + nums[i])\n      i += 1\n\n    return i == len(nums)",
      "title": "55. Jump Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f08c3f77-1f9c-408d-8ba6-646e85b02ca2",
      "code": "class Solution:\n  def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    for interval in sorted(intervals):\n      if not ans or ans[-1][1] < interval[0]:\n        ans.append(interval)\n      else:\n        ans[-1][1] = max(ans[-1][1], interval[1])\n\n    return ans",
      "title": "56. Merge Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaebc446-14d2-47b0-945b-02769d8deb3f",
      "code": "class Solution:\n  def insert(self, intervals: list[list[int]],\n             newInterval: list[int]) -> list[list[int]]:\n    n = len(intervals)\n    ans = []\n    i = 0\n\n    while i < n and intervals[i][1] < newInterval[0]:\n      ans.append(intervals[i])\n      i += 1\n\n    # Merge overlapping intervals.\n    while i < n and intervals[i][0] <= newInterval[1]:\n      newInterval[0] = min(newInterval[0], intervals[i][0])\n      newInterval[1] = max(newInterval[1], intervals[i][1])\n      i += 1\n\n    ans.append(newInterval)\n\n    while i < n:\n      ans.append(intervals[i])\n      i += 1\n\n    return ans",
      "title": "57. Insert Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eb7c3f2-6902-4e01-9bff-d7827e8377ed",
      "code": "class Solution:\n  def lengthOfLastWord(self, s: str) -> int:\n    i = len(s) - 1\n\n    while i >= 0 and s[i] == ' ':\n      i -= 1\n    lastIndex = i\n    while i >= 0 and s[i] != ' ':\n      i -= 1\n\n    return lastIndex - i",
      "title": "58. Length of Last Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7737d8ee-86ac-4bcf-9d4d-30d3c4dcc902",
      "code": "class Solution:\n  def generateMatrix(self, n: int) -> list[list[int]]:\n    ans = [[0] * n for _ in range(n)]\n    count = 1\n\n    for mn in range(n // 2):\n      mx = n - mn - 1\n      for i in range(mn, mx):\n        ans[mn][i] = count\n        count += 1\n      for i in range(mn, mx):\n        ans[i][mx] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[mx][i] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[i][mn] = count\n        count += 1\n\n    if n % 2 == 1:\n      ans[n // 2][n // 2] = count\n\n    return ans",
      "title": "59. Spiral Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "201ac450-b100-4572-8ae6-08290d45c6a6",
      "code": "class Solution:\n  def getPermutation(self, n: int, k: int) -> str:\n    ans = ''\n    nums = [i + 1 for i in range(n)]\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = fact[i - 1] * i\n\n    k -= 1  # 0-indexed\n\n    for i in reversed(range(n)):\n      j = k // fact[i]\n      k %= fact[i]\n      ans += str(nums[j])\n      nums.pop(j)\n\n    return ans",
      "title": "60. Permutation Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2853fd00-e3f6-47a9-9c7d-5cfebae4a9b5",
      "code": "class Solution:\n  def rotateRight(self, head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n      return head\n\n    tail = head\n    length = 1\n    while tail.next:\n      tail = tail.next\n      length += 1\n    tail.next = head  # Circle the list.\n\n    t = length - k % length\n    for _ in range(t):\n      tail = tail.next\n    newHead = tail.next\n    tail.next = None\n\n    return newHead",
      "title": "61. Rotate List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20d078d6-51c0-4a58-9aa7-4e9dc52af104",
      "code": "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]",
      "title": "62. Unique Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11855ed8-1a5c-435e-8b15-db8dbd271e29",
      "code": "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1  # Can also set dp[1][0] = 1.\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if obstacleGrid[i - 1][j - 1] == 0:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m][n]",
      "title": "63. Unique Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5623df2-7825-4bbb-98b4-06d5542996e0",
      "code": "class Solution:\n  def minPathSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if i > 0 and j > 0:\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        elif i > 0:\n          grid[i][0] += grid[i - 1][0]\n        elif j > 0:\n          grid[0][j] += grid[0][j - 1]\n\n    return grid[m - 1][n - 1]",
      "title": "64. Minimum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e29469dc-6238-4837-a9f8-7d60bb9daf51",
      "code": "class Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum",
      "title": "65. Valid Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1560bd2a-d12d-47cb-9500-5f94ecf15775",
      "code": "class Solution:\n  def plusOne(self, digits: list[int]) -> list[int]:\n    for i, d in reversed(list(enumerate(digits))):\n      if d < 9:\n        digits[i] += 1\n        return digits\n      digits[i] = 0\n\n    return [1] + digits",
      "title": "66. Plus One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9be81057-50b8-485c-bc34-0ab167e0c36b",
      "code": "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    ans = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      ans.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(reversed(ans))",
      "title": "67. Add Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b519032-d8f3-4479-b46b-27afc4d593a2",
      "code": "class Solution:\n  def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\n    ans = []\n    row = []\n    rowLetters = 0\n\n    for word in words:\n      # If we place the word in this row, it will exceed the maximum width.\n      # Therefore, we cannot put the word in this row and have to pad spaces\n      # for each word in this row.\n      if rowLetters + len(word) + len(row) > maxWidth:\n        for i in range(maxWidth - rowLetters):\n          row[i % (len(row) - 1 or 1)] += ' '\n        ans.append(''.join(row))\n        row = []\n        rowLetters = 0\n      row.append(word)\n      rowLetters += len(word)\n\n    return ans + [' '.join(row).ljust(maxWidth)]",
      "title": "68. Text Justification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29c67f1c-8b12-47f7-8acd-7e89f715b05a",
      "code": "class Solution:\n  def mySqrt(self, x: int) -> int:\n    return bisect.bisect_right(range(x + 1), x,\n                               key=lambda m: m * m) - 1",
      "title": "69. Sqrt(x)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fdb09a2-229d-4540-bd3c-9fac28876530",
      "code": "class Solution:\n  def climbStairs(self, n: int) -> int:\n    # dp[i] := the number of ways to climb to the i-th stair\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]",
      "title": "70. Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "423f9cda-c3ab-45bd-81af-d80b96e7ad6c",
      "code": "class Solution:\n  def simplifyPath(self, path: str) -> str:\n    stack = []\n\n    for str in path.split('/'):\n      if str in ('', '.'):\n        continue\n      if str == '..':\n        if stack:\n          stack.pop()\n      else:\n        stack.append(str)\n\n    return '/' + '/'.join(stack)",
      "title": "71. Simplify Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32b9c009-0b23-45ee-8c9c-0491d33578e2",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := the minimum number of operations to convert word1[0..i) to\n    # word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]",
      "title": "72. Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b46f7a6-d236-40d2-98df-510685b544ea",
      "code": "class Solution:\n  def setZeroes(self, matrix: list[list[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    # Store the information in the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    # Fill 0s for the matrix except the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    # Fill 0s for the first row if needed.\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    # Fill 0s for the first column if needed.\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0",
      "title": "73. Set Matrix Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8ed40a6-73a4-47d8-bf60-c7a7518f9e8f",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    if not matrix:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n    l = 0\n    r = m * n\n\n    while l < r:\n      mid = (l + r) // 2\n      i = mid // n\n      j = mid % n\n      if matrix[i][j] == target:\n        return True\n      if matrix[i][j] < target:\n        l = mid + 1\n      else:\n        r = mid\n\n    return False",
      "title": "74. Search a 2D Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0365c57-8240-4f95-a7e0-bf1c8be344b1",
      "code": "class Solution:\n  def sortColors(self, nums: list[int]) -> None:\n    l = 0  # The next 0 should be placed in l.\n    r = len(nums) - 1  # THe next 2 should be placed in r.\n\n    i = 0\n    while i <= r:\n      if nums[i] == 0:\n        nums[i], nums[l] = nums[l], nums[i]\n        i += 1\n        l += 1\n      elif nums[i] == 1:\n        i += 1\n      else:\n        # We may swap a 0 to index i, but we're still not sure whether this 0\n        # is placed in the correct index, so we can't move pointer i.\n        nums[i], nums[r] = nums[r], nums[i]\n        r -= 1",
      "title": "75. Sort Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f045b26e-7d64-4e42-a0cd-22f790af100b",
      "code": "class Solution:\n  def minWindow(self, s: str, t: str) -> str:\n    count = collections.Counter(t)\n    required = len(t)\n    bestLeft = -1\n    minLength = len(s) + 1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        count[s[l]] += 1\n        if count[s[l]] > 0:\n          required += 1\n        l += 1\n\n    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]",
      "title": "76. Minimum Window Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14c32f9c-7ff0-475b-9cdb-6ff3aa42a9a5",
      "code": "class Solution:\n  def combine(self, n: int, k: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) == k:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        path.append(i)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(1, [])\n    return ans",
      "title": "77. Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2e2bb2c-bca8-4f49-a34e-0e8b8e497d6d",
      "code": "class Solution:\n  def subsets(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n\n      for i in range(s, len(nums)):\n        dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "78. Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8f1a3fa-b88f-4177-b1ed-f940e88c74bb",
      "code": "class Solution:\n  def exist(self, board: list[list[str]], word: str) -> bool:\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int, s: int) -> bool:\n      if i < 0 or i == m or j < 0 or j == n:\n        return False\n      if board[i][j] != word[s] or board[i][j] == '*':\n        return False\n      if s == len(word) - 1:\n        return True\n\n      cache = board[i][j]\n      board[i][j] = '*'\n      isExist = (dfs(i + 1, j, s + 1) or\n                 dfs(i - 1, j, s + 1) or\n                 dfs(i, j + 1, s + 1) or\n                 dfs(i, j - 1, s + 1))\n      board[i][j] = cache\n\n      return isExist\n\n    return any(dfs(i, j, 0)\n               for i in range(m)\n               for j in range(n))",
      "title": "79. Word Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a8c1f30-f9d1-4bcf-9128-ce89109400a9",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 2 or num != nums[i - 2]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "80. Remove Duplicates from Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "430795e4-fd48-4da0-bfb2-55725510d7c4",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> bool:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return True\n      if nums[l] == nums[m] == nums[r]:\n        l += 1\n        r -= 1\n      elif nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return False",
      "title": "81. Search in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "517229d0-6b6a-44b1-9983-ceab153ee21f",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      while head.next and head.val == head.next.val:\n        head = head.next\n      if prev.next == head:\n        prev = prev.next\n      else:\n        prev.next = head.next\n      head = head.next\n\n    return dummy.next",
      "title": "82. Remove Duplicates from Sorted List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44f4edf1-1a94-4fce-a90b-18ca26cd874b",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    curr = head\n\n    while curr:\n      while curr.next and curr.val == curr.next.val:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return head",
      "title": "83. Remove Duplicates from Sorted List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1ca28ac-f52c-4c03-a554-5f57f296c381",
      "code": "class Solution:\n  def largestRectangleArea(self, heights: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(heights) + 1):\n      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n        h = heights[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans",
      "title": "84. Largest Rectangle in Histogram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6d42e00-fc27-447d-95d9-2af67fe4f41c",
      "code": "class Solution:\n  def maximalRectangle(self, matrix: list[list[str]]) -> int:\n    if not matrix:\n      return 0\n\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    def largestRectangleArea(heights: list[int]) -> int:\n      ans = 0\n      stack = []\n\n      for i in range(len(heights) + 1):\n        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n          h = heights[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n\n      return ans\n\n    for row in matrix:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == '0' else hist[i] + 1\n      ans = max(ans, largestRectangleArea(hist))\n\n    return ans",
      "title": "85. Maximal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d8394d0-5398-45e1-aa7d-f43558c12696",
      "code": "class Solution:\n  def partition(self, head: ListNode, x: int) -> ListNode:\n    beforeHead = ListNode(0)\n    afterHead = ListNode(0)\n    before = beforeHead\n    after = afterHead\n\n    while head:\n      if head.val < x:\n        before.next = head\n        before = head\n      else:\n        after.next = head\n        after = head\n      head = head.next\n\n    after.next = None\n    before.next = afterHead.next\n\n    return beforeHead.next",
      "title": "86. Partition List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68d59170-1843-465f-b068-c6b4a5b5dfe2",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def isScramble(self, s1: str, s2: str) -> bool:\n    if s1 == s2:\n      return True\n    if collections.Counter(s1) != collections.Counter(s2):\n      return False\n\n    for i in range(1, len(s1)):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if (self.isScramble(s1[:i], s2[len(s2) - i:]) and\n              self.isScramble(s1[i:], s2[: len(s2) - i])):\n        return True\n\n    return False",
      "title": "87. Scramble String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b172384d-b629-4dd3-b3af-4fefdf3f22d7",
      "code": "class Solution:\n  def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i = m - 1  # nums1's index (the actual nums)\n    j = n - 1  # nums2's index\n    k = m + n - 1  # nums1's index (the next filled position)\n\n    while j >= 0:\n      if i >= 0 and nums1[i] > nums2[j]:\n        nums1[k] = nums1[i]\n        k -= 1\n        i -= 1\n      else:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1",
      "title": "88. Merge Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09157de-8516-4049-a12e-bc7721bfb4c5",
      "code": "class Solution:\n  def grayCode(self, n: int) -> list[int]:\n    ans = [0]\n\n    for i in range(n):\n      for j in reversed(range(len(ans))):\n        ans.append(ans[j] | 1 << i)\n\n    return ans",
      "title": "89. Gray Code",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83695e87-8952-4e2f-9cf8-81ec8db2d999",
      "code": "class Solution:\n  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans",
      "title": "90. Subsets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e934a89f-caf0-4a29-aa56-01a74107db5a",
      "code": "class Solution:\n  def numDecodings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the number of ways to decode s[i..n)\n    dp = [0] * n + [1]\n\n    def isValid(a: str, b=None) -> bool:\n      if b:\n        return a == '1' or a == '2' and b < '7'\n      return a != '0'\n\n    if isValid(s[-1]):\n      dp[n - 1] = 1\n\n    for i in reversed(range(n - 1)):\n      if isValid(s[i]):\n        dp[i] += dp[i + 1]\n      if isValid(s[i], s[i + 1]):\n        dp[i] += dp[i + 2]\n\n    return dp[0]",
      "title": "91. Decode Ways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "906a5e5b-ff19-4056-a95d-3b019faa7797",
      "code": "class Solution:\n  def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n    if not head and m == n:\n      return head\n\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    for _ in range(m - 1):\n      prev = prev.next  # Point to the node before the sublist [m, n].\n\n    tail = prev.next  # Be the tail of the sublist [m, n].\n\n    # Reverse the sublist [m, n] one by one.\n    for _ in range(n - m):\n      cache = tail.next\n      tail.next = cache.next\n      cache.next = prev.next\n      prev.next = cache\n\n    return dummy.next",
      "title": "92. Reverse Linked List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdc4c12b-02cb-43b9-9163-2c764237f76a",
      "code": "class Solution:\n  def restoreIpAddresses(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(start: int, path: list[int]) -> None:\n      if len(path) == 4 and start == len(s):\n        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])\n        return\n      if len(path) == 4 or start == len(s):\n        return\n\n      for length in range(1, 4):\n        if start + length > len(s):\n          return  # out-of-bounds\n        if length > 1 and s[start] == '0':\n          return  # leading '0'\n        num = s[start: start + length]\n        if int(num) > 255:\n          return\n        dfs(start + length, path + [num])\n\n    dfs(0, [])\n    return ans",
      "title": "93. Restore IP Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07feb6b6-b68e-4f00-947c-a8bbd174f3ca",
      "code": "class Solution:\n  def inorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      ans.append(root.val)\n      root = root.right\n\n    return ans",
      "title": "94. Binary Tree Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd00940b-a1ab-4693-8988-fb8c0aeb6296",
      "code": "class Solution:\n  def generateTrees(self, n: int) -> list[TreeNode]:\n    if n == 0:\n      return []\n\n    def generateTrees(mn: int, mx: int) -> list[int | None]:\n      if mn > mx:\n        return [None]\n\n      ans = []\n\n      for i in range(mn, mx + 1):\n        for left in generateTrees(mn, i - 1):\n          for right in generateTrees(i + 1, mx):\n            ans.append(TreeNode(i))\n            ans[-1].left = left\n            ans[-1].right = right\n\n      return ans\n\n    return generateTrees(1, n)",
      "title": "95. Unique Binary Search Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79c12aac-9e73-45fd-abba-5febef02e0de",
      "code": "class Solution:\n  def numTrees(self, n: int) -> int:\n    # dp[i] := the number of unique BST's that store values 1..i\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]",
      "title": "96. Unique Binary Search Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50754af-6e86-4ac9-8ee6-21a13fd7040e",
      "code": "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    # s1[0..i) and s2[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or\n                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]",
      "title": "97. Interleaving String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43809cf7-d7bc-40ce-92f7-c509d288d342",
      "code": "class Solution:\n  def isValidBST(self, root: TreeNode | None) -> bool:\n    def isValidBST(root: TreeNode | None,\n                   minNode: TreeNode | None, maxNode: TreeNode | None) -> bool:\n      if not root:\n        return True\n      if minNode and root.val <= minNode.val:\n        return False\n      if maxNode and root.val >= maxNode.val:\n        return False\n\n      return (isValidBST(root.left, minNode, root) and\n              isValidBST(root.right, root, maxNode))\n\n    return isValidBST(root, None, None)",
      "title": "98. Validate Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18213318-9f9d-4e9f-a99e-e667fd78a814",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    pred = None\n    x = None  # the first wrong node\n    y = None  # the second wrong node\n\n    def findPredecessor(root: TreeNode | None) -> TreeNode | None:\n      pred = root.left\n      while pred.right and pred.right != root:\n        pred = pred.right\n      return pred\n\n    while root:\n      if root.left:\n        morrisPred = findPredecessor(root)\n        if morrisPred.right:\n          # The node has already been connected before.\n          # Start the main logic.\n          if pred and root.val < pred.val:\n            y = root\n            if not x:\n              x = pred\n          pred = root\n          # End of the main logic\n          morrisPred.right = None  # Break the connection.\n          root = root.right\n        else:\n          morrisPred.right = root  # Connect it.\n          root = root.left\n      else:\n        # Start the main logic.\n        if pred and root.val < pred.val:\n          y = root\n          if not x:\n            x = pred\n        pred = root\n        # End of the main logic.\n        root = root.right\n\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    swap(x, y)",
      "title": "99. Recover Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed939708-8332-47c8-87c8-dda8bb4c8dae",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n\n      if self.pred and root.val < self.pred.val:\n        self.y = root\n        if not self.x:\n          self.x = self.pred\n        else:\n          return\n      self.pred = root\n\n      inorder(root.right)\n\n    inorder(root)\n    swap(self.x, self.y)\n\n  pred = None\n  x = None  # the first wrong node\n  y = None  # the second wrong node",
      "title": "99. Recover Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "367a9e07-74e1-4d66-8b2c-5ffd5001df5d",
      "code": "class Solution:\n  def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\n    if not p or not q:\n      return p == q\n    return (p.val == q.val and\n            self.isSameTree(p.left, q.left) and\n            self.isSameTree(p.right, q.right))",
      "title": "100. Same Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87349fa4-bd1c-49a9-bf4a-ad06a6a6b2b6",
      "code": "class Solution:\n  def isSymmetric(self, root: TreeNode | None) -> bool:\n    def isSymmetric(p: TreeNode | None, q: TreeNode | None) -> bool:\n      if not p or not q:\n        return p == q\n      return (p.val == q.val and\n              isSymmetric(p.left, q.right) and\n              isSymmetric(p.right, q.left))\n\n    return isSymmetric(root, root)",
      "title": "101. Symmetric Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2de4d881-2557-4ee3-85e9-73dd2a2d9c83",
      "code": "class Solution:\n  def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans",
      "title": "102. Binary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d350ae27-63a7-4988-8d8d-5cbce6b7b3e8",
      "code": "class Solution:\n  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    dq = collections.deque([root])\n    isLeftToRight = True\n\n    while dq:\n      currLevel = []\n      for _ in range(len(dq)):\n        if isLeftToRight:\n          node = dq.popleft()\n          currLevel.append(node.val)\n          if node.left:\n            dq.append(node.left)\n          if node.right:\n            dq.append(node.right)\n        else:\n          node = dq.pop()\n          currLevel.append(node.val)\n          if node.right:\n            dq.appendleft(node.right)\n          if node.left:\n            dq.appendleft(node.left)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans",
      "title": "103. Binary Tree Zigzag Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47ee9aa1-4b1d-4bc6-8506-72db36204d21",
      "code": "class Solution:\n  def maxDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
      "title": "104. Maximum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7cf13a5-e044-4190-9a38-557c6a279563",
      "code": "class Solution:\n  def buildTree(\n      self,\n      preorder: list[int],\n      inorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        preStart: int,\n        preEnd: int,\n        inStart: int,\n        inEnd: int,\n    ) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n\n      rootVal = preorder[preStart]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        inStart, rootInIndex - 1)\n      root.right = build(preStart + leftSize + 1,\n                         preEnd, rootInIndex + 1, inEnd)\n      return root\n\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
      "title": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2aac25b-3aed-42eb-b922-84408d8f758c",
      "code": "class Solution:\n  def buildTree(\n      self,\n      inorder: list[int],\n      postorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        inStart: int,\n        inEnd: int,\n        postStart: int,\n        postEnd: int,\n    ) -> TreeNode | None:\n      if inStart > inEnd:\n        return None\n\n      rootVal = postorder[postEnd]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(inStart, rootInIndex - 1,  postStart,\n                        postStart + leftSize - 1)\n      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,\n                         postEnd - 1)\n      return root\n\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)",
      "title": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598e6b6d-6bd7-4e65-9c6c-b00fe02c73bd",
      "code": "class Solution:\n  def levelOrderBottom(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans[::-1]",
      "title": "107. Binary Tree Level Order Traversal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c815dfaa-eab4-49f8-93f3-24d437d58ebb",
      "code": "class Solution:\n  def sortedArrayToBST(self, nums: list[int]) -> TreeNode | None:\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "108. Convert Sorted Array to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f2c2812-cfde-4d8c-af45-ef8889a1c53d",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\n    def helper(l: int, r: int) -> TreeNode | None:\n      nonlocal head\n      if l > r:\n        return None\n\n      m = (l + r) // 2\n\n      # Simulate inorder traversal: recursively form the left half.\n      left = helper(l, m - 1)\n\n      # Once the left half is traversed, process the current node.\n      root = TreeNode(head.val)\n      root.left = left\n\n      # Maintain the invariance.\n      head = head.next\n\n      # Simulate inorder traversal: recursively form the right half.\n      root.right = helper(m + 1, r)\n      return root\n\n    return helper(0, self._getLength(head) - 1)\n\n  def _getLength(self, head: ListNode | None) -> int:\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n    return length",
      "title": "109. Convert Sorted List to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a49157f-7c60-4813-b8c3-878e3590f3af",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n    def findMid(head: ListNode) -> ListNode:\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    if not head:\n      return None\n    if not head.next:\n      return TreeNode(head.val)\n\n    mid = findMid(head)\n    root = TreeNode(mid.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(mid.next)\n    return root",
      "title": "109. Convert Sorted List to Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caa3402e-330e-4f27-99e5-2f3fb04c8a54",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    def maxDepth(root: TreeNode | None) -> int:\n      \"\"\"Returns the height of root if root is balanced; otherwise, returns -1.\"\"\"\n      if not root:\n        return 0\n\n      left = maxDepth(root.left)\n      if left == -1:\n        return -1\n      right = maxDepth(root.right)\n      if right == -1:\n        return -1\n      if abs(left - right) > 1:\n        return -1\n\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return maxDepth(root) != -1",
      "title": "110. Balanced Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53bba931-d3f6-4a0b-a229-6828e8e5f36d",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n\n    def maxDepth(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return (abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and\n            self.isBalanced(root.left) and\n            self.isBalanced(root.right))",
      "title": "110. Balanced Binary Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43d1cad2-1ee5-49ed-a9d7-0710bd9a5b9a",
      "code": "class Solution:\n  def minDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    q = collections.deque([root])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        node = q.popleft()\n        if not node.left and not node.right:\n          return step\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      step += 1",
      "title": "111. Minimum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15426c86-41bd-4f16-8637-c35b3346baea",
      "code": "class Solution:\n  def hasPathSum(self, root: TreeNode, summ: int) -> bool:\n    if not root:\n      return False\n    if root.val == summ and not root.left and not root.right:\n      return True\n    return (self.hasPathSum(root.left, summ - root.val) or\n            self.hasPathSum(root.right, summ - root.val))",
      "title": "112. Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eeddc1b5-956c-430b-88df-e59fef09264c",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(root: TreeNode, summ: int, path: list[int]) -> None:\n      if not root:\n        return\n      if root.val == summ and not root.left and not root.right:\n        ans.append(path + [root.val])\n        return\n\n      dfs(root.left, summ - root.val, path + [root.val])\n      dfs(root.right, summ - root.val, path + [root.val])\n\n    dfs(root, summ, [])\n    return ans",
      "title": "113. Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "803f808b-83bf-4861-88b0-6304570d4f25",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb70b9ed-157e-4a61-b55f-23329009675c",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4a95f49-9933-47b3-8fbb-dffbf627aa86",
      "code": "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n      dp[i][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]",
      "title": "115. Distinct Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9c074bb-0ee8-4ae1-b8fb-09568d4e642c",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node and node.left:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        needle.next = node.left\n        needle = needle.next\n        needle.next = node.right\n        needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "116. Populating Next Right Pointers in Each Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4997c447-5ec1-46c6-8540-9aa34aa03dc8",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        if node.left:  # Needle the left child.\n          needle.next = node.left\n          needle = needle.next\n        if node.right:  # Needle the right child.\n          needle.next = node.right\n          needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "117. Populating Next Right Pointers in Each Node II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "392068ec-509e-475c-a33d-4278fb793a8c",
      "code": "class Solution:\n  def generate(self, numRows: int) -> list[list[int]]:\n    ans = []\n\n    for i in range(numRows):\n      ans.append([1] * (i + 1))\n\n    for i in range(2, numRows):\n      for j in range(1, len(ans[i]) - 1):\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]\n\n    return ans",
      "title": "118. Pascal's Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1918292b-eb43-45d4-950d-97bff75aaaf8",
      "code": "class Solution:\n  def getRow(self, rowIndex: int) -> list[int]:\n    ans = [1] * (rowIndex + 1)\n\n    for i in range(2, rowIndex + 1):\n      for j in range(1, i):\n        ans[i - j] += ans[i - j - 1]\n\n    return ans",
      "title": "119. Pascal's Triangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "840751f8-836b-46fc-bdb6-a98b9608a16f",
      "code": "class Solution:\n  def minimumTotal(self, triangle: list[list[int]]) -> int:\n    for i in range(len(triangle) - 2, -1, -1):\n      for j in range(i + 1):\n        triangle[i][j] += min(triangle[i + 1][j],\n                              triangle[i + 1][j + 1])\n\n    return triangle[0][0]",
      "title": "120. Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d81f099f-b961-4d11-8f0c-10ea0cf96af7",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellOne",
      "title": "121. Best Time to Buy and Sell Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e7e64f9-33c5-46be-acbd-49e67b709856",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price)\n\n    return sell",
      "title": "122. Best Time to Buy and Sell Stock II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3b2c9e8-9152-4191-908e-e21573c2e590",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellTwo = 0\n    holdTwo = -math.inf\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellTwo = max(sellTwo, holdTwo + price)\n      holdTwo = max(holdTwo, sellOne - price)\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellTwo",
      "title": "123. Best Time to Buy and Sell Stock III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80518463-6df2-42ca-9ba0-627c58324913",
      "code": "class Solution:\n  def maxPathSum(self, root: TreeNode | None) -> int:\n    ans = -math.inf\n\n    def maxPathSumDownFrom(root: TreeNode | None) -> int:\n      \"\"\"\n      Returns the maximum path sum starting from the current root, where\n      root.val is always included.\n      \"\"\"\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = max(0, maxPathSumDownFrom(root.left))\n      r = max(0, maxPathSumDownFrom(root.right))\n      ans = max(ans, root.val + l + r)\n      return root.val + max(l, r)\n\n    maxPathSumDownFrom(root)\n    return ans",
      "title": "124. Binary Tree Maximum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e30e933-8130-46dc-9ac4-372b969e2c27",
      "code": "class Solution:\n  def isPalindrome(self, s: str) -> bool:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and not s[l].isalnum():\n        l += 1\n      while l < r and not s[r].isalnum():\n        r -= 1\n      if s[l].lower() != s[r].lower():\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "125. Valid Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1397ae60-84c6-4235-b55f-93953d8bc572",
      "code": "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: dict[str, list[str]] = collections.defaultdict(list)\n\n    # Build the graph from the beginWord to the endWord.\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordSet: set[str],\n      graph: dict[str, list[str]],\n  ) -> bool:\n    q1 = {beginWord}\n    q2 = {endWord}\n    backward = False\n\n    while q1 and q2:\n      for word in q1:\n        wordSet.discard(word)\n      for word in q2:\n        wordSet.discard(word)\n      # Always expand the smaller queue.\n      if len(q1) > len(q2):\n        q1, q2 = q2, q1\n        backward = not backward\n      q = set()\n      reachEndWord = False\n      for parent in q1:\n        for child in self._getChildren(parent, wordSet, q2):\n          if child in wordSet or child in q2:\n            q.add(child)\n            if backward:\n              graph[child].append(parent)\n            else:\n              graph[parent].append(child)\n          if child in q2:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      q1 = q\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: set[str], q2) -> list[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet or child in q2:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(\n      self,\n      graph: dict[str, list[str]],\n      word: str,\n      endWord: str,\n      path: list[str],\n      ans: list[list[str]],\n  ) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()",
      "title": "126. Word Ladder II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a8ef7f9-d826-48f9-b753-8d6eefdbe483",
      "code": "class Solution:\n  def ladderLength(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordList: list[str],\n  ) -> int:\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n      return 0\n\n    q = collections.deque([beginWord])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for i, cache in enumerate(wordList):\n          for c in string.ascii_lowercase:\n            wordList[i] = c\n            word = ''.join(wordList)\n            if word == endWord:\n              return step + 1\n            if word in wordSet:\n              q.append(word)\n              wordSet.remove(word)\n          wordList[i] = cache\n      step += 1\n\n    return 0",
      "title": "127. Word Ladder",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2516a5b-2520-4f3e-9a4d-9016a8831131",
      "code": "class Solution:\n  def longestConsecutive(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set(nums)\n\n    for num in seen:\n      # `num` is the start of a sequence.\n      if num - 1 in seen:\n        continue\n      length = 0\n      while num in seen:\n        num += 1\n        length += 1\n      ans = max(ans, length)\n\n    return ans",
      "title": "128. Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02e238b0-f986-4a4f-a639-0f415d0df5c8",
      "code": "class Solution:\n  def sumNumbers(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans += path * 10 + root.val\n        return\n\n      dfs(root.left, path * 10 + root.val)\n      dfs(root.right, path * 10 + root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "129. Sum Root to Leaf Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dcd7f2c-92e0-4e49-87d2-0750e89f5d02",
      "code": "class Solution:\n  def solve(self, board: list[list[str]]) -> None:\n    if not board:\n      return\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark the grids that stretch from the four sides with '*'.\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'",
      "title": "130. Surrounded Regions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ee5986a-b573-4090-b3da-fd0ee1ebb7f6",
      "code": "class Solution:\n  def partition(self, s: str) -> list[list[str]]:\n    ans = []\n\n    def isPalindrome(s: str) -> bool:\n      return s == s[::-1]\n\n    def dfs(s: str, j: int, path: list[str], ans: list[list[str]]) -> None:\n      if j == len(s):\n        ans.append(path)\n        return\n\n      for i in range(j, len(s)):\n        if isPalindrome(s[j: i + 1]):\n          dfs(s, i + 1, path + [s[j: i + 1]], ans)\n\n    dfs(s, 0, [], ans)\n    return ans",
      "title": "131. Palindrome Partitioning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92dcc061-a978-4026-ac51-1bc9e4127226",
      "code": "class Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    # isPalindrome[i][j] := True if s[i..j] is a palindrome\n    isPalindrome = [[True] * n for _ in range(n)]\n    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      # Try all the possible partitions.\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]",
      "title": "132. Palindrome Partitioning II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41c060cd-8ddd-44fe-bb99-1949b0c63ace",
      "code": "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n\n    q = collections.deque([node])\n    map = {node: Node(node.val)}\n\n    while q:\n      u = q.popleft()\n      for v in u.neighbors:\n        if v not in map:\n          map[v] = Node(v.val)\n          q.append(v)\n        map[u].neighbors.append(map[v])\n\n    return map[node]",
      "title": "133. Clone Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4df4983c-9bf3-4c84-a50a-6afdbeb8e086",
      "code": "class Solution:\n  def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n    ans = 0\n    net = 0\n    summ = 0\n\n    # Try to start from each index.\n    for i in range(len(gas)):\n      net += gas[i] - cost[i]\n      summ += gas[i] - cost[i]\n      if summ < 0:\n        summ = 0\n        ans = i + 1  # Start from the next index.\n\n    return -1 if net < 0 else ans",
      "title": "134. Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e824aed6-f1f8-49ac-ae5a-9f0bcaa7bb9d",
      "code": "class Solution:\n  def candy(self, ratings: list[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans",
      "title": "135. Candy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "427522a0-3bf3-4e86-ab9d-489068b2167d",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums, 0)",
      "title": "136. Single Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5d4c655-3060-4720-9859-a2fbfae4c81a",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= (num & ~twos)\n      twos ^= (num & ~ones)\n\n    return ones",
      "title": "137. Single Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fe5f3a1-22fa-4823-9bb9-86d0c5d272e3",
      "code": "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}",
      "title": "138. Copy List with Random Pointer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56161786-0c19-4f0c-8e98-b4d60bb48955",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a7c2501-8f6a-45c5-8d17-8ea3a82ebaf1",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29d4a2bf-09a1-497a-bf68-14cfd42cd5ab",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> bool:\n      \"\"\"Returns True if s can be segmented.\"\"\"\n      if s in wordSet:\n        return True\n      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))\n\n    return wordBreak(s)",
      "title": "139. Word Break_3",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9992c4e-cc4f-4a78-8720-82a765b8edd4",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> list[str]:\n      ans = []\n\n      # 1 <= len(prefix) < len(s)\n      for i in range(1, len(s)):\n        prefix = s[:i]\n        suffix = s[i:]\n        if prefix in wordSet:\n          for word in wordBreak(suffix):\n            ans.append(prefix + ' ' + word)\n\n      # `wordSet` contains the whole string s, so don't add any space.\n      if s in wordSet:\n        ans.append(s)\n\n      return ans\n\n    return wordBreak(s)",
      "title": "140. Word Break II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c776fbb2-33c6-48ff-abe3-c3b124f9fcc8",
      "code": "class Solution:\n  def hasCycle(self, head: ListNode) -> bool:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        return True\n\n    return False",
      "title": "141. Linked List Cycle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35163b6c-b435-4c70-8f0f-0eedca34a157",
      "code": "class Solution:\n  def detectCycle(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        slow = head\n        while slow != fast:\n          slow = slow.next\n          fast = fast.next\n        return slow\n\n    return None",
      "title": "142. Linked List Cycle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e7c251-3787-4fb3-8153-612ab0efefae",
      "code": "class Solution:\n  def reorderList(self, head: ListNode) -> None:\n    def findMid(head: ListNode):\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    def reverse(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    def merge(l1: ListNode, l2: ListNode) -> None:\n      while l2:\n        next = l1.next\n        l1.next = l2\n        l1 = l2\n        l2 = next\n\n    if not head or not head.next:\n      return\n\n    mid = findMid(head)\n    reversed = reverse(mid)\n    merge(head, reversed)",
      "title": "143. Reorder List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6946f0bd-189f-4afa-b9fa-e6a674b7a5dd",
      "code": "class Solution:\n  def preorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.right:\n        stack.append(node.right)\n      if node.left:\n        stack.append(node.left)\n\n    return ans",
      "title": "144. Binary Tree Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "215817d6-3f45-460a-a48a-da3ae5fcc8bf",
      "code": "class Solution:\n  def postorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.left:\n        stack.append(node.left)\n      if node.right:\n        stack.append(node.right)\n\n    return ans[::-1]",
      "title": "145. Binary Tree Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9190cf30-1ec9-4130-8ad6-28826a627dcd",
      "code": "class Solution:\n  def insertionSortList(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0)\n    prev = dummy  # the last and thus largest of the sorted list\n\n    while head:  # the current inserting node\n      next = head.next  # Cache the next inserting node.\n      if prev.val >= head.val:\n        prev = dummy  # Move `prev` to the front.\n      while prev.next and prev.next.val < head.val:\n        prev = prev.next\n      head.next = prev.next\n      prev.next = head\n      head = next  # Update the current inserting node.\n\n    return dummy.next",
      "title": "147. Insertion Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed6125a8-cfce-4ed1-b54c-f19d8c8cb9de",
      "code": "class Solution:\n  def sortList(self, head: ListNode) -> ListNode:\n    def split(head: ListNode, k: int) -> ListNode:\n      while k > 1 and head:\n        head = head.next\n        k -= 1\n      rest = head.next if head else None\n      if head:\n        head.next = None\n      return rest\n\n    def merge(l1: ListNode, l2: ListNode) -> tuple:\n      dummy = ListNode(0)\n      tail = dummy\n\n      while l1 and l2:\n        if l1.val > l2.val:\n          l1, l2 = l2, l1\n        tail.next = l1\n        l1 = l1.next\n        tail = tail.next\n      tail.next = l1 if l1 else l2\n      while tail.next:\n        tail = tail.next\n\n      return dummy.next, tail\n\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n\n    dummy = ListNode(0, head)\n\n    k = 1\n    while k < length:\n      curr = dummy.next\n      tail = dummy\n      while curr:\n        l = curr\n        r = split(l, k)\n        curr = split(r, k)\n        mergedHead, mergedTail = merge(l, r)\n        tail.next = mergedHead\n        tail = mergedTail\n      k *= 2\n\n    return dummy.next",
      "title": "148. Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bcdf89d-c08a-4a70-9545-591051af4a80",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i, p in enumerate(points):\n      slopeCount = collections.defaultdict(int)\n      samePoints = 1\n      maxPoints = 0  # the maximum number of points with the same slope\n      for j in range(i + 1, len(points)):\n        q = points[j]\n        if p == q:\n          samePoints += 1\n        else:\n          slope = getSlope(p, q)\n          slopeCount[slope] += 1\n          maxPoints = max(maxPoints, slopeCount[slope])\n      ans = max(ans, samePoints + maxPoints)\n\n    return ans",
      "title": "149. Max Points on a Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3118b47-7c2f-496f-bad2-228d238e8d77",
      "code": "class Solution:\n  def evalRPN(self, tokens: list[str]) -> int:\n    stack = []\n    op = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n      if token in op:\n        b = stack.pop()\n        a = stack.pop()\n        stack.append(op[token](a, b))\n      else:\n        stack.append(int(token))\n\n    return stack.pop()",
      "title": "150. Evaluate Reverse Polish Notation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2103d048-2a86-4a16-835a-ec934fb67ff1",
      "code": "class Solution:\n  def reverseWords(self, s: str) -> str:\n    return ' '.join(reversed(s.split()))",
      "title": "151. Reverse Words in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75486c12-405d-4870-8796-aa37a4d03c29",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    ans = nums[0]\n    dpMin = nums[0]  # the minimum so far\n    dpMax = nums[0]  # the maximum so far\n\n    for i in range(1, len(nums)):\n      num = nums[i]\n      prevMin = dpMin  # dpMin[i - 1]\n      prevMax = dpMax  # dpMax[i - 1]\n      if num < 0:\n        dpMin = min(prevMax * num, num)\n        dpMax = max(prevMin * num, num)\n      else:\n        dpMin = min(prevMin * num, num)\n        dpMax = max(prevMax * num, num)\n\n      ans = max(ans, dpMax)\n\n    return ans",
      "title": "152. Maximum Product Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58a927dc-0e2a-4b9b-b720-5b7d57ca7289",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "153. Find Minimum in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e553e538-3422-4995-a98a-47b40fde777d",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == nums[r]:\n        r -= 1\n      elif nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "154. Find Minimum in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9797d966-54a5-4e43-b389-d9100b48227a",
      "code": "class Solution:\n  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    prevRoot = None\n    prevRightChild = None\n\n    while root:\n      nextRoot = root.left  # Cache the next root.\n      root.left = prevRightChild\n      prevRightChild = root.right\n      root.right = prevRoot\n      prevRoot = root  # Record the previous root.\n      root = nextRoot  # Update the root.\n\n    return prevRoot",
      "title": "156. Binary Tree Upside Down",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf5643a-2599-4baa-8cd3-f486d856d001",
      "code": "\"\"\"\nThe read4 API is already defined for you.\n  def read4(buf4: list[str]) -> int:\n\n# Below is an example of how the read4 API can be called.\nfile = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # Read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # Read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # Read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\n\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    buf4 = [' '] * 4\n    i4 = 0  # buf4's index\n    n4 = 0  # buf4's size\n    i = 0  # buf's index\n\n    while i < n:\n      if i4 == n4:  # All the characters in the buf4 are consumed.\n        i4 = 0  # Reset the buf4's index.\n        n4 = read4(buf4)  # Read <= 4 characters from the file to the buf4.\n        if n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = buf4[i4]\n      i += 1\n      i4 += 1\n\n    return i",
      "title": "157. Read N Characters Given Read4",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73d51f47-2dd2-4e4d-9d9f-394879647ec5",
      "code": "# The read4 API is already defined for you.\n# Def read4(buf4: list[str]) -> int:\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    i = 0  # buf's index\n\n    while i < n:\n      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.\n        self.i4 = 0  # Reset the buf4's index.\n        # Read <= 4 characters from the file to the buf4.\n        self.n4 = read4(self.buf4)\n        if self.n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = self.buf4[self.i4]\n      i += 1\n      self.i4 += 1\n\n    return i\n\n  buf4 = [' '] * 4\n  i4 = 0  # buf4's index\n  n4 = 0  # buf4's size",
      "title": "158. Read N Characters Given Read4 II - Call multiple times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4e1a8f6-83aa-42f4-8a83-6e18c9b3aacc",
      "code": "class Solution:\n  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n    ans = 0\n    distinct = 0\n    count = [0] * 128\n\n    l = 0\n    for r, c in enumerate(s):\n      count[ord(c)] += 1\n      if count[ord(c)] == 1:\n        distinct += 1\n      while distinct == 3:\n        count[ord(s[l])] -= 1\n        if count[ord(s[l])] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "159. Longest Substring with At Most Two Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce642b58-e4f7-4ced-bdd0-1c199efcf156",
      "code": "class Solution:\n  def getIntersectionNode(\n      self,\n      headA: ListNode,\n      headB: ListNode,\n  ) -> ListNode | None:\n    a = headA\n    b = headB\n\n    while a != b:\n      a = a.next if a else headB\n      b = b.next if b else headA\n\n    return a",
      "title": "160. Intersection of Two Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "106aa79b-78ff-425b-b8f4-ab87b55e4c15",
      "code": "class Solution:\n  def isOneEditDistance(self, s: str, t: str) -> bool:\n    m = len(s)\n    n = len(t)\n    if m > n:  # Make sure that |s| <= |t|.\n      return self.isOneEditDistance(t, s)\n\n    for i in range(m):\n      if s[i] != t[i]:\n        if m == n:\n          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].\n        return s[i:] == t[i + 1:]  # Delete t[i].\n\n    return m + 1 == n  # Delete t[-1].",
      "title": "161. One Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6762dce-6ef1-48aa-9753-e2064927d66f",
      "code": "class Solution:\n  def findPeakElement(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] >= nums[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "162. Find Peak Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1533615e-079e-4e11-8f11-c038ef81b472",
      "code": "class Solution:\n  def findMissingRanges(\n      self,\n      nums: list[int],\n      lower: int,\n      upper: int,\n  ) -> list[list[int]]:\n    def getRange(lo: int, hi: int) -> list[int]:\n      if lo == hi:\n        return [lo, lo]\n      return [lo, hi]\n\n    if not nums:\n      return [getRange(lower, upper)]\n\n    ans = []\n\n    if nums[0] > lower:\n      ans.append(getRange(lower, nums[0] - 1))\n\n    for prev, curr in zip(nums, nums[1:]):\n      if curr > prev + 1:\n        ans.append(getRange(prev + 1, curr - 1))\n\n    if nums[-1] < upper:\n      ans.append(getRange(nums[-1] + 1, upper))\n\n    return ans",
      "title": "163. Missing Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50670932-2a7e-4393-bbe3-3070c6f1f8ea",
      "code": "class Bucket:\n  def __init__(self, mn: int, mx: int):\n    self.mn = mn\n    self.mx = mx\n\n\nclass Solution:\n  def maximumGap(self, nums: list[int]) -> int:\n    if len(nums) < 2:\n      return 0\n\n    mn = min(nums)\n    mx = max(nums)\n    if mn == mx:\n      return 0\n\n    gap = math.ceil((mx - mn) / (len(nums) - 1))\n    bucketSize = (mx - mn) // gap + 1\n    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]\n\n    for num in nums:\n      i = (num - mn) // gap\n      buckets[i].mn = min(buckets[i].mn, num)\n      buckets[i].mx = max(buckets[i].mx, num)\n\n    ans = 0\n    prevMax = mn\n\n    for bucket in buckets:\n      if bucket.mn == math.inf:\n        continue  # empty bucket\n      ans = max(ans, bucket.mn - prevMax)\n      prevMax = bucket.mx\n\n    return ans",
      "title": "164. Maximum Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97cb9bb3-dfa6-4343-bae0-b1769ddb89da",
      "code": "class Solution:\n  def compareVersion(self, version1: str, version2: str) -> int:\n    levels1 = version1.split('.')\n    levels2 = version2.split('.')\n    length = max(len(levels1), len(levels2))\n\n    for i in range(length):\n      v1 = int(levels1[i]) if i < len(levels1) else 0\n      v2 = int(levels2[i]) if i < len(levels2) else 0\n      if v1 < v2:\n        return -1\n      if v1 > v2:\n        return 1\n\n    return 0",
      "title": "165. Compare Version Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a2b72f6-6dd3-482f-a317-8d8a5fde8184",
      "code": "class Solution:\n  def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n    if numerator == 0:\n      return '0'\n\n    ans = ''\n\n    if (numerator < 0) ^ (denominator < 0):\n      ans += '-'\n\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    ans += str(numerator // denominator)\n\n    if numerator % denominator == 0:\n      return ans\n\n    ans += '.'\n    dict = {}\n\n    remainder = numerator % denominator\n    while remainder:\n      if remainder in dict:\n        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'\n        break\n      dict[remainder] = len(ans)\n      remainder *= 10\n      ans += str(remainder // denominator)\n      remainder %= denominator\n\n    return ans",
      "title": "166. Fraction to Recurring Decimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eab41ae4-6829-4df4-8ed1-af2536b3a962",
      "code": "class Solution:\n  def twoSum(self, numbers: list[int], target: int) -> list[int]:\n    l = 0\n    r = len(numbers) - 1\n\n    while l < r:\n      summ = numbers[l] + numbers[r]\n      if summ == target:\n        return [l + 1, r + 1]\n      if summ < target:\n        l += 1\n      else:\n        r -= 1",
      "title": "167. Two Sum II - Input array is sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66c6d61b-01ab-4c34-a80f-2d686999812f",
      "code": "class Solution:\n  def convertToTitle(self, n: int) -> str:\n    return (self.convertToTitle((n - 1) // 26) + chr(ord('A') + (n - 1) % 26)\n            if n\n            else '')",
      "title": "168. Excel Sheet Column Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34de4c09-7c26-4471-a09b-0256d717482f",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> int:\n    ans = None\n    count = 0\n\n    for num in nums:\n      if count == 0:\n        ans = num\n      count += (1 if num == ans else -1)\n\n    return ans",
      "title": "169. Majority Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a7c3f53-308f-4089-bd73-f301f450fc6c",
      "code": "class Solution:\n  def titleToNumber(self, columnTitle: str) -> int:\n    return functools.reduce(lambda subtotal, c:\n                            subtotal * 26 + ord(c) - ord('@'), columnTitle, 0)",
      "title": "171. Excel Sheet Column Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "422f9cfa-5ef6-4036-ba68-1ad9124b0ea0",
      "code": "class Solution:\n  def trailingZeroes(self, n: int) -> int:\n    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)",
      "title": "172. Factorial Trailing Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09d83126-1d3a-478a-a7f9-dc23a556cdf5",
      "code": "class Solution:\n  def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:\n    m = len(dungeon)\n    n = len(dungeon[0])\n    dp = [math.inf] * (n + 1)\n    dp[n - 1] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]\n        dp[j] = max(dp[j], 1)\n\n    return dp[0]",
      "title": "174. Dungeon Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcb5c90c-553f-400e-b3b3-06f8a5de544f",
      "code": "class LargerStrKey(str):\n  def __lt__(x: str, y: str) -> bool:\n    return x + y > y + x\n\n\nclass Solution:\n  def largestNumber(self, nums: list[int]) -> str:\n    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'",
      "title": "179. Largest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4287b91-cac5-48f1-862f-1223edcdf390",
      "code": "class Solution:\n  def reverseWords(self, s: list[str]) -> None:\n    def reverse(l: int, r: int) -> None:\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    def reverseWords(n: int) -> None:\n      i = 0\n      j = 0\n\n      while i < n:\n        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.\n          i += 1\n        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.\n          j += 1\n        reverse(i, j - 1)  # Reverse the word.\n\n    reverse(0, len(s) - 1)  # Reverse the whole string.\n    reverseWords(len(s))  # Reverse each word.",
      "title": "186. Reverse Words in a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c714d52-a46c-457d-aca5-62c40685ac0b",
      "code": "class Solution:\n  def findRepeatedDnaSequences(self, s: str) -> list[str]:\n    ans = set()\n    seen = set()\n\n    for i in range(len(s) - 9):\n      seq = s[i:i + 10]\n      if seq in seen:\n        ans.add(seq)\n      seen.add(seq)\n\n    return list(ans)",
      "title": "187. Repeated DNA Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbf6fe46-ad6e-4de1-b948-15adddd65cda",
      "code": "class Solution:\n  def maxProfit(self, k: int, prices: list[int]) -> int:\n    if k >= len(prices) // 2:\n      sell = 0\n      hold = -math.inf\n\n      for price in prices:\n        sell = max(sell, hold + price)\n        hold = max(hold, sell - price)\n\n      return sell\n\n    sell = [0] * (k + 1)\n    hold = [-math.inf] * (k + 1)\n\n    for price in prices:\n      for i in range(k, 0, -1):\n        sell[i] = max(sell[i], hold[i] + price)\n        hold[i] = max(hold[i], sell[i - 1] - price)\n\n    return sell[k]",
      "title": "188. Best Time to Buy and Sell Stock IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76fa8afc-cb61-4b50-a60e-6e5dc9a765cd",
      "code": "class Solution:\n  def rotate(self, nums: list[int], k: int) -> None:\n    k %= len(nums)\n    self.reverse(nums, 0, len(nums) - 1)\n    self.reverse(nums, 0, k - 1)\n    self.reverse(nums, k, len(nums) - 1)\n\n  def reverse(self, nums: list[int], l: int, r: int) -> None:\n    while l < r:\n      nums[l], nums[r] = nums[r], nums[l]\n      l += 1\n      r -= 1",
      "title": "189. Rotate Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "664f5f70-bc87-4fa2-a351-ab652e435d8f",
      "code": "class Solution:\n  def reverseBits(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if n >> i & 1:\n        ans |= 1 << 31 - i\n\n    return ans",
      "title": "190. Reverse Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddfa0763-d7dd-494d-804d-42f26a1729e3",
      "code": "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if (n >> i) & 1:\n        ans += 1\n\n    return ans",
      "title": "191. Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945e8531-ae2e-4bd9-b741-9ac0e19727ca",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) == 1:\n      return nums[0]\n\n    # dp[i]:= max money of robbing nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]",
      "title": "198. House Robber",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6a94c50-bf9d-4b38-af70-11c205487dc2",
      "code": "class Solution:\n  def rightSideView(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      size = len(q)\n      for i in range(size):\n        root = q.popleft()\n        if i == size - 1:\n          ans.append(root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n\n    return ans",
      "title": "199. Binary Tree Right Side View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d0dd5e-9fc3-4bd7-9330-cf6f16bff2f8",
      "code": "class Solution:\n  def numIslands(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def bfs(r, c):\n      q = collections.deque([(r, c)])\n      grid[r][c] = '2'  # Mark '2' as visited.\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] != '1':\n            continue\n          q.append((x, y))\n          grid[x][y] = '2'  # Mark '2' as visited.\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          bfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "200. Number of Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2402336-f166-4e13-9d5a-5a68fd36c952",
      "code": "class Solution:\n  def rangeBitwiseAnd(self, m: int, n: int) -> int:\n    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m",
      "title": "201. Bitwise AND of Numbers Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dd011e1-c8e1-4091-95d1-e15e7e5ecb6a",
      "code": "class Solution:\n  def isHappy(self, n: int) -> bool:\n    def squaredSum(n: int) -> bool:\n      summ = 0\n      while n > 0:\n        summ += pow(n % 10, 2)\n        n //= 10\n      return summ\n\n    slow = squaredSum(n)\n    fast = squaredSum(squaredSum(n))\n\n    while slow != fast:\n      slow = squaredSum(slow)\n      fast = squaredSum(squaredSum(fast))\n\n    return slow == 1",
      "title": "202. Happy Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dc07bf9-2e37-4d27-bac3-d220c46d1738",
      "code": "class Solution:\n  def removeElements(self, head: ListNode, val: int) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      if head.val != val:\n        prev.next = head\n        prev = prev.next\n      head = head.next\n    prev.next = None\n\n    return dummy.next",
      "title": "203. Remove Linked List Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea26c7ef-09dd-4210-835e-e194b82f06dc",
      "code": "class Solution:\n  def countPrimes(self, n: int) -> int:\n    if n <= 2:\n      return 0\n    return sum(self._sieveEratosthenes(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "204. Count Primes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "288f98fa-c6b6-4ff9-966a-30d2926679ab",
      "code": "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    return [*map(s.index, s)] == [*map(t.index, t)]",
      "title": "205. Isomorphic Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c1c4672-4e3f-41eb-829d-3b45bea547fe",
      "code": "class Solution:\n  def reverseList(self, head: ListNode | None) -> ListNode | None:\n    if not head or not head.next:\n      return head\n\n    newHead = self.reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return newHead",
      "title": "206. Reverse Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f3c0a6-0c2d-484f-bbfa-ed4b2da2966e",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not any(hasCycle(i) for i in range(numCourses))",
      "title": "207. Course Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9883339b-f5d6-44e0-976d-5bc72e219e1a",
      "code": "class Solution:\n  def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n    ans = math.inf\n    summ = 0\n    j = 0\n\n    for i, num in enumerate(nums):\n      summ += num\n      while summ >= target:\n        ans = min(ans, i - j + 1)\n        summ -= nums[j]\n        j += 1\n\n    return 0 if ans == math.inf else ans",
      "title": "209. Minimum Size Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b78c11f-8a02-4fb9-95d4-d82253bfed49",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def findOrder(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      ans.append(u)\n      return False\n\n    if any(hasCycle(i) for i in range(numCourses)):\n      return []\n\n    return ans[::-1]",
      "title": "210. Course Schedule II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fa99481-1383-45ef-b47e-76fc2d767f95",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n    m = len(board)\n    n = len(board[0])\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    for word in words:\n      insert(word)\n\n    def dfs(i: int, j: int, node: TrieNode) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] == '*':\n        return\n\n      c = board[i][j]\n      if c not in node.children:\n        return\n\n      child = node.children[c]\n      if child.word:\n        ans.append(child.word)\n        child.word = None\n\n      board[i][j] = '*'\n      dfs(i + 1, j, child)\n      dfs(i - 1, j, child)\n      dfs(i, j + 1, child)\n      dfs(i, j - 1, child)\n      board[i][j] = c\n\n    for i in range(m):\n      for j in range(n):\n        dfs(i, j, root)\n\n    return ans",
      "title": "212. Word Search II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f034317b-0f94-4756-9967-7a221085eb9b",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) < 2:\n      return nums[0]\n\n    def rob(l: int, r: int) -> int:\n      dp1 = 0\n      dp2 = 0\n\n      for i in range(l, r + 1):\n        temp = dp1\n        dp1 = max(dp1, dp2 + nums[i])\n        dp2 = temp\n\n      return dp1\n\n    return max(rob(0, len(nums) - 2),\n               rob(1, len(nums) - 1))",
      "title": "213. House Robber II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45fb8d2b-bcea-4f41-81b4-8fac3c03dc23",
      "code": "class Solution:\n  def shortestPalindrome(self, s: str) -> str:\n    t = s[::-1]\n\n    for i in range(len(t)):\n      if s.startswith(t[i:]):\n        return t[:i] + s\n\n    return t + s",
      "title": "214. Shortest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b72f869-9fe2-4ed5-bb86-b1d5dcc120f3",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "215. Kth Largest Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4221326d-6b9c-4420-9678-5fa838bf0b09",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, num)\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return minHeap[0]",
      "title": "215. Kth Largest Element in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "695c0525-4e14-4cf3-b48f-58469de8586a",
      "code": "class Solution:\n  def combinationSum3(self, k: int, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(k: int, n: int, s: int, path: list[int]) -> None:\n      if k == 0 and n == 0:\n        ans.append(path)\n        return\n      if k == 0 or n < 0:\n        return\n\n      for i in range(s, 10):\n        dfs(k - 1, n - i, i + 1, path + [i])\n\n    dfs(k, n, 1, [])\n    return ans",
      "title": "216. Combination Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2d79fcc-ce05-4681-87b3-77bd9a0761cf",
      "code": "class Solution:\n  def containsDuplicate(self, nums: list[int]) -> bool:\n    return len(nums) != len(set(nums))",
      "title": "217. Contains Duplicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad2fd495-1fd8-4c2e-a5bc-ba5f15223a90",
      "code": "class Solution:\n  def getSkyline(self, buildings: list[list[int]]) -> list[list[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: list[list[int]],\n             right: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # left's index\n    j = 0  # right's index\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      # Choose the powith smaller x\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]  # Update the ongoing `leftY`.\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]  # Update the ongoing `rightY`.\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: list[list[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])",
      "title": "218. The Skyline Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b14ab39f-a88a-4e05-84f0-2c0a62e0b21b",
      "code": "class Solution:\n  def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n    seen = set()\n\n    for i, num in enumerate(nums):\n      if i > k:\n        seen.remove(nums[i - k - 1])\n      if num in seen:\n        return True\n      seen.add(num)\n\n    return False",
      "title": "219. Contains Duplicate II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35656e97-e0e9-4bd5-9c6f-1a70a83f31a8",
      "code": "class Solution:\n  def containsNearbyAlmostDuplicate(\n      self,\n      nums: list[int],\n      indexDiff: int,\n      valueDiff: int,\n  ) -> bool:\n    if not nums or indexDiff <= 0 or valueDiff < 0:\n      return False\n\n    mn = min(nums)\n    diff = valueDiff + 1  # In case that `valueDiff` equals 0.\n    bucket = {}\n\n    def getKey(num: int) -> int:\n      return (num - mn) // diff\n\n    for i, num in enumerate(nums):\n      key = getKey(num)\n      if key in bucket:  # the current bucket\n        return True\n      # the left adjacent bucket\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\n        return True\n      # the right adjacent bucket\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\n        return True\n      bucket[key] = num\n      if i >= indexDiff:\n        del bucket[getKey(nums[i - indexDiff])]\n\n    return False",
      "title": "220. Contains Duplicate III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1696c6db-34b2-4431-9b86-35a8228596f4",
      "code": "class Solution:\n  def maximalSquare(self, matrix: list[list[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [0] * n\n    maxLength = 0\n    prev = 0  # dp[i - 1][j - 1]\n\n    for i in range(m):\n      for j in range(n):\n        cache = dp[j]\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[j] = min([prev, dp[j], dp[j - 1]]) + 1\n        maxLength = max(maxLength, dp[j])\n        prev = cache\n\n    return maxLength * maxLength",
      "title": "221. Maximal Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5103a98c-80d3-41e0-bb8a-cbccd1972e95",
      "code": "class Solution:\n  def countNodes(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    left = root\n    right = root\n    heightL = 0\n    heightR = 0\n\n    while left:\n      heightL += 1\n      left = left.left\n\n    while right:\n      heightR += 1\n      right = right.right\n\n    if heightL == heightR:  # `root` is a complete tree.\n      return pow(2, heightL) - 1\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)",
      "title": "222. Count Complete Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eaa45aeb-534a-415d-9bf1-3f98c69d0422",
      "code": "class Solution:\n  def computeArea(self,\n                  A: int, B: int, C: int, D: int,\n                  E: int, F: int, G: int, H: int) -> int:\n    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0\n    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y",
      "title": "223. Rectangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b2065cb-dff1-4119-9fa7-ed9e716725c3",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: the current environment's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + int(c)\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num",
      "title": "224. Basic Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d02b0ae-82f3-4a0b-a1a2-7d1030bc5d1a",
      "code": "class Solution:\n  def invertTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n\n    left = root.left\n    right = root.right\n    root.left = self.invertTree(right)\n    root.right = self.invertTree(left)\n    return root",
      "title": "226. Invert Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8024d60f-e364-4607-98a9-fe83e9dbfc98",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum",
      "title": "227. Basic Calculator II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57da6135-3073-444e-a268-b247847a0364",
      "code": "class Solution:\n  def summaryRanges(self, nums: list[int]) -> list[str]:\n    ans = []\n\n    i = 0\n    while i < len(nums):\n      begin = nums[i]\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n        i += 1\n      end = nums[i]\n      if begin == end:\n        ans.append(str(begin))\n      else:\n        ans.append(str(begin) + \"->\" + str(end))\n      i += 1\n\n    return ans",
      "title": "228. Summary Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c525ada7-6032-4426-8ccb-aa7ceed93fb0",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> list[int]:\n    ans1 = 0\n    ans2 = 1\n    count1 = 0\n    count2 = 0\n\n    for num in nums:\n      if num == ans1:\n        count1 += 1\n      elif num == ans2:\n        count2 += 1\n      elif count1 == 0:\n        ans1 = num\n        count1 = 1\n      elif count2 == 0:\n        ans2 = num\n        count2 = 1\n      else:\n        count1 -= 1\n        count2 -= 1\n\n    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]",
      "title": "229. Majority Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99edc922-069e-440c-8502-77ee27e9dc8f",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3df74e34-1006-4737-ac20-5e507f691f65",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a1d4bff-116c-40b4-8bb1-e8246912236c",
      "code": "class Solution:\n  def isPowerOfTwo(self, n: int) -> bool:\n    return n >= 0 and n.bit_count() == 1",
      "title": "231. Power of Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e3eb18-12b2-4888-ba02-2bcffa78f516",
      "code": "class Solution:\n  def countDigitOne(self, n: int) -> int:\n    ans = 0\n\n    pow10 = 1\n    while pow10 <= n:\n      divisor = pow10 * 10\n      quotient = n // divisor\n      remainder = n % divisor\n      if quotient > 0:\n        ans += quotient * pow10\n      if remainder >= pow10:\n        ans += min(remainder - pow10 + 1, pow10)\n      pow10 *= 10\n\n    return ans",
      "title": "233. Number of Digit One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "279bf1ed-2c41-45f4-8277-b7e51a250b5f",
      "code": "class Solution:\n  def isPalindrome(self, head: ListNode) -> bool:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n      return prev\n\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    if fast:\n      slow = slow.next\n    slow = reverseList(slow)\n\n    while slow:\n      if slow.val != head.val:\n        return False\n      slow = slow.next\n      head = head.next\n\n    return True",
      "title": "234. Palindrome Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afb4db38-d920-49f1-a42a-e4b12652e12e",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    if root.val > max(p.val, q.val):\n      return self.lowestCommonAncestor(root.left, p, q)\n    if root.val < min(p.val, q.val):\n      return self.lowestCommonAncestor(root.right, p, q)\n    return root",
      "title": "235. Lowest Common Ancestor of a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e188cf9-5928-4be0-872c-ce4ed53481b7",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n      q: TreeNode | None,\n  ) -> TreeNode | None:\n    q_ = collections.deque([root])\n    parent = {root: None}\n    ancestors = set()  # p's ancestors\n\n    # Iterate until we find both p and q.\n    while p not in parent or q not in parent:\n      root = q_.popleft()\n      if root.left:\n        parent[root.left] = root\n        q_.append(root.left)\n      if root.right:\n        parent[root.right] = root\n        q_.append(root.right)\n\n    # Insert all the p's ancestors.\n    while p:\n      ancestors.add(p)\n      p = parent[p]  # `p` becomes None in the end.\n\n    # Go up from q until we meet any of p's ancestors.\n    while q not in ancestors:\n      q = parent[q]\n\n    return q",
      "title": "236. Lowest Common Ancestor of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c2ae697-eb5a-4ab7-b856-8cf6e2fc7705",
      "code": "class Solution:\n  def deleteNode(self, node):\n    node.val = node.next.val\n    node.next = node.next.next",
      "title": "237. Delete Node in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bff05e85-1cf9-4173-a051-f447476c01fc",
      "code": "class Solution:\n  def productExceptSelf(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    prefix = [1] * n  # prefix product\n    suffix = [1] * n  # suffix product\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] * nums[i - 1]\n\n    for i in reversed(range(n - 1)):\n      suffix[i] = suffix[i + 1] * nums[i + 1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]",
      "title": "238. Product of Array Except Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "233e6514-699e-43d5-92d0-15e8d2773b66",
      "code": "class Solution:\n  def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    maxQ = collections.deque()\n\n    for i, num in enumerate(nums):\n      while maxQ and maxQ[-1] < num:\n        maxQ.pop()\n      maxQ.append(num)\n      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds\n        maxQ.popleft()\n      if i >= k - 1:\n        ans.append(maxQ[0])\n\n    return ans",
      "title": "239. Sliding Window Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c27d36ec-e669-4920-b256-7d2991e633a9",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    r = 0\n    c = len(matrix[0]) - 1\n\n    while r < len(matrix) and c >= 0:\n      if matrix[r][c] == target:\n        return True\n      if target < matrix[r][c]:\n        c -= 1\n      else:\n        r += 1\n\n    return False",
      "title": "240. Search a 2D Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce9f8a27-a84c-476c-87d1-c76bee5c2c6f",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def diffWaysToCompute(self, expression: str) -> list[int]:\n    ans = []\n\n    for i, c in enumerate(expression):\n      if c in '+-*':\n        for a in self.diffWaysToCompute(expression[:i]):\n          for b in self.diffWaysToCompute(expression[i + 1:]):\n            ans.append(eval(str(a) + c + str(b)))\n\n    return ans or [int(expression)]",
      "title": "241. Different Ways to Add Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb004fc2-edbc-47ec-9c0a-bc6e0edaf1a4",
      "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return all(freq == 0 for freq in count.values())",
      "title": "242. Valid Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "437a0a6a-90be-4876-8e74-59965d95ba6e",
      "code": "class Solution:\n  def shortestDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    ans = len(wordsDict)\n    index1 = -1  # wordsdict[index1] == word1\n    index2 = -1  # wordsdict[index2] == word2\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        index1 = i\n        if index2 != -1:\n          ans = min(ans, index1 - index2)\n      if word == word2:\n        index2 = i\n        if index1 != -1:\n          ans = min(ans, index2 - index1)\n\n    return ans",
      "title": "243. Shortest Word Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae76f03-18f8-42be-bd77-8335921e5d99",
      "code": "class Solution:\n  def shortestWordDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    isSame = word1 == word2\n    ans = math.inf\n    # If word1 == word2, index1 is the newest index.\n    index1 = len(wordsDict)\n    # If word1 == word2, index2 is the previous index.\n    index2 = -len(wordsDict)\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        if isSame:\n          index2 = index1\n        index1 = i\n      elif word == word2:\n        index2 = i\n      ans = min(ans, abs(index1 - index2))\n\n    return ans",
      "title": "245. Shortest Word Distance III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9845f677-2658-4e65-9251-9ad8cfa008eb",
      "code": "class Solution:\n  def isStrobogrammatic(self, num: str) -> bool:\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    l = 0\n    r = len(num) - 1\n\n    while l <= r:\n      if num[r] not in rotated:\n        return False\n      if num[l] != rotated[num[r]]:\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "246. Strobogrammatic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c73eb70-554c-4484-97d8-aaf0df1b4442",
      "code": "class Solution:\n  def findStrobogrammatic(self, n: int) -> list[str]:\n    def helper(n: int, k: int) -> list[str]:\n      if n == 0:\n        return ['']\n      if n == 1:\n        return ['0', '1', '8']\n\n      ans = []\n\n      for inner in helper(n - 2, k):\n        if n < k:\n          ans.append('0' + inner + '0')\n        ans.append('1' + inner + '1')\n        ans.append('6' + inner + '9')\n        ans.append('8' + inner + '8')\n        ans.append('9' + inner + '6')\n\n      return ans\n\n    return helper(n, n)",
      "title": "247. Strobogrammatic Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c67a9835-59a5-4eee-bb3d-74cabeb14d6f",
      "code": "class Solution:\n  def strobogrammaticInRange(self, low: str, high: str) -> int:\n    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]\n    ans = 0\n\n    def dfs(s: list[str], l: int, r: int) -> None:\n      nonlocal ans\n      if l > r:\n        if len(s) == len(low) and ''.join(s) < low:\n          return\n        if len(s) == len(high) and ''.join(s) > high:\n          return\n        ans += 1\n        return\n\n      for leftDigit, rightDigit in pairs:\n        if l == r and leftDigit != rightDigit:\n          continue\n        s[l] = leftDigit\n        s[r] = rightDigit\n        if len(s) > 1 and s[0] == '0':\n          continue\n        dfs(s, l + 1, r - 1)\n\n    for n in range(len(low), len(high) + 1):\n      dfs([' '] * n, 0, n - 1)\n\n    return ans",
      "title": "248. Strobogrammatic Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15c9167c-b2ca-4b14-be92-60aa8e0ee059",
      "code": "class Solution:\n  def groupStrings(self, strings: list[str]) -> list[list[str]]:\n    keyToStrings = collections.defaultdict(list)\n\n    def getKey(s: str) -> str:\n      \"\"\"\n      Returns the key of 's' by pairwise calculation of differences.\n      e.g. getKey(\"abc\") -> \"1,1\" because diff(a, b) = 1 and diff(b, c) = 1.\n      \"\"\"\n      diffs = []\n\n      for i in range(1, len(s)):\n        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26\n        diffs.append(str(diff))\n\n      return ','.join(diffs)\n\n    for s in strings:\n      keyToStrings[getKey(s)].append(s)\n\n    return keyToStrings.values()",
      "title": "249. Group Shifted Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50a22a84-11c2-4b05-94a4-0d488bcc874e",
      "code": "class Solution:\n  def countUnivalSubtrees(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def isUnival(root: TreeNode | None, val: int) -> bool:\n      nonlocal ans\n      if not root:\n        return True\n\n      if isUnival(root.left, root.val) & isUnival(root.right, root.val):\n        ans += 1\n        return root.val == val\n\n      return False\n\n    isUnival(root, math.inf)\n    return ans",
      "title": "250. Count Univalue Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bbead22-67cd-49f6-ac1e-aeaa8a16860d",
      "code": "class Solution:\n  def canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n      if intervals[i - 1][1] > intervals[i][0]:\n        return False\n\n    return True",
      "title": "252. Meeting Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7effda12-ef3f-4dcc-aefe-3c331d60f7e1",
      "code": "class Solution:\n  def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n    n = len(intervals)\n    ans = 0\n    starts = []\n    ends = []\n\n    for start, end in intervals:\n      starts.append(start)\n      ends.append(end)\n\n    starts.sort()\n    ends.sort()\n\n    j = 0\n    for i in range(n):\n      if starts[i] < ends[j]:\n        ans += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "253. Meeting Rooms II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0278197f-6431-42af-8906-cc3882a8b267",
      "code": "class Solution:\n  def getFactors(self, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(n: int, s: int, path: list[int]) -> None:\n      if n <= 1:\n        if len(path) > 1:\n          ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        if n % i == 0:\n          path.append(i)\n          dfs(n // i, i, path)\n          path.pop()\n\n    dfs(n, 2, [])  # The minimum factor is 2.\n    return ans",
      "title": "254. Factor Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2b2c8fd-1c68-4ca8-9b88-e384d87048f6",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f778186e-0aa1-45bc-8547-ff58573c5f20",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7de7baa-bb1e-441e-aedc-2d4c373e2c9d",
      "code": "class Solution:\n  def minCost(self, costs: list[list[int]]) -> list[list[int]]:\n    for i in range(1, len(costs)):\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n    return min(costs[-1])",
      "title": "256. Paint House",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a074e863-b12a-4967-bb68-0882063190db",
      "code": "class Solution:\n  def binaryTreePaths(self, root: TreeNode | None) -> list[str]:\n    ans = []\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans.append(''.join(path) + str(root.val))\n        return\n\n      path.append(str(root.val) + '->')\n      dfs(root.left, path)\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(root, [])\n    return ans",
      "title": "257. Binary Tree Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f87a94bb-bf27-4040-a5cc-b572d1824bf3",
      "code": "class Solution:\n  def addDigits(self, num: int) -> int:\n    return 0 if num == 0 else 1 + (num - 1) % 9",
      "title": "258. Add Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "712c44f9-071f-482f-a877-283da4a18274",
      "code": "class Solution:\n  def threeSumSmaller(self, nums: list[int], target: int) -> int:\n    if len(nums) < 3:\n      return 0\n\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        if nums[i] + nums[l] + nums[r] < target:\n          # (nums[i], nums[l], nums[r])\n          # (nums[i], nums[l], nums[r - 1])\n          # ...,\n          # (nums[i], nums[l], nums[l + 1])\n          ans += r - l\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "259. 3Sum Smaller",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06e2e02f-20da-4715-83e8-f8c3c8221dc0",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> list[int]:\n    xors = functools.reduce(operator.xor, nums)\n    lowbit = xors & -xors\n    ans = [0, 0]\n\n    # Seperate `nums` into two groups by `lowbit`.\n    for num in nums:\n      if num & lowbit:\n        ans[0] ^= num\n      else:\n        ans[1] ^= num\n\n    return ans",
      "title": "260. Single Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16284fe3-f3c4-446c-af29-7248327fb1b6",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validTree(self, n: int, edges: list[list[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count == 1",
      "title": "261. Graph Valid Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ed154fa-d1de-4eaf-859d-db802805e1d2",
      "code": "class Solution:\n  def isUgly(self, n: int) -> bool:\n    if n == 0:\n      return False\n\n    for prime in 2, 3, 5:\n      while n % prime == 0:\n        n //= prime\n\n    return n == 1",
      "title": "263. Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbe65846-de0f-47b8-8096-7e2e92c84bd8",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int) -> int:\n    nums = [1]\n    i2 = 0\n    i3 = 0\n    i5 = 0\n\n    while len(nums) < n:\n      next2 = nums[i2] * 2\n      next3 = nums[i3] * 3\n      next5 = nums[i5] * 5\n      next = min(next2, next3, next5)\n      if next == next2:\n        i2 += 1\n      if next == next3:\n        i3 += 1\n      if next == next5:\n        i5 += 1\n      nums.append(next)\n\n    return nums[-1]",
      "title": "264. Ugly Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36c4fb34-3625-408b-84d2-3711be39709d",
      "code": "class Solution:\n  def minCostII(self, costs: list[list[int]]) -> int:\n    prevIndex = -1  # the previous minimum index\n    prevMin1 = 0  # the minimum cost so far\n    prevMin2 = 0  # the second minimum cost so far\n\n    for cost in costs:  # O(n)\n      # the painted index that will achieve the minimum cost after painting the\n      # current house\n      index = -1\n      # the minimum cost after painting the current house\n      min1 = math.inf\n      # the second minimum cost after painting the current house\n      min2 = math.inf\n      for i, cst in enumerate(cost):   # O(k)\n        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)\n        if theCost < min1:\n          index = i\n          min2 = min1\n          min1 = theCost\n        elif theCost < min2:  # min1 <= theCost < min2\n          min2 = theCost\n\n      prevIndex = index\n      prevMin1 = min1\n      prevMin2 = min2\n\n    return prevMin1",
      "title": "265. Paint House II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64adc4a2-31bd-40f4-83a6-22ba8dd634ab",
      "code": "class Solution:\n  def canPermutePalindrome(self, s: str) -> bool:\n    seen = set()\n\n    for c in s:\n      if c in seen:\n        seen.remove(c)\n      else:\n        seen.add(c)\n\n    return len(seen) <= 1",
      "title": "266. Palindrome Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e67d4e13-4de4-40b1-8272-7d8fb8ffb7c9",
      "code": "class Solution:\n  def generatePalindromes(self, s: str) -> list[str]:\n    count = collections.Counter(s)\n\n    # Count odd ones.\n    odd = sum(value & 1 for value in count.values())\n\n    # Can't form any palindrome.\n    if odd > 1:\n      return []\n\n    ans = []\n    candidates = []\n    mid = ''\n\n    # Get the mid and the candidates characters.\n    for key, value in count.items():\n      if value % 2 == 1:\n        mid += key\n      for _ in range(value // 2):\n        candidates.append(key)\n\n    def dfs(used: list[bool], path: list[str]) -> None:\n      \"\"\"Generates all the unique palindromes from the candidates.\"\"\"\n      if len(path) == len(candidates):\n        ans.append(''.join(path) + mid + ''.join(reversed(path)))\n        return\n\n      for i, candidate in enumerate(candidates):\n        if used[i]:\n          continue\n        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(candidate)\n        dfs(used, path)\n        path.pop()\n        used[i] = False\n\n    # Backtrack to generate the ans strings.\n    dfs([False] * len(candidates), [])\n    return ans",
      "title": "267. Palindrome Permutation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70a692cf-8d03-4c4a-af0a-d797dfa3984f",
      "code": "class Solution:\n  def missingNumber(self, nums: list[int]) -> int:\n    ans = len(nums)\n\n    for i, num in enumerate(nums):\n      ans ^= i ^ num\n\n    return ans",
      "title": "268. Missing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "767aae46-2901-463e-b0c1-60cee8b5d792",
      "code": "class Solution:\n  def alienOrder(self, words: list[str]) -> str:\n    graph = {}\n    inDegrees = [0] * 26\n\n    self._buildGraph(graph, words, inDegrees)\n    return self._topology(graph, inDegrees)\n\n  def _buildGraph(\n      self,\n      graph: dict[str, set[str]],\n      words: list[str],\n      inDegrees: list[int],\n  ) -> None:\n    # Create a node for each character in each word.\n    for word in words:\n      for c in word:\n        if c not in graph:\n          graph[c] = set()\n\n    for first, second in zip(words, words[1:]):\n      length = min(len(first), len(second))\n      for j in range(length):\n        u = first[j]\n        v = second[j]\n        if u != v:\n          if v not in graph[u]:\n            graph[u].add(v)\n            inDegrees[ord(v) - ord('a')] += 1\n          break  # The order of characters after this are meaningless.\n        # First = 'ab', second = 'a' . invalid\n        if j == length - 1 and len(first) > len(second):\n          graph.clear()\n          return\n\n  def _topology(self, graph: dict[str, set[str]], inDegrees: list[int]) -> str:\n    s = ''\n    q = collections.deque()\n\n    for c in graph:\n      if inDegrees[ord(c) - ord('a')] == 0:\n        q.append(c)\n\n    while q:\n      u = q.pop()\n      s += u\n      for v in graph[u]:\n        inDegrees[ord(v) - ord('a')] -= 1\n        if inDegrees[ord(v) - ord('a')] == 0:\n          q.append(v)\n\n    # Words = ['z', 'x', 'y', 'x']\n    return s if len(s) == len(graph) else ''",
      "title": "269. Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93829a64-3b89-49b5-b69f-d580e9295ecd",
      "code": "class Solution:\n  def closestValue(self, root: TreeNode | None, target: float) -> int:\n    # If target < root.val, search the left subtree.\n    if target < root.val and root.left:\n      left = self.closestValue(root.left, target)\n      if abs(left - target) <= abs(root.val - target):\n        return left\n\n    # If target > root.val, search the right subtree.\n    if target > root.val and root.right:\n      right = self.closestValue(root.right, target)\n      if abs(right - target) < abs(root.val - target):\n        return right\n\n    return root.val",
      "title": "270. Closest Binary Search Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "913c5428-3ec9-4ab8-96a0-70bf349cbc30",
      "code": "class Solution:\n  def closestKValues(\n      self,\n      root: TreeNode | None,\n      target: float,\n      k: int,\n  ) -> list[int]:\n    dq = collections.deque()\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      dq.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    while len(dq) > k:\n      if abs(dq[0] - target) > abs(dq[-1] - target):\n        dq.popleft()\n      else:\n        dq.pop()\n\n    return list(dq)",
      "title": "272. Closest Binary Search Tree Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8470a994-da90-4893-a331-579efa8a8999",
      "code": "class Solution:\n  def numberToWords(self, num: int) -> str:\n    if num == 0:\n      return 'Zero'\n\n    belowTwenty = ['',        'One',       'Two',      'Three',\n                   'Four',    'Five',      'Six',      'Seven',\n                   'Eight',   'Nine',      'Ten',      'Eleven',\n                   'Twelve',  'Thirteen',  'Fourteen', 'Fifteen',\n                   'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n    tens = ['',      'Ten',   'Twenty',  'Thirty', 'Forty',\n            'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n\n    def helper(num: int) -> str:\n      if num < 20:\n        s = belowTwenty[num]\n      elif num < 100:\n        s = tens[num // 10] + ' ' + belowTwenty[num % 10]\n      elif num < 1000:\n        s = helper(num // 100) + ' Hundred ' + helper(num % 100)\n      elif num < 1000000:\n        s = helper(num // 1000) + ' Thousand ' + helper(num % 1000)\n      elif num < 1000000000:\n        s = helper(num // 1000000) + ' Million ' + helper(num % 1000000)\n      else:\n        s = helper(num // 1000000000) + ' Billion ' + helper(num % 1000000000)\n      return s.strip()\n\n    return helper(num)",
      "title": "273. Integer to English Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76c93dd1-dc92-4df3-a975-d17c239df8e7",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    accumulate = 0\n    count = [0] * (n + 1)\n\n    for citation in citations:\n      count[min(citation, n)] += 1\n\n    # To find the maximum h-index, loop from the back to the front.\n    # i := the candidate's h-index\n    for i, c in reversed(list(enumerate(count))):\n      accumulate += c\n      if accumulate >= i:\n        return i",
      "title": "274. H-Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a114f353-250c-4142-92bc-1d19005bd502",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    return n - bisect.bisect_left(range(n), n,\n                                  key=lambda m: citations[m] + m)",
      "title": "275. H-Index II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5b733cb-eb51-4c19-8f2b-68e137e1c0e6",
      "code": "class Solution:\n  def numWays(self, n: int, k: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return k\n    if n == 2:\n      return k * k\n\n    # dp[i] := the number of ways to pan posts with k colors\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]",
      "title": "276. Paint Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af650ea7-467e-4b4b-ac00-9862277eb779",
      "code": "# The knows API is already defined for you.\n# Returns a bool, whether a knows b\n# Def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n  def findCelebrity(self, n: int) -> int:\n    candidate = 0\n\n    # Everyone knows the celebrity.\n    for i in range(1, n):\n      if knows(candidate, i):\n        candidate = i\n\n    # The candidate knows nobody and everyone knows the celebrity.\n    for i in range(n):\n      if i < candidate and knows(candidate, i) or not knows(i, candidate):\n        return -1\n      if i > candidate and not knows(i, candidate):\n        return -1\n\n    return candidate",
      "title": "277. Find the Celebrity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52878086-6d33-4861-af43-310e7691a9e4",
      "code": "class Solution:\n  def firstBadVersion(self, n: int) -> int:\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r) >> 1\n      if isBadVersion(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "278. First Bad Version",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c231ef8a-35f5-4989-992f-3dec996cf5a4",
      "code": "class Solution:\n  def numSquares(self, n: int) -> int:\n    dp = [n] * (n + 1)  # 1^2 x n\n    dp[0] = 0  # no way\n    dp[1] = 1  # 1^2\n\n    for i in range(2, n + 1):\n      j = 1\n      while j * j <= i:\n        dp[i] = min(dp[i], dp[i - j * j] + 1)\n        j += 1\n\n    return dp[n]",
      "title": "279. Perfect Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f5f6759-5fb7-47c7-a714-df8beea42d0a",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    # 1. If i is even, then nums[i] <= nums[i - 1].\n    # 2. If i is odd, then nums[i] >= nums[i - 1].\n    for i in range(1, len(nums)):\n      if (i % 2 == 0 and nums[i] > nums[i - 1] or\n              i % 2 == 1 and nums[i] < nums[i - 1]):\n        nums[i], nums[i - 1] = nums[i - 1], nums[i]",
      "title": "280. Wiggle Sort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17ff9b90-fb00-4844-8acb-777da9f17841",
      "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> list[str]:\n    ans = []\n\n    def dfs(start: int, prev: int, eval: int, path: list[str]) -> None:\n      if start == len(num):\n        if eval == target:\n          ans.append(''.join(path))\n        return\n\n      for i in range(start, len(num)):\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    dfs(0, 0, 0, [])\n    return ans",
      "title": "282. Expression Add Operators",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86c8a4e8-29e7-40c4-af3f-4535eeca770b",
      "code": "class Solution:\n  def moveZeroes(self, nums: list[int]) -> None:\n    j = 0\n    for num in nums:\n      if num != 0:\n        nums[j] = num\n        j += 1\n\n    for i in range(j, len(nums)):\n      nums[i] = 0",
      "title": "283. Move Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce718833-ce38-496a-aee6-c92e0053df4e",
      "code": "class Solution:\n  def inorderSuccessor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val <= p.val:\n      return self.inorderSuccessor(root.right, p)\n    return self.inorderSuccessor(root.left, p) or root",
      "title": "285. Inorder Successor in BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba27fa50-8e12-4038-9d45-54f574a960d1",
      "code": "class Solution:\n  def wallsAndGates(self, rooms: list[list[int]]) -> None:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    INF = 2**31 - 1\n    m = len(rooms)\n    n = len(rooms[0])\n    q = collections.deque((i, j)\n                          for i in range(m)\n                          for j in range(n)\n                          if rooms[i][j] == 0)\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if rooms[x][y] != INF:\n          continue\n        rooms[x][y] = rooms[i][j] + 1\n        q.append((x, y))",
      "title": "286. Walls and Gates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b2e9b5a-999f-47d4-be69-0b2368423b0d",
      "code": "class Solution:\n  def findDuplicate(self, nums: list[int]) -> int:\n    slow = nums[nums[0]]\n    fast = nums[nums[nums[0]]]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[nums[fast]]\n\n    slow = nums[0]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[fast]\n\n    return slow",
      "title": "287. Find the Duplicate Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51a24e4a-8738-49d7-bd19-048c1275a2ee",
      "code": "class Solution:\n  def gameOfLife(self, board: list[list[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n        # Any live cell with two or three live neighbors lives on to the next\n        # generation.\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n        # Any dead cell with exactly three live neighbors becomes a live cell,\n        # as if by reproduction.\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1",
      "title": "289. Game of Life",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd1bc09-e433-44aa-8450-df0c7f9cc2ca",
      "code": "class Solution:\n  def wordPattern(self, pattern: str, str: str) -> bool:\n    t = str.split()\n    return [*map(pattern.index, pattern)] == [*map(t.index, t)]",
      "title": "290. Word Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd93f10-7444-4d86-bfad-0da6278409b2",
      "code": "class Solution:\n  def wordPatternMatch(self, pattern: str, s: str) -> bool:\n    def isMatch(\n            i: int, j: int, charToString: dict[str, str],\n            seen: set[str]) -> bool:\n      if i == len(pattern) and j == len(s):\n        return True\n      if i == len(pattern) or j == len(s):\n        return False\n\n      c = pattern[i]\n\n      if c in charToString:\n        t = charToString[c]\n        # See if we can match t with s[j..n).\n        if t not in s[j:]:\n          return False\n\n        # If there's a match, continue to match the rest.\n        return isMatch(i + 1, j + len(t), charToString, seen)\n\n      for k in range(j, len(s)):\n        t = s[j:k + 1]\n\n        # This string is mapped by another character.\n        if t in seen:\n          continue\n\n        charToString[c] = t\n        seen.add(t)\n\n        if isMatch(i + 1, k + 1, charToString, seen):\n          return True\n\n        # Backtrack.\n        del charToString[c]\n        seen.remove(t)\n\n      return False\n\n    return isMatch(0, 0, {}, set())",
      "title": "291. Word Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84e7be0a-bd56-4af3-b3e6-f483e8fcace1",
      "code": "class Solution:\n  def canWinNim(self, n: int) -> bool:\n    return n % 4 != 0",
      "title": "292. Nim Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bae97c0-1108-44e2-b763-03672ce9875b",
      "code": "class Solution:\n  def generatePossibleNextMoves(self, currentState: str) -> list[str]:\n    return [currentState[:i] + '--' + currentState[i + 2:]\n            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n            if a == '+' and b == '+']",
      "title": "293. Flip Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c21d8ee1-1534-47b8-86ff-566cf907ee01",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def canWin(self, currentState: str) -> bool:\n    # If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    # changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win.\n    return any(True\n               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n               if a == '+' and b == '+' and\n               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))",
      "title": "294. Flip Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1b1d303-9178-46c4-87a1-2e29b82ffc2b",
      "code": "class Solution:\n  def minTotalDistance(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # i indices s.t. grid[i][j] == 1\n    I = [i for i in range(m) for j in range(n) if grid[i][j]]\n    # j indices s.t. grid[i][j] == 1\n    J = [j for j in range(n) for i in range(m) if grid[i][j]]\n\n    def minTotalDistance(grid: list[int]) -> int:\n      summ = 0\n      i = 0\n      j = len(grid) - 1\n      while i < j:\n        summ += grid[j] - grid[i]\n        i += 1\n        j -= 1\n      return summ\n\n    # sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J)",
      "title": "296. Best Meeting Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ac267c2-0497-480b-8d89-7c2e5d0537a1",
      "code": "class Solution:\n  def longestConsecutive(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode | None, target: int, length: int, maxLength: int) -> int:\n      if not root:\n        return maxLength\n      if root.val == target:\n        length += 1\n        maxLength = max(maxLength, length)\n      else:\n        length = 1\n      return max(dfs(root.left, root.val + 1, length, maxLength),\n                 dfs(root.right, root.val + 1, length, maxLength))\n\n    return dfs(root, root.val, 0, 0)",
      "title": "298. Binary Tree Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d5e58b4-9bff-4241-9132-86fc5400b897",
      "code": "class Solution:\n  def getHint(self, secret: str, guess: str) -> str:\n    bulls = sum(map(operator.eq, secret, guess))\n    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\n    return '%dA%dB' % (bulls, bovine - bulls)",
      "title": "299. Bulls and Cows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03871deb-ea23-4ce6-ba7d-f349044043a8",
      "code": "class Solution:\n  def lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n\n    return len(tails)",
      "title": "300. Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8622ac09-0db9-46e2-a139-6f979eaec0be",
      "code": "class Solution:\n  def removeInvalidParentheses(self, s: str) -> list[str]:\n    # Similar to 921. Minimum Add to Make Parentheses Valid\n    def getLeftAndRightCounts(s: str) -> tuple[int, int]:\n      \"\"\"Returns how many '(' and ')' need to be deleted.\"\"\"\n      l = 0\n      r = 0\n\n      for c in s:\n        if c == '(':\n          l += 1\n        elif c == ')':\n          if l == 0:\n            r += 1\n          else:\n            l -= 1\n\n      return l, r\n\n    def isValid(s: str):\n      opened = 0  # the number of '(' - # of ')'\n      for c in s:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened < 0:\n          return False\n      return True  # opened == 0\n\n    ans = []\n\n    def dfs(s: str, start: int, l: int, r: int) -> None:\n      if l == 0 and r == 0 and isValid(s):\n        ans.append(s)\n        return\n\n      for i in range(start, len(s)):\n        if i > start and s[i] == s[i - 1]:\n          continue\n        if r > 0 and s[i] == ')':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\n        elif l > 0 and s[i] == '(':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\n\n    l, r = getLeftAndRightCounts(s)\n    dfs(s, 0, l, r)\n    return ans",
      "title": "301. Remove Invalid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d21f5a5a-ac63-4919-bfdb-337885caa341",
      "code": "class Solution:\n  def minArea(self, image: list[list[str]], x: int, y: int) -> int:\n    def firstAnyOne(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          l = m + 1\n        else:\n          r = m\n      return l\n\n    def firstAllZeros(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def colAllZeros(colIndex: int) -> bool:\n      return all(pixel == '0' for pixel in list(zip(*image))[colIndex])\n\n    def rowAllZeros(rowIndex: int) -> bool:\n      return all(pixel == '0' for pixel in image[rowIndex])\n\n    x1 = firstAnyOne(0, x, rowAllZeros)\n    x2 = firstAllZeros(x + 1, len(image), rowAllZeros)\n    y1 = firstAnyOne(0, y, colAllZeros)\n    y2 = firstAllZeros(y + 1, len(image[0]), colAllZeros)\n    return (x2 - x1) * (y2 - y1)",
      "title": "302. Smallest Rectangle Enclosing Black Pixels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8de16525-0571-4a6a-97a8-405363c14298",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = [-1] * n\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numIslands2(\n      self,\n      m: int,\n      n: int,\n      positions: list[list[int]],\n  ) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    seen = [[False] * n for _ in range(m)]\n    uf = UnionFind(m * n)\n    count = 0\n\n    def getId(i: int, j: int, n: int) -> int:\n      return i * n + j\n\n    for i, j in positions:\n      if seen[i][j]:\n        ans.append(count)\n        continue\n      seen[i][j] = True\n      id = getId(i, j, n)\n      uf.id[id] = id\n      count += 1\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        neighborId = getId(x, y, n)\n        if uf.id[neighborId] == -1:  # water\n          continue\n        currentParent = uf.find(id)\n        neighborParent = uf.find(neighborId)\n        if currentParent != neighborParent:\n          uf.unionByRank(currentParent, neighborParent)\n          count -= 1\n      ans.append(count)\n\n    return ans",
      "title": "305. Number of Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b427b90-a6bb-4697-b7bc-602b6d4c6a87",
      "code": "class Solution:\n  def isAdditiveNumber(self, num: str) -> bool:\n    n = len(num)\n\n    def dfs(firstNum: int, secondNum: int, s: int) -> bool:\n      if s == len(num):\n        return True\n\n      thirdNum = firstNum + secondNum\n      thirdNumStr = str(thirdNum)\n\n      return (num.find(thirdNumStr, s) == s and\n              dfs(secondNum, thirdNum, s + len(thirdNumStr)))\n\n    # num[0..i] = firstNum\n    for i in range(n // 2):\n      if i > 0 and num[0] == '0':\n        return False\n      firstNum = int(num[:i + 1])\n      # num[i + 1..j] = secondNum\n      # |thirdNum| >= max(|firstNum|, |secondNum|)\n      j = i + 1\n      while max(i, j - i) < n - j:\n        if j > i + 1 and num[i + 1] == '0':\n          break\n        secondNum = int(num[i + 1:j + 1])\n        if dfs(firstNum, secondNum, j + 1):\n          return True\n        j += 1\n\n    return False",
      "title": "306. Additive Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd02907f-cfa5-40e6-acfa-ce10a573f800",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n    prev = 0\n\n    for price in prices:\n      cache = sell\n      sell = max(sell, hold + price)\n      hold = max(hold, prev - price)\n      prev = cache\n\n    return sell",
      "title": "309. Best Time to Buy and Sell Stock with Cooldown",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4af3e9a-cead-4b14-8136-456fb99bd9f4",
      "code": "class Solution:\n  def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans",
      "title": "310. Minimum Height Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eafaf276-db88-4237-91f6-7a9595cf8422",
      "code": "class Solution:\n  def multiply(self, mat1: list[list[int]],\n               mat2: list[list[int]]) -> list[list[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n    nonZeroColIndicesInMat2 = [\n        [j for j, a in enumerate(row) if a]\n        for row in mat2\n    ]\n\n    for i in range(m):\n      for j, a in enumerate(mat1[i]):\n        if a == 0:\n          continue\n        # mat1s j-th column matches mat2's j-th row\n        for colIndex in nonZeroColIndicesInMat2[j]:\n          ans[i][colIndex] += a * mat2[j][colIndex]\n\n    return ans",
      "title": "311. Sparse Matrix Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cde2fff3-d91e-4845-9851-c221c2831d54",
      "code": "class Solution:\n  def maxCoins(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i][j] := maxCoins(nums[i..j])\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    nums = [1] + nums + [1]\n\n    for d in range(n):\n      for i in range(1, n - d + 1):\n        j = i + d\n        for k in range(i, j + 1):\n          dp[i][j] = max(\n              dp[i][j],\n              dp[i][k - 1] +\n              dp[k + 1][j] +\n              nums[i - 1] * nums[k] * nums[j + 1])\n\n    return dp[1][n]",
      "title": "312. Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33f07df1-d7e8-45be-929a-a670dbcaf183",
      "code": "class UglyNum:\n  def __init__(self, prime: int, index: int, value: int):\n    self.prime = prime\n    self.index = index  # Point the next index of uglyNums.\n    self.value = value  # prime * uglyNums[index]\n\n\nclass Solution:\n  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n    minHeap = []  # (value, prime, index)\n    uglyNums = [1]\n\n    for prime in primes:\n      heapq.heappush(minHeap, (prime * uglyNums[0], prime, 1))\n\n    while len(uglyNums) < n:\n      uglyNums.append(minHeap[0][0])\n      while minHeap[0][0] == uglyNums[-1]:\n        _, prime, index = heapq.heappop(minHeap)\n        heapq.heappush(minHeap, (prime * uglyNums[index], prime, index + 1))\n\n    return uglyNums[-1]",
      "title": "313. Super Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae29c815-7853-4949-b38c-1c40e4d2e36b",
      "code": "class Solution:\n  def verticalOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    range_ = [0] * 2\n\n    def getRange(root: TreeNode | None, x: int) -> None:\n      if not root:\n        return\n\n      range_[0] = min(range_[0], x)\n      range_[1] = max(range_[1], x)\n\n      getRange(root.left, x - 1)\n      getRange(root.right, x + 1)\n\n    getRange(root, 0)  # Get the leftmost and the rightmost x index.\n\n    ans = [[] for _ in range(range_[1] - range_[0] + 1)]\n    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)\n\n    while q:\n      node, x = q.popleft()\n      ans[x].append(node.val)\n      if node.left:\n        q.append((node.left, x - 1))\n      if node.right:\n        q.append((node.right, x + 1))\n\n    return ans",
      "title": "314. Binary Tree Vertical Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f92d137-5f82-4a98-ab5e-4088dcf36d71",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Item:\n  num: int = 0\n  index: int = 0\n\n\nclass Solution:\n  def countSmaller(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    items = [Item(num, i) for i, num in enumerate(nums)]\n\n    self._mergeSort(items, 0, n - 1, ans)\n    return ans\n\n  def _mergeSort(\n      self,\n      items: list[Item],\n      l: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(items, l, m, ans)\n    self._mergeSort(items, m + 1, r, ans)\n    self._merge(items, l, m, r, ans)\n\n  def _merge(\n      self,\n      items: list[Item],\n      l: int,\n      m: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    sorted = [Item()] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n    rightCount = 0  # the number of numbers < items[i].num\n\n    while i <= m and j <= r:\n      if items[i].num > items[j].num:\n        rightCount += 1\n        sorted[k] = items[j]\n        k += 1\n        j += 1\n      else:\n        ans[items[i].index] += rightCount\n        sorted[k] = items[i]\n        k += 1\n        i += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      ans[items[i].index] += rightCount\n      sorted[k] = items[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = items[j]\n      k += 1\n      j += 1\n\n    items[l:l + len(sorted)] = sorted",
      "title": "315. Count of Smaller Numbers After Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1310ef03-6b91-428e-9647-1506287125e5",
      "code": "class Solution:\n  def removeDuplicateLetters(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    used = [False] * 26\n\n    for c in s:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "316. Remove Duplicate Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f978847-0711-4d99-a678-54c46e1809a1",
      "code": "class Solution:\n  def shortestDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nBuildings = sum(a == 1 for row in grid for a in row)\n    ans = math.inf\n    # dist[i][j] := the total distance of grid[i][j] (0) to reach all the\n    # buildings (1)\n    dist = [[0] * n for _ in range(m)]\n    # reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach\n    reachCount = [[0] * n for _ in range(m)]\n\n    def bfs(row: int, col: int) -> bool:\n      q = collections.deque([(row, col)])\n      seen = {(row, col)}\n      seenBuildings = 1\n\n      step = 1\n      while q:\n        for _ in range(len(q)):\n          i, j = q.popleft()\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x == m or y < 0 or y == n:\n              continue\n            if (x, y) in seen:\n              continue\n            seen.add((x, y))\n            if not grid[x][y]:\n              dist[x][y] += step\n              reachCount[x][y] += 1\n              q.append((x, y))\n            elif grid[x][y] == 1:\n              seenBuildings += 1\n        step += 1\n\n      # True if all the buildings (1) are connected\n      return seenBuildings == nBuildings\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:  # BFS from this building.\n          if not bfs(i, j):\n            return -1\n\n    for i in range(m):\n      for j in range(n):\n        if reachCount[i][j] == nBuildings:\n          ans = min(ans, dist[i][j])\n\n    return -1 if ans == math.inf else ans",
      "title": "317. Shortest Distance from All Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33432b81-ed31-4970-ba45-eb5d4748f0c2",
      "code": "class Solution:\n  def maxProduct(self, words: list[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(words)):\n      for j in range(i):\n        if not (masks[i] & masks[j]):\n          ans = max(ans, len(words[i]) * len(words[j]))\n\n    return ans",
      "title": "318. Maximum Product of Word Lengths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff71c02c-11aa-4053-81f7-69f65f108d2c",
      "code": "class Solution:\n  def bulbSwitch(self, n: int) -> int:\n    # The k-th bulb can only be switched when k % i == 0.\n    # So, we can rephrase the problem:\n    # To find number of numbers <= n that have odd factors.\n    # Obviously, only square numbers have odd factor(s).\n    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return math.isqrt(n)",
      "title": "319. Bulb Switcher",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e7be37e-f86b-490a-a6ed-92147ff47f5e",
      "code": "class Solution:\n  def generateAbbreviations(self, word: str) -> list[str]:\n    ans = []\n\n    def getCountString(count: int) -> str:\n      return str(count) if count > 0 else ''\n\n    def dfs(i: int, count: int, path: list[str]) -> None:\n      if i == len(word):\n        ans.append(''.join(path) + getCountString(count))\n        return\n\n      # Abbreviate the word[i].\n      dfs(i + 1, count + 1, path)\n      # Keep the word[i], so consume the count as a string.\n      path.append(getCountString(count) + word[i])\n      # Reset the count to 0.\n      dfs(i + 1, 0, path)\n      path.pop()\n\n    dfs(0, 0, [])\n    return ans",
      "title": "320. Generalized Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d9f3a0-6b18-4825-8ba8-060f5f4f7141",
      "code": "class Solution:\n  def maxNumber(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    def maxArray(nums: list[int], k: int) -> list[int]:\n      res = []\n      toTop = len(nums) - k\n      for num in nums:\n        while res and res[-1] < num and toTop > 0:\n          res.pop()\n          toTop -= 1\n        res.append(num)\n      return res[:k]\n\n    def merge(nums1: list[int], nums2: list[int]) -> list[int]:\n      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))",
      "title": "321. Create Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "815b9ff9-d849-493a-84b8-18a847756e30",
      "code": "class Solution:\n  def coinChange(self, coins: list[int], amount: int) -> int:\n    # dp[i] := the minimum number Of coins to make up i\n    dp = [0] + [amount + 1] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return -1 if dp[amount] == amount + 1 else dp[amount]",
      "title": "322. Coin Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b3f579d-c426-42a6-a69f-bbffc3125f5c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count",
      "title": "323. Number of Connected Components in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a405d45c-0e9c-4a5c-8243-d9fc7317f4f3",
      "code": "class Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(node: int, seen: set[int]) -> None:\n      q = collections.deque([node])\n      seen.add(node)\n\n      while q:\n        u = q.pop()\n        for v in graph[u]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for i in range(n):\n      if i not in seen:\n        bfs(i, seen)\n        ans += 1\n\n    return ans",
      "title": "323. Number of Connected Components in an Undirected Graph_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57d3c739-0b5b-41dd-a58f-66903f59012a",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    n = len(nums)\n    median = self._findKthLargest(nums, (n + 1) // 2)\n\n    def A(i: int):\n      return (1 + 2 * i) % (n | 1)\n\n    i = 0\n    j = 0\n    k = n - 1\n\n    while i <= k:\n      if nums[A(i)] > median:\n        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]\n        i, j = i + 1, j + 1\n      elif nums[A(i)] < median:\n        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]\n        k -= 1\n      else:\n        i += 1\n\n  # Same as 215. Kth Largest Element in an Array\n  def _findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "324. Wiggle Sort II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "509ae45f-c9f6-4a61-8c4a-f2bcd49c2b87",
      "code": "class Solution:\n  def maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        ans = max(ans, i - prefixToIndex[target])\n      if prefix not in prefixToIndex:\n        prefixToIndex[prefix] = i\n\n    return ans",
      "title": "325. Maximum Size Subarray Sum Equals k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7f9600a-7899-4950-8610-48cdca1e9ae6",
      "code": "class Solution:\n  def isPowerOfThree(self, n: int) -> bool:\n    return n > 0 and 3**19 % n == 0",
      "title": "326. Power of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0216cdb5-2ddb-4440-a3e3-ffa5a54fa274",
      "code": "class Solution:\n  def countRangeSum(self, nums: list[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(\n      self,\n      prefix: list[int],\n      l: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(\n      self,\n      prefix: list[int],\n      l: int,\n      m: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    lo = m + 1  # the first index s.t. prefix[lo] - prefix[i] >= lower\n    hi = m + 1  # the first index s.t. prefix[hi] - prefix[i] > upper\n\n    # For each index i in range [l, m], add hi - lo to `ans`.\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted",
      "title": "327. Count of Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2116cf48-6955-49ef-b777-d3b044da1ae1",
      "code": "class Solution:\n  def oddEvenList(self, head: ListNode) -> ListNode:\n    oddHead = ListNode(0)\n    evenHead = ListNode(0)\n    odd = oddHead\n    even = evenHead\n    isOdd = True\n\n    while head:\n      if isOdd:\n        odd.next = head\n        odd = head\n      else:\n        even.next = head\n        even = head\n      head = head.next\n      isOdd = not isOdd\n\n    even.next = None\n    odd.next = evenHead.next\n    return oddHead.next",
      "title": "328. Odd Even Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26b055de-2e14-4452-9d98-4f15a9be4720",
      "code": "class Solution:\n  def longestIncreasingPath(self, matrix: list[list[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, prev: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 0\n      if matrix[i][j] <= prev:\n        return 0\n\n      curr = matrix[i][j]\n      return 1 + max(dfs(i + 1, j, curr),\n                     dfs(i - 1, j, curr),\n                     dfs(i, j + 1, curr),\n                     dfs(i, j - 1, curr))\n\n    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))",
      "title": "329. Longest Increasing Path in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d7c10a9-d570-4dc8-9e23-d8da08c1cbe9",
      "code": "class Solution:\n  def minPatches(self, nums: list[int], n: int) -> int:\n    ans = 0\n    i = 0  # nums' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    while miss <= n:\n      if i < len(nums) and nums[i] <= miss:\n        miss += nums[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "330. Patching Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75929170-b098-412e-bf77-ddba67371a9c",
      "code": "class Solution:\n  def isValidSerialization(self, preorder: str) -> bool:\n    degree = 1  # out-degree (children) - in-degree (parent)\n\n    for node in preorder.split(','):\n      degree -= 1\n      if degree < 0:\n        return False\n      if node != '#':\n        degree += 2\n\n    return degree == 0",
      "title": "331. Verify Preorder Serialization of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9666fb5f-e560-4a40-9da6-ac9156e5d9b5",
      "code": "class Solution:\n  def findItinerary(self, tickets: list[list[str]]) -> list[str]:\n    ans = []\n    graph = collections.defaultdict(list)\n\n    for a, b in reversed(sorted(tickets)):\n      graph[a].append(b)\n\n    def dfs(u: str) -> None:\n      while u in graph and graph[u]:\n        dfs(graph[u].pop())\n      ans.append(u)\n\n    dfs('JFK')\n    return ans[::-1]",
      "title": "332. Reconstruct Itinerary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75061a8e-b366-467c-b38a-aaed23a9515a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  mn: int  # the minimum value in the subtree\n  mx: int  # the maximum value in the subtree\n  size: int  # the size of the subtree\n\n\nclass Solution:\n  def largestBSTSubtree(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(math.inf, -math.inf, 0)\n\n      l = dfs(root.left)\n      r = dfs(root.right)\n\n      if l.mx < root.val < r.mn:\n        return T(min(l.mn, root.val), max(r.mx, root.val), 1 + l.size + r.size)\n\n      # Mark one as invalid, but still record the size of children.\n      # Return (-inf, inf) because no node will be > inf or < -inf.\n      return T(-math.inf, math.inf, max(l.size, r.size))\n\n    return dfs(root).size",
      "title": "333. Largest BST Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa3ab6e9-056b-47ff-a677-894ce9922516",
      "code": "class Solution:\n  def increasingTriplet(self, nums: list[int]) -> bool:\n    first = math.inf\n    second = math.inf\n\n    for num in nums:\n      if num <= first:\n        first = num\n      elif num <= second:  # first < num <= second\n        second = num\n      else:\n        return True  # first < second < num (third)\n\n    return False",
      "title": "334. Increasing Triplet Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9acf62c-ad12-42f4-a714-da0c902aa68e",
      "code": "class Solution:\n  def isSelfCrossing(self, x: list[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False",
      "title": "335. Self Crossing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "866e797c-a3e9-430b-965c-be4b98563b0c",
      "code": "class Solution:\n  def palindromePairs(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans",
      "title": "336. Palindrome Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34850518-b251-4cf6-9127-a6e392130c69",
      "code": "class Solution:\n  def rob(self, root: TreeNode | None) -> int:\n    def robOrNot(root: TreeNode | None) -> tuple:\n      if not root:\n        return (0, 0)\n\n      robLeft, notRobLeft = robOrNot(root.left)\n      robRight, notRobRight = robOrNot(root.right)\n\n      return (root.val + notRobLeft + notRobRight,\n              max(robLeft, notRobLeft) + max(robRight, notRobRight))\n\n    return max(robOrNot(root))",
      "title": "337. House Robber III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01c9bac3-23cd-4030-90bc-fdd9fb260e3d",
      "code": "class Solution:\n  def countBits(self, n: int) -> list[int]:\n    # f(i) := i's number of 1s in bitmask\n    # f(i) = f(i / 2) + i % 2\n    ans = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      ans[i] = ans[i // 2] + (i & 1)\n\n    return ans",
      "title": "338. Counting Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "869311d1-d07c-4be5-9084-1a87e26c8d89",
      "code": "class Solution:\n  def depthSum(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    depth = 0\n    q = collections.deque()\n\n    def addIntegers(nestedList: list[NestedInteger]) -> None:\n      for ni in nestedList:\n        q.append(ni)\n\n    addIntegers(nestedList)\n\n    while q:\n      depth += 1\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          addIntegers(ni.getList())\n\n    return ans",
      "title": "339. Nested List Weight Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0baff14-d284-4ba9-abe4-86f57c0bd594",
      "code": "class Solution:\n  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n    ans = 0\n    distinct = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        distinct += 1\n      while distinct == k + 1:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "340. Longest Substring with At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65cb4f36-3605-4f9e-99a2-e32c022f840b",
      "code": "class Solution:\n  def isPowerOfFour(self, n: int) -> bool:\n    # Why (4^n - 1) % 3 == 0?\n    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    # three consecutive numbers; among one of them, there must be a multiple\n    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    # Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0",
      "title": "342. Power of Four",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43f8a006-d47a-4c03-a3b1-dc2d8cd92792",
      "code": "class Solution:\n  def integerBreak(self, n: int) -> int:\n    # If an optimal product contains a factor f >= 4, then we can replace it\n    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    # (and 1 is wasteful).\n    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if n == 2:  # 1 * 1\n      return 1\n    if n == 3:  # 1 * 2\n      return 2\n\n    ans = 1\n\n    while n > 4:\n      n -= 3\n      ans *= 3\n    ans *= n\n\n    return ans",
      "title": "343. Integer Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "539e9648-2975-40fe-9042-c2fece28521a",
      "code": "class Solution:\n  def reverseString(self, s: list[str]) -> None:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      s[l], s[r] = s[r], s[l]\n      l += 1\n      r -= 1",
      "title": "344. Reverse String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86b1e0be-c808-4aeb-bedc-ce3a2a3e0761",
      "code": "class Solution:\n  def reverseVowels(self, s: str) -> str:\n    chars = list(s)\n    VOWELS = 'aeiouAEIOU'\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and chars[l] not in VOWELS:\n        l += 1\n      while l < r and chars[r] not in VOWELS:\n        r -= 1\n      chars[l], chars[r] = chars[r], chars[l]\n      l += 1\n      r -= 1\n\n    return ''.join(chars)",
      "title": "345. Reverse Vowels of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3669ee11-c8b2-4ccc-9926-ed04e72a854c",
      "code": "class Solution:\n  def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    bucket = [[] for _ in range(len(nums) + 1)]\n\n    for num, freq in collections.Counter(nums).items():\n      bucket[freq].append(num)\n\n    for b in reversed(bucket):\n      ans += b\n      if len(ans) == k:\n        return ans",
      "title": "347. Top K Frequent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32ba3412-bfcc-4223-a6c4-1d17f79501f6",
      "code": "class Solution:\n  def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    ans = []\n    nums1 = set(nums1)\n\n    for num in nums2:\n      if num in nums1:\n        ans.append(num)\n        nums1.remove(num)\n\n    return ans",
      "title": "349. Intersection of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f659d11-a14a-4a76-81f4-4e2c823056c9",
      "code": "class Solution:\n  def intersect(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    if len(nums1) > len(nums2):\n      return self.intersect(nums2, nums1)\n\n    ans = []\n    count = collections.Counter(nums1)\n\n    for num in nums2:\n      if count[num] > 0:\n        ans.append(num)\n        count[num] -= 1\n\n    return ans",
      "title": "350. Intersection of Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53fadc96-3520-42cf-902d-df00d13c6679",
      "code": "class Solution:\n  def numberOfPatterns(self, m: int, n: int) -> int:\n    seen = set()\n    accross = [[0] * 10 for _ in range(10)]\n\n    accross[1][3] = accross[3][1] = 2\n    accross[1][7] = accross[7][1] = 4\n    accross[3][9] = accross[9][3] = 6\n    accross[7][9] = accross[9][7] = 8\n    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \\\n        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5\n\n    def dfs(u: int, depth: int) -> int:\n      if depth > n:\n        return 0\n\n      seen.add(u)\n      ans = 1 if depth >= m else 0\n\n      for v in range(1, 10):\n        if v == u or v in seen:\n          continue\n        accrossed = accross[u][v]\n        if not accrossed or accrossed in seen:\n          ans += dfs(v, depth + 1)\n\n      seen.remove(u)\n      return ans\n\n    # 1, 3, 7, 9 are symmetric\n    # 2, 4, 6, 8 are symmetric\n    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)",
      "title": "351. Android Unlock Patterns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4a109e4-f4a5-4368-adbe-b6bc60a9dfeb",
      "code": "class Solution:\n  def maxEnvelopes(self, envelopes: list[list[int]]) -> int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    return self._lengthOfLIS(envelopes)\n\n  def _lengthOfLIS(self, envelopes: list[list[int]]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for _, h in envelopes:\n      if not tails or h > tails[-1]:\n        tails.append(h)\n      else:\n        tails[bisect.bisect_left(tails, h)] = h\n\n    return len(tails)",
      "title": "354. Russian Doll Envelopes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35661974-d9de-42b6-9b1c-8efe1027785e",
      "code": "class Solution:\n  def isReflected(self, points: list[list[int]]) -> bool:\n    minX = math.inf\n    maxX = -math.inf\n    seen = set()\n\n    for x, y in points:\n      minX = min(minX, x)\n      maxX = max(maxX, x)\n      seen.add((x, y))\n\n    summ = minX + maxX\n    # (leftX + rightX) / 2 = (minX + maxX) / 2\n    #  leftX = minX + maxX - rightX\n    # rightX = minX + maxX - leftX\n\n    return all((summ - x, y) in seen for x, y in points)",
      "title": "356. Line Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "028e3118-4b12-44a0-91ab-b6e4694b0a4a",
      "code": "class Solution:\n  def countNumbersWithUniqueDigits(self, n: int) -> int:\n    if n == 0:\n      return 1\n\n    ans = 10\n    uniqueDigits = 9\n    availableNum = 9\n\n    while n > 1 and availableNum > 0:\n      uniqueDigits *= availableNum\n      ans += uniqueDigits\n      n -= 1\n      availableNum -= 1\n\n    return ans",
      "title": "357. Count Numbers with Unique Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "104457f8-645b-4364-8683-5e8fa855828d",
      "code": "class Solution:\n  def rearrangeString(self, s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    count = collections.Counter(s)\n    # valid[i] := the leftmost index i can appear\n    valid = collections.Counter()\n\n    def getBestLetter(index: int) -> str:\n      \"\"\"Returns the valid letter that has the most count.\"\"\"\n      maxCount = -1\n      bestLetter = '*'\n\n      for c in string.ascii_lowercase:\n        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:\n          bestLetter = c\n          maxCount = count[c]\n\n      return bestLetter\n\n    for i in range(n):\n      c = getBestLetter(i)\n      if c == '*':\n        return ''\n      ans.append(c)\n      count[c] -= 1\n      valid[c] = i + k\n\n    return ''.join(ans)",
      "title": "358. Rearrange String k Distance Apart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c6f7d8-97c3-4980-b5d1-6369da49f20f",
      "code": "class Solution:\n  def sortTransformedArray(\n      self,\n      nums: list[int],\n      a: int,\n      b: int,\n      c: int,\n  ) -> list[int]:\n    n = len(nums)\n    upward = a > 0\n    ans = [0] * n\n\n    # The concavity of f only depends on a's sign.\n    def f(x: int, a: int, b: int, c: int) -> int:\n      return (a * x + b) * x + c\n\n    quad = [f(num, a, b, c) for num in nums]\n\n    i = n - 1 if upward else 0\n    l = 0\n    r = n - 1\n    while l <= r:\n      if upward:  # is the maximum in the both ends\n        if quad[l] > quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i -= 1\n      else:  # is the minimum in the both ends\n        if quad[l] < quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i += 1\n\n    return ans",
      "title": "360. Sort Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c1ad4ef-9bfd-4d2e-9145-9b05444c7a8b",
      "code": "class Solution:\n  def maxKilledEnemies(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    enemyCount = 0\n    # dp[i][j] := the maximum enemies grid[i][j] can kill\n    dp = [[0] * n for _ in range(m)]\n\n    def update(i: int, j: int) -> None:\n      nonlocal enemyCount\n      if grid[i][j] == '0':\n        dp[i][j] += enemyCount\n      elif grid[i][j] == 'E':\n        enemyCount += 1\n      else:  # grid[i][j] == 'W'\n        enemyCount = 0\n\n    # Extend the four directions, if meet 'W', need to start over from 0.\n    for i in range(m):\n      enemyCount = 0\n      for j in range(n):\n        update(i, j)\n      enemyCount = 0\n      for j in reversed(range(n)):\n        update(i, j)\n\n    for j in range(n):\n      enemyCount = 0\n      for i in range(m):\n        update(i, j)\n      enemyCount = 0\n      for i in reversed(range(m)):\n        update(i, j)\n\n    # Returns sum(map(sum, dp))\n    return max(map(max, dp))",
      "title": "361. Bomb Enemy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b8d1ee7-1c1b-476e-82b5-92dd7753eb8d",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = -math.inf\n\n    for baseCol in range(n):\n      # sums[i] := sum(matrix[i][baseCol..j])\n      sums = [0] * m\n      for j in range(baseCol, n):\n        for i in range(m):\n          sums[i] += matrix[i][j]\n        # Find the maximum sum <= k of all the subarrays.\n        accumulate = SortedList([0])\n        prefix = 0\n        for summ in sums:\n          prefix += summ\n          it = accumulate.bisect_left(prefix - k)\n          if it != len(accumulate):\n            ans = max(ans, prefix - accumulate[it])\n          accumulate.add(prefix)\n\n    return ans",
      "title": "363. Max Sum of Rectangle No Larger Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d47187b-2308-4092-897d-09a4453440f4",
      "code": "class Solution:\n  def depthSumInverse(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    prevSum = 0\n    q = collections.deque(nestedList)\n\n    while q:\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          prevSum += ni.getInteger()\n        else:\n          for nextNi in ni.getList():\n            q.append(nextNi)\n      ans += prevSum\n\n    return ans",
      "title": "364. Nested List Weight Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99763dea-ef74-4373-aebd-522c1c7ccd3e",
      "code": "class Solution:\n  def canMeasureWater(\n      self,\n      jug1Capacity: int,\n      jug2Capacity: int,\n      targetCapacity: int,\n  ) -> bool:\n    return (targetCapacity == 0 or\n            jug1Capacity + jug2Capacity >= targetCapacity and\n            targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0)",
      "title": "365. Water and Jug Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0926d17f-0813-4d67-a58a-f2d037c58893",
      "code": "class Solution:\n  def findLeaves(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n\n    def depth(root: TreeNode | None) -> int:\n      \"\"\"Returns the depth of the root (0-indexed).\"\"\"\n      if not root:\n        return -1\n\n      l = depth(root.left)\n      r = depth(root.right)\n      h = 1 + max(l, r)\n\n      if len(ans) == h:  # Meet a leaf\n        ans.append([])\n\n      ans[h].append(root.val)\n      return h\n\n    depth(root)\n    return ans",
      "title": "366. Find Leaves of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e1e94f8-5868-4a49-8960-0477386e214b",
      "code": "class Solution:\n  def isPerfectSquare(self, num: int) -> bool:\n    l = bisect.bisect_left(range(num), num, key=lambda m: m * m)\n    return l**2 == num",
      "title": "367. Valid Perfect Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4229fd05-b6d3-4db3-b6a0-15e3542793c4",
      "code": "class Solution:\n  def largestDivisibleSubset(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = []\n    count = [1] * n\n    prevIndex = [-1] * n\n    maxCount = 0\n    index = -1\n\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      for j in reversed(range(i)):\n        if num % nums[j] == 0 and count[i] < count[j] + 1:\n          count[i] = count[j] + 1\n          prevIndex[i] = j\n      if count[i] > maxCount:\n        maxCount = count[i]\n        index = i\n\n    while index != -1:\n      ans.append(nums[index])\n      index = prevIndex[index]\n\n    return ans",
      "title": "368. Largest Divisible Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e196c81c-7e6a-4b16-b8d5-405e79003902",
      "code": "class Solution:\n  def plusOne(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    dummy.next = head\n\n    while head:\n      if head.val != 9:\n        curr = head\n      head = head.next\n    # `curr` now points to the rightmost non-9 node.\n\n    curr.val += 1\n    while curr.next:\n      curr.next.val = 0\n      curr = curr.next\n\n    return dummy.next if dummy.val == 0 else dummy",
      "title": "369. Plus One Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "725c2fd8-029d-455a-b12f-fc6c7c8eb1af",
      "code": "class Solution:\n  def getModifiedArray(\n      self,\n      length: int,\n      updates: list[list[int]],\n  ) -> list[int]:\n    line = [0] * length\n\n    for start, end, inc in updates:\n      line[start] += inc\n      if end + 1 < length:\n        line[end + 1] -= inc\n\n    return itertools.accumulate(line)",
      "title": "370. Range Addition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7d4b710-4366-4baa-98a3-daa670ac8999",
      "code": "class Solution:\n  def getSum(self, a: int, b: int) -> int:\n    mask = 0xFFFFFFFF\n    MAX = 2000\n\n    while b != 0:\n      a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n\n    return a if a < MAX else ~(a ^ mask)",
      "title": "371. Sum of Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef21722f-2a84-4e91-baf2-8e1c067c6c1c",
      "code": "class Solution:\n  def superPow(self, a: int, b: list[int]) -> int:\n    MOD = 1337\n    ans = 1\n\n    for i in b:\n      ans = pow(ans, 10, MOD) * pow(a, i, MOD)\n\n    return ans % MOD",
      "title": "372. Super Pow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97d7079b-e6c5-4ad8-9bd6-343199610817",
      "code": "class Solution:\n  def kSmallestPairs(self, nums1: list[int],\n                     nums2: list[int],\n                     k: int) -> list[list[int]]:\n    minHeap = []\n\n    for i in range(min(k, len(nums1))):\n      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))\n\n    ans = []\n    while minHeap and len(ans) < k:\n      _, i, j = heapq.heappop(minHeap)\n      ans.append([nums1[i], nums2[j]])\n      if j + 1 < len(nums2):\n        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return ans",
      "title": "373. Find K Pairs with Smallest Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d316a97e-5db1-4e5b-acbc-b687d90a7a44",
      "code": "# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -> int:\n\nclass Solution:\n  def guessNumber(self, n: int) -> int:\n    l = 1\n    r = n\n\n    # Find the first guess number that >= the target number\n    while l < r:\n      m = (l + r) // 2\n      if guess(m) <= 0:  # -1, 0\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "374. Guess Number Higher or Lower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b5610e7-8bab-463d-b983-059fe0b24261",
      "code": "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    # dp[i][j] := the minimum money you need to guarantee a win of picking i..j\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    for d in range(1, n + 1):\n      for i in range(1, n - d + 1):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j + 1):\n          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k)\n\n    return dp[1][n]",
      "title": "375. Guess Number Higher or Lower II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42b27d5a-175c-4886-a280-f35ebd5318ed",
      "code": "class Solution:\n  def wiggleMaxLength(self, nums: list[int]) -> int:\n    increasing = 1\n    decreasing = 1\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing = decreasing + 1\n      elif b < a:\n        decreasing = increasing + 1\n\n    return max(increasing, decreasing)",
      "title": "376. Wiggle Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4ff85d1-db7d-4af2-96e3-3d5401e8b685",
      "code": "class Solution:\n  def combinationSum4(self, nums: list[int], target: int) -> int:\n    dp = [1] + [-1] * target\n\n    def dfs(target: int) -> int:\n      if target < 0:\n        return 0\n      if dp[target] != -1:\n        return dp[target]\n\n      dp[target] = sum(dfs(target - num) for num in nums)\n      return dp[target]\n\n    return dfs(target)",
      "title": "377. Combination Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0b46e43-a74e-41eb-ae92-af7797f110dc",
      "code": "class Solution:\n  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:\n    def numsNoGreaterThan(m: int) -> int:\n      count = 0\n      j = len(matrix[0]) - 1\n      # For each row, find the first index j s.t. row[j] <= m s.t. the number of\n      # numbers <= m for this row will be j + 1.\n      for row in matrix:\n        while j >= 0 and row[j] > m:\n          j -= 1\n        count += j + 1\n      return count\n\n    l = matrix[0][0]\n    r = matrix[-1][-1]\n    return bisect.bisect_left(range(l, r), k, key=numsNoGreaterThan) + l",
      "title": "378. Kth Smallest Element in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7151d269-ab27-453a-b290-edd6af11e05c",
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#   def __init__(self, val=0, next=None):\n#     self.val = val\n#     self.next = next\n\nclass Solution:\n  def __init__(self, head: ListNode | None):\n    self.head = head\n\n  def getRandom(self) -> int:\n    res = -1\n    i = 1\n    curr = self.head\n\n    while curr:\n      if random.randint(0, i - 1) == 0:\n        res = curr.val\n      curr = curr.next\n      i += 1\n\n    return res",
      "title": "382. Linked List Random Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c95bec20-8769-4a8f-bf7f-d16a9a395afd",
      "code": "class Solution:\n  def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n    count1 = collections.Counter(ransomNote)\n    count2 = collections.Counter(magazine)\n    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)",
      "title": "383. Ransom Note",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8b1c729-fb95-4c56-9769-275723744ebe",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def reset(self) -> list[int]:\n    return self.nums\n\n  def shuffle(self) -> list[int]:\n    arr = self.nums.copy()\n    for i in range(len(arr) - 1, 0, -1):\n      j = random.randint(0, i)\n      arr[i], arr[j] = arr[j], arr[i]\n    return arr",
      "title": "384. Shuffle an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e4c670a-42ab-4c3c-b791-5805ae23f3c0",
      "code": "class Solution:\n  def deserialize(self, s: str) -> NestedInteger:\n    if s[0] != '[':\n      return NestedInteger(int(s))\n\n    stack = []\n\n    for i, c in enumerate(s):\n      if c == '[':\n        stack.append(NestedInteger())\n        start = i + 1\n      elif c == ',':\n        if i > start:\n          num = int(s[start:i])\n          stack[-1].add(NestedInteger(num))\n        start = i + 1\n      elif c == ']':\n        popped = stack.pop()\n        if i > start:\n          num = int(s[start:i])\n          popped.add(NestedInteger(num))\n        if stack:\n          stack[-1].add(popped)\n        else:\n          return popped\n        start = i + 1",
      "title": "385. Mini Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eda6ee5c-dda6-4ee8-97b5-8dcb03fc6615",
      "code": "class Solution:\n  def lexicalOrder(self, n: int) -> list[int]:\n    ans = []\n    curr = 1\n\n    while len(ans) < n:\n      ans.append(curr)\n      if curr * 10 <= n:\n        curr *= 10\n      else:\n        while curr % 10 == 9 or curr == n:\n          curr //= 10\n        curr += 1\n\n    return ans",
      "title": "386. Lexicographical Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2b661d4-1d79-431a-9315-86b650bcfbe2",
      "code": "class Solution:\n  def firstUniqChar(self, s: str) -> int:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(s):\n      if count[c] == 1:\n        return i\n\n    return -1",
      "title": "387. First Unique Character in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a009a57-1ed9-4015-a502-b0cfea8e42d6",
      "code": "class Solution:\n  def lengthLongestPath(self, input: str) -> int:\n    ans = 0\n    stack = [(-1, 0)]  # placeholder\n\n    for token in input.split('\\n'):\n      depth = token.count('\\t')\n      token = token.replace('\\t', '')\n      while depth <= stack[-1][0]:\n        stack.pop()\n      if '.' in token:  # `token` is file.\n        ans = max(ans, stack[-1][1] + len(token))\n      else:  # directory + '/'\n        stack.append((depth, stack[-1][1] + len(token) + 1))\n\n    return ans",
      "title": "388. Longest Absolute File Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9340e2b-efe1-46b4-9f61-276212e6f225",
      "code": "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    sXors = chr(functools.reduce(operator.xor, map(ord, s), 0))\n    tXors = chr(functools.reduce(operator.xor, map(ord, t), 0))\n    return chr(ord(sXors) ^ ord(tXors))",
      "title": "389. Find the Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff1ffe6f-9479-4e1e-b4ba-426578b96dbb",
      "code": "class Solution:\n  def lastRemaining(self, n: int) -> int:\n    return 1 if n == 1 else 2 * (1 + n // 2 - self.lastRemaining(n // 2))",
      "title": "390. Elimination Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23cc7064-ed4e-4ce2-9cd4-6f4d307eaf55",
      "code": "class Solution:\n  def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: set[tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      # the four points of the current rectangle\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if ((x1, y1) not in corners or\n        (x1, y2) not in corners or\n        (x2, y1) not in corners or\n            (x2, y2) not in corners):\n      return False\n    return area == (x2 - x1) * (y2 - y1)",
      "title": "391. Perfect Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b01337d2-f2d3-45e0-8b21-0ee4e6b23d87",
      "code": "class Solution:\n  def isSubsequence(self, s: str, t: str) -> bool:\n    if not s:\n      return True\n\n    i = 0\n    for c in t:\n      if s[i] == c:\n        i += 1\n        if i == len(s):\n          return True\n\n    return False",
      "title": "392. Is Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b13bef8-b588-4980-bed8-2f5494e65a9f",
      "code": "class Solution:\n  def validUtf8(self, data: list[int]) -> bool:\n    followedBytes = 0\n\n    for d in data:\n      if followedBytes == 0:\n        if (d >> 3) == 0b11110:\n          followedBytes = 3\n        elif (d >> 4) == 0b1110:\n          followedBytes = 2\n        elif (d >> 5) == 0b110:\n          followedBytes = 1\n        elif (d >> 7) == 0b0:\n          followedBytes = 0\n        else:\n          return False\n      else:\n        if (d >> 6) != 0b10:\n          return False\n        followedBytes -= 1\n\n    return followedBytes == 0",
      "title": "393. UTF-8 Validation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b922d7bd-1e44-4c65-a8f6-99036b311962",
      "code": "class Solution:\n  def decodeString(self, s: str) -> str:\n    ans = ''\n\n    while self.i < len(s) and s[self.i] != ']':\n      if s[self.i].isdigit():\n        k = 0\n        while self.i < len(s) and s[self.i].isdigit():\n          k = k * 10 + int(s[self.i])\n          self.i += 1\n        self.i += 1  # '['\n        decodedString = self.decodeString(s)\n        self.i += 1  # ']'\n        ans += k * decodedString\n      else:\n        ans += s[self.i]\n        self.i += 1\n\n    return ans\n\n  i = 0",
      "title": "394. Decode String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b16c516d-e57d-422d-b868-bddd7185518c",
      "code": "class Solution:\n  def longestSubstring(self, s: str, k: int) -> int:\n    def longestSubstringWithNUniqueLetters(n: int) -> int:\n      res = 0\n      uniqueLetters = 0  # the number of unique letters\n      lettersHavingKFreq = 0  # the number of letters having frequency >= k\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == k:\n          lettersHavingKFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == k:\n            lettersHavingKFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having frequency >= k are equal to n, this is a valid window.\n        if lettersHavingKFreq == n:  # Implicit: uniqueLetters == n\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(longestSubstringWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "395. Longest Substring with At Least K Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21941c64-c8cd-4301-819b-c058578f6ff5",
      "code": "class Solution:\n  def maxRotateFunction(self, nums: list[int]) -> int:\n    f = sum(i * num for i, num in enumerate(nums))\n    ans = f\n    summ = sum(nums)\n\n    for a in reversed(nums):\n      f += summ - len(nums) * a\n      ans = max(ans, f)\n\n    return ans",
      "title": "396. Rotate Function",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc38c35f-0215-4949-ada9-980420e4c76a",
      "code": "class Solution:\n  def integerReplacement(self, n: int) -> int:\n    ans = 0\n\n    while n > 1:\n      if n % 2 == 0:  # `n` ends in 0.\n        n >>= 1\n      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.\n        n -= 1\n      else:  # `n` ends in 0b11.\n        n += 1\n      ans += 1\n\n    return ans",
      "title": "397. Integer Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85176e5c-b790-440b-8649-4216405c154d",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def pick(self, target: int) -> int:\n    ans = -1\n    rng = 0\n    for i, num in enumerate(self.nums):\n      if num == target:\n        rng += 1\n        if random.randint(0, rng - 1) == 0:\n          ans = i\n    return ans",
      "title": "398. Random Pick Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a30c162-d7d4-445c-a44c-2dee1f606e55",
      "code": "class Solution:\n  def calcEquation(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n      queries: list[list[str]],\n  ) -> list[float]:\n    ans = []\n    # graph[A][B] := A / B\n    graph = collections.defaultdict(dict)\n\n    for (A, B), value in zip(equations, values):\n      graph[A][B] = value\n      graph[B][A] = 1 / value\n\n    def devide(A: str, C: str, seen: set[str]) -> float:\n      \"\"\"Returns A / C.\"\"\"\n      if A == C:\n        return 1.0\n\n      seen.add(A)\n\n      # value := A / B\n      for B, value in graph[A].items():\n        if B in seen:\n          continue\n        res = devide(B, C, seen)  # B / C\n        if res > 0:  # valid result\n          return value * res  # (A / B) * (B / C) = A / C\n\n      return -1.0  # invalid result\n\n    for A, C in queries:\n      if A not in graph or C not in graph:\n        ans.append(-1.0)\n      else:\n        ans.append(devide(A, C, set()))\n\n    return ans",
      "title": "399. Evaluate Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7234781-5d26-41bd-9205-9b45d16d2f18",
      "code": "class Solution:\n  def findNthDigit(self, n: int) -> int:\n    def getDigit(num: int, pos: int, digitSize: int):\n      if pos == 0:\n        return num % 10\n      for _ in range(digitSize - pos):\n        num //= 10\n      return num % 10\n\n    digitSize = 1\n    startNum = 1\n    count = 9\n\n    while digitSize * count < n:\n      n -= digitSize * count\n      digitSize += 1\n      startNum *= 10\n      count *= 10\n\n    targetNum = startNum + (n - 1) // digitSize\n    pos = n % digitSize\n\n    return getDigit(targetNum, pos, digitSize)",
      "title": "400. Nth Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851bd650-1d36-4d96-99e2-32476bc0e62f",
      "code": "class Solution:\n  def readBinaryWatch(self, turnedOn: int) -> list[str]:\n    ans = []\n    hours = [1, 2, 4, 8]\n    minutes = [1, 2, 4, 8, 16, 32]\n\n    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:\n      if turnedOn == 0:\n        time = str(h) + \":\" + (str(m).zfill(2))\n        ans.append(time)\n        return\n\n      for i in range(s, len(hours) + len(minutes)):\n        if i < 4 and h + hours[i] < 12:\n          dfs(turnedOn - 1, i + 1, h + hours[i], m)\n        elif i >= 4 and m + minutes[i - 4] < 60:\n          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])\n\n    dfs(turnedOn, 0, 0, 0)\n    return ans",
      "title": "401. Binary Watch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad0de9b3-1c9e-48a2-bdc1-e91c2d70d1fc",
      "code": "class Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'",
      "title": "402. Remove K Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e43a2d3e-dbd2-465b-acd2-6c8d6a86f3f8",
      "code": "class Solution:\n  def canCross(self, stones: list[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump to stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][0] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k > n:\n          continue\n        for x in (k - 1, k, k + 1):\n          if 0 <= x <= n:\n            dp[i][k] |= dp[j][x]\n\n    return any(dp[-1])",
      "title": "403. Frog Jump",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eabc24b-389a-41c2-9125-8297c2f8202b",
      "code": "class Solution:\n  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    ans = 0\n    stack = [root]\n\n    while stack:\n      root = stack.pop()\n      if root.left:\n        if not root.left.left and not root.left.right:\n          ans += root.left.val\n        else:\n          stack.append(root.left)\n      if root.right:\n        stack.append(root.right)\n\n    return ans",
      "title": "404. Sum of Left Leaves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94579be2-a7ab-4600-bc23-c92a891c95f1",
      "code": "class Solution:\n  def toHex(self, num: int) -> str:\n    if num == 0:\n      return '0'\n\n    hex = '0123456789abcdef'\n    ans = []\n\n    # Handling negative numbers by using 32-bit unsigned representation Python's\n    # bitwise operation works on signed numbers, so we convert to 32-bit\n    # unsigned for negative numbers.\n    if num < 0:\n      num += 2**32\n\n    while num > 0:\n      ans.append(hex[num & 0xF])\n      num >>= 4\n\n    return ''.join(reversed(ans))",
      "title": "405. Convert a Number to Hexadecimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0bc3db1-608a-47bb-808f-1fafceb21935",
      "code": "class Solution:\n  def reconstructQueue(self, people: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for person in people:\n      ans.insert(person[1], person)\n\n    return ans",
      "title": "406. Queue Reconstruction by Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0407a86-a99b-4137-be30-135ecb68097d",
      "code": "class Solution:\n  def trapRainWater(self, heightMap: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          # Fill water in grid[x][y].\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans",
      "title": "407. Trapping Rain Water II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7a25b7c-d3d6-460e-a8f3-53b7ba068f74",
      "code": "class Solution:\n  def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n    i = 0  # word's index\n    j = 0  # abbr's index\n\n    while i < len(word) and j < len(abbr):\n      if word[i] == abbr[j]:\n        i += 1\n        j += 1\n        continue\n      if not abbr[j].isdigit() or abbr[j] == '0':\n        return False\n      num = 0\n      while j < len(abbr) and abbr[j].isdigit():\n        num = num * 10 + int(abbr[j])\n        j += 1\n      i += num\n\n    return i == len(word) and j == len(abbr)",
      "title": "408. Valid Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2ad7956-d366-4d65-bf4c-d8a4bb514964",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n\n    for c in count.values():\n      ans += c if c % 2 == 0 else c - 1\n\n    hasOddCount = any(c % 2 == 1 for c in count.values())\n    return ans + hasOddCount",
      "title": "409. Longest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc337d4e-6c14-4839-b518-c78acbcc932d",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # dp[i][k] := the minimum of the maximum sum to split the first i numbers\n    # into k groups\n    dp = [[math.inf] * (k + 1) for _ in range(n + 1)]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n + 1):\n      dp[i][1] = prefix[i]\n\n    for l in range(2, k + 1):\n      for i in range(l, n + 1):\n        for j in range(l - 1, i):\n          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]))\n\n    return dp[n][k]",
      "title": "410. Split Array Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d3b4c2-ba12-4f7e-864b-b7cb323d5e72",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum of the maximum sum to split the first i numbers into\n      k groups.\n      \"\"\"\n      if k == 1:\n        return prefix[i]\n      return min(max(dp(j, k - 1), prefix[i] - prefix[j])\n                 for j in range(k - 1, i))\n\n    return dp(len(nums), k)",
      "title": "410. Split Array Largest Sum_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f3c35f2-430c-4491-afb4-992247b17f4d",
      "code": "class Solution:\n  def minAbbreviation(self, target: str, dictionary: list[str]) -> str:\n    m = len(target)\n\n    def getMask(word: str) -> int:\n      # mask[i] = 0 := target[i] == word[i]\n      # mask[i] = 1 := target[i] != word[i]\n      # e.g. target = \"apple\"\n      #        word = \"blade\"\n      #        mask =  11110\n      mask = 0\n      for i, c in enumerate(word):\n        if c != target[i]:\n          mask |= 1 << m - 1 - i\n      return mask\n\n    masks = [getMask(word) for word in dictionary if len(word) == m]\n    if not masks:\n      return str(m)\n\n    abbrs = []\n\n    def getAbbr(cand: int) -> str:\n      abbr = []\n      replacedCount = 0\n      for i, c in enumerate(target):\n        if cand >> m - 1 - i & 1:\n          # If cand[i] = 1, `abbr` should show the original character.\n          if replacedCount:\n            abbr += str(replacedCount)\n          abbr.append(c)\n          replacedCount = 0\n        else:\n          # If cand[i] = 0, `abbr` can be replaced.\n          replacedCount += 1\n      if replacedCount:\n        abbr.append(str(replacedCount))\n      return ''.join(abbr)\n\n    # all the candidate representation of the target\n    for cand in range(2**m):\n      # All the masks have at lease one bit different from the candidate.\n      if all(cand & mask for mask in masks):\n        abbr = getAbbr(cand)\n        abbrs.append(abbr)\n\n    def getAbbrLen(abbr: str) -> int:\n      abbrLen = 0\n      i = 0\n      j = 0\n      while i < len(abbr):\n        if abbr[j].isalpha():\n          j += 1\n        else:\n          while j < len(abbr) and abbr[j].isdigit():\n            j += 1\n        abbrLen += 1\n        i = j\n      return abbrLen\n\n    return min(abbrs, key=lambda x: getAbbrLen(x))",
      "title": "411. Minimum Unique Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31b52f83-7349-478e-9bbd-64517a13ab89",
      "code": "class Solution:\n  def fizzBuzz(self, n: int) -> list[str]:\n    d = {3: 'Fizz', 5: 'Buzz'}\n    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]",
      "title": "412. Fizz Buzz",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4672130b-ff37-4c46-9cfd-3847437c43f1",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return 0\n\n    dp = [0] * n  # dp[i] := the number of arithmetic slices ending in index i\n\n    for i in range(2, len(nums)):\n      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n        dp[i] = dp[i - 1] + 1\n\n    return sum(dp)",
      "title": "413. Arithmetic Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8db4799d-95b7-4057-8995-c16221d86011",
      "code": "class Solution:\n  def thirdMax(self, nums: list[int]) -> int:\n    max1 = -math.inf  # the maximum\n    max2 = -math.inf  # the second maximum\n    max3 = -math.inf  # the third maximum\n\n    for num in nums:\n      if num > max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif max1 > num and num > max2:\n        max3 = max2\n        max2 = num\n      elif max2 > num and num > max3:\n        max3 = num\n\n    return max1 if max3 == -math.inf else max3",
      "title": "414. Third Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca7564bd-e4a0-49d7-9246-de1fdc8deea8",
      "code": "class Solution:\n  def addStrings(self, num1: str, num2: str) -> str:\n    ans = []\n    carry = 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(num1[i])\n      if j >= 0:\n        carry += int(num2[j])\n      ans.append(str(carry % 10))\n      carry //= 10\n      i -= 1\n      j -= 1\n\n    return ''.join(reversed(ans))",
      "title": "415. Add Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8e1315e-2ee8-48bd-a058-792882e2558f",
      "code": "class Solution:\n  def canPartition(self, nums: list[int]) -> bool:\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:\n    n = len(nums)\n    # dp[i][j] := True if j can be formed by nums[0..i)\n    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(subsetSum + 1):\n        if j < num:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]\n\n    return dp[n][subsetSum]",
      "title": "416. Partition Equal Subset Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41bd9738-3cf2-496a-a101-f0380fbe8ece",
      "code": "class Solution:\n  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: deque, seen: list[list[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    return [[i, j] for i in range(m) for j in range(n) if seenP[i][j] and seenA[i][j]]",
      "title": "417. Pacific Atlantic Water Flow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78fea63b-ef84-4938-8cfe-da987ee79abe",
      "code": "class Solution:\n  def wordsTyping(self, sentence: list[str], rows: int, cols: int) -> int:\n    combined = ' '.join(sentence) + ' '\n    n = len(combined)\n    i = 0\n\n    for _ in range(rows):\n      i += cols\n      if combined[i % n] == ' ':\n        i += 1\n      else:\n        while i > 0 and combined[(i - 1) % n] != ' ':\n          i -= 1\n\n    return i // n",
      "title": "418. Sentence Screen Fitting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f5e9123-57d3-476c-a5eb-a09829cdb7ad",
      "code": "class Solution:\n  def countBattleships(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i, row in enumerate(board):\n      for j, cell in enumerate(row):\n        if cell == '.':\n          continue\n        if i > 0 and board[i - 1][j] == 'X':\n          continue\n        if j > 0 and board[i][j - 1] == 'X':\n          continue\n        ans += 1\n\n    return ans",
      "title": "419. Battleships in a Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3335b42e-80fa-44ce-a4dd-a1d4932ed37f",
      "code": "class Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    # the number of replacements to deal with 3 repeating characters\n    replaces = 0\n    # the number of sequences that can be substituted with 1 deletions,\n    # (3k)-seqs\n    oneSeq = 0\n    # the number of sequences that can be substituted with 2 deletions,\n    # (3k + 1)-seqs\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2  # the length of the repeating password\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3  # 'aaaaaaa' -> 'aaxaaxa'\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    # Each replacement in (3k)-seqs can be substituted with 1 deletions.\n    replaces -= min(oneSeq, deletes)\n    # Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    # Each replacement in other seqs can be substituted with 3 deletions.\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return (3\n            - any(c.isupper() for c in password)\n            - any(c.islower() for c in password)\n            - any(c.isdigit() for c in password))",
      "title": "420. Strong Password Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d49f2100-18bb-46bc-bbb2-adff11d8eb3f",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def findMaximumXOR(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      ans = max(ans, bitTrie.getMaxXor(num))\n      bitTrie.insert(num)\n\n    return ans",
      "title": "421. Maximum XOR of Two Numbers in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f31b9962-acaa-4529-9f80-518503605be0",
      "code": "class Solution:\n  def validWordSquare(self, words: list[str]) -> bool:\n    for i, word in enumerate(words):\n      for j, c in enumerate(word):\n        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds\n          return False\n        if c != words[j][i]:\n          return False\n    return True",
      "title": "422. Valid Word Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7b47f37-3ddc-4c43-98e3-51615afcc0f4",
      "code": "class Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count)\n                   for _ in range(c))",
      "title": "423. Reconstruct Original Digits from English",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0e7b102-b2ac-4aae-a10b-c31daab2e2e3",
      "code": "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    maxCount = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n\n    return r - l + 1",
      "title": "424. Longest Repeating Character Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "176b00d3-b8c0-4c82-8d53-3fe8a0a12560",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.startsWith: list[str] = []\n\n\nclass Trie:\n  def __init__(self, words: list[str]):\n    self.root = TrieNode()\n    for word in words:\n      self._insert(word)\n\n  def findBy(self, prefix: str) -> list[str]:\n    node = self.root\n    for c in prefix:\n      if c not in node.children:\n        return []\n      node = node.children[c]\n    return node.startsWith\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n      node.startsWith.append(word)\n\n\nclass Solution:\n  def wordSquares(self, words: list[str]) -> list[list[str]]:\n    if not words:\n      return []\n\n    n = len(words[0])\n    ans = []\n    path = []\n    trie = Trie(words)\n\n    for word in words:\n      path.append(word)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n    return ans\n\n  def _dfs(self, trie: Trie, n: int, path: list[str], ans: list[list[str]]):\n    if len(path) == n:\n      ans.append(path.copy())\n      return\n\n    prefix = self._getPrefix(path)\n\n    for s in trie.findBy(prefix):\n      path.append(s)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n  def _getPrefix(self, path: list[str]) -> str:\n    \"\"\"\n    e.g. path = [\"wall\",\n                 \"area\"]\n       prefix =  \"le..\"\n    \"\"\"\n    prefix = []\n    index = len(path)\n    for s in path:\n      prefix.append(s[index])\n    return ''.join(prefix)",
      "title": "425. Word Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d819cbd-6df1-4324-89ce-cf31a6a990e3",
      "code": "class Solution:\n  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n    leftHead = self.treeToDoublyList(root.left)\n    rightHead = self.treeToDoublyList(root.right)\n    root.left = root\n    root.right = root\n    return self._connect(self._connect(leftHead, root), rightHead)\n\n  def _connect(self, node1: 'Node | None', node2: 'Node | None') -> 'Node | None':\n    if not node1:\n      return node2\n    if not node2:\n      return node1\n\n    tail1 = node1.left\n    tail2 = node2.left\n\n    # Connect node1's tail with node2.\n    tail1.right = node2\n    node2.left = tail1\n\n    # Connect node2's tail with node1.\n    tail2.right = node1\n    node1.left = tail2\n    return node1",
      "title": "426. Convert Binary Search Tree to Sorted Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "757aecd4-6189-4154-8ebc-14ea08813fa7",
      "code": "class Solution:\n  def construct(self, grid: list[list[int]]) -> 'Node':\n    return self._helper(grid, 0, 0, len(grid))\n\n  def _helper(self, grid: list[list[int]], i: int, j: int, w: int) -> 'Node':\n    if self._allSame(grid, i, j, w):\n      return Node(grid[i][j] == 1, True)\n    half = w // 2\n    return Node(True, False,\n                self._helper(grid, i, j, half),\n                self._helper(grid, i, j + half, half),\n                self._helper(grid, i + half, j, half),\n                self._helper(grid, i + half, j + half, half))\n\n  def _allSame(self, grid: list[list[int]], i: int, j: int, w: int) -> bool:\n    return all(grid[x][y] == grid[i][j]\n               for x in range(i, i + w)\n               for y in range(j, j + w))",
      "title": "427. Construct Quad Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a43e0367-705d-400e-a2a0-0e8a3a92094c",
      "code": "class Solution:\n  def levelOrder(self, root: 'Node') -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        for child in node.children:\n          q.append(child)\n      ans.append(currLevel)\n\n    return ans",
      "title": "429. N-ary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9377dff3-2b01-4554-ab1b-21aa4ee30181",
      "code": "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    curr = head\n\n    while curr:\n      if curr.child:\n        cachedNext = curr.next\n        curr.next = curr.child\n        curr.child.prev = curr\n        curr.child = None\n        tail = curr.next\n        while tail.next:\n          tail = tail.next\n        tail.next = cachedNext\n        if cachedNext:\n          cachedNext.prev = tail\n      curr = curr.next\n\n    return head",
      "title": "430. Flatten a Multilevel Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5655b329-8008-40fd-b69b-480ccb3c04c2",
      "code": "class Solution:\n  def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:\n    bankSet = set(bank)\n    if endGene not in bankSet:\n      return -1\n\n    GENES = 'ACGT'\n    q = collections.deque([startGene])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for j, cache in enumerate(wordList):\n          for c in GENES:\n            wordList[j] = c\n            word = ''.join(wordList)\n            if word == endGene:\n              return step\n            if word in bankSet:\n              bankSet.remove(word)\n              q.append(word)\n          wordList[j] = cache\n      step += 1\n\n    return -1",
      "title": "433. Minimum Genetic Mutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16d9576-893e-423e-bca9-5a9682a264b1",
      "code": "class Solution:\n  def countSegments(self, s: str) -> int:\n    return len(s.split())",
      "title": "434. Number of Segments in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d488210-4128-4769-be2c-f5e59f90c288",
      "code": "class Solution:\n  def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans",
      "title": "435. Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "beba2b18-f894-4d42-b34d-54c88e747260",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def findRightInterval(self, intervals: list[list[int]]) -> list[int]:\n    ans = []\n    startToIndex = SortedDict()\n\n    for i, (start, end) in enumerate(intervals):\n      startToIndex[start] = i\n\n    for start, end in intervals:\n      i = startToIndex.bisect_left(end)\n      ans.append(-1 if i == len(startToIndex) else startToIndex.peekitem(i)[1])\n\n    return ans",
      "title": "436. Find Right Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "218ab973-b3f1-4c54-b3ad-ec3c9c812367",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode | None, summ: int) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode, summ: int) -> int:\n      if not root:\n        return 0\n      return (int(summ == root.val) +\n              dfs(root.left, summ - root.val) +\n              dfs(root.right, summ - root.val))\n\n    return (dfs(root, summ) +\n            self.pathSum(root.left, summ) +\n            self.pathSum(root.right, summ))",
      "title": "437. Path Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16d3e722-d58f-42e8-8f94-b4c947ec4408",
      "code": "class Solution:\n  def findAnagrams(self, s: str, p: str) -> list[int]:\n    ans = []\n    count = collections.Counter(p)\n    required = len(p)\n\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(p):\n        count[s[r - len(p)]] += 1\n        if count[s[r - len(p)]] > 0:\n          required += 1\n      if required == 0:\n        ans.append(r - len(p) + 1)\n\n    return ans",
      "title": "438. Find All Anagrams in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84530e0c-273c-4d3a-a07e-d44a729fb73d",
      "code": "class Solution:\n  def parseTernary(self, expression: str) -> str:\n    c = expression[self.i]\n\n    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':\n      self.i += 2\n      return str(c)\n\n    self.i += 2\n    first = self.parseTernary(expression)\n    second = self.parseTernary(expression)\n\n    return first if c == 'T' else second\n\n  i = 0",
      "title": "439. Ternary Expression Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fb7868e-ff57-474f-8d8e-bbd83f03096d",
      "code": "class Solution:\n  def findKthNumber(self, n: int, k: int) -> int:\n    ans = 1\n\n    i = 1\n    while i < k:\n      gap = self._getGap(ans, ans + 1, n)\n      if i + gap <= k:\n        i += gap\n        ans += 1\n      else:\n        i += 1\n        ans *= 10\n\n    return ans\n\n  def _getGap(self, a: int, b: int, n: int) -> int:\n    gap = 0\n    while a <= n:\n      gap += min(n + 1, b) - a\n      a *= 10\n      b *= 10\n    return gap",
      "title": "440. K-th Smallest in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "883a7286-a55c-4945-ad52-3547bdd40061",
      "code": "class Solution:\n  def arrangeCoins(self, n: int) -> int:\n    return int((-1 + math.sqrt(8 * n + 1)) // 2)",
      "title": "441. Arranging Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bcc0e78-d02c-482c-af60-d539caff073f",
      "code": "class Solution:\n  def findDuplicates(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      nums[abs(num) - 1] *= -1\n      if nums[abs(num) - 1] > 0:\n        ans.append(abs(num))\n\n    return ans",
      "title": "442. Find All Duplicates in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87dc8d49-ac98-42ed-a873-0e13575b34ba",
      "code": "class Solution:\n  def compress(self, chars: list[str]) -> int:\n    ans = 0\n    i = 0\n\n    while i < len(chars):\n      letter = chars[i]\n      count = 0\n      while i < len(chars) and chars[i] == letter:\n        count += 1\n        i += 1\n      chars[ans] = letter\n      ans += 1\n      if count > 1:\n        for c in str(count):\n          chars[ans] = c\n          ans += 1\n\n    return ans",
      "title": "443. String Compression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2e72968-4828-4336-a159-8888c00d669f",
      "code": "class Solution:\n  def sequenceReconstruction(\n      self,\n      org: list[int],\n      seqs: list[list[int]],\n  ) -> bool:\n    if not seqs:\n      return False\n\n    n = len(org)\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for seq in seqs:\n      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:\n        return False\n      for u, v in zip(seq, seq[1:]):\n        if u < 1 or u > n or v < 1 or v > n:\n          return False\n        graph[u - 1].append(v - 1)\n        inDegrees[v - 1] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n    i = 0  # org's index\n\n    while q:\n      if len(q) > 1:\n        return False\n      u = q.popleft()\n      if u != org[i] - 1:\n        return False\n      i += 1\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return i == n",
      "title": "444. Sequence Reconstruction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29ba11ee-df60-4e93-a05c-741cb43674e3",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    stack1 = []\n    stack2 = []\n\n    while l1:\n      stack1.append(l1)\n      l1 = l1.next\n\n    while l2:\n      stack2.append(l2)\n      l2 = l2.next\n\n    head = None\n    carry = 0\n\n    while carry or stack1 or stack2:\n      if stack1:\n        carry += stack1.pop().val\n      if stack2:\n        carry += stack2.pop().val\n      node = ListNode(carry % 10)\n      node.next = head\n      head = node\n      carry //= 10\n\n    return head",
      "title": "445. Add Two Numbers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e039a0eb-92c3-4695-a9cb-345b10df1aa2",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][j] := the number of subsequences end in nums[j] nums[i]\n    dp = [[0] * n for _ in range(n)]\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for i in range(n):\n      for j in range(i):\n        target = nums[j] * 2 - nums[i]\n        if target in numToIndices:\n          for k in numToIndices[target]:\n            if k < j:\n              dp[i][j] += dp[j][k] + 1\n        ans += dp[i][j]\n\n    return ans",
      "title": "446. Arithmetic Slices II - Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d772fd-674f-435d-a134-ed389160a3e3",
      "code": "class Solution:\n  def numberOfBoomerangs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.Counter()\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans",
      "title": "447. Number of Boomerangs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06a9551b-1842-44cc-a085-db6e1dde25dc",
      "code": "class Solution:\n  def findDisappearedNumbers(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      index = abs(num) - 1\n      nums[index] = -abs(nums[index])\n\n    return [i + 1 for i, num in enumerate(nums) if num > 0]",
      "title": "448. Find All Numbers Disappeared in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96a5d4d9-6d9e-4d75-a1e4-6ee03eebd562",
      "code": "class Solution:\n  def deleteNode(self, root: TreeNode | None, key: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == key:\n      if not root.left:\n        return root.right\n      if not root.right:\n        return root.left\n      minNode = self._getMin(root.right)\n      root.right = self.deleteNode(root.right, minNode.val)\n      minNode.left = root.left\n      minNode.right = root.right\n      root = minNode\n    elif root.val < key:\n      root.right = self.deleteNode(root.right, key)\n    else:  # root.val > key\n      root.left = self.deleteNode(root.left, key)\n    return root\n\n  def _getMin(self, node: TreeNode | None) -> TreeNode | None:\n    while node.left:\n      node = node.left\n    return node",
      "title": "450. Delete Node in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b746f17c-b6b0-47e1-a401-257dd88d873f",
      "code": "class Solution:\n  def frequencySort(self, s: str) -> str:\n    ans = []\n    buckets = [[] for _ in range(len(s) + 1)]\n\n    for c, freq in collections.Counter(s).items():\n      buckets[freq].append(c)\n\n    for freq in reversed(range(len(buckets))):\n      for c in buckets[freq]:\n        ans.append(c * freq)\n\n    return ''.join(ans)",
      "title": "451. Sort Characters By Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "775b84bc-49ad-4274-b85f-28a385ae525a",
      "code": "class Solution:\n  def findMinArrowShots(self, points: list[list[int]]) -> int:\n    ans = 0\n    arrowX = -math.inf\n\n    for point in sorted(points, key=lambda x: x[1]):\n      if point[0] > arrowX:\n        ans += 1\n        arrowX = point[1]\n\n    return ans",
      "title": "452. Minimum Number of Arrows to Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db2a657a-148c-4760-9e72-eaac14e110ff",
      "code": "class Solution:\n  def minMoves(self, nums: list[int]) -> int:\n    mn = min(nums)\n    return sum(num - mn for num in nums)",
      "title": "453. Minimum Moves to Equal Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f033ca6-3a75-4f1c-9e2e-1633c441a5c0",
      "code": "class Solution:\n  def fourSumCount(self, nums1: list[int], nums2: list[int],\n                   nums3: list[int], nums4: list[int]) -> int:\n    count = collections.Counter(a + b for a in nums1 for b in nums2)\n    return sum(count[-c - d] for c in nums3 for d in nums4)",
      "title": "454. 4Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45b16b13-5595-4a0b-810d-24a120a1dc90",
      "code": "class Solution:\n  def findContentChildren(self, g: list[int], s: list[int]) -> int:\n    g.sort()\n    s.sort()\n\n    i = 0\n    for cookie in s:\n      if i < len(g) and g[i] <= cookie:\n        i += 1\n\n    return i",
      "title": "455. Assign Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7449137-20f4-44b6-913d-1cba97103d37",
      "code": "class Solution:\n  def find132pattern(self, nums: list[int]) -> bool:\n    stack = []  # a decreasing stack\n    ak = -math.inf  # Find a seq, where ai < ak < aj.\n\n    for num in reversed(nums):\n      # If ai < ak, done because ai must < aj.\n      if num < ak:\n        return True\n      while stack and stack[-1] < num:\n        ak = stack[-1]\n        stack.pop()\n      stack.append(num)  # `nums[i]` is a candidate of aj.\n\n    return False",
      "title": "456. 132 Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39651bc8-b483-4945-80fb-22e2aa3c678b",
      "code": "class Solution:\n  def circularArrayLoop(self, nums: list[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False",
      "title": "457. Circular Array Loop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdf79d88-f9c8-46b5-9a86-e066b10a2961",
      "code": "class Solution:\n  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    base = minutesToTest // minutesToDie + 1\n    ans = 0\n    x = 1\n    while x < buckets:\n      ans += 1\n      x *= base\n    return ans",
      "title": "458. Poor Pigs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e68ca7de-4c4d-44b3-b772-245516c13c15",
      "code": "class Solution:\n  def repeatedSubstringPattern(self, s: str) -> bool:\n    return s in (s + s)[1:-1]",
      "title": "459. Repeated Substring Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ced195-b7fa-4850-8ac5-7366251c7552",
      "code": "class Solution:\n  def hammingDistance(self, x: int, y: int) -> int:\n    ans = 0\n\n    while x > 0 or y > 0:\n      ans += (x & 1) ^ (y & 1)\n      x >>= 1\n      y >>= 1\n\n    return ans",
      "title": "461. Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ad84836-6389-4e44-86c1-23b35014bd1a",
      "code": "import statistics\n\n\nclass Solution:\n  def minMoves2(self, nums: list[int]) -> int:\n    median = int(statistics.median(nums))\n    return sum(abs(num - median) for num in nums)",
      "title": "462. Minimum Moves to Equal Array Elements II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "692c22f6-bf94-42dc-b564-7d89856eff9e",
      "code": "class Solution:\n  def islandPerimeter(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    islands = 0\n    neighbors = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          islands += 1\n          if i + 1 < m and grid[i + 1][j] == 1:\n            neighbors += 1\n          if j + 1 < n and grid[i][j + 1] == 1:\n            neighbors += 1\n\n    return islands * 4 - neighbors * 2",
      "title": "463. Island Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfc764b2-41a1-4434-9e1a-a898a17f33b9",
      "code": "class Solution:\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n    if desiredTotal <= 0:\n      return True\n\n    totalSum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n    if totalSum < desiredTotal:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(total: int, used: int) -> bool:\n      \"\"\"\n      Returns true if the first player can we, where `used` represents the use\n      numbers.\n      \"\"\"\n      if total <= 0:\n        return False\n      return any((used >> i & 1) == 0\n                 and not dp(total - i, used | 1 << i)\n                 for i in range(1, maxChoosableInteger + 1))\n\n    return dp(desiredTotal, 0)",
      "title": "464. Can I Win",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cab11f1c-c647-4ac0-aa96-ff504f9eba5d",
      "code": "class Solution:\n  def minTransfers(self, transactions: list[list[int]]) -> int:\n    balance = [0] * 21\n\n    for u, v, amount in transactions:\n      balance[u] -= amount\n      balance[v] += amount\n\n    debts = [b for b in balance if b]\n\n    def dfs(s: int) -> int:\n      while s < len(debts) and not debts[s]:\n        s += 1\n      if s == len(debts):\n        return 0\n\n      ans = math.inf\n\n      for i in range(s + 1, len(debts)):\n        if debts[i] * debts[s] < 0:\n          debts[i] += debts[s]  # `debts[s]` is settled.\n          ans = min(ans, 1 + dfs(s + 1))\n          debts[i] -= debts[s]  # Backtrack.\n\n      return ans\n\n    return dfs(0)",
      "title": "465. Optimal Account Balancing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2827b4b4-6fff-4586-8a28-f15a593ec143",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Record:\n  count: int\n  nextIndex: int\n\n\nclass Solution:\n  def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n    # records[i].count := the number of times that s2 starting from index i has\n    # been fully matched with s1\n    # records[i].nextIndex := the next index in s2 to be matched after\n    # completing a full match starting from index i\n    records = []\n\n    for nextIndex in range(len(s2)):\n      count = 0\n      for c in s1:\n        if s2[nextIndex] == c:\n          nextIndex += 1\n          if nextIndex == len(s2):  # There's a match.\n            count += 1\n            nextIndex = 0\n      records.append(Record(count, nextIndex))\n\n    matches = 0  # the number of matches between `s1` x n1 and `s2`\n    i = 0  # the index in `s2` to start matching\n\n    for _ in range(n1):\n      matches += records[i].count\n      i = records[i].nextIndex\n\n    return matches // n2",
      "title": "466. Count The Repetitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3afd19a-fe37-4ec9-8fa3-742614943326",
      "code": "class Solution:\n  def findSubstringInWraproundString(self, s: str) -> int:\n    maxLength = 1\n    # count[i] := the number of substrings ending in ('a' + i)\n    count = [0] * 26\n\n    for i in range(len(s)):\n      if i > 0 and (ord(s[i]) - ord(s[i - 1]) == 1\n                    or ord(s[i - 1]) - ord(s[i]) == 25):\n        maxLength += 1\n      else:\n        maxLength = 1\n      index = ord(s[i]) - ord('a')\n      count[index] = max(count[index], maxLength)\n\n    return sum(count)",
      "title": "467. Unique Substrings in Wraparound String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b92c372-5216-43c8-89ba-f46fcc9629d9",
      "code": "class Solution:\n  def validIPAddress(self, queryIP: str) -> str:\n    if queryIP.count('.') == 3:\n      parts = queryIP.split('.')\n      if len(parts) == 4 and all(self._isIPv4(part) for part in parts):\n        return 'IPv4'\n\n    if queryIP.count(':') == 7:\n      parts = queryIP.split(':')\n      if len(parts) == 8 and all(self._isIPv6(part) for part in parts):\n        return 'IPv6'\n\n    return 'Neither'\n\n  def _isIPv4(self, digit: str) -> bool:\n    if not digit or len(digit) > 3:\n      return False\n    if len(digit) > 1 and digit[0] == '0':\n      return False\n    if not all(c.isdigit() for c in digit):\n      return False\n    num = int(digit)\n    return 0 <= num <= 255\n\n  def _isIPv6(self, digit: str) -> bool:\n    if not digit or len(digit) > 4:\n      return False\n    validChars = set('0123456789abcdefABCDEF')\n    return all(c in validChars for c in digit)",
      "title": "468. Validate IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2d62e64-a0c4-404e-82b3-ae6db17c16c5",
      "code": "class Solution:\n  def isConvex(self, points: list[list[int]]) -> bool:\n    def getCross(p: list[int], q: list[int], r: list[int]):\n      \"\"\"Returns pq x qr.\"\"\"\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    sign = 0\n    for i in range(len(points)):\n      cross = getCross(points[i - 2], points[i - 1], points[i])\n      if cross == 0:  # p, q, r are collinear.\n        continue\n      if sign == 0:  # Find the first cross that's not 0.\n        sign = cross\n      elif cross * sign < 0:\n        return False\n\n    return True",
      "title": "469. Convex Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "febf4395-5435-4a8b-a291-11d0e88cb57a",
      "code": "# The rand7() API is already defined for you.\n# def rand7():\n# @return a random integer in the range 1 to 7\n\nclass Solution:\n  def rand10(self) -> int:\n    num = 40\n    while num >= 40:\n      num = (rand7() - 1) * 7 + (rand7() - 1)\n    return num % 10 + 1",
      "title": "470. Implement Rand10() Using Rand7()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe907a4d-3495-4959-ab51-000726acf89a",
      "code": "class Solution:\n  def encode(self, s: str) -> str:\n    n = len(s)\n    # dp[i][j] := the shortest encoded string of s[i..j]\n    dp = [[''] * n for _ in range(n)]\n\n    for d in range(n):\n      for i in range(n - d):\n        j = i + d\n        curr = s[i:j + 1]\n        dp[i][j] = curr\n\n        if len(dp[i][j]) < 5:\n          continue\n\n        # Try all the possible partitions.\n        for k in range(i, j):\n          if len(dp[i][k]) + len(dp[k + 1][j]) < len(dp[i][j]):\n            dp[i][j] = dp[i][k] + dp[k + 1][j]\n\n        # Try to compress the string.\n        # e.g. s = aabaabaab -> 3[aab]\n        for k in range(i, j):\n          pattern = s[i:k + 1]\n          if len(curr) % len(pattern) == 0 and pattern * (len(curr) //\n                                                          len(pattern)) == curr:\n            candidate = f\"{len(curr) // len(pattern)}[{dp[i][k]}]\"\n            if len(candidate) < len(dp[i][j]):\n              dp[i][j] = candidate\n\n    return dp[0][n - 1]",
      "title": "471. Encode String with Shortest Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73ca9b31-ca6a-4d98-9be5-30e00c4de6af",
      "code": "class Solution:\n  def findAllConcatenatedWordsInADict(self, words: list[str]) -> list[str]:\n    wordSet = set(words)\n\n    @functools.lru_cache(None)\n    def isConcat(word: str) -> bool:\n      for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\n          return True\n\n      return False\n\n    return [word for word in words if isConcat(word)]",
      "title": "472. Concatenated Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41775672-2dc6-47d5-9d15-06bfface2659",
      "code": "class Solution:\n  def makesquare(self, matchsticks: list[int]) -> bool:\n    if len(matchsticks) < 4:\n      return False\n\n    perimeter = sum(matchsticks)\n    if perimeter % 4 != 0:\n      return False\n\n    A = sorted(matchsticks)[::-1]\n\n    def dfs(selected: int, edges: list[int]) -> bool:\n      if selected == len(A):\n        return all(edge == edges[0] for edge in edges)\n\n      for i, edge in enumerate(edges):\n        if A[selected] > edge:\n          continue\n        edges[i] -= A[selected]\n        if dfs(selected + 1, edges):\n          return True\n        edges[i] += A[selected]\n\n      return False\n\n    return dfs(0, [perimeter // 4] * 4)",
      "title": "473. Matchsticks to Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c6eb761-4f46-4ffe-807a-2641e6702ae7",
      "code": "class Solution:\n  def findMaxForm(self, strs: list[str], m: int, n: int) -> int:\n    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are\n    # available\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n      zeros = s.count('0')\n      ones = len(s) - zeros\n      for i in range(m, zeros - 1, -1):\n        for j in range(n, ones - 1, -1):\n          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    return dp[m][n]",
      "title": "474. Ones and Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63f55b33-8ade-4fe4-8533-690c47b05ea6",
      "code": "class Solution:\n  def totalHammingDistance(self, nums: list[int]) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      ones = sum(num & (1 << i) > 0 for num in nums)\n      zeros = len(nums) - ones\n      ans += ones * zeros\n\n    return ans",
      "title": "477. Total Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d949a67-98b6-4015-b41c-c99e4e733607",
      "code": "class Solution:\n  def __init__(self, radius: float, x_center: float, y_center: float):\n    self.radius = radius\n    self.x_center = x_center\n    self.y_center = y_center\n\n  def randPoint(self) -> list[float]:\n    length = math.sqrt(random.uniform(0, 1)) * self.radius\n    degree = random.uniform(0, 1) * 2 * math.pi\n    x = self.x_center + length * math.cos(degree)\n    y = self.y_center + length * math.sin(degree)\n    return [x, y]",
      "title": "478. Generate Random Point in a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89dccdb8-988e-4c59-afae-c352e9fd7941",
      "code": "class Solution:\n  def largestPalindrome(self, n: int) -> int:\n    if n == 1:\n      return 9\n\n    MOD = 1337\n    upper = pow(10, n) - 1\n    lower = pow(10, n - 1) - 1\n\n    for i in range(upper, lower, -1):\n      cand = int(str(i) + str(i)[::-1])\n      j = upper\n      while j * j >= cand:\n        if cand % j == 0:\n          return cand % MOD\n        j -= 1",
      "title": "479. Largest Palindrome Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b673700-f08d-4d1e-96a7-46a26c714d90",
      "code": "class Solution:\n  def magicalString(self, n: int) -> int:\n    s = [' ', '1', '2', '2']\n\n    for i in range(3, n + 1):\n      if i % 2 == 1:\n        s.extend(['1'] * (int(s[i])))\n      else:\n        s.extend(['2'] * (int(s[i])))\n\n    return sum(1 for c in s[:n + 1] if c == '1')",
      "title": "481. Magical String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13d981b9-b83d-46b6-a511-323a9154a292",
      "code": "class Solution:\n  def licenseKeyFormatting(self, s: str, k: int) -> str:\n    ans = []\n    length = 0\n\n    for i in reversed(range(len(s))):\n      if s[i] == '-':\n        continue\n      if length > 0 and length % k == 0:\n        ans += '-'\n      ans += s[i].upper()\n      length += 1\n\n    return ''.join(reversed(ans))",
      "title": "482. License Key Formatting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f196c632-0d0b-4404-83f7-80ebd4c7d9e2",
      "code": "class Solution:\n  def smallestGoodBase(self, n: str) -> str:\n    n = int(n)\n\n    for m in range(int(math.log(n, 2)), 1, -1):\n      k = int(n**m**-1)\n      if (k**(m + 1) - 1) // (k - 1) == n:\n        return str(k)\n\n    return str(n - 1)",
      "title": "483. Smallest Good Base",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6878fc-bf9d-4ecf-988c-40bc548f3399",
      "code": "class Solution:\n  def findPermutation(self, s: str) -> list[int]:\n    ans = [i for i in range(1, len(s) + 2)]\n\n    # For each D* group (s[i..j]), reverse ans[i..j + 1].\n    i = -1\n    j = -1\n\n    def getNextIndex(c: str, start: int) -> int:\n      for i in range(start, len(s)):\n        if s[i] == c:\n          return i\n      return len(s)\n\n    while True:\n      i = getNextIndex('D', j + 1)\n      if i == len(s):\n        break\n      j = getNextIndex('I', i + 1)\n      ans[i:j + 1] = ans[i:j + 1][::-1]\n\n    return ans",
      "title": "484. Find Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fd84bdc-53b6-4420-a823-89f2a18db7dc",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    summ = 0\n\n    for num in nums:\n      if num == 0:\n        summ = 0\n      else:\n        summ += num\n        ans = max(ans, summ)\n\n    return ans",
      "title": "485. Max Consecutive Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "358a6414-baa8-481f-87e1-581f520809e0",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    maxZeros = 1\n    ans = 0\n    q = collections.deque()  # Store indices of zero.\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        q.append(r)\n      if len(q) > maxZeros:\n        l = q.popleft() + 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f6bd8b9-22bc-48ba-9a00-cbab9f93e511",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3bd843b-5556-4dee-b8d4-3437d86629ea",
      "code": "class Solution:\n  def findMinStep(self, board: str, hand: str) -> int:\n    def deDup(board):\n      start = 0  # the start index of a color sequenece\n      for i, c in enumerate(board):\n        if c != board[start]:\n          if i - start >= 3:\n            return deDup(board[:start] + board[i:])\n          start = i  # Meet a new sequence.\n      return board\n\n    @functools.lru_cache(None)\n    def dfs(board: str, hand: str):\n      board = deDup(board)\n      if board == '#':\n        return 0\n\n      boardSet = set(board)\n      # hand that is in board\n      hand = ''.join(h for h in hand if h in boardSet)\n      if not hand:  # infeasible\n        return math.inf\n\n      ans = math.inf\n\n      for i in range(len(board)):\n        for j, h in enumerate(hand):\n          # Place hs[j] in board[i].\n          newHand = hand[:j] + hand[j + 1:]\n          newBoard = board[:i] + h + board[i:]\n          ans = min(ans, 1 + dfs(newBoard, newHand))\n\n      return ans\n\n    ans = dfs(board + '#', hand)\n    return -1 if ans == math.inf else ans",
      "title": "488. Zuma Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e139044e-9d1d-45db-a01d-c471eeee655d",
      "code": "class Solution:\n  def hasPath(\n      self,\n      maze: list[list[int]],\n      start: list[int],\n      destination: list[int],\n  ) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(start[0], start[1])])\n    seen = {(start[0], start[1])}\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i\n        y = j\n        while isValid(x + dx, y + dy):\n          x += dx\n          y += dy\n        if [x, y] == destination:\n          return True\n        if (x, y) in seen:\n          continue\n        q.append((x, y))\n        seen.add((x, y))\n\n    return False",
      "title": "490. The Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c864ce3f-ee2d-4638-a26c-389c917f0d32",
      "code": "class Solution:\n  def findSubsequences(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) > 1:\n        ans.append(path)\n\n      used = set()\n\n      for i in range(s, len(nums)):\n        if nums[i] in used:\n          continue\n        if not path or nums[i] >= path[-1]:\n          used.add(nums[i])\n          dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "491. Increasing Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3e25371-ede4-4074-9722-a3ad604f0b9a",
      "code": "class Solution:\n  def findTargetSumWays(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) % 2 == 1:\n      return 0\n\n    def knapsack(nums: list[int], target: int) -> int:\n      # dp[i] := the number of ways to sum to i by nums so far\n      dp = [0] * (target + 1)\n      dp[0] = 1\n\n      for num in nums:\n        for i in range(target, num - 1, -1):\n          dp[i] += dp[i - num]\n\n      return dp[target]\n\n    return knapsack(nums, (summ + target) // 2)",
      "title": "494. Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56df8569-9d39-4c5a-aaf0-9492218737ce",
      "code": "class Solution:\n  def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\n    if duration == 0:\n      return 0\n\n    ans = 0\n\n    for i in range(0, len(timeSeries) - 1):\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration)\n\n    return ans + duration",
      "title": "495. Teemo Attacking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6080e12-f871-4b78-a824-7775087144d3",
      "code": "class Solution:\n  def nextGreaterElement(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToNextGreater = {}\n    stack = []  # a decreasing stack\n\n    for num in nums2:\n      while stack and stack[-1] < num:\n        numToNextGreater[stack.pop()] = num\n      stack.append(num)\n\n    return [numToNextGreater.get(num, -1) for num in nums1]",
      "title": "496. Next Greater Element I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f213564-cc93-45f1-b5e7-eb359518a881",
      "code": "class Solution:\n  def __init__(self, rects: list[list[int]]):\n    self.rects = rects\n    self.areas = list(itertools.accumulate(\n        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))\n\n  def pick(self) -> list[int]:\n    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))\n    x1, y1, x2, y2 = self.rects[index]\n    return [random.randint(x1, x2), random.randint(y1, y2)]",
      "title": "497. Random Point in Non-overlapping Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e906b040-691d-49e7-90a4-2ac609936766",
      "code": "class Solution:\n  def findShortestWay(\n      self,\n      maze: list[list[int]],\n      ball: list[int],\n      hole: list[int],\n  ) -> str:\n    ans = 'impossible'\n    minSteps = math.inf\n\n    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):\n      nonlocal ans\n      nonlocal minSteps\n      if steps >= minSteps:\n        return\n\n      if dx != 0 or dy != 0:  # Both are zeros for the initial ball position.\n        while (0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and\n               maze[i + dx][j + dy] != 1):\n          i += dx\n          j += dy\n          steps += 1\n          if i == hole[0] and j == hole[1] and steps < minSteps:\n            minSteps = steps\n            ans = path\n\n      if maze[i][j] == 0 or steps + 2 < maze[i][j]:\n        maze[i][j] = steps + 2  # +2 because maze[i][j] == 0 || 1.\n        if dx == 0:\n          dfs(i, j, 1, 0, steps, path + 'd')\n        if dy == 0:\n          dfs(i, j, 0, -1, steps, path + 'l')\n        if dy == 0:\n          dfs(i, j, 0, 1, steps, path + 'r')\n        if dx == 0:\n          dfs(i, j, -1, 0, steps, path + 'u')\n\n    dfs(ball[0], ball[1], 0, 0, 0, '')\n    return ans",
      "title": "499. The Maze III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a7c5fdb-973c-47df-b01b-6dfc76f9cf9e",
      "code": "class Solution:\n  def findWords(self, words: list[str]) -> list[str]:\n    ans = []\n    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n\n    for word in words:\n      lowerWord = set(word.lower())\n      if any(lowerWord <= row for row in rows):\n        ans.append(word)\n\n    return ans",
      "title": "500. Keyboard Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7d3a8ca-c278-48b0-9fb8-04ab0f4272ab",
      "code": "class Solution:\n  def findMode(self, root: TreeNode | None) -> list[int]:\n    self.ans = []\n    self.pred = None\n    self.count = 0\n    self.maxCount = 0\n\n    def updateCount(root: TreeNode | None) -> None:\n      if self.pred and self.pred.val == root.val:\n        self.count += 1\n      else:\n        self.count = 1\n\n      if self.count > self.maxCount:\n        self.maxCount = self.count\n        self.ans = [root.val]\n      elif self.count == self.maxCount:\n        self.ans.append(root.val)\n\n      self.pred = root\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      updateCount(root)\n      inorder(root.right)\n\n    inorder(root)\n    return self.ans",
      "title": "501. Find Mode in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54519651-cd43-463f-a7dc-766549b9d0c6",
      "code": "class Solution:\n  def nextGreaterElements(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [-1] * n\n    stack = []  # a decreasing stack storing indices\n\n    for i in range(n * 2):\n      num = nums[i % n]\n      while stack and nums[stack[-1]] < num:\n        ans[stack.pop()] = num\n      if i < n:\n        stack.append(i)\n\n    return ans",
      "title": "503. Next Greater Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48d5d268-0e26-4ae2-ad5c-14cf99c24b0a",
      "code": "class Solution:\n  def checkPerfectNumber(self, num: int) -> bool:\n    return num in {6, 28, 496, 8128, 33550336}",
      "title": "507. Perfect Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c821786-deaf-41b6-9a41-df37b687c9c7",
      "code": "class Solution:\n  def findFrequentTreeSum(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    count = collections.Counter()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      count[summ] += 1\n      return summ\n\n    dfs(root)\n    maxFreq = max(count.values())\n    return [summ for summ in count if count[summ] == maxFreq]",
      "title": "508. Most Frequent Subtree Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b68f20a-df80-4ea0-a3b1-406428ad001d",
      "code": "class Solution:\n  def fib(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 0, 1]\n\n    for i in range(2, n + 1):\n      dp[0] = dp[1]\n      dp[1] = dp[2]\n      dp[2] = dp[0] + dp[1]\n\n    return dp[2]",
      "title": "509. Fibonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7a40fae-f03b-40e6-93ec-cab9592751b8",
      "code": "class Solution:\n  def findBottomLeftValue(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxDepth = 0\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      nonlocal ans\n      nonlocal maxDepth\n      if not root:\n        return\n      if depth > maxDepth:\n        maxDepth = depth\n        ans = root.val\n\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 1)\n    return ans",
      "title": "513. Find Bottom Left Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffc09968-80c4-45b6-be37-11884b45d0ba",
      "code": "class Solution:\n  def findRotateSteps(self, ring: str, key: str) -> int:\n    @functools.lru_cache(None)\n    def dfs(ring: str, index: int) -> int:\n      \"\"\"Returns the number of rotates of ring to match key[index..n).\"\"\"\n      if index == len(key):\n        return 0\n\n      ans = math.inf\n\n      # For each ring[i] == key[index], we rotate the ring to match the ring[i]\n      # with the key[index], then recursively match the newRing with the\n      # key[index + 1..n).\n      for i, r in enumerate(ring):\n        if r == key[index]:\n          minRotates = min(i, len(ring) - i)\n          newRing = ring[i:] + ring[:i]\n          remainingRotates = dfs(newRing, index + 1)\n          ans = min(ans, minRotates + remainingRotates)\n\n      return ans\n\n    return dfs(ring, 0) + len(key)",
      "title": "514. Freedom Trail",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc9b86f6-c104-4ccf-b0a8-80092d663709",
      "code": "class Solution:\n  def largestValues(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      mx = -math.inf\n      for _ in range(len(q)):\n        root = q.popleft()\n        mx = max(mx, root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n      ans.append(mx)\n\n    return ans",
      "title": "515. Find Largest Value in Each Tree Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16b8bd0-fc29-481f-b605-3ce070f1cc57",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "516. Longest Palindromic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20e9bb60-3d3b-4a5b-99e3-82aeca499f00",
      "code": "class Solution:\n  def findMinMoves(self, machines: list[int]) -> int:\n    dresses = sum(machines)\n\n    if dresses % len(machines) != 0:\n      return -1\n\n    ans = 0\n    average = dresses // len(machines)\n    inout = 0\n\n    for dress in machines:\n      inout += dress - average\n      ans = max(ans, abs(inout), dress - average)\n\n    return ans",
      "title": "517. Super Washing Machines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b85bad6-c774-4016-bbf6-ef38ed7377b5",
      "code": "class Solution:\n  def change(self, amount: int, coins: list[int]) -> int:\n    dp = [1] + [0] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] += dp[i - coin]\n\n    return dp[amount]",
      "title": "518. Coin Change 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a56e475-6629-4479-9d4d-f498e3c9a502",
      "code": "class Solution:\n  def detectCapitalUse(self, word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()",
      "title": "520. Detect Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bf6e182-341f-41ac-9cca-c2f22d26a92a",
      "code": "class Solution:\n  def findLUSlength(self, a: str, b: str) -> int:\n    return -1 if a == b else max(len(a), len(b))",
      "title": "521. Longest Uncommon Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0272cd12-9e54-4808-b1b7-81da2572d3a5",
      "code": "class Solution:\n  def findLUSlength(self, strs: list[str]) -> int:\n    def isSubsequence(a: str, b: str) -> bool:\n      i = 0\n      j = 0\n\n      while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n          i += 1\n        j += 1\n\n      return i == len(a)\n\n    seen = set()\n    duplicates = set()\n\n    for s in strs:\n      if s in seen:\n        duplicates.add(s)\n      seen.add(s)\n\n    strs.sort(key=lambda x: -len(x))\n\n    for i in range(len(strs)):\n      if strs[i] in duplicates:\n        continue\n      isASubsequence = False\n      for j in range(i):\n        isASubsequence |= isSubsequence(strs[i], strs[j])\n      if not isASubsequence:\n        return len(strs[i])\n\n    return -1",
      "title": "522. Longest Uncommon Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b4a1a3a-7e98-4794-b483-e7a70a352a63",
      "code": "class Solution:\n  def checkSubarraySum(self, nums: list[int], k: int) -> bool:\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      if k != 0:\n        prefix %= k\n      if prefix in prefixToIndex:\n        if i - prefixToIndex[prefix] > 1:\n          return True\n      else:\n        # Set a new key if it's absent because the previous index is better.\n        prefixToIndex[prefix] = i\n\n    return False",
      "title": "523. Continuous Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "037fed65-8151-4527-8912-f65545372424",
      "code": "class Solution:\n  def findLongestWord(self, s: str, d: list[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans",
      "title": "524. Longest Word in Dictionary through Deleting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f173bf13-5c40-4c60-be11-f2fd0dc2f101",
      "code": "class Solution:\n  def findMaxLength(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += 1 if num else -1\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "525. Contiguous Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dca5a1e0-90c1-4348-9f07-29b517439621",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedWord:\n  word: str\n  index: int\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n    ans = [''] * n\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    abbrevToIndexedWords = collections.defaultdict(list)\n\n    for i, word in enumerate(words):\n      abbrev = getAbbrev(word, 0)\n      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))\n\n    def insertWord(root: TrieNode | None, word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    def firstUniqueIndex(root: TrieNode | None, word: str) -> None:\n      node = root\n      for i, c in enumerate(word):\n        node = node.children[c]\n        if node.count == 1:\n          return i\n      return len(word)\n\n    for indexedWords in abbrevToIndexedWords.values():\n      root = TrieNode()\n      for iw in indexedWords:\n        insertWord(root, iw.word)\n      for iw in indexedWords:\n        index = firstUniqueIndex(root, iw.word)\n        ans[iw.index] = getAbbrev(iw.word, index)\n\n    return ans",
      "title": "527. Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58361010-7d28-4839-9716-fe614541a311",
      "code": "class Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    ans = [getAbbrev(word, 0) for word in words]\n    # prefix[i] := ans[i] takes words[i][0..prefix[i]]\n    prefix = [0] * n\n\n    for i in range(n):\n      while True:\n        dupeIndices = []\n        for j in range(i + 1, n):\n          if ans[i] == ans[j]:\n            dupeIndices.append(j)\n        if not dupeIndices:\n          break\n        dupeIndices.append(i)\n        for index in dupeIndices:\n          prefix[index] += 1\n          ans[index] = getAbbrev(words[index], prefix[index])\n\n    return ans",
      "title": "527. Word Abbreviation_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8991cb8-a41e-4e60-9c08-c19f186ac544",
      "code": "class Solution:\n  def __init__(self, w: list[int]):\n    self.prefix = list(itertools.accumulate(w))\n\n  def pickIndex(self) -> int:\n    target = random.randint(0, self.prefix[-1] - 1)\n    return bisect.bisect_right(range(len(self.prefix)), target,\n                               key=lambda m: self.prefix[m])",
      "title": "528. Random Pick with Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caac6c0d-45cc-47b9-b8dd-d678ad140c71",
      "code": "class Solution:\n  def updateBoard(self, board: list[list[str]],\n                  click: list[int]) -> list[list[str]]:\n    i, j = click\n    if board[i][j] == 'M':\n      board[i][j] = 'X'\n      return board\n\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    def getMinesCount(i: int, j: int) -> int:\n      minesCount = 0\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):\n          continue\n        if board[x][y] == 'M':\n          minesCount += 1\n      return minesCount\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(board) or j < 0 or j == len(board[0]):\n        return\n      if board[i][j] != 'E':\n        return\n\n      minesCount = getMinesCount(i, j)\n      board[i][j] = 'B' if minesCount == 0 else str(minesCount)\n\n      if minesCount == 0:\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy)\n\n    dfs(i, j)\n    return board",
      "title": "529. Minesweeper",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36bef5f1-d19f-4f64-ae9d-0ea6c3be2162",
      "code": "class Solution:\n  def findLonelyPixel(self, picture: list[list[str]]) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [0] * m  # rows[i] := the number of B's in rows i\n    cols = [0] * n  # cols[i] := the number of B's in cols i\n\n    for i in range(m):\n      for j in range(n):\n        if picture[i][j] == 'B':\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.\n        for j in range(n):\n          # After meeting a 'B' in this rows, break and search the next row.\n          if picture[i][j] == 'B':\n            if cols[j] == 1:\n              ans += 1\n            break\n\n    return ans",
      "title": "531. Lonely Pixel I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab5b9bca-ee80-4621-bfbf-fa7c33175043",
      "code": "class Solution:\n  def findPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for i, num in enumerate(nums):\n      target = num + k\n      if target in numToIndex and numToIndex[target] != i:\n        ans += 1\n        del numToIndex[target]\n\n    return ans",
      "title": "532. K-diff Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "520ac19d-8d7c-45f0-9292-fc545f711624",
      "code": "class Solution:\n  def findBlackPixel(self, picture: list[list[str]], target: int) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [row.count('B') for row in picture]\n    cols = [col.count('B') for col in zip(*picture)]\n    rowStrings = [''.join(row) for row in picture]\n    countRowStrings = collections.Counter(rowStrings)\n\n    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):\n      if row == target and countRowStrings[stringRow] == target:\n        for j, col in enumerate(cols):\n          if picture[i][j] == 'B' and col == target:\n            ans += 1\n\n    return ans",
      "title": "533. Lonely Pixel II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d53dd0cc-ca24-481e-817a-ebb28a88cd21",
      "code": "class Solution:\n  def complexNumberMultiply(self, num1: str, num2: str) -> str:\n    a0, a1 = self._getReala0ndImag(num1)\n    b0, b1 = self._getReala0ndImag(num2)\n    return str(a0 * b0 - a1 * b1) + '+' + str(a0 * b1 + a1 * b0) + 'i'\n\n  def _getReala0ndImag(self, s: str) -> tuple:\n    return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])",
      "title": "537. Complex Number Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b2f2541-c2fd-42e7-b8f3-e52fe5fe14ac",
      "code": "class Solution:\n  def convertBST(self, root: TreeNode | None) -> TreeNode | None:\n    prefix = 0\n\n    def reversedInorder(root: TreeNode | None) -> None:\n      nonlocal prefix\n      if not root:\n        return\n\n      reversedInorder(root.right)\n      prefix += root.val\n      root.val = prefix\n      reversedInorder(root.left)\n\n    reversedInorder(root)\n    return root",
      "title": "538. Convert BST to Greater Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58f381e2-b6f4-42ef-8575-7cb85b12b9d7",
      "code": "class Solution:\n  def findMinDifference(self, timePoints: list[str]) -> int:\n    ans = 24 * 60\n    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])\n                   for timePoint in timePoints])\n\n    for a, b in zip(nums, nums[1:]):\n      ans = min(ans, b - a)\n\n    return min(ans, 24 * 60 - nums[-1] + nums[0])",
      "title": "539. Minimum Time Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2efb1a19-fc53-4380-8593-90fdf55f877d",
      "code": "class Solution:\n  def singleNonDuplicate(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if m % 2 == 1:\n        m -= 1\n      if nums[m] == nums[m + 1]:\n        l = m + 2\n      else:\n        r = m\n\n    return nums[l]",
      "title": "540. Single Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a49c42d-487c-4366-a7c0-997578309ad9",
      "code": "class Solution:\n  def reverseStr(self, s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2 * k] + self.reverseStr(s[2 * k:], k) if s else \"\"",
      "title": "541. Reverse String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e44dd46d-f708-4b7e-8ab2-0e60c2b65d0d",
      "code": "class Solution:\n  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat",
      "title": "542. 01 Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "becaf76f-f5b5-43fd-ba4c-32619505bf16",
      "code": "class Solution:\n  def diameterOfBinaryTree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def maxDepth(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = maxDepth(root.left)\n      r = maxDepth(root.right)\n      ans = max(ans, l + r)\n      return 1 + max(l, r)\n\n    maxDepth(root)\n    return ans",
      "title": "543. Diameter of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60355be9-cc1a-4f28-b27a-12bc0c9c359c",
      "code": "class Solution:\n  def findContestMatch(self, n: int) -> str:\n    def generateMatches(matches: list[str]) -> str:\n      if len(matches) == 1:\n        return matches[0]\n\n      nextMatches = []\n\n      for i in range(len(matches) // 2):\n        nextMatches.append(\n            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')\n\n      return generateMatches(nextMatches)\n\n    return generateMatches([str(i + 1) for i in range(n)])",
      "title": "544. Output Contest Matches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5efd69b8-cffb-4da6-a612-c51d215cd56e",
      "code": "class Solution:\n  def boundaryOfBinaryTree(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = [root.val]\n\n    def dfs(root: TreeNode | None, lb: bool, rb: bool):\n      \"\"\"\n      1. root.left is left boundary if root is left boundary.\n         root.right if left boundary if root.left is None.\n      2. Same applys for right boundary.\n      3. If root is left boundary, add it before 2 children - preorder.\n         If root is right boundary, add it after 2 children - postorder.\n      4. A leaf that is neighter left/right boundary belongs to the bottom.\n      \"\"\"\n      if not root:\n        return\n      if lb:\n        ans.append(root.val)\n      if not lb and not rb and not root.left and not root.right:\n        ans.append(root.val)\n\n      dfs(root.left, lb, rb and not root.right)\n      dfs(root.right, lb and not root.left, rb)\n      if rb:\n        ans.append(root.val)\n\n    dfs(root.left, True, False)\n    dfs(root.right, False, True)\n    return ans",
      "title": "545. Boundary of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8a18525-9ec4-42de-8c1f-941e88a70ca2",
      "code": "class Solution:\n  def removeBoxes(self, boxes: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].\n      \"\"\"\n      if i > j:\n        return 0\n\n      r = j\n      sameBoxes = k + 1\n      while r > 0 and boxes[r - 1] == boxes[r]:\n        r -= 1\n        sameBoxes += 1\n      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes\n\n      for p in range(i, r):\n        if boxes[p] == boxes[r]:\n          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))\n\n      return res\n\n    return dp(0, len(boxes) - 1, 0)",
      "title": "546. Remove Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce3e7d5-168e-45ba-b860-21731744e06c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: list[list[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count",
      "title": "547. Friend Circles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5db17a15-ba13-4dfd-94b3-32395c333a77",
      "code": "class Solution:\n  def checkRecord(self, s: str) -> bool:\n    return s.count('A') <= 1 and 'LLL' not in s",
      "title": "551. Student Attendance Record I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5120e2b-fc1d-4bf1-8779-2726f216fd14",
      "code": "class Solution:\n  def checkRecord(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the length so far with i A's and the last letters are j L's\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1\n\n    for _ in range(n):\n      prev = [A[:] for A in dp]\n\n      # Append a P.\n      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % MOD\n\n      # Append an L.\n      dp[0][1] = prev[0][0]\n\n      # Append an L.\n      dp[0][2] = prev[0][1]\n\n      # Append an A or append a P.\n      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +\n                  prev[1][0] + prev[1][1] + prev[1][2]) % MOD\n\n      # Append an L.\n      dp[1][1] = prev[1][0]\n\n      # Append an L.\n      dp[1][2] = prev[1][1]\n\n    return (sum(dp[0]) + sum(dp[1])) % MOD",
      "title": "552. Student Attendance Record II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fed631e9-f8dc-46c1-815f-744f64c917cd",
      "code": "class Solution:\n  def optimalDivision(self, nums: list[int]) -> str:\n    ans = str(nums[0])\n\n    if len(nums) == 1:\n      return ans\n    if len(nums) == 2:\n      return ans + '/' + str(nums[1])\n\n    ans += '/(' + str(nums[1])\n    for i in range(2, len(nums)):\n      ans += '/' + str(nums[i])\n    ans += ')'\n    return ans",
      "title": "553. Optimal Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "341d74c4-dc9f-4a76-beba-4bf02aa7b859",
      "code": "class Solution:\n  def leastBricks(self, wall: list[list[int]]) -> int:\n    maxFreq = 0\n    count = collections.defaultdict(int)\n\n    for row in wall:\n      prefix = 0\n      for i in range(len(row) - 1):\n        prefix += row[i]\n        count[prefix] += 1\n        maxFreq = max(maxFreq, count[prefix])\n\n    return len(wall) - maxFreq",
      "title": "554. Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bdf6dc-0ee8-4a48-9d16-a88936663c05",
      "code": "class Solution:\n  def splitLoopedString(self, strs: list[str]) -> str:\n    ans = ''\n    sortedStrs = [max(s, s[::-1]) for s in strs]\n\n    for i, sortedStr in enumerate(sortedStrs):\n      for s in (sortedStr, sortedStr[::-1]):\n        for j in range(len(s) + 1):\n          ans = max(\n              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])\n\n    return ans",
      "title": "555. Split Concatenated Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "145617e8-a200-4947-a71c-aba22b43f846",
      "code": "class Solution:\n  def nextGreaterElement(self, n: int) -> int:\n    def nextPermutation(s: list[str]) -> str:\n      i = len(s) - 2\n      while i >= 0:\n        if s[i] < s[i + 1]:\n          break\n        i -= 1\n\n      if i >= 0:\n        for j in range(len(s) - 1, i, -1):\n          if s[j] > s[i]:\n            break\n        s[i], s[j] = s[j], s[i]\n\n      reverse(s, i + 1, len(s) - 1)\n      return ''.join(s)\n\n    def reverse(s: list[str], l: int, r: int):\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    s = nextPermutation(list(str(n)))\n    ans = int(s)\n    return -1 if ans > 2**31 - 1 or ans <= n else ans",
      "title": "556. Next Greater Element III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aacab23-e831-4c41-a774-acfce58ae47c",
      "code": "class Solution:\n  def maxDepth(self, root: 'Node') -> int:\n    if not root:\n      return 0\n    if not root.children:\n      return 1\n    return 1 + max(self.maxDepth(child) for child in root.children)",
      "title": "559. Maximum Depth of N-ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0915ccee-593c-4312-9bbb-2ce58b384f1f",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix += num\n      ans += count[prefix - k]\n      count[prefix] += 1\n\n    return ans",
      "title": "560. Subarray Sum Equals K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "023ef533-10db-4357-b228-ea16ebf1c9a4",
      "code": "class Solution:\n  def arrayPairSum(self, nums: list[int]) -> int:\n    return sum(sorted(nums)[::2])",
      "title": "561. Array Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93d66a90-fb12-4344-8ef0-8abd24a63c0e",
      "code": "class Solution:\n  def longestLine(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    # dp[i][j][0] := horizontal\n    # dp[i][j][1] := vertical\n    # dp[i][j][2] := diagonal\n    # dp[i][j][3] := anti-diagonal\n    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1\n          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1\n          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1\n          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1\n          ans = max(ans, max(dp[i][j]))\n\n    return ans",
      "title": "562. Longest Line of Consecutive One in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dbd633b-a77c-4416-a673-82534e1cb2ea",
      "code": "class Solution:\n  def findTilt(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def summ(root: TreeNode | None) -> None:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = summ(root.left)\n      r = summ(root.right)\n      ans += abs(l - r)\n      return root.val + l + r\n\n    summ(root)\n    return ans",
      "title": "563. Binary Tree Tilt",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "369abe30-1fe5-45ba-9f35-545b1769c13f",
      "code": "class Solution:\n  def nearestPalindromic(self, n: str) -> str:\n    prevPalindrome, nextPalindrome = self._getPalindromes(n)\n    return (str(prevPalindrome)\n            if abs(prevPalindrome - int(n)) <= abs(nextPalindrome - int(n))\n            else str(nextPalindrome))\n\n  def _getPalindromes(self, s: str) -> tuple[str, str]:\n    \"\"\"Returns the two closest palindromes to the given number.\"\"\"\n    num = int(s)\n    sz = len(s)\n    palindromes = []\n    half = s[0:(sz + 1) // 2]\n    reversedHalf = half[:sz // 2][::-1]\n    candidate = int(half + reversedHalf)\n\n    if candidate < num:\n      palindromes.append(candidate)\n    else:\n      prevHalf = str(int(half) - 1)\n      reversedPrevHalf = prevHalf[:sz // 2][::-1]\n      if sz % 2 == 0 and int(prevHalf) == 0:\n        palindromes.append(9)\n      elif sz % 2 == 0 and prevHalf == '9':\n        palindromes.append(int(prevHalf + '9' + reversedPrevHalf))\n      else:\n        palindromes.append(int(prevHalf + reversedPrevHalf))\n\n    if candidate > num:\n      palindromes.append(candidate)\n    else:\n      nextHalf = str(int(half) + 1)\n      reversedNextHalf = nextHalf[:sz // 2][::-1]\n      palindromes.append(int(nextHalf + reversedNextHalf))\n\n    return palindromes",
      "title": "564. Find the Closest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6f987ba-ba86-492b-838b-c8eb6061382d",
      "code": "class Solution:\n  def arrayNesting(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if num == -1:\n        continue\n      index = num\n      count = 0\n      while nums[index] != -1:\n        cache = index\n        index = nums[index]\n        nums[cache] = -1\n        count += 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "565. Array Nesting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b90d50cb-3ba3-4128-a757-74c9b700755b",
      "code": "class Solution:\n  def matrixReshape(self, nums: list[list[int]],\n                    r: int, c: int) -> list[list[int]]:\n    if nums == [] or r * c != len(nums) * len(nums[0]):\n      return nums\n\n    ans = [[0 for j in range(c)] for i in range(r)]\n    k = 0\n\n    for row in nums:\n      for num in row:\n        ans[k // c][k % c] = num\n        k += 1\n\n    return ans",
      "title": "566. Reshape the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44e1bd35-c349-4cb5-acdd-0ca9f171b280",
      "code": "class Solution:\n  def checkInclusion(self, s1: str, s2: str) -> bool:\n    count = collections.Counter(s1)\n    required = len(s1)\n\n    for r, c in enumerate(s2):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(s1):  # The window is oversized.\n        count[s2[r - len(s1)]] += 1\n        if count[s2[r - len(s1)]] > 0:\n          required += 1\n      if required == 0:\n        return True\n\n    return False",
      "title": "567. Permutation in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebc313f7-b687-46ce-a427-4e0fac2b868e",
      "code": "class Solution:\n  def minDistance(\n      self,\n      height: int,\n      width: int,\n      tree: list[int],\n      squirrel: list[int],\n      nuts: list[list[int]],\n  ) -> int:\n    def dist(a: list[int], b: list[int]) -> int:\n      return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    totDist = sum(dist(nut, tree) for nut in nuts) * 2\n    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)\n    return totDist - maxSave",
      "title": "573. Squirrel Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22336040-1a2d-4ce0-bd4d-934a91791c89",
      "code": "class Solution:\n  def distributeCandies(self, candies: list[int]) -> int:\n    return min(len(candies) // 2, len(set(candies)))",
      "title": "575. Distribute Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc8855a-6e70-4aa3-b378-9850cb43f95b",
      "code": "class Solution:\n  def findPaths(\n      self,\n      m: int,\n      n: int,\n      maxMove: int,\n      startRow: int,\n      startColumn: int,\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n\n    for _ in range(maxMove):\n      newDp = [[0] * n for _ in range(m)]\n      for i in range(m):\n        for j in range(n):\n          if dp[i][j] > 0:\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                ans = (ans + dp[i][j]) % MOD\n              else:\n                newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return ans",
      "title": "576. Out of Boundary Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a34bb259-0110-40e3-98ea-aa6e2851bfae",
      "code": "class Solution:\n  def findUnsortedSubarray(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mn = min(mn, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        mx = max(mx, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mn:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < mx:\n        break\n\n    return 0 if l >= r else r - l + 1",
      "title": "581. Shortest Unsorted Continuous Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8faa324-4939-4980-a122-fb5b1cb1fc89",
      "code": "class Solution:\n  def killProcess(\n      self,\n      pid: list[int],\n      ppid: list[int],\n      kill: int,\n  ) -> list[int]:\n    ans = []\n    tree = collections.defaultdict(list)\n\n    for v, u in zip(pid, ppid):\n      if u == 0:\n        continue\n      tree[u].append(v)\n\n    def dfs(u: int) -> None:\n      ans.append(u)\n      for v in tree.get(u, []):\n        dfs(v)\n\n    dfs(kill)\n    return ans",
      "title": "582. Kill Process",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4e25101-c9ab-4554-bae7-d1dd792213ce",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    k = self._lcs(word1, word2)\n    return (len(word1) - k) + (len(word2) - k)\n\n  def _lcs(self, a: str, b: str) -> int:\n    m = len(a)\n    n = len(b)\n    # dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if a[i - 1] == b[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]",
      "title": "583. Delete Operation for Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a14fd8f-ba8f-444e-afff-2faa05d4957f",
      "code": "class Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\n    hull = []\n\n    trees.sort(key=lambda x: (x[0], x[1]))\n\n    def cross(p: list[int], q: list[int], r: list[int]) -> int:\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\n    # Build the lower hull: left-to-right scan.\n    for tree in trees:\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n    hull.pop()\n\n    # Build the upper hull: right-to-left scan.\n    for tree in reversed(trees):\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n\n    # Remove the redundant elements from the stack.\n    return list(set(hull))",
      "title": "587. Erect the Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9eaf6f46-7f27-4a56-b2a1-fe9225fc655b",
      "code": "class Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        # It's inside a tag, so check if it's a cdata.\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':  # the end tag\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 2: closeIndex],\n                  True):\n            return False\n        else:  # the start tag\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 1: closeIndex],\n                  False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag",
      "title": "591. Tag Validator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64f80da9-b2b0-4c15-98df-329e6fe2ad0a",
      "code": "class Solution:\n  def fractionAddition(self, expression: str) -> str:\n    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))\n    A = 0\n    B = 1\n\n    for a, b in zip(ints[::2], ints[1::2]):\n      A = A * b + a * B\n      B *= b\n      g = math.gcd(A, B)\n      A //= g\n      B //= g\n\n    return str(A) + '/' + str(B)",
      "title": "592. Fraction Addition and Subtraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3308d64b-34be-44a4-931d-566853501502",
      "code": "class Solution:\n  def validSquare(\n      self,\n      p1: list[int],\n      p2: list[int],\n      p3: list[int],\n      p4: list[int],\n  ) -> bool:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    distSet = set([dist(*pair)\n                   for pair in list(\n                       itertools.combinations([p1, p2, p3, p4], 2))])\n    return 0 not in distSet and len(distSet) == 2",
      "title": "593. Valid Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58ff43d5-1355-47cf-b80d-21a08f467bb5",
      "code": "class Solution:\n  def findLHS(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num + 1 in count:\n        ans = max(ans, freq + count[num + 1])\n\n    return ans",
      "title": "594. Longest Harmonious Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f456e13e-4b01-40d6-a840-49dcfd53c8b4",
      "code": "class Solution:\n  def maxCount(self, m: int, n: int, ops: list[list[int]]) -> int:\n    minY = m\n    minX = n\n\n    for y, x in ops:\n      minY = min(minY, y)\n      minX = min(minX, x)\n\n    return minX * minY",
      "title": "598. Range Addition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a47bcf26-a746-481d-8fd7-3c62c8bfae45",
      "code": "class Solution:\n  def findRestaurant(self, list1: list[str], list2: list[str]) -> list[str]:\n    ans = []\n    restaurantToIndex = {restaurant: i for i,\n                         restaurant in enumerate(list1)}\n    minSum = math.inf\n\n    for i, restaurant in enumerate(list2):\n      if restaurant in restaurantToIndex:\n        summ = restaurantToIndex[restaurant] + i\n        if summ < minSum:\n          ans.clear()\n        if summ <= minSum:\n          ans.append(restaurant)\n          minSum = summ\n\n    return ans",
      "title": "599. Minimum Index Sum of Two Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b407aa4-b85c-44fd-9643-0670a4aa1d2c",
      "code": "class Solution:\n  def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:\n    for i, flower in enumerate(flowerbed):\n      if flower == 0 and (\n              i == 0 or flowerbed[i - 1] == 0) and (\n              i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n        flowerbed[i] = 1\n        n -= 1\n      if n <= 0:\n        return True\n\n    return False",
      "title": "605. Can Place Flowers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f64de568-1ba6-4640-b7d8-8be95188838b",
      "code": "class Solution:\n  def tree2str(self, t: TreeNode | None) -> str:\n    def dfs(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n      if root.right:\n        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'\n      if root.left:\n        return str(root.val) + '(' + dfs(root.left) + ')'\n      return str(root.val)\n    return dfs(t)",
      "title": "606. Construct String from Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "029c640b-166f-43e9-91c3-8a2c9b273764",
      "code": "class Solution:\n  def findDuplicate(self, paths: list[str]) -> list[list[str]]:\n    contentToPathFiles = collections.defaultdict(list)\n\n    for path in paths:\n      words = path.split(' ')\n      rootPath = words[0]  # \"root/d1/d2/.../dm\"\n      for fileAndContent in words[1:]:  # \"fn.txt(fn_content)\"\n        l = fileAndContent.find('(')\n        r = fileAndContent.find(')')\n        # \"fn.txt\"\n        file = fileAndContent[:l]\n        # \"fn_content\"\n        content = fileAndContent[l + 1:r]\n        # \"root/d1/d2/.../dm/fn.txt\"\n        filePath = rootPath + '/' + file\n        contentToPathFiles[content].append(filePath)\n\n    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]",
      "title": "609. Find Duplicate File in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab7555c7-adf3-412b-b0df-b792fce1b2e4",
      "code": "class Solution:\n  def triangleNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for k in range(len(nums) - 1, 1, -1):\n      i = 0\n      j = k - 1\n      while i < j:\n        if nums[i] + nums[j] > nums[k]:\n          ans += j - i\n          j -= 1\n        else:\n          i += 1\n\n    return ans",
      "title": "611. Valid Triangle Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2ea333b-4a0e-47a6-9d34-b93628a59f2b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def addBoldTag(self, s: str, words: list[str]) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        if s[j] not in node.children:\n          node.children[s[j]] = TrieNode()\n        node = node.children[s[j]]\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "616. Add Bold Tag in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8a84271-4bc1-4dbb-bbf9-4e72bd2741e5",
      "code": "class Solution:\n  def mergeTrees(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root1 and not root2:\n      return None\n    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)\n    root = TreeNode(val)\n    root.left = self.mergeTrees(root1.left if root1 else None,\n                                root2.left if root2 else None)\n    root.right = self.mergeTrees(root1.right if root1 else None,\n                                 root2.right if root2 else None)\n    return root",
      "title": "617. Merge Two Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "399b8c05-c250-4054-ab76-967adcdad078",
      "code": "class Solution:\n  def leastInterval(self, tasks: list[str], n: int) -> int:\n    count = collections.Counter(tasks)\n    maxFreq = max(count.values())\n    # Put the most frequent task in the slot first.\n    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)\n    # Get the number of tasks with same frequency as maxFreq, we'll append them after the\n    # `maxFreqTaskOccupy`.\n    nMaxFreq = sum(value == maxFreq for value in count.values())\n    # max(\n    #   the most frequent task is frequent enough to force some idle slots,\n    #   the most frequent task is not frequent enough to force idle slots\n    # )\n    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))",
      "title": "621. Task Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1c9b15e-7e60-4344-bb35-5551654e90c6",
      "code": "class Solution:\n  def maxDistance(self, arrays: list[list[int]]) -> int:\n    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))\n    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))\n    if index_min1 != index_max1:\n      return max1 - min1\n\n    min2, index_min2 = min((A[0], i)\n                           for i, A in enumerate(arrays) if i != index_min1)\n    max2, index_min2 = max((A[-1], i)\n                           for i, A in enumerate(arrays) if i != index_max1)\n    return max(max1 - min2, max2 - min1)",
      "title": "624. Maximum Distance in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a1b1b36-bf27-4e65-9bcf-f527743e5581",
      "code": "class Solution:\n  def smallestFactorization(self, num: int) -> int:\n    if num == 1:\n      return 1\n\n    ans = 0\n    base = 1\n\n    for i in range(9, 1, -1):\n      while num % i == 0:\n        num //= i\n        ans = base * i + ans\n        base *= 10\n\n    return ans if num == 1 and ans < 2**31 - 1 else 0",
      "title": "625. Minimum Factorization",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1be5d659-ac86-4d52-a231-1427495cb91e",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int]) -> int:\n    min1 = inf   # the minimum\n    min2 = inf   # the second minimum\n    max1 = -inf  # the maximum\n    max2 = -inf  # the second maximum\n    max3 = -inf  # the third maximum\n\n    for num in nums:\n      if num <= min1:\n        min2 = min1\n        min1 = num\n      elif num <= min2:\n        min2 = num\n\n      if num >= max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif num >= max2:\n        max3 = max2\n        max2 = num\n      elif num >= max3:\n        max3 = num\n\n    return max(max1 * min1 * min2, max1 * max2 * max3)",
      "title": "628. Maximum Product of Three Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b12aff6f-e7fd-44dc-82b6-8a46fe071778",
      "code": "class Solution:\n  def kInversePairs(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # If there's no inverse pair, the permutation is unique '123..i'\n    for i in range(n + 1):\n      dp[i][0] = 1\n\n    for i in range(1, n + 1):\n      for j in range(1, k + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n        if j - i >= 0:\n          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n\n    return dp[n][k]",
      "title": "629. K Inverse Pairs Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "299d4297-c28c-4f28-8a7e-6b5eaf665ca0",
      "code": "class Solution:\n  def scheduleCourse(self, courses: list[list[int]]) -> int:\n    time = 0\n    maxHeap = []\n\n    for duration, lastDay in sorted(courses, key=lambda x: x[1]):\n      heapq.heappush(maxHeap, -duration)\n      time += duration\n      # If the current course cannot be taken, check if it can be swapped with\n      # a previously taken course that has a larger duration to increase the\n      # time available to take upcoming courses.\n      if time > lastDay:\n        time += heapq.heappop(maxHeap)\n\n    return len(maxHeap)",
      "title": "630. Course Schedule III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "733f0b02-96f6-4652-a33e-3c332148c3f1",
      "code": "class Solution:\n  def smallestRange(self, nums: list[list[int]]) -> list[int]:\n    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    maxRange = max(row[0] for row in nums)\n    minRange = heapq.nsmallest(1, minHeap)[0][0]\n    ans = [minRange, maxRange]\n\n    while len(minHeap) == len(nums):\n      num, r, c = heapq.heappop(minHeap)\n      if c + 1 < len(nums[r]):\n        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))\n        maxRange = max(maxRange, nums[r][c + 1])\n        minRange = heapq.nsmallest(1, minHeap)[0][0]\n        if maxRange - minRange < ans[1] - ans[0]:\n          ans[0], ans[1] = minRange, maxRange\n\n    return ans",
      "title": "632. Smallest Range Covering Elements from K Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0997f237-bd1b-40d2-8edc-570eceecdd43",
      "code": "class Solution:\n  def judgeSquareSum(self, c: int) -> bool:\n    l = 0\n    r = math.isqrt(c)\n\n    while l <= r:\n      summ = l * l + r * r\n      if summ == c:\n        return True\n      if summ < c:\n        l += 1\n      else:\n        r -= 1\n\n    return False",
      "title": "633. Sum of Square Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4b917a1-a4d3-4db6-bb1c-2f72a97bfc77",
      "code": "class Solution:\n  def findDerangement(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      if i == 0:\n        return 1\n      if i == 1:\n        return 0\n      return (i - 1) * (dp(i - 1) + dp(i - 2)) % MOD\n\n    return dp(n)",
      "title": "634. Find the Derangement of An Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "243dccd5-a05e-4d9e-9a8e-703e115edba9",
      "code": "class Solution:\n  def shoppingOffers(\n      self,\n      price: list[int],\n      special: list[list[int]],\n      needs: list[int]\n  ) -> int:\n    def dfs(s: int) -> int:\n      ans = 0\n      for i, need in enumerate(needs):\n        ans += need * price[i]\n\n      for i in range(s, len(special)):\n        offer = special[i]\n        if all(offer[j] <= need for j, need in enumerate(needs)):\n          # Use the special[i].\n          for j in range(len(needs)):\n            needs[j] -= offer[j]\n          ans = min(ans, offer[-1] + dfs(i))\n          # Unuse the special[i] (backtracking).\n          for j in range(len(needs)):\n            needs[j] += offer[j]\n\n      return ans\n\n    return dfs(0)",
      "title": "638. Shopping Offers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4fb777b1-bfee-4ff6-a7f2-e7643236c238",
      "code": "class Solution:\n  def solveEquation(self, equation: str) -> str:\n    def calculate(s: str) -> tuple:\n      coefficient = 0\n      constant = 0\n      num = 0\n      sign = 1\n\n      for i, c in enumerate(s):\n        if c.isdigit():\n          num = num * 10 + int(c)\n        elif c in '+-':\n          constant += sign * num\n          sign = 1 if c == '+' else -1\n          num = 0\n        else:\n          if i > 0 and num == 0 and s[i - 1] == '0':\n            continue\n          coefficient += sign if num == 0 else sign * num\n          num = 0\n\n      return coefficient, constant + sign * num\n\n    lhsEquation, rhsEquation = equation.split('=')\n    lhsCoefficient, lhsConstant = calculate(lhsEquation)\n    rhsCoefficient, rhsConstant = calculate(rhsEquation)\n    coefficient = lhsCoefficient - rhsCoefficient\n    constant = rhsConstant - lhsConstant\n\n    if coefficient == 0 and constant == 0:\n      return \"Infinite solutions\"\n    if coefficient == 0 and constant != 0:\n      return \"No solution\"\n    return \"x=\" + str(constant // coefficient)",
      "title": "640. Solve the Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c3cfb48-00f8-4520-9b5c-07d951745747",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    summ = sum(nums[:k])\n    ans = summ\n\n    for i in range(k, len(nums)):\n      summ += nums[i] - nums[i - k]\n      ans = max(ans, summ)\n\n    return ans / k",
      "title": "643. Maximum Average Subarray I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db7b67f0-1b18-44c9-bf9d-fbd53fa71b9f",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    ERR = 1e-5\n    l = min(nums)\n    r = max(nums)\n\n    def check(m: float) -> bool:\n      \"\"\"\n      Returns True if there's a subarray, where its length >= k and its average\n      sum >= m.\n      \"\"\"\n      summ = 0\n      prevSum = 0\n      minPrevSum = 0\n\n      for i, num in enumerate(nums):\n        # Need to substract m for each `num` so that we can check if the sum of\n        # the subarray >= 0.\n        summ += num - m\n        if i >= k:\n          prevSum += nums[i - k] - m\n          minPrevSum = min(minPrevSum, prevSum)\n        if i + 1 >= k and summ >= minPrevSum:\n          return True\n\n      return False\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if check(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "644. Maximum Average Subarray II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49a21672-44ee-4259-b78e-ac2f39ed44a0",
      "code": "class Solution:\n  def findErrorNums(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      if nums[abs(num) - 1] < 0:\n        duplicate = abs(num)\n      else:\n        nums[abs(num) - 1] *= -1\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        return [duplicate, i + 1]",
      "title": "645. Set Mismatch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c977ea18-cdb3-453b-8dd6-ecba73647744",
      "code": "class Solution:\n  def findLongestChain(self, pairs: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = -math.inf\n\n    for s, e in sorted(pairs, key=lambda x: x[1]):\n      if s > prevEnd:\n        ans += 1\n        prevEnd = e\n\n    return ans",
      "title": "646. Maximum Length of Pair Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "238f452c-6713-4f3e-a414-e5c46bd35147",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    def extendPalindromes(l: int, r: int) -> int:\n      count = 0\n\n      while l >= 0 and r < len(s) and s[l] == s[r]:\n        count += 1\n        l -= 1\n        r += 1\n\n      return count\n\n    ans = 0\n\n    for i in range(len(s)):\n      ans += extendPalindromes(i, i)\n      ans += extendPalindromes(i, i + 1)\n\n    return ans",
      "title": "647. Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d4ed161-5f6b-47ec-ac20-0cf66e31fbd4",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])",
      "title": "648. Replace Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4a357f7-2671-4877-a362-35304d1df899",
      "code": "class Solution:\n  def minSteps(self, n: int) -> int:\n    if n <= 1:\n      return 0\n\n    # dp[i] := the minimum steps to get i 'A's\n    # Copy 'A', then paste 'A' i - 1 times.\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n      for j in range(i // 2, 2, -1):\n        if i % j == 0:\n          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.\n          break\n\n    return dp[n]",
      "title": "650. 2 Keys Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e0b7d42-30ff-4e81-9cda-e1c263dfbf13",
      "code": "class Solution:\n  def findDuplicateSubtrees(self, root: TreeNode | None) -> list[TreeNode | None]:\n    ans = []\n    count = collections.Counter()\n\n    def encode(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n\n      encoded = (str(root.val) + '#' +\n                 encode(root.left) + '#' +\n                 encode(root.right))\n      count[encoded] += 1\n      if count[encoded] == 2:\n        ans.append(root)\n      return encoded\n\n    encode(root)\n    return ans",
      "title": "652. Find Duplicate Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef97125d-cdba-4656-a9bc-39bbd8c76391",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def findTarget(self, root: TreeNode | None, k: int) -> bool:\n    if not root:\n      return False\n\n    left = BSTIterator(root, True)\n    right = BSTIterator(root, False)\n\n    l = left.next()\n    r = right.next()\n    while l < r:\n      summ = l + r\n      if summ == k:\n        return True\n      if summ < k:\n        l = left.next()\n      else:\n        r = right.next()\n\n    return False",
      "title": "653. Two Sum IV - Input is a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd1a32df-06eb-468a-82e6-3f478750bb88",
      "code": "class Solution:\n  def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode | None:\n    def build(i: int, j: int) -> TreeNode | None:\n      if i > j:\n        return None\n\n      maxNum = max(nums[i:j + 1])\n      maxIndex = nums.index(maxNum)\n\n      root = TreeNode(maxNum)\n      root.left = build(i, maxIndex - 1)\n      root.right = build(maxIndex + 1, j)\n      return root\n\n    return build(0, len(nums) - 1)",
      "title": "654. Maximum Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e8a05bf-17af-403b-95f2-2dbacd67d32f",
      "code": "class Solution:\n  def printTree(self, root: TreeNode | None) -> list[list[str]]:\n    def maxHeight(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxHeight(root.left), maxHeight(root.right))\n\n    def dfs(root: TreeNode | None, row: int, left: int, right: int) -> None:\n      if not root:\n        return\n\n      mid = (left + right) // 2\n      ans[row][mid] = str(root.val)\n      dfs(root.left, row + 1, left, mid - 1)\n      dfs(root.right, row + 1, mid + 1, right)\n\n    m = maxHeight(root)\n    n = pow(2, m) - 1\n    ans = [[''] * n for _ in range(m)]\n    dfs(root, 0, 0, len(ans[0]) - 1)\n    return ans",
      "title": "655. Print Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "458158d7-93ed-4daf-9ff3-d1ef4dd822c4",
      "code": "class Solution:\n  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:\n    if coins[-1] == -1:\n      return []\n\n    n = len(coins)\n    # dp[i] := the minimum cost to jump from i to n - 1\n    dp = [math.inf] * n\n    next = [-1] * n\n\n    def cheapestJump(i: int) -> int:\n      if i == len(coins) - 1:\n        dp[i] = coins[i]\n        return dp[i]\n      if dp[i] < math.inf:\n        return dp[i]\n      if coins[i] == -1:\n        return math.inf\n\n      for j in range(i + 1, min(i + maxJump + 1, n)):\n        res = cheapestJump(j)\n        if res == math.inf:\n          continue\n        cost = coins[i] + res\n        if cost < dp[i]:\n          dp[i] = cost\n          next[i] = j\n\n      return dp[i]\n\n    cheapestJump(0)\n    if dp[0] == math.inf:\n      return []\n    return self._constructPath(next, 0)\n\n  def _constructPath(self, next: list[int], i: int) -> list[int]:\n    ans = []\n    while i != -1:\n      ans.append(i + 1)  # 1-indexed\n      i = next[i]\n    return ans",
      "title": "656. Coin Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "434aa2b6-06b1-45ae-98e7-c587fac5ffe9",
      "code": "class Solution:\n  def judgeCircle(self, moves: str) -> bool:\n    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')",
      "title": "657. Robot Return to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f46ca5c2-0d6e-4535-ab25-4b5113166b45",
      "code": "class Solution:\n  def findClosestElements(self, arr: list[int], k: int, x: int) -> list[int]:\n    l = 0\n    r = len(arr) - k\n\n    while l < r:\n      m = (l + r) // 2\n      if x - arr[m] <= arr[m + k] - x:\n        r = m\n      else:\n        l = m + 1\n\n    return arr[l:l + k]",
      "title": "658. Find K Closest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f888f34b-13dc-430c-80f7-c2b670966358",
      "code": "class Solution:\n  def newInteger(self, n: int) -> int:\n    ans = []\n    while n:\n      ans.append(str(n % 9))\n      n //= 9\n    return ''.join(reversed(ans))",
      "title": "660. Remove 9",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c97b4810-3337-46ee-a09e-01da30240525",
      "code": "class Solution:\n  def imageSmoother(self, M: list[list[int]]) -> list[list[int]]:\n    m = len(M)\n    n = len(M[0])\n    ans = [[0 for j in range(n)] for i in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        count = 0\n        for y in range(max(0, i - 1), min(m, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            ones += M[y][x]\n            count += 1\n        ans[i][j] = ones // count\n\n    return ans",
      "title": "661. Image Smoother",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9615dc32-ed3e-4b6b-94a3-b9ca09c818fd",
      "code": "class Solution:\n  def checkEqualTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n\n    seen = set()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      seen.add(summ)\n      return summ\n\n    summ = root.val + dfs(root.left) + dfs(root.right)\n    return summ % 2 == 0 and summ // 2 in seen",
      "title": "663. Equal Tree Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8e2100-620a-4914-b6ad-4ade0c4cb207",
      "code": "class Solution:\n  def checkPossibility(self, nums: list[int]) -> bool:\n    j = None\n\n    for i in range(len(nums) - 1):\n      if nums[i] > nums[i + 1]:\n        if j is not None:\n          return False\n        j = i\n\n    return (j is None or j == 0 or j == len(nums) - 2 or\n            nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2])",
      "title": "665. Non-decreasing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b788cd3-52dd-441e-b5b9-d87627514aef",
      "code": "class Solution:\n  def pathSum(self, nums: list[int]) -> int:\n    ans = 0\n    tree = [[-1] * 8 for _ in range(4)]\n\n    for num in nums:\n      d = num // 100 - 1\n      p = (num % 100) // 10 - 1\n      v = num % 10\n      tree[d][p] = v\n\n    def dfs(i: int, j: int, path: int) -> None:\n      nonlocal ans\n      if tree[i][j] == -1:\n        return\n      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:\n        ans += path + tree[i][j]\n        return\n\n      dfs(i + 1, j * 2, path + tree[i][j])\n      dfs(i + 1, j * 2 + 1, path + tree[i][j])\n\n    dfs(0, 0, 0)\n    return ans",
      "title": "666. Path Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "680e5e2a-fd87-4774-8dc4-5529523684ba",
      "code": "class Solution:\n  def constructArray(self, n: int, k: int) -> list[int]:\n    ans = list(range(1, n - k + 1))\n\n    for i in range(k):\n      if i % 2 == 0:\n        ans.append(n - i // 2)\n      else:\n        ans.append(n - k + (i + 1) // 2)\n\n    return ans",
      "title": "667. Beautiful Arrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dec4767-61fe-450d-94ad-8592c49e8219",
      "code": "class Solution:\n  def maximumSwap(self, num: int) -> int:\n    s = list(str(num))\n    dict = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n      for digit in reversed(string.digits):\n        if digit <= c:\n          break\n        if digit in dict and dict[digit] > i:\n          s[i], s[dict[digit]] = digit, s[i]\n          return int(''.join(s))\n\n    return num",
      "title": "670. Maximum Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71ffa310-30ee-47af-b61c-badd9801b978",
      "code": "class Solution:\n  def flipLights(self, n: int, m: int) -> int:\n    n = min(n, 3)\n\n    if m == 0:\n      return 1\n    if m == 1:\n      return [2, 3, 4][n - 1]\n    if m == 2:\n      return [2, 4, 7][n - 1]\n\n    return [2, 4, 8][n - 1]",
      "title": "672. Bulb Switcher II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f30a4ee-1625-40c1-8e26-9dfed72a598a",
      "code": "class Solution:\n  def findNumberOfLIS(self, nums: list[int]) -> int:\n    ans = 0\n    maxLength = 0\n    # length[i] := the length of the LIS ending in nums[i]\n    length = [1] * len(nums)\n    # count[i] := the number of LIS's ending in nums[i]\n    count = [1] * len(nums)\n\n    # Calculate the `length` and `count` arrays.\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    # Get the number of LIS.\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans",
      "title": "673. Number of Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a93d34d-e393-4cec-9c4e-6446ec344c3d",
      "code": "class Solution:\n  def findLengthOfLCIS(self, nums: list[int]) -> int:\n    ans = 0\n    j = 0\n\n    for i in range(len(nums)):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        j = i\n      ans = max(ans, i - j + 1)\n\n    return ans",
      "title": "674. Longest Continuous Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98acfef4-b781-4586-a1c6-cc3317216e85",
      "code": "class Solution:\n  def checkValidString(self, s: str) -> bool:\n    low = 0\n    high = 0\n\n    for c in s:\n      if c == '(':\n        low += 1\n        high += 1\n      elif c == ')':\n        if low > 0:\n          low -= 1\n        high -= 1\n      else:\n        if low > 0:\n          low -= 1\n        high += 1\n      if high < 0:\n        return False\n\n    return low == 0",
      "title": "678. Valid Parenthesis String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab1cdb87-c43c-4b5c-a0cd-47b710c0b1c4",
      "code": "class Solution:\n  def judgePoint24(self, nums: list[int]) -> bool:\n    def generate(a: float, b: float) -> list[float]:\n      return [a * b,\n              math.inf if b == 0 else a / b,\n              math.inf if a == 0 else b / a,\n              a + b, a - b, b - a]\n\n    def dfs(nums: list[float]) -> bool:\n      if len(nums) == 1:\n        return abs(nums[0] - 24.0) < 0.001\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        for num in generate(nums[i], nums[j]):\n          nextRound = [num]\n          for k in range(len(nums)):\n            if k == i or k == j:\n              continue\n            nextRound.append(nums[k])\n          if dfs(nextRound):\n            return True\n\n      return False\n\n    return dfs(nums)",
      "title": "679. 24 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "131694fc-c623-44b4-b294-32d6e5a1a8ac",
      "code": "class Solution:\n  def validPalindrome(self, s: str) -> bool:\n    def validPalindrome(l: int, r: int) -> bool:\n      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))\n\n    n = len(s)\n\n    for i in range(n // 2):\n      if s[i] != s[~i]:\n        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)\n\n    return True",
      "title": "680. Valid Palindrome II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d28bc56c-18f9-4a72-9d19-72d9997d5746",
      "code": "class Solution:\n  def nextClosestTime(self, time: str) -> str:\n    ans = list(time)\n    digits = sorted(ans)\n\n    def nextClosest(digit: str, limit: str) -> str:\n      next = bisect_right(digits, digit)\n      return digits[0] if next == 4 or digits[next] > limit else digits[next]\n\n    ans[4] = nextClosest(ans[4], '9')\n    if time[4] < ans[4]:\n      return ''.join(ans)\n\n    ans[3] = nextClosest(ans[3], '5')\n    if time[3] < ans[3]:\n      return ''.join(ans)\n\n    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')\n    if time[1] < ans[1]:\n      return ''.join(ans)\n\n    ans[0] = nextClosest(ans[0], '2')\n    return ''.join(ans)",
      "title": "681. Next Closest Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bf6976d-f427-44b9-b1a6-9f24538351b9",
      "code": "class Solution:\n  def calPoints(self, operations: list[str]) -> int:\n    scores = []\n\n    for operation in operations:\n      match operation:\n        case '+':\n          scores.append(scores[-1] + scores[-2])\n        case 'D':\n          scores.append(scores[-1] * 2)\n        case 'C':\n          scores.pop()\n        case default:\n          scores.append(int(operation))\n\n    return sum(scores)",
      "title": "682. Baseball Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5abb446f-f0f7-49b2-ad38-aa59991ffec4",
      "code": "class Solution:\n  def kEmptySlots(self, bulbs: list[int], k: int) -> int:\n    n = len(bulbs)\n    ans = math.inf\n    # day[i] := the day when bulbs[i] is turned on\n    day = [0] * n\n\n    for i, bulb in enumerate(bulbs):\n      day[bulb - 1] = i + 1\n\n    # Find a subarray of day[l..r], where its length is k + 2.\n    # For each l < i < r, day[i] > max(day[l], day[r]).\n    l = 0\n    r = l + k + 1\n    i = 1\n    while r < n:\n      if i == r:\n        ans = min(ans, max(day[l], day[r]))\n        l = i\n        r = i + k + 1\n      elif day[i] < max(day[l], day[r]):\n        l = i\n        r = i + k + 1\n      i += 1\n\n    return -1 if ans == math.inf else ans",
      "title": "683. K Empty Slots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a7025e0-3d04-4aae-bd3b-aaa092e8da67",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge",
      "title": "684. Redundant Connection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8039e639-0f57-45f9-af84-f1ff623abb49",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(\n      self, edges: list[list[int]],\n  ) -> list[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> list[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    # If there is no edge with two ids, don't skip any edge.\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        # Try to delete the edges[i].\n        if not findRedundantDirectedConnection(i):\n          return edges[i]",
      "title": "685. Redundant Connection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22302eb0-d8c7-4373-81ab-35bc92c96055",
      "code": "class Solution:\n  def repeatedStringMatch(self, a: str, b: str) -> int:\n    n = math.ceil(len(b) / len(a))\n    s = a * n\n    if b in s:\n      return n\n    if b in s + a:\n      return n + 1\n    return -1",
      "title": "686. Repeated String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf7209c5-34ab-47f7-88ee-1104b7dc254a",
      "code": "class Solution:\n  def longestUnivaluePath(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def longestUnivaluePathDownFrom(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = longestUnivaluePathDownFrom(root.left)\n      r = longestUnivaluePathDownFrom(root.right)\n      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0\n      arrowRight = r + 1 if root.right and root.right.val == root.val else 0\n      ans = max(ans, arrowLeft + arrowRight)\n      return max(arrowLeft, arrowRight)\n\n    longestUnivaluePathDownFrom(root)\n    return ans",
      "title": "687. Longest Univalue Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d92c626-e076-42bb-9ca2-4a407ff3a3b8",
      "code": "class Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    # dp[i][j] := the probability to stand on (i, j)\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k",
      "title": "688. Knight Probability in Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15af20ed-7d49-40fb-aa8c-e326380dcac7",
      "code": "class Solution:\n  def maxSumOfThreeSubarrays(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums) - k + 1\n    # sums[i] := sum(nums[i..i + k))\n    sums = [0] * n\n    # l[i] := the index in [0..i] that has the maximum sums[i]\n    l = [0] * n\n    # r[i] := the index in [i..n) that has the maximum sums[i]\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if (ans[0] == -1 or\n          sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <\n              sums[l[i - k]] + sums[i] + sums[r[i + k]]):\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans",
      "title": "689. Maximum Sum of 3 Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a71cf4f4-84e2-4067-8c30-a92f32a5c41d",
      "code": "class Solution:\n  def getImportance(self, employees: list['Employee'], id: int) -> int:\n    idToEmployee = {employee.id: employee for employee in employees}\n\n    def dfs(id: int) -> int:\n      values = idToEmployee[id].importance\n      for subId in idToEmployee[id].subordinates:\n        values += dfs(subId)\n      return values\n\n    return dfs(id)",
      "title": "690. Employee Importance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2599b1af-db83-418a-be2a-3b048aff5a79",
      "code": "class Solution:\n  def minStickers(self, stickers: list[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    # dp[i] := the minimum number of stickers to spell out i, where i is the\n    # bit mask of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      # Try to expand from `mask` by using each sticker.\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            # Try to apply it on a missing letter.\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "691. Stickers to Spell Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2077bd35-f731-43a5-a035-55dcf7db8a50",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  word: str\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.word > other.word\n    return self.freq < other.freq\n\n\nclass Solution:\n  def topKFrequent(self, words: list[str], k: int) -> list[str]:\n    ans = []\n    heap = []\n\n    for word, freq in collections.Counter(words).items():\n      heapq.heappush(heap, T(word, freq))\n      if len(heap) > k:\n        heapq.heappop(heap)\n\n    while heap:\n      ans.append(heapq.heappop(heap).word)\n\n    return ans[::-1]",
      "title": "692. Top K Frequent Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d886bb2-d1b2-44e1-85bc-8033002f06cb",
      "code": "class Solution:\n  def hasAlternatingBits(self, n: int) -> bool:\n    #            n = 0b010101\n    #       n >> 2 = 0b000101\n    # n ^ (n >> 2) = 0b010000 = a\n    #        a - 1 = 0b001111\n    #  a & (a - 1) = 0\n    a = n ^ (n >> 2)\n    return (a & (a - 1)) == 0",
      "title": "693. Binary Number with Alternating Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b015e62-9489-40e9-bd9d-e03a6f798cc4",
      "code": "class Solution:\n  def numDistinctIslands(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int, i0: int, j0: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i - i0, j - j0))\n      dfs(i + 1, j, i0, j0)\n      dfs(i - 1, j, i0, j0)\n      dfs(i, j + 1, i0, j0)\n      dfs(i, j - 1, i0, j0)\n\n    islands = set()  # all the different islands\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j, i, j)\n        if island:\n          islands.add(frozenset(island))\n\n    return len(islands)",
      "title": "694. Number of Distinct Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b05b7dc-8ce9-4b80-8a96-d6c7740299af",
      "code": "class Solution:\n  def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != 1:\n        return 0\n\n      grid[i][j] = 2\n\n      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n\n    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))",
      "title": "695. Max Area of Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56aa9721-2390-4ba9-9408-04af24601f7e",
      "code": "class Solution:\n  def countBinarySubstrings(self, s: str) -> int:\n    ans = 0\n    prevCount = 0\n    equals = 1\n\n    for i in range(len(s) - 1):\n      if s[i] == s[i + 1]:\n        equals += 1\n      else:\n        ans += min(prevCount, equals)\n        prevCount = equals\n        equals = 1\n\n    return ans + min(prevCount, equals)",
      "title": "696. Count Binary Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1742f10e-ca9b-40f5-b550-eb3946c647e8",
      "code": "class Solution:\n  def findShortestSubArray(self, nums: list[int]) -> int:\n    ans = 0\n    degree = 0\n    debut = {}\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      debut.setdefault(num, i)\n      count[num] += 1\n      if count[num] > degree:\n        degree = count[num]\n        ans = i - debut[num] + 1\n      elif count[num] == degree:\n        ans = min(ans, i - debut[num] + 1)\n\n    return ans",
      "title": "697. Degree of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc5016bd-ac70-4c45-98e8-4682b7655ba1",
      "code": "class Solution:\n  def canPartitionKSubsets(self, nums: list[int], k: int) -> bool:\n    summ = sum(nums)\n    if summ % k != 0:\n      return False\n\n    target = summ // k  # the target sum of each subset\n    if any(num > target for num in nums):\n      return False\n\n    def dfs(s: int, remainingGroups: int, currSum: int, used: int) -> bool:\n      if remainingGroups == 0:\n        return True\n      if currSum > target:\n        return False\n      if currSum == target:  # Find a valid group, so fresh start.\n        return dfs(0, remainingGroups - 1, 0, used)\n\n      for i in range(s, len(nums)):\n        if used >> i & 1:\n          continue\n        if dfs(i + 1, remainingGroups, currSum + nums[i], used | 1 << i):\n          return True\n\n      return False\n\n    nums.sort(reverse=True)\n    return dfs(0, k, 0, 0)",
      "title": "698. Partition to K Equal Sum Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abe04264-46ad-480d-b36c-875d3fe81bf5",
      "code": "class Solution:\n  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == val:\n      return root\n    if root.val > val:\n      return self.searchBST(root.left, val)\n    return self.searchBST(root.right, val)",
      "title": "700. Search in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9510730a-5547-4ee2-8191-57a6f97fd255",
      "code": "class Solution:\n  def insertIntoBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return TreeNode(val)\n    if root.val > val:\n      root.left = self.insertIntoBST(root.left, val)\n    else:\n      root.right = self.insertIntoBST(root.right, val)\n    return root",
      "title": "701. Insert into a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c30dc334-dd5c-4dfa-b049-f713abe5d80b",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class ArrayReader:\n#   def get(self, index: int) -> int:\n\nclass Solution:\n  def search(self, reader: 'ArrayReader', target: int) -> int:\n    l = bisect.bisect_left(range(10**4), target,\n                           key=lambda m: reader.get(m))\n    return l if reader.get(l) == target else -1",
      "title": "702. Search in a Sorted Array of Unknown Size",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "848c1c38-0bae-437b-8628-09d134cd697f",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    i = bisect.bisect_left(nums, target)\n    return -1 if i == len(nums) or nums[i] != target else i",
      "title": "704. Binary Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01e6f7a6-3e14-4e83-9b3f-02ac28d74128",
      "code": "class Solution:\n  def toLowerCase(self, str: str) -> str:\n    return ''.join(chr(ord(c) + 32) if 'A' <= c <= 'Z' else c for c in str)",
      "title": "709. To Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61206534-b251-4db0-bcec-7a70622c9bc6",
      "code": "class Solution:\n  def __init__(self, n: int, blacklist: list[int]):\n    self.validRange = n - len(blacklist)\n    self.dict = {}\n\n    maxAvailable = n - 1\n\n    for b in blacklist:\n      self.dict[b] = -1\n\n    for b in blacklist:\n      if b < self.validRange:\n        # Find the slot that haven't been used.\n        while maxAvailable in self.dict:\n          maxAvailable -= 1\n        self.dict[b] = maxAvailable\n        maxAvailable -= 1\n\n  def pick(self) -> int:\n    value = random.randint(0, self.validRange - 1)\n\n    if value in self.dict:\n      return self.dict[value]\n\n    return value",
      "title": "710. Random Pick with Blacklist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c35308ba-043c-4d45-9255-e0281dabab3d",
      "code": "class Solution:\n  def numDistinctIslands2(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i, j))\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    def normalize(island: list[tuple]) -> list[tuple]:\n      # points[i] := 8 different rotations/reflections of an island\n      points = [[] for _ in range(8)]\n\n      for i, j in island:\n        points[0].append((i, j))\n        points[1].append((i, -j))\n        points[2].append((-i, j))\n        points[3].append((-i, -j))\n        points[4].append((j, i))\n        points[5].append((j, -i))\n        points[6].append((-j, i))\n        points[7].append((-j, -i))\n\n      points = [sorted(p) for p in points]\n\n      # Normalize each p by substracting p[1..7] with p[0].\n      for p in points:\n        for i in range(1, len(island)):\n          p[i] = (p[i][0] - p[0][0],\n                  p[i][1] - p[0][1])\n        p[0] = (0, 0)\n\n      return sorted(points)[0]\n\n    islands = set()  # all the islands with different shapes\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j)\n        if island:\n          islands.add(frozenset(normalize(island)))\n\n    return len(islands)",
      "title": "711. Number of Distinct Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a59fc543-204c-4e01-85d2-9094048a3219",
      "code": "class Solution:\n  def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n    if k <= 1:\n      return 0\n\n    ans = 0\n    prod = 1\n\n    j = 0\n    for i, num in enumerate(nums):\n      prod *= num\n      while prod >= k:\n        prod /= nums[j]\n        j += 1\n      ans += i - j + 1\n\n    return ans",
      "title": "713. Subarray Product Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecd94514-cee9-424a-90e3-39d3f93035f9",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int], fee: int) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price - fee)\n\n    return sell",
      "title": "714. Best Time to Buy and Sell Stock with Transaction Fee",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "255aa6af-de5d-4617-ba17-2f756c19b0d5",
      "code": "class Solution:\n  def isOneBitCharacter(self, bits: list[int]) -> bool:\n    i = 0\n    while i < len(bits) - 1:\n      i += bits[i] + 1\n\n    return i == len(bits) - 1",
      "title": "717. 1-bit and 2-bit Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d4fcf11-9a43-4218-89d9-bb34073884b8",
      "code": "class Solution:\n  def findLength(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    ans = 0\n    # dp[i][j] := the maximum length of a subarray that appears in both\n    # nums1[i..m) and nums2[j..n)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        if nums1[i] == nums2[j]:\n          dp[i][j] = dp[i + 1][j + 1] + 1\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "718. Maximum Length of Repeated Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a991f5f-1118-4283-874d-27d2c9acb9bd",
      "code": "class Solution:\n  def smallestDistancePair(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    def numPairDistancesNoGreaterThan(m: int) -> int:\n      count = 0\n      j = 1\n      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,\n      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.\n      for i, num in enumerate(nums):\n        while j < len(nums) and nums[j] <= num + m:\n          j += 1\n        count += j - i - 1\n      return count\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), k,\n                              key=numPairDistancesNoGreaterThan)",
      "title": "719. Find K-th Smallest Pair Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3222622f-073a-43f3-af20-50b34fe91d77",
      "code": "class Solution:\n  def longestWord(self, words: list[str]) -> str:\n    root = {}\n\n    for word in words:\n      node = root\n      for c in word:\n        if c not in node:\n          node[c] = {}\n        node = node[c]\n      node['word'] = word\n\n    def dfs(node: dict) -> str:\n      ans = node['word'] if 'word' in node else ''\n\n      for child in node:\n        if 'word' in node[child] and len(node[child]['word']) > 0:\n          childWord = dfs(node[child])\n          if len(childWord) > len(ans) or (\n                  len(childWord) == len(ans) and childWord < ans):\n            ans = childWord\n\n      return ans\n\n    return dfs(root)",
      "title": "720. Longest Word in Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74a333e1-9ddd-441d-a774-b9d327608233",
      "code": "class Solution:\n  def removeComments(self, source: list[str]) -> list[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans",
      "title": "722. Remove Comments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b36a35cc-5718-4b7e-9f3b-58d1757ec39b",
      "code": "class Solution:\n  def pivotIndex(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      if prefix == summ - prefix - num:\n        return i\n      prefix += num\n\n    return -1",
      "title": "724. Find Pivot Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36a59a3e-8c82-48f1-aa81-a0ec22a57938",
      "code": "class Solution:\n  def splitListToParts(self, root: ListNode, k: int) -> list[ListNode]:\n    ans = [[] for _ in range(k)]\n    length = 0\n    curr = root\n    while curr:\n      length += 1\n      curr = curr.next\n    subLength = length // k\n    remainder = length % k\n\n    prev = None\n    head = root\n\n    for i in range(k):\n      ans[i] = head\n      for j in range(subLength + (1 if remainder > 0 else 0)):\n        prev = head\n        head = head.next\n      if prev:\n        prev.next = None\n      remainder -= 1\n\n    return ans",
      "title": "725. Split Linked List in Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8686d2c6-e006-4c62-a102-1d0adbcb00fe",
      "code": "class Solution:\n  def countOfAtoms(self, formula: str) -> str:\n    def parse() -> dict:\n      ans = collections.defaultdict(int)\n\n      nonlocal i\n      while i < n:\n        if formula[i] == '(':\n          i += 1\n          for elem, freq in parse().items():\n            ans[elem] += freq\n        elif formula[i] == ')':\n          i += 1\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          factor = int(formula[numStart:i])\n          for elem, freq in ans.items():\n            ans[elem] *= factor\n          return ans\n        elif formula[i].isupper():\n          elemStart = i\n          i += 1\n          while i < n and formula[i].islower():\n            i += 1\n          elem = formula[elemStart:i]\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          num = 1 if i == numStart else int(\n              formula[numStart:i])\n          ans[elem] += num\n\n      return ans\n\n    n = len(formula)\n\n    ans = \"\"\n    i = 0\n    count = parse()\n\n    for elem in sorted(count.keys()):\n      ans += elem\n      if count[elem] > 1:\n        ans += str(count[elem])\n\n    return ans",
      "title": "726. Number of Atoms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98c9d4a7-385a-4c33-8ae1-9c14a9a2312c",
      "code": "class Solution:\n  def selfDividingNumbers(self, left: int, right: int) -> list[int]:\n    return [num for num in range(left, right + 1) if all(n != 0 and num % n == 0 for n in map(int, str(num)))]",
      "title": "728. Self Dividing Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7817f64b-162f-48db-bd7c-992a516cc4f6",
      "code": "class Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    # dp[i][j] := the number of different non-empty palindromic subsequences in\n    # s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]",
      "title": "730. Count Different Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dff03f68-88da-487e-b9ef-b48eb5c5d1e8",
      "code": "class Solution:\n  def floodFill(self, image: list[list[int]],\n                sr: int, sc: int, newColor: int) -> list[list[int]]:\n    startColor = image[sr][sc]\n    seen = set()\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):\n        return\n      if image[i][j] != startColor or (i, j) in seen:\n        return\n\n      image[i][j] = newColor\n      seen.add((i, j))\n\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    dfs(sr, sc)\n    return image",
      "title": "733. Flood Fill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4b30397-6c32-4443-890c-ea18d0d0ef90",
      "code": "class Solution:\n  def areSentencesSimilar(\n      self,\n      sentence1: list[str],\n      sentence2: list[str],\n      similarPairs: list[list[str]],\n  ) -> bool:\n    if len(sentence1) != len(sentence2):\n      return False\n\n    # map[key] := all the similar words of key\n    map = collections.defaultdict(set)\n\n    for a, b in similarPairs:\n      map[a].add(b)\n      map[b].add(a)\n\n    for word1, word2 in zip(sentence1, sentence2):\n      if word1 == word2:\n        continue\n      if word1 not in map:\n        return False\n      if word2 not in map[word1]:\n        return False\n\n    return True",
      "title": "734. Sentence Similarity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e10130a3-7504-4f87-9fd1-1cea6ad0a800",
      "code": "class Solution:\n  def asteroidCollision(self, asteroids: list[int]) -> list[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:  # a < 0\n        # Destroy the previous positive one(s).\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()  # Both asteroids explode.\n        else:  # stack[-1] > the current asteroid.\n          pass  # Destroy the current asteroid, so do nothing.\n\n    return stack",
      "title": "735. Asteroid Collision",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e545a3fb-543c-4af3-b071-705d1a408547",
      "code": "class Solution:\n  def evaluate(self, expression: str) -> int:\n    def evaluate(e: str, prevScope: dict) -> int:\n      if e[0].isdigit() or e[0] == '-':\n        return int(e)\n      if e in prevScope:\n        return prevScope[e]\n\n      scope = prevScope.copy()\n      nextExpression = e[e.index(' ') + 1:-1]\n      tokens = parse(nextExpression)\n\n      if e[1] == 'm':  # 'mult'\n        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\n      if e[1] == 'a':  # 'add'\n        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\n\n      # 'let'\n      for i in range(0, len(tokens) - 2, 2):\n        scope[tokens[i]] = evaluate(tokens[i + 1], scope)\n\n      return evaluate(tokens[-1], scope)\n\n    def parse(e: str):\n      tokens = []\n      s = ''\n      opened = 0\n\n      for c in e:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened == 0 and c == ' ':\n          tokens.append(s)\n          s = ''\n        else:\n          s += c\n\n      if len(s) > 0:\n        tokens.append(s)\n      return tokens\n\n    return evaluate(expression, {})",
      "title": "736. Parse Lisp Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d9b6655-dd2e-4a4d-ab80-4c1ae179f954",
      "code": "class Solution:\n  def areSentencesSimilarTwo(\n      self,\n      words1: list[str],\n      words2: list[str],\n      pairs: list[list[str]],\n  ) -> bool:\n    if len(words1) != len(words2):\n      return False\n\n    # graph[key] := all the similar words of key\n    graph = collections.defaultdict(set)\n\n    for a, b in pairs:\n      graph[a].add(b)\n      graph[b].add(a)\n\n    def dfs(word1: str, word2: str, seen: set) -> bool:\n      if word1 in graph[word2]:\n        return True\n\n      seen.add(word1)\n\n      for child in graph[word1]:\n        if child in seen:\n          continue\n        if dfs(child, word2, seen):\n          return True\n\n      return False\n\n    for word1, word2 in zip(words1, words2):\n      if word1 == word2:\n        continue\n      if word1 not in graph:\n        return False\n      if not dfs(word1, word2, set()):\n        return False\n\n    return True",
      "title": "737. Sentence Similarity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80988867-8f0b-44b5-b523-897dcdc146af",
      "code": "class Solution:\n  def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n    ans = [0] * len(temperatures)\n    stack = []  # a decreasing stack\n\n    for i, temperature in enumerate(temperatures):\n      while stack and temperature > temperatures[stack[-1]]:\n        index = stack.pop()\n        ans[index] = i - index\n      stack.append(i)\n\n    return ans",
      "title": "739. Daily Temperatures",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b1f7b3d-3fa1-424b-8027-0f18fc6ae7cd",
      "code": "class Solution:\n  def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: list[list[tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1",
      "title": "743. Network Delay Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e163c8df-b173-4d00-aa4e-2e14f6b0051e",
      "code": "class Solution:\n  def nextGreatestLetter(self, letters: list[str], target: str) -> str:\n    l = bisect.bisect_right(range(len(letters)), target,\n                            key=lambda m: letters[m])\n    return letters[l % len(letters)]",
      "title": "744. Find Smallest Letter Greater Than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "800e89f6-aa3c-4f37-b9e0-21f4a980a767",
      "code": "class Solution:\n  def minCostClimbingStairs(self, cost: list[int]) -> int:\n    cost.append(0)\n\n    for i in range(2, len(cost)):\n      cost[i] += min(cost[i - 1], cost[i - 2])\n\n    return cost[-1]",
      "title": "746. Min Cost Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c1d03f3-d1a8-41ba-99d8-ddb25ccd41e9",
      "code": "class Solution:\n  def dominantIndex(self, nums: list[int]) -> int:\n    mx = 0\n    secondMax = 0\n\n    for i, num in enumerate(nums):\n      if num > mx:\n        secondMax = mx\n        mx = num\n        ans = i\n      elif num > secondMax:\n        secondMax = num\n\n    return ans if mx >= 2 * secondMax else -1",
      "title": "747. Largest Number At Least Twice of Others",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa809e6d-b719-4330-9f00-86874aa7e6fc",
      "code": "class Solution:\n  def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n    def isMatch(word: str) -> bool:\n      wordCount = collections.Counter(word)\n      return False if any(\n          wordCount[i] < count[i] for i in string.ascii_letters) else True\n\n    ans = '*' * 16\n    count = collections.defaultdict(int)\n\n    for c in licensePlate:\n      if c.isalpha():\n        count[c.lower()] += 1\n\n    for word in words:\n      if len(word) < len(ans) and isMatch(word):\n        ans = word\n\n    return ans",
      "title": "748. Shortest Completing Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56d6eb16-04c3-4730-be1d-79c1510daa88",
      "code": "class Solution:\n  def ipToCIDR(self, ip: str, n: int) -> list[str]:\n    ans = []\n    num = self._getNum(ip.split('.'))\n\n    while n > 0:\n      lowbit = num & -num\n      count = self._maxLow(n) if lowbit == 0 else self._firstFit(lowbit, n)\n      ans.append(self._getCIDR(num, self._getPrefix(count)))\n      n -= count\n      num += count\n\n    return ans\n\n  def _getNum(self, x: list[str]) -> int:\n    num = 0\n    for i in range(4):\n      num = num * 256 + int(x[i])\n    return num\n\n  def _maxLow(self, n: int) -> int | None:\n    \"\"\"Returns the maximum i s.t. 2^i < n.\"\"\"\n    for i in range(32):\n      if 1 << i + 1 > n:\n        return 1 << i\n\n  def _firstFit(self, lowbit: int, n: int) -> int:\n    while lowbit > n:\n      lowbit >>= 1\n    return lowbit\n\n  def _getCIDR(self, num: int, prefix: int) -> str:\n    d = num & 255\n    num >>= 8\n    c = num & 255\n    num >>= 8\n    b = num & 255\n    num >>= 8\n    a = num & 255\n    return '.'.join([str(s) for s in [a, b, c, d]]) + '/' + str(prefix)\n\n  def _getPrefix(self, count: int) -> int | None:\n    \"\"\"\n    e.g. count = 8 = 2^3 . prefix = 32 - 3 = 29\n         count = 1 = 2^0 . prefix = 32 - 0 = 32\n    \"\"\"\n    for i in range(32):\n      if count == 1 << i:\n        return 32 - i",
      "title": "751. IP to CIDR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05fb033f-bcf2-4cd2-bc6d-b9bf7319e54f",
      "code": "class Solution:\n  def crackSafe(self, n: int, k: int) -> str:\n    passwordSize = k**n\n    path = '0' * n\n    seen = set()\n    seen.add(path)\n\n    def dfs(path: str) -> str:\n      if len(seen) == passwordSize:\n        return path\n\n      for c in map(str, range(k)):\n        node = path[-n + 1:] + c if n > 1 else c\n        if node not in seen:\n          seen.add(node)\n          res = dfs(path + c)\n          if res:\n            return res\n          seen.remove(node)\n\n    return dfs(path)",
      "title": "753. Cracking the Safe",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20cb9dab-5fed-4342-983e-07272d2efd0f",
      "code": "class Solution:\n  def reachNumber(self, target: int) -> int:\n    ans = 0\n    pos = 0\n    target = abs(target)\n\n    while pos < target:\n      ans += 1\n      pos += ans\n\n    while (pos - target) % 2 == 1:\n      ans += 1\n      pos += ans\n\n    return ans",
      "title": "754. Reach a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fa93ed5-aa38-454b-ac75-4e425ada1f98",
      "code": "class Solution:\n  def pourWater(self, heights: list[int], volume: int, k: int) -> list[int]:\n    i = k\n\n    while volume > 0:\n      volume -= 1\n      while i > 0 and heights[i] >= heights[i - 1]:\n        i -= 1\n      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:\n        i += 1\n      while i > k and heights[i] == heights[i - 1]:\n        i -= 1\n      heights[i] += 1\n\n    return heights",
      "title": "755. Pour Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b30b6308-bb06-48df-8c9a-f6459e97afa1",
      "code": "class Solution:\n  def pyramidTransition(self, bottom: str, allowed: list[str]) -> bool:\n    prefixToBlocks = collections.defaultdict(list)\n\n    for a in allowed:\n      prefixToBlocks[a[:2]].append(a[2])\n\n    def dfs(row: str, nextRow: str, i: int) -> bool:\n      if len(row) == 1:\n        return True\n      if len(nextRow) + 1 == len(row):\n        return dfs(nextRow, '', 0)\n\n      for c in prefixToBlocks[row[i:i + 2]]:\n        if dfs(row, nextRow + c, i + 1):\n          return True\n\n      return False\n\n    return dfs(bottom, '', 0)",
      "title": "756. Pyramid Transition Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dd03dac-9023-403b-9a83-961b9b949b5b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def boldWords(self, words: list[str], s: str) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node.children:\n          node.children[c] = TrieNode()\n        node = node.children[c]\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        node = node.children.setdefault(s[j], TrieNode())\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "758. Bold Words in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c168377-66a0-4753-ae50-0677f7a1b9fe",
      "code": "class Solution:\n  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':\n    ans = []\n    intervals = []\n\n    for s in schedule:\n      intervals.extend(s)\n\n    intervals.sort(key=lambda x: x.start)\n\n    prevEnd = intervals[0].end\n\n    for interval in intervals:\n      if interval.start > prevEnd:\n        ans.append(Interval(prevEnd, interval.start))\n      prevEnd = max(prevEnd, interval.end)\n\n    return ans",
      "title": "759. Employee Free Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f886fe77-39c6-4b76-9173-6a263113442b",
      "code": "class Solution:\n  def anagramMappings(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums2):\n      numToIndices[num].append(i)\n\n    return [numToIndices[num].pop() for num in nums1]",
      "title": "760. Find Anagram Mappings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35a48646-b714-4360-a5c4-676b40ac5dad",
      "code": "class Solution:\n  def makeLargestSpecial(self, s: str) -> str:\n    specials = []\n    count = 0\n\n    i = 0\n    for j, c in enumerate(s):\n      count += 1 if c == '1' else -1\n      if count == 0:\n        specials.append(\n            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')\n        i = j + 1\n\n    return ''.join(sorted(specials)[::-1])",
      "title": "761. Special Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b21e121e-a102-40f9-8ff7-19780db33da3",
      "code": "class Solution:\n  def partitionLabels(self, s: str) -> list[int]:\n    ans = []\n    letterToRightmostIndex = {c: i for i, c in enumerate(s)}\n\n    l = 0  # the leftmost index of the current running string\n    r = 0  # the rightmost index of the current running string\n\n    for i, c in enumerate(s):\n      r = max(r, letterToRightmostIndex[c])\n      if i == r:\n        ans.append(r - l + 1)\n        l = r + 1\n\n    return ans",
      "title": "763. Partition Labels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7d13d10-f3ca-4842-b43c-d60f85c33a35",
      "code": "class Solution:\n  def isToeplitzMatrix(self, matrix: list[list[int]]) -> bool:\n    for i in range(len(matrix) - 1):\n      for j in range(len(matrix[0]) - 1):\n        if matrix[i][j] != matrix[i + 1][j + 1]:\n          return False\n\n    return True",
      "title": "766. Toeplitz Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbdaa831-5d17-44be-b444-05c39f4c585a",
      "code": "class Solution:\n  def reorganizeString(self, s: str) -> str:\n    count = collections.Counter(s)\n    if max(count.values()) > (len(s) + 1) // 2:\n      return ''\n\n    ans = []\n    maxHeap = [(-freq, c) for c, freq in count.items()]\n    heapq.heapify(maxHeap)\n    prevFreq = 0\n    prevChar = '@'\n\n    while maxHeap:\n      # Get the letter with the maximum frequency.\n      freq, c = heapq.heappop(maxHeap)\n      ans.append(c)\n      # Add the previous letter back s.t. any two adjacent characters are not\n      # the same.\n      if prevFreq < 0:\n        heapq.heappush(maxHeap, (prevFreq, prevChar))\n      prevFreq = freq + 1\n      prevChar = c\n\n    return ''.join(ans)",
      "title": "767. Reorganize String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a046d051-2ba5-4237-91b1-dc7655ca3966",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    mx = -math.inf\n    mn = [arr[-1]] * n\n\n    for i in reversed(range(n - 1)):\n      mn[i] = min(mn[i + 1], arr[i])\n\n    for i in range(n - 1):\n      mx = max(mx, arr[i])\n      if mx <= mn[i + 1]:\n        ans += 1\n\n    return ans + 1",
      "title": "768. Max Chunks To Make Sorted II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "328fecd2-c813-4398-b05d-6b98c6aef7dd",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    ans = 0\n    mx = -math.inf\n\n    for i, a in enumerate(arr):\n      mx = max(mx, a)\n      if mx == i:\n        ans += 1\n\n    return ans",
      "title": "769. Max Chunks To Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e38f4ffe-915e-43db-81ba-95804dd159ce",
      "code": "class Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  # Def __str__(self):\n  #   res = []\n  #   for term, coef in self.terms.items():\n  #     res.append(term + ': ' + str(coef))\n  #   return '{' + ', '.join(res) + '}'\n\n  def toList(self) -> list[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      # the minimum degree is the last\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      # the maximum degree is the first\n      # Break ties by their lexicographic orders.\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0  # A's index\n    j = 0  # B's index\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(\n      self,\n      expression: str,\n      evalvars: list[str],\n      evalints: list[int],\n  ) -> list[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: list[str]) -> list[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':  # isOperator(token)\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:  # isOperand(token)\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: list[str]) -> Poly:\n    polys: list[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:  # token == '*'\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]",
      "title": "770. Basic Calculator IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fed154cb-2b8b-4a0e-9ed0-196c75449936",
      "code": "class Solution:\n  def numJewelsInStones(self, jewels: str, stones: str) -> int:\n    jewelsSet = set(jewels)\n    return sum(stone in jewelsSet for stone in stones)",
      "title": "771. Jewels and Stones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "287047e1-80f3-4a57-9e41-363def271a4b",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    nums = []\n    ops = []\n\n    def calc():\n      b = nums.pop()\n      a = nums.pop()\n      op = ops.pop()\n      if op == '+':\n        nums.append(a + b)\n      elif op == '-':\n        nums.append(a - b)\n      elif op == '*':\n        nums.append(a * b)\n      else:  # op == '/'\n        nums.append(int(a / b))\n\n    def precedes(prev: str, curr: str) -> bool:\n      \"\"\"\n      Returns True if the previous character is a operator and the priority of\n      the previous operator >= the priority of the current character (operator).\n      \"\"\"\n      if prev == '(':\n        return False\n      return prev in '*/' or curr in '+-'\n\n    i = 0\n    hasPrevNum = False\n\n    while i < len(s):\n      c = s[i]\n      if c.isdigit():\n        num = int(c)\n        while i + 1 < len(s) and s[i + 1].isdigit():\n          num = num * 10 + int(s[i + 1])\n          i += 1\n        nums.append(num)\n        hasPrevNum = True\n      elif c == '(':\n        ops.append('(')\n        hasPrevNum = False\n      elif c == ')':\n        while ops[-1] != '(':\n          calc()\n        ops.pop()  # Pop '('\n      elif c in '+-*/':\n        if not hasPrevNum:  # Handle input like \"-1-(-1)\"\n          num.append(0)\n        while ops and precedes(ops[-1], c):\n          calc()\n        ops.append(c)\n      i += 1\n\n    while ops:\n      calc()\n\n    return nums.pop()",
      "title": "772. Basic Calculator III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f735fb2-3f44-42a0-92fb-634126c993b2",
      "code": "class Solution:\n  def minmaxGasDist(self, stations: list[int], k: int) -> float:\n    ERR = 1e-6\n    l = 0\n    r = stations[-1] - stations[0]\n\n    def possible(k: int, m: float) -> bool:\n      \"\"\"\n      Returns True if can use <= k gas stations to ensure that each adjacent\n      distance between gas stations <= m.\n      \"\"\"\n      for a, b in zip(stations, stations[1:]):\n        diff = b - a\n        if diff > m:\n          k -= math.ceil(diff / m) - 1\n          if k < 0:\n            return False\n      return True\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if possible(k, m):\n        r = m\n      else:\n        l = m\n\n    return l",
      "title": "774. Minimize Max Distance to Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09a8fb3d-d8bd-4ca3-aaa2-49c25ced4346",
      "code": "class Solution:\n  def isIdealPermutation(self, nums: list[int]) -> bool:\n    mx = -1  # the number that is most likely > nums[i + 2]\n\n    for i in range(len(nums) - 2):\n      mx = max(mx, nums[i])\n      if mx > nums[i + 2]:\n        return False\n\n    return True",
      "title": "775. Global and Local Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6377a214-7533-4b1e-878c-b48b71ce66a6",
      "code": "class Solution:\n  def splitBST(self, root: TreeNode | None, target: int) -> list[TreeNode | None]:\n    if not root:\n      return None, None\n    if root.val > target:\n      left, right = self.splitBST(root.left, target)\n      root.left = right\n      return left, root\n    else:  # root.val <= target\n      left, right = self.splitBST(root.right, target)\n      root.right = left\n      return root, right",
      "title": "776. Split BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a99b4c63-12f8-486a-97eb-a7fc729e1085",
      "code": "class Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0  # start's index\n    j = 0  # end's index\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      # L can only move to left.\n      if start[i] == 'L' and i < j:\n        return False\n      # R can only move to right.\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "777. Swap Adjacent in LR String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c83ecb7-c61b-483d-b094-d0c048df3063",
      "code": "class Solution:\n  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n    while sx < tx and sy < ty:\n      tx, ty = tx % ty, ty % tx\n\n    return (sx == tx and sy <= ty and (ty - sy) % tx == 0 or\n            sy == ty and sx <= tx and (tx - sx) % ty == 0)",
      "title": "780. Reaching Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "498ca686-11f9-4e2a-bace-96dfb1ac6ab9",
      "code": "class Solution:\n  def numRabbits(self, answers: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for answer in answers:\n      if count[answer] % (answer + 1) == 0:\n        ans += answer + 1\n      count[answer] += 1\n\n    return ans",
      "title": "781. Rabbits in Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "481d64dd-5f12-4423-82f4-75c7cce5a318",
      "code": "class Solution:\n  def movesToChessboard(self, board: list[list[int]]) -> int:\n    n = len(board)\n\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]\n           for i in range(n) for j in range(n)):\n      return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n % 2 == 1:\n      if rowSwaps % 2 == 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps % 2 == 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2",
      "title": "782. Transform to Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b9c66a9-697f-4e8e-998a-8a87d8fd207b",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def isBipartite(self, graph: list[list[int]]) -> bool:\n    colors = [Color.WHITE] * len(graph)\n\n    for i in range(len(graph)):\n      # This node has been colored, so do nothing.\n      if colors[i] != Color.WHITE:\n        continue\n      # Always paint red for a white node.\n      colors[i] = Color.RED\n      # BFS.\n      q = collections.deque([i])\n      while q:\n        for _ in range(len(q)):\n          u = q.popleft()\n          for v in graph[u]:\n            if colors[v] == colors[u]:\n              return False\n            if colors[v] == Color.WHITE:\n              colors[v] = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n              q.append(v)\n\n    return True",
      "title": "785. Is Graph Bipartite?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33e3e138-bb98-48f4-b709-1704e5168172",
      "code": "class Solution:\n  def kthSmallestPrimeFraction(self, arr: list[int], k: int) -> list[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans",
      "title": "786. K-th Smallest Prime Fraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d8a3be8-d977-436a-a555-5376f0afa1f2",
      "code": "class Solution:\n  def findCheapestPrice(\n      self,\n      n: int,\n      flights: list[list[int]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf] * (k + 2) for _ in range(len(graph))]\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]  # (d, u, stops)\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1",
      "title": "787. Cheapest Flights Within K Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39294177-1688-417b-baa0-9519a7293395",
      "code": "class Solution:\n  def rotatedDigits(self, n: int) -> int:\n    def isGoodNumber(i: int) -> bool:\n      isRotated = False\n\n      for c in str(i):\n        if c == '0' or c == '1' or c == '8':\n          continue\n        if c == '2' or c == '5' or c == '6' or c == '9':\n          isRotated = True\n        else:\n          return False\n\n      return isRotated\n\n    return sum(isGoodNumber(i) for i in range(1, n + 1))",
      "title": "788. Rotated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497740cf-68d5-48e0-a3d1-9d9dcafa560d",
      "code": "class Solution:\n  def escapeGhosts(self, ghosts: list[list[int]], target: list[int]) -> bool:\n    ghostSteps = min(abs(x - target[0]) +\n                     abs(y - target[1]) for x, y in ghosts)\n\n    return abs(target[0]) + abs(target[1]) < ghostSteps",
      "title": "789. Escape The Ghosts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "156a29bb-6452-4395-ac9f-214b924953f4",
      "code": "class Solution:\n  def numTilings(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = [0, 1, 2, 5] + [0] * 997\n\n    for i in range(4, n + 1):\n      dp[i] = 2 * dp[i - 1] + dp[i - 3]\n\n    return dp[n] % MOD",
      "title": "790. Domino and Tromino Tiling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c852d354-aed0-433b-85ac-ba4877c7a981",
      "code": "class Solution:\n  def customSortString(self, order: str, s: str) -> str:\n    ans = \"\"\n    count = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in order:\n      while count[ord(c) - ord('a')] > 0:\n        ans += c\n        count[ord(c) - ord('a')] -= 1\n\n    for c in string.ascii_lowercase:\n      for _ in range(count[ord(c) - ord('a')]):\n        ans += c\n\n    return ans",
      "title": "791. Custom Sort String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "561cab53-86d6-4023-a41d-a50fb31bba6e",
      "code": "class Solution:\n  def numMatchingSubseq(self, s: str, words: list[str]) -> int:\n    ans = 0\n    # [(i, j)] := words[i] and the letter words[i][j] is waiting for\n    bucket = [[] for _ in range(26)]\n\n    # For each word, it's waiting for word[0].\n    for i, word in enumerate(words):\n      bucket[ord(word[0]) - ord('a')].append((i, 0))\n\n    for c in s:\n      # Let prevBucket = bucket[c] and clear bucket[c].\n      index = ord(c) - ord('a')\n      prevBucket = bucket[index]\n      bucket[index] = []\n      for i, j in prevBucket:\n        j += 1\n        if j == len(words[i]):  # All the letters in words[i] are matched.\n          ans += 1\n        else:\n          bucket[ord(words[i][j]) - ord('a')].append((i, j))\n\n    return ans",
      "title": "792. Number of Matching Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f22d77b0-7764-45ca-ac2f-76b3cdcbd752",
      "code": "class Solution:\n  def validTicTacToe(self, board: list[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return (any(row.count(c) == 3 for row in board) or\n              any(row.count(c) == 3 for row in list(zip(*board))) or\n              all(board[i][i] == c for i in range(3)) or\n              all(board[i][2 - i] == c for i in range(3)))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True",
      "title": "794. Valid Tic-Tac-Toe State",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd98d11e-5e6b-4dcf-a9e7-aafafc73eaa3",
      "code": "class Solution:\n  def numSubarrayBoundedMax(\n      self,\n      nums: list[int],\n      left: int,\n      right: int,\n  ) -> int:\n    ans = 0\n    l = -1\n    r = -1\n\n    for i, num in enumerate(nums):\n      if num > right:  # Handle the reset value.\n        l = i\n      if num >= left:  # Handle the reset and the needed value.\n        r = i\n      ans += r - l\n\n    return ans",
      "title": "795. Number of Subarrays with Bounded Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb2d2d32-ad9f-441f-b19f-e5d9ae72cfaa",
      "code": "class Solution:\n  def rotateString(self, s: str, goal: str) -> bool:\n    return len(s) == len(goal) and goal in s + s",
      "title": "796. Rotate String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d84a96-8aea-4f26-b8fb-7f95fda3dc50",
      "code": "class Solution:\n  def allPathsSourceTarget(self, graph: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(u: int, path: list[int]) -> None:\n      if u == len(graph) - 1:\n        ans.append(path)\n        return\n\n      for v in graph[u]:\n        dfs(v, path + [v])\n\n    dfs(0, [0])\n    return ans",
      "title": "797. All Paths From Source to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f24de2b-5b88-4204-b8c4-2f2548c78887",
      "code": "class Solution:\n  def similarRGB(self, color: str) -> str:\n    SHORTHANDS = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',\n                  'aa', 'bb', 'cc', 'dd', 'ee', 'ff']\n    ans = ['#']\n\n    for i in range(1, len(color), 2):\n      currValue = int(color[i:i + 2], 16)\n      closestShorthand = min(SHORTHANDS,\n                             key=lambda x: (currValue - int(x, 16))**2)\n      ans.append(closestShorthand)\n\n    return ''.join(ans)",
      "title": "800. Similar RGB Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8602eff-db4b-4787-b00c-5e9fd47a4a30",
      "code": "class Solution:\n  def minSwap(self, nums1: list[int], nums2: list[int]) -> int:\n    keepAt = [math.inf] * len(nums1)\n    swapAt = [math.inf] * len(nums1)\n    keepAt[0] = 0\n    swapAt[0] = 1\n\n    for i in range(1, len(nums1)):\n      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n        keepAt[i] = keepAt[i - 1]\n        swapAt[i] = swapAt[i - 1] + 1\n      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n        keepAt[i] = min(keepAt[i], swapAt[i - 1])\n        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)\n\n    return min(keepAt[-1], swapAt[-1])",
      "title": "801. Minimum Swaps To Make Sequences Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b0c9101-bf30-4983-9ca2-6e5dc90d44de",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return [i for i in range(len(graph)) if not hasCycle(i)]",
      "title": "802. Find Eventual Safe States",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d15247f-c094-4e96-9e6c-58b25fc40fde",
      "code": "class Solution:\n  def uniqueMorseRepresentations(self, words: list[str]) -> int:\n    morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\",\n             \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\",\n             \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n    transformations = set()\n\n    for word in words:\n      transformation = ''.join(\n          morse[ord(c) - ord('a')] for c in word)\n      transformations.add(transformation)\n\n    return len(transformations)",
      "title": "804. Unique Morse Code Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ca4d18-03fb-4cc3-a377-0947e23de9e5",
      "code": "class Solution:\n  def splitArraySameAverage(self, nums: list[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False",
      "title": "805. Split Array With Same Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b05fa28-d919-4a71-ad95-dcf55c12b4b8",
      "code": "class Solution:\n  def numberOfLines(self, widths: list[int], s: str) -> list[int]:\n    numLines = 1\n    runningWidth = 0\n\n    for c in s:\n      width = widths[ord(c) - ord('a')]\n      if runningWidth + width <= 100:\n        runningWidth += width\n      else:\n        numLines += 1\n        runningWidth = width\n\n    return [numLines, runningWidth]",
      "title": "806. Number of Lines To Write String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "469811fa-bf7f-48fd-9020-481caa5e59c4",
      "code": "class Solution:\n  def maxIncreaseKeepingSkyline(self, grid: list[list[int]]) -> int:\n    rowMax = list(map(max, grid))\n    colMax = list(map(max, zip(*grid)))\n    return sum(min(i, j) for i in rowMax for j in colMax) - sum(map(sum, grid))",
      "title": "807. Max Increase to Keep City Skyline",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45899cf3-f37d-4023-89ff-566088c30e28",
      "code": "class Solution:\n  def soupServings(self, n: int) -> float:\n    @functools.lru_cache(None)\n    def dfs(a: int, b: int) -> float:\n      if a <= 0 and b <= 0:\n        return 0.5\n      if a <= 0:\n        return 1.0\n      if b <= 0:\n        return 0.0\n      return 0.25 * (dfs(a - 4, b) +\n                     dfs(a - 3, b - 1) +\n                     dfs(a - 2, b - 2) +\n                     dfs(a - 1, b - 3))\n\n    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)",
      "title": "808. Soup Servings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a96047d6-baa9-4960-bdfa-639c4f8e124b",
      "code": "class Solution:\n  def expressiveWords(self, s: str, words: list[str]) -> int:\n    def isStretchy(word: str) -> bool:\n      n = len(s)\n      m = len(word)\n\n      j = 0\n      for i in range(n):\n        if j < m and s[i] == word[j]:\n          j += 1\n        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:\n          continue\n        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:\n          continue\n        else:\n          return False\n\n      return j == m\n\n    return sum(isStretchy(word) for word in words)",
      "title": "809. Expressive Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c55cbba5-ea07-4bed-b14e-944f8712640b",
      "code": "class Solution:\n  def xorGame(self, nums: list[int]) -> bool:\n    return functools.reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0",
      "title": "810. Chalkboard XOR Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1764822-735f-4327-a356-fb1da0062622",
      "code": "class Solution:\n  def subdomainVisits(self, cpdomains: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    for cpdomain in cpdomains:\n      num, domains = cpdomain.split()\n      num, domains = int(num), domains.split('.')\n      for i in reversed(range(len(domains))):\n        count['.'.join(domains[i:])] += num\n\n    return [str(freq) + ' ' + domain for domain, freq in count.items()]",
      "title": "811. Subdomain Visit Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31e570ba-7aa7-4fa4-bc71-46e96ab1e55c",
      "code": "class Solution:\n  def largestTriangleArea(self, points: list[list[int]]) -> float:\n    ans = 0\n\n    for Ax, Ay in points:\n      for Bx, By in points:\n        for Cx, Cy in points:\n          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -\n                                   (Cx - Ax) * (By - Ay)))\n\n    return ans",
      "title": "812. Largest Triangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b02db260-7006-453d-b4ef-29595d636ab0",
      "code": "class Solution:\n  def pruneTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.pruneTree(root.left)\n    root.right = self.pruneTree(root.right)\n    if not root.left and not root.right and not root.val:\n      return None\n    return root",
      "title": "814. Binary Tree Pruning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91943605-a7d2-4721-880e-735c750e2b3a",
      "code": "class Solution:\n  def numBusesToDestination(\n      self,\n      routes: list[list[int]],\n      source: int,\n      target: int,\n  ) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    q = collections.deque([source])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return step\n            q.append(nextRoute)\n      step += 1\n\n    return -1",
      "title": "815. Bus Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7457d93-1b66-400d-9713-0cd082ebdde5",
      "code": "class Solution:\n  def ambiguousCoordinates(self, s: str) -> list[str]:\n    def splits(s: str) -> list[str]:\n      if not s or len(s) > 1 and s[0] == s[-1] == '0':\n        return []\n      if s[-1] == '0':\n        return [s]\n      if s[0] == '0':\n        return [s[0] + '.' + s[1:]]\n      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]\n\n    ans = []\n    s = s[1:-1]\n\n    for i in range(1, len(s)):\n      for x in splits(s[:i]):\n        for y in splits(s[i:]):\n          ans.append('(%s, %s)' % (x, y))\n\n    return ans",
      "title": "816. Ambiguous Coordinates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2af38007-ff37-4557-b110-0a72b331f2c8",
      "code": "class Solution:\n  def numComponents(self, head: ListNode | None, nums: list[int]) -> int:\n    ans = 0\n    numsSet = set(nums)\n\n    while head:\n      if head.val in numsSet and (\n              head.next == None or head.next.val not in numsSet):\n        ans += 1\n      head = head.next\n\n    return ans",
      "title": "817. Linked List Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "518c2a74-94ea-412f-8631-fa8b8eea3c9c",
      "code": "class Solution:\n  def mostCommonWord(self, paragraph: str, banned: list[str]) -> str:\n    banned = set(banned)\n    words = re.findall(r'\\w+', paragraph.lower())\n    return collections.Counter(\n        word for word in words if word not in banned).most_common(1)[0][0]",
      "title": "819. Most Common Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d41ae64c-291a-49ec-8dc4-faa0247564d2",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.depth = 0\n\n\nclass Solution:\n  def minimumLengthEncoding(self, words: list[str]) -> int:\n    root = TrieNode()\n    leaves = []\n\n    def insert(word: str) -> TrieNode:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n      node.depth = len(word)\n      return node\n\n    for word in set(words):\n      leaves.append(insert(word))\n\n    return sum(leaf.depth + 1 for leaf in leaves\n               if not len(leaf.children))",
      "title": "820. Short Encoding of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41bc4261-f2c9-4c2a-bac8-b63893540fa7",
      "code": "class Solution:\n  def shortestToChar(self, s: str, c: str) -> list[int]:\n    n = len(s)\n    ans = [0] * n\n    prev = -n\n\n    for i in range(n):\n      if s[i] == c:\n        prev = i\n      ans[i] = i - prev\n\n    for i in range(prev - 1, -1, -1):\n      if s[i] == c:\n        prev = i\n      ans[i] = min(ans[i], prev - i)\n\n    return ans",
      "title": "821. Shortest Distance to a Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "963d8c26-208e-4806-9e53-4be4cec6a484",
      "code": "class Solution:\n  def flipgame(self, fronts: list[int], backs: list[int]) -> int:\n    same = {front\n            for front, back in zip(fronts, backs)\n            if front == back}\n    return min([num for num in fronts + backs\n                if num not in same] or [0])",
      "title": "822. Card Flipping Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ba80fd3-ae66-47f4-ad42-d3a56dbad270",
      "code": "class Solution:\n  def numFactoredBinaryTrees(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    # dp[i] := the number of binary trees with arr[i] as the root\n    dp = [1] * n\n    arr.sort()\n    numToIndex = {a: i for i, a in enumerate(arr)}\n\n    for i, root in enumerate(arr):  # arr[i] is the root\n      for j in range(i):\n        if root % arr[j] == 0:  # arr[j] is the left subtree\n          right = root // arr[j]\n          if right in numToIndex:\n            dp[i] += dp[j] * dp[numToIndex[right]]\n            dp[i] %= MOD\n\n    return sum(dp) % MOD",
      "title": "823. Binary Trees With Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e54bf39-efca-4452-894b-0cfd02d7dad4",
      "code": "class Solution:\n  def toGoatLatin(self, sentence: str) -> str:\n    ans = []\n    VOWELS = 'aeiouAEIOU'\n\n    i = 1\n    for word in sentence.split():\n      if i > 1:\n        ans.append(' ')\n      if word[0] in VOWELS:\n        ans.append(word)\n      else:\n        ans.append(word[1:] + word[0])\n      ans.append('ma' + 'a' * i)\n      i += 1\n\n    return ''.join(ans)",
      "title": "824. Goat Latin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91df4899-4071-477b-9803-7e8055a23b7a",
      "code": "class Solution:\n  def numFriendRequests(self, ages: list[int]) -> int:\n    ans = 0\n    count = [0] * 121\n\n    for age in ages:\n      count[age] += 1\n\n    for i in range(15, 121):\n      ans += count[i] * (count[i] - 1)\n\n    for i in range(15, 121):\n      for j in range(i // 2 + 8, i):\n        ans += count[i] * count[j]\n\n    return ans",
      "title": "825. Friends Of Appropriate Ages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b28ff935-a62d-413d-8ae8-3865181a0fd6",
      "code": "class Solution:\n  def maxProfitAssignment(\n      self,\n      difficulty: list[int],\n      profit: list[int],\n      worker: list[int],\n  ) -> int:\n    ans = 0\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort(reverse=1)\n\n    i = 0\n    maxProfit = 0\n\n    for w in sorted(worker):\n      while i < len(jobs) and w >= jobs[i][0]:\n        maxProfit = max(maxProfit, jobs[i][1])\n        i += 1\n      ans += maxProfit\n\n    return ans",
      "title": "826. Most Profit Assigning Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00664a3b-eb47-4657-ae7e-7bf70a37eaad",
      "code": "class Solution:\n  def uniqueLetterString(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time ('a' + i) appeared\n    lastSeen = collections.defaultdict(lambda: -1)\n    # prevSeen[c] := the previous index of the last time ('a' + i) appeared\n    prevLastSeen = collections.defaultdict(lambda: -1)\n\n    for i, c in enumerate(s):\n      if c in lastSeen:\n        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n      prevLastSeen[c] = lastSeen[c]\n      lastSeen[c] = i\n\n    for c in string.ascii_uppercase:\n      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n\n    return ans",
      "title": "828. Count Unique Characters of All Substrings of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d4cbe16-e364-4416-9383-1ecfd46afa7f",
      "code": "class Solution:\n  def consecutiveNumbersSum(self, n: int) -> int:\n    ans = 0\n    i = 1\n    triangleNum = 1\n    while triangleNum <= n:\n      if (n - triangleNum) % i == 0:\n        ans += 1\n      i += 1\n      triangleNum += i\n    return ans",
      "title": "829. Consecutive Numbers Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68590a13-b9f2-4948-b419-9a39963aeaf1",
      "code": "class Solution:\n  def largeGroupPositions(self, s: str) -> list[list[int]]:\n    n = len(s)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      while j < n and s[j] == s[i]:\n        j += 1\n      if j - i >= 3:\n        ans.append([i, j - 1])\n      i = j\n\n    return ans",
      "title": "830. Positions of Large Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fb7ee57-1ec3-4795-8e39-d2d25cbb53e2",
      "code": "class Solution:\n  def maskPII(self, s: str) -> str:\n    atIndex = s.find('@')\n    if atIndex != -1:\n      s = s.lower()\n      return s[0] + '*' * 5 + s[atIndex - 1:]\n\n    ans = ''.join(c for c in s if c.isdigit())\n\n    if len(ans) == 10:\n      return '***-***-' + ans[-4:]\n    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]",
      "title": "831. Masking Personal Information",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22a091b4-8e52-4093-96f2-730b0ff8ffcd",
      "code": "class Solution:\n  def flipAndInvertImage(self, A: list[list[int]]) -> list[list[int]]:\n    n = len(A)\n\n    for i in range(n):\n      for j in range((n + 2) // 2):\n        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1\n\n    return A",
      "title": "832. Flipping an Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7c4493e-26a5-4df2-b224-651b7258be5a",
      "code": "class Solution:\n  def findReplaceString(\n      self,\n      s: str,\n      indices: list[int],\n      sources: list[str],\n      targets: list[str]\n  ) -> str:\n    for index, source, target in sorted(zip(indices, sources, targets),\n                                        reverse=True):\n      if s[index:index + len(source)] == source:\n        s = s[:index] + target + s[index + len(source):]\n    return s",
      "title": "833. Find And Replace in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b2a3daa-9006-46da-bc2b-a5f9638a8e3b",
      "code": "class Solution:\n  def sumOfDistancesInTree(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    count = [1] * n\n    tree = [set() for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    def postorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        postorder(v, u)\n        count[u] += count[v]\n        ans[u] += ans[v] + count[v]\n\n    def preorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # count[v] us are 1 step closer from v than prev.\n        # (n - count[v]) us are 1 step farther from v than prev.\n        ans[v] = ans[u] - count[v] + (n - count[v])\n        preorder(v, u)\n\n    postorder(0, -1)\n    preorder(0, -1)\n    return ans",
      "title": "834. Sum of Distances in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0292b682-d8cb-4aaa-a8eb-97cf87580dd3",
      "code": "class Solution:\n  def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:\n    MAGIC = 100\n    ones1 = [(i, j)\n             for i, row in enumerate(img1)\n             for j, num in enumerate(row)\n             if num == 1]\n    ones2 = [(i, j)\n             for i, row in enumerate(img2)\n             for j, num in enumerate(row)\n             if num == 1]\n    offsetCount = collections.Counter()\n\n    for ax, ay in ones1:\n      for bx, by in ones2:\n        offsetCount[(ax - bx) * MAGIC + (ay - by)] += 1\n\n    return max(offsetCount.values()) if offsetCount else 0",
      "title": "835. Image Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39be4d89-061c-44b7-a964-d43e56d0104e",
      "code": "class Solution:\n  def isRectangleOverlap(self, rec1: list[int], rec2: list[int]) -> bool:\n    return rec1[0] < rec2[2] and rec2[0] < rec1[2] and rec1[1] < rec2[3] and rec2[1] < rec1[3]",
      "title": "836. Rectangle Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8522848-ad11-4fdf-b9b6-556d59c13ecb",
      "code": "class Solution:\n  def new21Game(self, n: int, k: int, maxPts: int) -> float:\n    # When the game ends, the point is in [k..k - 1 maxPts].\n    #   P = 1, if n >= k - 1 + maxPts\n    #   P = 0, if n < k (note that the constraints already have k <= n)\n    if k == 0 or n >= k - 1 + maxPts:\n      return 1.0\n\n    ans = 0.0\n    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points\n    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)\n\n    for i in range(1, n + 1):\n      # The probability to get i points is\n      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts\n      dp[i] = windowSum / maxPts\n      if i < k:\n        windowSum += dp[i]\n      else:  # The game ends.\n        ans += dp[i]\n      if i - maxPts >= 0:\n        windowSum -= dp[i - maxPts]\n\n    return ans",
      "title": "837. New 21 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1404818e-8c7e-4790-ac26-837b0ff34b24",
      "code": "class Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)",
      "title": "838. Push Dominoes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3616d8d7-fdd6-46b6-8ab6-db49b2ed847a",
      "code": "class Solution:\n  def numMagicSquaresInside(self, grid: list[list[int]]) -> int:\n    def isMagic(i: int, j: int) -> int:\n      s = \"\".join(str(grid[i + num // 3][j + num % 3])\n                  for num in [0, 1, 2, 5, 8, 7, 6, 3])\n      return s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2\n\n    ans = 0\n\n    for i in range(len(grid) - 2):\n      for j in range(len(grid[0]) - 2):\n        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:\n          ans += isMagic(i, j)\n\n    return ans",
      "title": "840. Magic Squares In Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a70df95e-d344-488f-afef-c825fc43f003",
      "code": "class Solution:\n  def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n    seen = [False] * len(rooms)\n\n    def dfs(node: int) -> None:\n      seen[node] = True\n      for child in rooms[node]:\n        if not seen[child]:\n          dfs(child)\n\n    dfs(0)\n    return all(seen)",
      "title": "841. Keys and Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "970176a2-df32-480c-bff5-ef94dbb49cdb",
      "code": "# \"\"\"\n# This is Master's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class Master:\n#   def guess(self, word: str) -> int:\n\nclass Solution:\n  def findSecretWord(self, words: list[str], master: 'Master') -> None:\n    for _ in range(10):\n      guessedWord = words[random.randint(0, len(words) - 1)]\n      matches = master.guess(guessedWord)\n      if matches == 6:\n        break\n      words = [\n          word for word in words\n          if sum(c1 == c2 for c1, c2 in zip(guessedWord, word)) == matches]",
      "title": "843. Guess the Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42ec11aa-6f52-4a2b-a902-a914c30f9bf4",
      "code": "class Solution:\n  def backspaceCompare(self, s: str, t: str) -> bool:\n    i = len(s) - 1  # s' index\n    j = len(t) - 1  # t's index\n\n    while True:\n      # Delete characters of s if needed.\n      backspace = 0\n      while i >= 0 and (s[i] == '#' or backspace > 0):\n        backspace += 1 if s[i] == '#' else -1\n        i -= 1\n      # Delete characters of t if needed.\n      backspace = 0\n      while j >= 0 and (t[j] == '#' or backspace > 0):\n        backspace += 1 if t[j] == '#' else -1\n        j -= 1\n      if i >= 0 and j >= 0 and s[i] == t[j]:\n        i -= 1\n        j -= 1\n      else:\n        break\n\n    return i == -1 and j == -1",
      "title": "844. Backspace String Compare",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b4539ec-a03c-4c63-920e-8b5b3af955cd",
      "code": "class Solution:\n  def longestMountain(self, arr: list[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans",
      "title": "845. Longest Mountain in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84b10510-f39e-425f-a7c0-0b8facd97f99",
      "code": "class Solution:\n  def isNStraightHand(self, hand: list[int], groupSize: int) -> bool:\n    count = collections.Counter(hand)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + groupSize):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "846. Hand of Straights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35c7faf3-edcc-481c-8296-47af96be04c4",
      "code": "class Solution:\n  def shortestPathLength(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    goal = (1 << n) - 1\n    q = collections.deque()  # (u, state)\n    seen = set()\n\n    for i in range(n):\n      q.append((i, 1 << i))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, state = q.popleft()\n        if state == goal:\n          return step\n        if (u, state) in seen:\n          continue\n        seen.add((u, state))\n        for v in graph[u]:\n          q.append((v, state | 1 << v))\n      step += 1\n\n    return -1",
      "title": "847. Shortest Path Visiting All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c66f8f1d-8f38-42a4-a84a-5f07e4f40b05",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[int]) -> str:\n    ans = []\n\n    for i in reversed(range(len(shifts) - 1)):\n      shifts[i] += shifts[i + 1]\n\n    for c, shift in zip(s, shifts):\n      ans.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))\n\n    return ''.join(ans)",
      "title": "848. Shifting Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae74a2c6-f5b8-44ee-95ea-a5fe70d669c9",
      "code": "class Solution:\n  def maxDistToClosest(self, seats: list[int]) -> int:\n    n = len(seats)\n    ans = 0\n    j = -1\n\n    for i in range(n):\n      if seats[i] == 1:\n        ans = i if j == -1 else max(ans, (i - j) // 2)\n        j = i\n\n    return max(ans, n - j - 1)",
      "title": "849. Maximize Distance to Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7788ed5-d3e9-4d2e-be92-d5ee0b9d389f",
      "code": "class Solution:\n  def rectangleArea(self, rectangles: list[list[int]]) -> int:\n    events = []\n\n    for x1, y1, x2, y2 in rectangles:\n      events.append((x1, y1, y2, 's'))\n      events.append((x2, y1, y2, 'e'))\n\n    events.sort(key=lambda x: x[0])\n\n    ans = 0\n    prevX = 0\n    yPairs = []\n\n    def getHeight(yPairs: list[tuple[int, int]]) -> int:\n      height = 0\n      prevY = 0\n\n      for y1, y2 in yPairs:\n        prevY = max(prevY, y1)\n        if y2 > prevY:\n          height += y2 - prevY\n          prevY = y2\n\n      return height\n\n    for currX, y1, y2, type in events:\n      if currX > prevX:\n        width = currX - prevX\n        ans += width * getHeight(yPairs)\n        prevX = currX\n      if type == 's':\n        yPairs.append((y1, y2))\n        yPairs.sort()\n      else:  # type == 'e'\n        yPairs.remove((y1, y2))\n\n    return ans % (10**9 + 7)",
      "title": "850. Rectangle Area II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01841968-e3f5-4416-9292-194c53193eea",
      "code": "class Solution:\n  def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\n    graph = [[] for _ in range(len(quiet))]\n\n    for v, u in richer:\n      graph[u].append(v)\n\n    @functools.lru_cache(None)\n    def dfs(u: int) -> int:\n      ans = u\n\n      for v in graph[u]:\n        res = dfs(v)\n        if quiet[res] < quiet[ans]:\n          ans = res\n\n      return ans\n\n    return map(dfs, range(len(graph)))",
      "title": "851. Loud and Rich",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4738e57-efdc-4ba4-a465-6712929744c8",
      "code": "class Solution:\n  def peakIndexInMountainArray(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] >= arr[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "852. Peak Index in a Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df3c7f03-f57f-4755-8b4a-1c4cd8c0fd24",
      "code": "class Solution:\n  def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:\n    ans = 0\n    times = [\n        float(target - p) / s for p, s in sorted(zip(position, speed),\n                                                 reverse=True)]\n    maxTime = 0  # the time of the slowest car to reach the target\n\n    for time in times:\n      # A car needs more time to reach the target, so it becomes the slowest.\n      if time > maxTime:\n        maxTime = time\n        ans += 1\n\n    return ans",
      "title": "853. Car Fleet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7326cd9d-8d7d-409a-809d-b4726b78d089",
      "code": "class Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    q = collections.deque([s1])\n    seen = {s1}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return step\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      step += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> list[str]:\n    children = []\n    s = list(curr)\n    i = 0  # the first index s.t. curr[i] != target[i]\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children",
      "title": "854. K-Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "673ad6d9-a998-4f99-9ca6-f00b9d17500c",
      "code": "class Solution:\n  def scoreOfParentheses(self, s: str) -> int:\n    ans = 0\n    layer = 0\n\n    for a, b in itertools.pairwise(s):\n      if a + b == '()':\n        ans += 1 << layer\n      layer += 1 if a == '(' else -1\n\n    return ans",
      "title": "856. Score of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b9b9f8d-f387-4de0-831e-1b3112c3e1bb",
      "code": "class Solution:\n  def mincostToHireWorkers(\n      self,\n      quality: list[int],\n      wage: list[int],\n      k: int,\n  ) -> float:\n    ans = math.inf\n    qualitySum = 0\n    # (wagePerQuality, quality) sorted by wagePerQuality\n    workers = sorted((w / q, q) for q, w in zip(quality, wage))\n    maxHeap = []\n\n    for wagePerQuality, q in workers:\n      heapq.heappush(maxHeap, -q)\n      qualitySum += q\n      if len(maxHeap) > k:\n        qualitySum += heapq.heappop(maxHeap)\n      if len(maxHeap) == k:\n        ans = min(ans, qualitySum * wagePerQuality)\n\n    return ans",
      "title": "857. Minimum Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c35967a2-b6a0-4699-b8bb-025397d8ab02",
      "code": "class Solution:\n  def mirrorReflection(self, p: int, q: int) -> int:\n    while p % 2 == 0 and q % 2 == 0:\n      p //= 2\n      q //= 2\n\n    if p % 2 == 0:\n      return 2\n    if q % 2 == 0:\n      return 0\n    return 1",
      "title": "858. Mirror Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd4d24da-c780-497a-8fa6-881d0a7c41b2",
      "code": "class Solution:\n  def buddyStrings(self, s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n      return False\n    if s == goal and len(set(s)) < len(s):\n      return True\n    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))\n                   if a != b]\n    return (len(diffIndices) == 2 and\n            s[diffIndices[0]] == goal[diffIndices[1]] and\n            s[diffIndices[1]] == goal[diffIndices[0]])",
      "title": "859. Buddy Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb48654b-3f10-4388-ae6a-735a581824a7",
      "code": "class Solution:\n  def lemonadeChange(self, bills: list[int]) -> bool:\n    fives = 0\n    tens = 0\n\n    for bill in bills:\n      if bill == 5:\n        fives += 1\n      elif bill == 10:\n        fives -= 1\n        tens += 1\n      else:  # bill == 20\n        if tens > 0:\n          tens -= 1\n          fives -= 1\n        else:\n          fives -= 3\n      if fives < 0:\n        return False\n\n    return True",
      "title": "860. Lemonade Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ec7da38-26b7-42ac-91b1-1ee698927b27",
      "code": "class Solution:\n  def matrixScore(self, grid: list[list[int]]) -> int:\n    # Flip the rows with a leading 0.\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    # Flip the columns with 1s < 0s.\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    # Add a binary number for each row.\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: list[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: list[list[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: list[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res",
      "title": "861. Score After Flipping Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66879a62-28cb-475b-85d6-9ba62eb73b06",
      "code": "class Solution:\n  def shortestSubarray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = n + 1\n    dq = collections.deque()\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(n + 1):\n      while dq and prefix[i] - prefix[dq[0]] >= k:\n        ans = min(ans, i - dq.popleft())\n      while dq and prefix[i] <= prefix[dq[-1]]:\n        dq.pop()\n      dq.append(i)\n\n    return ans if ans <= n else -1",
      "title": "862. Shortest Subarray with Sum at Least K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e608f944-6a18-4dd4-8d03-32d37011eaa0",
      "code": "class Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int) -> int:\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1",
      "title": "866. Prime Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "899582cb-5d39-43e3-bac2-bd1b3319b18c",
      "code": "class Solution:\n  def transpose(self, A: list[list[int]]) -> list[list[int]]:\n    ans = [[0] * len(A) for _ in range(len(A[0]))]\n\n    for i in range(len(A)):\n      for j in range(len(A[0])):\n        ans[j][i] = A[i][j]\n\n    return ans",
      "title": "867. Transpose Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "223cf5e7-44fa-4f42-970d-552a5d9f2b74",
      "code": "class Solution:\n  def binaryGap(self, n: int) -> int:\n    ans = 0\n    d = -32  # the distance between any two 1s\n\n    while n:\n      if n % 2 == 1:\n        ans = max(ans, d)\n        d = 0\n      n //= 2\n      d += 1\n\n    return ans",
      "title": "868. Binary Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b2f229d-ae04-4e21-8b44-1589e312e989",
      "code": "class Solution:\n  def reorderedPowerOf2(self, n: int) -> bool:\n    count = collections.Counter(str(n))\n    return any(Counter(str(1 << i)) == count for i in range(30))",
      "title": "869. Reordered Power of 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acfe2c1f-7b9f-41df-8883-9071eccc0d96",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def advantageCount(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    sl = SortedList(nums1)\n\n    for i, num in enumerate(nums2):\n      index = 0 if sl[-1] <= num else sl.bisect_right(num)\n      nums1[i] = sl[index]\n      del sl[index]\n\n    return nums1",
      "title": "870. Advantage Shuffle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63bc4d2a-8825-4ab5-8966-b199d4cb5aeb",
      "code": "class Solution:\n  def minRefuelStops(\n      self,\n      target: int,\n      startFuel: int,\n      stations: list[list[int]],\n  ) -> int:\n    ans = 0\n    i = 0  # station's index\n    curr = startFuel\n    maxHeap = []\n\n    while curr < target:\n      # Add all the reachable stops to maxHeap\n      while i < len(stations) and stations[i][0] <= curr:\n        heapq.heappush(maxHeap, -stations[i][1])\n        i += 1\n      if not maxHeap:  # Can't be refueled.\n        return -1\n      curr -= heapq.heappop(maxHeap)  # Pop out the largest gas.\n      ans += 1  # Then, refuel once.\n\n    return ans",
      "title": "871. Minimum Number of Refueling Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "589eaf71-316f-44f5-ba20-0dcb2f281619",
      "code": "class Solution:\n  def leafSimilar(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    def dfs(root: TreeNode | None) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        yield root.val\n        return\n\n      yield from dfs(root.left)\n      yield from dfs(root.right)\n\n    return list(dfs(root1)) == list(dfs(root2))",
      "title": "872. Leaf-Similar Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5d0e5ba-522d-4d22-af5b-002ee25336b5",
      "code": "class Solution:\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    numToIndex = {a: i for i, a in enumerate(arr)}\n    dp = [[2] * n for _ in range(n)]\n\n    for j in range(n):\n      for k in range(j + 1, n):\n        ai = arr[k] - arr[j]\n        if ai < arr[j] and ai in numToIndex:\n          i = numToIndex[ai]\n          dp[j][k] = dp[i][j] + 1\n          ans = max(ans, dp[j][k])\n\n    return ans",
      "title": "873. Length of Longest Fibonacci Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4b1dc1b-633b-4f61-8c98-cb8b3ad7f2c0",
      "code": "class Solution:\n  def robotSim(self, commands: list[int], obstacles: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = 0\n    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west\n    x = 0  # the start x\n    y = 0  # the start y\n    obstaclesSet = {(x, y) for x, y in obstacles}\n\n    for command in commands:\n      if command == -1:\n        d = (d + 1) % 4\n      elif command == -2:\n        d = (d + 3) % 4\n      else:\n        for _ in range(command):\n          if (x + DIRS[d][0], y + DIRS[d][1]) in obstaclesSet:\n            break\n          x += DIRS[d][0]\n          y += DIRS[d][1]\n      ans = max(ans, x * x + y * y)\n\n    return ans",
      "title": "874. Walking Robot Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "793d00a8-4fef-4792-a5e5-50eb3cc82388",
      "code": "class Solution:\n  def minEatingSpeed(self, piles: list[int], h: int) -> int:\n    def eatHours(m: int) -> bool:\n      \"\"\"Returns the hours to eat all the piles with speed m.\"\"\"\n      return sum((pile - 1) // m + 1 for pile in piles)\n    l = 1\n    r = max(piles)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: eatHours(m) <= h) + l",
      "title": "875. Koko Eating Bananas",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc119823-d616-4b1a-93b8-64337a843c89",
      "code": "class Solution:\n  def middleNode(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    return slow",
      "title": "876. Middle of the Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1fb8af5-b6c1-4063-89d3-ba661c1fedca",
      "code": "class Solution:\n  def stoneGame(self, piles: list[int]) -> bool:\n    n = len(piles)\n    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, pile in enumerate(piles):\n      dp[i][i] = pile\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = max(piles[i] - dp[i + 1][j],\n                       piles[j] - dp[i][j - 1])\n\n    return dp[0][n - 1] > 0",
      "title": "877. Stone Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30851b28-410b-424b-91b7-d0aa851967b4",
      "code": "class Solution:\n  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n    lcm = a * b // math.gcd(a, b)\n    l = min(a, b)\n    r = min(a, b) * n\n    ans = bisect.bisect_left(range(l, r), n,\n                             key=lambda m: m // a + m // b - m // lcm) + l\n    return ans % (10**9 + 7)",
      "title": "878. Nth Magical Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a661ce91-a960-4f6c-b5f5-5835d6d3bb4f",
      "code": "class Solution:\n  def decodeAtIndex(self, s: str, k: int) -> str:\n    size = 0\n\n    for c in s:\n      if c.isdigit():\n        size *= int(c)\n      else:\n        size += 1\n\n    for c in reversed(s):\n      k %= size\n      if k == 0 and c.isalpha():\n        return c\n      if c.isdigit():\n        size //= int(c)\n      else:\n        size -= 1",
      "title": "880. Decoded String at Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20cc5578-97ed-41d4-9027-498cf9367a89",
      "code": "class Solution:\n  def numRescueBoats(self, people: list[int], limit: int) -> int:\n    ans = 0\n    i = 0\n    j = len(people) - 1\n\n    people.sort()\n\n    while i <= j:\n      remain = limit - people[j]\n      j -= 1\n      if people[i] <= remain:\n        i += 1\n      ans += 1\n\n    return ans",
      "title": "881. Boats to Save People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07f0445a-a140-47fc-a219-d1c15e460a91",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      edges: list[list[int]],\n      maxMoves: int,\n      n: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      # the number of reachable nodes of (u, v) from `u`\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      # the number of reachable nodes of (u, v) from `v`\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      maxMoves: int,\n      dist: list[int],\n  ) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      # Already took `maxMoves` to reach `u`, so can't explore anymore.\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)",
      "title": "882. Reachable Nodes In Subdivided Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f1357bd-7173-45fc-a5f2-e1f336b9f18a",
      "code": "class Solution:\n  def projectionArea(self, grid: list[list[int]]) -> int:\n    return sum(\n        a > 0 for row in grid for a in row) + sum(\n        max(row) for row in grid) + sum(\n        max(col) for col in zip(*grid))",
      "title": "883. Projection Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0b428d6-641f-4086-8e49-95a9942209c3",
      "code": "class Solution:\n  def uncommonFromSentences(self, A: str, B: str) -> list[str]:\n    count = collections.Counter((A + ' ' + B).split())\n    return [word for word, freq in count.items() if freq == 1]",
      "title": "884. Uncommon Words from Two Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e7df059-6b44-48b0-a8c1-eed85ea792e0",
      "code": "class Solution:\n  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> list[list[int]]:\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n    ans = [[rStart, cStart]]\n    i = 0\n\n    while len(ans) < rows * cols:\n      for _ in range(i // 2 + 1):\n        rStart += dy[i % 4]\n        cStart += dx[i % 4]\n        if 0 <= rStart < rows and 0 <= cStart < cols:\n          ans.append([rStart, cStart])\n      i += 1\n\n    return ans",
      "title": "885. Spiral Matrix III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2345f0d6-ed04-438b-bb10-64d6eb269712",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def possibleBipartition(self, n: int, dislikes: list[list[int]]) -> bool:\n    graph = [[] for _ in range(n + 1)]\n    colors = [Color.WHITE] * (n + 1)\n\n    for u, v in dislikes:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Reduce to 785. Is Graph Bipartite?\n    def isValidColor(u: int, color: Color) -> bool:\n      # Always paint red for a white node.\n      if colors[u] != Color.WHITE:\n        return colors[u] == color\n\n      colors[u] = color  # Always paint the node with `color`.\n\n      # All the children should have valid colors.\n      childrenColor = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n      return all(isValidColor(v, childrenColor) for v in graph[u])\n\n    return all(colors[i] != Color.WHITE or isValidColor(i, Color.RED)\n               for i in range(1, n + 1))",
      "title": "886. Possible Bipartition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff1aa2dd-9443-48aa-96dd-9825ecbe9404",
      "code": "class Solution:\n  def superEggDrop(self, k: int, n: int) -> int:\n    moves = 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    while dp[moves][k] < n:\n      moves += 1\n      for eggs in range(1, k + 1):\n        dp[moves][eggs] = (dp[moves - 1][eggs - 1] +\n                           dp[moves - 1][eggs] + 1)\n\n    return moves",
      "title": "887. Super Egg Drop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81f01f94-4020-4af6-a99f-6f721b57175d",
      "code": "class Solution:\n  def fairCandySwap(\n      self,\n      aliceSizes: list[int],\n      bobSizes: list[int],\n  ) -> list[int]:\n    diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n    bobSizesSet = set(bobSizes)\n\n    for aliceSize in aliceSizes:\n      target = aliceSize - diff\n      if target in bobSizesSet:\n        return [aliceSize, target]",
      "title": "888. Fair Candy Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b114aede-395c-4246-b32d-6f96b2acd248",
      "code": "class Solution:\n  def constructFromPrePost(\n      self,\n      pre: list[int],\n      post: list[int],\n  ) -> TreeNode | None:\n    postToIndex = {num: i for i, num in enumerate(post)}\n\n    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n      if preStart == preEnd:\n        return TreeNode(pre[preStart])\n\n      rootVal = pre[preStart]\n      leftRootVal = pre[preStart + 1]\n      leftRootPostIndex = postToIndex[leftRootVal]\n      leftSize = leftRootPostIndex - postStart + 1\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        postStart, leftRootPostIndex)\n      root.right = build(preStart + leftSize + 1, preEnd,\n                         leftRootPostIndex + 1, postEnd - 1)\n      return root\n\n    return build(0, len(pre) - 1, 0, len(post) - 1)",
      "title": "889. Construct Binary Tree from Preorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac5ff77d-98ac-47f2-936f-adae07d1455a",
      "code": "class Solution:\n  def findAndReplacePattern(self, words: list[str], pattern: str) -> list[str]:\n    def isIsomorphic(w: str, p: str) -> bool:\n      return [*map(w.index, w)] == [*map(p.index, p)]\n    return [word for word in words if isIsomorphic(word, pattern)]",
      "title": "890. Find and Replace Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59ae95f6-4294-47dc-816b-cca9010a1afb",
      "code": "class Solution:\n  def sumSubseqWidths(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    exp = 1\n\n    nums.sort()\n\n    for i in range(n):\n      ans += (nums[i] - nums[n - 1 - i]) * exp\n      ans %= MOD\n      exp = exp * 2 % MOD\n\n    return ans",
      "title": "891. Sum of Subsequence Widths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d3ef132-8364-491a-a916-d52195525f49",
      "code": "class Solution:\n  def surfaceArea(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(len(grid)):\n      for j in range(len(grid)):\n        if grid[i][j]:\n          ans += grid[i][j] * 4 + 2\n        if i > 0:\n          ans -= min(grid[i][j], grid[i - 1][j]) * 2\n        if j > 0:\n          ans -= min(grid[i][j], grid[i][j - 1]) * 2\n\n    return ans",
      "title": "892. Surface Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db2dd680-6f50-44fc-aa45-f0f1db3dd1fe",
      "code": "class Solution:\n  def numSpecialEquivGroups(self, words: list[str]) -> int:\n    return len({''.join(sorted(word[::2])) + ''.join(sorted(word[1::2]))\n                for word in words})",
      "title": "893. Groups of Special-Equivalent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fec7463-8386-4aa2-ba79-658f9f04f951",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def allPossibleFBT(self, n: int) -> list[TreeNode | None]:\n    if n % 2 == 0:\n      return []\n    if n == 1:\n      return [TreeNode(0)]\n\n    ans = []\n\n    for leftCount in range(n):\n      rightCount = n - 1 - leftCount\n      for left in self.allPossibleFBT(leftCount):\n        for right in self.allPossibleFBT(rightCount):\n          ans.append(TreeNode(0))\n          ans[-1].left = left\n          ans[-1].right = right\n\n    return ans",
      "title": "894. All Possible Full Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93d2623a-8864-40d4-b47c-d72b60f510be",
      "code": "class Solution:\n  def isMonotonic(self, nums: list[int]) -> bool:\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(nums)):\n      increasing &= nums[i - 1] <= nums[i]\n      decreasing &= nums[i - 1] >= nums[i]\n\n    return increasing or decreasing",
      "title": "896. Monotonic Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9a91c72-9b96-4086-b438-d0531936dac4",
      "code": "class Solution:\n  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:\n    if not root:\n      return tail\n\n    res = self.increasingBST(root.left, root)\n    root.left = None\n    root.right = self.increasingBST(root.right, tail)\n    return res",
      "title": "897. Increasing Order Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7aa799f-1816-4220-95e6-cee1afd027b3",
      "code": "class Solution:\n  def orderlyQueue(self, s: str, k: int) -> str:\n    return (''.join(sorted(s)) if k > 1\n            else min(s[i:] + s[:i] for i in range(len(s))))",
      "title": "899. Orderly Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86f8c366-d650-4ede-8749-d4b06fea5ad1",
      "code": "class Solution:\n  def atMostNGivenDigitSet(self, digits: list[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n\n    return ans + 1",
      "title": "902. Numbers At Most N Given Digit Set",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cde68be-70ee-4f1b-9c0a-6e86c204d98f",
      "code": "class Solution:\n  def totalFruit(self, fruits: list[int]) -> int:\n    ans = 0\n    count = collections.defaultdict(int)\n\n    l = 0\n    for r, fruit in enumerate(fruits):\n      count[fruit] += 1\n      while len(count) > 2:\n        count[fruits[l]] -= 1\n        if count[fruits[l]] == 0:\n          del count[fruits[l]]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "904. Fruit Into Baskets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37b7f0bd-761c-4c37-9779-46743ac8e9c6",
      "code": "class Solution:\n  def sortArrayByParity(self, nums: list[int]) -> list[int]:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      if nums[l] % 2 == 1 and nums[r] % 2 == 0:\n        nums[l], nums[r] = nums[r], nums[l]\n      if nums[l] % 2 == 0:\n        l += 1\n      if nums[r] % 2 == 1:\n        r -= 1\n\n    return nums",
      "title": "905. Sort Array By Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45207c67-8624-4e2f-9a93-9f4dc11cf683",
      "code": "class Solution:\n  def superpalindromesInRange(self, left: str, right: str) -> int:\n    def nextPalindrome(num: int) -> int:\n      s = str(num)\n      n = len(s)\n\n      half = s[0:(n + 1) // 2]\n      reversedHalf = half[:n // 2][::-1]\n      candidate = int(half + reversedHalf)\n      if candidate >= num:\n        return candidate\n\n      half = str(int(half) + 1)\n      reversedHalf = half[:n // 2][::-1]\n      return int(half + reversedHalf)\n\n    def isPalindrome(num: int) -> bool:\n      s = str(num)\n      l = 0\n      r = len(s) - 1\n\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n\n      return True\n\n    ans = 0\n    l = int(left)\n    r = int(right)\n    i = math.isqrt(l)\n\n    while i * i <= r:\n      palindrome = nextPalindrome(i)\n      squared = palindrome**2\n      if squared <= r and isPalindrome(squared):\n        ans += 1\n      i = palindrome + 1\n\n    return ans",
      "title": "906. Super Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcc30cdd-a21d-4dbc-9fa2-ec39b2297188",
      "code": "class Solution:\n  def sumSubarrayMins(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    ans = 0\n    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]\n    prevMin = [-1] * n\n    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]\n    nextMin = [n] * n\n    stack = []\n\n    for i, a in enumerate(arr):\n      while stack and arr[stack[-1]] > a:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    for i, a in enumerate(arr):\n      ans += a * (i - prevMin[i]) * (nextMin[i] - i)\n      ans %= MOD\n\n    return ans",
      "title": "907. Sum of Subarray Minimums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ac10dfc-5c8e-4435-8987-2c0d09e76da0",
      "code": "class Solution:\n  def smallestRangeI(self, nums: list[int], k: int) -> int:\n    return max(0, max(nums) - min(nums) - 2 * k)",
      "title": "908. Smallest Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6e722ff-45a5-4324-99a5-b607bb095c1d",
      "code": "class Solution:\n  def snakesAndLadders(self, board: list[list[int]]) -> int:\n    n = len(board)\n    q = collections.deque([1])\n    seen = set()\n    arr = [0] * (1 + n * n)  # 2D -> 1D\n\n    for i in range(n):\n      for j in range(n):\n        arr[(n - 1 - i) * n + (n - j if (n - i) % 2 == 0 else j + 1)] = board[i][j]\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = arr[next] if arr[next] > 0 else next\n          if dest == n * n:\n            return step\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n      step += 1\n\n    return -1",
      "title": "909. Snakes and Ladders",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62bfe706-daeb-43af-a05f-3f063fef7a5f",
      "code": "class Solution:\n  def smallestRangeII(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = nums[-1] - nums[0]\n    left = nums[0] + k\n    right = nums[-1] - k\n\n    for a, b in itertools.pairwise(nums):\n      mn = min(left, b - k)\n      mx = max(right, a + k)\n      ans = min(ans, mx - mn)\n\n    return ans",
      "title": "910. Smallest Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50b2de9d-1e3d-40aa-937a-116eb97e7398",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0ab1d69-efe8-4d63-b38c-a53369208a40",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2097d261-a14d-4a7c-9e86-b5b5d5633a44",
      "code": "from enum import IntEnum\n\n\nclass State(IntEnum):\n  DRAW = 0\n  MOUSE_WIN = 1\n  CAT_WIN = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    # result of (cat, mouse, move)\n    # move := 0 (mouse) // 1 (cat)\n    states = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    outDegree = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    q = collections.deque()  # (cat, mouse, move, state)\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    # Start from the states s.t. the winner can be determined.\n    for cat in range(1, n):\n      for move in range(2):\n        # Mouse is in the hole.\n        states[cat][0][move] = int(State.MOUSE_WIN)\n        q.append((cat, 0, move, int(State.MOUSE_WIN)))\n        # Cat catches mouse.\n        states[cat][cat][move] = int(State.CAT_WIN)\n        q.append((cat, cat, move, int(State.CAT_WIN)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:  # invalid\n          continue\n        prevMouse = mouse if prevMove else prev\n        # The state has been determined.\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if (prevMove == 0 and state == int(State.MOUSE_WIN) or\n                prevMove == 1 and state == int(State.CAT_WIN)):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]",
      "title": "913. Cat and Mouse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0c23d76-56a0-4bbe-81f8-a72b47cb7268",
      "code": "class Solution:\n  def hasGroupsSizeX(self, deck: list[int]) -> bool:\n    count = collections.Counter(deck)\n    return functools.reduce(math.gcd, count.values()) >= 2",
      "title": "914. X of a Kind in a Deck of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e868dd42-d92f-4e99-abad-8a4ef5e1f608",
      "code": "class Solution:\n  def partitionDisjoint(self, nums: list[int]) -> int:\n    n = len(nums)\n    mn = [0] * (n - 1) + [nums[-1]]\n    mx = -math.inf\n\n    for i in range(n - 2, - 1, -1):\n      mn[i] = min(mn[i + 1], nums[i])\n\n    for i, num in enumerate(nums):\n      mx = max(mx, num)\n      if mx <= mn[i + 1]:\n        return i + 1",
      "title": "915. Partition Array into Disjoint Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a75c713-d49e-4f88-ba09-e33c3247cb1b",
      "code": "class Solution:\n  def wordSubsets(self, A: list[str], B: list[str]) -> list[str]:\n    count = collections.Counter()\n\n    for b in B:\n      count = count | collections.Counter(b)\n\n    return [a for a in A if collections.Counter(a) & count == count]",
      "title": "916. Word Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "848a089f-e401-4f62-8c0b-67d2132b50ba",
      "code": "class Solution:\n  def reverseOnlyLetters(self, s: str) -> str:\n    ans = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      while i < j and not s[i].isalpha():\n        i += 1\n      while i < j and not s[j].isalpha():\n        j -= 1\n      ans[i], ans[j] = ans[j], ans[i]\n      i += 1\n      j -= 1\n\n    return ''.join(ans)",
      "title": "917. Reverse Only Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b74f57a-e150-45ac-965d-67308425d6d1",
      "code": "class Solution:\n  def maxSubarraySumCircular(self, nums: list[int]) -> int:\n    totalSum = 0\n    currMaxSum = 0\n    currMinSum = 0\n    maxSum = -math.inf\n    minSum = math.inf\n\n    for num in nums:\n      totalSum += num\n      currMaxSum = max(currMaxSum + num, num)\n      currMinSum = min(currMinSum + num, num)\n      maxSum = max(maxSum, currMaxSum)\n      minSum = min(minSum, currMinSum)\n\n    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)",
      "title": "918. Maximum Sum Circular Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11cd1571-c80c-4f01-9d80-761a6823540e",
      "code": "class Solution:\n  def minAddToMakeValid(self, s: str) -> int:\n    l = 0\n    r = 0\n\n    for c in s:\n      if c == '(':\n        l += 1\n      else:\n        if l == 0:\n          r += 1\n        else:\n          l -= 1\n\n    return l + r",
      "title": "921. Minimum Add to Make Parentheses Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eea80b9-3324-4280-bd49-013ac471c05e",
      "code": "class Solution:\n  def sortArrayByParityII(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    i = 0\n    j = 1\n    while i < n:\n      while i < n and nums[i] % 2 == 0:\n        i += 2\n      while j < n and nums[j] % 2 == 1:\n        j += 2\n      if i < n:\n        nums[i], nums[j] = nums[j], nums[i]\n\n    return nums",
      "title": "922. Sort Array By Parity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "741ba3b0-2acb-4e74-b540-4a0f4d2632ec",
      "code": "class Solution:\n  def threeSumMulti(self, arr: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % MOD\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % MOD\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % MOD\n\n    return ans % MOD",
      "title": "923. 3Sum With Multiplicity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94f5fe90-f382-479d-b7b2-0c57ecb87f85",
      "code": "class Solution:\n  def isLongPressedName(self, name: str, typed: str) -> bool:\n    i = 0\n\n    for j, t in enumerate(typed):\n      if i < len(name) and name[i] == t:\n        i += 1\n      elif j == 0 or t != typed[j - 1]:\n        return False\n\n    return i == len(name)",
      "title": "925. Long Pressed Name",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49feb1bc-84e0-4f55-93dd-1d1ec2bb71be",
      "code": "class Solution:\n  def minFlipsMonoIncr(self, s: str) -> int:\n    # the number of characters to be flilpped to make the substring so far\n    # monotone increasing\n    dp = 0\n    count1 = 0\n\n    for c in s:\n      if c == '0':\n        # 1. Flip '0'.\n        # 2. Keep '0' and flip all the previous 1s.\n        dp = min(dp + 1, count1)\n      else:\n        count1 += 1\n\n    return dp",
      "title": "926. Flip String to Monotone Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a5da41f-8e81-44a1-91ea-d65993a363c9",
      "code": "class Solution:\n  def threeEqualParts(self, arr: list[int]) -> list[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]",
      "title": "927. Three Equal Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38565b19-bc85-459a-bf0a-c730de805357",
      "code": "class Solution:\n  def numUniqueEmails(self, emails: list[str]) -> int:\n    seen = set()\n\n    for email in emails:\n      local, domain = email.split('@')\n      local = local.split('+')[0].replace('.', '')\n      seen.add(local + '@' + domain)\n\n    return len(seen)",
      "title": "929. Unique Email Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf9aed17-8d18-4b72-8d11-99ec18c9b858",
      "code": "class Solution:\n  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:\n    def numSubarraysWithSumAtMost(goal: int) -> int:\n      res = 0\n      count = 0\n      l = 0\n      r = 0\n\n      while r < len(nums):\n        count += nums[r]\n        r += 1\n        while l < r and count > goal:\n          count -= nums[l]\n          l += 1\n        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]\n        res += r - l\n\n      return res\n\n    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)",
      "title": "930. Binary Subarrays With Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783c645e-026c-44c3-87c6-9fca436a9fcf",
      "code": "class Solution:\n  def minFallingPathSum(self, A: list[list[int]]) -> int:\n    n = len(A)\n\n    for i in range(1, n):\n      for j in range(n):\n        mn = math.inf\n        for k in range(max(0, j - 1), min(n, j + 2)):\n          mn = min(mn, A[i - 1][k])\n        A[i][j] += mn\n\n    return min(A[-1])",
      "title": "931. Minimum Falling Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08055337-e0e8-451c-b0d4-37b28bb13a2d",
      "code": "class Solution:\n  def beautifulArray(self, n: int) -> list[int]:\n    arr = [i for i in range(1, n + 1)]\n\n    def partition(l: int, r: int, mask: int) -> int:\n      nextSwapped = l\n      for i in range(l, r + 1):\n        if arr[i] & mask:\n          arr[i], arr[nextSwapped] = arr[nextSwapped], arr[i]\n          nextSwapped += 1\n      return nextSwapped - 1\n\n    def divide(l: int, r: int, mask: int) -> None:\n      if l >= r:\n        return\n      m = partition(l, r, mask)\n      divide(l, m, mask << 1)\n      divide(m + 1, r, mask << 1)\n\n    divide(0, n - 1, 1)\n    return arr",
      "title": "932. Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db4bd4f1-47ef-4b57-ae48-957e72677e89",
      "code": "class Solution:\n  def knightDialer(self, n: int) -> int:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    MOD = 1_000_000_007\n\n    # dp[i][j] := the number of ways stand on (i, j)\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return sum(map(sum, dp)) % MOD",
      "title": "935. Knight Dialer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eb6a0b0-731f-4aab-a2c4-10797a8a4a1f",
      "code": "class Solution:\n  def movesToStamp(self, stamp: str, target: str) -> list[int]:\n    def stampify(s: int) -> int:\n      \"\"\"\n      Stamps target[i..i + |stamp|) and returns the number of newly stamped\n      characters.\n      e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\".\n      \"\"\"\n      stampified = len(stamp)\n\n      for i, st in enumerate(stamp):\n        if target[s + i] == '*':  # It's already been stamped.\n          stampified -= 1\n        elif target[s + i] != st:  # We can't stamp on the index i.\n          return 0\n\n      for i in range(s, s + len(stamp)):\n        target[i] = '*'\n\n      return stampified\n\n    ans = []\n    target = list(target)\n    # stamped[i] := True if we already stamped target by stamping on index i\n    stamped = [False] * len(target)\n    stampedCount = 0  # Our goal is to make stampedCount = |target|.\n\n    while stampedCount < len(target):\n      isStamped = False\n      # Try to stamp target[i..i + |stamp|) for each index.\n      for i in range(len(target) - len(stamp) + 1):\n        if stamped[i]:\n          continue\n        stampified = stampify(i)\n        if stampified == 0:\n          continue\n        stampedCount += stampified\n        isStamped = True\n        stamped[i] = True\n        ans.append(i)\n      # After trying to stamp on each index, we can't find a valid stamp.\n      if not isStamped:\n        return []\n\n    return ans[::-1]",
      "title": "936. Stamping The Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "601da3e4-ba9c-47df-a42b-84c077f8f16f",
      "code": "class Solution:\n  def reorderLogFiles(self, logs: list[str]) -> list[str]:\n    digitLogs = []\n    letterLogs = []\n\n    for log in logs:\n      i = log.index(' ')\n      if log[i + 1].isdigit():\n        digitLogs.append(log)\n      else:\n        letterLogs.append((log[:i], log[i + 1:]))\n\n    letterLogs.sort(key=lambda x: (x[1], x[0]))\n    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs",
      "title": "937. Reorder Data in Log Files",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa649a4d-835d-4287-86e3-b5777b421ae7",
      "code": "class Solution:\n  def minAreaRect(self, points: list[list[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0",
      "title": "939. Minimum Area Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "790e32a4-b7f2-4222-8bd0-866619982822",
      "code": "class Solution:\n  def distinctSubseqII(self, s: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('a' + i)\n    endsIn = [0] * 26\n\n    for c in s:\n      endsIn[ord(c) - ord('a')] = (sum(endsIn) + 1) % MOD\n\n    return sum(endsIn) % MOD",
      "title": "940. Distinct Subsequences II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9d2230a-51c5-46db-a6e5-c0c4d5c07b64",
      "code": "class Solution:\n  def validMountainArray(self, arr: list[int]) -> bool:\n    if len(arr) < 3:\n      return False\n\n    l = 0\n    r = len(arr) - 1\n\n    while l + 1 < len(arr) and arr[l] < arr[l + 1]:\n      l += 1\n    while r > 0 and arr[r] < arr[r - 1]:\n      r -= 1\n\n    return l > 0 and r < len(arr) - 1 and l == r",
      "title": "941. Valid Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e416b776-23b0-4db4-84a7-ac7705814545",
      "code": "class Solution:\n  def diStringMatch(self, s: str) -> list[int]:\n    ans = []\n    mn = 0\n    mx = len(s)\n\n    for c in s:\n      if c == 'I':\n        ans.append(mn)\n        mn += 1\n      else:\n        ans.append(mx)\n        mx -= 1\n\n    return ans + [mn]",
      "title": "942. DI String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb19ba1d-d4c3-4073-9075-d23093dad902",
      "code": "class Solution:\n  def minDeletionSize(self, strs: list[str]) -> int:\n    ans = 0\n\n    for j in range(len(strs[0])):\n      for i in range(len(strs) - 1):\n        if strs[i][j] > strs[i + 1][j]:\n          ans += 1\n          break\n\n    return ans",
      "title": "944. Delete Columns to Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06319833-e590-44a1-8e32-81e3eec9ba71",
      "code": "class Solution:\n  def minIncrementForUnique(self, nums: list[int]) -> int:\n    ans = 0\n    minAvailable = 0\n\n    for num in sorted(nums):\n      ans += max(minAvailable - num, 0)\n      minAvailable = max(minAvailable, num) + 1\n\n    return ans",
      "title": "945. Minimum Increment to Make Array Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7fbe669-374e-4a87-ac8c-6e715f7e319b",
      "code": "class Solution:\n  def validateStackSequences(\n      self,\n      pushed: list[int],\n      popped: list[int],\n  ) -> bool:\n    stack = []\n    i = 0  # popped's index\n\n    for x in pushed:\n      stack.append(x)\n      while stack and stack[-1] == popped[i]:\n        stack.pop()\n        i += 1\n\n    return not stack",
      "title": "946. Validate Stack Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7331c950-03a7-4b72-b7b0-aab8f3ccf85a",
      "code": "class Solution:\n  def bagOfTokensScore(self, tokens: list[int], power: int) -> int:\n    ans = 0\n    score = 0\n    q = collections.deque(sorted(tokens))\n\n    while q and (power >= q[0] or score):\n      while q and power >= q[0]:\n        # Play the smallest face up.\n        power -= q.popleft()\n        score += 1\n      ans = max(ans, score)\n      if q and score:\n        # Play the largest face down.\n        power += q.pop()\n        score -= 1\n\n    return ans",
      "title": "948. Bag of Tokens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "697ae9b6-a3c3-4ef8-b865-69ce15bd7784",
      "code": "class Solution:\n  def largestTimeFromDigits(self, arr: list[int]) -> str:\n    for time in itertools.permutations(sorted(arr, reverse=True)):\n      if time[:2] < (2, 4) and time[2] < 6:\n        return '%d%d:%d%d' % time\n    return ''",
      "title": "949. Largest Time for Given Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "973357a3-3649-473b-8e34-8b25233bf7e7",
      "code": "class Solution:\n  def deckRevealedIncreasing(self, deck: list[int]) -> list[int]:\n    dq = collections.deque()\n\n    for card in reversed(sorted(deck)):\n      dq.rotate()\n      dq.appendleft(card)\n\n    return list(dq)",
      "title": "950. Reveal Cards In Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8cb7086-1e9a-41f7-9b20-e1f632b3e6d4",
      "code": "class Solution:\n  def flipEquiv(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    if not root1:\n      return not root2\n    if not root2:\n      return not root1\n    if root1.val != root2.val:\n      return False\n    return (self.flipEquiv(root1.left, root2.left) and\n            self.flipEquiv(root1.right, root2.right) or\n            self.flipEquiv(root1.left, root2.right) and\n            self.flipEquiv(root1.right, root2.left))",
      "title": "951. Flip Equivalent Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13e87c5c-5e92-4bf9-a7bc-a3c75fd4bf5e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: list[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, math.isqrt(num) + 1):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans",
      "title": "952. Largest Component Size by Common Factor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d95a46d4-e22e-4cb9-a172-c11b7cbb3037",
      "code": "class Solution:\n  def isAlienSorted(self, words: list[str], order: str) -> bool:\n    dict = {c: i for i, c in enumerate(order)}\n    words = [[dict[c] for c in word] for word in words]\n    return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))",
      "title": "953. Verifying an Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29c5841b-2cdc-4780-a840-9dcc5641de5c",
      "code": "class Solution:\n  def canReorderDoubled(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n\n    for key in sorted(count, key=abs):\n      if count[key] > count[2 * key]:\n        return False\n      count[2 * key] -= count[key]\n\n    return True",
      "title": "954. Array of Doubled Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50f59a96-32d0-4ae8-860b-e23d69aec815",
      "code": "class Solution:\n  def prisonAfterNDays(self, cells: list[int], n: int) -> list[int]:\n    nextDayCells = [0] * len(cells)\n    day = 0\n\n    while n > 0:\n      n -= 1\n      for i in range(1, len(cells) - 1):\n        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0\n      if day == 0:\n        firstDayCells = nextDayCells.copy()\n      elif nextDayCells == firstDayCells:\n        n %= day\n      cells = nextDayCells.copy()\n      day += 1\n\n    return cells",
      "title": "957. Prison Cells After N Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2dd78467-ebf7-4a62-93c8-c69c50403acd",
      "code": "class Solution:\n  def repeatedNTimes(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2):\n      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:\n        return nums[i]\n    return nums[-1]",
      "title": "961. N-Repeated Element in Size 2N Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00132a76-3750-4bf8-ac7e-b3bd3e3393ec",
      "code": "class Solution:\n  def maxWidthRamp(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i, num in enumerate(nums):\n      if stack == [] or num <= nums[stack[-1]]:\n        stack.append(i)\n\n    for i, num in reversed(list(enumerate(nums))):\n      while stack and num >= nums[stack[-1]]:\n        ans = max(ans, i - stack.pop())\n\n    return ans",
      "title": "962. Maximum Width Ramp",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22114e5c-0404-4b51-9cda-200b99852bef",
      "code": "class Solution:\n  def minAreaFreeRect(self, points: list[list[int]]) -> float:\n    ans = math.inf\n    # For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    # For all pair points \"that share the same center\".\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          # AC is perpendicular to AD.\n          # AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else math.sqrt(ans)",
      "title": "963. Minimum Area Rectangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d40e5a5c-26e5-48b1-aa1b-701949601865",
      "code": "class Solution:\n  def leastOpsExpressTarget(self, x: int, target: int) -> int:\n    @functools.lru_cache(None)\n    def dfs(target):\n      if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n      if x == target:\n        return 0\n\n      prod = x\n      n = 0\n      while prod < target:\n        prod *= x\n        n += 1\n      if prod == target:\n        return n\n\n      ans = dfs(target - prod // x) + n\n      if prod < 2 * target:\n        ans = min(ans, dfs(prod - target) + n + 1)\n      return ans\n\n    return dfs(target)",
      "title": "964. Least Operators to Express Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6b4724a-cb62-45e2-9e52-032cb3122b1a",
      "code": "class Solution:\n  def isUnivalTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n    if root.left and root.left.val != root.val:\n      return False\n    if root.right and root.right.val != root.val:\n      return False\n    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)",
      "title": "965. Univalued Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e977bdf-9611-4d33-8252-bf571e00ae0a",
      "code": "class Solution:\n  def spellchecker(self, wordlist: list[str], queries: list[str]) -> list[str]:\n    def lowerKey(word: str) -> str:\n      return '$' + ''.join([c.lower() for c in word])\n\n    def vowelKey(word: str) -> str:\n      return ''.join(['*' if c.lower() in 'aeiou' else c.lower() for c in word])\n\n    ans = []\n    dict = {}\n\n    for word in wordlist:\n      dict.setdefault(word, word)\n      dict.setdefault(lowerKey(word), word)\n      dict.setdefault(vowelKey(word), word)\n\n    for query in queries:\n      if query in dict:\n        ans.append(dict[query])\n      elif lowerKey(query) in dict:\n        ans.append(dict[lowerKey(query)])\n      elif vowelKey(query) in dict:\n        ans.append(dict[vowelKey(query)])\n      else:\n        ans.append('')\n\n    return ans",
      "title": "966. Vowel Spellchecker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8900149f-3cdf-405a-8553-92e911bdf918",
      "code": "class Solution:\n  def pancakeSort(self, arr: list[int]) -> list[int]:\n    ans = []\n\n    for target in range(len(arr), 0, -1):\n      index = arr.index(target)\n      arr[:index + 1] = arr[:index + 1][::-1]\n      arr[:target] = arr[:target][::-1]\n      ans.append(index + 1)\n      ans.append(target)\n\n    return ans",
      "title": "969. Pancake Sorting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f5b8cc2-13b0-4b0b-927c-983ade0a2627",
      "code": "class Solution:\n  def powerfulIntegers(self, x: int, y: int, bound: int) -> list[int]:\n    xs = {x**i for i in range(20) if x**i < bound}\n    ys = {y**i for i in range(20) if y**i < bound}\n    return list({i + j for i in xs for j in ys if i + j <= bound})",
      "title": "970. Powerful Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc2755f8-cd8e-4666-b7c6-5aeb64fd699a",
      "code": "class Solution:\n  def isRationalEqual(self, s: str, t: str) -> bool:\n    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]\n\n    def valueOf(s: str) -> float:\n      if s.find('(') == -1:\n        return float(s)\n\n      # Get the indices.\n      leftParenIndex = s.find('(')\n      rightParenIndex = s.find(')')\n      dotIndex = s.find('.')\n\n      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n      integerAndNonRepeating = float(s[:leftParenIndex])\n      nonRepeatingLength = leftParenIndex - dotIndex - 1\n\n      # repeating := <RepeatingPart>\n      repeating = int(s[leftParenIndex + 1:rightParenIndex])\n      repeatingLength = rightParenIndex - leftParenIndex - 1\n      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]\n\n    return abs(valueOf(s) - valueOf(t)) < 1e-9",
      "title": "972. Equal Rational Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c57b0c7b-7691-4c11-ad0b-d2c210ce0c64",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      randIndex = random.randint(0, r - l + 1) + l\n      points[randIndex], points[r] = points[r], points[randIndex]\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n\n\nclass Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]",
      "title": "973. K Closest Points to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bad2f65-010b-4b5f-ac75-3735b2a4eefa",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    maxHeap = []\n\n    for x, y in points:\n      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n\n    return [pair[1] for pair in maxHeap]",
      "title": "973. K Closest Points to Origin_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2bad443-a1ac-49bb-a249-3aae22b72de0",
      "code": "class Solution:\n  def subarraysDivByK(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = [0] * k\n    count[0] = 1\n\n    for num in nums:\n      prefix = (prefix + num % k + k) % k\n      ans += count[prefix]\n      count[prefix] += 1\n\n    return ans",
      "title": "974. Subarray Sums Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d63ee29-6bd8-4794-bff1-dd29895d0987",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    nums = sorted(nums)\n\n    for i in range(len(nums) - 1, 1, -1):\n      if nums[i - 2] + nums[i - 1] > nums[i]:\n        return nums[i - 2] + nums[i - 1] + nums[i]\n\n    return 0",
      "title": "976. Largest Perimeter Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8b72d5-0cd5-41d9-bc6a-89a5b1487ea6",
      "code": "class Solution:\n  def sortedSquares(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    l = 0\n    r = n - 1\n    ans = [0] * n\n\n    while n:\n      n -= 1\n      if abs(nums[l]) > abs(nums[r]):\n        ans[n] = nums[l] * nums[l]\n        l += 1\n      else:\n        ans[n] = nums[r] * nums[r]\n        r -= 1\n\n    return ans",
      "title": "977. Squares of a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25d06bd8-49cf-4253-bc3f-bf198f5f5327",
      "code": "class Solution:\n  def maxTurbulenceSize(self, arr: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(arr)):\n      if arr[i] > arr[i - 1]:\n        increasing = decreasing + 1\n        decreasing = 1\n      elif arr[i] < arr[i - 1]:\n        decreasing = increasing + 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, max(increasing, decreasing))\n\n    return ans",
      "title": "978. Longest Turbulent Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b79a5548-56a2-4835-9270-c50094037fe3",
      "code": "class Solution:\n  def countTriplets(self, nums: list[int]) -> int:\n    MAX = 1 << 16\n    ans = 0\n    count = [0] * MAX  # {nums[i] & nums[j]: times}\n\n    for a in nums:\n      for b in nums:\n        count[a & b] += 1\n\n    for num in nums:\n      for i in range(MAX):\n        if (num & i) == 0:\n          ans += count[i]\n\n    return ans",
      "title": "982. Triples with Bitwise AND Equal To Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a05606c-b134-42d4-bb8f-213e13e483f2",
      "code": "class Solution:\n  def mincostTickets(self, days: list[int], costs: list[int]) -> int:\n    ans = 0\n    last7 = collections.deque()\n    last30 = collections.deque()\n\n    for day in days:\n      while last7 and last7[0][0] + 7 <= day:\n        last7.popleft()\n      while last30 and last30[0][0] + 30 <= day:\n        last30.popleft()\n      last7.append([day, ans + costs[1]])\n      last30.append([day, ans + costs[2]])\n      ans = min(ans + costs[0], last7[0][1], last30[0][1])\n\n    return ans",
      "title": "983. Minimum Cost For Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8680a11-73ae-4b4b-afe5-05026e48359b",
      "code": "class Solution:\n  def sumEvenAfterQueries(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    summ = sum(a for a in nums if a % 2 == 0)\n\n    for val, index in queries:\n      if nums[index] % 2 == 0:\n        summ -= nums[index]\n      nums[index] += val\n      if nums[index] % 2 == 0:\n        summ += nums[index]\n      ans.append(summ)\n\n    return ans",
      "title": "985. Sum of Even Numbers After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d8a8041-e1a7-4651-9506-c38d40b1e8ba",
      "code": "class Solution:\n  def intervalIntersection(self, firstList: list[list[int]],\n                           secondList: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0\n    j = 0\n\n    while i < len(firstList) and j < len(secondList):\n      # lo := the start of the intersection\n      # hi := the end of the intersection\n      lo = max(firstlist[i][0], secondlist[j][0])\n      hi = min(firstlist[i][1], secondlist[j][1])\n      if lo <= hi:\n        ans.append([lo, hi])\n      if firstlist[i][1] < secondlist[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "986. Interval List Intersections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f23896c8-2a1b-42dd-809e-fe3bb3603884",
      "code": "class Solution:\n  def verticalTraversal(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n    xToNodes = collections.defaultdict(list)\n\n    def dfs(node: TreeNode | None, x: int, y: int) -> None:\n      if not node:\n        return\n      xToNodes[x].append((-y, node.val))\n      dfs(node.left, x - 1, y - 1)\n      dfs(node.right, x + 1, y - 1)\n\n    dfs(root, 0, 0)\n\n    for _, nodes in sorted(xToNodes.items(), key=lambda x: x[0]):\n      ans.append([val for _, val in sorted(nodes)])\n\n    return ans",
      "title": "987. Vertical Order Traversal of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b467e6a5-d5e9-45fd-8c6c-1722164592ba",
      "code": "class Solution:\n  def addToArrayForm(self, num: list[int], k: int) -> list[int]:\n    for i in reversed(range(len(num))):\n      k, num[i] = divmod(num[i] + k, 10)\n\n    while k > 0:\n      num = [k % 10] + num\n      k //= 10\n\n    return num",
      "title": "989. Add to Array-Form of Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5da3c7c7-7294-4631-b221-27ee902d1617",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: list[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'),\n                 ord(y) - ord('a'))\n\n    return all(\n        uf.find(ord(x) - ord('a')) !=\n        uf.find(ord(y) - ord('a'))\n        for x, op, _, y in equations\n        if op == '!')",
      "title": "990. Satisfiability of Equality Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f7261d3-21e0-447c-940a-edafce036039",
      "code": "class Solution:\n  def brokenCalc(self, startValue: int, target: int) -> int:\n    ops = 0\n\n    while startValue < target:\n      if target % 2 == 0:\n        target //= 2\n      else:\n        target += 1\n      ops += 1\n\n    return ops + startValue - target",
      "title": "991. Broken Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17f60e04-5194-462d-b309-9c26fefc2f76",
      "code": "class Solution:\n  def subarraysWithKDistinct(self, nums: list[int], k: int) -> int:\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)",
      "title": "992. Subarrays with K Different Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c0ec0ec-6a84-40d7-bef9-04afe63541ce",
      "code": "class Solution:\n  def minKBitFlips(self, nums: list[int], k: int) -> int:\n    ans = 0\n    flippedTime = 0\n\n    for i, num in enumerate(nums):\n      if i >= k and nums[i - k] == 2:\n        flippedTime -= 1\n      if flippedTime % 2 == num:\n        if i + k > len(nums):\n          return -1\n        ans += 1\n        flippedTime += 1\n        nums[i] = 2\n\n    return ans",
      "title": "995. Minimum Number of K Consecutive Bit Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7889c3da-ba84-4629-a05a-ffc14702d998",
      "code": "class Solution:\n  def numSquarefulPerms(self, nums: list[int]) -> int:\n    ans = 0\n    used = [False] * len(nums)\n\n    def isSquare(num: int) -> bool:\n      root = math.isqrt(num)\n      return root * root == num\n\n    def dfs(path: list[int]) -> None:\n      nonlocal ans\n      if len(path) > 1 and not isSquare(path[-1] + path[-2]):\n        return\n      if len(path) == len(nums):\n        ans += 1\n        return\n\n      for i, a in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        dfs(path + [a])\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "996. Number of Squareful Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad016483-24d3-4bd8-9801-0cb045a10045",
      "code": "class Solution:\n  def findJudge(self, n: int, trust: list[list[int]]) -> int:\n    count = [0] * (n + 1)\n\n    for a, b in trust:\n      count[a] -= 1\n      count[b] += 1\n\n    for i in range(1, n + 1):\n      if count[i] == n - 1:\n        return i\n\n    return -1",
      "title": "997. Find the Town Judge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12a07389-8383-446f-a06a-117bdb9a755e",
      "code": "class Solution:\n  def insertIntoMaxTree(\n      self,\n      root: TreeNode | None,\n      val: int,\n  ) -> TreeNode | None:\n    if root.val < val:\n      return TreeNode(val, root, None)\n    curr = root\n    while curr.right and curr.right.val > val:\n      curr = curr.right\n    inserted = TreeNode(val, curr.right, None)\n    curr.right = inserted\n    return root",
      "title": "998. Maximum Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f04d20f6-bf1d-4391-a909-24ba92d375e6",
      "code": "class Solution:\n  def numRookCaptures(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "999. Available Captures for Rook",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c9d4fff-7a7c-4c97-be8f-68e5b1d81c9c",
      "code": "class Solution:\n  def gridIllumination(\n      self,\n      n: int,\n      lamps: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans",
      "title": "1001. Grid Illumination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a434700-6ec5-4cec-a602-d2e7e64b0020",
      "code": "class Solution:\n  def commonChars(self, words: list[str]) -> list[str]:\n    return functools.reduce(lambda a, b: a & b,\n                            map(collections.Counter, words)).elements()",
      "title": "1002. Find Common Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a682f05a-ea11-48f1-b5e8-c9b384b03637",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == 'c':\n        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n          return False\n        stack.pop()\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return not stack",
      "title": "1003. Check If Word Is Valid After Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4d4a5df-1b01-414c-ac47-6723b7598ac6",
      "code": "class Solution:\n  def longestOnes(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        k -= 1\n      while k < 0:\n        if nums[l] == 0:\n          k += 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1004. Max Consecutive Ones III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e2a127e-0b8d-45b9-a3e7-dd8672961798",
      "code": "class Solution:\n  def largestSumAfterKNegations(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      if num > 0 or k == 0:\n        break\n      nums[i] = -num\n      k -= 1\n\n    return sum(nums) - (k % 2) * min(nums) * 2",
      "title": "1005. Maximize Sum Of Array After K Negations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42de4a01-d84e-4341-a98b-a9bf82a9af07",
      "code": "class Solution:\n  def clumsy(self, n: int) -> int:\n    if n == 1:\n      return 1\n    if n == 2:\n      return 2\n    if n == 3:\n      return 6\n    if n == 4:\n      return 7\n    if n % 4 == 1:\n      return n + 2\n    if n % 4 == 2:\n      return n + 2\n    if n % 4 == 3:\n      return n - 1\n    return n + 1",
      "title": "1006. Clumsy Factorial",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2256e98-3c28-4fef-b8b5-0376c3ea4b68",
      "code": "class Solution:\n  def minDominoRotations(self, tops: list[int], bottoms: list[int]) -> int:\n    for num in range(1, 7):\n      if all(num in pair for pair in zip(tops, bottoms)):\n        return len(tops) - max(tops.count(num), bottoms.count(num))\n    return -1",
      "title": "1007. Minimum Domino Rotations For Equal Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f0efe62-cd5a-4267-8a29-c9317c2ace86",
      "code": "class Solution:\n  def bstFromPreorder(self, preorder: list[int]) -> TreeNode | None:\n    root = TreeNode(preorder[0])\n    stack = [root]\n\n    for i in range(1, len(preorder)):\n      parent = stack[-1]\n      child = TreeNode(preorder[i])\n      # Adjust the parent.\n      while stack and stack[-1].val < child.val:\n        parent = stack.pop()\n      # Create parent-child link according to BST property.\n      if parent.val > child.val:\n        parent.left = child\n      else:\n        parent.right = child\n      stack.append(child)\n\n    return root",
      "title": "1008. Construct Binary Search Tree from Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fe4540f-0be4-4d91-805b-c98393a38730",
      "code": "class Solution:\n  def bitwiseComplement(self, n: int) -> int:\n    mask = 1\n    while mask < n:\n      mask = (mask << 1) + 1\n    return mask ^ n",
      "title": "1009. Complement of Base 10 Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e4ab45e-8f7a-4ed4-b5ba-a242eb07b16b",
      "code": "class Solution:\n  def numPairsDivisibleBy60(self, time: list[int]) -> int:\n    ans = 0\n    count = [0] * 60\n\n    for t in time:\n      t %= 60\n      ans += count[(60 - t) % 60]\n      count[t] += 1\n\n    return ans",
      "title": "1010. Pairs of Songs With Total Durations Divisible by 60",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e960f93-3684-4d4a-b465-8388bbc8bcde",
      "code": "class Solution:\n  def shipWithinDays(self, weights: list[int], days: int) -> int:\n    def shipDays(shipCapacity: int) -> int:\n      shipDays = 1\n      capacity = 0\n      for weight in weights:\n        if capacity + weight > shipCapacity:\n          shipDays += 1\n          capacity = weight\n        else:\n          capacity += weight\n      return shipDays\n\n    l = max(weights)\n    r = sum(weights)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: shipDays(m) <= days) + l",
      "title": "1011. Capacity To Ship Packages Within D Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88dfcf0d-a11b-42d4-a396-d1f24f2e42a1",
      "code": "class Solution:\n  def numDupDigitsAtMostN(self, n: int) -> int:\n    return n - self._countSpecialNumbers(n)\n\n  # Same as 2376. Count Special Integers\n  def _countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "1012. Numbers With Repeated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31a62de7-3c76-4a29-84b4-84588048f3ed",
      "code": "class Solution:\n  def canThreePartsEqualSum(self, arr: list[int]) -> bool:\n    summ = sum(arr)\n    if summ % 3 != 0:\n      return False\n\n    average = summ // 3\n    partCount = 0\n    partSum = 0\n\n    for a in arr:\n      partSum += a\n      if partSum == average:\n        partCount += 1\n        partSum = 0\n\n    # edge case: arr = [0, 0, 0, 0] . partCount = 4.\n    return partCount >= 3",
      "title": "1013. Partition Array Into Three Parts With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cd4b959-8834-4c6f-b183-a616b3cd5a1b",
      "code": "class Solution:\n  def maxScoreSightseeingPair(self, values: list[int]) -> int:\n    ans = 0\n    bestPrev = 0\n\n    for value in values:\n      ans = max(ans, value + bestPrev)\n      bestPrev = max(bestPrev, value) - 1\n\n    return ans",
      "title": "1014. Best Sightseeing Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2dbba38-adae-41c4-a1e5-bda8bddfbee4",
      "code": "class Solution:\n  def smallestRepunitDivByK(self, k: int) -> int:\n    if k % 10 not in {1, 3, 7, 9}:\n      return -1\n\n    seen = set()\n    n = 0\n\n    for length in range(1, k + 1):\n      n = (n * 10 + 1) % k\n      if n == 0:\n        return length\n      if n in seen:\n        return -1\n      seen.add(n)\n\n    return -1",
      "title": "1015. Smallest Integer Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0324b633-d407-4a40-acda-fcc830eb182f",
      "code": "class Solution:\n  def queryString(self, s: str, n: int) -> bool:\n    if n > 1511:\n      return False\n\n    for i in range(n, n // 2, -1):\n      if format(i, 'b') not in s:\n        return False\n\n    return True",
      "title": "1016. Binary String With Substrings Representing 1 To N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bc6048e-d176-409c-bc2a-1d493221a2d4",
      "code": "class Solution:\n  def baseNeg2(self, n: int) -> str:\n    ans = []\n\n    while n != 0:\n      ans.append(str(n % 2))\n      n = -(n >> 1)\n\n    return ''.join(reversed(ans)) if ans else '0'",
      "title": "1017. Convert to Base -2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34a22c2c-2c12-415e-900b-61b62e0add1f",
      "code": "class Solution:\n  def prefixesDivBy5(self, nums: list[int]) -> list[bool]:\n    ans = []\n    curr = 0\n\n    for num in nums:\n      curr = (curr * 2 + num) % 5\n      ans.append(curr % 5 == 0)\n\n    return ans",
      "title": "1018. Binary Prefix Divisible By 5",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc44b80f-9f7e-4ab5-8b0e-a9753526007b",
      "code": "class Solution:\n  def nextLargerNodes(self, head: ListNode) -> list[int]:\n    ans = []\n    stack = []\n\n    while head:\n      while stack and head.val > ans[stack[-1]]:\n        index = stack.pop()\n        ans[index] = head.val\n      stack.append(len(ans))\n      ans.append(head.val)\n      head = head.next\n\n    for i in stack:\n      ans[i] = 0\n\n    return ans",
      "title": "1019. Next Greater Node In Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13a9aef1-998d-4115-ae98-a9944ecbb574",
      "code": "class Solution:\n  def removeOuterParentheses(self, s: str) -> str:\n    ans = []\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        if opened > 1:\n          ans.append(c)\n      else:  # c == ')'\n        opened -= 1\n        if opened > 0:\n          ans.append(c)\n\n    return ''.join(ans)",
      "title": "1021. Remove Outermost Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23089b81-7706-4bf1-9de3-46eec1c9da1c",
      "code": "class Solution:\n  def sumRootToLeaf(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, val: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      val = val * 2 + root.val\n      if not root.left and not root.right:\n        ans += val\n      dfs(root.left, val)\n      dfs(root.right, val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1022. Sum of Root To Leaf Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7c835db-50f7-47b6-92be-65a14bc8e072",
      "code": "class Solution:\n  def camelMatch(self, queries: list[str], pattern: str) -> list[bool]:\n    def isMatch(query: str) -> bool:\n      j = 0\n      for c in query:\n        if j < len(pattern) and c == pattern[j]:\n          j += 1\n        elif c.isupper():\n          return False\n      return j == len(pattern)\n\n    return [isMatch(query) for query in queries]",
      "title": "1023. Camelcase Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bc80e46-68d2-436f-9914-f1f2c0cb9079",
      "code": "class Solution:\n  def videoStitching(self, clips: list[list[int]], time: int) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    clips.sort()\n\n    i = 0\n    while farthest < time:\n      while i < len(clips) and clips[i][0] <= end:\n        farthest = max(farthest, clips[i][1])\n        i += 1\n      if end == farthest:\n        return -1\n      ans += 1\n      end = farthest\n\n    return ans",
      "title": "1024. Video Stitching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89c10016-6d4d-4b97-bb1a-0aaba7697344",
      "code": "class Solution:\n  def divisorGame(self, n: int) -> bool:\n    return n % 2 == 0",
      "title": "1025. Divisor Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b17238a7-1912-41e0-86d7-c82fac196e2d",
      "code": "class Solution:\n  def longestArithSeqLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]\n    # with k = diff + 500\n    dp = [[0] * 1001 for _ in range(n)]\n\n    for i in range(n):\n      for j in range(i):\n        k = nums[i] - nums[j] + 500\n        dp[i][k] = max(2, dp[j][k] + 1)\n        ans = max(ans, dp[i][k])\n\n    return ans",
      "title": "1027. Longest Arithmetic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3e0232f-f4c9-43e3-9f7e-49035f7e1fe9",
      "code": "class Solution:\n  def recoverFromPreorder(self, traversal: str) -> TreeNode | None:\n    i = 0\n\n    def recoverFromPreorder(depth: int) -> TreeNode | None:\n      nonlocal i\n      nDashes = 0\n      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':\n        nDashes += 1\n      if nDashes != depth:\n        return None\n\n      i += depth\n      start = i\n      while i < len(traversal) and traversal[i].isdigit():\n        i += 1\n\n      return TreeNode(int(traversal[start:i]),\n                      recoverFromPreorder(depth + 1),\n                      recoverFromPreorder(depth + 1))\n\n    return recoverFromPreorder(0)",
      "title": "1028. Recover a Tree From Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47dfa502-3ba1-4677-90b5-db630c96a386",
      "code": "class Solution:\n  def twoCitySchedCost(self, costs: list[list[int]]) -> int:\n    n = len(costs) // 2\n\n    # How much money can we save if we fly a person to A instead of B?\n    # To save money, we should\n    #   1. Fly the person with the maximum saving to A.\n    #   2. Fly the person with the minimum saving to B.\n\n    # Sort `costs` in ascending order by the money saved if we fly a person to\n    # B instead of A.\n    costs.sort(key=lambda x: x[0] - x[1])\n    return sum(costs[i][0] + costs[i + n][1] for i in range(n))",
      "title": "1029. Two City Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f851e060-9e5d-4f59-81d6-0f9746504217",
      "code": "class Solution:\n  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    q = collections.deque([(rCenter, cCenter)])\n    seen = {(rCenter, cCenter)}\n\n    while q:\n      i, j = q.popleft()\n      ans.append([i, j])\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == rows or y < 0 or y == cols:\n          continue\n        if (x, y) in seen:\n          continue\n        seen.add((x, y))\n        q.append((x, y))\n\n    return ans",
      "title": "1030. Matrix Cells in Distance Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "448f113c-1595-46a6-8f97-778bc2627714",
      "code": "class Solution:\n  def maxSumTwoNoOverlap(\n      self,\n      nums: list[int],\n      firstLen: int,\n      secondLen: int,\n  ) -> int:\n    def helper(l: int, r: int) -> int:\n      n = len(nums)\n      left = [0] * n\n      summ = 0\n\n      for i in range(n):\n        summ += nums[i]\n        if i >= l:\n          summ -= nums[i - l]\n        if i >= l - 1:\n          left[i] = max(left[i - 1], summ) if i > 0 else summ\n\n      right = [0] * n\n      summ = 0\n\n      for i in reversed(range(n)):\n        summ += nums[i]\n        if i <= n - r - 1:\n          summ -= nums[i + r]\n        if i <= n - r:\n          right[i] = max(right[i + 1], summ) if i < n - 1 else summ\n\n      return max(left[i] + right[i + 1] for i in range(n - 1))\n\n    return max(helper(firstLen, secondLen), helper(secondLen, firstLen))",
      "title": "1031. Maximum Sum of Two Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "410091ad-7f95-41c8-9b4e-32f012fabbb8",
      "code": "class Solution:\n  def numMovesStones(self, a: int, b: int, c: int) -> list[int]:\n    nums = sorted([a, b, c])\n\n    if nums[2] - nums[0] == 2:\n      return [0, 0]\n    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,\n            nums[2] - nums[0] - 2]",
      "title": "1033. Moving Stones Until Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a61c9d0-9742-4332-987e-56f6b7c70389",
      "code": "class Solution:\n  def colorBorder(\n      self,\n      grid: list[list[int]],\n      r0: int,\n      c0: int,\n      color: int\n  ) -> list[list[int]]:\n    def dfs(i: int, j: int, startColor: int) -> None:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] != startColor:\n        return\n\n      grid[i][j] = -startColor\n      dfs(i + 1, j, startColor)\n      dfs(i - 1, j, startColor)\n      dfs(i, j + 1, startColor)\n      dfs(i, j - 1, startColor)\n\n      # If this cell is already on the boarder, it must be painted later.\n      if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:\n        return\n\n      if (abs(grid[i + 1][j]) == startColor and\n          abs(grid[i - 1][j]) == startColor and\n          abs(grid[i][j + 1]) == startColor and\n              abs(grid[i][j - 1]) == startColor):\n        grid[i][j] = startColor\n\n    dfs(r0, c0, grid[r0][c0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num < 0:\n          grid[i][j] = color\n\n    return grid",
      "title": "1034. Coloring A Border",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7d12607-46cd-4263-91c2-6449e4207c1e",
      "code": "class Solution:\n  def maxUncrossedLines(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j - 1] + 1\n                    if nums1[i - 1] == nums2[j - 1]\n                    else max(dp[i - 1][j], dp[i][j - 1]))\n\n    return dp[m][n]",
      "title": "1035. Uncrossed Lines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b03a492c-938c-4664-88a3-6bc183bafab7",
      "code": "class Solution:\n  def isEscapePossible(\n      self,\n      blocked: list[list[int]],\n      source: list[int],\n      target: list[int]\n  ) -> bool:\n    def dfs(i: int, j: int, target: list[int], seen: set) -> bool:\n      if i < 0 or i >= 10**6 or j < 0 or j >= 10**6:\n        return False\n      if (i, j) in blocked or (i, j) in seen:\n        return False\n      seen.add((i, j))\n      return (len(seen) > (1 + 199) * 199 // 2 or [i, j] == target or\n              dfs(i + 1, j, target, seen) or\n              dfs(i - 1, j, target, seen) or\n              dfs(i, j + 1, target, seen) or\n              dfs(i, j - 1, target, seen))\n\n    blocked = set(tuple(b) for b in blocked)\n    return (dfs(source[0], source[1], target, set()) and\n            dfs(target[0], target[1], source, set()))",
      "title": "1036. Escape a Large Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0e2d766-f656-4794-806c-0053419c2f38",
      "code": "class Solution:\n  def isBoomerang(self, points: list[list[int]]) -> bool:\n    return ((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=\n            (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]))",
      "title": "1037. Valid Boomerang",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "371a631e-2119-476b-b22f-d67f846b48ca",
      "code": "class Solution:\n  def minScoreTriangulation(self, values: list[int]) -> int:\n    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for j in range(2, n):\n      for i in range(j - 2, -1, -1):\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + values[i]\n                         * values[k] * values[j] + dp[k][j])\n\n    return dp[0][n - 1]",
      "title": "1039. Minimum Score Triangulation of Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d29fcaab-60f1-47f4-8097-2a6057e4a89f",
      "code": "class Solution:\n  def numMovesStonesII(self, stones: list[int]) -> list[int]:\n    n = len(stones)\n    minMoves = n\n\n    stones.sort()\n\n    l = 0\n    for r, stone in enumerate(stones):\n      while stone - stones[l] + 1 > n:\n        l += 1\n      alreadyStored = r - l + 1\n      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:\n        minMoves = 2\n      else:\n        minMoves = min(minMoves, n - alreadyStored)\n\n    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]",
      "title": "1040. Moving Stones Until Consecutive II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62cd3c7f-f6f2-4f24-a57c-33f872e71965",
      "code": "class Solution:\n  def isRobotBounded(self, instructions: str) -> bool:\n    x = 0\n    y = 0\n    d = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for instruction in instructions:\n      if instruction == 'G':\n        x += directions[d][0]\n        y += directions[d][1]\n      elif instruction == 'L':\n        d = (d + 3) % 4\n      else:\n        d = (d + 1) % 4\n\n    return (x, y) == (0, 0) or d > 0",
      "title": "1041. Robot Bounded In Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf0123ae-ba4d-406c-8bbe-a902b90a8689",
      "code": "class Solution:\n  def gardenNoAdj(self, n: int, paths: list[list[int]]) -> list[int]:\n    ans = [0] * n  # ans[i] := 1, 2, 3, or 4\n    graph = [[] for _ in range(n)]\n\n    for x, y in paths:\n      u = x - 1\n      v = y - 1\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u in range(n):\n      used = functools.reduce(operator.or_, (1 << ans[v] for v in graph[u]), 0)\n      ans[u] = next(type_\n                    for type_ in range(1, 5)\n                    if not (used >> type_ & 1))\n\n    return ans",
      "title": "1042. Flower Planting With No Adjacent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0eee250c-1277-476c-8c4f-d11ed79aa15e",
      "code": "class Solution:\n  def maxSumAfterPartitioning(self, arr: list[int], k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      mx = -math.inf\n      for j in range(1, min(i, k) + 1):\n        mx = max(mx, arr[i - j])\n        dp[i] = max(dp[i], dp[i - j] + mx * j)\n\n    return dp[n]",
      "title": "1043. Partition Array for Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7777979-70b0-42ac-8f5a-7c0ebf1e63f4",
      "code": "class Solution:\n  def longestDupSubstring(self, s: str) -> str:\n    BASE = 26\n    HASH = 1_000_000_007\n    bestStart = -1\n    l = 1\n    r = len(s)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    # k := the length of the substring to be hashed\n    def getStart(k: int) -> int | None:\n      maxPow = pow(BASE, k - 1, HASH)\n      hashToStart = collections.defaultdict(list)\n      h = 0\n\n      # Compute the hash value of s[:k].\n      for i in range(k):\n        h = (h * BASE + val(s[i])) % HASH\n      hashToStart[h].append(0)\n\n      # Compute the rolling hash by Rabin Karp.\n      for i in range(k, len(s)):\n        startIndex = i - k + 1\n        h = (h - maxPow * val(s[i - k])) % HASH\n        h = (h * BASE + val(s[i])) % HASH\n        if h in hashToStart:\n          currSub = s[startIndex:startIndex + k]\n          for start in hashToStart[h]:\n            if s[start:start + k] == currSub:\n              return startIndex\n        hashToStart[h].append(startIndex)\n\n    while l < r:\n      m = (l + r) // 2\n      start: int | None = getStart(m)\n      if start:\n        bestStart = start\n        l = m + 1\n      else:\n        r = m\n\n    if bestStart == -1:\n      return ''\n    if getStart(l):\n      return s[bestStart:bestStart + l]\n    return s[bestStart:bestStart + l - 1]",
      "title": "1044. Longest Duplicate Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "585e3b5b-01a7-49ad-9c15-15399c72dca0",
      "code": "class Solution:\n  def lastStoneWeight(self, stones: list[int]) -> int:\n    pq = [-stone for stone in stones]\n    heapq.heapify(pq)\n\n    while len(pq) >= 2:\n      n1 = -heapq.heappop(pq)\n      n2 = -heapq.heappop(pq)\n      if n1 != n2:\n        heapq.heappush(pq, -(n1 - n2))\n\n    return 0 if not pq else -pq[0]",
      "title": "1046. Last Stone Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "158253c8-e6b5-422c-8ea2-95108509c20c",
      "code": "class Solution:\n  def longestStrChain(self, words: list[str]) -> int:\n    wordsSet = set(words)\n\n    @functools.lru_cache(None)\n    def dp(s: str) -> int:\n      \"\"\"Returns the longest chain where s is the last word.\"\"\"\n      ans = 1\n      for i in range(len(s)):\n        pred = s[:i] + s[i + 1:]\n        if pred in wordsSet:\n          ans = max(ans, dp(pred) + 1)\n      return ans\n\n    return max(dp(word) for word in words)",
      "title": "1048. Longest String Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ceffcc9-6de5-41a9-bd4f-2fc933d98ab2",
      "code": "class Solution:\n  def lastStoneWeightII(self, stones: list[int]) -> int:\n    summ = sum(stones)\n    s = 0\n    dp = [True] + [False] * summ\n\n    for stone in stones:\n      for w in range(summ // 2 + 1)[::-1]:\n        if w >= stone:\n          dp[w] = dp[w] or dp[w - stone]\n        if dp[w]:\n          s = max(s, w)\n\n    return summ - 2 * s",
      "title": "1049. Last Stone Weight II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "011222b0-eafc-4008-b08c-c1c5886f76f5",
      "code": "class Solution:\n  def heightChecker(self, heights: list[int]) -> int:\n    ans = 0\n    currentHeight = 1\n    count = [0] * 101\n\n    for height in heights:\n      count[height] += 1\n\n    for height in heights:\n      while count[currentHeight] == 0:\n        currentHeight += 1\n      if height != currentHeight:\n        ans += 1\n      count[currentHeight] -= 1\n\n    return ans",
      "title": "1051. Height Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5b6a590-a4d2-4c36-bc22-ec7c4b2a623b",
      "code": "class Solution:\n  def maxSatisfied(\n      self,\n      customers: list[int],\n      grumpy: list[int],\n      X: int,\n  ) -> int:\n    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)\n    madeSatisfied = 0\n    windowSatisfied = 0\n\n    for i, customer in enumerate(customers):\n      if grumpy[i] == 1:\n        windowSatisfied += customer\n      if i >= X and grumpy[i - X] == 1:\n        windowSatisfied -= customers[i - X]\n      madeSatisfied = max(madeSatisfied, windowSatisfied)\n\n    return satisfied + madeSatisfied",
      "title": "1052. Grumpy Bookstore Owner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6c362e1-077b-48af-8af2-936f8661aace",
      "code": "class Solution:\n  def prevPermOpt1(self, arr: list[int]) -> list[int]:\n    n = len(arr)\n    l = n - 2\n    r = n - 1\n\n    while l >= 0 and arr[l] <= arr[l + 1]:\n      l -= 1\n    if l < 0:\n      return arr\n    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:\n      r -= 1\n    arr[l], arr[r] = arr[r], arr[l]\n\n    return arr",
      "title": "1053. Previous Permutation With One Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d7cf70c-7505-4ff9-a5a6-a3ff538e3bb9",
      "code": "class Solution:\n  def rearrangeBarcodes(self, barcodes: list[int]) -> list[int]:\n    ans = [0] * len(barcodes)\n    count = collections.Counter(barcodes)\n    i = 0  # ans' index\n    maxNum = max(count, key=count.get)\n\n    def fillAns(num: int) -> None:\n      nonlocal i\n      while count[num]:\n        ans[i] = num\n        i = i + 2 if i + 2 < len(barcodes) else 1\n        count[num] -= 1\n\n    fillAns(maxNum)\n    for num in count.keys():\n      fillAns(num)\n\n    return ans",
      "title": "1054. Distant Barcodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9445bf16-35c1-4649-8449-8ea56738bbe8",
      "code": "class Solution:\n  def confusingNumber(self, n: int) -> bool:\n    s = str(n)\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    rotatedNum = []\n\n    for c in s[::-1]:\n      if c not in rotated:\n        return False\n      rotatedNum.append(rotated[c])\n\n    return ''.join(rotatedNum) != s",
      "title": "1056. Confusing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "726cbe99-3deb-4862-b633-4d9af7fcbcdc",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(workers)\n    usedBikes = [False] * len(bikes)\n    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])\n    buckets = [[] for _ in range(2001)]\n\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    for i, worker in enumerate(workers):\n      for j, bike in enumerate(bikes):\n        buckets[dist(worker, bike)].append((i, j))\n\n    for k in range(2001):\n      for i, j in buckets[k]:\n        if ans[i] == -1 and not usedBikes[j]:\n          ans[i] = j\n          usedBikes[j] = True\n\n    return ans",
      "title": "1057. Campus Bikes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3dffa66-0dc7-4a17-8389-fc8b742b43f6",
      "code": "class Solution:\n  def minimizeError(self, prices: list[str], target: int) -> str:\n    # A[i] := (costCeil - costFloor, costCeil, costFloor)\n    # The lower the costCeil - costFloor is, the cheaper to ceil it.\n    A = []\n    sumFloored = 0\n    sumCeiled = 0\n\n    for price in map(float, prices):\n      floored = math.floor(price)\n      ceiled = math.ceil(price)\n      sumFloored += floored\n      sumCeiled += ceiled\n      costFloor = price - floored\n      costCeil = ceiled - price\n      A.append((costCeil - costFloor, costCeil, costFloor))\n\n    if not sumFloored <= target <= sumCeiled:\n      return '-1'\n\n    A.sort()\n    nCeiled = target - sumFloored\n    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +\n                           sum(a[2] for a in A[nCeiled:]))",
      "title": "1058. Minimize Rounding Error to Meet Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "245a8e97-df78-4ead-b1a4-5816da61f0cd",
      "code": "class Solution:\n  def longestRepeatingSubstring(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      for j in range(i + 1, n + 1):\n        if s[i - 1] == s[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "1062. Longest Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c47dd0f-5871-4c0f-aae8-f17f69b18382",
      "code": "class Solution:\n  def validSubarrays(self, nums: list[int]) -> int:\n    # For each `num` in `nums`, each element x in the stack can be the leftmost\n    # element s.t. [x, num] forms a valid subarray, so the size of the stack is\n    # the number of valid subarrays ending in the current number.\n    #\n    # e.g. nums = [1, 3, 2]\n    # num = 1, stack = [1] -> valid subarray is [1]\n    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]\n    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      stack.append(num)\n      ans += len(stack)\n\n    return ans",
      "title": "1063. Number of Valid Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8a49633-dc2a-45a6-90b1-9b03a1326cfa",
      "code": "class Solution:\n  def fixedPoint(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.\n    # Therefore, binary search `arr` for the first arr[i] - i = 0.\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] - m >= 0:\n        r = m\n      else:\n        l = m + 1\n\n    return l if arr[l] == l else -1",
      "title": "1064. Fixed Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1d56837-5f60-4ce3-bd6f-5e03705819e6",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def indexPairs(self, text: str, words: list[str]) -> list[list[int]]:\n    ans = []\n    root = TrieNode()\n\n    for word in words:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    # Scan each text[i..j].\n    for i in range(len(text)):\n      node: TrieNode = root\n      for j in range(i, len(text)):\n        c = text[j]\n        if c not in node.children:\n          break\n        node = node.children[c]\n        if node.isWord:\n          ans.append([i, j])\n\n    return ans",
      "title": "1065. Index Pairs of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8430bd49-2a0e-47a6-b4b3-090a8aa6e3e3",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> int:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    @functools.lru_cache(None)\n    def dp(workerIndex: int, used: int) -> int:\n      \"\"\"\n      Returns the minimum Manhattan distances to assign bikes to\n      workers[workerIndex..n), where `used` is the bitmask of the used bikes.\n      \"\"\"\n      if workerIndex == len(workers):\n        return 0\n      return min(\n          (dist(workers[workerIndex],\n                bike) + dp(workerIndex + 1, used | 1 << i) for i,\n           bike in enumerate(bikes) if not used >> i & 1),\n          default=math.inf)\n\n    return dp(0, 0)",
      "title": "1066. Campus Bikes II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acf83915-e692-4a89-8d67-1eb03fe33eca",
      "code": "class Solution:\n  def gcdOfStrings(self, str1: str, str2: str) -> str:\n    for sz in range(min(len(str1), len(str2)), 0, -1):\n      if self._isDivisible(str1, str2, sz):\n        return str1[:sz]\n    return ''\n\n  def _isDivisible(self, str1: str, str2: str, sz: int) -> bool:\n    \"\"\"Returns True if str1 and str2 are divisible by str1[0..sz).\"\"\"\n    if len(str1) % sz > 0 or len(str2) % sz > 0:\n      return False\n    gcd = str1[:sz]\n    return str1.replace(gcd, '') == '' and str2.replace(gcd, '') == ''",
      "title": "1071. Greatest Common Divisor of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad376328-bb43-4c34-ab80-ef15622a439f",
      "code": "class Solution:\n  def maxEqualRowsAfterFlips(self, matrix: list[list[int]]) -> int:\n    patterns = [tuple(a ^ row[0] for a in row) for row in matrix]\n    return max(Counter(patterns).values())",
      "title": "1072. Flip Columns For Maximum Number of Equal Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef90846c-e497-42e1-9e9e-ba635316b4f2",
      "code": "class Solution:\n  def addNegabinary(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    carry = 0\n\n    while carry != 0 or arr1 or arr2:\n      if arr1:\n        carry += arr1.pop()\n      if arr2:\n        carry += arr2.pop()\n      ans.append(carry & 1)\n      carry = -(carry >> 1)\n\n    while len(ans) > 1 and ans[-1] == 0:\n      ans.pop()\n\n    return ans[::-1]",
      "title": "1073. Adding Two Negabinary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95570c16-6fec-4e92-be55-3a049a98a9be",
      "code": "class Solution:\n  def numSubmatrixSumTarget(self, matrix: list[list[int]], target: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = 0\n\n    # Transfer each row in the matrix to the prefix sum.\n    for row in matrix:\n      for i in range(1, n):\n        row[i] += row[i - 1]\n\n    for baseCol in range(n):\n      for j in range(baseCol, n):\n        prefixCount = collections.Counter({0: 1})\n        summ = 0\n        for i in range(m):\n          if baseCol > 0:\n            summ -= matrix[i][baseCol - 1]\n          summ += matrix[i][j]\n          ans += prefixCount[summ - target]\n          prefixCount[summ] += 1\n\n    return ans",
      "title": "1074. Number of Submatrices That Sum to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4118ed3-6589-4bf0-9c47-55b0905b5e3a",
      "code": "class Solution:\n  def findOcurrences(self, text: str, first: str, second: str) -> list[str]:\n    words = text.split()\n    return [c for a, b, c in zip(words, words[1:], words[2:]) if a == first and b == second]",
      "title": "1078. Occurrences After Bigram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a225bee-ca80-4aeb-b5a2-1d8103f12779",
      "code": "class Solution:\n  def numTilePossibilities(self, tiles: str) -> int:\n    count = collections.Counter(tiles)\n\n    def dfs(count: dict[int, int]) -> int:\n      possibleSequences = 0\n\n      for k, v in count.items():\n        if v == 0:\n          continue\n        # Put c in the current position. We only care about the number of possible\n        # sequences of letters but don't care about the actual combination.\n        count[k] -= 1\n        possibleSequences += 1 + dfs(count)\n        count[k] += 1\n\n      return possibleSequences\n\n    return dfs(count)",
      "title": "1079. Letter Tile Possibilities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b9a80b8-2c9a-4314-830d-67260d372176",
      "code": "class Solution:\n  def sufficientSubset(\n      self,\n      root: TreeNode | None,\n      limit: int\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if not root.left and not root.right:\n      return None if root.val < limit else root\n    root.left = self.sufficientSubset(root.left, limit - root.val)\n    root.right = self.sufficientSubset(root.right, limit - root.val)\n    return None if not root.left and not root.right else root",
      "title": "1080. Insufficient Nodes in Root to Leaf Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7a6d2df-e7bd-48de-88d7-9475828350e7",
      "code": "class Solution:\n  def smallestSubsequence(self, text: str) -> str:\n    ans = []\n    count = collections.Counter(text)\n    used = [False] * 26\n\n    for c in text:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "1081. Smallest Subsequence of Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d28cc3d-eb73-498c-9719-a6ab8c66049b",
      "code": "class Solution:\n  def sumOfDigits(self, nums: list[int]) -> int:\n    return sum(int(d) for d in str(min(nums))) & 1 ^ 1",
      "title": "1085. Sum of Digits in the Minimum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d055964-7684-43ec-9d0c-eeaedce4d611",
      "code": "class Solution:\n  def highFive(self, items: list[list[int]]) -> list[list[int]]:\n    idToScores = collections.defaultdict(list)\n\n    for id, score in items:\n      heapq.heappush(idToScores[id], score)\n      if len(idToScores[id]) > 5:\n        heapq.heappop(idToScores[id])\n\n    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]",
      "title": "1086. High Five",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0eac31b-66ad-4e8f-bab5-e8e4bd7bcd13",
      "code": "class Solution:\n  def expand(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(s):\n        ans.append(''.join(path))\n        return\n      if s[i] == '{':\n        nextRightBraceIndex = s.find('}', i)\n        for c in s[i + 1:nextRightBraceIndex].split(','):\n          path.append(c)\n          dfs(nextRightBraceIndex + 1, path)\n          path.pop()\n      else:  # s[i] != '{'\n        path.append(s[i])\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return sorted(ans)",
      "title": "1087. Brace Expansion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e92abac-3b46-4972-a543-926551168c18",
      "code": "class Solution:\n  def confusingNumberII(self, n: int) -> int:\n    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]\n\n    def dfs(num: int, rotatedNum: int, unit: int) -> int:\n      ans = 0 if num == rotatedNum else 1\n      # Add one more digit\n      for digit, rotated in digitToRotated:\n        if digit == 0 and num == 0:\n          continue\n        nextNum = num * 10 + digit\n        if nextNum > n:\n          break\n        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)\n      return ans\n\n    return dfs(0, 0, 1)",
      "title": "1088. Confusing Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc73859c-9941-46be-b224-49e374f7b9e7",
      "code": "class Solution:\n  def duplicateZeros(self, arr: list[int]) -> None:\n    zeros = arr.count(0)\n    i = len(arr) - 1\n    j = len(arr) + zeros - 1\n\n    while i < j:\n      if j < len(arr):\n        arr[j] = arr[i]\n      if arr[i] == 0:\n        j -= 1\n        if j < len(arr):\n          arr[j] = arr[i]\n      i -= 1\n      j -= 1",
      "title": "1089. Duplicate Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7c03be3-e15f-485d-a1a6-7ec570b0d618",
      "code": "class Solution:\n  def sampleStats(self, count: list[int]) -> list[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(\n        list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]",
      "title": "1093. Statistics from a Large Sample",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "978a502a-a212-4527-8604-dcc898da1487",
      "code": "# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class MountainArray:\n#   def get(self, index: int) -> int:\n#   def length(self) -> int:\n\nclass Solution:\n  def findInMountainArray(\n      self,\n      target: int,\n      mountain_arr: 'MountainArray',\n  ) -> int:\n    n = mountain_arr.length()\n    peakIndex = self.peakIndexInMountainArray(mountain_arr, 0, n - 1)\n\n    leftIndex = self.searchLeft(mountain_arr, target, 0, peakIndex)\n    if mountain_arr.get(leftIndex) == target:\n      return leftIndex\n\n    rightIndex = self.searchRight(mountain_arr, target, peakIndex + 1, n - 1)\n    if mountain_arr.get(rightIndex) == target:\n      return rightIndex\n\n    return -1\n\n  # 852. Peak Index in a Mountain Array\n  def peakIndexInMountainArray(self, A: 'MountainArray', l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < A.get(m + 1):\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchLeft(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < target:\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchRight(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) > target:\n        l = m + 1\n      else:\n        r = m\n    return l",
      "title": "1095. Find in Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "025f47e3-b80c-46f5-8cfb-3d698b7605aa",
      "code": "class Solution:\n  def braceExpansionII(self, expression: str) -> list[str]:\n    def merge(groups: list[list[str]], group: list[str]) -> None:\n      if not groups[-1]:\n        groups[-1] = group\n        return\n\n      groups[-1] = [word1 + word2 for word1 in groups[-1]\n                    for word2 in group]\n\n    def dfs(s: int, e: int) -> list[str]:\n      groups = [[]]\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if c == '{':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == '}':\n          layer -= 1\n          if layer == 0:\n            group = dfs(left, i - 1)\n            merge(groups, group)\n        elif c == ',' and layer == 0:\n          groups.append([])\n        elif layer == 0:\n          merge(groups, [c])\n\n      return sorted(list({word for group in groups for word in group}))\n\n    return dfs(0, len(expression) - 1)",
      "title": "1096. Brace Expansion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a73a4bcd-2eba-4e32-ad5b-41698ba0cc3a",
      "code": "class Solution:\n  def twoSumLessThanK(self, nums: list[int], k: int) -> int:\n    if len(nums) < 2:\n      return -1\n\n    ans = -1  # Note the constrathat nums[i] > 0.\n    l = 0\n    r = len(nums) - 1\n\n    nums.sort()\n\n    while l < r:\n      if nums[l] + nums[r] < k:\n        ans = max(ans, nums[l] + nums[r])\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "1099. Two Sum Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8251886a-fc25-40fc-b013-4ee88e95eef1",
      "code": "class Solution:\n  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:\n    ans = 0\n    unique = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        unique += 1\n      if i >= k:\n        count[s[i - k]] -= 1\n        if count[s[i - k]] == 0:\n          unique -= 1\n        if unique == k:\n          ans += 1\n\n    return ans",
      "title": "1100. Find K-Length Substrings With No Repeated Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb01b798-32ca-405f-8d74-3378634042b2",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def earliestAcq(self, logs: list[list[int]], n: int) -> int:\n    uf = UnionFind(n)\n\n    # Sort `logs` by timestamp.\n    logs.sort(key=lambda x: x[0])\n\n    for timestamp, x, y in logs:\n      uf.unionByRank(x, y)\n      if uf.getCount() == 1:\n        return timestamp\n\n    return -1",
      "title": "1101. The Earliest Moment When Everyone Become Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09043945-8b76-4c41-8a10-1de9d5d42e1b",
      "code": "class Solution:\n  def distributeCandies(self, candies: int, n: int) -> list[int]:\n    ans = [0] * n\n    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))\n    accumN = rows * (rows - 1) * n // 2\n\n    for i in range(n):\n      ans[i] = accumN + rows * (i + 1)\n\n    givenCandies = (n**2 * rows**2 + n * rows) // 2\n    candies -= givenCandies\n    lastGiven = rows * n\n    i = 0\n\n    while candies > 0:\n      lastGiven += 1\n      actualGiven = min(lastGiven, candies)\n      candies -= actualGiven\n      ans[i] += actualGiven\n      i += 1\n\n    return ans",
      "title": "1103. Distribute Candies to People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2d6ea61-c323-4dec-a2e5-41b26468f967",
      "code": "class Solution:\n  def pathInZigZagTree(self, label: int) -> list[int]:\n    def boundarySum(level: int):\n      return 2**level + 2**(level + 1) - 1\n\n    ans = []\n\n    for l in range(21):\n      if 2**l > label:\n        level = l - 1\n        break\n\n    if level % 2 == 1:\n      label = boundarySum(level) - label\n\n    for l in reversed(range(level + 1)):\n      ans.append(label if l % 2 == 0 else boundarySum(l) - label)\n      label //= 2\n\n    return ans[::-1]",
      "title": "1104. Path In Zigzag Labelled Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0afbda94-cf98-450f-853c-4392e6f75b49",
      "code": "class Solution:\n  def minHeightShelves(self, books: list[list[int]], shelfWidth: int) -> int:\n    # dp[i] := the minimum height to place the first i books\n    dp = [0] + [math.inf] * len(books)\n\n    for i in range(len(books)):\n      sumThickness = 0\n      maxHeight = 0\n      # Place books[j..i] on a new shelf.\n      for j in range(i, -1, -1):\n        thickness, height = books[j]\n        sumThickness += thickness\n        if sumThickness > shelfWidth:\n          break\n        maxHeight = max(maxHeight, height)\n        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)\n\n    return dp[-1]",
      "title": "1105. Filling Bookcase Shelves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e659151-b44e-43d5-ae23-403cd87dfaa7",
      "code": "class Solution:\n  def parseBoolExpr(self, expression: str) -> bool:\n    def dfs(s: int, e: int) -> list[str]:\n      if s == e:\n        return True if expression[s] == 't' else False\n\n      exps = []\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if layer == 0 and c in '!&|':\n          op = c\n        elif c == '(':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == ')':\n          layer -= 1\n          if layer == 0:\n            exps.append(dfs(left, i - 1))\n        elif c == ',' and layer == 1:\n          exps.append(dfs(left, i - 1))\n          left = i + 1\n\n      if op == '|':\n        return functools.reduce(operator.or_, exps)\n      if op == '&':\n        return functools.reduce(operator.and_, exps)\n      if op == '!':\n        return not exps[0]\n\n    return dfs(0, len(expression) - 1)",
      "title": "1106. Parsing A Boolean Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2c787c1-42ff-4020-abe1-59029ecb2b4c",
      "code": "class Solution:\n  def defangIPaddr(self, address: str) -> str:\n    return address.replace('.', '[.]')",
      "title": "1108. Defanging an IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "862cf3c7-bc62-4820-b585-71cf53b34664",
      "code": "class Solution:\n  def corpFlightBookings(self, bookings: list[list[int]], n: int) -> list[int]:\n    ans = [0] * n\n\n    for booking in bookings:\n      ans[booking[0] - 1] += booking[2]\n      if booking[1] < n:\n        ans[booking[1]] -= booking[2]\n\n    for i in range(1, n):\n      ans[i] += ans[i - 1]\n\n    return ans",
      "title": "1109. Corporate Flight Bookings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b108b91e-40d9-4093-acf5-d804fe047d12",
      "code": "class Solution:\n  def delNodes(self, root: TreeNode, to_delete: list[int]) -> list[TreeNode]:\n    ans = []\n    toDeleteSet = set(to_delete)\n\n    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:\n      if not root:\n        return None\n\n      deleted = root.val in toDeleteSet\n      if isRoot and not deleted:\n        ans.append(root)\n\n      # If root is deleted, both children have the possibility to be a new root\n      root.left = dfs(root.left, deleted)\n      root.right = dfs(root.right, deleted)\n      return None if deleted else root\n\n    dfs(root, True)\n    return ans",
      "title": "1110. Delete Nodes And Return Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bfe729e-167d-42e5-8856-9b96123ce9e6",
      "code": "class Solution:\n  def maxDepthAfterSplit(self, seq: str) -> list[int]:\n    ans = []\n    depth = 1\n\n    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.\n    for c in seq:\n      if c == '(':\n        depth += 1\n        ans.append(depth % 2)\n      else:\n        ans.append(depth % 2)\n        depth -= 1\n\n    return ans",
      "title": "1111. Maximum Nesting Depth of Two Valid Parentheses Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d25878f-16c2-4872-90d6-d67b5735a039",
      "code": "class Solution:\n  def numberOfDays(self, year: int, month: int) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n    return 29 if month == 2 and isLeapYear(year) else days[month]",
      "title": "1118. Number of Days in a Month",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d9ed611-9226-4c99-ac87-7605a4531702",
      "code": "class Solution:\n  def removeVowels(self, s: str) -> str:\n    return re.sub('a|e|i|o|u', '', s)",
      "title": "1119. Remove Vowels from a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ad77a92-812d-42aa-9cca-d827b8cbfe62",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n  maxAverage: int\n\n\nclass Solution:\n  def maximumAverageSubtree(self, root: TreeNode | None) -> float:\n    def maximumAverage(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0, 0)\n\n      left = maximumAverage(root.left)\n      right = maximumAverage(root.right)\n\n      summ = root.val + left.summ + right.summ\n      count = 1 + left.count + right.count\n      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)\n      return T(summ, count, maxAverage)\n\n    return maximumAverage(root).maxAverage",
      "title": "1120. Maximum Average Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90024373-406a-4abe-ab6c-460fe3de5e77",
      "code": "class Solution:\n  def canDivideIntoSubsequences(self, nums: list[int], k: int) -> bool:\n    # Find the number with the maxFreq, we need at least maxFreq * k elements\n    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to\n    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x\n    # 3 = 6, which is impossible if len(nums) = 5\n    return len(nums) >= k * max(Counter(nums).values())",
      "title": "1121. Divide Array Into Increasing Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b561a01d-24a3-4392-84c1-9efeb66531d1",
      "code": "class Solution:\n  def relativeSortArray(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    count = [0] * 1001\n\n    for a in arr1:\n      count[a] += 1\n\n    for a in arr2:\n      while count[a] > 0:\n        ans.append(a)\n        count[a] -= 1\n\n    for num in range(1001):\n      for _ in range(count[num]):\n        ans.append(num)\n\n    return ans",
      "title": "1122. Relative Sort Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a5581dc-3f42-4242-8b58-91cfd77e69d2",
      "code": "class Solution:\n  def longestWPI(self, hours: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    dict = {}\n\n    for i in range(len(hours)):\n      prefix += 1 if hours[i] > 8 else -1\n      if prefix > 0:\n        ans = i + 1\n      else:\n        if prefix not in dict:\n          dict[prefix] = i\n        if prefix - 1 in dict:\n          ans = max(ans, i - dict[prefix - 1])\n\n    return ans",
      "title": "1124. Longest Well-Performing Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce7b01a1-851d-401b-a83f-aee4dcc6b697",
      "code": "class Solution:\n  def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for domino in dominoes:\n      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n      ans += count[key]\n      count[key] += 1\n\n    return ans",
      "title": "1128. Number of Equivalent Domino Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12552c36-366f-4d9c-a739-960064a786df",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  INIT = 0\n  RED = 1\n  BLUE = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(\n      self,\n      n: int,\n      redEdges: list[list[int]],\n      blueEdges: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]  # graph[u] := [(v, edgeColor)]\n    q = collections.deque([(0, Color.INIT)])  # [(u, prevColor)]\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.RED))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.BLUE))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)  # Mark (u, v) as used.\n      step += 1\n\n    return ans",
      "title": "1129. Shortest Path with Alternating Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e4bb608-081b-4e04-8872-ab667eecf4fb",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "062d4513-8b1b-4adb-9e9d-9512b12781ff",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f478b08-bd39-4eee-8fce-8bef91816147",
      "code": "class Solution:\n  def maxAbsValExpr(self, arr1: list[int], arr2: list[int]) -> int:\n    n = len(arr1)\n    a = [arr1[i] + arr2[i] + i for i in range(n)]\n    b = [arr1[i] + arr2[i] - i for i in range(n)]\n    c = [arr1[i] - arr2[i] + i for i in range(n)]\n    d = [arr1[i] - arr2[i] - i for i in range(n)]\n    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))",
      "title": "1131. Maximum of Absolute Value Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f363a45-2cca-4ef4-a8d7-1dee9b3b17ae",
      "code": "class Solution:\n  def largestUniqueNumber(self, nums: list[int]) -> int:\n    return max([num for num, freq in collections.Counter(nums).items()\n                if freq == 1], default=-1)",
      "title": "1133. Largest Unique Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0d7a1e0-b5bc-490e-b40a-f0e14cfc758c",
      "code": "class Solution:\n  def isArmstrong(self, n: int) -> bool:\n    s = str(n)\n    k = len(s)\n    return sum(pow(int(c), k) for c in s) == n",
      "title": "1134. Armstrong Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "351d7f5f-4207-4206-b0cb-e61b5bcc2175",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, connections: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n + 1)\n\n    # Sort by cost.\n    connections.sort(key=lambda x: x[2])\n\n    for u, v, cost in connections:\n      if uf.find(u) == uf.find(v):\n        continue\n      uf.unionByRank(u, v)\n      ans += cost\n\n    root = uf.find(1)\n    if any(uf.find(i) != root for i in range(1, n + 1)):\n      return -1\n\n    return ans",
      "title": "1135. Connecting Cities With Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ec4b1f5-3936-4745-920a-25b45e7565df",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    states = [State.INIT] * n\n    depth = [1] * n\n\n    for u, v in relations:\n      graph[u - 1].append(v - 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if hasCycle(v):\n          return True\n        depth[u] = max(depth[u], 1 + depth[v])\n      states[u] = State.VISITED\n      return False\n\n    if any(hasCycle(i) for i in range(n)):\n      return -1\n    return max(depth)",
      "title": "1136. Parallel Courses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4292c75f-345b-45e1-8800-0414a88aa13f",
      "code": "class Solution:\n  def tribonacci(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 1, 1]\n\n    for _ in range(3, n + 1):\n      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)\n\n    return dp[2]",
      "title": "1137. N-th Tribonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd5e775c-cd3a-4f3c-a1ed-39ff74163cef",
      "code": "class Solution:\n  def largest1BorderedSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    # leftOnes[i][j] := consecutive 1s in the left of grid[i][j]\n    leftOnes = [[0] * n for _ in range(m)]\n    # topOnes[i][j] := consecutive 1s in the top of grid[i][j]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          leftOnes[i][j] = 1 if j == 0 else 1 + leftOnes[i][j - 1]\n          topOnes[i][j] = 1 if i == 0 else 1 + topOnes[i - 1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          # If grid[i..x][j..y] has all 1s on its border.\n          if min(\n                  leftOnes[i][y],\n                  leftOnes[x][y],\n                  topOnes[x][j],\n                  topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0",
      "title": "1139. Largest 1-Bordered Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "156c3702-a9e0-4274-9fa8-9cd130d51f8d",
      "code": "class Solution:\n  def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n    m = len(text1)\n    n = len(text2)\n    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = (1 + dp[i][j] if text1[i] == text2[j]\n                            else max(dp[i][j + 1], dp[i + 1][j]))\n\n    return dp[m][n]",
      "title": "1143. Longest Common Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33cf87e9-73ee-4a73-a66c-30ea484884a7",
      "code": "class Solution:\n  def movesToMakeZigzag(self, nums: list[int]) -> int:\n    decreasing = [0] * 2\n\n    for i, num in enumerate(nums):\n      l = nums[i - 1] if i > 0 else 1001\n      r = nums[i + 1] if i + 1 < len(nums) else 1001\n      decreasing[i % 2] += max(0, num - min(l, r) + 1)\n\n    return min(decreasing[0], decreasing[1])",
      "title": "1144. Decrease Elements To Make Array Zigzag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3c09290-2246-41f2-ae97-6ba3a1605145",
      "code": "class Solution:\n  def isMajorityElement(self, nums: list[int], target: int) -> bool:\n    n = len(nums)\n    i = bisect.bisect_left(nums, target)\n    return i + n // 2 < n and nums[i + n // 2] == target",
      "title": "1150. Check If a Number Is Majority Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b48ca71-cd5e-4082-8a47-ad9e33764946",
      "code": "class Solution:\n  def minSwaps(self, data: list[int]) -> int:\n    k = data.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i, num in enumerate(data):\n      if i >= k and data[i - k]:\n        ones -= 1\n      if num:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "1151. Minimum Swaps to Group All 1's Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c4c5678-7cce-4215-a569-d99a32664f40",
      "code": "class Solution:\n  def mostVisitedPattern(\n      self,\n      username: list[str],\n      timestamp: list[int],\n      website: list[str],\n  ) -> list[str]:\n    userToSites = collections.defaultdict(list)\n\n    # Sort websites of each user by timestamp.\n    for user, _, site in sorted(\n            zip(username, timestamp, website),\n            key=lambda x: x[1]):\n      userToSites[user].append(site)\n\n    # For each of three websites, count its frequency.\n    patternCount = collections.Counter()\n\n    for user, sites in userToSites.items():\n      patternCount.update(Counter(set(itertools.combinations(sites, 3))))\n\n    return max(sorted(patternCount), key=patternCount.get)",
      "title": "1152. Analyze User Website Visit Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4de0b521-0791-4993-8db4-5ba5ea585ed0",
      "code": "class Solution:\n  def canConvert(self, str1: str, str2: str) -> bool:\n    if str1 == str2:\n      return True\n\n    mappings = {}\n\n    for a, b in zip(str1, str2):\n      if mappings.get(a, b) != b:\n        return False\n      mappings[a] = b\n\n    # No letter in the str1 maps to > 1 letter in the str2 and there is at\n    # lest one temporary letter can break any loops.\n    return len(set(str2)) < 26",
      "title": "1153. String Transforms Into Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30ee9434-8a35-4556-a384-96b7204df931",
      "code": "class Solution:\n  def dayOfYear(self, date: str) -> int:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    year = int(date[:4])\n    month = int(date[5:7])\n    day = int(date[8:])\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    return sum(days[:month - 1]) + day",
      "title": "1154. Day of the Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bd612e3-d67c-4c62-872c-68da3ac0e12d",
      "code": "class Solution:\n  def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n    MOD = 1_000_000_007\n    dp = [1] + [0] * target\n\n    for _ in range(n):  # n dices\n      newDp = [0] * (target + 1)\n      for i in range(1, k + 1):  # numbers 1, 2, ..., f\n        for t in range(i, target + 1):  # all the possible targets\n          newDp[t] += dp[t - i]\n          newDp[t] %= MOD\n      dp = newDp\n\n    return dp[target]",
      "title": "1155. Number of Dice Rolls With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c513fd74-662a-47f4-93c9-31d011451777",
      "code": "class Solution:\n  def maxRepOpt1(self, text: str) -> int:\n    count = collections.Counter(text)\n    groups = [[c, len(list(group))]\n              for c, group in itertools.groupby(text)]\n    ans = max(min(length + 1, count[c]) for c, length in groups)\n\n    for i in range(1, len(groups) - 1):\n      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:\n        ans = max(\n            ans,\n            min(groups[i - 1][1] + groups[i + 1][1] + 1, count\n                [groups[i - 1][0]]))\n\n    return ans",
      "title": "1156. Swap For Longest Repeated Character Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c38ffbd-aa67-40b5-b106-07867c81533a",
      "code": "class Solution:\n  def countCharacters(self, words: list[str], chars: str) -> int:\n    ans = 0\n    count = collections.Counter(chars)\n\n    for word in words:\n      tempCount = count.copy()\n      for c in word:\n        tempCount[c] -= 1\n        if tempCount[c] < 0:\n          ans -= len(word)\n          break\n      ans += len(word)\n\n    return ans",
      "title": "1160. Find Words That Can Be Formed by Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31a8e825-a872-4feb-b867-0524d7f7c3e5",
      "code": "class Solution:\n  def maxLevelSum(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxLevelSum = -math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum > maxLevelSum:\n        maxLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "1161. Maximum Level Sum of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4cc2cff-865a-4279-b5fd-31016e7ced1c",
      "code": "class Solution:\n  def maxDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2  # Mark as visited.\n      d += 1\n\n    return ans",
      "title": "1162. As Far from Land as Possible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f5a77be-29ee-4884-ba4a-af989db9b6bd",
      "code": "class Solution:\n  def lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "1163. Last Substring in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cc1d581-3bbf-40ec-bcb5-a52203d940ec",
      "code": "class Solution:\n  def calculateTime(self, keyboard: str, word: str) -> int:\n    letterToIndex = {c: i for i, c in enumerate(keyboard)}\n    return (letterToIndex[word[0]] +\n            sum(abs(letterToIndex[a] - letterToIndex[b])\n            for a, b in itertools.pairwise(word)))",
      "title": "1165. Single-Row Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e09847c-afbf-491a-b58e-9adfef10eb55",
      "code": "class Solution:\n  def connectSticks(self, sticks: list[int]) -> int:\n    ans = 0\n    heapq.heapify(sticks)\n\n    while len(sticks) > 1:\n      x = heapq.heappop(sticks)\n      y = heapq.heappop(sticks)\n      ans += x + y\n      heapq.heappush(sticks, x + y)\n\n    return ans",
      "title": "1167. Minimum Cost to Connect Sticks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3d86a3b-01b7-49d4-8ed0-14314c91e838",
      "code": "class Solution:\n  def minCostToSupplyWater(\n      self,\n      n: int,\n      wells: list[int],\n      pipes: list[list[int]],\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n + 1)]\n    minHeap = []  # (d, u)\n\n    for u, v, w in pipes:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    # Connect virtual 0 with nodes 1 to n.\n    for i, well in enumerate(wells):\n      graph[0].append((i + 1, well))\n      heapq.heappush(minHeap, (well, i + 1))\n\n    mst = {0}\n\n    while len(mst) < n + 1:\n      d, u = heapq.heappop(minHeap)\n      if u in mst:\n        continue\n      # Add the new vertex.\n      mst.add(u)\n      ans += d\n      # Expand if possible.\n      for v, w in graph[u]:\n        if v not in mst:\n          heapq.heappush(minHeap, (w, v))\n\n    return ans",
      "title": "1168. Optimize Water Distribution in a Village",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db85d4ae-2fc5-4dc7-b1d5-e19681483043",
      "code": "class Solution:\n  def invalidTransactions(self, transactions: list[str]) -> list[str]:\n    ans = []\n    nameToTrans = collections.defaultdict(list)\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      nameToTrans[name].append({'time': time, 'city': city})\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      if amount > 1000:\n        ans.append(t)\n      elif name in nameToTrans:\n        for sameName in nameToTrans[name]:\n          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:\n            ans.append(t)\n            break\n\n    return ans",
      "title": "1169. Invalid Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ed57e95-1dd2-43cb-91c4-1b4c859b34ff",
      "code": "class Solution:\n  def numSmallerByFrequency(\n      self,\n      queries: list[str],\n      words: list[str],\n  ) -> list[int]:\n    ans = []\n    wordsFreq = sorted([word.count(min(word)) for word in words])\n\n    for q in queries:\n      count = q.count(min(q))\n      index = bisect.bisect(wordsFreq, count)\n      ans.append(len(words) - index)\n\n    return ans",
      "title": "1170. Compare Strings by Frequency of the Smallest Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdcb1455-79ba-4e08-acfe-1b0b447195a8",
      "code": "class Solution:\n  def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prefix = 0\n    prefixToNode = {0: dummy}\n\n    while head:\n      prefix += head.val\n      prefixToNode[prefix] = head\n      head = head.next\n\n    prefix = 0\n    head = dummy\n\n    while head:\n      prefix += head.val\n      head.next = prefixToNode[prefix].next\n      head = head.next\n\n    return dummy.next",
      "title": "1171. Remove Zero Sum Consecutive Nodes from Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ecc67e3-d78b-4006-9af5-31fe6b18a1f5",
      "code": "class Solution:\n  def numPrimeArrangements(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def factorial(n: int) -> int:\n      fact = 1\n      for i in range(2, n + 1):\n        fact = fact * i % MOD\n      return fact\n\n    count = self._countPrimes(n)\n    return factorial(count) * factorial(n - count) % MOD\n\n  def _countPrimes(self, n: int) -> int:\n    isPrime = [False] * 2 + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n + 1, i):\n          isPrime[j] = False\n    return sum(isPrime)",
      "title": "1175. Prime Arrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2871804b-4110-4e31-b3ca-3d8069124061",
      "code": "class Solution:\n  def dietPlanPerformance(\n      self,\n      calories: list[int],\n      k: int,\n      lower: int,\n      upper: int,\n  ) -> int:\n    ans = 0\n    summ = 0\n\n    for i, calorie in enumerate(calories):\n      summ += calorie\n      if i < k - 1:\n        continue\n      if i >= k:\n        summ -= calories[i - k]\n      if summ < lower:\n        ans -= 1\n      elif summ > upper:\n        ans += 1\n\n    return ans",
      "title": "1176. Diet Plan Performance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0add7aae-4c1d-4604-a1a3-05061e7d9a2f",
      "code": "class Solution:\n  def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\n    dp = [0] * (len(s) + 1)\n\n    for i in range(1, len(s) + 1):\n      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')\n\n    return [\n        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k\n        for left, right, k in queries\n    ]",
      "title": "1177. Can Make Palindrome from Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb7db5b4-d0ca-4cf8-b482-a0531fcf0db9",
      "code": "class Solution:\n  def findNumOfValidWords(\n      self,\n      words: list[str],\n      puzzles: list[str],\n  ) -> list[int]:\n    ans = []\n    binaryCount = collections.Counter()\n\n    for word in words:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      binaryCount[mask] += 1\n\n    for puzzle in puzzles:\n      valid = 0\n      n = len(puzzle) - 1\n      for i in range(1 << n):\n        mask = 1 << ord(puzzle[0]) - ord('a')\n        for j in range(n):\n          if i >> j & 1:\n            mask |= 1 << ord(puzzle[j + 1]) - ord('a')\n        if mask in binaryCount:\n          valid += binaryCount[mask]\n      ans.append(valid)\n\n    return ans",
      "title": "1178. Number of Valid Words for Each Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20758191-b984-47fd-8175-cdf6fdcd70e6",
      "code": "class Solution:\n  def countLetters(self, s: str) -> int:\n    ans = 0\n    dp = 0  # the length of the running letter\n    letter = '@'  # the running letter\n\n    for c in s:\n      if c == letter:\n        dp += 1\n      else:\n        dp = 1\n        letter = c\n      ans += dp  # Add the number of substrings ending in the current letter.\n\n    return ans",
      "title": "1180. Count Substrings with Only One Distinct Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9e7d9fd-3eb6-4cf1-bf49-57a29936f483",
      "code": "class Solution:\n  def shortestDistanceColor(\n      self,\n      colors: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    NUM_COLOR = 3\n    n = len(colors)\n    ans = []\n    # left[i][c] := the closest index of color c in index i to the left\n    left = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n    # right[i][c] := the closest index of color c in index i to the right\n    right = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # 0-indexed, -1 means N//A\n    for i, color in enumerate(colors):\n      colorToLatestIndex[color] = i\n      for c in range(1, NUM_COLOR + 1):\n        left[i][c] = colorToLatestIndex[c]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # Reset.\n    for i in range(n - 1, -1, -1):\n      colorToLatestIndex[colors[i]] = i\n      for c in range(1, NUM_COLOR + 1):\n        right[i][c] = colorToLatestIndex[c]\n\n    for i, c in queries:\n      leftDist = math.inf if left[i][c] == -1 else i - left[i][c]\n      rightDist = math.inf if right[i][c] == -1 else right[i][c] - i\n      minDist = min(leftDist, rightDist)\n      ans.append(-1 if minDist == math.inf else minDist)\n\n    return ans",
      "title": "1182. Shortest Distance to Target Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e625c29d-f8dc-4586-b9ec-4da33ac42b57",
      "code": "class Solution:\n  def maximumNumberOfOnes(\n      self,\n      width: int,\n      height: int,\n      sideLength: int,\n      maxOnes: int,\n  ) -> int:\n    subCount = []\n\n    def getCount(length: int, index: int) -> int:\n      return (length - index - 1) // sideLength + 1\n\n    for i in range(sideLength):\n      for j in range(sideLength):\n        subCount.append(getCount(width, i) * getCount(height, j))\n\n    return sum(sorted(subCount, reverse=True)[:maxOnes])",
      "title": "1183. Maximum Number of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2a2346b-ea53-4027-b580-de55fc025404",
      "code": "class Solution:\n  def distanceBetweenBusStops(\n      self,\n      distance: list[int],\n      start: int, destination: int,\n  ) -> int:\n    clockwise = 0\n    counterclockwise = 0\n\n    if start > destination:\n      start, destination = destination, start\n\n    for i, d in enumerate(distance):\n      if i >= start and i < destination:\n        clockwise += d\n      else:\n        counterclockwise += d\n\n    return min(clockwise, counterclockwise)",
      "title": "1184. Distance Between Bus Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8266f15a-eff5-4810-84d8-e41dd0ae0177",
      "code": "class Solution:\n  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    week = [\"Sunday\", \"Monday\", \"Tuesday\",\n            \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    count = 0\n\n    for i in range(1971, year):\n      count += 366 if i % 4 == 0 else 365\n    for i in range(month - 1):\n      count += days[i]\n    count += day\n\n    return week[(count + 4) % 7]",
      "title": "1185. Day of the Week",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b17c9f3e-e02c-415d-83bd-d38f0269e821",
      "code": "class Solution:\n  # Similar to 53. Maximum Subarray\n  def maximumSum(self, arr: list[int]) -> int:\n    # dp[0][i] := the maximum sum subarray ending in i (no deletion)\n    # dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)\n    dp = [[0] * len(arr) for _ in range(2)]\n\n    dp[0][0] = arr[0]\n    dp[1][0] = arr[0]\n    for i in range(1, len(arr)):\n      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i])\n      dp[1][i] = max(arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1])\n\n    return max(dp[1])",
      "title": "1186. Maximum Subarray Sum with One Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eccab6f2-ecb3-4ca4-ba3b-b5357bcf69a3",
      "code": "class Solution:\n  def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\n    # dp[i] := the minimum steps to reach i at previous round\n    dp = {-1: 0}\n\n    arr2.sort()\n\n    for a in arr1:\n      newDp = collections.defaultdict(lambda: math.inf)\n      for val, steps in dp.items():\n        # It's possible to use the value in the arr1.\n        if a > val:\n          newDp[a] = min(newDp[a], steps)\n        # Also try the value in the arr2.\n        i = bisect_right(arr2, val)\n        if i < len(arr2):\n          newDp[arr2[i]] = min(newDp[arr2[i]], steps + 1)\n      if not newDp:\n        return -1\n      dp = newDp\n\n    return min(dp.values())",
      "title": "1187. Make Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64131787-42be-4ddb-8174-3f3db1a612b1",
      "code": "class Solution:\n  def maxNumberOfBalloons(self, text: str) -> int:\n    count = collections.Counter(text)\n    return min(\n        count['b'],\n        count['a'],\n        count['l'] // 2, count['o'] // 2, count['n'])",
      "title": "1189. Maximum Number of Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61c2213f-d96b-401c-9363-67afb8d0d046",
      "code": "class Solution:\n  def reverseParentheses(self, s: str) -> str:\n    ans = []\n    stack = []\n    pair = {}\n\n    for i, c in enumerate(s):\n      if c == '(':\n        stack.append(i)\n      elif c == ')':\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\n    i = 0\n    d = 1\n    while i < len(s):\n      if s[i] in '()':\n        i = pair[i]\n        d = -d\n      else:\n        ans.append(s[i])\n      i += d\n\n    return ''.join(ans)",
      "title": "1190. Reverse Substrings Between Each Pair of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36a4d229-328c-4131-9102-6a6b0c453875",
      "code": "class Solution:\n  def kConcatenationMaxSum(self, arr: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    sz = len(arr) * (1 if k == 1 else 2)\n    summ = sum(arr)\n    # The concatenated array will be [arr1, arr2, ..., arrk].\n    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.\n    # Equivalently, maxSubarraySum is from arr1 and arrk.\n    if summ > 0 and k > 2:\n      return (self._kadane(arr, sz) + summ * (k - 2)) % MOD\n    return self._kadane(arr, sz) % MOD\n\n  def _kadane(self, arr: list[int], sz: int) -> int:\n    ans = 0\n    summ = 0\n    for i in range(sz):\n      a = arr[i % len(arr)]\n      summ = max(a, summ + a)\n      ans = max(ans, summ)\n    return ans",
      "title": "1191. K-Concatenation Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d548900a-20d1-4fb6-a67a-ee28ce3a2afa",
      "code": "class Solution:\n  def maxNumberOfApples(self, weight: list[int]) -> int:\n    summ = 0\n\n    for i, w in enumerate(sorted(weight)):\n      summ += w\n      if summ > 5000:\n        return i\n\n    return len(weight)",
      "title": "1196. How Many Apples Can You Put into the Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3715f540-b945-4df6-a925-382ad6c7cdc7",
      "code": "class Solution:\n  def smallestCommonElement(self, mat: list[list[int]]) -> int:\n    MAX = 10000\n    count = [0] * (MAX + 1)\n\n    for row in mat:\n      for a in row:\n        count[a] += 1\n        if count[a] == len(mat):\n          return a\n\n    return -1",
      "title": "1198. Find Smallest Common Element in All Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86830b51-15ce-4450-bd06-154ce8535620",
      "code": "class Solution:\n  def minBuildTime(self, blocks: list[int], split: int) -> int:\n    minHeap = blocks.copy()\n    heapify(minHeap)\n\n    while len(minHeap) > 1:\n      heapq.heappop(minHeap)  # the minimum\n      x = heapq.heappop(minHeap)  # the second minimum\n      heapq.heappush(minHeap, x + split)\n\n    return minHeap[0]",
      "title": "1199. Minimum Time to Build Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbcaa65e-ab7d-46b0-9284-9847fe1312bc",
      "code": "class Solution:\n  def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:\n    ans = []\n    mn = math.inf\n\n    arr.sort()\n\n    for a, b in itertools.pairwise(arr):\n      diff = b - a\n      if diff < mn:\n        mn = diff\n        ans = []\n      if diff == mn:\n        ans.append([a, b])\n\n    return ans",
      "title": "1200. Minimum Absolute Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52f9d66e-26ff-4b5f-a444-87826356044f",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * bc // math.gcd(a, bc)\n    return bisect.bisect_left(range(2 * 10**9), n,\n                              key=lambda m: m // a + m // b + m // c\n                              - m // ab - m // ac - m // bc\n                              + m // abc)",
      "title": "1201. Ugly Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2b228c7-844b-4c3c-b401-a38ba2d29b7f",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: list[list[int]]) -> str:\n    uf = UnionFind(len(s))\n    indexToLetters = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      indexToLetters[uf.find(i)].append(c)\n\n    for key in indexToLetters.keys():\n      indexToLetters[key].sort(reverse=True)\n\n    return ''.join(indexToLetters[uf.find(i)].pop()\n                   for i in range(len(s)))",
      "title": "1202. Smallest String With Swaps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "142f0135-2147-4fd0-a671-d48592f03ffe",
      "code": "class Solution:\n  def uniqueOccurrences(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n    occurrences = set()\n\n    for value in count.values():\n      if value in occurrences:\n        return False\n      occurrences.add(value)\n\n    return True",
      "title": "1207. Unique Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29518d77-a5f0-4c73-89ff-b48887712a16",
      "code": "class Solution:\n  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n    j = 0\n    for i in range(len(s)):\n      maxCost -= abs(ord(s[i]) - ord(t[i]))\n      if maxCost < 0:\n        maxCost += abs(ord(s[j]) - ord(t[j]))\n        j += 1\n\n    return len(s) - j",
      "title": "1208. Get Equal Substrings Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "940d5b59-cb61-45ac-a8b2-1af20ac5a61e",
      "code": "class Solution:\n  def removeDuplicates(self, s: str, k: int) -> str:\n    stack = []\n\n    for c in s:\n      if not stack or stack[-1][0] != c:\n        stack.append([c, 1])\n      else:  # stack[-1][0] == c\n        stack[-1][1] += 1\n        if stack[-1][1] == k:\n          stack.pop()\n\n    return ''.join(c * count for c, count in stack)",
      "title": "1209. Remove All Adjacent Duplicates in String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a010710e-7934-4a23-94fa-0e8aed25636b",
      "code": "from enum import IntEnum\n\n\nclass Pos(IntEnum):\n  HORIZONTAL = 0\n  VERTICAL = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # the state of (x, y, pos)\n    # pos := 0 (horizontal) / 1 (vertical)\n    q = collections.deque([(0, 0, Pos.HORIZONTAL)])\n    seen = {(0, 0, Pos.HORIZONTAL)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.HORIZONTAL:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.VERTICAL:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.HORIZONTAL and x + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x + 1][y])\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.VERTICAL and y + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x][y + 1])\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.HORIZONTAL:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.VERTICAL if pos == Pos.HORIZONTAL else Pos.HORIZONTAL\n        if ((canRotateClockwise(x, y, pos) or\n             canRotateCounterclockwise(x, y, pos)) and\n                (x, y, newPos) not in seen):\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1",
      "title": "1210. Minimum Moves to Reach Target with Rotations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abc84d85-26ad-4e98-9636-18d2b54a4da9",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def hasNext(self) -> bool:\n    return len(self.stack) > 0\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def twoSumBSTs(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n      target: int,\n  ) -> bool:\n    bst1 = BSTIterator(root1, True)\n    bst2 = BSTIterator(root2, False)\n\n    l = bst1.next()\n    r = bst2.next()\n    while True:\n      summ = l + r\n      if summ == target:\n        return True\n      if summ < target:\n        if not bst1.hasNext():\n          return False\n        l = bst1.next()\n      else:\n        if not bst2.hasNext():\n          return False\n        r = bst2.next()",
      "title": "1214. Two Sum BSTs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e62256b8-58fb-4143-9bee-9ff18fa2a554",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: int, high: int) -> list[int]:\n    ans = [0] if low == 0 else []\n    q = collections.deque(list(range(1, 10)))\n\n    while q:\n      curr = q.popleft()\n      if curr > high:\n        continue\n      if curr >= low:\n        ans.append(curr)\n      lastDigit = curr % 10\n      if lastDigit > 0:\n        q.append(curr * 10 + lastDigit - 1)\n      if lastDigit < 9:\n        q.append(curr * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1215. Stepping Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45e6007c-e989-458d-be77-55007a38877a",
      "code": "class Solution:\n  def isValidPalindrome(self, s: str, k: int) -> bool:\n    return len(s) - self._longestPalindromeSubseq(s) <= k\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1216. Valid Palindrome III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52c1c5be-0bbd-4f77-a57f-87e6897503f8",
      "code": "class Solution:\n  def minCostToMoveChips(self, position: list[int]) -> int:\n    count = [0, 0]\n    for p in position:\n      count[p % 2] += 1\n    return min(count[0], count[1])",
      "title": "1217. Play with Chips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca6fe059-b5ce-400b-a636-d910218f8925",
      "code": "class Solution:\n  def longestSubsequence(self, arr: list[int], difference: int) -> int:\n    ans = 0\n    lengthAt = {}\n\n    for a in arr:\n      lengthAt[a] = lengthAt.get(a - difference, 0) + 1\n      ans = max(ans, lengthAt[a])\n\n    return ans",
      "title": "1218. Longest Arithmetic Subsequence of Given Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f035219-3efe-49be-9ea1-2ef235597a4d",
      "code": "class Solution:\n  def getMaximumGold(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n\n      gold = grid[i][j]\n      grid[i][j] = 0  # Mark as visited.\n      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),\n                    dfs(i, j + 1), dfs(i, j - 1))\n      grid[i][j] = gold\n      return gold + maxPath\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "1219. Path with Maximum Gold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7911d27b-512b-4048-8e28-a2a5fea5a318",
      "code": "class Solution:\n  def countVowelPermutation(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}\n\n    for _ in range(n - 1):\n      newDp = {'a': dp['e'] + dp['i'] + dp['u'],\n               'e': dp['a'] + dp['i'],\n               'i': dp['e'] + dp['o'],\n               'o': dp['i'],\n               'u': dp['i'] + dp['o']}\n      dp = newDp\n\n    return sum(dp.values()) % MOD",
      "title": "1220. Count Vowels Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5cf328d-7e14-4b54-8a93-c95192c8e8ba",
      "code": "class Solution:\n  def queensAttacktheKing(self, queens: list[list[int]],\n                          king: list[int]) -> list[list[int]]:\n    ans = []\n    queens = {(i, j) for i, j in queens}\n\n    for d in [\n        [-1, -1],\n        [-1, 0],\n        [-1, 1],\n        [0, -1],\n        [0, 1],\n        [1, -1],\n        [1, 0],\n            [1, 1]]:\n      i = king[0] + d[0]\n      j = king[1] + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if (i, j) in queens:\n          ans.append([i, j])\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "1222. Queens That Can Attack the King",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94571053-be18-423f-b1a8-c382b0f706f8",
      "code": "class Solution:\n  def dieSimulator(self, n: int, rollMax: list[int]) -> int:\n    MAX_ROLLS = 15\n    MOD = 1_000_000_007\n\n    dp = [[[0] * (MAX_ROLLS + 1) for j in range(6)] for i in range(n + 1)]\n\n    for num in range(6):\n      dp[1][num][1] = 1\n\n    for i in range(2, n + 1):\n      for currNum in range(6):\n        for prevNum in range(6):\n          for k in range(1, 15 + 1):\n            if prevNum != currNum:\n              dp[i][currNum][1] = (\n                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % MOD\n            elif k < rollMax[currNum]:\n              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]\n\n    ans = 0\n\n    for num in range(6):\n      for k in range(1, 15 + 1):\n        ans += dp[n][num][k]\n\n    return ans % MOD",
      "title": "1223. Dice Roll Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec8c95dd-0680-4453-a50a-7c658a0b8498",
      "code": "class Solution:\n  def maxEqualFreq(self, nums: list[int]) -> int:\n    ans = 0\n    maxFreq = 0\n    count = collections.Counter()\n    freq = collections.Counter()\n\n    for i, num in enumerate(nums):\n      freq[count[num]] -= 1\n      count[num] += 1\n      freq[count[num]] += 1\n      maxFreq = max(maxFreq, count[num])\n      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (\n              freq[maxFreq - 1] + 1) == i:\n        ans = i + 1\n\n    return ans",
      "title": "1224. Maximum Equal Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98a66bd7-b274-4c8e-842c-e910592cc69a",
      "code": "class Solution:\n  def nthPersonGetsNthSeat(self, n: int) -> float:\n    return 1 if n == 1 else 0.5",
      "title": "1227. Airplane Seat Assignment Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf100d8d-35fc-4097-9c62-140aa13f406d",
      "code": "class Solution:\n  def missingNumber(self, arr: list[int]) -> int:\n    n = len(arr)\n    delta = (arr[-1] - arr[0]) // n\n    l = 0\n    r = n - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] == arr[0] + m * delta:\n        l = m + 1\n      else:\n        r = m\n\n    return arr[0] + l * delta",
      "title": "1228. Missing Number In Arithmetic Progression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06707e8c-ff14-4bf5-a970-3673833b8369",
      "code": "class Solution:\n  def minAvailableDuration(\n      self,\n      slots1: list[list[int]],\n      slots2: list[list[int]],\n      duration: int,\n  ) -> list[int]:\n    slots1.sort()\n    slots2.sort()\n\n    i = 0  # slots1's index\n    j = 0  # slots2's index\n\n    while i < len(slots1) and j < len(slots2):\n      start = max(slots1[i][0], slots2[j][0])\n      end = min(slots1[i][1], slots2[j][1])\n      if start + duration <= end:\n        return [start, start + duration]\n      if slots1[i][1] < slots2[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return []",
      "title": "1229. Meeting Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5eda457-bc29-412f-9a30-7fdde6f9bf21",
      "code": "class Solution:\n  def probabilityOfHeads(self, prob: list[float], target: int) -> float:\n    # dp[i][j] := the probability of tossing the first i coins with j heads\n    dp = [[0] * (target + 1) for _ in range(len(prob) + 1)]\n    dp[0][0] = 1.0\n\n    for i in range(1, len(prob) + 1):\n      for j in range(target + 1):\n        dp[i][j] = ((dp[i - 1][j - 1] * prob[i - 1] if j > 0 else 0) +\n                    dp[i - 1][j] * (1 - prob[i - 1]))\n\n    return dp[len(prob)][target]",
      "title": "1230. Toss Strange Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6e514a3-2aba-428a-a16b-1eb18aae294d",
      "code": "class Solution:\n  def maximizeSweetness(self, sweetness: list[int], k: int) -> int:\n    l = len(sweetness) // (k + 1)\n    r = sum(sweetness) // (k + 1)\n\n    def canEat(m: int) -> bool:\n      \"\"\"\n      Returns True if can eat m sweetness (the minimum sweetness of each piece).\n      \"\"\"\n      pieces = 0\n      summ = 0  # the running sum\n      for s in sweetness:\n        summ += s\n        if summ >= m:\n          pieces += 1\n          summ = 0\n      return pieces > k\n\n    while l < r:\n      m = (l + r) // 2\n      if canEat(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l if canEat(l) else l - 1",
      "title": "1231. Divide Chocolate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "043f2dc0-209a-40dc-9f97-f7de62aef24e",
      "code": "class Solution:\n  def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\n    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]\n    dx = x1 - x0\n    dy = y1 - y0\n\n    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)",
      "title": "1232. Check If It Is a Straight Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a1fb82a-51ee-4cdd-b9a1-d59ffa81eb51",
      "code": "class Solution:\n  def removeSubfolders(self, folder: list[str]) -> list[str]:\n    ans = []\n    prev = \"\"\n\n    folder.sort()\n\n    for f in folder:\n      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':\n        continue\n      ans.append(f)\n      prev = f\n\n    return ans",
      "title": "1233. Remove Sub-Folders from the Filesystem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00b746ea-6dbb-4609-9c51-9d7695ce35c4",
      "code": "class Solution:\n  def balancedString(self, s: str) -> int:\n    ans = len(s)\n    count = collections.Counter(s)\n    j = 0\n\n    for i, c in enumerate(s):\n      count[c] -= 1\n      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):\n        ans = min(ans, i - j + 1)\n        count[s[j]] += 1\n        j += 1\n\n    return ans",
      "title": "1234. Replace the Substring for Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08fd3126-6c0c-403c-a4b5-84c3005034c8",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    maxProfit = 0\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n    minHeap = []  # (endTime, profit)\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    for s, e, p in jobs:\n      while minHeap and s >= minHeap[0][0]:\n        maxProfit = max(maxProfit, heapq.heappop(minHeap)[1])\n      heapq.heappush(minHeap, (e, p + maxProfit))\n\n    return max(maxProfit, max(p for _, p in minHeap))",
      "title": "1235. Maximum Profit in Job Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dff1552-4f5c-4e30-915e-a814d3b65243",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the maximum profit to schedule jobs[i..n).\"\"\"\n      if i == len(startTime):\n        return 0\n      j = bisect.bisect_left(startTime, jobs[i][1])\n      return max(jobs[i][2] + dp(j), dp(i + 1))\n\n    return dp(0)",
      "title": "1235. Maximum Profit in Job Scheduling_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abdc4344-69d8-48a5-938c-32a0acc91b29",
      "code": "# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class HtmlParser(object):\n#   def getUrls(self, url: str) -> list[str]:\n\nclass Solution:\n  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> list[str]:\n    q = collections.deque([startUrl])\n    seen = {startUrl}\n    hostname = startUrl.split('/')[2]\n\n    while q:\n      currUrl = q.popleft()\n      for url in htmlParser.getUrls(currUrl):\n        if url in seen:\n          continue\n        if hostname in url:\n          q.append(url)\n          seen.add(url)\n\n    return seen",
      "title": "1236. Web Crawler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2124b53-6eb7-46ea-a953-f8030e5f61ef",
      "code": "class Solution:\n  def findSolution(self, customfunction: 'CustomFunction', z: int) -> list[list[int]]:\n    ans = []\n    x = 1\n    y = 1000\n\n    while x <= 1000 and y >= 1:\n      f = customfunction.f(x, y)\n      if f < z:\n        x += 1\n      elif f > z:\n        y -= 1\n      else:\n        ans.append([x, y])\n        x += 1\n        y -= 1\n\n    return ans",
      "title": "1237. Find Positive Integer Solution for a Given Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cb404ea-6664-486c-b5b7-991ae2e6a09e",
      "code": "class Solution:\n  def circularPermutation(self, n: int, start: int) -> list[int]:\n    return [start ^ i ^ i >> 1 for i in range(1 << n)]",
      "title": "1238. Circular Permutation in Binary Representation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd660af8-1d91-46ec-a8e0-d532c757bf32",
      "code": "class Solution:\n  def tilingRectangle(self, n: int, m: int) -> int:\n    @functools.lru_cache(None)\n    def dp(heights: int) -> int:\n      minHeight = min(heights)\n      if minHeight == n:  # All filled.\n        return 0\n\n      ans = m * n\n      heightsList = list(heights)\n      start = heightsList.index(minHeight)\n\n      # Try to put square of different size that doesn't exceed the width/height.\n      for sz in range(1, min(m - start + 1, n - minHeight + 1)):\n        # heights[start..start + sz) must has the same height.\n        if heights[start + sz - 1] != minHeight:\n          break\n        # Put a square of size `sz` to cover heights[start..start + sz).\n        heightslist[start:start + sz] = [minHeight + sz] * sz\n        ans = min(ans, dp(tuple(heightsList)))\n\n      return 1 + ans\n\n    return dp(tuple([0] * m))",
      "title": "1240. Tiling a Rectangle with the Fewest Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3b7faf0-4a65-45f6-8b65-09d0bd4be97f",
      "code": "class Solution:\n  def transformArray(self, arr: list[int]) -> list[int]:\n    if len(arr) < 3:\n      return arr\n\n    ans = []\n\n    while ans != arr:\n      ans = arr[:]\n      for i in range(1, len(arr) - 1):\n        if ans[i - 1] > ans[i] < ans[i + 1]:\n          arr[i] += 1\n        elif ans[i - 1] < ans[i] > ans[i + 1]:\n          arr[i] -= 1\n\n    return ans",
      "title": "1243. Array Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aa9c528-ba60-4a00-b845-8948712b4c24",
      "code": "class Solution:\n  def minimumMoves(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]\n    dp = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for i in range(n - 1):\n      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2\n\n    for d in range(2, n):\n      for i in range(n - d):\n        j = i + d\n        # Remove arr[i] and arr[j] within the move of removing\n        # arr[i + 1..j - 1]\n        if arr[i] == arr[j]:\n          dp[i][j] = dp[i + 1][j - 1]\n        # Try all the possible partitions.\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    return dp[0][n - 1]",
      "title": "1246. Palindrome Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b37c5ec-a739-452e-88ed-af41b1280d63",
      "code": "class Solution:\n  def minimumSwap(self, s1: str, s2: str) -> int:\n    # ('xx', 'yy') = (2 'xy's) . 1 swap\n    # ('yy', 'xx') = (2 'yx's) . 1 swap\n    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps\n    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'\n    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'\n\n    for a, b in zip(s1, s2):\n      if a == b:\n        continue\n      if a == 'x':\n        xy += 1\n      else:\n        yx += 1\n\n    if (xy + yx) % 2 == 1:\n      return -1\n    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)",
      "title": "1247. Minimum Swaps to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79ebf640-5432-4b28-9a60-a909b9d944f8",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int], k: int) -> int:\n    def numberOfSubarraysAtMost(k: int) -> int:\n      ans = 0\n      l = 0\n      r = 0\n\n      while r <= len(nums):\n        if k >= 0:\n          ans += r - l\n          if r == len(nums):\n            break\n          if nums[r] & 1:\n            k -= 1\n          r += 1\n        else:\n          if nums[l] & 1:\n            k += 1\n          l += 1\n      return ans\n\n    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)",
      "title": "1248. Count Number of Nice Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "842a81fb-92f4-45d4-9a66-4dc710c1dca0",
      "code": "class Solution:\n  def minRemoveToMakeValid(self, s: str) -> str:\n    stack = []  # unpaired '(' indices\n    chars = list(s)\n\n    for i, c in enumerate(chars):\n      if c == '(':\n        stack.append(i)  # Record the unpaired '(' index.\n      elif c == ')':\n        if stack:\n          stack.pop()  # Find a pair\n        else:\n          chars[i] = '*'  # Mark the unpaired ')' as '*'.\n\n    # Mark the unpaired '(' as '*'.\n    while stack:\n      chars[stack.pop()] = '*'\n\n    return ''.join(chars).replace('*', '')",
      "title": "1249. Minimum Remove to Make Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc36596d-bc81-497a-aa97-46b231e9a33d",
      "code": "class Solution:\n  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:\n    # rows[i] and cols[i] :=\n    #   1. True (flipped even times)\n    #   2. False (flipped odd times)\n    rows = [False] * m\n    cols = [False] * n\n\n    for r, c in indices:\n      rows[r] ^= True\n      cols[c] ^= True\n\n    oddRowsCount = rows.count(True)\n    oddColsCount = cols.count(True)\n    evenRowsCount = m - oddRowsCount\n    evenColsCount = n - oddColsCount\n    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount",
      "title": "1252. Cells with Odd Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b73656dc-ffe8-481a-8c1b-6ed6f4a8c942",
      "code": "class Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: list[int]) -> list[list[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans",
      "title": "1253. Reconstruct a 2-Row Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0432042-8583-4983-afbe-7abc0a86c0f8",
      "code": "class Solution:\n  def closedIsland(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    # Remove the lands connected to the edge.\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    # Reduce to 200. Number of Islands\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "1254. Number of Closed Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38c7d5e6-6545-45d7-8895-f05d3435cc71",
      "code": "class Solution:\n  def maxScoreWords(\n      self,\n      words: list[str],\n      letters: list[str],\n      score: list[int],\n  ) -> int:\n    count = collections.Counter(letters)\n\n    def useWord(i: int) -> int:\n      isValid = True\n      earned = 0\n      for c in words[i]:\n        count[c] -= 1\n        if count[c] < 0:\n          isValid = False\n        earned += score[ord(c) - ord('a')]\n      return earned if isValid else -1\n\n    def unuseWord(i: int) -> None:\n      for c in words[i]:\n        count[c] += 1\n\n    def dfs(s: int) -> int:\n      \"\"\"Returns the maximum score you can get from words[s..n).\"\"\"\n      ans = 0\n      for i in range(s, len(words)):\n        earned = useWord(i)\n        if earned > 0:\n          ans = max(ans, earned + dfs(i + 1))\n        unuseWord(i)\n      return ans\n\n    return dfs(0)",
      "title": "1255. Maximum Score Words Formed by Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "627f0e55-5862-43d5-8cec-f4f34f6ed0da",
      "code": "class Solution:\n  def encode(self, num: int) -> str:\n    return bin(num + 1)[3:]",
      "title": "1256. Encode Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64c601f6-1ba1-447d-ad54-3e8646260437",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def generateSentences(\n      self,\n      synonyms: list[list[str]],\n      text: str,\n  ) -> list[str]:\n    ans = SortedSet()\n    graph = collections.defaultdict(list)\n    q = collections.deque([text])\n\n    for s, t in synonyms:\n      graph[s].append(t)\n      graph[t].append(s)\n\n    while q:\n      u = q.popleft()\n      ans.add(u)\n      words = u.split()\n      for i, word in enumerate(words):\n        for synonym in graph[word]:\n          # Replace words[i] with its synonym.\n          words[i] = synonym\n          newText = ' '.join(words)\n          if newText not in ans:\n            q.append(newText)\n\n    return list(ans)",
      "title": "1258. Synonymous Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68760700-5cca-4510-bbc4-31b1c71f4cbe",
      "code": "class Solution:\n  def numberOfWays(self, numPeople: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways i handshakes could occure s.t. none of the\n    # handshakes cross\n    dp = [1] + [0] * (numPeople // 2)\n\n    for i in range(1, numPeople // 2 + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - 1 - j]\n        dp[i] %= MOD\n\n    return dp[numPeople // 2]",
      "title": "1259. Handshakes That Don't Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87d3744d-3738-4a85-b893-d8af65231075",
      "code": "class Solution:\n  def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    k %= m * n\n\n    for i in range(m):\n      for j in range(n):\n        index = (i * n + j + k) % (m * n)\n        x = index // n\n        y = index % n\n        ans[x][y] = grid[i][j]\n\n    return ans",
      "title": "1260. Shift 2D Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fd51207-0e09-4013-9447-a7f37396f068",
      "code": "class Solution:\n  def minPushBox(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 'B':\n          box = (i, j)\n        elif grid[i][j] == 'S':\n          player = (i, j)\n        elif grid[i][j] == 'T':\n          target = (i, j)\n\n    def isInvalid(playerX: int, playerY: int) -> bool:\n      return (playerX < 0 or playerX == m or playerY < 0 or playerY == n or\n              grid[playerX][playerY] == '#')\n\n    def canGoTo(\n        playerX: int,\n        playerY: int,\n        fromX: int,\n        fromY: int,\n        boxX: int,\n        boxY: int\n    ) -> bool:\n      \"\"\"Returns True if (playerX, playerY) can go to (fromX, fromY).\"\"\"\n      q = collections.deque([(playerX, playerY)])\n      seen = {(playerX, playerY)}\n\n      while q:\n        i, j = q.popleft()\n        if i == fromX and j == fromY:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if isInvalid(x, y):\n            continue\n          if (x, y) in seen:\n            continue\n          if x == boxX and y == boxY:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    # (boxX, boxY, playerX, playerY)\n    q = collections.deque([(box[0], box[1], player[0], player[1])])\n    seen = {(box[0], box[1], player[0], player[1])}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        boxX, boxY, playerX, playerY = q.popleft()\n        if boxX == target[0] and boxY == target[1]:\n          return step\n        for k, (dx, dy) in enumerate(DIRS):\n          nextBoxX = boxX + dx\n          nextBoxY = boxY + dy\n          if isInvalid(nextBoxX, nextBoxY):\n            continue\n          if (nextBoxX, nextBoxY, boxX, boxY) in seen:\n            continue\n          fromX = boxX + DIRS[(k + 2) % 4][0]\n          fromY = boxY + DIRS[(k + 2) % 4][1]\n          if isInvalid(fromX, fromY):\n            continue\n          if canGoTo(playerX, playerY, fromX, fromY, boxX, boxY):\n            q.append((nextBoxX, nextBoxY, boxX, boxY))\n            seen.add((nextBoxX, nextBoxY, boxX, boxY))\n      step += 1\n\n    return -1",
      "title": "1263. Minimum Moves to Move a Box to Their Target Location",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f134845-f77f-4b3f-bc71-f59a095cc111",
      "code": "class Solution:\n  def minTimeToVisitAllPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(1, len(points)):\n      ans += max(abs(points[i][0] - points[i - 1][0]),\n                 abs(points[i][1] - points[i - 1][1]))\n\n    return ans",
      "title": "1266. Minimum Time Visiting All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15aedb80-28f3-4994-a48e-2ead6618e99b",
      "code": "class Solution:\n  def countServers(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans",
      "title": "1267. Count Servers that Communicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d46ff460-031e-4b5e-a931-f8ab5ec8f1b5",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def suggestedProducts(\n      self,\n      products: list[str],\n      searchWord: str\n  ) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    def search(node: TrieNode | None) -> list[str]:\n      res: list[str] = []\n      dfs(node, res)\n      return res\n\n    def dfs(node: TrieNode | None, res: list[str]) -> None:\n      if len(res) == 3:\n        return\n      if not node:\n        return\n      if node.word:\n        res.append(node.word)\n      for c in string.ascii_lowercase:\n        if c in node.children:\n          dfs(node.children[c], res)\n\n    for product in products:\n      insert(product)\n\n    node = root\n\n    for c in searchWord:\n      if not node or c not in node.children:\n        node = None\n        ans.append([])\n        continue\n      node = node.children[c]\n      ans.append(search(node))\n\n    return ans",
      "title": "1268. Search Suggestions System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bc96dac-556e-47a2-aaaa-ec5ffb665df0",
      "code": "class Solution:\n  def numWays(self, steps: int, arrLen: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to stay at index i\n    dp = [0] * min(steps // 2 + 1, arrLen)\n    dp[0] = 1\n\n    for _ in range(steps):\n      newDp = [0] * min(steps // 2 + 1, arrLen)\n      for i, ways in enumerate(dp):\n        if ways > 0:\n          for dx in (-1, 0, 1):\n            nextIndex = i + dx\n            if 0 <= nextIndex < len(dp):\n              newDp[nextIndex] += ways\n              newDp[nextIndex] %= MOD\n      dp = newDp\n\n    return dp[0]",
      "title": "1269. Number of Ways to Stay in the Same Place After Some Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d5cba2e-414a-49f6-a685-5d7d397c2a67",
      "code": "class Solution:\n  def toHexspeak(self, num: str) -> str:\n    s = hex(int(num)).upper()[2:].translate(str.maketrans('01', 'OI'))\n    return 'ERROR' if any(c.isdigit() for c in s) else s",
      "title": "1271. Hexspeak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24029b15-09c2-4e01-a530-6b97e837393a",
      "code": "class Solution:\n  def removeInterval(self, intervals: list[list[int]],\n                     toBeRemoved: list[int]) -> list[list[int]]:\n    ans = []\n\n    for a, b in intervals:\n      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:\n        ans.append([a, b])\n      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]\n        if a < toBeRemoved[0]:\n          ans.append([a, toBeRemoved[0]])\n        if b > toBeRemoved[1]:\n          ans.append([toBeRemoved[1], b])\n\n    return ans",
      "title": "1272. Remove Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "623fedf5-8bdf-41ea-8b5b-c61405b6d3e7",
      "code": "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Sea(object):\n#   def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#     pass\n#\n# class Point(object):\n# def __init__(self, x: int, y: int):\n# self.x = x\n# self.y = y\n\nclass Solution(object):\n  def countShips(\n      self,\n      sea: 'Sea',\n      topRight: 'Point',\n      bottomLeft: 'Point',\n  ) -> int:\n    if topRight.x < bottomLeft.x or topRight.y < bottomLeft.y:\n      return 0\n    if not sea.hasShips(topRight, bottomLeft):\n      return 0\n\n    # sea.hashShips(topRight, bottomLeft) == True\n    if topRight.x == bottomLeft.x and topRight.y == bottomLeft.y:\n      return 1\n\n    mx = (topRight.x + bottomLeft.x) // 2\n    my = (topRight.y + bottomLeft.y) // 2\n    ans = 0\n    # the top-right\n    ans += self.countShips(sea, topRight, Point(mx + 1, my + 1))\n    # the bottom-right\n    ans += self.countShips(sea, Point(topRight.x, my),\n                           Point(mx + 1, bottomLeft.y))\n    # the top-left\n    ans += self.countShips(sea, Point(mx, topRight.y),\n                           Point(bottomLeft.x, my + 1))\n    # the bottom-left\n    ans += self.countShips(sea, Point(mx, my), bottomLeft)\n    return ans",
      "title": "1274. Number of Ships in a Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4809d14-8ace-476b-a075-39a6c8538fe0",
      "code": "class Solution:\n  def tictactoe(self, moves: list[list[int]]) -> str:\n    row = [[0] * 3 for _ in range(2)]\n    col = [[0] * 3 for _ in range(2)]\n    diag1 = [0] * 2\n    diag2 = [0] * 2\n    i = 0\n\n    for r, c in moves:\n      row[i][r] += 1\n      col[i][c] += 1\n      diag1[i] += r == c\n      diag2[i] += r + c == 2\n      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):\n        return 'A' if i == 0 else 'B'\n      i ^= 1\n\n    return 'Draw' if len(moves) == 9 else 'Pending'",
      "title": "1275. Find Winner on a Tic Tac Toe Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d42a8c98-ad18-4aaa-a7df-270f93edb5c8",
      "code": "class Solution:\n  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> list[int]:\n    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:\n      return []\n\n    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2\n\n    return [jumboBurgers, cheeseSlices - jumboBurgers]",
      "title": "1276. Number of Burgers with No Waste of Ingredients",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "992324a5-68c3-448d-9c46-16009a6123aa",
      "code": "class Solution:\n  def countSquares(self, matrix: list[list[int]]) -> int:\n    for i in range(len(matrix)):\n      for j in range(len(matrix[0])):\n        if matrix[i][j] == 1 and i > 0 and j > 0:\n          matrix[i][j] += min(matrix[i - 1][j - 1],\n                              matrix[i - 1][j], matrix[i][j - 1])\n    return sum(map(sum, matrix))",
      "title": "1277. Count Square Submatrices with All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "655ce6ac-6422-4d4f-8110-7fe610941720",
      "code": "class Solution:\n  def subtractProductAndSum(self, n: int) -> int:\n    prod = 1\n    summ = 0\n\n    while n > 0:\n      prod *= n % 10\n      summ += n % 10\n      n //= 10\n\n    return prod - summ",
      "title": "1281. Subtract the Product and Sum of Digits of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e446f98-e55a-4d96-bc13-d04949b449b0",
      "code": "class Solution:\n  def groupThePeople(self, groupSizes: list[int]) -> list[list[int]]:\n    ans = []\n    groupSizeToIndices = defaultdict(list)\n\n    for i, groupSize in enumerate(groupSizes):\n      groupSizeToIndices[groupSize].append(i)\n\n    for groupSize, indices in groupSizeToIndices.items():\n      groupIndices = []\n      for index in indices:\n        groupIndices.append(index)\n        if len(groupIndices) == groupSize:\n          ans.append(groupIndices.copy())\n          groupIndices.clear()\n\n    return ans",
      "title": "1282. Group the People Given the Group Size They Belong To",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4ecf6f8-59ff-49e3-931d-882a923f0fd6",
      "code": "class Solution:\n  def smallestDivisor(self, nums: list[int], threshold: int) -> int:\n    l = 1\n    r = max(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if sum((num - 1) // m + 1 for num in nums) <= threshold:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "1283. Find the Smallest Divisor Given a Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "451b1d2b-a6bc-47db-a68a-a0f833097c30",
      "code": "class Solution:\n  def minFlips(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            # Flie the four neighbors.\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: list[list[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash",
      "title": "1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a79da00-e722-46c3-b2f5-ea9585dea338",
      "code": "class Solution:\n  def findSpecialInteger(self, arr: list[int]) -> int:\n    n = len(arr)\n    quarter = n // 4\n\n    for i in range(n - quarter):\n      if arr[i] == arr[i + quarter]:\n        return arr[i]",
      "title": "1287. Element Appearing More Than 25% In Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6929ec96-c7b2-4582-a685-df0b9b7b0a94",
      "code": "class Solution:\n  def removeCoveredIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = 0\n\n    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):\n      # The current interval is not covered by the previous one.\n      if prevEnd < end:\n        prevEnd = end\n        ans += 1\n\n    return ans",
      "title": "1288. Remove Covered Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f50f5686-bfb3-4f73-ac0c-b86484b22927",
      "code": "class Solution:\n  def minFallingPathSum(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n\n    for i in range(1, n):\n      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(\n          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]\n      for j in range(n):\n        if j == firstMinIndex:\n          grid[i][j] += secondMinNum\n        else:\n          grid[i][j] += firstMinNum\n\n    return min(grid[-1])",
      "title": "1289. Minimum Falling Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f22608c0-aa74-46b5-8632-36e79287bd03",
      "code": "class Solution:\n  def getDecimalValue(self, head: ListNode) -> int:\n    ans = 0\n\n    while head:\n      ans = ans * 2 + head.val\n      head = head.next\n\n    return ans",
      "title": "1290. Convert Binary Number in a Linked List to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91e6f998-847b-4dcd-be8d-8484cc99abdd",
      "code": "class Solution:\n  def sequentialDigits(self, low: int, high: int) -> list[int]:\n    ans = []\n    q = collections.deque([num for num in range(1, 10)])\n\n    while q:\n      num = q.popleft()\n      if num > high:\n        return ans\n      if low <= num and num <= high:\n        ans.append(num)\n      lastDigit = num % 10\n      if lastDigit < 9:\n        q.append(num * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1291. Sequential Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58661dd9-499c-499b-87f6-2e2bbb17ab4e",
      "code": "class Solution:\n  def maxSideLength(self, mat: list[list[int]], threshold: int) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:\n      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]\n\n    for i in range(m):\n      for j in range(n):\n        for length in range(ans, min(m - i, n - j)):\n          if squareSum(i, j, i + length, j + length) > threshold:\n            break\n          ans = max(ans, length + 1)\n\n    return ans",
      "title": "1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63319cb1-8613-4104-9784-ba582934e0fc",
      "code": "class Solution:\n  def shortestPath(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    step = 0\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return step\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1",
      "title": "1293. Shortest Path in a Grid with Obstacles Elimination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d252b26-61f6-4f70-b8a5-e6cbe98fda58",
      "code": "class Solution:\n  def findNumbers(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if 9 < num < 100 or 999 < num < 10000 or num == 100000:\n        ans += 1\n\n    return ans",
      "title": "1295. Find Numbers with Even Number of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26be8809-b8c3-48e3-ae20-ed3460132e55",
      "code": "class Solution:\n  def isPossibleDivide(self, nums: list[int], k: int) -> bool:\n    count = collections.Counter(nums)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + k):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "1296. Divide Array in Sets of K Consecutive Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a170b773-08d6-4154-944e-a8fe98a85a09",
      "code": "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    # Greedily consider strings with `minSize`, so ignore `maxSize`.\n    ans = 0\n    letters = 0\n    count = collections.Counter()\n    substringCount = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        letters += 1\n      while letters > maxLetters or r - l + 1 > minSize:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          letters -= 1\n        l += 1\n      if r - l + 1 == minSize:\n        sub = s[l:l + minSize]\n        substringCount[sub] += 1\n        ans = max(ans, substringCount[sub])\n\n    return ans",
      "title": "1297. Maximum Number of Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ebda2ab-1198-43a5-9d33-4129f799f930",
      "code": "class Solution:\n  def maxCandies(\n      self,\n      status: list[int],\n      candies: list[int],\n      keys: list[list[int]],\n      containedBoxes: list[list[int]],\n      initialBoxes: list[int],\n  ) -> int:\n    ans = 0\n    q = collections.deque()\n    reachedClosedBoxes = [0] * len(status)\n\n    def pushBoxesIfPossible(boxes: list[int]) -> None:\n      for box in boxes:\n        if status[box]:\n          q.append(box)\n        else:\n          reachedClosedBoxes[box] = True\n\n    pushBoxesIfPossible(initialBoxes)\n\n    while q:\n      currBox = q.popleft()\n\n      # Add the candies.\n      ans += candies[currBox]\n\n      # Push `reachedClosedBoxes` by `key` obtained in this turn and change\n      # their statuses.\n      for key in keys[currBox]:\n        if not status[key] and reachedClosedBoxes[key]:\n          q.append(key)\n        status[key] = 1  # boxes[key] is now open\n\n      # Push the boxes contained in `currBox`.\n      pushBoxesIfPossible(containedBoxes[currBox])\n\n    return ans",
      "title": "1298. Maximum Candies You Can Get from Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05017b7e-0430-4fc2-8579-e2b09d796099",
      "code": "class Solution:\n  def replaceElements(self, arr: list[int]) -> list[int]:\n    maxOfRight = -1\n    for i in reversed(range(len(arr))):\n      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])\n    return arr",
      "title": "1299. Replace Elements with Greatest Element on Right Side",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f41b0de-1e97-4b22-8285-1b00dffaf510",
      "code": "class Solution:\n  def findBestValue(self, arr: list[int], target: int) -> int:\n    prefix = 0\n\n    arr.sort()\n\n    for i, a in enumerate(arr):\n      ans = round((target - prefix) / (len(arr) - i))\n      if ans <= a:\n        return ans\n      prefix += a\n\n    return arr[-1]",
      "title": "1300. Sum of Mutated Array Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c6c1dcb-9386-4773-9a12-8293e8f2c48b",
      "code": "class Solution:\n  def pathsWithMaxScore(self, board: list[str]) -> list[int]:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (1, 1))\n    n = len(board)\n    # dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    # count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to\n    # (i, j)\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= MOD\n\n        # If there's path(s) from 'S' to (i, j) and the cell is not 'E'.\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= MOD\n\n    return [dp[0][0], count[0][0]]",
      "title": "1301. Number of Paths with Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed0a24b1-2058-48bb-8ace-fe64db2bc0db",
      "code": "class Solution:\n  def sumZero(self, n: int) -> list[int]:\n    return list(range(1 - n, n, 2))",
      "title": "1304. Find N Unique Integers Sum up to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2081cb77-b318-4b28-874c-46cf7c4f6a64",
      "code": "class Solution:\n  def isSolvable(self, words: list[str], result: str) -> bool:\n    words.append(result)\n    rows = len(words)\n    cols = max(map(len, words))\n    letterToDigit = {}\n    usedDigit = [False] * 10\n\n    def dfs(row: int, col: int, summ: int) -> bool:\n      if col == cols:\n        return summ == 0\n      if row == rows:\n        return summ % 10 == 0 and dfs(0, col + 1, summ // 10)\n\n      word = words[row]\n      if col >= len(word):\n        return dfs(row + 1, col, summ)\n\n      letter = word[~col]\n      sign = -1 if row == rows - 1 else 1\n\n      if letter in letterToDigit and (\n              letterToDigit[letter] > 0 or col < len(word) - 1):\n        return dfs(row + 1, col, summ + sign * letterToDigit[letter])\n\n      for digit, used in enumerate(usedDigit):\n        if not used and (digit > 0 or col < len(word) - 1):\n          letterToDigit[letter] = digit\n          usedDigit[digit] = True\n          if dfs(row + 1, col, summ + sign * digit):\n            return True\n          usedDigit[digit] = False\n          if letter in letterToDigit:\n            del letterToDigit[letter]\n\n      return False\n\n    return dfs(0, 0, 0)",
      "title": "1307. Verbal Arithmetic Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06b41619-52d1-4673-b581-a20ae9fef2e0",
      "code": "class Solution:\n  def freqAlphabets(self, s: str) -> str:\n    ans = ''\n    i = 0\n\n    while i < len(s):\n      if i + 2 < len(s) and s[i + 2] == '#':\n        ans += chr(int(s[i:i + 2]) + ord('a') - 1)\n        i += 3\n      else:\n        ans += chr(int(s[i]) + ord('a') - 1)\n        i += 1\n\n    return ans",
      "title": "1309. Decrypt String from Alphabet to Integer Mapping",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79a9339b-2e5e-4776-9354-098e831a0b6d",
      "code": "class Solution:\n  def xorQueries(self, arr: list[int], queries: list[list[int]]) -> list[int]:\n    ans = []\n    xors = [0] * (len(arr) + 1)\n\n    for i, a in enumerate(arr):\n      xors[i + 1] = xors[i] ^ a\n\n    for left, right in queries:\n      ans.append(xors[left] ^ xors[right + 1])\n\n    return ans",
      "title": "1310. XOR Queries of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a649b07d-f80f-4332-9ba6-f51794aa66cd",
      "code": "class Solution:\n  def watchedVideosByFriends(\n      self,\n      watchedVideos: list[list[str]],\n      friends: list[list[int]],\n      id: int,\n      level: int,\n  ) -> list[str]:\n    seen = [False] * 100\n    seen[id] = True\n    q = collections.deque([id])\n    count = collections.Counter()\n\n    for _ in range(level):\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for friend in friends[curr]:\n          if not seen[friend]:\n            seen[friend] = True\n            q.append(friend)\n\n    for friend in q:\n      for video in watchedVideos[friend]:\n        count[video] += 1\n\n    return sorted(count, key=lambda video: (count[video], video))",
      "title": "1311. Get Watched Videos by Your Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3862071-5460-47af-8fc0-11b3a1af57bb",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    return len(s) - self._longestPalindromeSubseq(s)\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1312. Minimum Insertion Steps to Make a String Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f448254-7bb9-4c11-9d94-fd1f8b1e25de",
      "code": "class Solution:\n  def decompressRLElist(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for i in range(0, len(nums), 2):\n      ans += [nums[i + 1]] * nums[i]\n\n    return ans",
      "title": "1313. Decompress Run-Length Encoded List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "266035b9-3347-422b-a2b0-9f67af4443e1",
      "code": "class Solution:\n  def matrixBlockSum(self, mat: list[list[int]], k: int) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    for i in range(m):\n      for j in range(n):\n        r1 = max(0, i - k) + 1\n        c1 = max(0, j - k) + 1\n        r2 = min(m - 1, i + k) + 1\n        c2 = min(n - 1, j + k) + 1\n        ans[i][j] = (prefix[r2][c2] - prefix[r2][c1 - 1] -\n                     prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1])\n\n    return ans",
      "title": "1314. Matrix Block Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65a44054-e839-40a2-a002-258ce142fc95",
      "code": "class Solution:\n  def distinctEchoSubstrings(self, text: str) -> int:\n    seen = set()\n\n    for k in range(1, len(text) // 2 + 1):  # the target length\n      same = 0\n      l = 0\n      for r in range(k, len(text)):\n        if text[l] == text[r]:\n          same += 1\n        else:\n          same = 0\n        if same == k:\n          seen.add(text[l - k + 1:l + 1])\n          # Move the window thus leaving a letter behind, so we need to\n          # decrease the counter.\n          same -= 1\n        l += 1\n\n    return len(seen)",
      "title": "1316. Distinct Echo Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52c0b4ab-0e55-40a8-91c9-afdf0dd838fe",
      "code": "class Solution:\n  def getNoZeroIntegers(self, n: int) -> list[int]:\n    for A in range(n):\n      B = n - A\n      if '0' not in str(A) and '0' not in str(B):\n        return A, B",
      "title": "1317. Convert Integer to the Sum of Two No-Zero Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1b0e201-5dbd-4fed-a3f4-ed9162eb59ba",
      "code": "class Solution:\n  def minFlips(self, a: int, b: int, c: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      if c >> i & 1:\n        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0\n      else:  # (c >> i & 1) == 0\n        ans += (a >> i & 1) + (b >> i & 1)\n\n    return ans",
      "title": "1318. Minimum Flips to Make a OR b Equal to c",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "666ad60e-6cac-475f-b036-38977b22c729",
      "code": "class Solution:\n  def minimumDistance(self, word: str) -> int:\n    def dist(a: int, b: int) -> int:\n      if a == 26:  # the first hovering state\n        return 0\n      x1, y1 = a // 6, a % 6\n      x2, y2 = b // 6, b % 6\n      return abs(x1 - x2) + abs(y1 - y2)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to type the `word`, where the left finger is\n      on the i-th letter, the right finger is on the j-th letter, and the\n      words[0..k) have been written.\n      \"\"\"\n      if k == len(word):\n        return 0\n      nxt = ord(word[k]) - ord('A')\n      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)\n      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)\n      return min(moveLeft, moveRight)\n\n    return dp(26, 26, 0)",
      "title": "1320. Minimum Distance to Type a Word Using Two Fingers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a22a4b0-176f-474d-af17-31deac172d88",
      "code": "class Solution:\n  def maximum69Number(self, num: int) -> int:\n    return int(str(num).replace('6', '9', 1))",
      "title": "1323. Maximum 69 Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91a7cf78-3862-4402-9164-e1c904287b76",
      "code": "class Solution:\n  def printVertically(self, s: str) -> list[str]:\n    ans = []\n    words = s.split()\n    maxLength = max(len(word) for word in words)\n\n    for i in range(maxLength):\n      row = []\n      for word in words:\n        row.append(word[i] if i < len(word) else ' ')\n      ans.append(''.join(row).rstrip())\n\n    return ans",
      "title": "1324. Print Words Vertically",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0976e2eb-f479-49ae-9c2d-381e916b1aaa",
      "code": "class Solution:\n  def removeLeafNodes(\n      self,\n      root: TreeNode | None,\n      target: int,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.removeLeafNodes(root.left, target)\n    root.right = self.removeLeafNodes(root.right, target)\n    return None if self._isLeaf(root) and root.val == target else root\n\n  def _isLeaf(self, root: TreeNode | None) -> bool:\n    return not root.left and not root.right",
      "title": "1325. Delete Leaves With a Given Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2777eebe-85a6-4b42-abf7-99b3fb70c605",
      "code": "class Solution:\n  def minTaps(self, n: int, ranges: list[int]) -> int:\n    nums = [0] * (n + 1)\n\n    for i, range_ in enumerate(ranges):\n      l = max(0, i - range_)\n      r = min(n, range_ + i)\n      nums[l] = max(nums[l], r - l)\n\n    ans = 0\n    end = 0\n    farthest = 0\n\n    for i in range(n):\n      farthest = max(farthest, i + nums[i])\n      if i == end:\n        ans += 1\n        end = farthest\n\n    return ans if end == n else -1",
      "title": "1326. Minimum Number of Taps to Open to Water a Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "410a8614-586c-42b0-993a-13c851b3b142",
      "code": "class Solution:\n  def breakPalindrome(self, palindrome: str) -> str:\n    if len(palindrome) == 1:\n      return ''\n\n    ans = list(palindrome)\n\n    for i in range(len(palindrome) // 2):\n      if palindrome[i] != 'a':\n        ans[i] = 'a'\n        return ''.join(ans)\n\n    ans[-1] = 'b'\n    return ''.join(ans)",
      "title": "1328. Break a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8499fc2c-a210-4344-a95b-c1a460b117a1",
      "code": "class Solution:\n  def diagonalSort(self, mat: list[list[int]]) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n\n    count = collections.defaultdict(list)\n\n    for i in range(m):\n      for j in range(n):\n        count[i - j].append(mat[i][j])\n\n    for value in count.values():\n      value.sort(reverse=1)\n\n    for i in range(m):\n      for j in range(n):\n        mat[i][j] = count[i - j].pop()\n\n    return mat",
      "title": "1329. Sort the Matrix Diagonally",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "165eff82-fca1-4975-8300-35c35d303b68",
      "code": "class Solution:\n  def maxValueAfterReverse(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n\n    for a, b in zip(nums, nums[1:]):\n      mn = min(mn, max(a, b))\n      mx = max(mx, min(a, b))\n    diff = max(0, (mx - mn) * 2)\n\n    for a, b in zip(nums, nums[1:]):\n      headDiff = -abs(a - b) + abs(nums[0] - b)\n      tailDiff = -abs(a - b) + abs(nums[-1] - a)\n      diff = max(diff, headDiff, tailDiff)\n\n    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff",
      "title": "1330. Reverse Subarray To Maximize Array Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6e2bb59-6301-4cf3-acd0-6744eca3d7a7",
      "code": "class Solution:\n  def arrayRankTransform(self, arr: list[int]) -> list[int]:\n    rank = {}\n\n    for a in sorted(arr):\n      if a not in rank:\n        rank[a] = len(rank) + 1\n\n    return map(rank.get, arr)",
      "title": "1331. Rank Transform of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30f7df86-c09b-458e-852a-249176e03643",
      "code": "class Solution:\n  def removePalindromeSub(self, s: str) -> int:\n    return 1 if s == s[::-1] else 2",
      "title": "1332. Remove Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b6be4cb-0d01-471e-90cd-05bf4df4fef2",
      "code": "class Solution:\n  def filterRestaurants(\n      self,\n      restaurants: list[list[int]],\n      veganFriendly: int,\n      maxPrice: int,\n      maxDistance: int,\n  ) -> list[int]:\n    restaurants.sort(key=lambda x: (-x[1], -x[0]))\n    return [i for i, _, v, p, d in restaurants\n            if v >= veganFriendly and p <= maxPrice and d <= maxDistance]",
      "title": "1333. Filter Restaurants by Vegan-Friendly, Price and Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c3ada1b-27ed-44e9-9432-f8952055f540",
      "code": "class Solution:\n  def findTheCity(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> list[list[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist",
      "title": "1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "540cda0c-4869-4de5-af41-c3392a778827",
      "code": "class Solution:\n  def minDifficulty(self, jobDifficulty: list[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if d > n:\n      return -1\n\n    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days\n    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n      for k in range(1, d + 1):\n        maxDifficulty = 0  # max(job[j + 1..i])\n        for j in range(i - 1, k - 2, -1):  # 1-based\n          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)\n\n    return dp[n][d]",
      "title": "1335. Minimum Difficulty of a Job Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da58f91e-cbd8-4686-a9ec-a507ffa8c723",
      "code": "class Solution:\n  def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\n    rowSums = [(sum(row), i) for i, row in enumerate(mat)]\n    return [i for _, i in sorted(rowSums)[:k]]",
      "title": "1337. The K Weakest Rows in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ce48fa-e297-41ca-a66a-c02c02bc5e73",
      "code": "class Solution:\n  def minSetSize(self, arr: list[int]) -> int:\n    count = collections.Counter(arr).most_common()\n    count.sort(key=lambda x: -x[1])\n\n    summ = 0\n    for i, (_, freq) in enumerate(count):\n      summ += freq\n      if summ >= len(arr) // 2:\n        return i + 1",
      "title": "1338. Reduce Array Size to The Half",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e1f8a3c-bf79-41e2-a61e-beb239f1c73c",
      "code": "class Solution:\n  def maxJumps(self, arr: list[int], d: int) -> int:\n    n = len(arr)\n    # dp[i] := the maximum jumps starting from arr[i]\n    dp = [1] * n\n    # a dcreasing stack that stores indices\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            # Can jump from i to j.\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            # Can jump from stack[-1] to j\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)",
      "title": "1340. Jump Game V",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ecf7a3f-f2fc-4d7d-b59d-2b6fa278d1d1",
      "code": "class Solution:\n  def numberOfSteps(self, num: int) -> int:\n    if num == 0:\n      return 0\n    subtractSteps = num.bit_count()\n    divideSteps = num.bit_length() - 1\n    return subtractSteps + divideSteps",
      "title": "1342. Number of Steps to Reduce a Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0918914b-3244-4470-a736-c332a9b5a749",
      "code": "class Solution:\n  def numOfSubarrays(self, arr: list[int], k: int, threshold: int) -> int:\n    ans = 0\n    windowSum = 0\n\n    for i in range(len(arr)):\n      windowSum += arr[i]\n      if i >= k:\n        windowSum -= arr[i - k]\n      if i >= k - 1 and windowSum // k >= threshold:\n        ans += 1\n\n    return ans",
      "title": "1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bb5fc7c-413a-46a5-8ee3-a27164396563",
      "code": "class Solution:\n  def angleClock(self, hour: int, minutes: int) -> float:\n    hourAngle = (hour % 12) * 30 + minutes * 0.5\n    minuteAngle = minutes * 6\n    ans = abs(hourAngle - minuteAngle)\n\n    return min(ans, 360 - ans)",
      "title": "1344. Angle Between Hands of a Clock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7679873b-f267-43eb-9d68-9265b8bf4845",
      "code": "class Solution:\n  def minJumps(self, arr: list[int]) -> int:\n    n = len(arr)\n    # {num: indices}\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1",
      "title": "1345. Jump Game IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "666fd05b-cec8-4290-9793-1a2778810fac",
      "code": "class Solution:\n  def checkIfExist(self, arr: list[int]) -> bool:\n    seen = set()\n\n    for a in arr:\n      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:\n        return True\n      seen.add(a)\n\n    return False",
      "title": "1346. Check If N and Its Double Exist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1b48349-5a4d-40eb-b17f-2428b9465f05",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum(abs(value) for value in count.values()) // 2",
      "title": "1347. Minimum Number of Steps to Make Two Strings Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba69e06-c543-4607-be00-93513f0696e6",
      "code": "class Solution:\n  def maxStudents(self, seats: list[list[str]]) -> int:\n    m = len(seats)\n    n = len(seats[0])\n    DIRS = ((-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1))\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seats[x][y] != '.' or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    def hungarian() -> int:\n      count = 0\n      for i in range(m):\n        for j in range(n):\n          if seats[i][j] == '.' and match[i][j] == -1:\n            sessionId = i * n + j\n            seen[i][j] = sessionId\n            count += dfs(i, j, sessionId)\n      return count\n\n    return sum(seats[i][j] == '.'\n               for i in range(m)\n               for j in range(n)) - hungarian()",
      "title": "1349. Maximum Students Taking Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba3c6f38-dbb0-45c1-9c5d-49dd2b05bbb2",
      "code": "class Solution:\n  def countNegatives(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    i = m - 1\n    j = 0\n\n    while i >= 0 and j < n:\n      if grid[i][j] < 0:\n        ans += n - j\n        i -= 1\n      else:\n        j += 1\n\n    return ans",
      "title": "1351. Count Negative Numbers in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d13e2e3-56c2-4542-a678-967e73ffc977",
      "code": "class Solution:\n  def maxEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    minHeap = []\n    i = 0  # events' index\n\n    events.sort(key=lambda x: x[0])\n\n    while minHeap or i < len(events):\n      # If no events are available to attend today, let time flies to the next\n      # available event.\n      if not minHeap:\n        d = events[i][0]\n      # All the events starting from today are newly available.\n      while i < len(events) and events[i][0] == d:\n        heapq.heappush(minHeap, events[i][1])\n        i += 1\n      # Greedily attend the event that'll end the earliest since it has higher\n      # chance can't be attended in the future.\n      heapq.heappop(minHeap)\n      ans += 1\n      d += 1\n      # Pop the events that can't be attended.\n      while minHeap and minHeap[0] < d:\n        heapq.heappop(minHeap)\n\n    return ans",
      "title": "1353. Maximum Number of Events That Can Be Attended",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "639620ec-3516-40c5-8712-b5ed7b368a38",
      "code": "class Solution:\n  def isPossible(self, target: list[int]) -> bool:\n    if len(target) == 1:\n      return target[0] == 1\n\n    summ = sum(target)\n    maxHeap = [-num for num in target]\n    heapq.heapify(maxHeap)\n\n    while -maxHeap[0] > 1:\n      mx = -heapq.heappop(maxHeap)\n      restSum = summ - mx\n      # Only occurs if n == 2.\n      if restSum == 1:\n        return True\n      updated = mx % restSum\n      # updated == 0 (invalid) or didn't change.\n      if updated == 0 or updated == mx:\n        return False\n      heapq.heappush(maxHeap, -updated)\n      summ = summ - mx + updated\n\n    return True",
      "title": "1354. Construct Target Array With Multiple Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "594cc8d6-ee26-4c8b-9a0d-18e8e289a4e2",
      "code": "class Solution:\n  def sortByBits(self, arr: list[int]) -> list[int]:\n    return sorted(arr, key=lambda x: (x.bit_count(), x))",
      "title": "1356. Sort Integers by The Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec83f3d0-e550-4aaa-957a-1b3dd34a82e2",
      "code": "class Solution:\n  # Similar to 3. Longest SubWithout Repeating Characters\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {c: -1 for c in 'abc'}\n\n    for i, c in enumerate(s):\n      lastSeen[c] = i\n      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.\n      ans += 1 + min(lastSeen.values())\n\n    return ans",
      "title": "1358. Number of Substrings Containing All Three Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c709721-bf87-47b1-a2c5-f61d784baf1b",
      "code": "class Solution:\n  def countOrders(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n\n    for i in range(1, n + 1):\n      ans = ans * i * (i * 2 - 1) % MOD\n\n    return ans",
      "title": "1359. Count All Valid Pickup and Delivery Options",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e305812-20d5-403e-93e7-ca7a70eb709e",
      "code": "class Solution:\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n\n    def daysFrom1971(date: str) -> int:\n      year, month, day = map(int, date.split('-'))\n      return (365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) +\n              sum(days[:month]) + day + (month > 2 and isLeapYear(year)))\n\n    return abs(daysFrom1971(date1) - daysFrom1971(date2))",
      "title": "1360. Number of Days Between Two Dates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d05b8b8d-7177-4781-95bb-3ba792184a18",
      "code": "class Solution:\n  def closestDivisors(self, num: int) -> list[int]:\n    for root in reversed(range(math.isqrt(num + 2) + 1)):\n      for cand in [num + 1, num + 2]:\n        if cand % root == 0:\n          return [root, cand // root]",
      "title": "1362. Closest Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44d02192-2f22-47f1-a246-f9ddbf055efa",
      "code": "class Solution:\n  def largestMultipleOfThree(self, digits: list[int]) -> str:\n    ans = ''\n    mod1 = [1, 4, 7, 2, 5, 8]\n    mod2 = [2, 5, 8, 1, 4, 7]\n    count = collections.Counter(digits)\n    summ = sum(digits)\n\n    while summ % 3 != 0:\n      for digit in (mod1 if summ % 3 == 1 else mod2):\n        if count[digit]:\n          count[digit] -= 1\n          summ -= digit\n          break\n\n    for digit in reversed(range(10)):\n      ans += str(digit) * count[digit]\n\n    return '0' if len(ans) and ans[0] == '0' else ans",
      "title": "1363. Largest Multiple of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cb83891-5665-44b1-9bbe-3a2bf9e3cb8b",
      "code": "class Solution:\n  def smallerNumbersThanCurrent(self, nums: list[int]) -> list[int]:\n    MAX = 100\n    count = collections.Counter(nums)\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    return [0 if num == 0 else count[num - 1]\n            for num in nums]",
      "title": "1365. How Many Numbers Are Smaller Than the Current Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd1a6ce-3862-4dec-83bd-8078cfdbde0c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Team:\n  name: str\n  rank: list[int]\n\n  def __init__(self, name: str, teamSize: int):\n    self.name = name\n    self.rank = [0] * teamSize\n\n\nclass Solution:\n  def rankTeams(self, votes: list[str]) -> str:\n    teamSize = len(votes[0])\n    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]\n\n    for vote in votes:\n      for i in range(teamSize):\n        teams[ord(vote[i]) - ord('A')].rank[i] += 1\n\n    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)\n    return ''.join(team.name for team in teams[:teamSize])",
      "title": "1366. Rank Teams by Votes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dee251e4-619c-4eab-8420-3f5df9c568ef",
      "code": "class Solution:\n  def isSubPath(self, head: ListNode | None, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n    return (self._isContinuousSubPath(head, root) or\n            self.isSubPath(head, root.left) or\n            self.isSubPath(head, root.right))\n\n  def _isContinuousSubPath(\n      self,\n      head: ListNode | None,\n      root: TreeNode | None,\n  ) -> bool:\n    if not head:\n      return True\n    if not root:\n      return False\n    return (head.val == root.val and\n            (self._isContinuousSubPath(head.next, root.left) or\n             self._isContinuousSubPath(head.next, root.right)))",
      "title": "1367. Linked List in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "895b3292-8cc0-4b7b-aea8-2bbda582d3ec",
      "code": "class Solution:\n  def minCost(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    DIRS = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    dp = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    def dfs(i: int, j: int, cost: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if dp[i][j] != -1:\n        return\n      dp[i][j] = cost\n      q.append((i, j))\n      dx, dy = DIRS[grid[i][j] - 1]\n      dfs(i + dx, j + dy, cost)\n\n    dfs(0, 0, 0)\n\n    cost = 0\n    while q:\n      cost += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy, cost)\n\n    return dp[-1][-1]",
      "title": "1368. Minimum Cost to Make at Least One Valid Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab42c06a-a7b0-4a6e-ae5d-3c4ece97b51f",
      "code": "class Solution:\n  def sortString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n\n    while count:\n      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):\n        ans += [c for c in chars if c in count]\n        count -= dict.fromkeys(count, 1)\n\n    return ''.join(ans)",
      "title": "1370. Increasing Decreasing String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf44a437-5f2d-451e-84f5-e2a9602af43c",
      "code": "class Solution:\n  def findTheLongestSubstring(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = {0: -1}\n\n    for i, c in enumerate(s):\n      index = VOWELS.find(c)\n      if index != -1:\n        prefix ^= 1 << index\n      prefixToIndex.setdefault(prefix, i)\n      ans = max(ans, i - prefixToIndex[prefix])\n\n    return ans",
      "title": "1371. Find the Longest Substring Containing Vowels in Even Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "381e818f-f994-4c0e-92e5-019c03c3359e",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  leftMax: int\n  rightMax: int\n  subtreeMax: int\n\n\nclass Solution:\n  def longestZigZag(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(-1, -1, -1)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      leftZigZag = left.rightMax + 1\n      rightZigZag = right.leftMax + 1\n      subtreeMax = max(leftZigZag, rightZigZag,\n                       left.subtreeMax, right.subtreeMax)\n      return T(leftZigZag, rightZigZag, subtreeMax)\n\n    return dfs(root).subtreeMax",
      "title": "1372. Longest ZigZag Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f09cee92-ebba-4be3-a2d7-96c6574704dd",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass T:\n  isBST: bool | None = False\n  mx: int | None = None\n  mn: int | None = None\n  summ: int | None = None\n\n\nclass Solution:\n  def maxSumBST(self, root: TreeNode | None) -> int:\n    self.ans = 0\n\n    def traverse(root: TreeNode | None) -> T:\n      if not root:\n        return T(True, -math.inf, math.inf, 0)\n\n      left: T = traverse(root.left)\n      right: T = traverse(root.right)\n\n      if not left.isBST or not right.isBST:\n        return T()\n      if root.val <= left.mx or root.val >= right.mn:\n        return T()\n\n      # The `root` is a valid BST.\n      summ = root.val + left.summ + right.summ\n      self.ans = max(self.ans, summ)\n      return T(True, max(root.val, right.mx), min(root.val, left.mn), summ)\n\n    traverse(root)\n    return self.ans",
      "title": "1373. Maximum Sum BST in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efe0eabc-0f41-4703-b7ae-7aa56dfee116",
      "code": "class Solution:\n  def generateTheString(self, n: int) -> str:\n    s = 'a' * n\n    if n % 2 == 0:\n      s = s[:-1] + 'b'\n    return s",
      "title": "1374. Generate a String With Characters That Have Odd Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5b337d5-32f9-405b-9901-8c509b305def",
      "code": "class Solution:\n  def numTimesAllBlue(self, flips: list[int]) -> int:\n    ans = 0\n    rightmost = 0\n\n    for i, flip in enumerate(flips):\n      rightmost = max(rightmost, flip)\n      # max(flips[0..i]) = rightmost = i + 1,\n      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.\n      if rightmost == i + 1:\n        ans += 1\n\n    return ans",
      "title": "1375. Number of Times Binary String Is Prefix-Aligned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d06382-91a5-440e-bbef-cfdc58b12c2c",
      "code": "class Solution:\n  def frogPosition(\n      self,\n      n: int,\n      edges: list[list[int]],\n      t: int,\n      target: int,\n  ) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]",
      "title": "1377. Frog Position After T Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "486c55c9-8490-431b-8f00-e374235d69ae",
      "code": "class Solution:\n  def getTargetCopy(\n      self,\n      original: TreeNode,\n      cloned: TreeNode,\n      target: TreeNode,\n  ) -> TreeNode:\n    ans = None\n\n    def dfs(original: TreeNode, cloned: TreeNode) -> None:\n      nonlocal ans\n      if ans:\n        return\n      if not original:\n        return\n      if original == target:\n        ans = cloned\n        return\n\n      dfs(original.left, cloned.left)\n      dfs(original.right, cloned.right)\n\n    dfs(original, cloned)\n    return ans",
      "title": "1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72387a78-57b2-43f6-ad57-28a0aade1909",
      "code": "class Solution:\n  def luckyNumbers(self, matrix: list[list[int]]) -> list[int]:\n    for row in matrix:\n      minIndex = row.index(min(row))\n      if row[minIndex] == max(list(zip(*matrix))[minIndex]):\n        return [row[minIndex]]\n    return []",
      "title": "1380. Lucky Numbers in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03bf109d-de3c-489f-9cc1-b8602772e50f",
      "code": "class Solution:\n  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:\n    nums = []\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n      inorder(root.left)\n      nums.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    # Same as 108. Convert Sorted Array to Binary Search Tree\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "1382. Balance a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc10e496-66b7-4e5b-bf9f-e14392e34646",
      "code": "class Solution:\n  # Similar to 857. Minimum Cost to Hire K Workers\n  def maxPerformance(\n      self,\n      n: int,\n      speed: list[int],\n      efficiency: list[int],\n      k: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    speedSum = 0\n    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order\n    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)\n    minHeap = []\n\n    for e, s in A:\n      heapq.heappush(minHeap, s)\n      speedSum += s\n      if len(minHeap) > k:\n        speedSum -= heapq.heappop(minHeap)\n      ans = max(ans, speedSum * e)\n\n    return ans % MOD",
      "title": "1383. Maximum Performance of a Team",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd275b2d-34a1-4d77-bc47-d22fd74c2a63",
      "code": "class Solution:\n  def findTheDistanceValue(\n      self,\n      arr1: list[int],\n      arr2: list[int],\n      d: int,\n  ) -> int:\n    ans = 0\n\n    arr2.sort()\n\n    for a in arr1:\n      i = bisect.bisect_left(arr2, a)\n      if ((i == len(arr2) or arr2[i] - a > d) and\n              (i == 0 or a - arr2[i - 1] > d)):\n        ans += 1\n\n    return ans",
      "title": "1385. Find the Distance Value Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b0cfb17-54c2-4981-a726-ea9a97f4a1df",
      "code": "class Solution:\n  def maxNumberOfFamilies(self, n: int, reservedSeats: list[list[int]]) -> int:\n    ans = 0\n    rowToSeats = collections.Counter()\n\n    for row, seat in reservedSeats:\n      rowToSeats[row] |= 1 << (seat - 1)\n\n    for seats in rowToSeats.values():\n      if (seats & 0b0111111110) == 0:\n        # Can fit 2 four-person groups.\n        ans += 2\n      elif ((seats & 0b0111100000) == 0 or\n            (seats & 0b0001111000) == 0 or\n            (seats & 0b0000011110) == 0):\n        # Can fit 1 four-person group.\n        ans += 1\n\n    # Any empty row can fit 2 four-person groups.\n    return ans + (n - len(rowToSeats)) * 2",
      "title": "1386. Cinema Seat Allocation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e6d8b20-6ad7-48b2-97dd-ffee28f6877e",
      "code": "class Solution:\n  def getKth(self, lo: int, hi: int, k: int) -> int:\n    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]\n\n  def _getPow(self, n: int) -> int:\n    if n == 1:\n      return 0\n    if n % 2 == 0:\n      return 1 + self._getPow(n // 2)\n    return 1 + self._getPow(n * 3 + 1)",
      "title": "1387. Sort Integers by The Power Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "183bdeb8-cf45-4289-8b3d-d8dd3e9a68e0",
      "code": "class Solution:\n  def maxSizeSlices(self, slices: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum the sum of slices if you can pick k slices from\n      slices[i..j).\n      \"\"\"\n      if k == 1:\n        return max(slices[i:j])\n      # Note that j - i is not the number of all the left slices. Since you\n      # Might have chosen not to take a slice in a previous step, there would be\n      # Leftovers outside [i:j]. If you take slices[i], one of the slices your\n      # Friends take will be outside of [i:j], so the length of [i:j] is reduced\n      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only\n      # Requires one slice).\n      if j - i < 2 * k - 1:\n        return -math.inf\n      return max(slices[i] + dp(i + 2, j, k - 1),\n                 dp(i + 1, j, k))\n\n    k = len(slices) // 3\n    return max(dp(0, len(slices) - 1, k),\n               dp(1, len(slices), k))",
      "title": "1388. Pizza With 3n Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30117555-1871-4306-a056-127d4866178e",
      "code": "class Solution:\n  def createTargetArray(self, nums, index):\n    ans = []\n    for num, i in zip(nums, index):\n      ans.insert(i, num)\n    return ans",
      "title": "1389. Create Target Array in the Given Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3defb62a-3188-4a65-abdd-89a5e023a024",
      "code": "class Solution:\n  def sumFourDivisors(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      divisor = 0\n      for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n          if divisor == 0:\n            divisor = i\n          else:\n            divisor = 0\n            break\n      if divisor > 0 and divisor * divisor < num:\n        ans += 1 + num + divisor + num // divisor\n\n    return ans",
      "title": "1390. Four Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5625f7c2-ebaf-4987-8653-d0b574a86b57",
      "code": "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    BASE = 26\n    HASH = 8_417_508_174_513\n    n = len(s)\n    maxLength = 0\n    pow = 1\n    prefixHash = 0  # the hash of s[0..i]\n    suffixHash = 0  # the hash of s[j..n)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    j = n - 1\n    for i in range(n - 1):\n      prefixHash = (prefixHash * BASE + val(s[i])) % HASH\n      suffixHash = (val(s[j]) * pow + suffixHash) % HASH\n      pow = pow * BASE % HASH\n      if prefixHash == suffixHash:\n        maxLength = i + 1\n      j -= 1\n\n    return s[:maxLength]",
      "title": "1392. Longest Happy Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b73b880f-b2da-4b79-874c-46153f2dcc74",
      "code": "class Solution:\n  def findLucky(self, arr: list[int]) -> int:\n    count = [0] * (len(arr) + 1)\n\n    for a in arr:\n      if a <= len(arr):\n        count[a] += 1\n\n    for i in range(len(arr), 0, -1):\n      if count[i] == i:\n        return i\n\n    return -1",
      "title": "1394. Find Lucky Integer in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3335830-d3f9-4cc6-82aa-7df0f5884b5e",
      "code": "class Solution:\n  def numTeams(self, rating: list[int]) -> int:\n    ans = 0\n\n    for i in range(1, len(rating) - 1):\n      # Calculate soldiers on the left with less//greater ratings.\n      leftLess = 0\n      leftGreater = 0\n      for j in range(i):\n        if rating[j] < rating[i]:\n          leftLess += 1\n        elif rating[j] > rating[i]:\n          leftGreater += 1\n      # Calculate soldiers on the right with less//greater ratings.\n      rightLess = 0\n      rightGreater = 0\n      for j in range(i + 1, len(rating)):\n        if rating[j] < rating[i]:\n          rightLess += 1\n        elif rating[j] > rating[i]:\n          rightGreater += 1\n      ans += leftLess * rightGreater + leftGreater * rightLess\n\n    return ans",
      "title": "1395. Count Number of Teams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "926873d8-bd66-4e70-b446-3a165a1d5b43",
      "code": "class Solution:\n  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n    MOD = 1_000_000_007\n    evilLPS = self._getLPS(evil)\n\n    @functools.lru_cache(None)\n    def getNextMatchedEvilCount(j: int, currChar: str) -> int:\n      \"\"\"\n      Returns the number of next matched evil count, where there're j matches\n      with `evil` and the current letter is ('a' + j).\n      \"\"\"\n      while j > 0 and evil[j] != currChar:\n        j = evilLPS[j - 1]\n      return j + 1 if evil[j] == currChar else j\n\n    @functools.lru_cache(None)\n    def dp(i: int, matchedEvilCount: int, isS1Prefix: bool, isS2Prefix: bool) -> int:\n      \"\"\"\n      Returns the number of good strings for s[i..n), where there're j matches\n      with `evil`, `isS1Prefix` indicates if the current letter is tightly bound\n      for `s1` and `isS2Prefix` indicates if the current letter is tightly bound\n      for `s2`.\n      \"\"\"\n      # s[0..i) contains `evil`, so don't consider any ongoing strings.\n      if matchedEvilCount == len(evil):\n        return 0\n      # Run out of strings, so contribute one.\n      if i == n:\n        return 1\n      ans = 0\n      minCharIndex = ord(s1[i]) if isS1Prefix else ord('a')\n      maxCharIndex = ord(s2[i]) if isS2Prefix else ord('z')\n      for charIndex in range(minCharIndex, maxCharIndex + 1):\n        c = chr(charIndex)\n        nextMatchedEvilCount = getNextMatchedEvilCount(matchedEvilCount, c)\n        ans += dp(i + 1, nextMatchedEvilCount,\n                  isS1Prefix and c == s1[i],\n                  isS2Prefix and c == s2[i])\n        ans %= MOD\n      return ans\n\n    return dp(0, 0, True, True)\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "1397. Find All Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c60e814-d303-44d8-bc03-4b94aeb61df3",
      "code": "class Solution:\n  def countLargestGroup(self, n: int) -> int:\n    count = [0] * (9 * 4 + 1)\n    for i in range(1, n + 1):\n      count[self._getDigitSum(i)] += 1\n    return count.count(max(count))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1399. Count Largest Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e27e2c8-837c-4f63-978d-7819ce5c8790",
      "code": "class Solution:\n  def canConstruct(self, s: str, k: int) -> bool:\n    # If |s| < k, we cannot construct k strings from the s.\n    # If the number of letters that have odd counts > k, the minimum number of\n    # palindromic strings we can construct is > k.\n    return sum(freq & 1\n               for freq in collections.Counter(s).values()) <= k <= len(s)",
      "title": "1400. Construct K Palindrome Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "240e99a9-489f-4f67-a5bb-223619c6dd0e",
      "code": "class Solution:\n  def maxSatisfaction(self, satisfaction: list[int]) -> int:\n    ans = 0\n    sumSatisfaction = 0\n\n    for s in sorted(satisfaction, reverse=True):\n      sumSatisfaction += s\n      if sumSatisfaction <= 0:\n        return ans\n      ans += sumSatisfaction\n\n    return ans",
      "title": "1402. Reducing Dishes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8342a9d-2233-4075-89b8-50851e3d1bb0",
      "code": "class Solution:\n  def minSubsequence(self, nums: list[int]) -> list[int]:\n    ans = []\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n    half = sum(nums) // 2\n\n    while half >= 0:\n      ans.append(-maxHeap[0])\n      half += heapq.heappop(maxHeap)\n\n    return ans",
      "title": "1403. Minimum Subsequence in Non-Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2324589a-e50e-458f-935e-56e4560cad9e",
      "code": "class Solution:\n  def numSteps(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    # All the trailing 0s can be popped by 1 step.\n    while chars[-1] == '0':\n      chars.pop()\n      ans += 1\n\n    if ''.join(chars) == '1':\n      return ans\n\n    # `s` is now odd, so add 1 to `s` and cost 1 step.\n    # All the 1s will become 0s and can be popped by 1 step.\n    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then\n    # dividing by 2).\n    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)",
      "title": "1404. Number of Steps to Reduce a Number in Binary Representation to One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0e11b7b-cdc7-44ae-9138-4636abf8cad5",
      "code": "class Solution:\n  def stoneGameIII(self, stoneValue: list[int]) -> str:\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"\n      Returns the maximum relative score Alice can make with stoneValue[i..n).\n      \"\"\"\n      if i == len(stoneValue):\n        return 0\n\n      res = -math.inf\n      summ = 0\n\n      for j in range(i, i + 3):\n        if j == len(stoneValue):\n          break\n        summ += stoneValue[j]\n        res = max(res, summ - dp(j + 1))\n\n      return res\n\n    score = dp(0)\n    if score == 0:\n      return 'Tie'\n    return 'Alice' if score > 0 else 'Bob'",
      "title": "1406. Stone Game III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd5e556f-8b8a-4ade-b9f6-953f51af1b52",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return True\n\n\nclass Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    trie = Trie()\n\n    for word in sorted(words, key=lambda x: -len(x)):\n      if trie.search(word):\n        ans.append(word)\n      for i in range(len(word)):\n        trie.insert(word[i:])\n\n    return ans",
      "title": "1408. String Matching in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20a58c1b-c14a-43f5-9ffb-3ff1a0ae2791",
      "code": "class Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    for a in words:\n      for b in words:\n        if len(a) < len(b) and b.find(a) != -1:\n          ans.append(a)\n          break\n    return ans",
      "title": "1408. String Matching in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50a0586-a025-41a0-85c7-fd10f425449f",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def processQueries(self, queries: list[int], m: int) -> list[int]:\n    ans = []\n    # Map [-m, m] to [0, 2 * m].\n    tree = FenwickTree(2 * m + 1)\n    numToIndex = {num: num + m for num in range(1, m + 1)}\n\n    for num in range(1, m + 1):\n      tree.add(num + m, 1)\n\n    nextEmptyIndex = m  # Map 0 to m.\n\n    for query in queries:\n      index = numToIndex[query]\n      ans.append(tree.get(index - 1))\n      # Move `query` from `index` to `nextEmptyIndex`.\n      tree.add(index, -1)\n      tree.add(nextEmptyIndex, 1)\n      numToIndex[query] = nextEmptyIndex\n      nextEmptyIndex -= 1\n\n    return ans",
      "title": "1409. Queries on a Permutation With Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c120da27-e605-40dd-821f-90350288eb7c",
      "code": "class Solution:\n  def entityParser(self, text: str) -> str:\n    entityToChar = {'&quot;': '\"', '&apos;': '\\'',\n                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}\n\n    for entity, c in entityToChar.items():\n      text = text.replace(entity, c)\n\n    # Process '&' in last.\n    return text.replace('&amp;', '&')",
      "title": "1410. HTML Entity Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c7a50c2-bf86-4260-8a33-41597efa1c1a",
      "code": "class Solution:\n  def minStartValue(self, nums: list[int]) -> int:\n    summ = 0\n    minSum = 0\n\n    for num in nums:\n      summ += num\n      minSum = min(minSum, summ)\n\n    return 1 - minSum",
      "title": "1413. Minimum Value to Get Positive Step by Step Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1009503f-8a0c-4e78-a605-0b43e0fa6baa",
      "code": "class Solution:\n  def findMinFibonacciNumbers(self, k: int) -> int:\n    ans = 0\n    a = 1  # F_1\n    b = 1  # F_2\n\n    while b <= k:\n      #    a, b = F_{i + 1}, F_{i + 2}\n      # -> a, b = F_{i + 2}, F_{i + 3}\n      a, b = b, a + b\n\n    while a > 0:\n      if a <= k:\n        k -= a\n        ans += 1\n      #    a, b = F_{i + 2}, F_{i + 3}\n      # -> a, b = F_{i + 1}, F_{i + 2}\n      a, b = b - a, a\n\n    return ans",
      "title": "1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16425520-f2bd-4d28-b214-d4cabe74d16c",
      "code": "class Solution:\n  def getHappyString(self, n: int, k: int) -> str:\n    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}\n    q = collections.deque(['a', 'b', 'c'])\n\n    while len(q[0]) != n:\n      u = q.popleft()\n      for nextLetter in nextLetters[u[-1]]:\n        q.append(u + nextLetter)\n\n    return '' if len(q) < k else q[k - 1]",
      "title": "1415. The k-th Lexicographical String of All Happy Strings of Length n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abd78a4c-da7c-41f5-a7d4-dee7493017ec",
      "code": "class Solution:\n  def reformat(self, s: str) -> str:\n    A = [c for c in s if c.isalpha()]\n    B = [c for c in s if c.isdigit()]\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)",
      "title": "1417. Reformat The String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3aff618f-44a1-461e-81cc-ccd1d1391b9a",
      "code": "class Solution:\n  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n    CROAK = 'croak'\n    ans = 0\n    frogs = 0\n    count = [0] * 5\n\n    for c in croakOfFrogs:\n      count[CROAK.index(c)] += 1\n      if any(count[i] > count[i - 1] for i in range(1, 5)):\n        return -1\n      if c == 'c':\n        frogs += 1\n      elif c == 'k':\n        frogs -= 1\n      ans = max(ans, frogs)\n\n    return ans if frogs == 0 else -1",
      "title": "1419. Minimum Number of Frogs Croaking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79a7824d-e5fd-423d-b57a-32f8bea0962e",
      "code": "class Solution:\n  def numOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of ways to build an array of length i, where j\n    # is the maximum number and k is the `search_cost`\n    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n    # prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j\n    prefix = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n\n    for j in range(1, m + 1):\n      dp[1][j][1] = 1\n      prefix[1][j][1] = j\n\n    for i in range(2, n + 1):  # for each length\n      for j in range(1, m + 1):  # for each max value\n        for cost in range(1, k + 1):  # for each cost\n          # 1. Appending any of [1, j] in the i-th position doesn't change the\n          #    maximum and cost.\n          # 2. Appending j in the i-th position makes j the new max and cost 1.\n          dp[i][j][cost] = (j * dp[i - 1][j][cost] +\n                            prefix[i - 1][j - 1][cost - 1]) % MOD\n          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % MOD\n\n    return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD",
      "title": "1420. Build Array Where You Can Find The Maximum Exactly K Comparisons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e2f45ff-7a7e-4e88-9753-5ff9ef1509fe",
      "code": "class Solution:\n  def maxScore(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n    ones = s.count('1')\n\n    for i in range(len(s) - 1):\n      if s[i] == '0':\n        zeros += 1\n      else:\n        ones -= 1\n      ans = max(ans, zeros + ones)\n\n    return ans",
      "title": "1422. Maximum Score After Splitting a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "649e4b9d-6d2c-492d-bc97-40b1b5eede80",
      "code": "class Solution:\n  def maxScore(self, cardPoints: list[int], k: int) -> int:\n    n = len(cardPoints)\n    summ = sum(cardPoints)\n    windowSum = sum(cardPoints[:n - k])\n    ans = summ - windowSum\n\n    for i in range(k):\n      windowSum -= cardPoints[i]\n      windowSum += cardPoints[i + n - k]\n      ans = max(ans, summ - windowSum)\n\n    return ans",
      "title": "1423. Maximum Points You Can Obtain from Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43eba4c4-0a59-4b65-972b-bdf6f6dbc3a4",
      "code": "class Solution:\n  def constrainedSubsetSum(self, nums: list[int], k: int) -> int:\n    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]\n    dp = [0] * len(nums)\n    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0\n    # in decreasing order.\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if dq:\n        dp[i] = max(dq[0], 0) + num\n      else:\n        dp[i] = num\n      while dq and dq[-1] < dp[i]:\n        dq.pop()\n      dq.append(dp[i])\n      if i >= k and dp[i - k] == dq[0]:\n        dq.popleft()\n\n    return max(dp)",
      "title": "1425. Constrained Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7664d60-5e67-4b64-93a8-8e9a90233794",
      "code": "class Solution:\n  def countElements(self, arr: list[int]) -> int:\n    count = collections.Counter(arr)\n    return sum(freq\n               for a, freq in count.items()\n               if count[a + 1] > 0)",
      "title": "1426. Counting Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "092b6bc2-9266-4911-ab7a-cd56abaf9465",
      "code": "class Solution:\n  def stringShift(self, s: str, shift: list[list[int]]) -> str:\n    move = 0\n\n    for direction, amount in shift:\n      if direction == 0:\n        move -= amount\n      else:\n        move += amount\n\n    move %= len(s)\n    return s[-move:] + s[:-move]",
      "title": "1427. Perform String Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f251434-0fbf-42df-9cf0-8636bddf0da9",
      "code": "# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class BinaryMatrix(object):\n#   def get(self, row: int, col: int) -> int:\n#   def dimensions(self) -> list[int]:\n\nclass Solution:\n  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:\n    m, n = binaryMatrix.dimensions()\n    ans = -1\n    l = 0\n    r = n - 1\n\n    while l <= r:\n      mid = (l + r) // 2\n      if any(binaryMatrix.get(i, mid) for i in range(m)):\n        ans = mid\n        r = mid - 1\n      else:\n        l = mid + 1\n\n    return ans",
      "title": "1428. Leftmost Column with at Least a One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c40c240-77ba-4c76-b23f-8edb0958a15b",
      "code": "class Solution:\n  def isValidSequence(self, root: TreeNode | None, arr: list[int]) -> bool:\n    def isValidSequence(root: TreeNode | None, i: int) -> bool:\n      if not root:\n        return False\n      if i == len(arr) - 1:\n        return root.val == arr[i] and not root.left and not root.right\n      return root.val == arr[i] and (\n          isValidSequence(root.left, i + 1) or\n          isValidSequence(root.right, i + 1))\n\n    return isValidSequence(root, 0)",
      "title": "1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06b08707-158c-4736-b531-202ad3b9640d",
      "code": "class Solution:\n  def kidsWithCandies(\n      self,\n      candies: list[int],\n      extraCandies: int,\n  ) -> list[bool]:\n    maxCandy = max(candies)\n    return [candy + extraCandies >= maxCandy for candy in candies]",
      "title": "1431. Kids With the Greatest Number of Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0634da69-3d6d-4451-a957-52c83ca9a7c8",
      "code": "class Solution:\n  def maxDiff(self, num: int) -> int:\n    s = str(num)\n\n    def firstNot(s: str, t: str) -> int:\n      for i, c in enumerate(s):\n        if all(c != d for d in t):\n          return i\n      return 0\n\n    firstNot9 = firstNot(s, '9')\n    firstNot01 = firstNot(s, '01')\n    a = s.replace(s[firstNot9], '9')\n    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')\n    return int(a) - int(b)",
      "title": "1432. Max Difference You Can Get From Changing an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcf3c8eb-7cc8-49a6-a251-6105cc654124",
      "code": "class Solution:\n  def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n    count1 = collections.Counter(s1)\n    count2 = collections.Counter(s2)\n\n    def canBreak(count1: dict[str, int], count2: dict[str, int]) -> bool:\n      \"\"\"Returns True if count1 can break count2.\"\"\"\n      diff = 0\n      for c in string.ascii_lowercase:\n        diff += count2[c] - count1[c]\n        # count2 is alphabetically greater than count1.\n        if diff < 0:\n          return False\n      return True\n\n    return canBreak(count1, count2) or canBreak(count2, count1)",
      "title": "1433. Check If a String Can Break Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0722d3f1-94ca-41ae-860b-e6f77e8979fc",
      "code": "class Solution:\n  def destCity(self, paths: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for a, b in paths:\n      count[a] += 1\n\n    for a, b in paths:\n      if b in count:\n        count[b] -= 1\n        if count[b] == 0:\n          del count[b]\n      else:\n        return b",
      "title": "1436. Destination City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63db2d23-610d-4882-aa30-87b91d2685fe",
      "code": "class Solution:\n  def kLengthApart(self, nums: list[int], k: int) -> bool:\n    if k == 0:\n      return True\n\n    n = len(nums)\n    curr = 0\n    next = 1\n\n    while curr < n and next < n:\n      if nums[next] == 1:\n        if nums[curr] == 1 and next - curr <= k:\n          return False\n        curr = next\n      next += 1\n\n    return True",
      "title": "1437. Check If All 1's Are at Least Length K Places Away",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5f76ce9-7a76-428c-af3c-8d79696c15b8",
      "code": "class Solution:\n  def buildArray(self, target: list[int], n: int) -> list[str]:\n    ans = []\n    i = 0  # Target pointer\n    num = 1  # Curr num\n\n    while i < len(target):\n      t = target[i]\n      if t == num:\n        ans.append('Push')\n        i += 1\n      else:\n        ans.append('Push')\n        ans.append('Pop')\n      num += 1\n\n    return ans",
      "title": "1441. Build an Array With Stack Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e6247a6-94b3-4976-98a4-37ba0250dd7c",
      "code": "class Solution:\n  def countTriplets(self, arr: list[int]) -> int:\n    ans = 0\n    xors = [0]\n    prefix = 0\n\n    for i, a in enumerate(arr):\n      prefix ^= a\n      xors.append(prefix)\n\n    for j in range(1, len(arr)):\n      for i in range(0, j):\n        xors_i = xors[j] ^ xors[i]\n        for k in range(j, len(arr)):\n          xors_k = xors[k + 1] ^ xors[j]\n          if xors_i == xors_k:\n            ans += 1\n\n    return ans",
      "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd7a853a-6437-4cce-b31d-2688db5c8dae",
      "code": "class Solution:\n  def ways(self, pizza: list[str], k: int) -> int:\n    MOD = 1_000_000_007\n    M = len(pizza)\n    N = len(pizza[0])\n    prefix = [[0] * (N + 1) for _ in range(M + 1)]\n\n    for i in range(M):\n      for j in range(N):\n        prefix[i + 1][j + 1] = ((pizza[i][j] == 'A') + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def hasApple(row1: int, row2: int, col1: int, col2: int) -> bool:\n      \"\"\"Returns True if pizza[row1..row2)[col1..col2) has apple.\"\"\"\n      return (prefix[row2][col2] - prefix[row1][col2] -\n              prefix[row2][col1] + prefix[row1][col1]) > 0\n\n    @functools.lru_cache(None)\n    def dp(m: int, n: int, k: int) -> int:\n      \"\"\"Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.\"\"\"\n      if k == 0:\n        return 1 if hasApple(m, M, n, N) else 0\n\n      res = 0\n\n      for i in range(m + 1, M):  # Cut horizontally.\n        if hasApple(m, i, n, N) and hasApple(i, M, n, N):\n          res += dp(i, n, k - 1)\n\n      for j in range(n + 1, N):  # Cut vertically.\n        if hasApple(m, M, n, j) and hasApple(m, M, j, N):\n          res += dp(m, j, k - 1)\n\n      return res % MOD\n\n    return dp(0, 0, k - 1)",
      "title": "1444. Number of Ways of Cutting a Pizza",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b17f8659-23ca-4239-b44f-0d0ab64c0212",
      "code": "class Solution:\n  def maxPower(self, s: str) -> int:\n    ans = 1\n    count = 1\n\n    for i in range(1, len(s)):\n      count = count + 1 if s[i] == s[i - 1] else 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "1446. Consecutive Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39647a33-b8e5-4232-9832-da80a50b2496",
      "code": "class Solution:\n  def simplifiedFractions(self, n: int) -> list[str]:\n    ans = []\n    for denominator in range(2, n + 1):\n      for numerator in range(1, denominator):\n        if math.gcd(denominator, numerator) == 1:\n          ans.append(str(numerator) + '/' + str(denominator))\n    return ans",
      "title": "1447. Simplified Fractions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc9c23bf-8b85-4af0-add9-98669a0423ba",
      "code": "class Solution:\n  def arrangeWords(self, text: str) -> str:\n    words = text.split()\n    count = collections.defaultdict(list)\n\n    for word in words:\n      count[len(word)].append(word.lower())\n\n    c2 = OrderedDict(sorted(count.items()))\n\n    ans = []\n\n    for l in c2:\n      for word in c2[l]:\n        ans.append(word)\n\n    ans[0] = ans[0].capitalize()\n\n    return ' '.join(ans)",
      "title": "1451. Rearrange Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b84d61fa-b139-4e10-916d-2258521efa7c",
      "code": "class Solution:\n  def peopleIndexes(self, favoriteCompanies: list[list[str]]) -> list[int]:\n    ans = []\n    n = len(favoriteCompanies)\n    companies = [set(comp) for comp in favoriteCompanies]\n\n    for i in range(n):\n      find = False\n      for j in range(n):\n        if i == j:\n          continue\n        if companies[i].issubset(companies[j]):\n          find = True\n          break\n      if not find:\n        ans.append(i)\n\n    return ans",
      "title": "1452. People Whose List of Favorite Companies Is Not a Subset of Another List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5780dfbf-4a3b-44bf-a3f1-e05e02d72131",
      "code": "class Point:\n  def __init__(self, x: float, y: float):\n    self.x = x\n    self.y = y\n\n\nclass Solution:\n  def numPoints(self, darts: list[list[int]], r: int) -> int:\n    ERR = 1e-6\n    ans = 1\n    points = [Point(x, y) for x, y in darts]\n\n    def dist(p: Point, q: Point) -> float:\n      return ((p.x - q.x)**2 + (p.y - q.y)**2)**0.5\n\n    def getCircles(p: Point, q: Point) -> list[Point]:\n      if dist(p, q) - 2.0 * r > ERR:\n        return []\n      m = Point((p.x + q.x) / 2, (p.y + q.y) / 2)\n      distCM = (r**2 - (dist(p, q) / 2)**2)**0.5\n      alpha = math.atan2(p.y - q.y, q.x - p.x)\n      return [Point(m.x - distCM * math.sin(alpha), m.y - distCM * math.cos(alpha)),\n              Point(m.x + distCM * math.sin(alpha), m.y + distCM * math.cos(alpha))]\n\n    for i, j in itertools.combinations(points, 2):\n      for c in getCircles(i, j):\n        count = 0\n        for point in points:\n          if dist(c, point) - r <= ERR:\n            count += 1\n        ans = max(ans, count)\n\n    return ans",
      "title": "1453. Maximum Number of Darts Inside of a Circular Dartboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78319971-763e-495d-8878-5c5c01d47d29",
      "code": "class Solution:\n  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n    words = sentence.split()\n\n    for i, word in enumerate(words):\n      if word.startswith(searchWord):\n        return i + 1\n\n    return -1",
      "title": "1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f742ed36-6df0-4f09-acfd-59d2f6302e85",
      "code": "class Solution:\n  def maxVowels(self, s: str, k: int) -> int:\n    ans = 0\n    mx = 0\n    VOWELS = 'aeiou'\n\n    for i, c in enumerate(s):\n      if c in VOWELS:\n        mx += 1\n      if i >= k and s[i - k] in VOWELS:\n        mx -= 1\n      ans = max(ans, mx)\n\n    return ans",
      "title": "1456. Maximum Number of Vowels in a Substring of Given Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85f66454-0d21-45dd-8dfb-85010487f8c7",
      "code": "class Solution:\n  def pseudoPalindromicPaths(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        path ^= 1 << root.val\n        if path & (path - 1) == 0:\n          ans += 1\n        return\n\n      dfs(root.left, path ^ 1 << root.val)\n      dfs(root.right, path ^ 1 << root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1457. Pseudo-Palindromic Paths in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04151e99-b934-478c-bcec-12604778d2d6",
      "code": "class Solution:\n  def maxDotProduct(self, A: list[int], B: list[int]) -> int:\n    m = len(A)\n    n = len(B)\n    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)\n    # and nums2[0..j)\n    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],\n                               max(0, dp[i][j]) + A[i] * B[j])\n\n    return dp[m][n]",
      "title": "1458. Max Dot Product of Two Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd2651cd-7810-42e8-981c-1aeaab64f7ff",
      "code": "class Solution:\n  def canBeEqual(self, target: list[int], arr: list[int]) -> bool:\n    return collections.Counter(arr) == collections.Counter(target)",
      "title": "1460. Make Two Arrays Equal by Reversing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b7c3ca8-3444-4ed0-b9f6-15e65159880c",
      "code": "class Solution:\n  def hasAllCodes(self, s: str, k: int) -> bool:\n    n = 1 << k\n    if len(s) < n:\n      return False\n\n    # used[i] := True if i is a substring of `s`\n    used = [0] * n\n\n    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)\n    for i in range(k - 1, len(s)):\n      # Include the s[i].\n      windowStr = (windowStr << 1) + int(s[i])\n      # Discard the s[i - k].\n      windowStr &= n - 1\n      used[windowStr] = True\n\n    return all(u for u in used)",
      "title": "1461. Check If a String Contains All Binary Codes of Size K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dd0b762-16ba-441b-9371-85ad2c69f245",
      "code": "class Solution:\n  def checkIfPrerequisite(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    graph = [[] for _ in range(numCourses)]\n    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    # DFS from every course.\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: list[list[int]], u: int, used: list[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)",
      "title": "1462. Course Schedule IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "292bcff8-f53b-4720-96ee-8ee17d4e8a8a",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    max1 = 0\n    max2 = 0\n\n    for num in nums:\n      if num > max1:\n        max2, max1 = max1, num\n      elif num > max2:\n        max2 = num\n\n    return (max1 - 1) * (max2 - 1)",
      "title": "1464. Maximum Product of Two Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49a62cdf-bb5f-4173-a5fb-46fd043a90ad",
      "code": "class Solution:\n  def maxArea(\n      self,\n      h: int,\n      w: int,\n      horizontalCuts: list[int],\n      verticalCuts: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # the maximum gap of each direction\n    maxGapX = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(horizontalCuts) + [h]))\n    maxGapY = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(verticalCuts) + [w]))\n    return maxGapX * maxGapY % MOD",
      "title": "1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5609009-2535-420e-a80b-46431498e1f4",
      "code": "from enum import Enum\n\n\nclass BoxCase(Enum):\n  EQUAL_DISTANT_BALLS = 0\n  EQUAL_BALLS = 1\n\n\nclass Solution:\n  def getProbability(self, balls: list[int]) -> float:\n    n = sum(balls) // 2\n    fact = [1, 1, 2, 6, 24, 120, 720]\n\n    def cases(\n            i: int,\n            ballsCountA: int,\n            ballsCountB: int,\n            colorsCountA: int,\n            colorsCountB,\n            boxCase: BoxCase) -> float:\n      if ballsCountA > n or ballsCountB > n:\n        return 0\n      if i == len(balls):\n        return (1 if boxCase == BoxCase.EQUAL_BALLS\n                else colorsCountA == colorsCountB)\n\n      ans = 0.0\n\n      # balls taken from A for `balls[i]`\n      for ballsTakenA in range(balls[i] + 1):\n        ballsTakenB = balls[i] - ballsTakenA\n        newcolorsCountA = colorsCountA + (ballsTakenA > 0)\n        newcolorsCountB = colorsCountB + (ballsTakenB > 0)\n        ans += (cases(i + 1,\n                      ballsCountA + ballsTakenA,\n                      ballsCountB + ballsTakenB,\n                      newcolorsCountA, newcolorsCountB, boxCase) /\n                (fact[ballsTakenA] * fact[ballsTakenB]))\n\n      return ans\n\n    return (cases(0, 0, 0, 0, 0, BoxCase.EQUAL_DISTANT_BALLS) /\n            cases(0, 0, 0, 0, 0, BoxCase.EQUAL_BALLS))",
      "title": "1467. Probability of a Two Boxes Having The Same Number of Distinct Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fea23f3-e384-4228-9fb4-47db536e2af7",
      "code": "class Solution:\n  def shuffle(self, nums: list[int], n: int) -> list[int]:\n    ans = []\n    for a, b in zip(nums[:n], nums[n:]):\n      ans.append(a)\n      ans.append(b)\n    return ans",
      "title": "1470. Shuffle the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4c4c1c1-91bd-4637-a6a6-c08b71f77876",
      "code": "class Solution:\n  def getStrongest(self, arr: list[int], k: int) -> list[int]:\n    arr.sort()\n\n    ans = []\n    median = arr[(len(arr) - 1) // 2]\n    l = 0\n    r = len(arr) - 1\n\n    for _ in range(k):\n      if median - arr[l] > arr[r] - median:\n        ans.append(arr[l])\n        l -= 1\n      else:\n        ans.append(arr[r])\n        r += 1\n\n    return ans",
      "title": "1471. The k Strongest Values in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2a9b62b-1cfe-4392-8388-621d858c52b2",
      "code": "class Solution:\n  def deleteNodes(\n      self,\n      head: ListNode | None,\n      m: int,\n      n: int,\n  ) -> ListNode | None:\n    curr = head\n    prev = None  # prev.next == curr\n\n    while curr:\n      # Set the m-th node as `prev`.\n      for _ in range(m):\n        if not curr:\n          break\n        prev = curr\n        curr = curr.next\n      # Set the (m + n + 1)-th node as `curr`.\n      for _ in range(n):\n        if not curr:\n          break\n        curr = curr.next\n      # Delete the nodes [m + 1..n - 1].\n      prev.next = curr\n\n    return head",
      "title": "1474. Delete N Nodes After M Nodes of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b25b38f-82a7-457a-af23-eb5a254443de",
      "code": "class Solution:\n  def finalPrices(self, prices: list[int]) -> list[int]:\n    ans = prices.copy()\n    stack = []\n\n    for i, price in enumerate(prices):\n      # stack[-1] := i in the problem description.\n      while stack and prices[stack[-1]] >= price:\n        ans[stack.pop()] -= price\n      stack.append(i)\n\n    return ans",
      "title": "1475. Final Prices With a Special Discount in a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f0a2bc3-fda9-45cb-bcee-582d92653cf9",
      "code": "class Solution:\n  def runningSum(self, nums: list[int]) -> list[int]:\n    return itertools.accumulate(nums)",
      "title": "1480. Running Sum of 1d Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a848fd0-c53d-4e04-8e4a-a610d9b9f116",
      "code": "class Solution:\n  def findLeastNumOfUniqueInts(self, arr: list[int], k: int) -> int:\n    minHeap = list(collections.Counter(arr).values())\n    heapq.heapify(minHeap)\n\n    # Greedily remove the k least frequent numbers to have the least number of unique integers.\n    while k > 0:\n      k -= heapq.heappop(minHeap)\n\n    return len(minHeap) + (1 if k < 0 else 0)",
      "title": "1481. Least Number of Unique Integers after K Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4d6f8e6-349c-4376-99c3-93a057206d2d",
      "code": "class Solution:\n  def minDays(self, bloomDay: list[int], m: int, k: int) -> int:\n    if len(bloomDay) < m * k:\n      return -1\n\n    def getBouquetCount(waitingDays: int) -> int:\n      \"\"\"\n      Returns the number of bouquets (k flowers needed) can be made after the\n      `waitingDays`.\n      \"\"\"\n      bouquetCount = 0\n      requiredFlowers = k\n      for day in bloomDay:\n        if day > waitingDays:\n          # Reset `requiredFlowers` since there was not enough adjacent flowers.\n          requiredFlowers = k\n        else:\n          requiredFlowers -= 1\n          if requiredFlowers == 0:\n            # Use k adjacent flowers to make a bouquet.\n            bouquetCount += 1\n            requiredFlowers = k\n      return bouquetCount\n\n    l = min(bloomDay)\n    r = max(bloomDay)\n\n    while l < r:\n      mid = (l + r) // 2\n      if getBouquetCount(mid) >= m:\n        r = mid\n      else:\n        l = mid + 1\n\n    return l",
      "title": "1482. Minimum Number of Days to Make m Bouquets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7e708a2-22f5-4972-9b08-95f48b9f21a7",
      "code": "class Solution:\n  def xorOperation(self, n: int, start: int) -> int:\n    return functools.reduce(operator.xor,\n                            [start + 2 * i for i in range(n)])",
      "title": "1486. XOR Operation in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56037242-1d4e-4f31-bbc0-f1c722f20bae",
      "code": "class Solution:\n  def getFolderNames(self, names: list[str]) -> list[str]:\n    ans = []\n    nameToSuffix = {}\n\n    for name in names:\n      if name in nameToSuffix:\n        suffix = nameToSuffix[name] + 1\n        newName = self._getName(name, suffix)\n        while newName in nameToSuffix:\n          suffix += 1\n          newName = self._getName(name, suffix)\n        nameToSuffix[name] = suffix\n        nameToSuffix[newName] = 0\n        ans.append(newName)\n      else:\n        nameToSuffix[name] = 0\n        ans.append(name)\n\n    return ans\n\n  def _getName(self, name: str, suffix: int) -> str:\n    return name + '(' + str(suffix) + ')'",
      "title": "1487. Making File Names Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9412d9b0-066b-428e-81a6-f3d902e351e2",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def avoidFlood(self, rains: list[int]) -> list[int]:\n    ans = [-1] * len(rains)\n    lakeIdToFullDay = {}\n    emptyDays = SortedSet()  # indices of rains[i] == 0\n\n    for i, lakeId in enumerate(rains):\n      if lakeId == 0:\n        emptyDays.add(i)\n        continue\n        # The lake was full in a previous day. Greedily find the closest day\n        # to make the lake empty.\n      if lakeId in lakeIdToFullDay:\n        fullDay = lakeIdToFullDay[lakeId]\n        emptyDayIndex = emptyDays.bisect_right(fullDay)\n        if emptyDayIndex == len(emptyDays):  # Not found.\n          return []\n        # Empty the lake at this day.\n        emptyDay = emptyDays[emptyDayIndex]\n        ans[emptyDay] = lakeId\n        emptyDays.discard(emptyDay)\n      # The lake with `lakeId` becomes full at the day `i`.\n      lakeIdToFullDay[lakeId] = i\n\n    # Empty an arbitrary lake if there are remaining empty days.\n    for emptyDay in emptyDays:\n      ans[emptyDay] = 1\n\n    return ans",
      "title": "1488. Avoid Flood in The City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f822ad6-1d4e-4ef0-8f0a-3dc4886200f4",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    # Record the index information, so edges[i] := (u, v, weight, index).\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    # Sort by the weight.\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(\n            firstEdge: list[int],\n            deletedEdgeIndex: int) -> int | float:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      # Deleting the `edge` increases the weight of the MST or makes the MST\n      # invalid.\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      # If an edge can be in any MST, we can always add `edge` to the edge set.\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]",
      "title": "1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c9c3504-5bd7-4db8-a004-55c96a4320e4",
      "code": "class Solution:\n  def average(self, salary: list[int]) -> float:\n    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)",
      "title": "1491. Average Salary Excluding the Minimum and Maximum Salary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0fb1751-a09a-4301-9904-1607eb1e7811",
      "code": "class Solution:\n  def kthFactor(self, n: int, k: int) -> int:\n    # If i is a divisor of n, then n // i is also a divisor of n. So, we can\n    # find all the divisors of n by processing the numbers <= sqrt(n).\n    factor = 1\n    i = 0  # the i-th factor\n\n    while factor < math.isqrt(n):\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return factor\n      factor += 1\n\n    factor = n // factor\n    while factor >= 1:\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return n // factor\n      factor -= 1\n\n    return -1",
      "title": "1492. The kth Factor of n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72b2318c-a3da-4936-b6a3-43954346e476",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l)\n\n    return ans",
      "title": "1493. Longest Subarray of 1's After Deleting One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93556c6b-0d98-482e-be50-758cc6366e81",
      "code": "class Solution:\n  def minNumberOfSemesters(\n      self,\n      n: int,\n      relations: list[list[int]],\n      k: int,\n  ) -> int:\n    # dp[i] := the minimum number of semesters to take the courses, where i is\n    # the bitmask of the taken courses\n    dp = [n] * (1 << n)\n    # prereq[i] := bitmask of all dependencies of course i\n    prereq = [0] * n\n\n    for prevCourse, nextCourse in relations:\n      prereq[nextCourse - 1] |= 1 << prevCourse - 1\n\n    dp[0] = 0  # Don't need time to finish 0 course.\n\n    for i in range(1 << n):\n      # the bitmask of all the courses can be taken\n      coursesCanBeTaken = 0\n      # Can take the j-th course if i contains all of j's prerequisites.\n      for j in range(n):\n        if (i & prereq[j]) == prereq[j]:\n          coursesCanBeTaken |= 1 << j\n      # Don't take any course which is already taken.\n      # (i represents set of courses that are already taken)\n      coursesCanBeTaken &= ~i\n      # Enumerate every bitmask subset of `coursesCanBeTaken`.\n      s = coursesCanBeTaken\n      while s:\n        if s.bit_count() <= k:\n          # Any combination of courses (if <= k) can be taken now.\n          # i | s := combining courses taken with courses can be taken.\n          dp[i | s] = min(dp[i | s], dp[i] + 1)\n        s = (s - 1) & coursesCanBeTaken\n\n    return dp[-1]",
      "title": "1494. Parallel Courses II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf8fa53-b7e0-48dc-9800-d742723227f1",
      "code": "class Solution:\n  def canArrange(self, arr: list[int], k: int) -> bool:\n    count = [0] * k\n\n    for a in arr:\n      a %= k\n      count[a if a >= 0 else a + k] += 1\n\n    return (count[0] % 2 == 0 and\n            all(count[i] == count[k - i]\n                for i in range(1, k // 2 + 1)))",
      "title": "1497. Check If Array Pairs Are Divisible by k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df34b370-ec6e-4aac-8c3b-dd02917c334b",
      "code": "class Solution:\n  def numSubseq(self, nums: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    l = 0\n    r = n - 1\n    while l <= r:\n      if nums[l] + nums[r] <= target:\n        ans += pow(2, r - l, MOD)\n        l += 1\n      else:\n        r -= 1\n\n    return ans % MOD",
      "title": "1498. Number of Subsequences That Satisfy the Given Sum Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ab975c0-4683-4ac6-8417-6cff53e21ce3",
      "code": "class Solution:\n  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:\n    ans = -math.inf\n    maxQ = collections.deque()  # (y - x, x)\n\n    for x, y in points:\n      # Remove the invalid points, xj - xi > k\n      while maxQ and x - maxQ[0][1] > k:\n        maxQ.popleft()\n      if maxQ:\n        ans = max(ans, x + y + maxQ[0][0])\n      # Remove the points that contribute less value and have a bigger x.\n      while maxQ and y - x >= maxQ[-1][0]:\n        maxQ.pop()\n      maxQ.append((y - x, x))\n\n    return ans",
      "title": "1499. Max Value of Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e773c5f-0262-453b-8725-2b9718d05d19",
      "code": "class Solution:\n  def numSubmat(self, mat: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(mat[0])\n\n    for row in mat:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n      ans += self._count(hist)\n\n    return ans\n\n  def _count(self, hist: list[int]) -> int:\n    # submatrices[i] := the number of submatrices, where the i-th column is the\n    # right border\n    submatrices = [0] * len(hist)\n    stack = []\n\n    for i, h in enumerate(hist):\n      while stack and hist[stack[-1]] >= h:\n        stack.pop()\n      if stack:\n        prevIndex = stack[-1]\n        submatrices[i] = submatrices[prevIndex] + h * (i - prevIndex)\n      else:\n        submatrices[i] = h * (i + 1)\n      stack.append(i)\n\n    return sum(submatrices)",
      "title": "1504. Count Submatrices With All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "549c2520-ca76-47f7-aa51-49684bf1007f",
      "code": "class Solution:\n  def findRoot(self, tree: list['Node']) -> 'Node':\n    sum = 0\n\n    for node in tree:\n      sum ^= node.val\n      for child in node.children:\n        sum ^= child.val\n\n    for node in tree:\n      if node.val == sum:\n        return node",
      "title": "1506. Find Root of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "332e1fe6-3631-4248-9384-151fc14a3e04",
      "code": "class Solution:\n  def reformatDate(self, date: str) -> str:\n    monthToNumString = {\n        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',\n        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',\n        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',\n    }\n    day, month, year = date.split()\n    day = day[:-2] if len(day) == 4 else '0' + day[:-2]\n    return f'{year}-{monthToNumString[month]}-{day}'",
      "title": "1507. Reformat Date",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "174fb63a-4695-4016-b29c-ea51be38138d",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 5:\n      return 0\n\n    ans = math.inf\n\n    nums.sort()\n\n    # 1. Change nums[0..i) to nums[i].\n    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].\n    for i in range(4):\n      ans = min(ans, nums[n - 4 + i] - nums[i])\n\n    return ans",
      "title": "1509. Minimum Difference Between Largest and Smallest Value in Three Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a84ddf1-2650-4da8-b436-36085c054454",
      "code": "class Solution:\n  def maxProbability(\n      self,\n      n: int,\n      edges: list[list[int]],\n      succProb: list[float],\n      start: int,\n      end: int,\n  ) -> float:\n    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}\n    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)\n    seen = [False] * n\n\n    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):\n      graph[u].append((v, prob))\n      graph[v].append((u, prob))\n\n    while maxHeap:\n      prob, u = heapq.heappop(maxHeap)\n      prob *= -1\n      if u == end:\n        return prob\n      if seen[u]:\n        continue\n      seen[u] = True\n      for nextNode, edgeProb in graph[u]:\n        if seen[nextNode]:\n          continue\n        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))\n\n    return 0",
      "title": "1514. Path with Maximum Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83e49272-0d50-4c92-a793-d7e54b7bcdcb",
      "code": "class Solution:\n  def getMinDistSum(self, positions: list[list[int]]) -> float:\n    def distSum(a: float, b: float) -> float:\n      return sum(math.sqrt((a - x)**2 + (b - y)**2)\n                 for x, y in positions)\n\n    ERR = 1e-6\n    currX = 50\n    currY = 50\n    ans = distSum(currX, currY)\n    step = 1\n\n    while step > ERR:\n      shouldDecreaseStep = True\n      for dx, dy in [(0, step), (0, -step), (step, 0), (-step, 0)]:\n        x = currX + dx\n        y = currY + dy\n        newDistSum = distSum(x, y)\n        if newDistSum < ans:\n          ans = newDistSum\n          currX = x\n          currY = y\n          shouldDecreaseStep = False\n      if shouldDecreaseStep:\n        step /= 10\n\n    return ans",
      "title": "1515. Best Position for a Service Centre",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f8fb6db-5cef-4d9d-aa6d-2048561b5b90",
      "code": "class Solution:\n  def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':\n    if p in q.children:\n      return root\n\n    # Create a dummy Node for the case when root == p\n    dummy = Node(None, [root])\n\n    # Get each parent of p and q\n    pParent = self._getParent(dummy, p)\n    qParent = self._getParent(p, q)\n\n    # Get p's original index in p's parent\n    pIndex = pParent.children.index(p)\n    pParent.children.pop(pIndex)\n\n    q.children.append(p)\n\n    # If q is in the p's subtree, qParent != None\n    if qParent:\n      qParent.children.remove(q)\n      pParent.children.insert(pIndex, q)\n\n    return dummy.children[0]\n\n  def _getParent(self, root: 'Node', target: 'Node') -> Optional['Node']:\n    for child in root.children:\n      if child == target:\n        return root\n      res = self._getParent(child, target)\n      if res:\n        return res\n    return None",
      "title": "1516. Move Sub-Tree of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6923254f-9db1-4e5e-b44c-4e22666e9b91",
      "code": "class Solution:\n  def closestToTarget(self, arr: list[int], target: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in arr:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the AND operation, the size of `dp` will be at most\n      # num.bit_count() + 1.\n      dp = {num} | {val & num for val in dp}\n      ans = min(ans, min(abs(target - val) for val in dp))\n\n    return ans",
      "title": "1521. Find a Value of a Mysterious Function Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5af541fb-a2b0-4c50-880d-a12cdcaff880",
      "code": "class Solution:\n  def diameter(self, root: 'Node') -> int:\n    ans = 0\n\n    def maxDepth(root: 'Node') -> int:\n      \"\"\"Returns the maximum depth of the subtree rooted at `root`.\"\"\"\n      nonlocal ans\n      maxSubDepth1 = 0\n      maxSubDepth2 = 0\n      for child in root.children:\n        maxSubDepth = maxDepth(child)\n        if maxSubDepth > maxSubDepth1:\n          maxSubDepth2 = maxSubDepth1\n          maxSubDepth1 = maxSubDepth\n        elif maxSubDepth > maxSubDepth2:\n          maxSubDepth2 = maxSubDepth\n      ans = max(ans, maxSubDepth1 + maxSubDepth2)\n      return 1 + maxSubDepth1\n\n    maxDepth(root)\n    return ans",
      "title": "1522. Diameter of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11386e5f-662f-4da7-bfd5-8e5bf57061d0",
      "code": "class Solution:\n  def numSplits(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    seen = set()\n    prefix = [0] * n\n    suffix = [0] * n\n\n    for i in range(n):\n      seen.add(s[i])\n      prefix[i] = len(seen)\n\n    seen.clear()\n\n    for i in reversed(range(n)):\n      seen.add(s[i])\n      suffix[i] = len(seen)\n\n    for i in range(n - 1):\n      if prefix[i] == suffix[i + 1]:\n        ans += 1\n\n    return ans",
      "title": "1525. Number of Good Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb3aa663-a14f-4ded-8b1b-a6dc405d1e50",
      "code": "class Solution:\n  def minNumberOperations(self, target: list[int]) -> int:\n    ans = target[0]\n\n    for a, b in zip(target, target[1:]):\n      if a < b:\n        ans += b - a\n\n    return ans",
      "title": "1526. Minimum Number of Increments on Subarrays to Form a Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44cc37c8-12a6-4fd0-8e03-1674603fdf7d",
      "code": "class Solution:\n  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n    def getLength(maxFreq: int) -> int:\n      \"\"\"Returns the length to compress `maxFreq`.\"\"\"\n      if maxFreq == 1:\n        return 1  # c\n      if maxFreq < 10:\n        return 2  # [1-9]c\n      if maxFreq < 100:\n        return 3  # [1-9][0-9]c\n      return 4    # [1-9][0-9][0-9]c\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the length of optimal dp of s[i..n) with at most k deletion.\"\"\"\n      if k < 0:\n        return math.inf\n      if i == len(s) or len(s) - i <= k:\n        return 0\n\n      ans = math.inf\n      maxFreq = 0  # the maximum frequency in s[i..j]\n      count = collections.Counter()\n\n      # Make letters in s[i..j] be the same.\n      # Keep the letter that has the maximum frequency in this range and remove\n      # the other letters.\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        maxFreq = max(maxFreq, count[s[j]])\n        ans = min(ans, getLength(maxFreq) +\n                  dp(j + 1, k - (j - i + 1 - maxFreq)))\n\n      return ans\n\n    return dp(0, k)",
      "title": "1531. String Compression II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6d78729-4a9b-4058-ae91-ab666c681ac2",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# # Returns the length of the array\n#   def length(self) -> int:\n#\n\n\nclass Solution:\n  def getIndex(self, reader: 'ArrayReader') -> int:\n    l = 0\n    r = reader.length() - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if (r - l) % 2 == 0:\n        res = reader.compareSub(l, m - 1, m + 1, r)\n        if res == 0:\n          return m\n        if res == 1:\n          r = m - 1\n        else:  # res == -1\n          l = m + 1\n      else:\n        res = reader.compareSub(l, m, m + 1, r)\n        # res is either 1 or -1.\n        if res == 1:\n          r = m\n        else:  # res == -1\n          l = m + 1\n\n    return l",
      "title": "1533. Find the Index of the Large Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7b25e7c-ced3-45d7-bf74-ccecafc84838",
      "code": "class Solution:\n  def countGoodTriplets(self, arr: list[int], a: int, b: int, c: int) -> int:\n    return sum(abs(arr[i] - arr[j]) <= a and\n               abs(arr[j] - arr[k]) <= b and\n               abs(arr[i] - arr[k]) <= c\n               for i, j, k in itertools.combinations(range(len(arr)), 3))",
      "title": "1534. Count Good Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "563f7470-46cd-4cea-a8f3-93799428e082",
      "code": "class Solution:\n  def getWinner(self, arr: list[int], k: int) -> int:\n    ans = arr[0]\n    wins = 0\n\n    i = 1\n    while i < len(arr) and wins < k:\n      if arr[i] > ans:\n        ans = arr[i]\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "1535. Find the Winner of an Array Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00d1d35e-2968-4be6-bcb7-b3badff28aef",
      "code": "class Solution:\n  def minSwaps(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # suffixZeros[i] := the number of suffix zeros in the i-th row\n    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]\n\n    for i in range(n):\n      neededZeros = n - 1 - i\n      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).\n      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)\n      if j == -1:\n        return -1\n      # Move the rows[j] to the rows[i].\n      for k in range(j, i, -1):\n        suffixZeros[k] = suffixZeros[k - 1]\n      ans += j - i\n\n    return ans",
      "title": "1536. Minimum Swaps to Arrange a Binary Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a295041a-3221-4657-a03a-5b0ed66f43ac",
      "code": "class Solution:\n  def maxSum(self, nums1: list[int], nums2: list[int]) -> int:\n    # Keep the running the sum of `nums1` and `nums2` before the next rendezvous.\n    # Since `nums1` and `nums2` are increasing, move forward on the smaller one\n    # to ensure we don't miss any rendezvous. When meet rendezvous, choose the\n    # better path.\n    ans = 0\n    sum1 = 0  # sum(nums1) in (the prevoious rendezvous, the next rendezvous)\n    sum2 = 0  # sum(nums2) in (the prevoious rendezvous, the next rendezvous)\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] < nums2[j]:\n        sum1 += nums1[i]\n        i += 1\n      elif nums1[i] > nums2[j]:\n        sum2 += nums2[j]\n        j += 1\n      else:  # An rendezvous happens.\n        ans += max(sum1, sum2) + nums1[i]\n        sum1 = 0\n        sum2 = 0\n        i += 1\n        j += 1\n\n    while i < len(nums1):\n      sum1 += nums1[i]\n      i += 1\n\n    while j < len(nums2):\n      sum2 += nums2[j]\n      j += 1\n\n    return (ans + max(sum1, sum2)) % (10**9 + 7)",
      "title": "1537. Get the Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb8a45df-ad28-433f-8b6e-79879fd38714",
      "code": "# \"\"\"\n# This is the ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n#   # Compares 4 different elements in the array\n#   # Returns 4 if the values of the 4 elements are the same (0 or 1).\n#   # Returns 2 if three elements have a value equal to 0 and one element has\n#   #           value equal to 1 or vice versa.\n#   # Returns 0 if two element have a value equal to 0 and two elements have a\n#   #           value equal to 1.\n#   def query(self, a: int, b: int, c: int, d: int) -> int:\n#\n#   # Returns the length of the array\n#   def length(self) -> int:\n#\n\nclass Solution:\n  def guessMajority(self, reader: 'ArrayReader') -> int:\n    n = reader.length()\n    query0123 = reader.query(0, 1, 2, 3)\n    query1234 = reader.query(1, 2, 3, 4)\n    zeros = 1  # the number of numbers that are same as `nums[0]`\n    nonZeros = 0  # the number of numbers that are different from `nums[0]`\n    indexNot0 = -1  # any index i s.t. nums[i] != nums[0]\n\n    # Find which group nums[1..3] belong to.\n    for i in range(1, 4):\n      abcd = [0] + [num for num in [1, 2, 3] if num != i] + [4]\n      if reader.query(*abcd) == query1234:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    # Find which group nums[4..n) belong to.\n    for i in range(4, n):\n      if reader.query(1, 2, 3, i) == query0123:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    if zeros == nonZeros:\n      return -1\n    if zeros > nonZeros:\n      return 0\n    return indexNot0",
      "title": "1538. Guess the Majority in a Hidden Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0eeeaac-8915-4604-a257-5259a752f001",
      "code": "class Solution:\n  def canConvertString(self, s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n      return False\n\n    # e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\n    # 1. a -> b, need 1 move.\n    # 2. a -> b, need 1 + 26 moves.\n    # 3. b -> c, need 1 + 26 * 2 moves.\n    shiftCount = [0] * 26\n\n    for a, b in zip(s, t):\n      shift = (ord(b) - ord(a) + 26) % 26\n      if shift == 0:\n        continue\n      if shift + 26 * shiftCount[shift] > k:\n        return False\n      shiftCount[shift] += 1\n\n    return True",
      "title": "1540. Can Convert String in K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "899a45c9-fa7c-46d8-ab1d-15c02894b37d",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    neededRight = 0   # Increment by 2 for each '('.\n    missingLeft = 0   # Increment by 1 for each missing '('.\n    missingRight = 0  # Increment by 1 for each missing ')'.\n\n    for c in s:\n      if c == '(':\n        if neededRight % 2 == 1:\n          # e.g. '()(...'\n          missingRight += 1\n          neededRight -= 1\n        neededRight += 2\n      else:  # c == ')'\n        neededRight -= 1\n        if neededRight < 0:\n          # e.g. '()))...'\n          missingLeft += 1\n          neededRight += 2\n\n    return neededRight + missingLeft + missingRight",
      "title": "1541. Minimum Insertions to Balance a Parentheses String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d659b4-1362-445d-b133-5ddf2c60463b",
      "code": "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = [len(s)] * 1024\n    prefixToIndex[0] = -1\n\n    for i, c in enumerate(s):\n      prefix ^= 1 << int(c)\n      ans = max(ans, i - prefixToIndex[prefix])\n      for j in range(10):\n        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])\n      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)\n\n    return ans",
      "title": "1542. Find Longest Awesome Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbf3babb-3324-4e2d-a3ef-7d9f74fff17c",
      "code": "class Solution:\n  def makeGood(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if ans and self._is_bad_pair(ans[-1], c):\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)\n\n  def _is_bad_pair(self, a: str, b: str) -> bool:\n    return a != b and a.lower() == b.lower()",
      "title": "1544. Make The String Great",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6ac41b2-7333-42cb-8236-73eeff26003c",
      "code": "class Solution:\n  def findKthBit(self, n: int, k: int) -> str:\n    if n == 1:\n      return '0'\n    midIndex = pow(2, n - 1)  # 1-indexed\n    if k == midIndex:\n      return '1'\n    if k < midIndex:\n      return self.findKthBit(n - 1, k)\n    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'",
      "title": "1545. Find Kth Bit in Nth Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec35ca7a-3396-4f34-b908-f8aa454e8cd3",
      "code": "class Solution:\n  def maxNonOverlapping(self, nums: list[int], target: int) -> int:\n    # Ending the subarray ASAP always has a better result.\n    ans = 0\n    prefix = 0\n    prefixes = {0}\n\n    # Greedily find the subarrays that equal to the target.\n    for num in nums:\n      # Check if there is a subarray ends in here and equals to the target.\n      prefix += num\n      if prefix - target in prefixes:\n        # Find one and discard all the prefixes that have been used.\n        ans += 1\n        prefix = 0\n        prefixes = {0}\n      else:\n        prefixes.add(prefix)\n\n    return ans",
      "title": "1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54fa4c15-b269-4113-a991-f96f998c6741",
      "code": "class Solution:\n  def minCost(self, n: int, cuts: list[int]) -> int:\n    arr = sorted([0] + cuts + [n])\n\n    dp = [[0] * len(arr) for _ in range(len(arr))]\n\n    for d in range(2, len(arr)):\n      for i in range(len(arr) - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], arr[j] - arr[i] + dp[i][k] + dp[k][j])\n\n    return dp[0][len(arr) - 1]",
      "title": "1547. Minimum Cost to Cut a Stick",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cee68cf-4465-4d05-9151-85b5cc7074cb",
      "code": "class Solution:\n  def mostSimilar(self, n: int, roads: list[list[int]], names: list[str],\n                  targetPath: list[str]) -> list[int]:\n    # cost[i][j] := the minimum cost to start from names[i] in path[j]\n    cost = [[-1] * len(targetPath) for _ in range(len(names))]\n    # next[i][j] := the best next of names[i] in path[j]\n    next = [[0] * len(targetPath) for _ in range(len(names))]\n    graph = [[] for _ in range(n)]\n\n    for u, v in roads:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    minDist = math.inf\n    start = 0\n\n    def dfs(nameIndex: int, pathIndex: int) -> int:\n      if cost[nameIndex][pathIndex] != -1:\n        return cost[nameIndex][pathIndex]\n\n      editDist = names[nameIndex] != targetPath[pathIndex]\n      if pathIndex == len(targetPath) - 1:\n        return editDist\n\n      minDist = math.inf\n\n      for v in graph[nameIndex]:\n        dist = dfs(v, pathIndex + 1)\n        if dist < minDist:\n          minDist = dist\n          next[nameIndex][pathIndex] = v\n\n      cost[nameIndex][pathIndex] = editDist + minDist\n      return editDist + minDist\n\n    for i in range(n):\n      dist = dfs(i, 0)\n      if dist < minDist:\n        minDist = dist\n        start = i\n\n    ans = []\n\n    while len(ans) < len(targetPath):\n      ans.append(start)\n      start = next[start][len(ans) - 1]\n\n    return ans",
      "title": "1548. The Most Similar Path in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6eeed92-cfb7-4fac-878c-935c06984112",
      "code": "class Solution:\n  def threeConsecutiveOdds(self, arr: list[int]) -> bool:\n    count = 0\n    for a in arr:\n      count = 0 if a % 2 == 0 else count + 1\n      if count == 3:\n        return True\n    return False",
      "title": "1550. Three Consecutive Odds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68fa595a-a4eb-48ec-8f79-435630775e3c",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    def arr(self, i: int) -> int:\n      \"\"\"Returns the i-th element of `arr`, where 1 <= i <= n.\"\"\"\n      return (i - 1) * 2 + 1\n\n    #     median := median of arr\n    #   diffs[i] := median - arr[i] where i <= i <= n // 2\n    #        ans := sum(diffs)\n    # e.g.\n    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n    #        ans = (4 + 2) * 2 // 2 = 6\n    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n    #        ans = (5 + 1) * 3 // 2 = 9\n    halfSize = n // 2\n    median = (arr(n) + arr(1)) // 2\n    firstDiff = median - arr(1)\n    lastDiff = median - arr(halfSize)\n    return (firstDiff + lastDiff) * halfSize // 2",
      "title": "1551. Minimum Operations to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c5ad61d-e331-4d47-b42b-9110b08e09a6",
      "code": "class Solution:\n  def maxDistance(self, position: list[int], m: int) -> int:\n    position.sort()\n\n    l = 1\n    r = position[-1] - position[0]\n\n    def numBalls(force: int) -> int:\n      balls = 0\n      prevPosition = -force\n      for pos in position:\n        if pos - prevPosition >= force:\n          balls += 1\n          prevPosition = pos\n      return balls\n\n    while l < r:\n      mid = r - (r - l) // 2\n      if numBalls(mid) >= m:\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "1552. Magnetic Force Between Two Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dafecd7-f704-4f0b-abfb-57b871654591",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def minDays(self, n: int) -> int:\n    if n <= 1:\n      return n\n    return 1 + min(self.minDays(n // 3) + n % 3,\n                   self.minDays(n // 2) + n % 2)",
      "title": "1553. Minimum Number of Days to Eat N Oranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f595cddd-be44-471d-afd4-820cd957a9be",
      "code": "class Solution:\n  def differByOne(self, dict: list[str]) -> bool:\n    BASE = 26\n    HASH = 1_000_000_007\n    m = len(dict[0])\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    def getHash(s: str) -> int:\n      \"\"\"Returns the hash of `s`. Assume the length of `s` is m.\n\n      e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].\n      \"\"\"\n      hash = 0\n      for c in s:\n        hash = (hash * BASE + val(c))\n      return hash\n\n    wordToHash = [getHash(word) for word in dict]\n\n    # Compute the hash without each letter.\n    # e.g. hash of \"abc\" = 26^2 * 'a' + 26 * 'b' + 'c'\n    #   newHash of \"a*c\" = hash - 26 * 'b'\n    coefficient = 1\n    for j in range(m - 1, -1, -1):\n      newHashToIndices = collections.defaultdict(list)\n      for i, (word, hash) in enumerate(zip(dict, wordToHash)):\n        newHash = (hash - coefficient * val(word[j]) % HASH + HASH) % HASH\n        if any(word[: j] == dict[index][: j] and word[j + 1:] ==\n               dict[index][j + 1:] for index in newHashToIndices[newHash]):\n          return True\n        newHashToIndices[newHash].append(i)\n      coefficient = coefficient * BASE % HASH\n\n    return False",
      "title": "1554. Strings Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ecc49ec-a7d3-43fa-a57a-f741ce6b899a",
      "code": "class Solution:\n  def thousandSeparator(self, n: int) -> str:\n    return f'{n:,}'.replace(',', '.')",
      "title": "1556. Thousand Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b41ecab2-a5e9-4780-bfeb-7d9b1c44269a",
      "code": "class Solution:\n  def findSmallestSetOfVertices(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return [i for i, d in enumerate(inDegrees) if d == 0]",
      "title": "1557. Minimum Number of Vertices to Reach All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06a91b49-967b-40e9-8435-905f2b7b96b7",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    mx = max(nums)\n    return (sum(num.bit_count() for num in nums) +\n            (0 if mx == 0 else mx.bit_length() - 1))",
      "title": "1558. Minimum Numbers of Function Calls to Make Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b0064d7-35d3-4e51-ab2d-b571b7c51911",
      "code": "class Solution:\n  def mostVisited(self, n: int, rounds: list[int]) -> list[int]:\n    # 1. if start <= end, [start, end] is the most visited.\n    #\n    #      s --------- n\n    # 1 -------------- n\n    # 1 ------ e\n    #\n    # 2. if start > end, [1, end] and [start, n] are the most visited.\n    #\n    #             s -- n\n    # 1 -------------- n\n    # 1 ------ e\n    start = rounds[0]\n    end = rounds[-1]\n    if start <= end:\n      return range(start, end + 1)\n    return list(range(1, end + 1)) + list(range(start, n + 1))",
      "title": "1560. Most Visited Sector in a Circular Track",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6ff54cf-86c2-4c2f-ae56-966cb8106171",
      "code": "class Solution:\n  def maxCoins(self, piles: list[int]) -> int:\n    return sum(sorted(piles)[len(piles) // 3::2])",
      "title": "1561. Maximum Number of Coins You Can Get",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a042358-fffd-4dda-8d9d-60abe7bf59bf",
      "code": "class Solution:\n  def findLatestStep(self, arr: list[int], m: int) -> int:\n    if len(arr) == m:\n      return len(arr)\n\n    ans = -1\n    step = 0\n    # sizes[i] := the size of the group starting from i or ending in i\n    # (1-indexed)\n    sizes = [0] * (len(arr) + 2)\n\n    for i in arr:\n      step += 1\n      # In the previous step, there exists a group with a size of m.\n      if sizes[i - 1] == m or sizes[i + 1] == m:\n        ans = step - 1\n      head = i - sizes[i - 1]\n      tail = i + sizes[i + 1]\n      sizes[head] = tail - head + 1\n      sizes[tail] = tail - head + 1\n\n    return ans",
      "title": "1562. Find Latest Group of Size M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eabf1433-10c9-42a5-ba3f-9152a4fb6572",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    realWarehouse = [warehouse[0]]\n\n    for i in range(1, len(warehouse)):\n      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))\n\n    boxes.sort()\n    i = 0  # boxes' index\n    for height in reversed(realWarehouse):\n      if i < len(boxes) and boxes[i] <= height:\n        i += 1\n\n    return i",
      "title": "1564. Put Boxes Into the Warehouse I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1b80897-21ae-404d-8079-2f6c8cb44e80",
      "code": "class Solution:\n  def containsPattern(self, arr: list[int], m: int, k: int) -> bool:\n    count = 0\n    for i in range(m, len(arr)):\n      count = count + 1 if arr[i] == arr[i - m] else 0\n      if count == m * k - m:\n        return True\n    return False",
      "title": "1566. Detect Pattern of Length M Repeated K or More Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06ec0c5a-da34-48af-a84d-6eba85cf8860",
      "code": "class Solution:\n  def getMaxLen(self, nums: list[int]) -> int:\n    ans = 0\n    # the maximum length of subarrays ending in `num` with a negative product\n    neg = 0\n    # the maximum length of subarrays ending in `num` with a positive product\n    pos = 0\n\n    for num in nums:\n      pos = 0 if num == 0 else pos + 1\n      neg = 0 if num == 0 or neg == 0 else neg + 1\n      if num < 0:\n        pos, neg = neg, pos\n      ans = max(ans, pos)\n\n    return ans",
      "title": "1567. Maximum Length of Subarray With Positive Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "570368c4-6e38-4320-9a14-c7044b3c74e5",
      "code": "class Solution:\n  def minDays(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(grid: list[list[int]], i: int, j: int, seen: set[tuple[int, int]]):\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or (x, y) in seen:\n          continue\n        dfs(grid, x, y, seen)\n\n    def disconnected(grid: list[list[int]]) -> bool:\n      islandsCount = 0\n      seen = set()\n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 0 or (i, j) in seen:\n            continue\n          if islandsCount > 1:\n            return True\n          islandsCount += 1\n          dfs(grid, i, j, seen)\n      return islandsCount != 1\n\n    if disconnected(grid):\n      return 0\n\n    # Try to remove 1 land.\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          grid[i][j] = 0\n          if disconnected(grid):\n            return 1\n          grid[i][j] = 1\n\n    # Remove 2 lands.\n    return 2",
      "title": "1568. Minimum Number of Days to Disconnect Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58ba4b6f-cb80-4195-a33e-8130ef4444d0",
      "code": "class Solution:\n  def diagonalSum(self, mat: list[list[int]]) -> int:\n    n = len(mat)\n    ans = 0\n\n    for i in range(n):\n      ans += mat[i][i]\n      ans += mat[n - 1 - i][i]\n\n    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]",
      "title": "1572. Matrix Diagonal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d13eaea2-bade-41ca-b817-4e567dbf109d",
      "code": "class Solution:\n  def numWays(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % MOD\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % MOD",
      "title": "1573. Number of Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca4f769a-1aa0-4bfd-b825-82ffbf8c1890",
      "code": "class Solution:\n  def findLengthOfShortestSubarray(self, arr: list[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    # arr[0..l] is non-decreasing.\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    # arr[r..n - 1] is non-decreasing.\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    # Remove arr[l + 1..n - 1] or arr[0..r - 1].\n    ans = min(n - 1 - l, r)\n\n    # Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers\n    # at the rightmost indices, l and n - 1, and greedily shrink them toward\n    # the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],\n    # we ensure that `arr` becomes non-decreasing.\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans",
      "title": "1574. Shortest Subarray to be Removed to Make Array Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53da0716-d8f4-4208-baaa-8449e5b04f1b",
      "code": "class Solution:\n  def countRoutes(\n      self,\n      locations: list[int],\n      start: int,\n      finish: int,\n      fuel: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(locations)\n    # dp[i][j] := the number of ways to reach the `finish` city from the i-th\n    # city with `j` fuel\n    dp = [[0] * (fuel + 1) for _ in range(n)]\n\n    for f in range(fuel + 1):\n      dp[finish][f] = 1\n\n    for f in range(fuel + 1):\n      for i in range(n):\n        for j in range(n):\n          if i == j:\n            continue\n          requiredFuel = abs(locations[i] - locations[j])\n          if requiredFuel <= f:\n            dp[i][f] += dp[j][f - requiredFuel]\n            dp[i][f] %= MOD\n\n    return dp[start][fuel]",
      "title": "1575. Count All Possible Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d17eaa2b-504d-45a2-8148-5b65fe15e94b",
      "code": "class Solution:\n  def modifyString(self, s: str) -> str:\n    ans = []\n\n    def nextAvailable(ans: list[int], s: str, i: int) -> str:\n      c = 'a'\n      while ((i > 0 and ans[i - 1] == c) or\n             (i + 1 < len(s) and c == s[i + 1])):\n        c = chr(ord(c) + 1)\n      return c\n\n    for i, c in enumerate(s):\n      if c == '?':\n        ans.append(nextAvailable(ans, s, i))\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "1576. Replace All ?'s to Avoid Consecutive Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdb166b1-be1e-4162-b8ba-adc8053a654f",
      "code": "class Solution:\n  def numTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    def countTriplets(A: list[int], B: list[int]):\n      \"\"\"Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].\"\"\"\n      res = 0\n      count = collections.Counter(B)\n\n      for a in A:\n        target = a * a\n        for b, freq in count.items():\n          if target % b > 0 or target // b not in count:\n            continue\n          if target // b == b:\n            res += freq * (freq - 1)\n          else:\n            res += freq * count[target // b]\n\n      return res // 2\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)",
      "title": "1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd9c63f8-5764-431e-a091-cb0d27a1b419",
      "code": "class Solution:\n  def minCost(self, colors: str, neededTime: list[int]) -> int:\n    ans = 0\n    maxNeededTime = neededTime[0]\n\n    for i in range(1, len(colors)):\n      if colors[i] == colors[i - 1]:\n        ans += min(maxNeededTime, neededTime[i])\n        # For each continuous group, Bob needs to remove every balloon except\n        # the one with the maximum `neededTime`. So, he should hold the balloon\n        # with the highest `neededTime` in his hand.\n        maxNeededTime = max(maxNeededTime, neededTime[i])\n      else:\n        # If the current balloon is different from the previous one, discard\n        # the balloon from the previous group and hold the new one in hand.\n        maxNeededTime = neededTime[i]\n\n    return ans",
      "title": "1578. Minimum Time to Make Rope Colorful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ecb7f92-28af-42de-a964-4254cc3aef95",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    # Greedily put type 3 edges in the front.\n    for type_, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type_ == 3:  # Can be traversed by Alice and Bob.\n          # Note that we should use | instead of or because if the first\n          # expression is True, short-circuiting will skip the second\n          # expression.\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type_ == 2:  # Can be traversed by Bob.\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:  # type == 1 Can be traversed by Alice.\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    return (len(edges) - requiredEdges\n            if alice.count == 1 and bob.count == 1\n            else -1)",
      "title": "1579. Remove Max Number of Edges to Keep Graph Fully Traversable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11a79a8a-b6b1-4bf2-9063-14c7924ace20",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    l = 0\n    r = len(warehouse) - 1\n\n    for box in sorted(boxes, reverse=True):\n      if l > r:\n        return len(warehouse)\n      if box <= warehouse[l]:\n        l += 1\n      elif box <= warehouse[r]:\n        r -= 1\n\n    return l + (len(warehouse) - r - 1)",
      "title": "1580. Put Boxes Into the Warehouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f6f7eb9-22b4-4734-abca-264a87bb97cc",
      "code": "class Solution:\n  def numSpecial(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans",
      "title": "1582. Special Positions in a Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "823cb157-166e-4f75-9014-4be02bdf208a",
      "code": "class Solution:\n  def unhappyFriends(\n      self,\n      n: int,\n      preferences: list[list[int]],\n      pairs: list[list[int]],\n  ) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans",
      "title": "1583. Count Unhappy Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59994a85-16f0-4f23-b46a-f054fbd0625b",
      "code": "class Solution:\n  def minCostConnectPoints(self, points: list[int]) -> int:\n    # dist[i] := the minimum distance to connect the points[i]\n    dist = [math.inf] * len(points)\n    ans = 0\n\n    for i in range(len(points) - 1):\n      for j in range(i + 1, len(points)):\n        # Try to connect the points[i] with the points[j].\n        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +\n                      abs(points[i][1] - points[j][1]))\n        # Swap the points[j] (the point with the mnimum distance) with the\n        # points[i + 1].\n        if dist[j] < dist[i + 1]:\n          points[j], points[i + 1] = points[i + 1], points[j]\n          dist[j], dist[i + 1] = dist[i + 1], dist[j]\n      ans += dist[i + 1]\n\n    return ans",
      "title": "1584. Min Cost to Connect All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58515b8f-65cd-443a-84c8-97917bf1793b",
      "code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    if collections.Counter(s) != collections.Counter(t):\n      return False\n\n    positions = [collections.deque() for _ in range(10)]\n\n    for i, c in enumerate(s):\n      positions[int(c)].append(i)\n\n    # For each digit in `t`, check if we can put this digit in `s` at the same\n    # position as `t`. Ensure that all the left digits are equal to or greater\n    # than it. This is because the only operation we can perform is sorting in\n    # ascending order. If there is a digit to the left that is smaller than it,\n    # we can never move it to the same position as in `t`. However, if all the\n    # digits to its left are equal to or greater than it, we can move it one\n    # position to the left until it reaches the same position as in `t`.\n    for c in t:\n      d = int(c)\n      front = positions[d].popleft()\n      for smaller in range(d):\n        if positions[smaller] and positions[smaller][0] < front:\n          return False\n\n    return True",
      "title": "1585. Check If String Is Transformable With Substring Sort Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ade904b6-8c67-4ff4-9fd6-20dc1b9e0dcf",
      "code": "class Solution:\n  def sumOddLengthSubarrays(self, arr: list[int]) -> int:\n    ans = 0\n    # Maintain two sums of subarrays ending in the previous index.\n    # Each time we meet a new number, we'll consider 'how many times' it should\n    # contribute to the newly built subarrays by calculating the number of\n    # previous even/odd-length subarrays.\n    prevEvenSum = 0  # the sum of even-length subarrays\n    prevOddSum = 0  # the sum of odd-length subarrays\n\n    for i, a in enumerate(arr):\n      # (i + 1) // 2 := the number of previous odd-length subarrays.\n      currEvenSum = prevOddSum + ((i + 1) // 2) * a\n      # i // 2 + 1 := the number of previous even-length subarrays\n      # (including 0).\n      currOddSum = prevEvenSum + (i // 2 + 1) * a\n      ans += currOddSum\n      prevEvenSum = currEvenSum\n      prevOddSum = currOddSum\n\n    return ans",
      "title": "1588. Sum of All Odd Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f5950c9-0b85-439a-9f4c-900d85eaf17a",
      "code": "class Solution:\n  def maxSumRangeQuery(self, nums: list[int], requests: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # count[i] := the number of times nums[i] has been requested\n    count = [0] * len(nums)\n\n    for start, end in requests:\n      count[start] += 1\n      if end + 1 < len(nums):\n        count[end + 1] -= 1\n\n    for i in range(1, len(nums)):\n      count[i] += count[i - 1]\n\n    for num, c in zip(sorted(nums), sorted(count)):\n      ans += num * c\n      ans %= MOD\n\n    return ans",
      "title": "1589. Maximum Sum Obtained of Any Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ff8d84c-5205-4ca9-a590-2d16d3776356",
      "code": "class Solution:\n  def minSubarray(self, nums: list[int], p: int) -> int:\n    summ = sum(nums)\n    remainder = summ % p\n    if remainder == 0:\n      return 0\n\n    ans = len(nums)\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefix %= p\n      target = (prefix - remainder + p) % p\n      if target in prefixToIndex:\n        ans = min(ans, i - prefixToIndex[target])\n      prefixToIndex[prefix] = i\n\n    return -1 if ans == len(nums) else ans",
      "title": "1590. Make Sum Divisible by P",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62f6a97b-5b76-4b66-8501-ae92c9be9b43",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: list[list[int]]) -> bool:\n    MAX_COLOR = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    # graph[u] := {v1, v2} means v1 and v2 cover u\n    graph = [set() for _ in range(MAX_COLOR + 1)]\n\n    for color in range(1, MAX_COLOR + 1):\n      # Get the rectangle of the current color.\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      # Add any color covering the current as the children.\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.INIT] * (MAX_COLOR + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not (any(hasCycle(i) for i in range(1, MAX_COLOR + 1)))",
      "title": "1591. Strange Printer II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b948b966-8936-4bed-925a-ef5c61d0b0b0",
      "code": "class Solution:\n  def connectTwoGroups(self, cost: list[list[int]]) -> int:\n    # minCosts[j] := the minimum cost of connecting group2's point j\n    minCosts = [min(col) for col in zip(*cost)]\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum cost to connect group1's points[i..n) with group2's\n      points, where `mask` is the bitmask of the connected points in group2.\n      \"\"\"\n      if i == len(cost):\n        # All the points in group 1 are connected, so greedily assign the\n        # minimum cost for the unconnected points of group2.\n        return sum(minCost for j, minCost in enumerate(minCosts)\n                   if (mask >> j & 1) == 0)\n      return min(cost[i][j] + dp(i + 1, mask | 1 << j)\n                 for j in range(len(cost[0])))\n\n    return dp(0, 0)",
      "title": "1595. Minimum Cost to Connect Two Groups of Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d4b60e4-c797-426b-8d60-e8dffb18f4aa",
      "code": "class Solution:\n  def findNearestRightNode(\n      self,\n      root: TreeNode,\n      u: TreeNode,\n  ) -> TreeNode | None:\n    ans = None\n    targetDepth = -1\n\n    def dfs(root: TreeNode, depth: int) -> None:\n      nonlocal ans\n      nonlocal targetDepth\n      if not root:\n        return\n      if root == u:\n        targetDepth = depth\n        return\n      if depth == targetDepth and not ans:\n        ans = root\n        return\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 0)\n    return ans",
      "title": "1602. Find Nearest Right Node in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a99029-3037-4e84-9f5a-a202683faf51",
      "code": "class Solution:\n  def alertNames(self, keyName: list[str], keyTime: list[str]) -> list[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    return sorted([name for name, minutes in nameToMinutes.items()\n                   if self._hasAlert(minutes)])\n\n  def _hasAlert(self, minutes: list[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1604. Alert Using Same Key-Card Three or More Times in a One Hour Period",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0d186ea-5f90-45fb-a29e-ac58b574fd1a",
      "code": "class Solution:\n  def restoreMatrix(self, rowSum: list[int],\n                    colSum: list[int]) -> list[list[int]]:\n    m = len(rowSum)\n    n = len(colSum)\n    ans = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = min(rowSum[i], colSum[j])\n        rowSum[i] -= ans[i][j]\n        colSum[j] -= ans[i][j]\n\n    return ans",
      "title": "1605. Find Valid Matrix Given Row and Column Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4710ee13-7d8f-4292-8ac5-2a2b0a88ffec",
      "code": "class Solution:\n  def specialArray(self, nums: list[int]) -> int:\n    nums.sort()\n\n    if nums[0] >= len(nums):\n      return len(nums)\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      count = len(nums) - i - 1\n      if a < count and b >= count:\n        return count\n\n    return -1",
      "title": "1608. Special Array With X Elements Greater Than or Equal X",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4eb2ff20-8870-4967-bb08-7d70fdc5811e",
      "code": "class Solution:\n  def isEvenOddTree(self, root: TreeNode | None) -> bool:\n    q = collections.deque([root])\n    isEven = True\n\n    while q:\n      prevVal = -math.inf if isEven else math.inf\n      for _ in range(sz):\n        node = q.popleft()\n        if isEven and (node.val % 2 == 0 or node.val <= prevVal):\n          return False  # invalid case on even level\n        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):\n          return False  # invalid case on odd level\n        prevVal = node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      isEven = not isEven\n\n    return True",
      "title": "1609. Even Odd Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ca6207d-2373-4a84-a0a7-8e09503d04e9",
      "code": "class Solution:\n  def visiblePoints(\n      self,\n      points: list[list[int]],\n      angle: int,\n      location: list[int],\n  ) -> int:\n    posX, posY = location\n    maxVisible = 0\n    same = 0\n    A = []\n\n    for x, y in points:\n      if x == posX and y == posY:\n        same += 1\n      else:\n        A.append(math.atan2(y - posY, x - posX))\n\n    A.sort()\n    A = A + [a + 2.0 * math.pi for a in A]\n\n    angleInRadians = math.pi * (angle / 180)\n\n    l = 0\n    for r in range(len(A)):\n      while A[r] - A[l] > angleInRadians:\n        l += 1\n      maxVisible = max(maxVisible, r - l + 1)\n\n    return maxVisible + same",
      "title": "1610. Maximum Number of Visible Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "948ef7c6-7f1e-4ecc-9d9a-88cfe354ac01",
      "code": "class Solution:\n  def minimumOneBitOperations(self, n: int) -> int:\n    # Observation: e.g. n = 2^2\n    #        100 (2^2 needs 2^3 - 1 ops)\n    # op1 -> 101\n    # op2 -> 111\n    # op1 -> 110\n    # op2 -> 010 (2^1 needs 2^2 - 1 ops)\n    # op1 -> 011\n    # op2 -> 001 (2^0 needs 2^1 - 1 ops)\n    # op1 -> 000\n    #\n    # So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\n    # also takes 2^(k + 1) - 1 ops.\n\n    # e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\n    #   - If the second bit is 1, you only need to consider the cost of turning\n    #     the last 2 bits to 0.\n    #   - If the second bit is 0, you need to add up the cost of flipping the\n    #     second bit from 0 to 1.\n    # XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\n    # Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\n    if n == 0:\n      return 0\n    # x is the largest 2^k <= n.\n    # x | x >> 1 -> x >> 1 needs 1 op.\n    #     x >> 1 -> 0      needs x = 2^k - 1 ops.\n    x = 1 << n.bit_length() - 1\n    return self.minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1",
      "title": "1611. Minimum One Bit Operations to Make Integers Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7113a97e-80ac-40e2-918c-004308bfac76",
      "code": "class Solution:\n  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n    count = collections.Counter()\n\n    def dfs(root: 'Node', add: int) -> None:\n      if not root:\n        return\n      if 'a' <= root.val <= 'z':\n        count[root.val] += add\n      dfs(root.left, add)\n      dfs(root.right, add)\n\n    dfs(root1, 1)\n    dfs(root2, -1)\n    return all(value == 0 for value in count.values())",
      "title": "1612. Check If Two Expression Trees are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed6749e7-7a85-4cab-9feb-3592ed6c66bc",
      "code": "class Solution:\n  def maxDepth(self, s: str) -> int:\n    ans = 0\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        ans = max(ans, opened)\n      elif c == ')':\n        opened -= 1\n\n    return ans",
      "title": "1614. Maximum Nesting Depth of the Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b82d1eca-55b1-4d5b-a361-02b69290c151",
      "code": "class Solution:\n  def maximalNetworkRank(self, n: int, roads: list[list[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    # Find the first maximum and the second maximum degrees.\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    # There can be multiple nodes with `maxDegree1` or `maxDegree2`.\n    # Find the counts of such nodes.\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      # 1. If there is only one node with degree = `maxDegree1`, then we'll\n      # need to use the node with degree = `maxDegree2`. The answer in general\n      # will be (maxDegree1 + maxDegree2), but if the two nodes that we're\n      # considering are connected, then we'll have to subtract 1.\n      edgeCount = (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +\n                   self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1))\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      # 2. If there are more than one node with degree = `maxDegree1`, then we\n      # can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.\n      # The answer in general will be 2 * maxDegree1, but if the two nodes that\n      # we're considering are connected, then we'll have to subtract 1.\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(\n      self,\n      roads: list[list[int]],\n      degrees: list[int],\n      degreeU: int, degreeV: int,\n  ) -> int:\n    \"\"\"\n    Returns the number of edges (u, v) where degress[u] == degreeU and\n    degrees[v] == degreeV.\n    \"\"\"\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount",
      "title": "1615. Maximal Network Rank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1997b437-2ea0-4412-b256-a6cf59784f7f",
      "code": "class Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        # a[0:i] + a[i..j] + b[j + 1:] or\n        # a[0:i] + b[i..j] + b[j + 1:]\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True",
      "title": "1616. Split Two Strings to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ee72c1e-6308-442c-8b93-153fc5aa3d52",
      "code": "class Solution:\n  def countSubgraphsForEachDiameter(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    # mask := the subset of the cities\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: list[list[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:  # u is not in the subset.\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:  # v is not in the subset.\n          continue\n        if dist[u][v] == 1:  # u and v are connected.\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    return maxDist if edgeCount == cityCount - 1 else 0",
      "title": "1617. Count Subtrees With Max Distance Between Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c589e3-452e-49df-a3cf-2a0b77b9bd30",
      "code": "# \"\"\"\n# This is FontInfo's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class FontInfo(object):\n#   Return the width of char ch when fontSize is used.\n#   def getWidth(self, fontSize: int, ch: str) -> int:\n#     pass\n#\n#   def getHeight(self, fontSize: int) -> int:\n#     pass\nclass Solution:\n  def maxFont(\n      self,\n      text: str,\n      w: int,\n      h: int,\n      fonts: list[int],\n      fontInfo: 'FontInfo',\n  ) -> int:\n    count = collections.Counter(text)\n    l = 0\n    r = len(fonts) - 1\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if fontInfo.getHeight(\n              fonts[m]) <= h and self._getWidthSum(\n              count, fonts[m],\n              fontInfo) <= w:\n        l = m\n      else:\n        r = m - 1\n\n    return fonts[l] if self._getWidthSum(count, fonts[l], fontInfo) <= w else -1\n\n  def _getWidthSum(\n      self,\n      count: list[int],\n      font: int,\n      fontInfo: 'FontInfo',\n  ) -> int:\n    width = 0\n    for c in string.ascii_lowercase:\n      width += count[c] * fontInfo.getWidth(font, c)\n    return width",
      "title": "1618. Maximum Font to Fit a Sentence in a Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07478917-2593-4242-bc3b-d81c86a9d848",
      "code": "class Solution:\n  def trimMean(self, arr: list[int]) -> float:\n    arr.sort()\n    offset = len(arr) // 20\n    return mean(arr[offset:-offset])",
      "title": "1619. Mean of Array After Removing Some Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dfb5939-9ef4-408f-96a2-9dd8c9b01447",
      "code": "class Solution:\n  def bestCoordinate(self, towers: list[list[int]], radius: int) -> list[int]:\n    MAX = 50\n    n = len(towers)\n    ans = [0] * 2\n    maxQuality = 0\n\n    def dist(tower: list[int], i: int, j: int) -> float:\n      \"\"\"Returns the distance between the tower and the coordinate.\"\"\"\n      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)\n\n    for i in range(MAX + 1):\n      for j in range(MAX + 1):\n        qualitySum = 0\n        for tower in towers:\n          q = tower[2]\n          d = dist(tower, i, j)\n          if d <= radius:\n            qualitySum += int(q / (1 + d))\n        if qualitySum > maxQuality:\n          maxQuality = qualitySum\n          ans = [i, j]\n\n    return ans",
      "title": "1620. Coordinate With Maximum Network Quality",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3cd5c00-00f8-444c-9992-4f04bc8eec28",
      "code": "class Solution:\n  def numberOfSets(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, drawing: bool) -> int:\n      if k == 0:  # Find a way to draw k segments.\n        return 1\n      if i == n:  # Reach the end.\n        return 0\n      if drawing:\n        # 1. Keep drawing at i and move to i + 1.\n        # 2. Stop at i so decrease k. We can start from i for the next segment.\n        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % MOD\n      # 1. Skip i and move to i + 1.\n      # 2. Start at i and move to i + 1.\n      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % MOD\n\n    return dp(0, k, False)",
      "title": "1621. Number of Sets of K Non-Overlapping Line Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcfe092d-dbe0-42bf-a552-a3426f0be643",
      "code": "class Solution:\n  def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n    ans = -1\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      if c not in lastSeen:\n        lastSeen[c] = i\n      else:\n        ans = max(ans, i - lastSeen[c] - 1)\n\n    return ans",
      "title": "1624. Largest Substring Between Two Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3836f44-faf9-49eb-a170-dffa71df551f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Player:\n  age: int\n  score: int\n\n\nclass Solution:\n  def bestTeamScore(self, scores: list[int], ages: list[int]) -> int:\n    n = len(scores)\n    players = [Player(age, score) for age, score in zip(ages, scores)]\n    # dp[i] := the maximum score of choosing the players[0..i] with the\n    # players[i] being selected\n    dp = [0] * n\n\n    # Sort by age descending, then by score descending\n    players.sort(key=lambda x: (-x.age, -x.score))\n\n    for i in range(n):\n      # For each player, choose it first\n      dp[i] = players[i].score\n      # players[j].age >= players[i].age since we sort in descending order.\n      # So, we only have to check that players[j].score >= players[i].score.\n      for j in range(i):\n        if players[j].score >= players[i].score:\n          dp[i] = max(dp[i], dp[j] + players[i].score)\n\n    return max(dp)",
      "title": "1626. Best Team With No Conflicts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5dbd4fa-235d-4255-b5dd-593bce428f02",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(\n      self,\n      n: int,\n      threshold: int,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]",
      "title": "1627. Graph Connectivity With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1b01569-901d-484e-a8cf-042d63586f6e",
      "code": "class Solution:\n  def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:\n    ans = keysPressed[0]\n    maxDuration = releaseTimes[0]\n\n    for i in range(1, len(keysPressed)):\n      duration = releaseTimes[i] - releaseTimes[i-1]\n      if duration > maxDuration or (\n              duration == maxDuration and keysPressed[i] > ans):\n        ans = keysPressed[i]\n        maxDuration = duration\n\n    return ans",
      "title": "1629. Slowest Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d6c7197-d2bc-4ebd-9468-60c6a3f39709",
      "code": "class Solution:\n  def checkArithmeticSubarrays(\n      self,\n      nums: list[int],\n      l: list[int],\n      r: list[int],\n  ) -> list[bool]:\n    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]\n\n  def _isArithmetic(self, nums: list[int], l: int, r: int) -> bool:\n    if r - l < 2:\n      return True\n\n    numsSet = set()\n    mn = math.inf\n    mx = -math.inf\n\n    for i in range(l, r+1):\n      mn = min(mn, nums[i])\n      mx = max(mx, nums[i])\n      numsSet.add(nums[i])\n\n    if (mx - mn) % (r - l) != 0:\n      return False\n\n    interval = (mx - mn) // (r - l)\n    return all(mn + k * interval in numsSet\n               for k in range(1, r - l + 1))",
      "title": "1630. Arithmetic Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fc9c61d-c38d-4154-bab7-0007fc9c6e64",
      "code": "class Solution:\n  def minimumEffortPath(self, heights: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    # diff[i][j] := the maximum absolute difference to reach (i, j)\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]  # (d, i, j)\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))",
      "title": "1631. Path With Minimum Effort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cfa1b04-1cab-483f-9853-2c02f4e630ff",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> dict[int, list[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    # {val: [(i, j)]}\n    valToGrids = collections.defaultdict(list)\n    # rank[i] := the maximum rank of the row or column so far\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        # Union i-th row with j-th col.\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        # Get the maximum rank of all the included rows and columns.\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          # Update all the rows and columns to maxRank + 1.\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans",
      "title": "1632. Rank Transform of a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3db39a94-65ac-4224-a722-97b87f25142e",
      "code": "# Definition for polynomial singly-linked list.\n# class PolyNode:\n#   def __init__(self, x=0, y=0, next=None):\n#     self.coefficient = x\n#     self.power = y\n#     self.next = next\n\nclass Solution:\n  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':\n    dummy = PolyNode()\n    curr = dummy\n    p = poly1  # poly1's pointer\n    q = poly2  # poly2's pointer\n\n    while p and q:\n      if p.power > q.power:\n        curr.next = PolyNode(p.coefficient, p.power)\n        curr = curr.next\n        p = p.next\n      elif p.power < q.power:\n        curr.next = PolyNode(q.coefficient, q.power)\n        curr = curr.next\n        q = q.next\n      else:  # p.power == q.power\n        sumCoefficient = p.coefficient + q.coefficient\n        if sumCoefficient != 0:\n          curr.next = PolyNode(sumCoefficient, p.power)\n          curr = curr.next\n        p = p.next\n        q = q.next\n\n    while p:\n      curr.next = PolyNode(p.coefficient, p.power)\n      curr = curr.next\n      p = p.next\n\n    while q:\n      curr.next = PolyNode(q.coefficient, q.power)\n      curr = curr.next\n      q = q.next\n\n    return dummy.next",
      "title": "1634. Add Two Polynomials Represented as Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bb659e4-e5f5-4a29-805e-61d0bac67102",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  num: int\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.num > other.num\n    return self.freq < other.freq\n\n\nclass Solution:\n  def frequencySort(self, nums: list[int]) -> list[int]:\n    ans = []\n    heap = []\n\n    for num, freq in collections.Counter(nums).items():\n      heapq.heappush(heap, T(num, freq))\n\n    while len(heap) > 0:\n      num = heap[0].num\n      freq = heapq.heappop(heap).freq\n      ans.extend([num] * freq)\n\n    return ans",
      "title": "1636. Sort Array by Increasing Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e44f4896-e79b-49b8-919c-538640dfa8ca",
      "code": "class Solution:\n  def maxWidthOfVerticalArea(self, points: list[list[int]]) -> int:\n    xs = sorted([x for x, _ in points])\n    return max(b - a for a, b in itertools.pairwise(xs))",
      "title": "1637. Widest Vertical Area Between Two Points Containing No Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64ee3db8-29ca-4922-b796-c48745abeffb",
      "code": "class Solution:\n  def countSubstrings(self, s: str, t: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      ans += self._count(s, t, i, 0)\n\n    for j in range(1, len(t)):\n      ans += self._count(s, t, 0, j)\n\n    return ans\n\n  def _count(self, s: str, t: str, i: int, j: int) -> int:\n    \"\"\"Returns the number of substrings of s[i..n) and t[j:] that differ by one char.\"\"\"\n    res = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with zero different letter\n    dp0 = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with one different letter\n    dp1 = 0\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        dp0 += 1\n      else:\n        dp0, dp1 = 0, dp0 + 1\n      res += dp1\n      i += 1\n      j += 1\n\n    return res",
      "title": "1638. Count Substrings That Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8875d07-5d02-41ab-9abb-10eb9192ef2e",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # dp[i][j] := the number of ways to form the first i characters of the\n    # `target` using the j first characters in each word\n    dp = [[0] * (wordLength + 1) for _ in range(len(target) + 1)]\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    dp[0][0] = 1\n\n    for i in range(len(target) + 1):\n      for j in range(wordLength):\n        if i < len(target):\n          # Pick the character target[i] from word[j].\n          dp[i + 1][j + 1] = dp[i][j] * counts[j][target[i]]\n          dp[i + 1][j + 1] %= MOD\n        # Skip the word[j].\n        dp[i][j + 1] += dp[i][j]\n        dp[i][j + 1] %= MOD\n\n    return dp[len(target)][wordLength]",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d1d6a41-1c9b-4f99-94b1-5402fc3634a3",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int):\n      \"\"\"Returns the number of ways to form target[i..n) using word[j..n).\"\"\"\n      if i == len(target):\n        return 1\n      if j == wordLength:\n        return 0\n      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % MOD\n\n    return dp(0, 0)",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "186c86ea-e3cb-4f2f-9b75-09dbda221706",
      "code": "class Solution:\n  def canFormArray(self, arr: list[int], pieces: list[list[int]]) -> bool:\n    concatenated = []\n    startToPiece = {piece[0]: piece for piece in pieces}\n\n    for a in arr:\n      concatenated += startToPiece.get(a, [])\n\n    return concatenated == arr",
      "title": "1640. Check Array Formation Through Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50a84a13-dd20-423d-a999-23581ef8e8bb",
      "code": "class Solution:\n  def furthestBuilding(\n      self,\n      heights: list[int],\n      bricks: int,\n      ladders: int,\n  ) -> int:\n    minHeap = []\n\n    for i, (a, b) in enumerate(itertools.pairwise(heights)):\n      diff = b - a\n      if diff <= 0:\n        continue\n      heapq.heappush(minHeap, diff)\n      # If we run out of ladders, greedily use as less bricks as possible.\n      if len(minHeap) > ladders:\n        bricks -= heapq.heappop(minHeap)\n      if bricks < 0:\n        return i\n\n    return len(heights) - 1",
      "title": "1642. Furthest Building You Can Reach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c2d64fd-a6c7-4e18-b461-5e81dac68510",
      "code": "class Solution:\n  def kthSmallestPath(self, destination: list[int], k: int) -> str:\n    ans = []\n    v, h = destination\n\n    for _ in range(h + v):\n      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.\n      availableRank = math.comb(h + v - 1, v)\n      if availableRank >= k:  # Should pick 'H'.\n        ans.append('H')\n        h -= 1\n      else:  # Should pick 'V'.\n        k -= availableRank\n        ans.append('V')\n        v -= 1\n\n    return ''.join(ans)",
      "title": "1643. Kth Smallest Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "283aa285-1898-4b43-94c6-45b49615d540",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    seenP = False\n    seenQ = False\n\n    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n      nonlocal seenP\n      nonlocal seenQ\n      if not root:\n        return None\n      # Need to traverse the entire tree to update `seenP` and `seenQ`.\n      left = getLCA(root.left, p, q)\n      right = getLCA(root.right, p, q)\n      if root == p:\n        seenP = True\n        return root\n      if root == q:\n        seenQ = True\n        return root\n      if left and right:\n        return root\n      return left or right\n\n    lca = getLCA(root, p, q)\n    return lca if seenP and seenQ else None",
      "title": "1644. Lowest Common Ancestor of a Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "075039e5-7c12-41f4-a58a-07d5260a95ba",
      "code": "class Solution:\n  def getMaximumGenerated(self, n: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return 1\n\n    nums = [0] * (n + 1)\n    nums[1] = 1\n\n    i = 1\n    while 2 * i + 1 <= n:\n      nums[2 * i] = nums[i]\n      nums[2 * i + 1] = nums[i] + nums[i + 1]\n      i += 1\n\n    return max(nums)",
      "title": "1646. Get Maximum in Generated Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a5e6689-b484-460f-ac19-c2302dbea6a4",
      "code": "class Solution:\n  def minDeletions(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n    usedFreq = set()\n\n    for freq in count.values():\n      while freq > 0 and freq in usedFreq:\n        freq -= 1  # Delete ('a' + i).\n        ans += 1\n      usedFreq.add(freq)\n\n    return ans",
      "title": "1647. Minimum Deletions to Make Character Frequencies Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ca9c2aa-8c91-434f-888e-cbf0459635c8",
      "code": "class Solution:\n  def maxProfit(self, inventory: list[int], orders: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    largestCount = 1\n\n    def trapezoid(a: int, b: int) -> int:\n      return (a + b) * (a - b + 1) // 2\n\n    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):\n      if a > b:\n        # If we are at the last inventory, or inventory[i] > inventory[i + 1].\n        # In either case, we will pick inventory[i - largestCount + 1..i].\n        pick = a - b\n        # We have run out of orders, so we need to recalculate the number of\n        # balls that we actually pick for inventory[i - largestCount + 1..i].\n        if largestCount * pick >= orders:\n          actualPick, remaining = divmod(orders, largestCount)\n          return (ans +\n                  largestCount * trapezoid(a, a - actualPick + 1) +\n                  remaining * (a - actualPick)) % MOD\n        ans += largestCount * trapezoid(a, a - pick + 1)\n        ans %= MOD\n        orders -= largestCount * pick\n      largestCount += 1",
      "title": "1648. Sell Diminishing-Valued Colored Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12cc80e7-4d5a-42dd-9574-277643592478",
      "code": "class Solution:\n  # Same as 160. Intersection of Two Linked Lists\n  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n    a = p\n    b = q\n\n    while a != b:\n      a = a.parent if a else q\n      b = b.parent if b else p\n\n    return a",
      "title": "1650. Lowest Common Ancestor of a Binary Tree III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe5ebc57-89dc-4b7f-93c1-4d114145d05c",
      "code": "class Solution:\n  def decrypt(self, code: list[int], k: int) -> list[int]:\n    n = len(code)\n    ans = [0] * n\n    if k == 0:\n      return ans\n\n    summ = 0\n    start = 1 if k > 0 else n + k  # the start of the next k numbers\n    end = k if k > 0 else n - 1  # the end of the next k numbers\n\n    for i in range(start, end + 1):\n      summ += code[i]\n\n    for i in range(n):\n      ans[i] = summ\n      summ -= code[start % n]\n      start += 1\n      end += 1\n      summ += code[end % n]\n\n    return ans",
      "title": "1652. Defuse the Bomb",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ec0991-97fd-4efa-acbb-a48a790fc386",
      "code": "class Solution:\n  # Same as 926. Flip String to Monotone Increasing\n  def minimumDeletions(self, s: str) -> int:\n    dp = 0  # the number of characters to be deleted to make subso far balanced\n    countB = 0\n\n    for c in s:\n      if c == 'a':\n        # 1. Delete 'a'.\n        # 2. Keep 'a' and delete the previous 'b's.\n        dp = min(dp + 1, countB)\n      else:\n        countB += 1\n\n    return dp",
      "title": "1653. Minimum Deletions to Make String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19a96513-8c8d-4fe6-976c-de30670768d7",
      "code": "from enum import Enum\n\n\nclass Direction(Enum):\n  FORWARD = 0\n  BACKWARD = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: list[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    # (direction, position)\n    q = collections.deque([(Direction.FORWARD, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.FORWARD, forward))\n        # It cannot jump backward twice in a row.\n        if dir == Direction.FORWARD and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.BACKWARD, backward))\n      ans += 1\n\n    return -1",
      "title": "1654. Minimum Jumps to Reach Home",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8df968e9-886f-4519-8c2d-80edb6bfd1b1",
      "code": "class Solution:\n  def canDistribute(self, nums: list[int], quantity: list[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    # validDistribution[i][j] := True if it's possible to distribute the i-th\n    # freq into a subset of quantity represented by the bitmask j\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    # dp[i][j] := true if it's possible to distribute freqs[i..n), where j is\n    # the bitmask of the selected quantity\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: list[int],\n                            quantity: list[int]) -> list[list[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: list[int], mask: int) -> int:\n    \"\"\"Returns the sum of the selected quantity represented by `mask`.\"\"\"\n    return sum(q for i, q in enumerate(quantity) if mask >> i & 1)",
      "title": "1655. Distribute Repeating Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e1ebae1-a2f0-4fd0-b309-e466034ad720",
      "code": "class Solution:\n  def closeStrings(self, word1: str, word2: str) -> bool:\n    if len(word1) != len(word2):\n      return False\n\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    if count1.keys() != count2.keys():\n      return False\n\n    return sorted(count1.values()) == sorted(count2.values())",
      "title": "1657. Determine if Two Strings Are Close",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1175d16f-fae4-43a4-bb26-16a213daa3d8",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int) -> int:\n    targetSum = sum(nums) - x\n    if targetSum == 0:\n      return len(nums)\n    maxLen = self._maxSubArrayLen(nums, targetSum)\n    return -1 if maxLen == -1 else len(nums) - maxLen\n\n  # Same as 325. Maximum Size Subarray Sum Equals k\n  def _maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    res = -1\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        res = max(res, i - prefixToIndex[target])\n      # No need to check the existence of the prefix since it's unique.\n      prefixToIndex[prefix] = i\n\n    return res",
      "title": "1658. Minimum Operations to Reduce X to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc562bed-5aac-4fa5-b4c1-a1956aac3613",
      "code": "class Solution:\n  def getMaxGridHappiness(\n      self,\n      m: int,\n      n: int,\n      introvertsCount: int,\n      extrovertsCount: int,\n  ) -> int:\n    def getPlacementCost(\n        i: int,\n        j: int,\n        inMask: int,\n        exMask: int,\n        diff: int,\n    ) -> int:\n      \"\"\"Calculates the cost based on left and up neighbors.\n\n      The `diff` parameter represents the happiness change due to the current\n      placed person in (i, j). We add `diff` each time we encounter a neighbor\n      (left or up) who is already placed.\n\n      1. If the neighbor is an introvert, we subtract 30 from cost.\n      2. If the neighbor is an extrovert, we add 20 to from cost.\n      \"\"\"\n      cost = 0\n      if i > 0:\n        if (1 << (n - 1)) & inMask:\n          cost += diff - 30\n        if (1 << (n - 1)) & exMask:\n          cost += diff + 20\n      if j > 0:\n        if 1 & inMask:\n          cost += diff - 30\n        if 1 & exMask:\n          cost += diff + 20\n      return cost\n\n    @functools.lru_cache(None)\n    def dp(\n        pos: int, inMask: int, exMask: int, inCount: int, exCount: int\n    ) -> int:\n      # `inMask` is the placement of introvert people in the last n cells.\n      # e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means\n      #\n      # ? 1 0\n      # 1 x ? (x := current position)\n      i, j = divmod(pos, n)\n      if i == m:\n        return 0\n\n      shiftedInMask = (inMask << 1) & ((1 << n) - 1)\n      shiftedExMask = (exMask << 1) & ((1 << n) - 1)\n\n      skip = dp(pos + 1, shiftedInMask, shiftedExMask, inCount, exCount)\n      placeIntrovert = (\n          120 + getPlacementCost(i, j, inMask, exMask, -30) +\n          dp(pos + 1, shiftedInMask + 1, shiftedExMask, inCount - 1, exCount)\n          if inCount > 0\n          else -math.inf)\n      placeExtrovert = (\n          40 + getPlacementCost(i, j, inMask, exMask, 20) +\n          dp(pos + 1, shiftedInMask, shiftedExMask + 1, inCount, exCount - 1)\n          if exCount > 0\n          else -math.inf)\n      return max(skip, placeIntrovert, placeExtrovert)\n\n    return dp(0, 0, 0, introvertsCount, extrovertsCount)",
      "title": "1659. Maximize Grid Happiness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8088cac5-62ee-4f79-b56f-07bb5e574e4c",
      "code": "class Solution:\n  def __init__(self):\n    self.seen = set()\n\n  def correctBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    if root == None:\n      return None\n    if root.right and root.right.val in self.seen:\n      return None\n    self.seen.add(root.val)\n    root.right = self.correctBinaryTree(root.right)\n    root.left = self.correctBinaryTree(root.left)\n    return root",
      "title": "1660. Correct a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e474f152-0017-42f9-a7ea-33bd12032d89",
      "code": "class Solution:\n  def arrayStringsAreEqual(self, word1: list[str], word2: list[str]) -> bool:\n    i = 0  # word1's index\n    j = 0  # word2's index\n    a = 0  # word1[i]'s index\n    b = 0  # word2[j]'s index\n\n    while i < len(word1) and j < len(word2):\n      if word1[i][a] != word2[j][b]:\n        return False\n      a += 1\n      if a == len(word1[i]):\n        i += 1\n        a = 0\n      b += 1\n      if b == len(word2[j]):\n        j += 1\n        b = 0\n\n    return i == len(word1) and j == len(word2)",
      "title": "1662. Check If Two String Arrays are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02b620df-401c-4d2d-a874-53c551fdee22",
      "code": "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n    ans = []\n\n    for i in range(n):\n      remainingLetters = n - 1 - i\n      rank = max(1, k - remainingLetters * 26)\n      ans.append(chr(ord('a') + rank - 1))\n      k -= rank\n\n    return ''.join(ans)",
      "title": "1663. Smallest String With A Given Numeric Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0e340eb-d9e7-42af-bf92-e13c893342ba",
      "code": "class Solution:\n  def minimumEffort(self, tasks: list[list[int]]) -> int:\n    ans = 0\n    prevSaved = 0\n\n    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):\n      if prevSaved < minimum:\n        ans += minimum - prevSaved\n        prevSaved = minimum - actual\n      else:\n        prevSaved -= actual\n\n    return ans",
      "title": "1665. Minimum Initial Energy to Finish Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc21bf78-d3cd-4a94-9c9c-306bbffc301c",
      "code": "class Solution:\n  def maxRepeating(self, sequence: str, word: str) -> int:\n    ans = 1\n    while word * ans in sequence:\n      ans += 1\n    return ans - 1",
      "title": "1668. Maximum Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6acddd12-ba66-4dd0-97fd-13c0eebe42c2",
      "code": "class Solution:\n  def mergeInBetween(\n      self,\n      list1: ListNode,\n      a: int,\n      b: int,\n      list2: ListNode,\n  ) -> ListNode:\n    nodeBeforeA = list1\n    for i in range(a - 1):\n      nodeBeforeA = nodeBeforeA.next\n\n    nodeB = nodeBeforeA.next\n    for i in range(b - a):\n      nodeB = nodeB.next\n\n    nodeBeforeA.next = list2\n    lastNodeInList2 = list2\n\n    while lastNodeInList2.next:\n      lastNodeInList2 = lastNodeInList2.next\n\n    lastNodeInList2.next = nodeB.next\n    nodeB.next = None\n    return list1",
      "title": "1669. Merge In Between Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "269b90a0-29b0-4e0a-aaf7-6dc58767bc1d",
      "code": "class Solution:\n  def minimumMountainRemovals(self, nums: list[int]) -> int:\n    left = self._lengthOfLIS(nums)\n    right = self._lengthOfLIS(nums[::-1])[::-1]\n    maxMountainSeq = 0\n\n    for l, r in zip(left, right):\n      if l > 1 and r > 1:\n        maxMountainSeq = max(maxMountainSeq, l + r - 1)\n\n    return len(nums) - maxMountainSeq\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> list[int]:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    # dp[i] := the length of LIS ending in nums[i]\n    dp = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n      dp.append(len(tails))\n    return dp",
      "title": "1671. Minimum Number of Removals to Make Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94a39b31-6b89-45e3-83c3-3bac1df8ad85",
      "code": "class Solution:\n  def maximumWealth(self, accounts: list[list[int]]) -> int:\n    return max(map(sum, accounts))",
      "title": "1672. Richest Customer Wealth",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bc25d26-8497-4771-85fc-db5bb2cdeafa",
      "code": "class Solution:\n  def mostCompetitive(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n\n    for i, num in enumerate(nums):\n      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough\n      # numbers, and we can safely pop an element from ans.\n      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:\n        ans.pop()\n      if len(ans) < k:\n        ans.append(nums[i])\n\n    return ans",
      "title": "1673. Find the Most Competitive Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "099dcf8e-446e-49a5-b888-24e0979d004c",
      "code": "class Solution:\n  def minMoves(self, nums: list[int], limit: int) -> int:\n    n = len(nums)\n    ans = n\n    # delta[i] := the number of moves needed when target goes from i - 1 to i\n    delta = [0] * (limit * 2 + 2)\n\n    for i in range(n // 2):\n      a = nums[i]\n      b = nums[n - 1 - i]\n      delta[min(a, b) + 1] -= 1\n      delta[a + b] -= 1\n      delta[a + b + 1] += 1\n      delta[max(a, b) + limit + 1] += 1\n\n    # Initially, we need `moves` when the target is 2.\n    moves = n\n    for i in range(2, limit * 2 + 1):\n      moves += delta[i]\n      ans = min(ans, moves)\n\n    return ans",
      "title": "1674. Minimum Moves to Make Array Complementary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fc69c00-01e1-40e1-913e-a6d8c454c4f3",
      "code": "class Solution:\n  def minimumDeviation(self, nums: list[int]) -> int:\n    ans = math.inf\n    mn = math.inf\n    maxHeap = []\n\n    for num in nums:\n      evenNum = num if num % 2 == 0 else num * 2\n      heapq.heappush(maxHeap, -evenNum)\n      mn = min(mn, evenNum)\n\n    while maxHeap[0] % 2 == 0:\n      mx = -heapq.heappop(maxHeap)\n      ans = min(ans, mx - mn)\n      mn = min(mn, mx // 2)\n      heapq.heappush(maxHeap, -mx // 2)\n\n    return min(ans, -maxHeap[0] - mn)",
      "title": "1675. Minimize Deviation in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e0f9c59-86a6-4c89-909b-a1733e156ac9",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      nodes: 'list[TreeNode]',\n  ) -> 'TreeNode':\n    nodes = set(nodes)\n\n    def lca(root: 'TreeNode') -> 'TreeNode':\n      if not root:\n        return None\n      if root in nodes:\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    return lca(root)",
      "title": "1676. Lowest Common Ancestor of a Binary Tree IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b3c0359-3595-4d75-88c8-ac2ab99ef4bb",
      "code": "class Solution:\n  def interpret(self, command: str) -> str:\n    return command.replace('()', 'o').replace('(al)', 'al')",
      "title": "1678. Goal Parser Interpretation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8ce52f4-3b2b-4fae-80d6-dae08070f2ea",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(min(count[num], count[k - num])\n               for num in count) // 2",
      "title": "1679. Max Number of K-Sum Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e8d171b-b61e-47c0-a1a9-481d88e91a11",
      "code": "class Solution:\n  def concatenatedBinary(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    numberOfBits = 0\n\n    for i in range(1, n + 1):\n      if i.bit_count() == 1:\n        numberOfBits += 1\n      ans = ((ans << numberOfBits) + i) % MOD\n\n    return ans",
      "title": "1680. Concatenation of Consecutive Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "398b8a70-45ae-400c-bfd9-8379ac05dbc7",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX_NUM = 16\n\n  def minimumIncompatibility(self, nums: list[int], k: int) -> int:\n    MAX_COMPATIBILITY = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    # dp[i] := the minimum possible sum of incompatibilities of the subset\n    # of numbers represented by the bitmask i\n    dp = [MAX_COMPATIBILITY] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      # The number of 1s in `mask` isn't a multiple of `subsetSize`.\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      # https://cp-algorithms.com/algebra/all-submasks.html\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:  # valid submask\n          dp[mask] = min(dp[mask], dp[mask - submask] +\n                         incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    return dp[-1] if dp[-1] != MAX_COMPATIBILITY else -1\n\n  def _getIncompatibilities(\n      self,\n      nums: list[int],\n      subsetSize: int,\n  ) -> list[int]:\n    \"\"\"\n    Returns an incompatibilities array where\n    * incompatibilities[i] := the incompatibility of the subset of numbers\n      represented by the bitmask i\n    * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not\n      `subsetSize`\n    \"\"\"\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: list[int], mask: int, subsetSize: int) -> bool:\n    \"\"\"Returns True if the numbers selected by `mask` are unique.\"\"\"\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: list[int], mask: int) -> int:\n    \"\"\"\n    Returns the incompatibility of the selected numbers represented by the\n    `mask`.\n    \"\"\"\n    mn = self.MAX_NUM\n    mx = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        mx = max(mx, num)\n        mn = min(mn, num)\n    return mx - mn",
      "title": "1681. Minimum Incompatibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "832224cf-c10c-44a7-9c2b-b533c47510c6",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is\n    # ('a' + k).\n    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        for k in range(27):\n          j = i + d\n          if s[i] == s[j] and s[i] != chr(ord('a') + k):\n            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2\n          else:\n            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])\n\n    return dp[0][n - 1][26]",
      "title": "1682. Longest Palindromic Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71b4e880-5e53-4027-be61-b1d65adfc78e",
      "code": "class Solution:\n  def countConsistentStrings(self, allowed: str, words: list[str]) -> int:\n    return sum(all(c in allowed for c in word)\n               for word in words)",
      "title": "1684. Count the Number of Consistent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c415dfc2-308b-46f3-b807-89281c6267c7",
      "code": "class Solution:\n  def getSumAbsoluteDifferences(self, nums: list[int]) -> list[int]:\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)\n            for i, num in enumerate(nums)]",
      "title": "1685. Sum of Absolute Differences in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf864735-3ee5-40e7-8445-fd7c206739f3",
      "code": "class Solution:\n  def boxDelivering(\n      self,\n      boxes: list[list[int]],\n      portsCount: int,\n      maxBoxes: int,\n      maxWeight: int,\n  ) -> int:\n    n = len(boxes)\n    # dp[i] := the minimum trips to deliver boxes[0..i) and return to the\n    # storage\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      # The current box is different from the previous one, need to make one\n      # more trip.\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      # Loading boxes[l] in the previous turn is always no bad than loading it\n      # in this turn\n      while r - l + 1 > maxBoxes or weight > maxWeight or (\n              l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      #   min trips to deliver boxes[0..r]\n      # = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]",
      "title": "1687. Delivering Boxes from Storage to Ports",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8b07a8e-a72e-48be-9c52-d1eacfc8b58d",
      "code": "class Solution:\n  def numberOfMatches(self, n: int) -> int:\n    return n - 1",
      "title": "1688. Count of Matches in Tournament",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2d516e3-40af-490e-b895-ee9a8752f8b5",
      "code": "class Solution:\n  def minPartitions(self, n: str) -> int:\n    return int(max(n))",
      "title": "1689. Partitioning Into Minimum Number Of Deci-Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd7bbf2d-d24a-4e22-8bea-b4e157735e34",
      "code": "class Solution:\n  def reformatNumber(self, number: str) -> str:\n    ans = []\n\n    number = number.replace(\"-\", \"\").replace(\" \", \"\")\n\n    i = 0  # number's index\n    while i + 4 < len(number):\n      ans.append(number[i:i + 3] + '-')\n      i += 3\n\n    countFinalDigits = len(number) - i\n    if countFinalDigits < 4:\n      ans.append(number[i:])\n    else:  # countFinalDigits == 4\n      ans.append(number[i:i + 2] + '-' + number[i + 2:])\n\n    return ''.join(ans)",
      "title": "1694. Reformat Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56ec9fd1-b55b-41d9-9ba4-3c398f08dd03",
      "code": "class Solution:\n  def maximumUniqueSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n    seen = set()\n\n    l = 0\n    for r, num in enumerate(nums):\n      while num in seen:\n        score -= nums[l]\n        seen.remove(nums[l])\n        l += 1\n      seen.add(nums[r])\n      score += nums[r]\n      ans = max(ans, score)\n\n    return ans",
      "title": "1695. Maximum Erasure Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945a2f15-3226-48bc-8567-8868951c094a",
      "code": "class Solution:\n  def maxResult(self, nums: list[int], k: int) -> int:\n    # Stores dp[i] within the bounds.\n    maxQ = collections.deque([0])\n    # dp[i] := the maximum score to consider nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n      # Pop the index if it's out-of-bounds.\n      if maxQ[0] + k < i:\n        maxQ.popleft()\n      dp[i] = dp[maxQ[0]] + nums[i]\n      # Pop indices that won't be chosen in the future.\n      while maxQ and dp[maxQ[-1]] <= dp[i]:\n        maxQ.pop()\n      maxQ.append(i)\n\n    return dp[-1]",
      "title": "1696. Jump Game VI",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a29bafab-5ab2-4cca-a662-86cd72fac206",
      "code": "class Solution:\n  def countDistinct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n\n    n = len(s)\n    ans = 0\n    pow = [1] + [0] * n     # pow[i] := BASE^i\n    hashes = [0] * (n + 1)  # hashes[i] := the hash of s[0..i)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for i in range(1, n + 1):\n      pow[i] = pow[i - 1] * BASE % HASH\n      hashes[i] = (hashes[i - 1] * BASE + val(s[i - 1])) % HASH\n\n    def getHash(l: int, r: int) -> int:\n      \"\"\"Returns the hash of s[l..r).\"\"\"\n      hash = (hashes[r] - hashes[l] * pow[r - l]) % HASH\n      return hash + HASH if hash < 0 else hash\n\n    for length in range(1, n + 1):\n      seen = set()\n      for i in range(n - length + 1):\n        seen.add(getHash(i, i + length))\n      ans += len(seen)\n\n    return ans",
      "title": "1698. Number of Distinct Substrings in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "923b3f6f-0170-4394-a3a5-ebf51c759c70",
      "code": "class Solution:\n  def countStudents(self, students: list[int], sandwiches: list[int]) -> int:\n    count = collections.Counter(students)\n\n    for i, sandwich in enumerate(sandwiches):\n      if count[sandwich] == 0:\n        return len(sandwiches) - i\n      count[sandwich] -= 1\n\n    return 0",
      "title": "1700. Number of Students Unable to Eat Lunch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c58909d0-a310-48a1-9031-b58b436a6d1c",
      "code": "class Solution:\n  def maximumBinaryString(self, binary: str) -> str:\n    #     e.g. binary = '100110'\n    # Do Operation 2 -> '100011'\n    # Do Operation 1 -> '111011'\n    # So, the index of the only '0' is prefixOnes + zeros - 1.\n    zeros = binary.count('0')\n    prefixOnes = binary.find('0')\n\n    # Make the entire string as 1s.\n    ans = ['1'] * len(binary)\n\n    # Make the only '0' if necessary.\n    if prefixOnes != -1:\n      ans[prefixOnes + zeros - 1] = '0'\n    return ''.join(ans)",
      "title": "1702. Maximum Binary String After Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ff3b930-f764-45d9-aae1-57c55948a06b",
      "code": "class Solution:\n  def halvesAreAlike(self, s: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n    aVowelsCount = sum(c in VOWELS for c in s[:len(s) // 2])\n    bVowelsCount = sum(c in VOWELS for c in s[len(s) // 2:])\n    return aVowelsCount == bVowelsCount",
      "title": "1704. Determine if String Halves Are Alike",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a47047e-20c3-45b2-8b33-55e4fb8e73bc",
      "code": "class Solution:\n  def eatenApples(self, apples: list[int], days: list[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []  # (the rotten day, the number of apples)\n\n    i = 0\n    while i < n or minHeap:\n      # Remove the rotten apples.\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      # Add today's apples.\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      # Eat one apple today.\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans",
      "title": "1705. Maximum Number of Eaten Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83da5bf7-297f-44da-ab51-0ef7efd49a4c",
      "code": "class Solution:\n  def findBall(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i] := status of the i-th column\n    # -1 := empty, 0 := b0, 1 := b1, ...\n    dp = [i for i in range(n)]\n    # ans[i] := the i-th ball's final positio\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        # out-of-bounds\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if (grid[i][j] == 1 and grid[i][j + 1] == -1 or\n                grid[i][j] == -1 and grid[i][j - 1] == 1):\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans",
      "title": "1706. Where Will the Ball Fall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4328a7d7-15aa-43f4-aea9-32f9b91f912b",
      "code": "from dataclasses import dataclass\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  x: int\n  m: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0  # nums' index\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m)\n                                    for i, (x, m) in enumerate(queries)],\n                                   key=lambda x: x.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans",
      "title": "1707. Maximum XOR With an Element From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28ba0704-599b-4efa-a1a9-cbbafed7f19a",
      "code": "class Solution:\n  def largestSubarray(self, nums: list[int], k: int) -> list[int]:\n    mx = max(nums[:len(nums) - k + 1])\n    i = nums.index(mx)\n    return nums[i:i + k]",
      "title": "1708. Largest Subarray Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75fc1bde-bf3a-467f-88ad-383ae3791f0b",
      "code": "class Solution:\n  def maximumUnits(self, boxTypes: list[list[int]], truckSize: int) -> int:\n    ans = 0\n\n    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):\n      if boxes >= truckSize:\n        return ans + truckSize * units\n      ans += boxes * units\n      truckSize -= boxes\n\n    return ans",
      "title": "1710. Maximum Units on a Truck",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14f8b27b-a433-4003-bb25-a54a1dbbe5eb",
      "code": "class Solution:\n  def countPairs(self, deliciousness: list[int]) -> int:\n    MOD = 10**9 + 7\n    MAX_BIT = 20 + 1\n    ans = 0\n    count = collections.Counter()\n\n    for d in deliciousness:\n      for i in range(MAX_BIT + 1):\n        power = 1 << i\n        ans += count[power - d]\n        ans %= MOD\n      count[d] += 1\n\n    return ans",
      "title": "1711. Count Good Meals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3c83c39-0ab4-4929-8cb8-d59d7a5a4567",
      "code": "class Solution:\n  def waysToSplit(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n\n    def firstGreaterEqual(i: int) -> int:\n      \"\"\"Finds the first index j s.t.\n         Mid = prefix[j] - prefix[i] >= left = prefix[i]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] >= prefix[i]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def firstGreater(i: int) -> int:\n      \"\"\"Finds the first index k s.t.\n         mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    for i in range(n - 2):\n      j = firstGreaterEqual(i)\n      if j == n - 1:\n        break\n      mid = prefix[j] - prefix[i]\n      right = prefix[-1] - prefix[j]\n      if mid > right:\n        continue\n      k = firstGreater(i)\n      ans = (ans + k - j) % MOD\n\n    return ans",
      "title": "1712. Ways to Split Array Into Three Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f433d701-87ac-4904-ade4-d62ec9f921f3",
      "code": "class Solution:\n  def minOperations(self, target: list[int], arr: list[int]) -> int:\n    indices = []\n    numToIndex = {num: i for i, num in enumerate(target)}\n\n    for a in arr:\n      if a in numToIndex:\n        indices.append(numToIndex[a])\n\n    return len(target) - self._lengthOfLIS(indices)\n\n  # Same as 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n    return len(tails)",
      "title": "1713. Minimum Operations to Make a Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c4ef544-fedd-4544-8779-7e5f7fb27c6b",
      "code": "class Solution:\n  def solve(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    MOD = 10**9 + 7\n    n = len(nums)\n    sqrtN = int(n**0.5)\n    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n\n    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].\n    prefix = [[num] * sqrtN for num in nums]\n\n    for x in range(n - 1, -1, -1):\n      for y in range(1, sqrtN):\n        if x + y < n:\n          prefix[x][y] += prefix[x + y][y]\n          prefix[x][y] %= MOD\n\n    return [prefix[x][y] if y < sqrtN\n            else sum(nums[x::y]) % MOD\n            for x, y in queries]",
      "title": "1714. Sum Of Special Evenly-Spaced Elements In Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "feb0fc61-0673-4b53-8f3b-657c3b0a1991",
      "code": "class Solution:\n  def totalMoney(self, n: int) -> int:\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    weeks = n // 7\n    firstWeek = trapezoid(1, 7)\n    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)\n    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)\n    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays",
      "title": "1716. Calculate Money in Leetcode Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5157fc6-0300-471b-ac98-ad7921c6f9cd",
      "code": "class Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    # The assumption that gain('ab') > gain('ba') while removing 'ba' first is\n    # optimal is contradicted. Only 'b(ab)a' satisfies the condition of\n    # preventing two 'ba' removals, but after removing 'ab', we can still\n    # remove one 'ba', resulting in a higher gain. Thus, removing 'ba' first is\n    # not optimal.\n    return (self._gain(s, 'ab', x, 'ba', y) if x > y else\n            self._gain(s, 'ba', y, 'ab', x))\n\n  # Returns the points gained by first removing sub1 ('ab' | 'ba') from s with\n  # point1, then removing sub2 ('ab' | 'ba') from s with point2.\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    # Remove 'sub1' from s with point1 gain.\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    # Remove 'sub2' from s with point2 gain.\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points",
      "title": "1717. Maximum Score From Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd076b6f-79fe-48f0-ae92-5daf57b6aff0",
      "code": "class Solution:\n  def constructDistancedSequence(self, n: int) -> list[int]:\n    ans = [0] * (2 * n - 1)\n\n    def dfs(i: int, mask: int) -> bool:\n      if i == len(ans):\n        return True\n      if ans[i] > 0:\n        return dfs(i + 1, mask)\n\n      # Greedily fill in `ans` in descending order.\n      for num in range(n, 0, -1):\n        if (mask >> num & 1) == 1:\n          continue\n        if num == 1:\n          ans[i] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i] = 0\n        else:  # num in [2, n]\n          if i + num >= len(ans) or ans[i + num] > 0:\n            continue\n          ans[i] = num\n          ans[i + num] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i + num] = 0\n          ans[i] = 0\n\n      return False\n\n    dfs(0, 0)\n    return ans",
      "title": "1718. Construct the Lexicographically Largest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a67a62b4-caa8-446b-9bf8-6e7f05610718",
      "code": "class Solution:\n  def checkWays(self, pairs: list[list[int]]) -> int:\n    MAX = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * MAX\n    connected = [[False] * MAX for _ in range(MAX)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    # For each node, sort its children by degrees in descending order.\n    for _, children in graph.items():\n      children.sort(key=lambda x: -degrees[x])\n\n    # Find the root with a degree that equals to n - 1.\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n      \"\"\"\n      Returns True if each node rooted at u is connected to all of its\n      ancestors.\n      \"\"\"\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * MAX):\n      return 0\n    return 2 if hasMoreThanOneWay else 1",
      "title": "1719. Number Of Ways To Reconstruct A Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee7898ac-af17-4e9b-8dd9-14f346b08080",
      "code": "class Solution:\n  def decode(self, encoded: list[int], first: int) -> list[int]:\n    ans = [first]\n\n    for e in encoded:\n      ans.append(e ^ ans[-1])\n\n    return ans",
      "title": "1720. Decode XORed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb1a8904-e437-4e91-a65d-03891e0bd259",
      "code": "class Solution:\n  def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\n    p = None  # Points the k-th node from the beginning.\n    q = None  # Points the k-th node from the end.\n\n    curr = head\n    while curr:\n      if q:\n        q = q.next\n      k -= 1\n      if k == 0:\n        p = curr\n        q = head\n      curr = curr.next\n\n    p.val, q.val = q.val, p.val\n    return head",
      "title": "1721. Swapping Nodes in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "195df4a9-2569-41c4-84bd-02d679ec8ce7",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(\n      self,\n      source: list[int],\n      target: list[int],\n      allowedSwaps: list[list[int]],\n  ) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans",
      "title": "1722. Minimize Hamming Distance After Swap Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbca1833-1799-439a-be74-599090a6efca",
      "code": "class Solution:\n  def minimumTimeRequired(self, jobs: list[int], k: int) -> int:\n    ans = sum(jobs)\n    times = [0] * k  # times[i] := accumulate time of workers[i]\n\n    # Assign the most time-consuming job first.\n    jobs.sort(reverse=True)\n\n    def dfs(s: int) -> None:\n      nonlocal ans\n      if s == len(jobs):\n        ans = min(ans, max(times))\n        return\n      for i in range(k):\n        # There is no need to explore assigning jobs[s] to workers[i] further as\n        # it would not yield better results.\n        if times[i] + jobs[s] >= ans:\n          continue\n        times[i] += jobs[s]\n        dfs(s + 1)\n        times[i] -= jobs[s]\n        # It's always non-optimal to have a worker with no jobs.\n        if times[i] == 0:\n          return\n\n    dfs(0)\n    return ans",
      "title": "1723. Find Minimum Time to Finish All Jobs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9f24609-019a-4268-9ebb-0daf2834270a",
      "code": "class Solution:\n  def countGoodRectangles(self, rectangles: list[list[int]]) -> int:\n    minSides = [min(x, y) for x, y in rectangles]\n    return minSides.count(max(minSides))",
      "title": "1725. Number Of Rectangles That Can Form The Largest Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bbe51aa-cdac-4177-998f-31eaa000c8fe",
      "code": "class Solution:\n  def tupleSameProduct(self, nums: list[int]) -> int:\n    # nums of ways to arrange (a, b) = 2\n    # nums of ways to arrange (c, d) = 2\n    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8\n    ans = 0\n    count = collections.Counter()\n\n    for i in range(len(nums)):\n      for j in range(i):\n        prod = nums[i] * nums[j]\n        ans += count[prod] * 8\n        count[prod] += 1\n\n    return ans",
      "title": "1726. Tuple with Same Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59fb9410-9f2f-449b-95dc-fc44b8ca7a63",
      "code": "class Solution:\n  def largestSubmatrix(self, matrix: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    for row in matrix:\n      # Accumulate the histogram if possible.\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n\n      # Get the sorted histogram.\n      sortedHist = sorted(hist)\n\n      # Greedily calculate the answer.\n      for i, h in enumerate(sortedHist):\n        ans = max(ans, h * (len(row) - i))\n\n    return ans",
      "title": "1727. Largest Submatrix With Rearrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d14042d-a853-4c5a-a9d6-1fffc83545ff",
      "code": "class Solution:\n  def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nFloors = 0\n    cat = 0  # cat's position\n    mouse = 0  # mouse's position\n\n    def hash(i: int, j: int) -> int:\n      return i * n + j\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] != '#':\n          nFloors += 1\n        if grid[i][j] == 'C':\n          cat = hash(i, j)\n        elif grid[i][j] == 'M':\n          mouse = hash(i, j)\n\n    @functools.lru_cache(None)\n    def dp(cat: int, mouse: int, turn: int) -> bool:\n      \"\"\"\n      Returns True if the mouse can win, where the cat is on (i / 8, i % 8), the\n      mouse is on (j / 8, j % 8), and the turns is k.\n      \"\"\"\n      # We already search the whole touchable grid.\n      if turn == nFloors * 2:\n        return False\n\n      if turn % 2 == 0:\n        # the mouse's turn\n        i = mouse // n\n        j = mouse % n\n        for dx, dy in DIRS:\n          for jump in range(mouseJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The mouse eats the food, so the mouse wins.\n            if grid[x][y] == 'F':\n              return True\n            if dp(cat, hash(x, y), turn + 1):\n              return True\n        # The mouse can't win, so the mouse loses.\n        return False\n      else:\n        # the cat's turn\n        i = cat // n\n        j = cat % n\n        for dx, dy in DIRS:\n          for jump in range(catJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The cat eats the food, so the mouse loses.\n            if grid[x][y] == 'F':\n              return False\n            nextCat = hash(x, y)\n            # The cat catches the mouse, so the mouse loses.\n            if nextCat == mouse:\n              return False\n            if not dp(nextCat, mouse, turn + 1):\n              return False\n        # The cat can't win, so the mouse wins.\n        return True\n\n    return dp(cat, mouse, 0)",
      "title": "1728. Cat and Mouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bda1241c-4340-44a1-b1dc-74b61c595e3c",
      "code": "class Solution:\n  def getFood(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    q = collections.deque([self._getStartLocation(grid)])\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] == 'X':\n            continue\n          if grid[x][y] == '#':\n            return ans + 1\n          q.append((x, y))\n          grid[x][y] = 'X'  # Mark as visited.\n      ans += 1\n\n    return -1\n\n  def _getStartLocation(self, grid: list[list[str]]) -> tuple[int, int]:\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          return (i, j)",
      "title": "1730. Shortest Path to Get Food",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "956d45e4-138a-471e-a16a-53416fdaee97",
      "code": "class Solution:\n  def largestAltitude(self, gain: list[int]) -> int:\n    ans = 0\n    currAltitude = 0\n    for g in gain:\n      currAltitude += g\n      ans = max(ans, currAltitude)\n    return ans",
      "title": "1732. Find the Highest Altitude",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0617d48-18f1-4bab-85c7-24257a6c0ceb",
      "code": "class Solution:\n  def minimumTeachings(\n      self,\n      n: int,\n      languages: list[list[int]],\n      friendships: list[list[int]],\n  ) -> int:\n    languageSets = [set(languages) for languages in languages]\n    needTeach = set()\n    languageCount = collections.Counter()\n\n    # Find friends that can't communicate.\n    for u, v in friendships:\n      if not languageSets[u - 1] & languageSets[v - 1]:\n        needTeach.add(u - 1)\n        needTeach.add(v - 1)\n\n    # Find the most popular language.\n    for u in needTeach:\n      for language in languageSets[u]:\n        languageCount[language] += 1\n\n    # Teach the most popular language to people don't understand.\n    return len(needTeach) - max(languageCount.values(), default=0)",
      "title": "1733. Minimum Number of People to Teach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc0e1af5-88d2-430a-8b25-26d26e3a3438",
      "code": "class Solution:\n  def decode(self, encoded: list[int]) -> list[int]:\n    # Our goal is to find the value of a1, which will allow us to decode a2, a3,\n    # ..., an. This can be achieved by performing XOR operation between each\n    # element in `encoded` and a1.\n    #\n    # e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3].\n    #               encoded = [a1^a2, a2^a3]\n    #    accumulatedEncoded = [a1^a2, a1^a3]\n    #    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)\n    #    a2 = a1^(a1^a2)\n    #    a3 = a2^(a2^a3)\n    n = len(encoded) + 1\n    nXors = functools.reduce(operator.xor, [i for i in range(1, n + 1)])\n\n    # Instead of constructing the array, we can track of the running XOR value\n    # of `accumulatedEncoded`.\n    xors = 0  # xors(accumulatedEncoded)\n\n    for encode in encoded:\n      runningXors ^= encode\n      xors ^= runningXors\n\n    ans = [xors ^ nXors]\n\n    for encode in encoded:\n      ans.append(ans[-1] ^ encode)\n\n    return ans",
      "title": "1734. Decode XORed Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94a46012-e8e3-401a-8b85-edbb8b0b1326",
      "code": "class Solution:\n  def waysToFillArray(self, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX = 10_000\n    minPrimeFactors = self._sieveEratosthenes(MAX + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % MOD\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: list[int]) -> dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count",
      "title": "1735. Count Ways to Make Array With Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5473ed6-267a-4c6b-8cd7-37f9f0939cec",
      "code": "class Solution:\n  def maximumTime(self, time: str) -> str:\n    ans = list(time)\n    if time[0] == '?':\n      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'\n    if time[1] == '?':\n      ans[1] = '3' if ans[0] == '2' else '9'\n    if time[3] == '?':\n      ans[3] = '5'\n    if time[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "1736. Latest Time by Replacing Hidden Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06eae1b7-def5-4e9b-b5c9-ce7ea461f67a",
      "code": "class Solution:\n  def minimumBoxes(self, n: int) -> int:\n    nBoxes = 0\n    nextTouchings = 0  # j\n    currLevelBoxes = 0  # 1 + 2 + ... + j\n\n    # Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)\n    # >= n\n    while nBoxes < n:\n      nextTouchings += 1\n      currLevelBoxes += nextTouchings\n      nBoxes += currLevelBoxes\n\n    # If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.\n    if nBoxes == n:\n      return currLevelBoxes\n\n    # Otherwise, need to remove the boxes in the current level and rebuild it.\n    nBoxes -= currLevelBoxes\n    currLevelBoxes -= nextTouchings\n    nextTouchings = 0\n\n    while nBoxes < n:\n      nextTouchings += 1\n      nBoxes += nextTouchings\n\n    return currLevelBoxes + nextTouchings",
      "title": "1739. Building Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1f4ada7-fb65-4510-a409-d4643646f940",
      "code": "class Solution:\n  def findDistance(self, root: TreeNode, p: int, q: int) -> int:\n    def getLCA(root, p, q):\n      if not root or root.val == p or root.val == q:\n        return root\n\n      l = getLCA(root.left, p, q)\n      r = getLCA(root.right, p, q)\n\n      if l and r:\n        return root\n      return l or r\n\n    def dist(lca, target):\n      if not lca:\n        return 10000\n      if lca.val == target:\n        return 0\n      return 1 + min(dist(lca.left, target), dist(lca.right, target))\n\n    lca = getLCA(root, p, q)\n    return dist(lca, p) + dist(lca, q)",
      "title": "1740. Find Distance in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ace91bfd-2e30-4f7f-9f67-146519937042",
      "code": "class Solution:\n  def countBalls(self, lowLimit: int, highLimit: int) -> int:\n    maxDigitSum = 9 * 5  # 99999\n    ans = 0\n    count = [0] * (maxDigitSum + 1)\n\n    for num in range(lowLimit, highLimit + 1):\n      digitSum = self._getDigitSum(num)\n      count[digitSum] += 1\n      ans = max(ans, count[digitSum])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1742. Maximum Number of Balls in a Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc118171-956f-4a33-bcb5-3360ca29a7dc",
      "code": "class Solution:\n  def restoreArray(self, adjacentPairs: list[list[int]]) -> list[int]:\n    ans = []\n    numToAdjs = collections.defaultdict(list)\n\n    for a, b in adjacentPairs:\n      numToAdjs[a].append(b)\n      numToAdjs[b].append(a)\n\n    for num, adjs in numToAdjs.items():\n      if len(adjs) == 1:\n        ans.append(num)\n        ans.append(adjs[0])\n        break\n\n    while len(ans) < len(adjacentPairs) + 1:\n      tail = ans[-1]\n      prev = ans[-2]\n      adjs = numToAdjs[tail]\n      if adjs[0] == prev:  # adjs[0] is already used\n        ans.append(adjs[1])\n      else:\n        ans.append(adjs[0])\n\n    return ans",
      "title": "1743. Restore the Array From Adjacent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2716400f-555b-40d8-af6f-50ede7cdebee",
      "code": "class Solution:\n  def canEat(\n      self,\n      candiesCount: list[int],\n      queries: list[list[int]]\n  ) -> list[bool]:\n    prefix = list(itertools.accumulate(candiesCount, initial=0))\n    return [prefix[t] // c <= d < prefix[t + 1] for t, d, c in queries]",
      "title": "1744. Can You Eat Your Favorite Candy on Your Favorite Day?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd04a3f0-6ffa-4e50-a52e-d7f43494340a",
      "code": "class Solution:\n  def checkPartitioning(self, s: str) -> bool:\n    @functools.lru_cache(None)\n    def isPalindrome(i: int, j: int) -> bool:\n      \"\"\"Returns True if s[i..j] is a palindrome.\"\"\"\n      if i > j:\n        return True\n      if s[i] == s[j]:\n        return isPalindrome(i + 1, j - 1)\n      return False\n\n    n = len(s)\n    return any(isPalindrome(0, i) and\n               isPalindrome(i + 1, j) and\n               isPalindrome(j + 1, n - 1)\n               for i in range(n)\n               for j in range(i + 1, n - 1))",
      "title": "1745. Palindrome Partitioning IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd2d3710-c646-406d-8439-64828af10798",
      "code": "class Solution:\n  def maxSumAfterOperation(self, nums: list[int]) -> int:\n    ans = -math.inf\n    regular = 0\n    squared = 0\n\n    for num in nums:\n      squared = max(num**2, regular + num**2, squared + num)\n      regular = max(num, regular + num)\n      ans = max(ans, squared)\n\n    return ans",
      "title": "1746. Maximum Subarray Sum After One Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80125f76-d2bc-49d3-93be-d35f9b44306a",
      "code": "class Solution:\n  def sumOfUnique(self, nums: list[int]) -> int:\n    return sum(num\n               for num, freq in collections.Counter(nums).items()\n               if freq == 1)",
      "title": "1748. Sum of Unique Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3178528-9924-4712-b951-563b7ba0b853",
      "code": "class Solution:\n  def maxAbsoluteSum(self, nums):\n    ans = -math.inf\n    maxSum = 0\n    minSum = 0\n\n    for num in nums:\n      maxSum = max(num, maxSum + num)\n      minSum = min(num, minSum + num)\n      ans = max(ans, maxSum, -minSum)\n\n    return ans",
      "title": "1749. Maximum Absolute Sum of Any Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f8f7fb6-3c01-4f12-99d4-82c732948cae",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    i = 0\n    j = len(s) - 1\n\n    while i < j and s[i] == s[j]:\n      c = s[i]\n      while i <= j and s[i] == c:\n        i += 1\n      while i <= j and s[j] == c:\n        j -= 1\n\n    return j - i + 1",
      "title": "1750. Minimum Length of String After Deleting Similar Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77da12c0-961d-45a0-b3f9-6f30303c5cbd",
      "code": "class Solution:\n  def maxValue(self, events: list[list[int]], k: int) -> int:\n    events.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum sum of values that you can receive by attending\n      events[i..n), where k is the maximum number of attendance.\n      \"\"\"\n      if k == 0 or i == len(events):\n        return 0\n\n      # Binary search `events` to find the first index j\n      # s.t. events[j][0] > events[i][1].\n      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)\n      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))\n\n    return dp(0, k)",
      "title": "1751. Maximum Number of Events That Can Be Attended II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2f8482c-4b4d-4ee5-bfac-e07c8ba52f6d",
      "code": "class Solution:\n  def largestMerge(self, word1: str, word2: str) -> str:\n    if not word1:\n      return word2\n    if not word2:\n      return word1\n    if word1 > word2:\n      return word1[0] + self.largestMerge(word1[1:], word2)\n    return word2[0] + self.largestMerge(word1, word2[1:])",
      "title": "1754. Largest Merge Of Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a09efa63-d899-4825-94d8-cb4573615207",
      "code": "class Solution:\n  def minAbsDifference(self, nums: list[int], goal: int) -> int:\n    n = len(nums) // 2\n    ans = math.inf\n    lSums = []\n    rSums = []\n\n    def dfs(arr: list[int], i: int, path: int, sums: list[int]) -> None:\n      if i == len(arr):\n        sums.append(path)\n        return\n      dfs(arr, i + 1, path + arr[i], sums)\n      dfs(arr, i + 1, path, sums)\n\n    dfs(nums[:n], 0, 0, lSums)\n    dfs(nums[n:], 0, 0, rSums)\n    rSums.sort()\n\n    for lSum in lSums:\n      i = bisect_left(rSums, goal - lSum)\n      if i < len(rSums):  # 2^n\n        ans = min(ans, abs(goal - lSum - rSums[i]))\n      if i > 0:\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\n\n    return ans",
      "title": "1755. Closest Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed66860e-56d7-4c58-af64-28dd650292b8",
      "code": "class Solution:\n  def minOperations(self, s: str) -> int:\n    # the cost to make s \"1010\"\n    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))\n    # the cost to make s \"0101\"\n    cost01 = len(s) - cost10\n    return min(cost10, cost01)",
      "title": "1758. Minimum Changes To Make Alternating Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d9eb2c7-834b-4565-b443-38d746a88541",
      "code": "class Solution:\n  def countHomogenous(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = 0\n    currentChar = '@'\n\n    for c in s:\n      count = count + 1 if c == currentChar else 1\n      currentChar = c\n      ans += count\n      ans %= MOD\n\n    return ans",
      "title": "1759. Count Number of Homogenous Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06406528-6581-48a8-b31e-abd229c6e5a8",
      "code": "class Solution:\n  def minimumSize(self, nums: list[int], maxOperations: int) -> int:\n    def numOperations(m: int) -> int:\n      \"\"\"Returns the number of operations required to make m penalty.\"\"\"\n      return sum((num - 1) // m for num in nums)\n    l = 1\n    r = max(nums)\n    return bisect.bisect_left(\n        range(l, r),\n        True, key=lambda m: numOperations(m) <= maxOperations) + l",
      "title": "1760. Minimum Limit of Balls in a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a7fc0c2-ce26-4c70-a8bd-4cbbceff3049",
      "code": "class Solution:\n  def minTrioDegree(self, n: int, edges: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [set() for _ in range(n)]\n    degrees = [0] * n\n\n    for u, v in edges:\n      u -= 1\n      v -= 1\n      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.\n      graph[min(u, v)].add(max(u, v))\n      degrees[u] += 1\n      degrees[v] += 1\n\n    for u in range(n):\n      for v in graph[u]:\n        for w in graph[u]:\n          if w in graph[v]:\n            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)\n\n    return -1 if ans == math.inf else ans",
      "title": "1761. Minimum Degree of a Connected Trio in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1b480a7-afc3-443b-830d-7551f98acfd8",
      "code": "class Solution:\n  def findBuildings(self, heights: list[int]) -> list[int]:\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        stack.pop()\n      stack.append(i)\n\n    return stack",
      "title": "1762. Buildings With an Ocean View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5b2b829-b71e-474c-a2cc-426b4e03c870",
      "code": "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n    if len(s) < 2:\n      return ''\n\n    seen = set(s)\n\n    for i, c in enumerate(s):\n      # If both upper and lower case letters exists in the string, keep moving,\n      # else take the erroneous character as a partition and check for its left\n      # and right parts to be nice strings.\n      if c.swapcase() not in seen:\n        prefix = self.longestNiceSubstring(s[:i])\n        suffix = self.longestNiceSubstring(s[i + 1:])\n        return max(prefix, suffix, key=len)\n\n    return s",
      "title": "1763. Longest Nice Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cbc9194-82ab-4566-86e0-bc19daef342e",
      "code": "class Solution:\n  def canChoose(self, groups: list[list[int]], nums: list[int]) -> bool:\n    i = 0  # groups' index\n    j = 0  # nums' index\n\n    while i < len(groups) and j < len(nums):\n      if self._isMatch(groups[i], nums, j):\n        j += len(groups[i])\n        i += 1\n      else:\n        j += 1\n\n    return i == len(groups)\n\n  # Returns True if group == nums[j..j + |group|].\n  def _isMatch(self, group: list[int], nums: list[int], j: int) -> bool:\n    if j + |group | > len(nums):\n      return False\n    for i, g in enumerate(group):\n      if g != nums[j + i]:\n        return False\n    return True",
      "title": "1764. Form Array by Concatenating Subarrays of Another Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5a893f8-a243-4bd8-b327-095bb9840bab",
      "code": "class Solution:\n  def highestPeak(self, isWater: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans",
      "title": "1765. Map of Highest Peak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af711d79-23ea-42fa-a41e-5f9ed3f270bb",
      "code": "class Solution:\n  def getCoprimes(self, nums: list[int], edges: list[list[int]]) -> list[int]:\n    MAX = 50\n    ans = [-1] * len(nums)\n    tree = [[] for _ in range(len(nums))]\n    # stacks[i] := (node, depth)s of nodes with value i\n    stacks = [[] for _ in range(MAX + 1)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def getAncestor(u: int) -> int:\n      maxNode = -1\n      maxDepth = -1\n      for i, stack in enumerate(stacks):\n        if stack and stack[-1][1] > maxDepth and math.gcd(nums[u], i) == 1:\n          maxNode, maxDepth = stack[-1]\n      return maxNode\n\n    def dfs(u: int, prev: int, depth: int) -> int:\n      ans[u] = getAncestor(u)\n      stacks[nums[u]].append((u, depth))\n\n      for v in tree[u]:\n        if v != prev:\n          dfs(v, u, depth + 1)\n\n      stacks[nums[u]].pop()\n\n    dfs(0, -1, 0)\n    return ans",
      "title": "1766. Tree of Coprimes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49e8f2de-1de6-4b09-a71e-e4fd180d4328",
      "code": "class Solution:\n  def mergeAlternately(self, word1: str, word2: str) -> str:\n    return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))",
      "title": "1768. Merge Strings Alternately",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e995f08f-894e-401e-ba0e-ee3fe4f2f3f3",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], multipliers: list[int]) -> int:\n    @functools.lru_cache(2000)\n    def dp(s: int, i: int) -> int:\n      \"\"\"Returns the maximum score of nums[s..e] and multipliers[i].\"\"\"\n      if i == len(multipliers):\n        return 0\n\n      # The number of nums picked on the start side is s.\n      # The number of nums picked on the end side is i - s.\n      # So, e = n - (i - s) - 1.\n      e = len(nums) - (i - s) - 1\n      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)\n      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)\n      return max(pickStart, pickEnd)\n\n    return dp(0, 0)",
      "title": "1770. Maximum Score from Performing Multiplication Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b71b840-0c2b-479d-86e9-f4ff8ba32f93",
      "code": "class Solution:\n  def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:\n    ans = []\n    stack = []  # (pos, speed, collisionTime)\n\n    def getCollisionTime(\n            car: tuple[int, int, int],\n            pos: int, speed: int) -> float:\n      return (car[0] - pos) / (speed - car[1])\n\n    for pos, speed in reversed(cars):\n      while stack and (\n              speed <= stack[-1][1] or getCollisionTime(stack[-1],\n                                                        pos, speed) >=\n              stack[-1][2]):\n        stack.pop()\n      if stack:\n        collisionTime = getCollisionTime(stack[-1], pos, speed)\n        stack.append((pos, speed, collisionTime))\n        ans.append(collisionTime)\n      else:\n        stack.append((pos, speed, math.inf))\n        ans.append(-1)\n\n    return ans[::-1]",
      "title": "1776. Car Fleet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36c99d6c-49d8-49cc-bb92-d4250b50f2d6",
      "code": "class Solution:\n  def checkPowersOfThree(self, n: int) -> bool:\n    while n > 1:\n      n, r = divmod(n, 3)\n      if r == 2:\n        return False\n    return True",
      "title": "1780. Check if Number is a Sum of Powers of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d4277f4-dee6-4df0-a2ab-207b60ae20ca",
      "code": "class Solution:\n  def beautySum(self, s: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      count = collections.Counter()\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        ans += max(count.values()) - min(count.values())\n\n    return ans",
      "title": "1781. Sum of Beauty of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1590b06-8503-43d6-b19a-3404eef45dbd",
      "code": "class Solution:\n  def countPairs(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n\n    # count[i] := the number of edges of node i\n    count = [0] * (n + 1)\n\n    # shared[i][j] := the number of edges incident to i or j, where i < j\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          # sortedCount[i] + sortedCount[j] > query\n          # sortedCount[i + 1] + sortedCount[j] > query\n          # ...\n          # sortedCount[j - 1] + sortedCount[j] > query\n          # So, there are (j - 1) - i + 1 = j - i pairs > query\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans",
      "title": "1782. Count Pairs Of Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20af0ab0-41ea-45d4-8d2e-3d78aa21f3b1",
      "code": "class Solution:\n  def checkOnesSegment(self, s: str) -> bool:\n    return '01' not in s",
      "title": "1784. Check if Binary String Has at Most One Segment of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f746be9-42ab-468c-b150-41c8f91313f1",
      "code": "class Solution:\n  def countRestrictedPaths(self, n: int, edges: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    # ways[i] := the number of restricted path from i to n\n    ways = [0] * len(graph)\n    # dist[i] := the distance to the last node of i\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= MOD\n\n    return ways[src]",
      "title": "1786. Number of Restricted Paths From First to Last Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7fdc2bd-c64d-4da5-a0ac-7960681a292d",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    MAX = 1024\n    n = len(nums)\n    # counts[i] := the counter that maps at the i-th position\n    counts = [collections.Counter() for _ in range(k)]\n    # dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k - 1]) is j\n    dp = [[n] * MAX for _ in range(k)]\n\n    for i, num in enumerate(nums):\n      counts[i % k][num] += 1\n\n    def countAt(i: int) -> int:\n      return n // k + (1 if n % k > i else 0)\n\n    # Initialize the DP array.\n    for j in range(MAX):\n      dp[k - 1][j] = countAt(k - 1) - counts[k - 1][j]\n\n    for i in range(k - 2, -1, -1):\n      # The worst-case scenario is changing all the i-th position numbers to a\n      # non-existent value in the current bucket.\n      changeAll = countAt(i) + min(dp[i + 1])\n      for j in range(MAX):\n        dp[i][j] = changeAll\n        for num, freq in counts[i].items():\n          # the cost to change every number in the i-th position to `num`\n          cost = countAt(i) - freq\n          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost)\n\n    return dp[0][0]",
      "title": "1787. Make the XOR of All Segments Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "530902b2-6799-437d-955d-8a65c51738db",
      "code": "class Solution:\n  def maximumBeauty(self, flowers: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    flowerToPrefix = collections.defaultdict(int)\n\n    for flower in flowers:\n      if flower in flowerToPrefix:\n        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)\n      prefix += max(0, flower)\n      flowerToPrefix.setdefault(flower, prefix)\n\n    return ans",
      "title": "1788. Maximize the Beauty of the Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4a6f2e4-5066-45e5-81e8-8eaa5e09839f",
      "code": "class Solution:\n  # Similar to 859. Buddy Strings\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    return not diffIndices or (len(diffIndices) == 2 and\n                               s1[diffIndices[0]] == s2[diffIndices[1]] and\n                               s1[diffIndices[1]] == s2[diffIndices[0]])",
      "title": "1790. Check if One String Swap Can Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7c242dc-a5e8-43e5-8e0e-fe77086427f8",
      "code": "class Solution:\n  def findCenter(self, edges: list[list[int]]) -> int:\n    if edges[0][0] in edges[1]:\n      return edges[0][0]\n    return edges[0][1]",
      "title": "1791. Find Center of Star Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed81ffb-5cfd-4c00-8aa8-44d1e8da8944",
      "code": "class Solution:\n  def maxAverageRatio(\n      self,\n      classes: list[list[int]],\n      extraStudents: int,\n  ) -> float:\n    def extraPassRatio(pas: int, total: int) -> float:\n      \"\"\"Returns the extra pass ratio if a brilliant student joins.\"\"\"\n      return (pas + 1) / (total + 1) - pas / total\n\n    maxHeap = [(-extraPassRatio(pas, total), pas, total)\n               for pas, total in classes]\n    heapq.heapify(maxHeap)\n\n    for _ in range(extraStudents):\n      _, pas, total = heapq.heappop(maxHeap)\n      heapq.heappush(\n          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))\n\n    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)",
      "title": "1792. Maximum Average Pass Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e9b2078-8527-497e-929f-b65455655474",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = nums[k]\n    mn = nums[k]\n    i = k\n    j = k\n\n    # Greedily expand the window and decrease the minimum as slow as possible.\n    while i > 0 or j < n - 1:\n      if i == 0:\n        j += 1\n      elif j == n - 1:\n        i -= 1\n      elif nums[i - 1] < nums[j + 1]:\n        j += 1\n      else:\n        i -= 1\n      mn = min(mn, nums[i], nums[j])\n      ans = max(ans, mn * (j - i + 1))\n\n    return ans",
      "title": "1793. Maximum Score of a Good Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07167452-124a-4b9a-84d0-33f751ad9e3b",
      "code": "class Solution:\n  def countQuadruples(self, s1: str, s2: str) -> int:\n    # To minimize j - a, the length of the substring should be 1. This is\n    # because for substrings with a size greater than 1, a will decrease,\n    # causing j - a to become larger.\n    ans = 0\n    diff = math.inf  # diff := j - a\n    firstJ = {}\n    lastA = {}\n\n    for j in range(len(s1) - 1, -1, -1):\n      firstJ[s1[j]] = j\n\n    for a in range(len(s2)):\n      lastA[s2[a]] = a\n\n    for c in string.ascii_lowercase:\n      if c not in firstJ or c not in lastA:\n        continue\n      if firstJ[c] - lastA[c] < diff:\n        diff = firstJ[c] - lastA[c]\n        ans = 0\n      if firstJ[c] - lastA[c] == diff:\n        ans += 1\n\n    return ans",
      "title": "1794. Count Pairs of Equal Substrings With Minimum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "793b407d-7b47-4587-8ed7-9d2d8f457f88",
      "code": "class Solution:\n  def secondHighest(self, s: str) -> int:\n    maxDigit = -1\n    secondMaxDigit = -1\n\n    for c in s:\n      if c.isdigit():\n        d = int(c)\n        if d > maxDigit:\n          secondMaxDigit = maxDigit\n          maxDigit = d\n        elif maxDigit > d > secondMaxDigit:\n          secondMaxDigit = d\n\n    return secondMaxDigit",
      "title": "1796. Second Largest Digit in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b05e009-fa73-42c0-acc5-e44713e640b1",
      "code": "class Solution:\n  def getMaximumConsecutive(self, coins: list[int]) -> int:\n    ans = 1  # the next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
      "title": "1798. Maximum Number of Consecutive Values You Can Make",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffadf7cc-a3fb-4761-b512-b37c0fd470bc",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n\n    @functools.lru_cache(None)\n    def dp(k: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score you can receive after performing the k to n\n      operations, where `mask` is the bitmask of the chosen numbers.\n      \"\"\"\n      if k == n + 1:\n        return 0\n\n      res = 0\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        chosenMask = 1 << i | 1 << j\n        if (mask & chosenMask) == 0:\n          res = max(res, k * math.gcd(nums[i], nums[j])\n                    + dp(k + 1, mask | chosenMask))\n\n      return res\n\n    return dp(1, 0)",
      "title": "1799. Maximize Score After N Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a44dece2-9f92-4635-9800-cd8888ef284c",
      "code": "class Solution:\n  def maxAscendingSum(self, nums: list[int]) -> int:\n    ans = 0\n    sum = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        sum += nums[i]\n      else:\n        ans = max(ans, sum)\n        sum = nums[i]\n\n    return max(ans, sum)",
      "title": "1800. Maximum Ascending Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2972c38b-221c-40da-8029-932fdf51cd78",
      "code": "class Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    return ['0'] if index == -1 else s[index:]",
      "title": "1805. Number of Different Integers in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65705507-6a99-42d1-a2b6-3bc821a89c66",
      "code": "class Solution:\n  def squareIsWhite(self, coordinates: str) -> bool:\n    letter, digit = coordinates\n    return ord(letter) % 2 != int(digit) % 2",
      "title": "1812. Determine Color of a Chessboard Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81465fc1-9640-4d83-9313-a525e86732b0",
      "code": "class Solution:\n  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n    if len(sentence1) == len(sentence2):\n      return sentence1 == sentence2\n\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n    m, n = map(len, (words1, words2))\n    if m > n:\n      return self.areSentencesSimilar(sentence2, sentence1)\n\n    i = 0  # words1's index\n    while i < m and words1[i] == words2[i]:\n      i += 1\n    while i < m and words1[i] == words2[i + n - m]:\n      i += 1\n\n    return i == m",
      "title": "1813. Sentence Similarity III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "971e00a1-df33-4e66-a8c7-9ab9d78a0db2",
      "code": "class Solution:\n  def countNicePairs(self, nums: list[int]) -> int:\n    freqs = collections.Counter(num - int(str(num)[::-1]) for num in nums)\n    return sum(freq * (freq - 1) // 2 for freq in freqs.values()) % 1000000007",
      "title": "1814. Count Nice Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a066621-c15e-4e60-a057-2c640868f045",
      "code": "class Solution:\n  def maxHappyGroups(self, batchSize: int, groups: list[int]) -> int:\n    happy = 0\n    freq = [0] * batchSize\n\n    for g in groups:\n      g %= batchSize\n      if g == 0:\n        happy += 1\n      elif freq[batchSize - g]:\n        freq[batchSize - g] -= 1\n        happy += 1\n      else:\n        freq[g] += 1\n\n    @functools.lru_cache(None)\n    def dp(freq: int, remainder: int) -> int:\n      \"\"\"Returns the maximum number of partitions can be formed.\"\"\"\n      ans = 0\n      if any(freq):\n        for i, f in enumerate(freq):\n          if f:\n            ans = max(ans, dp(freq[:i] + (f - 1,) +\n                              freq[i + 1:], (remainder + i) % batchSize))\n        if remainder == 0:\n          ans += 1\n      return ans\n\n    return happy + dp(tuple(freq), 0)",
      "title": "1815. Maximum Number of Groups Getting Fresh Donuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f0fdc38-5cbf-4686-bc30-7174cd53b23b",
      "code": "class Solution:\n  def truncateSentence(self, s: str, k: int) -> str:\n    return ' '.join(s.split()[:k])",
      "title": "1816. Truncate Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "599ef220-7d9c-444d-a2e7-98198f83a1df",
      "code": "class Solution:\n  def findingUsersActiveMinutes(\n      self,\n      logs: list[list[int]],\n      k: int,\n  ) -> list[int]:\n    idToTimes = collections.defaultdict(set)\n\n    for id, time in logs:\n      idToTimes[id].add(time)\n\n    c = collections.Counter(len(times) for times in idToTimes.values())\n    return [c[i] for i in range(1, k + 1)]",
      "title": "1817. Finding the Users Active Minutes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdb66090-7c93-439f-a020-d19e3c3eb9b9",
      "code": "class Solution:\n  def minAbsoluteSumDiff(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = math.inf\n    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]\n    sumDiff = sum(diffs)\n\n    nums1.sort()\n\n    for num, diff in zip(nums2, diffs):\n      i = bisect.bisect_left(nums1, num)\n      if i > 0:\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))\n      if i < len(nums1):\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))\n\n    return ans % 1_000_000_007",
      "title": "1818. Minimum Absolute Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "149acde2-8c80-4c15-ba0c-1d5903ea68cf",
      "code": "class Solution:\n  def maximumInvitations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    mates = [-1] * n  # mates[i] := the i-th girl's mate\n\n    def canInvite(i: int, seen: list[bool]) -> bool:\n      \"\"\"Returns True if the i-th boy can make an invitation.\"\"\"\n      # The i-th boy asks each girl.\n      for j in range(n):\n        if not grid[i][j] or seen[j]:\n          continue\n        seen[j] = True\n        if mates[j] == -1 or canInvite(mates[j], seen):\n          mates[j] = i  # Match the j-th girl with i-th boy.\n          return True\n      return False\n\n    for i in range(m):\n      seen = [False] * n\n      if canInvite(i, seen):\n        ans += 1\n\n    return ans",
      "title": "1820. Maximum Number of Accepted Invitations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "294ed14d-0ac8-4883-850a-1a1ed236341e",
      "code": "class Solution:\n  def arraySign(self, nums: list[int]) -> int:\n    sign = 1\n\n    for num in nums:\n      if num == 0:\n        return 0\n      if num < 0:\n        sign = -sign\n\n    return sign",
      "title": "1822. Sign of the Product of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a17bb402-8102-4e98-8f12-d266d45d8c16",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # e.g. n = 4, k = 2.\n    # By using 0-indexed notation, we have the following circle:\n    #\n    # 0 -> 1 -> 2 -> 3 -> 0\n    #      x\n    #           0 -> 1 -> 2 -> 0\n    #\n    # After the first round, 1 is removed.\n    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n    def f(n: int, k: int) -> int:\n      ans = 0  # f(1, k)\n      # Computes f(i, k) based on f(i - 1, k).\n      for i in range(2, n + 1):\n        ans = (ans + k) % i\n      return ans\n\n    # Converts back to 1-indexed.\n    return f(n, k) + 1",
      "title": "1823. Find the Winner of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cc675ce-3f4e-4412-bf2a-df2955b55fda",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # True if i-th friend is left\n    friends = [False] * n\n\n    friendCount = n\n    fp = 0  # friends' index\n\n    while friendCount > 1:\n      for _ in range(k):\n        while friends[fp % n]:  # The friend is not there.\n          fp += 1  # Point to the next one.\n        fp += 1\n      friends[(fp - 1) % n] = True\n      friendCount -= 1\n\n    fp = 0\n    while friends[fp]:\n      fp += 1\n\n    return fp + 1",
      "title": "1823. Find the Winner of the Circular Game_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3d772c8-ad41-4710-8040-a48df327b0d0",
      "code": "class Solution:\n  def minSideJumps(self, obstacles: list[int]) -> int:\n    INF = 1e6\n    # dp[i] := the minimum jump to reach the i-th lane\n    dp = [INF, 1, 0, 1]\n\n    for obstacle in obstacles:\n      print(dp)\n      if obstacle > 0:\n        dp[obstacle] = INF\n      for i in range(1, 4):  # the current\n        if i != obstacle:\n          for j in range(1, 4):  # the previous\n            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))\n\n    return min(dp)",
      "title": "1824. Minimum Sideway Jumps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "495d80c1-277d-49c0-b032-dc85682a2c4b",
      "code": "class Solution:\n  def badSensor(self, sensor1: list[int], sensor2: list[int]) -> int:\n    # A -> B, so B is defect\n    def canReplace(A, B):\n      i = 0  # A's index\n      j = 0  # B's index\n      droppedValue = -1\n\n      while i < len(A):\n        if A[i] == B[j]:\n          i += 1\n          j += 1\n        else:\n          droppedValue = A[i]\n          i += 1\n\n      return j == len(B) - 1 and B[-1] != droppedValue\n\n    oneDefect = canReplace(sensor2, sensor1)\n    twoDefect = canReplace(sensor1, sensor2)\n    if oneDefect and twoDefect:\n      return -1\n    if not oneDefect and not twoDefect:\n      return -1\n    return 1 if oneDefect else 2",
      "title": "1826. Faulty Sensor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9d3b7ad-3380-4dd0-86da-28366a4e6a67",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    last = 0\n\n    for num in nums:\n      ans += max(0, last - num + 1)\n      last = max(num, last + 1)\n\n    return ans",
      "title": "1827. Minimum Operations to Make the Array Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "545482db-9a06-4812-b94f-6fac2ce64adf",
      "code": "class Solution:\n  def countPoints(\n      self,\n      points: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    for xj, yj, rj in queries:\n      count = 0\n      for xi, yi in points:\n        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:\n          count += 1\n      ans.append(count)\n\n    return ans",
      "title": "1828. Queries on Number of Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8db217e0-57ac-463c-8c0b-bf4d039ee364",
      "code": "class Solution:\n  def getMaximumXor(self, nums: list[int], maximumBit: int) -> list[int]:\n    mx = (1 << maximumBit) - 1\n    ans = []\n    xors = 0\n\n    for num in nums:\n      xors ^= num\n      ans.append(xors ^ mx)\n\n    return ans[::-1]",
      "title": "1829. Maximum XOR for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "734ddaf9-a8d3-4819-bd61-12f40646c695",
      "code": "class Solution:\n  def makeStringSorted(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = [0] * 26\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    for i, c in enumerate(reversed(s)):\n      order = ord(c) - ord('a')\n      count[order] += 1\n      # count[:order] := s[i] can be any character smaller than c\n      # fact(i) := s[i + 1..n - 1] can be any sequence of characters\n      perm = sum(count[:order]) * fact(i)\n      for j in range(26):\n        perm = perm * inv(fact(count[j])) % MOD\n      ans = (ans + perm) % MOD\n\n    return ans",
      "title": "1830. Minimum Number of Operations to Make String Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "617d0dd4-d07b-440e-b109-2d29d15c3731",
      "code": "class Solution:\n  def checkIfPangram(self, sentence: str) -> bool:\n    seen = 0\n\n    for c in sentence:\n      seen |= 1 << ord(c) - ord('a')\n\n    return seen == (1 << 26) - 1",
      "title": "1832. Check if the Sentence Is Pangram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "296c291f-8469-4e34-8dd3-2156bce0c138",
      "code": "class Solution:\n  def maxIceCream(self, costs: list[int], coins: int) -> int:\n    for i, cost in enumerate(sorted(costs)):\n      if coins >= cost:\n        coins -= cost\n      else:\n        return i\n\n    return len(costs)",
      "title": "1833. Maximum Ice Cream Bars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "771b9a73-f5a0-46a4-adf0-f0d70603ef59",
      "code": "class Solution:\n  def getOrder(self, tasks: list[list[int]]) -> list[int]:\n    n = len(tasks)\n    A = [[*task, i] for i, task in enumerate(tasks)]\n    ans = []\n    minHeap = []\n    i = 0  # tasks' index\n    time = 0  # the current time\n\n    A.sort()\n\n    while i < n or minHeap:\n      if not minHeap:\n        time = max(time, A[i][0])\n      while i < n and time >= A[i][0]:\n        heapq.heappush(minHeap, (A[i][1], A[i][2]))\n        i += 1\n      procTime, index = heapq.heappop(minHeap)\n      time += procTime\n      ans.append(index)\n\n    return ans",
      "title": "1834. Single-Threaded CPU",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5de11358-4426-48bc-95c7-a053258c5352",
      "code": "class Solution:\n  def getXORSum(self, arr1: list[int], arr2: list[int]) -> int:\n    return functools.reduce(\n        operator.xor, arr1) & functools.reduce(\n        operator.xor, arr2)",
      "title": "1835. Find XOR Sum of All Pairs Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7c7741a-a518-4ba8-aa9c-9d65b9597e68",
      "code": "class Solution:\n  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    count = collections.Counter()\n\n    curr = head\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    curr = dummy\n\n    while curr:\n      while curr.next and curr.next.val in count and count[curr.next.val] > 1:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return dummy.next",
      "title": "1836. Remove Duplicates From an Unsorted Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee216d27-2537-4ea0-86a9-832e007da2c1",
      "code": "class Solution:\n  def sumBase(self, n: int, k: int) -> int:\n    ans = 0\n\n    while n > 0:\n      ans += n % k\n      n //= k\n\n    return ans",
      "title": "1837. Sum of Digits in Base K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5213a99-ab4f-4046-b3a6-0fce28714db9",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    nums.sort()\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ + k < num * (r - l + 1):\n        summ -= nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1838. Frequency of the Most Frequent Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c02ee74b-9d6d-48d3-9876-467d9cf9419d",
      "code": "class Solution:\n  def longestBeautifulSubstring(self, word: str) -> int:\n    ans = 0\n    count = 1\n\n    l = 0\n    for r in range(1, len(word)):\n      curr = word[r]\n      prev = word[r - 1]\n      if curr >= prev:\n        if curr > prev:\n          count += 1\n        if count == 5:\n          ans = max(ans, r - l + 1)\n      else:\n        count = 1\n        l = r\n\n    return ans",
      "title": "1839. Longest Substring Of All Vowels in Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abe7003d-ed4f-4927-bf7b-d22a28b2d022",
      "code": "class Solution:\n  def maxBuilding(self, n: int, restrictions: list[list[int]]) -> int:\n    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])\n\n    for i in range(len(A)):\n      dist = A[i][0] - A[i - 1][0]\n      A[i][1] = min(A[i][1], A[i - 1][1] + dist)\n\n    for i in reversed(range(len(A) - 1)):\n      dist = A[i + 1][0] - A[i][0]\n      A[i][1] = min(A[i][1], A[i + 1][1] + dist)\n\n    ans = 0\n\n    for (l, hL), (r, hR) in zip(A, A[1:]):\n      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)\n\n    return ans",
      "title": "1840. Maximum Building Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2831400e-099b-4fae-b227-377b245ecb37",
      "code": "class Solution:\n  def nextPalindrome(self, num: str) -> str:\n    def nextPermutation(nums: list[int]) -> bool:\n      n = len(nums)\n\n      # From the back to the front, find the first num < nums[i + 1].\n      i = n - 2\n      while i >= 0:\n        if nums[i] < nums[i + 1]:\n          break\n        i -= 1\n\n      if i < 0:\n        return False\n\n      # From the back to the front, find the first num > nums[i] and swap it\n      # with nums[i].\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n      def reverse(nums, l, r):\n        while l < r:\n          nums[l], nums[r] = nums[r], nums[l]\n          l += 1\n          r -= 1\n\n      # Reverse nums[i + 1..n - 1].\n      reverse(nums, i + 1, len(nums) - 1)\n      return True\n\n    n = len(num)\n    arr = [int(num[i]) for i in range(len(num) // 2)]\n    if not nextPermutation(arr):\n      return ''\n\n    s = ''.join([chr(ord('0') + a) for a in arr])\n    if n % 2 == 1:\n      return s + num[n // 2] + s[::-1]\n    return s + s[::-1]",
      "title": "1842. Next Palindrome Using Same Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ffe3716-9ec1-486a-9ae9-7aca9bd6e051",
      "code": "class Solution:\n  def replaceDigits(self, s: str) -> str:\n    return ''.join(\n        c if i % 2 == 0 else chr(ord(s[i - 1]) + int(c))\n        for i, c in enumerate(s)\n    )",
      "title": "1844. Replace All Digits with Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b6e53f0-dd13-4db7-9a16-f14346943272",
      "code": "class Solution:\n  def maximumElementAfterDecrementingAndRearranging(\n      self, arr: list[int],\n  ) -> int:\n    arr.sort()\n    arr[0] = 1\n\n    for i in range(1, len(arr)):\n      arr[i] = min(arr[i], arr[i - 1] + 1)\n\n    return arr[-1]",
      "title": "1846. Maximum Element After Decreasing and Rearranging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "971cadfc-7352-435a-94e2-ac8c122ec7b5",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def closestRoom(\n      self,\n      rooms: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    qs = [[*q, i] for i, q in enumerate(queries)]\n    roomIds = SortedList()\n\n    rooms.sort(key=lambda x: -x[1])\n    qs.sort(key=lambda x: -x[1])\n\n    def searchClosestRoomId(roomIds: SortedList, preferred: int):\n      if not roomIds:\n        return -1\n\n      candIds = []\n      i = roomIds.bisect_right(preferred)\n      if i > 0:\n        candIds.append(roomIds[i - 1])\n      if i < len(roomIds):\n        candIds.append(roomIds[i])\n      return min(candIds, key=lambda x: abs(x - preferred))\n\n    i = 0  # rooms' index\n    for preferred, minSize, index in qs:\n      while i < len(rooms) and rooms[i][1] >= minSize:\n        roomIds.add(rooms[i][0])\n        i += 1\n      ans[index] = searchClosestRoomId(roomIds, preferred)\n\n    return ans",
      "title": "1847. Closest Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbf8896c-e16f-46be-85a8-a86b8043ceaf",
      "code": "class Solution:\n  def getMinDistance(self, nums: list[int], target: int, start: int) -> int:\n    ans = math.inf\n\n    for i, num in enumerate(nums):\n      if num == target:\n        ans = min(ans, abs(i - start))\n\n    return ans",
      "title": "1848. Minimum Distance to the Target Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89da1a01-135a-4c49-9301-66f32845cff4",
      "code": "class Solution:\n  def splitString(self, s: str) -> bool:\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\n      if start == len(s) and segment > 1:\n        return True\n\n      curr = 0\n      for i in range(start, len(s)):\n        curr = curr * 10 + int(s[i])\n        if curr > 9999999999:\n          return False\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\n          return True\n\n      return False\n\n    return isValid(s, 0, -1, 0)",
      "title": "1849. Splitting a String Into Descending Consecutive Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "336cf719-9f79-478f-be31-a713cd927485",
      "code": "class Solution:\n  def getMinSwaps(self, num: str, k: int) -> int:\n    original = [int(c) for c in num]\n    permutated = original.copy()\n\n    for _ in range(k):\n      self._nextPermutation(permutated)\n\n    return self._countSteps(original, permutated)\n\n  def _nextPermutation(self, nums: list[int]):\n    n = len(nums)\n\n    # From the back to the front, find the first num < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From the back to the front, find the first num > nums[i] and swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums, l, r):\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)\n\n  def _countSteps(self, A: list[int], B: list[int]) -> int:\n    count = 0\n\n    j = 0\n    for i in range(len(A)):\n      j = i\n      while A[i] != B[j]:\n        j += 1\n      while i < j:\n        B[j], B[j - 1] = B[j - 1], B[j]\n        j -= 1\n        count += 1\n\n    return count",
      "title": "1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b55cb69-ce8e-4273-b95c-f8b50ecf97f5",
      "code": "class Solution:\n  def distinctNumbers(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    count = collections.Counter()\n    distinct = 0\n\n    for i, num in enumerate(nums):\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n      if i >= k - 1:\n        ans.append(distinct)\n\n    return ans",
      "title": "1852. Distinct Numbers in Each Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad1fb492-6612-435f-aa68-d3950f8314c4",
      "code": "class Solution:\n  def maximumPopulation(self, logs: list[list[int]]) -> int:\n    MIN_YEAR = 1950\n    MAX_YEAR = 2050\n    ans = 0\n    maxPopulation = 0\n    runningPopulation = 0\n    # population[i] := the population of year i\n    population = [0] * (MAX_YEAR + 1)\n\n    for birth, death in logs:\n      population[birth] += 1\n      population[death] -= 1\n\n    for year in range(MIN_YEAR, MAX_YEAR + 1):\n      runningPopulation += population[year]\n      if runningPopulation > maxPopulation:\n        maxPopulation = runningPopulation\n        ans = year\n\n    return ans",
      "title": "1854. Maximum Population Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6950df3e-fbc2-4854-b54f-806671e22413",
      "code": "class Solution:\n  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    i = 0\n    j = 0\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] > nums2[j]:\n        i += 1\n      else:\n        ans = max(ans, j - i)\n        j += 1\n\n    return ans",
      "title": "1855. Maximum Distance Between a Pair of Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e925b95d-25ce-40f1-bbbe-18908d4d1e67",
      "code": "class Solution:\n  def maxSumMinProduct(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        minVal = nums[stack.pop()]\n        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]\n        ans = max(ans, minVal * summ)\n      stack.append(i)\n\n    return ans % 1_000_000_007",
      "title": "1856. Maximum Subarray Min-Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4fcf1930-c29f-4acf-96e9-22da0264a3fc",
      "code": "class Solution:\n  def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Vpology\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans if processed == n else -1",
      "title": "1857. Largest Color Value in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "770a0458-1085-41da-90b1-012d32fb5510",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def longestWord(self, words: list[str]) -> str:\n    ans = ''\n\n    for word in words:\n      self.insert(word)\n\n    for word in words:\n      if not self.allPrefixed(word):\n        continue\n      if len(ans) < len(word) or (len(ans) == len(word) and ans > word):\n        ans = word\n\n    return ans\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['isWord'] = True\n\n  def allPrefixed(self, word: str) -> bool:\n    node = self.root\n    for c in word:\n      node = node[c]\n      if 'isWord' not in node:\n        return False\n    return True",
      "title": "1858. Longest Word With All Prefixes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab391bf2-e0d6-4104-822e-cbb61c1685d3",
      "code": "class Solution:\n  def sortSentence(self, s: str) -> str:\n    return ' '.join([word[:-1]\n                     for word in sorted(s.split(), key=lambda x: x[-1])])",
      "title": "1859. Sorting the Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0a404cc-7452-4ba4-83cf-676d1b267cf2",
      "code": "class Solution:\n  def memLeak(self, memory1: int, memory2: int) -> list[int]:\n    i = 1\n\n    while memory1 >= i or memory2 >= i:\n      if memory1 >= memory2:\n        memory1 -= i\n      else:\n        memory2 -= i\n      i += 1\n\n    return [i, memory1, memory2]",
      "title": "1860. Incremental Memory Leak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4229edfd-7cc7-4233-a713-d212d38ace2f",
      "code": "class Solution:\n  def rotateTheBox(self, box: list[list[str]]) -> list[list[str]]:\n    m = len(box)\n    n = len(box[0])\n    rotated = [['.'] * m for _ in range(n)]\n\n    for i in range(m):\n      k = n - 1\n      for j in reversed(range(n)):\n        if box[i][j] != '.':\n          if box[i][j] == '*':\n            k = j\n          rotated[k][m - i - 1] = box[i][j]\n          k -= 1\n\n    return [''.join(row) for row in rotated]",
      "title": "1861. Rotating the Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b875748-b4a9-4b59-af2c-ec5bb5268c7c",
      "code": "class Solution:\n  def sumOfFlooredPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = max(nums)\n    ans = 0\n    count = [0] * (MAX + 1)\n\n    for num in nums:\n      count[num] += 1\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    for i in range(1, MAX + 1):\n      if count[i] > count[i - 1]:\n        summ = 0\n        j = 1\n        while i * j <= MAX:\n          lo = i * j - 1\n          hi = i * (j + 1) - 1\n          summ += (count[min(hi, MAX)] - count[lo]) * j\n          j += 1\n        ans += summ * (count[i] - count[i - 1])\n        ans %= MOD\n\n    return ans",
      "title": "1862. Sum of Floored Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e97057dc-d141-49f9-a658-9c3e40868b8b",
      "code": "class Solution:\n  def subsetXORSum(self, nums: list[int]) -> int:\n    def dfs(i: int, xors: int) -> int:\n      if i == len(nums):\n        return xors\n\n      x = dfs(i + 1, xors)\n      y = dfs(i + 1, nums[i] ^ xors)\n      return x + y\n\n    return dfs(0, 0)",
      "title": "1863. Sum of All Subset XOR Totals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5226353-e76a-4ab8-b41f-939a3374db6b",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    ones = s.count('1')\n    zeros = len(s) - ones\n    if abs(ones - zeros) > 1:\n      return -1\n\n    def countSwaps(curr: str) -> int:\n      swaps = 0\n      for c in s:\n        if c != curr:\n          swaps += 1\n        curr = chr(ord(curr) ^ 1)\n      return swaps // 2\n\n    if ones > zeros:\n      return countSwaps('1')\n    if zeros > ones:\n      return countSwaps('0')\n    return min(countSwaps('1'), countSwaps('0'))",
      "title": "1864. Minimum Number of Swaps to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01ef3553-3898-4918-99fb-b2a043de82f3",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def rearrangeSticks(self, n: int, k: int) -> int:\n    if n == k:\n      return 1\n    if k == 0:\n      return 0\n    return (self.rearrangeSticks(n - 1, k - 1) +\n            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.MOD\n\n  MOD = 1_000_000_007",
      "title": "1866. Number of Ways to Rearrange Sticks With K Sticks Visible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34ac6f9e-2878-4356-88b8-a7c78b4d1c60",
      "code": "class Solution:\n  def findRLEArray(self, encoded1: list[list[int]],\n                   encoded2: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # encoded1's index\n    j = 0  # encoded2's index\n\n    while i < len(encoded1) and j < len(encoded2):\n      mult = encoded1[i][0] * encoded2[j][0]\n      minFreq = min(encoded1[i][1], encoded2[j][1])\n      if ans and mult == ans[-1][0]:\n        ans[-1][1] += minFreq\n      else:\n        ans.append([mult, minFreq])\n      encoded1[i][1] -= minFreq\n      encoded2[j][1] -= minFreq\n      if encoded1[i][1] == 0:\n        i += 1\n      if encoded2[j][1] == 0:\n        j += 1\n\n    return ans",
      "title": "1868. Product of Two Run-Length Encoded Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4108a4d4-8143-4b51-b096-8ef0edac119b",
      "code": "class Solution:\n  def checkZeroOnes(self, s: str) -> bool:\n    longestOnes = 0\n    longestZeros = 0\n    currentOnes = 0\n    currentZeros = 0\n\n    for c in s:\n      if c == '0':\n        currentOnes = 0\n        currentZeros += 1\n        longestZeros = max(longestZeros, currentZeros)\n      else:\n        currentZeros = 0\n        currentOnes += 1\n        longestOnes = max(longestOnes, currentOnes)\n\n    return longestOnes > longestZeros",
      "title": "1869. Longer Contiguous Segments of Ones than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1db298de-88e1-4d50-9182-88750afa7a18",
      "code": "class Solution:\n  def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\n    ans = -1\n    l = 1\n    r = int(1e7)\n\n    def time(speed: int) -> float:\n      summ = 0\n      for i in range(len(dist) - 1):\n        summ += math.ceil(dist[i] / speed)\n      return summ + dist[-1] / speed\n\n    while l <= r:\n      m = (l + r) // 2\n      if time(m) > hour:\n        l = m + 1\n      else:\n        ans = m\n        r = m - 1\n\n    return ans",
      "title": "1870. Minimum Speed to Arrive on Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51dcd9fe-1d61-41db-845f-0aa86e6c8b0a",
      "code": "class Solution:\n  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n    count = 0\n    dp = [True] + [False] * (len(s) - 1)\n\n    for i in range(minJump, len(s)):\n      count += dp[i - minJump]\n      if i - maxJump > 0:\n        count -= dp[i - maxJump - 1]\n      dp[i] = count and s[i] == '0'\n\n    return dp[-1]",
      "title": "1871. Jump Game VII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27176cda-760e-4361-a061-928fa223f5e8",
      "code": "class Solution:\n  def stoneGameVIII(self, stones: list[int]) -> int:\n    n = len(stones)\n    prefix = list(itertools.accumulate(stones))\n    # dp[i] := the maximum score difference the current player can get when the\n    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    dp = [-math.inf] * n\n\n    # Must take all when there're only two stones left.\n    dp[n - 2] = prefix[-1]\n\n    for i in reversed(range(n - 2)):\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])\n\n    return dp[0]",
      "title": "1872. Stone Game VIII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8c1fed-1c7f-45f9-aa16-e3078dcc7ff0",
      "code": "class Solution:\n  def minProductSum(self, nums1: list[int], nums2: list[int]) -> int:\n    return sum([a * b for a, b in zip(sorted(nums1), sorted(nums2, reverse=True))])",
      "title": "1874. Minimize Product Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac7c5356-e106-4109-8e3c-fa5d2966f17d",
      "code": "class Solution:\n  def countGoodSubstrings(self, s: str) -> int:\n    ans = 0\n\n    for a, b, c in zip(s, s[1:], s[2:]):\n      if a == b or a == c or b == c:\n        continue\n      ans += 1\n\n    return ans",
      "title": "1876. Substrings of Size Three with Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b31306a-72b8-424a-befb-dcc69a00cf2a",
      "code": "class Solution:\n  def minPairSum(self, nums: list[int]) -> int:\n    nums.sort()\n    return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) // 2))",
      "title": "1877. Minimize Maximum Pair Sum in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae6d2ba9-cfbe-4b27-a7ba-699705637130",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return sums\n\n  def _getSum(self, grid: list[list[int]], i: int, j: int, sz: int) -> int:\n    \"\"\"\n    Returns the sum of the rhombus, where the top grid is (i, j) and the edge\n    size is `sz`.\n    \"\"\"\n    x = i\n    y = j\n    summ = 0\n\n    # Go left down.\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right down.\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right up.\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    # Go left up.\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ",
      "title": "1878. Get Biggest Three Rhombus Sums in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f657aaef-fdd6-4114-875b-ea720aab63a1",
      "code": "class Solution:\n  def minimumXORSum(self, nums1: list[int], nums2: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      i = mask.bit_count()\n      if i == len(nums1):\n        return 0\n      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)\n                 for j in range(len(nums2)) if not mask >> j & 1)\n    return dp(0)",
      "title": "1879. Minimum XOR Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e3a6415-6e58-4275-bbdf-fcdbe6c47750",
      "code": "class Solution:\n  def isSumEqual(\n      self,\n      firstWord: str,\n      secondWord: str,\n      targetWord: str,\n  ) -> bool:\n    first = self._getNumber(firstWord)\n    second = self._getNumber(secondWord)\n    target = self._getNumber(targetWord)\n    return first + second == target\n\n  def _getNumber(self, word: str) -> int:\n    num = 0\n    for c in word:\n      num = num * 10 + ord(c) - ord('a')\n    return num",
      "title": "1880. Check if Word Equals Summation of Two Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67227d14-51fa-4098-b8e1-b52f148a3edf",
      "code": "class Solution:\n  def maxValue(self, n: str, x: int) -> str:\n    isNegative = n[0] == '-'\n\n    for i, c in enumerate(n):\n      if not isNegative and int(c) < x or isNegative and int(c) > x:\n        return n[:i] + str(x) + n[i:]\n\n    return n + str(x)",
      "title": "1881. Maximum Value after Insertion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "995a9e95-1aa6-4dd9-bd04-b93a6b7ef9bb",
      "code": "class Solution:\n  def assignTasks(self, servers: list[int], tasks: list[int]) -> list[int]:\n    ans = []\n    free = []  # (weight, index, freeTime)\n    used = []  # (freeTime, weight, index)\n\n    for i, weight in enumerate(servers):\n      heapq.heappush(free, (weight, i, 0))\n\n    for i, executionTime in enumerate(tasks):  # i := the current time\n      # Poll all servers that'll be free at time i.\n      while used and used[0][0] <= i:\n        curr = heapq.heappop(used)\n        heapq.heappush(free, (curr[1], curr[2], curr[0]))\n      if free:\n        curr = heapq.heappop(free)\n        ans.append(curr[1])\n        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))\n      else:\n        curr = heapq.heappop(used)\n        ans.append(curr[2])\n        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))\n\n    return ans",
      "title": "1882. Process Tasks Using Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5057d99-c8bd-493f-b08d-52c6391091e7",
      "code": "class Solution:\n  def minSkips(self, dist: list[int], speed: int, hoursBefore: int) -> int:\n    INF = 10**7\n    EPS = 1e-9\n    n = len(dist)\n    # dp[i][j] := the minimum time, where i is the number of roads we traversed\n    # so far and j is the number of skips we did\n    dp = [[INF] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i, d in enumerate(dist, 1):\n      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - EPS)\n      for j in range(1, i + 1):\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       math.ceil(dp[i - 1][j] + d / speed - EPS))\n\n    for j, time in enumerate(dp[-1]):\n      if time <= hoursBefore:\n        return j\n\n    return -1",
      "title": "1883. Minimum Skips to Arrive at Meeting On Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59c0fd53-f807-4934-b2e7-af7abe4756f4",
      "code": "class Solution:\n  def countPairs(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    arr = sorted([x - y for x, y in zip(nums1, nums2)])\n\n    for i, a in enumerate(arr):\n      index = bisect_left(arr, -a + 1)\n      ans += len(arr) - max(i + 1, index)\n\n    return ans",
      "title": "1885. Count Pairs in Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04afc4c3-0cfd-41ee-933b-03d6576ca3a2",
      "code": "class Solution:\n  def findRotation(self, mat: list[list[int]], target: list[list[int]]) -> bool:\n    for _ in range(4):\n      if mat == target:\n        return True\n      mat = [list(x) for x in zip(*mat[::-1])]\n    return False",
      "title": "1886. Determine Whether Matrix Can Be Obtained By Rotation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a0098d5-7897-4bbd-b004-828adbf9224e",
      "code": "class Solution:\n  def reductionOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 1, 0, -1):\n      if nums[i] != nums[i - 1]:\n        ans += len(nums) - i\n\n    return ans",
      "title": "1887. Reduction Operations to Make the Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b232c0e-508c-4bc4-80f8-01483f55b38c",
      "code": "class Solution:\n  def minFlips(self, s: str) -> int:\n    n = len(s)\n    # count[0][0] :=  the number of '0' in the even indices\n    # count[0][1] :=  the number of '0' in the odd indices\n    # count[1][0] :=  the number of '1' in the even indices\n    # count[1][1] :=  the number of '1' in the odd indices\n    count = [[0] * 2 for _ in range(2)]\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] += 1\n\n    # min(make all 0s in the even indices + make all 1s in the odd indices,\n    #     make all 1s in the even indices + make all 0s in the odd indices)\n    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] -= 1\n      count[int(c)][(n + i) % 2] += 1\n      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    return ans",
      "title": "1888. Minimum Number of Flips to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed3e3290-7794-468f-baff-b9564800234e",
      "code": "class Solution:\n  def minWastedSpace(self, packages: list[int], boxes: list[list[int]]) -> int:\n    ans = math.inf\n\n    packages.sort()\n\n    for box in boxes:\n      box.sort()\n      if box[-1] < packages[-1]:\n        continue\n      accu = 0\n      i = 0\n      for b in box:\n        j = bisect.bisect(packages, b, i)\n        accu += b * (j - i)\n        i = j\n      ans = min(ans, accu)\n\n    return -1 if ans == math.inf else (ans - sum(packages)) % 1_000_000_007",
      "title": "1889. Minimum Space Wasted From Packaging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13f97a0d-e2ad-4b73-971b-7a693581ffa8",
      "code": "class Solution:\n  def maxLength(self, ribbons: list[int], k: int) -> int:\n    def isCutPossible(length: int) -> bool:\n      count = 0\n      for ribbon in ribbons:\n        count += ribbon // length\n      return count >= k\n\n    l = 1\n    r = sum(ribbons) // k + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if not isCutPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l - 1",
      "title": "1891. Cutting Ribbons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "419aa9bf-1bb9-4f4c-8ec4-1d32399ce18e",
      "code": "class Solution:\n  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:\n    seen = [0] * 52\n\n    for l, r in ranges:\n      seen[l] += 1\n      seen[r + 1] -= 1\n\n    for i in range(1, 52):\n      seen[i] += seen[i - 1]\n\n    return all(seen[i] for i in range(left, right + 1))",
      "title": "1893. Check if All the Integers in a Range Are Covered",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1969ac03-a86f-48bf-a536-e78da9996c74",
      "code": "class Solution:\n  def chalkReplacer(self, chalk: list[int], k: int) -> int:\n    k %= sum(chalk)\n    if k == 0:\n      return 0\n\n    for i, c in enumerate(chalk):\n      k -= c\n      if k < 0:\n        return i",
      "title": "1894. Find the Student that Will Replace the Chalk",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40d20a40-06d6-4408-95bf-e69670cfe494",
      "code": "class Solution:\n  def largestMagicSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # prefixRow[i][j] := the sum of the first j numbers in the i-th row\n    prefixRow = [[0] * (n + 1) for _ in range(m)]\n    # prefixCol[i][j] := the sum of the first j numbers in the i-th column\n    prefixCol = [[0] * (m + 1) for _ in range(n)]\n\n    for i in range(m):\n      for j in range(n):\n        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j]\n        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j]\n\n    def isMagicSquare(i: int, j: int, k: int) -> bool:\n      \"\"\"Returns True if grid[i..i + k)[j..j + k) is a magic square.\"\"\"\n      diag, antiDiag = 0, 0\n      for d in range(k):\n        diag += grid[i + d][j + d]\n        antiDiag += grid[i + d][j + k - 1 - d]\n      if diag != antiDiag:\n        return False\n      for d in range(k):\n        if self._getSum(prefixRow, i + d, j, j + k - 1) != diag:\n          return False\n        if self._getSum(prefixCol, j + d, i, i + k - 1) != diag:\n          return False\n      return True\n\n    def containsMagicSquare(k: int) -> bool:\n      \"\"\"Returns True if the grid contains any magic square of size k x k.\"\"\"\n      for i in range(m - k + 1):\n        for j in range(n - k + 1):\n          if isMagicSquare(i, j, k):\n            return True\n      return False\n\n    for k in range(min(m, n), 1, -1):\n      if containsMagicSquare(k):\n        return k\n\n    return 1\n\n  def _getSum(self, prefix: list[list[int]], i: int, l: int, r: int) -> int:\n    \"\"\"Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).\"\"\"\n    return prefix[i][r + 1] - prefix[i][l]",
      "title": "1895. Largest Magic Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ebeac1a-b26c-4514-b692-92d8d67a3c95",
      "code": "class Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []  # [(the expression, the cost to toggle the expression)]\n\n    for e in expression:\n      if e in '(&|':\n        # These aren't expressions, so the cost is meaningless.\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()  # Pop '('.\n      else:  # e == '0' or e == '1'\n        # Store the '0' or '1'. The cost to change their values is just 1,\n        # whether it's changing '0' to '1' or '1' to '0'.\n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        # Determine the cost to toggle op(a, b).\n        if op == '&':\n          if a == '0' and b == '0':\n            # Change '&' to '|' and a|b to '1'.\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          else:  # a == '1' and b == '1'\n            # Change a|b to '0'.\n            lastPair = ('1', min(costA, costB))\n        else:  # op == '|'\n          if a == '0' and b == '0':\n            # Change a|b to '1'.\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          else:  # a == '1' and b == '1'\n            # Change '|' to '&' and a|b to '0'.\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]",
      "title": "1896. Minimum Cost to Change the Final Value of Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9da9cf53-82ef-418a-a006-2a55219e34dd",
      "code": "class Solution:\n  def makeEqual(self, words: list[str]) -> bool:\n    return all(c % len(words) == 0\n               for c in collections.Counter(''.join(words)).values())",
      "title": "1897. Redistribute Characters to Make All Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3a58ea8-f09b-4a10-9460-80ff78abfe97",
      "code": "class Solution:\n  def maximumRemovals(self, s: str, p: str, removable: list[int]) -> int:\n    l = 0\n    r = len(removable) + 1\n\n    def remove(k: int) -> str:\n      removed = [c for c in s]\n      for i in range(k):\n        removed[removable[i]] = '*'\n      return ''.join(removed)\n\n    def isSubsequence(p: str, s: str) -> bool:\n      i = 0\n      for j, c in enumerate(s):\n        if p[i] == s[j]:\n          i += 1\n          if i == len(p):\n            return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      removed = remove(m)\n      if isSubsequence(p, removed):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "1898. Maximum Number of Removable Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d740ce52-5a10-41be-a8c7-0b6281f6e741",
      "code": "class Solution:\n  def mergeTriplets(self, triplets: list[list[int]], target: list[int]) -> bool:\n    merged = [0] * len(target)\n\n    for triplet in triplets:\n      if all(a <= b for a, b in zip(triplet, target)):\n        for i in range(3):\n          merged[i] = max(merged[i], triplet[i])\n\n    return merged == target",
      "title": "1899. Merge Triplets to Form Target Triplet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5397f5a1-9b24-4595-bdfe-e61b7220ead2",
      "code": "class Solution:\n  def earliestAndLatest(self, n: int,\n                        firstPlayer: int, secondPlayer: int) -> list[int]:\n    @functools.lru_cache(None)\n    def dp(l: int, r: int, k: int) -> list[int]:\n      \"\"\"\n      Returns the (earliest, latest) pair, the first player is the l-th player\n      from the front, the second player is the r-th player from the end, and\n      there're k people.\n      \"\"\"\n      if l == r:\n        return [1, 1]\n      if l > r:\n        return dp(r, l, k)\n\n      a = math.inf\n      b = -math.inf\n\n      # Enumerate all the possible positions.\n      for i in range(1, l + 1):\n        for j in range(l - i + 1, r - i + 1):\n          if not l + r - k // 2 <= i + j <= (k + 1) // 2:\n            continue\n          x, y = dp(i, j, (k + 1) // 2)\n          a = min(a, x + 1)\n          b = max(b, y + 1)\n\n      return [a, b]\n\n    return dp(firstPlayer, n - secondPlayer + 1, n)",
      "title": "1900. The Earliest and Latest Rounds Where Players Compete",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c479f3c4-b394-4a84-9e34-7d2e45113899",
      "code": "class Solution:\n  def findPeakGrid(self, mat: list[list[int]]) -> list[int]:\n    l = 0\n    r = len(mat) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if max(mat[m]) >= max(mat[m + 1]):\n        r = m\n      else:\n        l = m + 1\n\n    return [l, mat[l].index(max(mat[l]))]",
      "title": "1901. Find a Peak Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69cb0c9e-12ca-4bf5-a64b-eb17ad37beba",
      "code": "class Solution:\n  def largestOddNumber(self, num: str) -> str:\n    for i, n in reversed(list(enumerate(num))):\n      if int(n) % 2 == 1:\n        return num[:i + 1]\n    return ''",
      "title": "1903. Largest Odd Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19ddb230-07aa-4559-9de1-ec6f4562e9ab",
      "code": "class Solution:\n  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n    start = self._getMinutes(loginTime)\n    finish = self._getMinutes(logoutTime)\n    if start > finish:\n      finish += 60 * 24\n\n    return max(0, finish // 15 - (start + 14) // 15)\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1904. The Number of Full Rounds You Have Played",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "666d407a-0f44-4f5a-93b4-513c42ef928c",
      "code": "class Solution:\n  def countSubIslands(\n      self,\n      grid1: list[list[int]],\n      grid2: list[list[int]],\n  ) -> int:\n    m = len(grid2)\n    n = len(grid2[0])\n\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 1\n      if grid2[i][j] != 1:\n        return 1\n\n      grid2[i][j] = 2  # Mark 2 as visited.\n\n      return (dfs(i + 1, j) & dfs(i - 1, j) &\n              dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j])\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid2[i][j] == 1:\n          ans += dfs(i, j)\n\n    return ans",
      "title": "1905. Count Sub Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5de528b7-cb90-46d8-bf90-87eb72725785",
      "code": "class Solution:\n  def minDifference(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans",
      "title": "1906. Minimum Absolute Difference Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26abedfa-d0ad-489b-9b1a-d09820c51909",
      "code": "class Solution:\n  def nimGame(self, piles: list[int]) -> bool:\n    return functools.reduce(operator.xor, piles) > 0",
      "title": "1908. Game of Nim",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ca96b88-f08c-4c91-975c-51b90f5e864a",
      "code": "class Solution:\n  def canBeIncreasing(self, nums: list[int]) -> bool:\n    removed = False\n\n    for i in range(1, len(nums)):\n      if nums[i - 1] >= nums[i]:\n        if removed:\n          return False\n        removed = True  # Remove nums[i - 1].\n        if i > 1 and nums[i - 2] >= nums[i]:\n          nums[i] = nums[i - 1]  # Remove nums[i] instead.\n\n    return True",
      "title": "1909. Remove One Element to Make the Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "875faa20-c637-4dff-bd4e-c6b42a942438",
      "code": "class Solution:\n  def removeOccurrences(self, s: str, part: str) -> str:\n    n = len(s)\n    k = len(part)\n\n    t = [' '] * n\n    j = 0  # t's index\n\n    for i, c in enumerate(s):\n      t[j] = c\n      j += 1\n      if j >= k and ''.join(t[j - k:j]) == part:\n        j -= k\n\n    return ''.join(t[:j])",
      "title": "1910. Remove All Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08f21b05-247f-44b5-8d14-f1bc6b96a638",
      "code": "class Solution:\n  def maxAlternatingSum(self, nums: list[int]) -> int:\n    even = 0  # the maximum alternating sum ending in an even index\n    odd = 0  # the maximum alternating sum ending in an odd index\n\n    for num in nums:\n      even = max(even, odd + num)\n      odd = even - num\n\n    return even",
      "title": "1911. Maximum Alternating Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f4a590-7fd8-40a1-926e-9a7f0ffcefb9",
      "code": "class Solution:\n  def maxProductDifference(self, nums: list[int]) -> int:\n    max1 = -math.inf\n    max2 = -math.inf\n    min1 = math.inf\n    min2 = math.inf\n\n    for num in nums:\n      if num > max1:\n        max2 = max1\n        max1 = num\n      elif num > max2:\n        max2 = num\n      if num < min1:\n        min2 = min1\n        min1 = num\n      elif num < min2:\n        min2 = num\n\n    return max1 * max2 - min1 * min2",
      "title": "1913. Maximum Product Difference Between Two Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd81fe3e-7389-4eee-91d9-db3079ca46c2",
      "code": "class Solution:\n  def rotateGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    t = 0  # the top\n    l = 0  # the left\n    b = m - 1  # the bottom\n    r = n - 1  # the right\n\n    while t < b and l < r:\n      elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4\n      netRotations = k % elementInThisLayer\n      for _ in range(netRotations):\n        topLeft = grid[t][l]\n        for j in range(l, r):\n          grid[t][j] = grid[t][j + 1]\n        for i in range(t, b):\n          grid[i][r] = grid[i + 1][r]\n        for j in range(r, l, - 1):\n          grid[b][j] = grid[b][j - 1]\n        for i in range(b, t, -1):\n          grid[i][l] = grid[i - 1][l]\n        grid[t + 1][l] = topLeft\n      t += 1\n      l += 1\n      b -= 1\n      r -= 1\n\n    return grid",
      "title": "1914. Cyclically Rotating a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c19298dc-291c-49cb-81f2-0fe07669d06a",
      "code": "class Solution:\n  def wonderfulSubstrings(self, word: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    count = [0] * 1024  # the binary prefix count\n    count[0] = 1  # the empty string \"\"\n\n    for c in word:\n      prefix ^= 1 << ord(c) - ord('a')\n      # All the letters occur even number of times.\n      ans += count[prefix]\n      # `c` occurs odd number of times.\n      ans += sum(count[prefix ^ 1 << i] for i in range(10))\n      count[prefix] += 1\n\n    return ans",
      "title": "1915. Number of Wonderful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0a06b12-af41-4014-ac02-6dfd7dd805a1",
      "code": "class Solution:\n  def waysToBuildRooms(self, prevRoom: list[int]) -> int:\n    MOD = 1_000_000_007\n    graph = collections.defaultdict(list)\n\n    for i, prev in enumerate(prevRoom):\n      graph[prev].append(i)\n\n    def dfs(node: int) -> tuple[int, int]:\n      if not graph[node]:\n        return 1, 1\n\n      ans = 1\n      l = 0\n\n      for child in graph[node]:\n        temp, r = dfs(child)\n        ans = (ans * temp * math.comb(l + r, r)) % MOD\n        l += r\n\n      return ans, l + 1\n\n    return dfs(0)[0]",
      "title": "1916. Count Ways to Build Rooms in an Ant Colony",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c71a622-ae92-4754-b17b-21e742b69888",
      "code": "class Solution:\n  def kthSmallestSubarraySum(self, nums: list[int], k: int) -> int:\n    def numSubarrayLessThan(m: int) -> int:\n      res = 0\n      summ = 0\n      l = 0\n      for r, num in enumerate(nums):\n        summ += num\n        while summ > m:\n          summ -= nums[l]\n          l += 1\n        res += r - l + 1\n      return res\n\n    return bisect.bisect_left(range(sum(nums)), k, key=numSubarrayLessThan)",
      "title": "1918. Kth Smallest Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c4060c1-1996-4147-9772-01b809c82749",
      "code": "class Solution:\n  def buildArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n      nums[i] += n * (nums[num] % n)\n\n    for i in range(n):\n      nums[i] //= n\n\n    return nums",
      "title": "1920. Build Array from Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c848f2fa-c34d-4ccd-b64e-74ffa72cd862",
      "code": "class Solution:\n  def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\n    for i, arrivalTime in enumerate(\n            sorted([(d - 1) // s for d, s in zip(dist, speed)])):\n      if i > arrivalTime:\n        return i\n    return len(dist)",
      "title": "1921. Eliminate Maximum Number of Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cddfa7a1-b960-4693-9087-bf87e241f1db",
      "code": "class Solution:\n  def countGoodNumbers(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % MOD",
      "title": "1922. Count Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d8d451-2dda-4142-a8e4-51ad379e8206",
      "code": "class Solution:\n  def __init__(self):\n    self.BASE = 165_131\n    self.HASH = 8_417_508_174_513\n\n  def longestCommonSubpath(self, n: int, paths: list[list[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: list[list[int]], m: int) -> bool:\n    \"\"\"\n    Returns True if there's a common subpath of length m for all the paths.\n    \"\"\"\n    # Calculate the hash values for subpaths of length m for every path.\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    # Check if there is a common subpath of length m.\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: list[int], m: int) -> set[int]:\n    \"\"\"Returns the hash values for subpaths of length m in the path.\"\"\"\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.BASE + num) % self.HASH\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower %\n                self.HASH + self.HASH) % self.HASH\n      else:\n        maxPower = maxPower * self.BASE % self.HASH\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes",
      "title": "1923. Longest Common Subpath",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d02b745d-f4f5-4b5f-a6fb-df9f4a06113f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Point:\n  x: float\n  y: float\n\n\n@dataclass(frozen=True)\nclass Disk:\n  center: Point\n  radius: float\n\n\nclass Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[float]:\n    points = [Point(x, y) for x, y in trees]\n    disk = self._welzl(points, 0, [])\n    return [disk.center.x, disk.center.y, disk.radius]\n\n  def _welzl(\n      self,\n      points: list[Point],\n      i: int,\n      planePoints: list[Point],\n  ) -> Disk:\n    \"\"\"Returns the smallest disk that encloses points[i..n).\n\n    https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm\n    \"\"\"\n    if i == len(points) or len(planePoints) == 3:\n      return self._trivial(planePoints)\n    disk = self._welzl(points, i + 1, planePoints)\n    if self._inside(disk, points[i]):\n      return disk\n    return self._welzl(points, i + 1, planePoints + [points[i]])\n\n  def _trivial(self, planePoints: list[Point]) -> Disk:\n    \"\"\"Returns the smallest disk that encloses `planePoints`.\"\"\"\n    if len(planePoints) == 0:\n      return Disk(Point(0, 0), 0)\n    if len(planePoints) == 1:\n      return Disk(Point(planePoints[0].x, planePoints[0].y), 0)\n    if len(planePoints) == 2:\n      return self._getDisk(planePoints[0], planePoints[1])\n\n    disk01 = self._getDisk(planePoints[0], planePoints[1])\n    if self._inside(disk01, planePoints[2]):\n      return disk01\n\n    disk02 = self._getDisk(planePoints[0], planePoints[2])\n    if self._inside(disk02, planePoints[1]):\n      return disk02\n\n    disk12 = self._getDisk(planePoints[1], planePoints[2])\n    if self._inside(disk12, planePoints[0]):\n      return disk12\n\n    return self._getDiskFromThree(\n        planePoints[0],\n        planePoints[1],\n        planePoints[2])\n\n  def _getDisk(self, A: Point, B: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A and B.\"\"\"\n    x = (A.x + B.x) / 2\n    y = (A.y + B.y) / 2\n    return Disk(Point(x, y), self._distance(A, B) / 2)\n\n  def _getDiskFromThree(self, A: Point, B: Point, C: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A, B, and C.\"\"\"\n    # Calculate midpoints.\n    mAB = Point((A.x + B.x) / 2, (A.y + B.y) / 2)\n    mBC = Point((B.x + C.x) / 2, (B.y + C.y) / 2)\n\n    # Calculate the slopes and the perpendicular slopes.\n    slopeAB = math.inf if B.x == A.x else (B.y - A.y) / (B.x - A.x)\n    slopeBC = math.inf if C.x == B.x else (C.y - B.y) / (C.x - B.x)\n    perpSlopeAB = math.inf if slopeAB == 0 else -1 / slopeAB\n    perpSlopeBC = math.inf if slopeBC == 0 else -1 / slopeBC\n\n    # Calculate the center.\n    x = (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x +\n         mAB.y - mBC.y) / (perpSlopeBC - perpSlopeAB)\n    y = perpSlopeAB * (x - mAB.x) + mAB.y\n    center = Point(x, y)\n    return Disk(center, self._distance(center, A))\n\n  def _inside(self, disk: Disk, point: Point) -> bool:\n    \"\"\"Returns True if the point is inside the disk.\"\"\"\n    return disk.radius > 0 and self._distance(disk.center, point) <= disk.radius\n\n  def _distance(self, A: Point, B: Point) -> float:\n    dx = A.x - B.x\n    dy = A.y - B.y\n    return math.sqrt(dx**2 + dy**2)",
      "title": "1924. Erect the Fence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a67d51c-24d7-45e4-a60b-de1c5ec60134",
      "code": "class Solution:\n  def countTriples(self, n: int) -> int:\n    ans = 0\n    squared = set()\n\n    for i in range(1, n + 1):\n      squared.add(i * i)\n\n    for a in squared:\n      for b in squared:\n        if a + b in squared:\n          ans += 1\n\n    return ans",
      "title": "1925. Count Square Sum Triples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57042380-8411-4c1c-9154-f1adff9532a3",
      "code": "class Solution:\n  def nearestExit(self, maze: list[list[str]], entrance: list[int]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return step\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1",
      "title": "1926. Nearest Exit from Entrance in Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afdd4917-3ae0-4dc4-8363-bd9bcf59c788",
      "code": "class Solution:\n  def sumGame(self, num: str) -> bool:\n    n = len(num)\n    ans = 0.0\n\n    def getExpectation(c: str) -> float:\n      return 4.5 if c == '?' else int(c)\n\n    for i in range(n // 2):\n      ans += getExpectation(num[i])\n\n    for i in range(n // 2, n):\n      ans -= getExpectation(num[i])\n\n    return ans != 0.0",
      "title": "1927. Sum Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d596dd6-0d6c-4b86-a469-d7283e0cb0c6",
      "code": "class Solution:\n  def minCost(\n      self,\n      maxTime: int,\n      edges: list[list[int]],\n      passingFees: list[int],\n  ) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      maxTime: int,\n      passingFees: list[int],\n  ) -> int:\n    # cost[i] := the minimum cost to reach the i-th city\n    cost = [math.inf] * len(graph)\n    # dist[i] := the minimum time to reach the i-th city\n    dist = [maxTime + 1] * len(graph)\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]  # (cost[u], dist[u], u)\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        # Go from u -> v.\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1",
      "title": "1928. Minimum Cost to Reach Destination in Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "028ede6f-c294-41af-9b10-67ce41c23446",
      "code": "class Solution:\n  def getConcatenation(self, nums: list[int]) -> list[int]:\n    return nums * 2",
      "title": "1929. Concatenation of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2297b24f-cfa5-4741-b140-ee7d2ceb31d9",
      "code": "class Solution:\n  def countPalindromicSubsequence(self, s: str) -> int:\n    ans = 0\n    first = [len(s)] * 26\n    last = [-1] * 26\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      first[index] = min(first[index], i)\n      last[index] = i\n\n    for f, l in zip(first, last):\n      if f < l:\n        ans += len(set(s[f + 1:l]))\n\n    return ans",
      "title": "1930. Unique Length-3 Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09c74f7-29e8-45dc-aea3-e52565355f47",
      "code": "class Solution:\n  def colorTheGrid(self, m: int, n: int) -> int:\n    def getColor(mask: int, r: int) -> int:\n      return mask >> r * 2 & 3\n\n    def setColor(mask: int, r: int, color: int) -> int:\n      return mask | color << r * 2\n\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(r: int, c: int, prevColMask: int, currColMask: int) -> int:\n      if c == n:\n        return 1\n      if r == m:\n        return dp(0, c + 1, currColMask, 0)\n\n      ans = 0\n\n      # 1 := red, 2 := green, 3 := blue\n      for color in range(1, 4):\n        if getColor(prevColMask, r) == color:\n          continue\n        if r > 0 and getColor(currColMask, r - 1) == color:\n          continue\n        ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color))\n        ans %= MOD\n\n      return ans\n\n    return dp(0, 0, 0, 0)",
      "title": "1931. Painting a Grid With Three Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "100015a7-3376-4b31-b669-091cbf4325b3",
      "code": "class Solution:\n  def canMerge(self, trees: list[TreeNode]) -> TreeNode | None:\n    valToNode = {}  # {val: node}\n    count = collections.Counter()  # {val: freq}\n\n    for tree in trees:\n      valToNode[tree.val] = tree\n      count[tree.val] += 1\n      if tree.left:\n        count[tree.left.val] += 1\n      if tree.right:\n        count[tree.right.val] += 1\n\n    def isValidBST(tree: TreeNode | None, minNode: TreeNode | None,\n                   maxNode: TreeNode | None) -> bool:\n      if not tree:\n        return True\n      if minNode and tree.val <= minNode.val:\n        return False\n      if maxNode and tree.val >= maxNode.val:\n        return False\n      if not tree.left and not tree.right and tree.val in valToNode:\n        val = tree.val\n        tree.left = valToNode[val].left\n        tree.right = valToNode[val].right\n        del valToNode[val]\n\n      return isValidBST(\n          tree.left, minNode, tree) and isValidBST(\n          tree.right, tree, maxNode)\n\n    for tree in trees:\n      if count[tree.val] == 1:\n        if isValidBST(tree, None, None) and len(valToNode) <= 1:\n          return tree\n        return None\n\n    return None",
      "title": "1932. Merge BSTs to Create Single BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c65f7a6b-466d-42fe-9f37-4b9b341d3665",
      "code": "class Solution:\n  def isDecomposable(self, s: str) -> bool:\n    twos = 0\n\n    for _, group in itertools.groupby(s):\n      groupLength = len(list(group))\n      if groupLength % 3 == 1:\n        return False\n      if groupLength % 3 == 2:\n        twos += 1\n        if twos > 1:\n          return False\n\n    return twos == 1",
      "title": "1933. Check if String Is Decomposable Into Value-Equal Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "898646da-0ba3-4c47-8a62-59d8a3dfcd21",
      "code": "class Solution:\n  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n    ans = 0\n    broken = set(brokenLetters)\n\n    for word in text.split():\n      ans += all(c not in broken for c in word)\n\n    return ans",
      "title": "1935. Maximum Number of Words You Can Type",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb3facdf-2d76-46ac-99f6-74be30459f6b",
      "code": "class Solution:\n  def addRungs(self, rungs: list[int], dist: int) -> int:\n    ans = 0\n    prev = 0\n\n    for rung in rungs:\n      ans += (rung - prev - 1) // dist\n      prev = rung\n\n    return ans",
      "title": "1936. Add Minimum Number of Rungs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98294c2a-28bd-462c-85ac-660d9cd7a10a",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    n = len(points[0])\n    # dp[j] := the maximum number of points you can have if points[i][j] is the\n    # most recent cell you picked\n    dp = [0] * n\n\n    for row in points:\n      leftToRight = [0] * n\n      runningMax = 0\n      for j in range(n):\n        runningMax = max(runningMax - 1, dp[j])\n        leftToRight[j] = runningMax\n\n      rightToLeft = [0] * n\n      runningMax = 0\n      for j in range(n - 1, - 1, -1):\n        runningMax = max(runningMax - 1, dp[j])\n        rightToLeft[j] = runningMax\n\n      for j in range(n):\n        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]\n\n    return max(dp)",
      "title": "1937. Maximum Number of Points with Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f17a7ce1-4445-4cf5-a7ab-147881dd17fd",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.HEIGHT = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(\n      self,\n      parents: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)  # {node: (index, val)}\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      # Answer queries for node\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans",
      "title": "1938. Maximum Genetic Difference Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "090c2dc0-1b5d-49db-b7b7-76493d4928a6",
      "code": "class Solution:\n  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:\n    MAX = 100\n    ans = []\n    count = [0] * (MAX + 1)\n\n    for array in arrays:\n      for a in array:\n        count[a] += 1\n        if count[a] == len(arrays):\n          ans.append(a)\n\n    return ans",
      "title": "1940. Longest Common Subsequence Between Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dbe82c5-40a4-401e-9ab4-43fbe18cf779",
      "code": "class Solution:\n  def areOccurrencesEqual(self, s: str) -> bool:\n    return len(set(collections.Counter(s).values())) == 1",
      "title": "1941. Check if All Characters Have Equal Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da94d66c-2203-4316-8312-8f1c10f358aa",
      "code": "class Solution:\n  def smallestChair(self, times: list[list[int]], targetFriend: int) -> int:\n    nextUnsatChair = 0\n    emptyChairs = []\n    occupied = []  # (leaving, chair)\n\n    for i in range(len(times)):\n      times[i].append(i)\n\n    times.sort(key=lambda x: x[0])\n\n    for arrival, leaving, i in times:\n      while len(occupied) > 0 and occupied[0][0] <= arrival:\n        unsatChair = heapq.heappop(occupied)[1]\n        heapq.heappush(emptyChairs, unsatChair)\n      if i == targetFriend:\n        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair\n      if len(emptyChairs) == 0:\n        heapq.heappush(occupied, (leaving, nextUnsatChair))\n        nextUnsatChair += 1\n      else:\n        emptyChair = heapq.heappop(emptyChairs)\n        heapq.heappush(occupied, (leaving, emptyChair))",
      "title": "1942. The Number of the Smallest Unoccupied Chair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ad61020-2328-4ac2-bcec-37f2221dbd3a",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def splitPainting(self, segments: list[list[int]]) -> list[list[int]]:\n    ans = []\n    prevIndex = 0\n    runningMix = 0\n    line = SortedDict()\n\n    for start, end, color in segments:\n      line[start] = line.get(start, 0) + color\n      line[end] = line.get(end, 0) - color\n\n    for i, mix in line.items():\n      if runningMix > 0:\n        ans.append([prevIndex, i, runningMix])\n      runningMix += mix\n      prevIndex = i\n\n    return ans",
      "title": "1943. Describe the Painting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851245c6-6a7a-4f32-8408-20b679b06310",
      "code": "class Solution:\n  def canSeePersonsCount(self, heights: list[int]) -> list[int]:\n    ans = [0] * len(heights)\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        ans[stack.pop()] += 1\n      if stack:\n        ans[stack[-1]] += 1\n      stack.append(i)\n\n    return ans",
      "title": "1944. Number of Visible People in a Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf9db048-c079-4ab4-98cc-2a43245fa3e5",
      "code": "class Solution:\n  def getLucky(self, s: str, k: int) -> int:\n    ans = self._convert(s)\n    for _ in range(k):\n      ans = self._getDigitSum(ans)\n    return ans\n\n  def _convert(self, s: str) -> int:\n    return int(''.join(str(ord(c) - ord('a') + 1) for c in s))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1945. Sum of Digits of String After Convert",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b023598-9ffc-45d5-95a8-e13d110b3fb1",
      "code": "class Solution:\n  def maximumNumber(self, num: str, change: list[int]) -> str:\n    numList = list(num)\n    mutated = False\n\n    for i, c in enumerate(numList):\n      d = int(c)\n      numlist[i] = chr(ord('0') + max(d, change[d]))\n      if mutated and d > change[d]:\n        return ''.join(numList)\n      if d < change[d]:\n        mutated = True\n\n    return ''.join(numList)",
      "title": "1946. Largest Number After Mutating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53640642-8b51-432e-aa27-2c68feaa5575",
      "code": "class Solution:\n  def maxCompatibilitySum(\n      self,\n      students: list[list[int]],\n      mentors: list[list[int]],\n  ) -> int:\n    ans = 0\n\n    def dfs(i: int, scoreSum: int, used: list[bool]) -> None:\n      nonlocal ans\n      if i == len(students):\n        ans = max(ans, scoreSum)\n        return\n\n      for j, mentor in enumerate(mentors):\n        if used[j]:\n          continue\n        used[j] = True  # The `mentors[j]` is used.\n        dfs(i + 1, scoreSum + sum(s == m\n                                  for s, m in zip(students[i], mentor)), used)\n        used[j] = False\n\n    dfs(0, 0, [False] * len(students))\n    return ans",
      "title": "1947. Maximum Compatibility Score Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "811c7f5d-5ea5-4f98-93b9-a8ccede59f13",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.deleted = False\n\n\nclass Solution:\n  def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n    subtreeToNodes: dict[str, list[TrieNode]] = collections.defaultdict(list)\n\n    # Construct the Trie\n    for path in sorted(paths):\n      node = root\n      for s in path:\n        node = node.children.setdefault(s, TrieNode())\n\n    # For each subtree, fill in the {subtree encoding: [root]} hash table\n    def buildSubtreeToRoots(node: TrieNode) -> str:\n      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])\n                              for s in node.children) + ')'\n      if subtree != '()':\n        subtreeToNodes[subtree].append(node)\n      return subtree\n\n    buildSubtreeToRoots(root)\n\n    # Mark nodes that should be deleted\n    for nodes in subtreeToNodes.values():\n      if len(nodes) > 1:\n        for node in nodes:\n          node.deleted = True\n\n    # Construct the answer array for nodes that haven't been deleted\n    def constructPath(node: TrieNode, path: list[str]) -> None:\n      for s, child in node.children.items():\n        if not child.deleted:\n          constructPath(child, path + [s])\n      if path:\n        ans.append(path)\n\n    constructPath(root, [])\n    return ans",
      "title": "1948. Delete Duplicate Folders in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5e74dd0-84ba-4178-a59c-d6ad98af4f68",
      "code": "class Solution:\n  # Similar to 1950. Maximum of Minimum Values in All Subarrays\n  def findMaximums(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    # prevMin[i] := the index k s.t.\n    # nums[k] is the previous minimum in nums[0..n)\n    prevMin = [-1] * n\n    # nextMin[i] := the index k s.t.\n    # nums[k] is the next minimum innums[i + 1..n)\n    nextMin = [n] * n\n    stack = []\n\n    for i, num in enumerate(nums):\n      while stack and nums[stack[-1]] > nums[i]:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    # For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.\n    # nums[i] is the minimum in nums[l..r].\n    # So, the ans[r - l + 1] will be at least nums[i].\n    for num, l, r in zip(nums, prevMin, nextMin):\n      sz = r - l - 1\n      ans[sz - 1] = max(ans[sz - 1], num)\n\n    # ans[i] should always >= ans[i + 1..n).\n    for i in range(n - 2, -1, -1):\n      ans[i] = max(ans[i], ans[i + 1])\n\n    return ans",
      "title": "1950. Maximum of Minimum Values in All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64ab1246-fbf4-45a5-bec7-6480b8166d52",
      "code": "class Solution:\n  def isThree(self, n: int) -> bool:\n    if n == 1:\n      return False\n    # The numbers with exactly three divisors are perfect squares of a prime\n    # number.\n    root = math.isqrt(n)\n    return (root**2 == n and\n            all(root % i != 0\n                for i in range(2, math.isqrt(root) + 1)))",
      "title": "1952. Three Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bcc8ff2-710a-4895-9f64-eec69d8a43a2",
      "code": "class Solution:\n  def numberOfWeeks(self, milestones: list[int]) -> int:\n    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.\n    summ = sum(milestones)\n    nonMax = summ - max(milestones)\n    return min(summ, 2 * nonMax + 1)",
      "title": "1953. Maximum Number of Weeks for Which You Can Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5e04b03-a3b3-44c1-966a-c31c93a0948e",
      "code": "class Solution:\n  def minimumPerimeter(self, neededApples: int) -> int:\n    def numApples(k: int) -> int:\n      \"\"\"Returns the number of apples at the k-th level.\n\n         k := the level making perimeter = 8k\n      p(k) := the number of apples at the k-th level on the perimeter\n      n(k) := the number of apples at the k-th level not no the perimeter\n\n      p(1) =             1 + 2\n      p(2) =         3 + 2 + 3 + 4\n      p(3) =     5 + 4 + 3 + 4 + 5 + 6\n      p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8\n      p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k\n          = k + 2k^2 + 2*k(k-1)//2\n          = k + 2k^2 + k^2 - k = 3k^2\n\n      n(k) = p(1) + p(2) + p(3) + ... + p(k)\n          = 3*1  + 3*4  + 3*9  + ... + 3*k^2\n          = 3 * (1 + 4 + 9 + ... + k^2)\n          = 3 * k(k+1)(2k+1)//6 = k(k+1)(2k+1)//2\n      So, the number of apples at the k-th level should be\n        k(k+1)(2k+1)//2 * 4 = 2k(k+1)(2k+1)\n      \"\"\"\n      return 2 * k * (k + 1) * (2 * k + 1)\n\n    return bisect.bisect_left(range(100_000), neededApples,\n                              key=numApples) * 8",
      "title": "1954. Minimum Garden Perimeter to Collect Enough Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f6fa593-6f33-4bac-bde8-3605ce6137ba",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of increasing subsequences of the first i numbers\n    # that end in j\n    dp = [[0] * 3 for _ in range(n)]\n\n    if nums[0] == 0:\n      dp[0][0] = 1\n\n    for i in range(1, n):\n      for ending in range(3):\n        dp[i][ending] = dp[i - 1][ending]\n\n      if nums[i] == 0:\n        # 1. The number of the previous subsequences that end in 0.\n        # 2. Append a 0 to the previous subsequences that end in 0.\n        # 3. Start a new subsequence from this 0.\n        dp[i][0] = dp[i - 1][0] * 2 + 1\n      elif nums[i] == 1:\n        # 1. The number of the previous subsequences that end in 1.\n        # 2. Append a 1 to the previous subsequences that end in 1.\n        # 3. Append a 1 to the previous subsequences that end in 0.\n        dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0]\n      else:  # nums[i] == 2\n        # 1. The number of the previous subsequences that end in 2.\n        # 2. Append a 2 to the previous subsequences that end in 2.\n        # 3. Append a 2 to the previous subsequences that end in 1.\n        dp[i][2] = dp[i - 1][2] * 2 + dp[i - 1][1]\n\n      for ending in range(3):\n        dp[i][ending] %= MOD\n\n    return dp[-1][2]",
      "title": "1955. Count Number of Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67de1f15-cc84-49c2-93a4-72f82c6fca54",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of increasing subsequences of the first i numbers,\n      where the the previous number is j - 1.\n      \"\"\"\n      if i == len(nums):\n        return prev == 2\n\n      res = 0\n\n      # Don't include `nums[i]`.\n      res += dp(i + 1, prev)\n\n      # Include `nums[i]`.\n      if nums[i] == prev:\n        res += dp(i + 1, prev)\n      if prev == -1 and nums[i] == 0:\n        res += dp(i + 1, 0)\n      if prev == 0 and nums[i] == 1:\n        res += dp(i + 1, 1)\n      if prev == 1 and nums[i] == 2:\n        res += dp(i + 1, 2)\n\n      res %= MOD\n      return res\n\n    return dp(0, -1)",
      "title": "1955. Count Number of Special Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85164a13-c3eb-4d73-a2c8-2c8a1a6ad071",
      "code": "class Solution:\n  def minDayskVariants(self, points: list[list[int]], k: int) -> int:\n    MAX = 100\n    ans = math.inf\n\n    for a in range(1, MAX + 1):\n      for b in range(1, MAX + 1):\n        # Stores the k minimum distances of points that can reach (a, b).\n        maxHeap = []\n        for x, y in points:\n          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))\n          if len(maxHeap) > k:\n            heapq.heappop(maxHeap)\n        ans = min(ans, -maxHeap[0])\n\n    return ans",
      "title": "1956. Minimum Time For K Virus Variants to Spread",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eaf57b3-c442-4eb2-83ab-5a3dd4d97cf9",
      "code": "class Solution:\n  def makeFancyString(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "1957. Delete Characters to Make Fancy String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6d606f7-25ad-4d99-ba39-f0e4e396a276",
      "code": "class Solution:\n  def checkMove(\n      self,\n      board: list[list[str]],\n      rMove: int,\n      cMove: int,\n      color: str,\n  ) -> bool:\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    for dx, dy in DIRS:\n      cellsCount = 2\n      i = rMove + dx\n      j = cMove + dy\n      while 0 <= i < 8 and 0 <= j < 8:\n        # There are no free cells in between.\n        if board[i][j] == '.':\n          break\n        # Need >= 3 cells.\n        if cellsCount == 2 and board[i][j] == color:\n          break\n        # >= 3 cells.\n        if board[i][j] == color:\n          return True\n        i += dx\n        j += dy\n        cellsCount += 1\n\n    return False",
      "title": "1958. Check if Move is Legal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebdee498-5af3-41b7-b36f-3b9bbe8a633d",
      "code": "class Solution:\n  def minSpaceWastedKResizing(self, nums: list[int], k: int) -> int:\n    MAX = 200_000_000\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum space wasted for nums[i..n) if you can resize k times.\n      \"\"\"\n      if i == len(nums):\n        return 0\n      if k == -1:\n        return MAX\n\n      res = MAX\n      summ = 0\n      maxNum = nums[i]\n\n      for j in range(i, len(nums)):\n        summ += nums[j]\n        maxNum = max(maxNum, nums[j])\n        wasted = maxNum * (j - i + 1) - summ\n        res = min(res, dp(j + 1, k - 1) + wasted)\n\n      return res\n\n    return dp(0, k)",
      "title": "1959. Minimum Total Space Wasted With K Resizing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76b4aaf8-05ca-4517-a623-9af0d15ca390",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n    n = len(s)\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hashL[i] = the hash of the first i letters of s, where hashL[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hashL = [0]\n    # hashR[i] = the hash of the last i letters of s, where hashR[i] =\n    # (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % HASH\n    hashR = [0]\n    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    maxLeft = [0] * n\n    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    maxRight = [0] * n\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for _ in range(n):\n      pows.append(pows[-1] * BASE % HASH)\n\n    for c in s:\n      hashL.append((hashL[-1] * BASE + val(c)) % HASH)\n\n    for c in reversed(s):\n      hashR.append((hashR[-1] * BASE + val(c)) % HASH)\n\n    hashR.reverse()\n\n    def getLeftRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the left rolling hash of s[l..r).\"\"\"\n      h = (hashL[r] - hashL[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def getRightRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the right rolling hash of s[l..r).\"\"\"\n      h = (hashR[l] - hashR[r] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True if s[l..r) is a palindrome.\"\"\"\n      return getLeftRollingHash(l, r) == getRightRollingHash(l, r)\n\n    maxLength = 1\n    for r in range(n):\n      l = (r - maxLength - 2) + 1\n      if l >= 0 and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxLeft[r] = maxLength\n\n    maxLength = 1\n    for l in reversed(range(n)):\n      r = (l + maxLength + 2) - 1\n      if r < n and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxRight[l] = maxLength\n\n    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))",
      "title": "1960. Maximum Product of the Length of Two Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7675684-6f2d-4678-958c-70cbde423ff1",
      "code": "class Solution:\n  def isPrefixString(self, s: str, words: list[str]) -> bool:\n    prefix = []\n    for word in words:\n      prefix.append(word)\n      if ''.join(prefix) == s:\n        return True\n    return False",
      "title": "1961. Check If String Is a Prefix of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d1d32ee-5eab-4672-841a-8300a32d1b5d",
      "code": "class Solution:\n  def minStoneSum(self, piles: list[int], k: int) -> int:\n    maxHeap = [-pile for pile in piles]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      heapq.heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)",
      "title": "1962. Remove Stones to Minimize the Total",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fa9d26c-6ec3-4298-9346-fc722895ef6a",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.\n    # The answer is ceil(# of unmatched pairs // 2).\n    unmatched = 0\n\n    for c in s:\n      if c == '[':\n        unmatched += 1\n      elif unmatched > 0:  # c == ']' and there's a match.\n        unmatched -= 1\n\n    return (unmatched + 1) // 2",
      "title": "1963. Minimum Number of Swaps to Make the String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0032b744-9ee4-4520-a12f-5f40c424d3dc",
      "code": "class Solution:\n  # Similar to 300. Longest Increasing Subsequence\n  def longestObstacleCourseAtEachPosition(\n      self, obstacles: list[int],\n  ) -> list[int]:\n    ans = []\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for obstacle in obstacles:\n      if not tails or obstacle >= tails[-1]:\n        tails.append(obstacle)\n        ans.append(len(tails))\n      else:\n        index = bisect.bisect_right(tails, obstacle)\n        tails[index] = obstacle\n        ans.append(index + 1)\n\n    return ans",
      "title": "1964. Find the Longest Valid Obstacle Course at Each Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f38afedd-4fbc-4d78-b494-a00d3b7d6ad3",
      "code": "class Solution:\n  def binarySearchableNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixMaxs[i] := max(nums[0..i))\n    prefixMaxs = [0] * n\n    # suffixMins[i] := min(nums[i + 1..n))\n    suffixMins = [0] * n\n\n    # Fill in `prefixMaxs`.\n    prefixMaxs[0] = -math.inf\n    for i in range(1, n):\n      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])\n\n    # Fill in `suffixMins`.\n    suffixMins[n - 1] = math.inf\n    for i in range(n - 2, -1, -1):\n      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])\n\n    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))",
      "title": "1966. Binary Searchable Numbers in an Unsorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33e20e22-e005-4044-ada1-bde0e7df6839",
      "code": "class Solution:\n  def numOfStrings(self, patterns: list[str], word: str) -> int:\n    return sum(pattern in word for pattern in patterns)",
      "title": "1967. Number of Strings That Appear as Substrings in Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03323393-dbff-419f-9e8a-040f230fdc0e",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    for i in range(1, len(nums), 2):\n      nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums",
      "title": "1968. Array With Elements Not Equal to Average of Neighbors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "756dcacd-d3fb-4fe0-8df9-4b2f0e74257b",
      "code": "class Solution:\n  def minNonZeroProduct(self, p: int) -> int:\n    MOD = 1_000_000_007\n    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].\n    n = 1 << p\n    halfCount = n // 2 - 1\n    return pow(n - 2, halfCount, MOD) * ((n - 1) % MOD) % MOD",
      "title": "1969. Minimum Non-Zero Product of the Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d753ad33-b2b3-4c9c-81fa-b29ec1db909a",
      "code": "class Solution:\n  def latestDayToCross(self, row: int, col: int, cells: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def canWalk(day: int) -> bool:\n      matrix = [[0] * col for _ in range(row)]\n      for i in range(day):\n        x, y = cells[i]\n        matrix[x - 1][y - 1] = 1\n\n      q = collections.deque()\n\n      for j in range(col):\n        if matrix[0][j] == 0:\n          q.append((0, j))\n          matrix[0][j] = 1\n\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == row or y < 0 or y == col:\n            continue\n          if matrix[x][y] == 1:\n            continue\n          if x == row - 1:\n            return True\n          q.append((x, y))\n          matrix[x][y] = 1\n\n      return False\n\n    ans = 0\n    l = 1\n    r = len(cells) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if canWalk(m):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "1970. Last Day Where You Can Still Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2889c1e9-b459-4865-be2a-de4596b4b02b",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(\n      self,\n      n: int,\n      edges: list[list[int]],\n      source: int,\n      destination: int,\n  ) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)",
      "title": "1971. Find if Path Exists in Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc15f7a7-545f-4631-adef-baf865910f6c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n\n\nclass Solution:\n  def equalToDescendants(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      return T(root.val + left.summ + right.summ,\n               left.count + right.count +\n               (1 if root.val == left.summ + right.summ else 0))\n\n    return dfs(root).count",
      "title": "1973. Count Nodes Equal to Sum of Descendants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56d09a21-3752-48db-b62a-af039e6e3d27",
      "code": "class Solution:\n  def minTimeToType(self, word: str) -> int:\n    moves = 0\n    letter = 'a'\n\n    for c in word:\n      diff = abs(ord(c) - ord(letter))\n      moves += min(diff, 26 - diff)\n      letter = c\n\n    return moves + len(word)",
      "title": "1974. Minimum Time to Type Word Using Special Typewriter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f6f95fa-a82d-422f-8db3-c469465c099c",
      "code": "class Solution:\n  def maxMatrixSum(self, matrix: list[list[int]]) -> int:\n    absSum = 0\n    minAbs = math.inf\n    # 0 := even number of negatives\n    # 1 := odd number of negatives\n    oddNeg = 0\n\n    for row in matrix:\n      for num in row:\n        absSum += abs(num)\n        minAbs = min(minAbs, abs(num))\n        if num < 0:\n          oddNeg ^= 1\n\n    return absSum - oddNeg * minAbs * 2",
      "title": "1975. Maximum Matrix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "214be979-2ba4-470f-ba43-a2e286b1d6b4",
      "code": "class Solution:\n  def countPaths(self, n: int, roads: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= MOD\n\n    return ways[dst]",
      "title": "1976. Number of Ways to Arrive at Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8b79a0e-0bfc-4441-a7bc-0b30ed6d4b9c",
      "code": "class Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    MOD = 1_000_000_007\n    n = len(num)\n    # dp[i][k] := the number of possible lists of integers ending in num[i]\n    # with the length of the last number being 1..k\n    dp = [[0] * (n + 1) for _ in range(n)]\n    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= MOD\n        # The last number is num[s..i].\n        s = i - k + 1\n        if num[s] == '0':\n          # the number of possible lists of integers ending in num[i] with the\n          # length of the last number being k\n          continue\n        if s == 0:  # the whole string\n          dp[i][k] += 1\n          continue\n        if s < k:\n          # The length k is not enough, so add the number of possible lists of\n          # integers in num[0..s - 1].\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          # Have enough length k and num[s - k..s - 1] <= num[j..i].\n          dp[i][k] += dp[s - 1][k]\n        else:\n          # Have enough length k but num[s - k..s - 1] > num[j..i].\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % MOD",
      "title": "1977. Number of Ways to Separate Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c75edbe9-0075-4e7a-9c5d-f1c758dc53e7",
      "code": "class Solution:\n  def findGCD(self, nums: list[int]) -> int:\n    return math.gcd(min(nums), max(nums))",
      "title": "1979. Find Greatest Common Divisor of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a6007ce-d95e-47a9-b2cb-e3bfedc8d9fa",
      "code": "class Solution:\n  def findDifferentBinaryString(self, nums: list[str]) -> str:\n    bitSize = len(nums[0])\n    maxNum = 1 << bitSize\n    numsSet = {int(num, 2) for num in nums}\n\n    for num in range(maxNum):\n      if num not in numsSet:\n        return f'{num:0>{bitSize}b}'",
      "title": "1980. Find Unique Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8b93c4f-2dda-42a3-b42b-5f5244f3335d",
      "code": "class Solution:\n  def minimizeTheDifference(self, mat: list[list[int]], target: int) -> int:\n    minSum = sum(min(row) for row in mat)\n    if minSum >= target:  # No need to consider any larger combination.\n      return minSum - target\n\n    @functools.lru_cache(None)\n    def dp(i: int, summ: int) -> int:\n      if i == len(mat):\n        return abs(summ - target)\n      return min(dp(i + 1, summ + num) for num in mat[i])\n\n    return dp(0, 0)",
      "title": "1981. Minimize the Difference Between Target and Chosen Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b091f674-220f-4b18-ac62-2ebdc23b3cc6",
      "code": "class Solution:\n  def recoverArray(self, n: int, sums: list[int]) -> list[int]:\n    def recover(sums: list[int]) -> list[int]:\n      if len(sums) == 1:\n        return []\n\n      count = collections.Counter(sums)\n      # Either num or -num must be in the final array.\n      #  num + sumsExcludingNum = sumsIncludingNum\n      # -num + sumsIncludingNum = sumsExcludingNum\n      num = sums[1] - sums[0]\n      sumsExcludingNum = []\n      sumsIncludingNum = []\n      chooseSumsExcludingNum = True\n\n      for summ in sums:\n        if count[summ] == 0:\n          continue\n        count[summ] -= 1\n        count[summ + num] -= 1\n        sumsExcludingNum.append(summ)\n        sumsIncludingNum.append(summ + num)\n        if summ + num == 0:\n          chooseSumsExcludingNum = False\n\n      # Choose `sumsExludingNum` by default since we want to gradually strip\n      # `num` from each sum in `sums` to have the final array. However, we should\n      # always choose the group of sums with 0 since it's a must-have.\n      return ([num] + recover(sumsExcludingNum) if chooseSumsExcludingNum else\n              [-num] + recover(sumsIncludingNum))\n\n    return recover(sorted(sums))",
      "title": "1982. Find Array Given Subset Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f91b4f2b-0cf0-4bbf-9a76-584af6778614",
      "code": "class Solution:\n  def widestPairOfIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      prefix += num1 - num2\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "1983. Widest Pair of Indices With Equal Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1281b2b6-0313-4805-b3ec-b6d10756900c",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = nums[k - 1] - nums[0]\n\n    for i in range(k, len(nums)):\n      ans = min(ans, nums[i] - nums[i - k + 1])\n\n    return ans",
      "title": "1984. Minimum Difference Between Highest and Lowest of K Scores",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f95b9761-9d99-434c-ac49-4b456f532e4d",
      "code": "class Solution:\n  # Similar to 215. Kth Largest Element in an Array\n  def kthLargestNumber(self, nums: list[str], k: int) -> str:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, int(num))\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return str(minHeap[0])",
      "title": "1985. Find the Kth Largest Integer in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3aab33ec-c973-4ee8-a462-18ada47af1cc",
      "code": "class Solution:\n  def minSessions(self, tasks: list[int], sessionTime: int) -> int:\n    # Returns True if we can assign tasks[s..n) to `sessions`. Note that `sessions`\n    # may be occupied by some tasks.\n    def dfs(s: int, sessions: list[int]) -> bool:\n      if s == len(tasks):\n        return True\n\n      for i, session in enumerate(sessions):\n        # Can't assign the tasks[s] to this session.\n        if session + tasks[s] > sessionTime:\n          continue\n        # Assign the tasks[s] to this session.\n        sessions[i] += tasks[s]\n        if dfs(s + 1, sessions):\n          return True\n        # Backtracking.\n        sessions[i] -= tasks[s]\n        # If it's the first time we assign the tasks[s] to this session, then future\n        # `session`s can't satisfy either.\n        if sessions[i] == 0:\n          return False\n\n      return False\n\n    for numSessions in range(1, len(tasks) + 1):\n      if dfs(0, [0] * numSessions):\n        return numSessions",
      "title": "1986. Minimum Number of Work Sessions to Finish the Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4efd78e-19b1-48c2-8772-eeed19a8443a",
      "code": "class Solution:\n  # Similar to 940. Distinct Subsequences II\n  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('0' + i)\n    endsIn = {'0': 0, '1': 0}\n\n    for c in binary:\n      endsIn[c] = sum(endsIn.values()) % MOD\n      # Don't count '0' since we want to avoid the leading zeros case.\n      # However, we can always count '1'.\n      if c == '1':\n        endsIn['1'] += 1\n\n    # Count '0' in the end.\n    return (sum(endsIn.values()) + ('0' in binary)) % MOD",
      "title": "1987. Number of Unique Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4071f641-7167-4d5d-b713-58aee9e16994",
      "code": "class Solution:\n  def catchMaximumAmountofPeople(self, team: list[int], dist: int) -> int:\n    ans = 0\n    i = 0  # 0s index\n    j = 0  # 1s index\n\n    while i < len(team) and j < len(team):\n      if i + dist < j or team[i] != 0:\n        # Find the next 0 that can be caught by 1.\n        i += 1\n      elif j + dist < i or team[j] != 1:\n        # Find the next 1 that can catch 0.\n        j += 1\n      else:\n        # team[j] catches team[i], so move both.\n        ans += 1\n        i += 1\n        j += 1\n\n    return ans",
      "title": "1989. Maximum Number of People That Can Be Caught in Tag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c06bde8-6cce-4231-8912-1cd0b4c7c8c7",
      "code": "class Solution:\n  def findMiddleIndex(self, nums: list[int]) -> int:\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      suffix -= num\n      if prefix == suffix:\n        return i\n      prefix += num\n\n    return -1",
      "title": "1991. Find the Middle Index in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b9e4a52-c8fa-455a-90db-d6d70287a750",
      "code": "class Solution:\n  def findFarmland(self, land: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(i: int, j: int, cell: list[int]) -> None:\n      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):\n        return\n      if land[i][j] != 1:\n        return\n      land[i][j] = 2  # Mark as visited.\n      cell[0] = max(cell[0], i)\n      cell[1] = max(cell[1], j)\n      dfs(i + 1, j, cell)\n      dfs(i, j + 1, cell)\n\n    for i in range(len(land)):\n      for j in range(len(land[0])):\n        if land[i][j] == 1:\n          cell = [i, j]\n          dfs(i, j, cell)\n          ans.append([i, j, *cell])\n\n    return ans",
      "title": "1992. Find All Groups of Farmland",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb45ac2f-56fd-4df8-948d-6d8567a2bc30",
      "code": "class Solution:\n  def numberOfGoodSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    # dp[i] := the number of good subsets with set of primes = i bit mask\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = sum(1 << i\n                          for i, prime in enumerate(primes)\n                          if num % prime == 0)\n      for primesMask in range(n):\n        # Skip since there're commen set of primes (becomes invalid subset)\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= MOD\n\n    return (1 << count[1]) * sum(dp[1:]) % MOD",
      "title": "1994. The Number of Good Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfb0e303-c6e5-4dbd-8f84-c8b52dc27353",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    count = collections.Counter()\n\n    #    nums[a] + nums[b] + nums[c] == nums[d]\n    # => nums[a] + nums[b] == nums[d] - nums[c]\n    for b in range(n - 1, 0, -1):  # `b` also represents `c`.\n      for a in range(b - 1, -1, -1):\n        ans += count[nums[a] + nums[b]]\n      for d in range(n - 1, b, -1):\n        count[nums[d] - nums[b]] += 1  # b := c\n\n    return ans",
      "title": "1995. Count Special Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c065d45-ecb4-4418-ab86-be0a44bc0a40",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    return sum(nums[a] + nums[b] + nums[c] == nums[d]\n               for a in range(n)\n               for b in range(a + 1, n)\n               for c in range(b + 1, n)\n               for d in range(c + 1, n))",
      "title": "1995. Count Special Quadruplets_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2f92af9-873b-4c8a-a5c6-8346cd795455",
      "code": "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans",
      "title": "1996. The Number of Weak Characters in the Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c5b6338-5642-412b-ace1-c0cfe745365b",
      "code": "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]",
      "title": "1997. First Day Where You Have Been in All the Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1366317-9dc6-4988-afe5-ed9c04928992",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "1998. GCD Sort of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64684ec7-f140-4fc9-8354-2c10095f20a2",
      "code": "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1",
      "title": "1999. Smallest Greater Multiple Made of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b28a24c5-fa61-4602-9305-d61cfc0faeec",
      "code": "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]",
      "title": "2000. Reverse Prefix of Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22e60d13-1722-4d01-872d-955c7584f620",
      "code": "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())",
      "title": "2001. Number of Pairs of Interchangeable Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdc9285a-750f-499c-90fa-55bf5a99b63f",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans",
      "title": "2002. Maximum Product of the Length of Two Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5399b24c-d343-4fa6-9583-2594063cc2de",
      "code": "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans",
      "title": "2003. Smallest Missing Genetic Value in Each Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b23289d6-fbf5-412f-8c53-2f47d5edceef",
      "code": "class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1",
      "title": "2005. Subtree Removal Game with Fibonacci Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ac9f38c-c03a-4617-90a4-3624a416c18d",
      "code": "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))",
      "title": "2006. Count Number of Pairs With Absolute Difference K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "814bbc39-6c32-48b7-b260-3cc887e41ef6",
      "code": "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans",
      "title": "2007. Find Original Array From Doubled Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06809f11-be2d-45d3-aef5-4a762514155f",
      "code": "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]",
      "title": "2008. Maximum Earnings From Taxi",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd76e55-cb07-4649-8245-c88f4d7ca967",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans",
      "title": "2009. Minimum Number of Operations to Make Array Continuous",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5ee1dec-3df0-49bc-b067-b601ee07056e",
      "code": "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)",
      "title": "2011. Final Value of Variable After Performing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9bc2ae3-a997-41f7-b789-dee8cd973614",
      "code": "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans",
      "title": "2012. Sum of Beauty in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "328521d9-d1fd-4dab-b6ac-f1ec26e1b053",
      "code": "class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans",
      "title": "2014. Longest Subsequence Repeated k Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb148cd5-bb40-4323-9ca9-7bbf07fe22be",
      "code": "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans",
      "title": "2015. Average Height of Buildings in Each Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8ed3896-ddfb-42b9-a72c-175f027fef79",
      "code": "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans",
      "title": "2016. Maximum Difference Between Increasing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90fc6f7c-511a-4cbd-8751-bbf38e35aaeb",
      "code": "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans",
      "title": "2017. Grid Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "933702f0-59e6-4fdc-ba3f-df1382f77d75",
      "code": "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False",
      "title": "2018. Check if Word Can Be Placed In Crossword",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07e90495-73c8-4f59-a83e-da594e4f1bff",
      "code": "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans",
      "title": "2019. The Score of Students Solving Math Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df05b1d9-2b53-49c6-b46d-0f41940f573d",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans",
      "title": "2021. Brightest Position on Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0233164d-0d0f-4d3a-be9c-79b7028703c8",
      "code": "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans",
      "title": "2022. Convert 1D Array Into 2D Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf1e2b33-a51d-46e0-9ea2-2ddb2cb00ebe",
      "code": "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans",
      "title": "2023. Number of Pairs of Strings With Concatenation Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e44a22bb-149c-4007-a646-8c216973b49b",
      "code": "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2024. Maximize the Confusion of an Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2093ac1c-9254-4c49-afd4-c3730156828c",
      "code": "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans",
      "title": "2025. Maximum Number of Ways to Partition an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31e0cbd7-3070-4a1d-84d9-869f7fbb4cb2",
      "code": "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans",
      "title": "2027. Minimum Moves to Convert String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3f4a742-d87f-4e04-94e0-8a73ef8dae52",
      "code": "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans",
      "title": "2028. Find Missing Observations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "098af294-ce08-4323-ba41-963890371939",
      "code": "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2",
      "title": "2029. Stone Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5016ecc6-718f-4a35-ae91-8092d2da99e0",
      "code": "class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)",
      "title": "2030. Smallest K-Length Subsequence With Occurrences of a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c881f8b4-a46b-45ab-87cb-b5487326cb4b",
      "code": "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans",
      "title": "2031. Count Subarrays With More Ones Than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3583a998-9bf0-4c8b-b82b-a6f29cb0e2ab",
      "code": "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]",
      "title": "2032. Two Out of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85185e6d-c298-4b51-af72-467141b3dad8",
      "code": "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans",
      "title": "2033. Minimum Operations to Make a Uni-Value Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb666b86-d69e-4079-8ee1-f22cd845f87d",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans",
      "title": "2035. Partition Array Into Two Arrays to Minimize Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dce607c-65ba-4534-a8c7-7c49a103cd25",
      "code": "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans",
      "title": "2036. Maximum Alternating Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eca956b6-e22c-45d2-9db0-a1eeb9daa2a6",
      "code": "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))",
      "title": "2037. Minimum Number of Moves to Seat Everyone",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8e58940-599c-48b7-9973-45907ce984e9",
      "code": "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB",
      "title": "2038. Remove Colored Pieces if Both Neighbors are the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "843ccd6f-c3c2-47ad-a592-211112c46fb2",
      "code": "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1",
      "title": "2039. The Time When the Network Becomes Idle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c25da17-c555-4354-9783-a6b7040890b3",
      "code": "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l",
      "title": "2040. Kth Smallest Product of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f57a5de8-c2af-4485-81e8-36e74f7a19da",
      "code": "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True",
      "title": "2042. Check if Numbers Are Ascending in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9172c130-928c-4127-84f0-35e8e759b720",
      "code": "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans",
      "title": "2044. Count Number of Maximum Bitwise-OR Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5f549d3-57bd-44ef-94e1-e389c6d2aad3",
      "code": "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))",
      "title": "2045. Second Minimum Time to Reach Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b0edadf-13de-4fd3-9365-44c09ed4a548",
      "code": "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head",
      "title": "2046. Sort Linked List Already Sorted Using Absolute Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8573be87-f4fb-4509-8057-b37b260e13eb",
      "code": "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())",
      "title": "2047. Number of Valid Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "559bddbc-2c51-420b-805c-c33c6ae7fc01",
      "code": "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n",
      "title": "2048. Next Greater Numerically Balanced Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2a64513-236f-4c39-9d2d-5b99fbc8b83f",
      "code": "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans",
      "title": "2049. Count Nodes With the Highest Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3e347d5-a5d8-48cc-b078-51afedb24b05",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)",
      "title": "2050. Parallel Courses III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "414b0119-a0d1-4843-8732-88451088cfc3",
      "code": "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])",
      "title": "2052. Minimum Cost to Separate Sentence Into Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa7ed381-cbdd-4c48-941d-63190e9eeac6",
      "code": "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''",
      "title": "2053. Kth Distinct String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45668ab6-6004-43a4-a2f6-62ca8335ad35",
      "code": "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans",
      "title": "2054. Two Best Non-Overlapping Events",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8225da69-241f-433c-be9c-ab851dc377f0",
      "code": "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans",
      "title": "2055. Plates Between Candles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dfd0fd6-b6d3-4415-9c69-736d4b6c9f16",
      "code": "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)",
      "title": "2056. Number of Valid Move Combinations On Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b71d3f0b-0028-43ed-9d5f-52f4f3cdc1fe",
      "code": "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)",
      "title": "2057. Smallest Index With Equal Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f85b14af-b8e2-4177-adc5-520442cce5d2",
      "code": "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]",
      "title": "2058. Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efb48add-9c42-48e9-a1dd-75e0de7cb9d8",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1",
      "title": "2059. Minimum Operations to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba39d6b7-4dbe-4f29-aee0-05eed6ea07df",
      "code": "class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)",
      "title": "2060. Check if an Original String Exists Given Two Encoded Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7139b45-dda4-41bc-b626-80c85659ce5b",
      "code": "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))",
      "title": "2061. Number of Spaces Cleaning Robot Cleaned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fc869bf-7943-42bf-8adf-a4337e48a4a6",
      "code": "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)",
      "title": "2062. Count Vowel Substrings of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf05c601-4f68-495a-b7b0-8dbfc9747dd0",
      "code": "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)",
      "title": "2063. Vowels of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15efa08-ec23-4029-8b4a-b7fc07b47660",
      "code": "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2064. Minimized Maximum of Products Distributed to Any Store",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75b9d339-5d62-4a35-9e81-2503b5a12da2",
      "code": "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans",
      "title": "2065. Maximum Path Quality of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48e931b9-c9ad-4620-a7b5-8df91997f146",
      "code": "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans",
      "title": "2067. Number of Equal Count Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09ac806d-17e9-40cb-94f7-db83c938a058",
      "code": "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())",
      "title": "2068. Check Whether Two Strings are Almost Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7406b4e-7d38-406a-8696-958893fc25e4",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]",
      "title": "2070. Most Beautiful Item for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56170287-c713-4ac9-a6ba-cf0f9fb4f853",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "2071. Maximum Number of Tasks You Can Assign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "999d8fe9-723c-41b7-ba72-bd30e62a0210",
      "code": "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans",
      "title": "2073. Time Needed to Buy Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "301503f2-1371-41ce-a10e-8616120215c4",
      "code": "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next",
      "title": "2074. Reverse Nodes in Even Length Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d539493-d268-4d2c-8b9c-dafcbe423686",
      "code": "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()",
      "title": "2075. Decode the Slanted Ciphertext",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1852692-3e8f-4d00-ae02-c31d0e62491a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans",
      "title": "2076. Process Restricted Friend Requests",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f57c63e-c7ed-40b0-bc47-919428c5f39c",
      "code": "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3",
      "title": "2077. Paths in Maze That Lead to Same Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfade47a-acff-4e3b-963d-b1513b8703b6",
      "code": "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)",
      "title": "2078. Two Furthest Houses With Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "423e154e-0d28-47c0-84af-f307093f0143",
      "code": "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)",
      "title": "2079. Watering Plants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebfa28e6-c110-46f8-b8a0-2bef07aca41d",
      "code": "class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans",
      "title": "2081. Sum of k-Mirror Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee3e8760-7de5-4533-a76b-3f14b35dd9fe",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans",
      "title": "2083. Substrings That Begin and End With the Same Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fe768aa-3407-44a4-ab4b-33e217cc080f",
      "code": "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())",
      "title": "2085. Count Common Words With One Occurrence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7884f90a-d61c-4de6-b8fa-a63ba7172a93",
      "code": "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')",
      "title": "2086. Minimum Number of Buckets Required to Collect Rainwater from Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa3660f9-a08a-4c78-8a39-cef97ebb4523",
      "code": "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans",
      "title": "2087. Minimum Cost Homecoming of a Robot in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ea3767-d634-4b29-aa7c-7628daa9af22",
      "code": "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)",
      "title": "2088. Count Fertile Pyramids in a Land",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdd6a731-9021-479f-a234-75fd596a8790",
      "code": "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]",
      "title": "2089. Find Target Indices After Sorting Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f781f047-5605-4203-bd8c-e055217420e8",
      "code": "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans",
      "title": "2090. K Radius Subarray Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba6dc182-9ca4-4b99-a7ae-af9d4a0e1708",
      "code": "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)",
      "title": "2091. Removing Minimum and Maximum From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0523804f-b92f-4a4f-9e29-202a2043d17e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]",
      "title": "2092. Find All People With Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1183c88-2352-4762-98cf-14e99dd3a190",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1",
      "title": "2093. Minimum Cost to Reach City With Discounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9952088f-7515-425d-a52f-c4c4e612c937",
      "code": "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans",
      "title": "2094. Finding 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8aec75d-982b-4fa9-8f7a-8218d4dd9892",
      "code": "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next",
      "title": "2095. Delete the Middle Node of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22a24387-779a-4aeb-8569-3a8bbfd70054",
      "code": "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26ffeaac-1bde-4635-9102-a10897eb5ced",
      "code": "class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]",
      "title": "2097. Valid Arrangement of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b11cda2-d510-40b8-b35c-1ee9c75befa7",
      "code": "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans",
      "title": "2098. Subsequence of Size K With the Largest Even Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0706569-64c7-4486-bbd6-69216a05dd2c",
      "code": "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans",
      "title": "2099. Find Subsequence of Length K With the Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01b9e1b9-0f55-4a62-b2cc-908ed1e1423c",
      "code": "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]",
      "title": "2100. Find Good Days to Rob the Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "382f7adb-e62c-45cc-bb82-1f0343c9548a",
      "code": "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans",
      "title": "2101. Detonate the Maximum Bombs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83319ff0-31e0-4454-8427-e55fcaf5b284",
      "code": "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)",
      "title": "2103. Rings and Rods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0781082f-b776-4f57-b541-8fb2b41335cd",
      "code": "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "2104. Sum of Subarray Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75992f4e-f6b9-43a5-b308-5cb6405bc329",
      "code": "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])",
      "title": "2105. Watering Plants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff063498-7581-42ba-bda4-531b6946e98f",
      "code": "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans",
      "title": "2106. Maximum Fruits Harvested After at Most K Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3107ed51-e7ac-4814-ba52-1fcd92f87b87",
      "code": "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans",
      "title": "2107. Number of Unique Flavors After Sharing K Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9eeee4e-e4b5-4ead-be6a-0d65cc999683",
      "code": "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')",
      "title": "2108. Find First Palindromic String in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "083f15a0-b08d-4091-bfd5-6b1393573a7a",
      "code": "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)",
      "title": "2109. Adding Spaces to a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8de76ce-3332-461e-ad7a-58205f0c5d46",
      "code": "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans",
      "title": "2110. Number of Smooth Descent Periods of a Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6db190eb-3a16-4e9b-9b16-6a231ad1c44a",
      "code": "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))",
      "title": "2111. Minimum Operations to Make the Array K-Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8dc8134-13e3-455c-b824-e07aeb4e1bf9",
      "code": "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]",
      "title": "2113. Elements in Array After Removing and Replacing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a95f0487-4db8-49a4-b905-e1290a23371f",
      "code": "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1",
      "title": "2114. Maximum Number of Words Found in Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58996925-622f-46d4-acbd-9abab66ef2a0",
      "code": "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans",
      "title": "2115. Find All Possible Recipes from Given Supplies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0917698f-a6af-4f83-a5bc-84d6aaf7a716",
      "code": "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)",
      "title": "2116. Check if a Parentheses String Can Be Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4280ed34-ddb5-45c5-a7d9-205cf4e62338",
      "code": "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)",
      "title": "2117. Abbreviating the Product of a Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b97c1c90-639a-4a12-9f5d-de361e12aa8f",
      "code": "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num",
      "title": "2119. A Number After a Double Reversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abe75c1c-bc0d-4013-95b3-98c0007498b9",
      "code": "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans",
      "title": "2120. Execution of All Suffix Instructions Staying in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea90b64c-1a83-49b3-8877-03cc1b5bb2b4",
      "code": "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]",
      "title": "2121. Intervals Between Identical Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "136ac50e-9e61-487e-b325-55f55d583e21",
      "code": "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr",
      "title": "2122. Recover the Original Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dcb0219-3dea-4896-98cf-f6f9dc7e472f",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans",
      "title": "2123. Minimum Operations to Remove Adjacent Ones in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f6d2570-b698-4711-8000-6cfb4222c92c",
      "code": "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s",
      "title": "2124. Check if All A's Appears Before All B's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5aee4711-a737-4f76-ac1d-abb95a928fc2",
      "code": "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans",
      "title": "2125. Number of Laser Beams in a Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3341792f-eba9-4810-bd89-003a0357680d",
      "code": "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True",
      "title": "2126. Destroying Asteroids",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3683be82-c2e5-44b1-a27e-981d646a1401",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)",
      "title": "2127. Maximum Employees to Be Invited to a Meeting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c335ddb-2f97-4884-b901-b18bf20d6a9c",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)",
      "title": "2128. Remove All Ones With Row and Column Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f3f8479-4041-472f-91b7-c416ccfbf0f3",
      "code": "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())",
      "title": "2129. Capitalize the Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75849c18-1dc3-497c-907f-151fe4ed2587",
      "code": "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans",
      "title": "2130. Maximum Twin Sum of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd2deaa2-0507-4342-a72d-aacee014383f",
      "code": "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans",
      "title": "2131. Longest Palindrome by Concatenating Two Letter Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7d7338d-6df8-454d-9eed-11413fcf2a8b",
      "code": "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True",
      "title": "2132. Stamping the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fdc9ed5-7adc-4a15-9394-f21b87550437",
      "code": "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))",
      "title": "2133. Check if Every Row and Column Contains All Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94f193f8-9b52-476a-9425-7d231cbd8d66",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "2134. Minimum Swaps to Group All 1's Together II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fe0077f-14d7-4adf-b00b-f22ee06fcf0a",
      "code": "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans",
      "title": "2135. Count Words Obtained After Adding a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac95808a-fe25-4fa3-82f4-8cefb14457be",
      "code": "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans",
      "title": "2136. Earliest Possible Day of Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b297004a-b6ae-4377-a027-5b73ff87f960",
      "code": "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "2137. Pour Water Between Buckets to Make Water Levels Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84b080ca-7f59-46a0-a388-eecead4e1875",
      "code": "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]",
      "title": "2138. Divide a String Into Groups of Size k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9011f378-b379-45f5-bab0-413faeec9606",
      "code": "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1",
      "title": "2139. Minimum Moves to Reach Target Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44b29926-a708-49d4-8072-2d9ecd4c0e74",
      "code": "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]",
      "title": "2140. Solving Questions With Brainpower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee57cae0-54ed-487c-83a2-e8c4f471db87",
      "code": "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n",
      "title": "2141. Maximum Running Time of N Computers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "275cb49d-41f9-450c-9db9-13684346cec1",
      "code": "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans",
      "title": "2143. Choose Numbers From Two Arrays in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b868d049-9a63-4861-8bf3-7508ee644ce7",
      "code": "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])",
      "title": "2144. Minimum Cost of Buying Candies With Discount",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "174a9996-f5b0-48d1-b2be-57e99c1cc58f",
      "code": "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)",
      "title": "2145. Count the Hidden Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8e12a02-404a-4471-9aec-b762968bf6c2",
      "code": "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans",
      "title": "2146. K Highest Ranked Items Within a Price Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46298cb4-e188-46ba-9346-f072692d4930",
      "code": "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0",
      "title": "2147. Number of Ways to Divide a Long Corridor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc94325e-5e75-481c-b376-556b59140627",
      "code": "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)",
      "title": "2148. Count Elements With Strictly Smaller and Greater Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0227aa16-c451-46cc-95bd-628808de0ca9",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans",
      "title": "2149. Rearrange Array Elements by Sign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4856624e-7708-4473-b658-a901d2a0ce5b",
      "code": "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]",
      "title": "2150. Find All Lonely Numbers in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67292b31-0abd-4349-9edf-e69ab90a9045",
      "code": "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans",
      "title": "2151. Maximum Good People Based on Statements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "573b0be6-d92b-48dd-9086-32d52b2dea44",
      "code": "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)",
      "title": "2152. Minimum Number of Lines to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb37d48f-fc68-4f11-a2ea-75bd88cae275",
      "code": "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original",
      "title": "2154. Keep Multiplying Found Values by Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a7ba54e-2e38-4767-91d1-642500874972",
      "code": "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans",
      "title": "2155. All Divisions With the Highest Score of a Binary Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6bd3a99-ba97-4cca-8b06-b1dded97391c",
      "code": "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]",
      "title": "2156. Find Substring With Given Hash Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87739926-0ba9-43cb-bf21-e625cd21b737",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]",
      "title": "2157. Groups of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa63a96c-b628-4318-be66-d3b4134b04a5",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans",
      "title": "2158. Amount of New Area Painted Each Day",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a409dbf-0d63-4f00-abbe-672a9eff8685",
      "code": "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])",
      "title": "2160. Minimum Sum of Four Digit Number After Splitting Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e98a6a1c-a34e-4e62-b301-bdff4f065687",
      "code": "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])",
      "title": "2161. Partition Array According to Given Pivot",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5675aa6-68f3-40eb-b4d0-451c7da77d4a",
      "code": "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans",
      "title": "2162. Minimum Cost to Set Cooking Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c57fd3ed-b280-4f82-88c6-d0615b845047",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans",
      "title": "2163. Minimum Difference in Sums After Removal of Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0be4f062-9202-43d5-a492-28bb4a9d41d5",
      "code": "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans",
      "title": "2164. Sort Even and Odd Indices Independently",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83974979-4fdc-4a67-a8e6-ae5a4d5b0b87",
      "code": "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)",
      "title": "2165. Smallest Value of the Rearranged Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02bc3b3b-547e-4e6c-ae0a-786cfb21dd83",
      "code": "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)",
      "title": "2167. Minimum Time to Remove All Cars Containing Illegal Goods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25c5dea6-21f7-46a3-bd31-efe0e61299e6",
      "code": "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())",
      "title": "2168. Unique Substrings With Equal Digit Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43872612-2209-436b-b78a-6dac989b1e9d",
      "code": "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans",
      "title": "2169. Count Operations to Obtain Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99cf3560-ca46-4781-b019-12423a7d322c",
      "code": "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)",
      "title": "2170. Minimum Operations to Make the Array Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8d3aa5b-b769-4185-92d6-13370f2cf51f",
      "code": "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))",
      "title": "2171. Removing Minimum Number of Magic Beans",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d77c7bbe-4b0f-4d70-9b65-c89866d6dd76",
      "code": "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]",
      "title": "2172. Maximum AND Sum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bd639c1-f640-467a-87fa-970ad643dc3b",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            newMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              newMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              newMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(newMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded",
      "title": "2174. Remove All Ones With Row and Column Flips II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37cd1550-0a8d-4af6-9488-102019974eec",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans",
      "title": "2176. Count Equal and Divisible Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4af3d38d-0171-4a02-b8fd-165e42cb62ea",
      "code": "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]",
      "title": "2177. Find Three Consecutive Integers That Sum to a Given Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "714ee5c4-562a-4886-b3a2-93b618573305",
      "code": "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]",
      "title": "2178. Maximum Split of Positive Even Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8fe8389-a753-4602-8c46-6e5c2d0b986c",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))",
      "title": "2179. Count Good Triplets in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bce920bf-f9fc-4ec3-97db-e0aa9ae78318",
      "code": "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2180. Count Integers With Even Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee7d5457-90d1-4ac2-b90a-3be3cb8fd1fc",
      "code": "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next",
      "title": "2181. Merge Nodes in Between Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2bf7cb9-e2d4-4adc-987f-bebdf5d1f07c",
      "code": "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '",
      "title": "2182. Construct String With Repeat Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3ad4409-c483-411f-bb63-aa6a68872ee1",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans",
      "title": "2183. Count Array Pairs Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f1737bc-fc3d-488c-9a46-c70b1dca75ef",
      "code": "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)",
      "title": "2184. Number of Ways to Build Sturdy Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82b8d4fa-41ca-44b0-9b79-a3274930b23f",
      "code": "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)",
      "title": "2185. Counting Words With a Given Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cce6142-c3c5-4851-9cf8-c03a800ff403",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])",
      "title": "2186. Minimum Number of Steps to Make Two Strings Anagram II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99006ed0-89d4-4be7-b1bb-5f1cbfa6a682",
      "code": "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2187. Minimum Time to Complete Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "946312f4-b67d-483c-af57-376704793d34",
      "code": "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime",
      "title": "2188. Minimum Time to Finish the Race",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf4b5251-704e-46af-8906-f25073d97f35",
      "code": "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]",
      "title": "2189. Number of Ways to Build House of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56c66f04-bffd-49ad-b166-32e925e4ef8e",
      "code": "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])",
      "title": "2190. Most Frequent Number Following Key In an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8fe31d2-07bf-4e45-8d58-759741797246",
      "code": "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]",
      "title": "2191. Sort the Jumbled Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f761dd6-f665-41b4-bef2-0871c7cf870c",
      "code": "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]",
      "title": "2192. All Ancestors of a Node in a Directed Acyclic Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a294c29a-71d8-4afd-a757-81c89a355b32",
      "code": "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans",
      "title": "2193. Minimum Number of Moves to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50cd8dd1-795f-486d-848e-ab6abe0ab0bb",
      "code": "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans",
      "title": "2194. Cells in a Range on an Excel Sheet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35bd74fa-e61d-4c09-a1c6-e8491a141734",
      "code": "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans",
      "title": "2195. Append K Integers With Minimal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87794781-fce0-4955-ac87-c54aec14de5d",
      "code": "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]",
      "title": "2196. Create Binary Tree From Descriptions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05e34ebb-5af7-44d4-95be-eb9b431f8412",
      "code": "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans",
      "title": "2197. Replace Non-Coprime Numbers in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15ed0fd-c127-4ee7-a157-7f999149e947",
      "code": "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6",
      "title": "2198. Number of Single Divisor Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac050e1b-955c-4a20-8a1a-8a734f4c55a5",
      "code": "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans",
      "title": "2200. Find All K-Distant Indices in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92699381-a6ad-4979-b6c6-a1ddb92002bd",
      "code": "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)",
      "title": "2201. Count Artifacts That Can Be Extracted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba77d3b2-2d31-4f6b-986c-be4fc8fc7de6",
      "code": "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])",
      "title": "2202. Maximize the Topmost Element After K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59d7cc93-5173-467d-8b20-198bf6b6f668",
      "code": "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2203. Minimum Weighted Subgraph With the Required Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56817dcd-6bfb-4599-a49b-09f7e1a9b6f9",
      "code": "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans",
      "title": "2204. Distance to a Cycle in Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8c8e484-93ff-496a-9c58-8fd6ffed934f",
      "code": "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())",
      "title": "2206. Divide Array Into Equal Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "935db980-8ad6-4d3d-bc54-c36914c2fa23",
      "code": "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)",
      "title": "2207. Maximize Number of Subsequences in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd0cab7c-381a-4fa7-9415-7aa2210fca65",
      "code": "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans",
      "title": "2208. Minimum Operations to Halve Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dac7376-b7f5-4396-b355-1e5d64a2bb1d",
      "code": "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]",
      "title": "2209. Minimum White Tiles After Covering With Carpets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d17f52e-a92e-44ad-a635-ffba2eaae330",
      "code": "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans",
      "title": "2210. Count Hills and Valleys in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fe100a8-df63-41a6-8c47-fe5435a5886b",
      "code": "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])",
      "title": "2211. Count Collisions on a Road",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36de2a01-5041-4efe-a53b-0313200d5c74",
      "code": "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)",
      "title": "2212. Maximum Points in an Archery Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91c97924-1e96-422b-a33f-01701a8c1937",
      "code": "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)",
      "title": "2214. Minimum Health to Beat Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffbcd7d0-edda-45fd-9cba-6ee5700af400",
      "code": "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]",
      "title": "2215. Find the Difference of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19917b4d-1f5b-402b-9bf4-4d06cee8ec6b",
      "code": "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)",
      "title": "2216. Minimum Deletions to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b173fc0d-f6ef-4b28-a360-35d6b63b4344",
      "code": "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]",
      "title": "2217. Find Palindrome With Fixed Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbe6e25a-1413-43c5-9ce4-663ed01039c7",
      "code": "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)",
      "title": "2218. Maximum Value of K Coins From Piles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87af1491-6a63-4ccd-abd5-d5760604a482",
      "code": "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans",
      "title": "2219. Maximum Sum Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "260d9bc4-465e-4d2d-8990-93e4e69b9952",
      "code": "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()",
      "title": "2220. Minimum Bit Flips to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "647407ed-7a1a-48e6-9eae-f295122acbc4",
      "code": "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]",
      "title": "2221. Find Triangular Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1066b9a-05a7-4e38-a49b-a2ebe4896a83",
      "code": "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans",
      "title": "2222. Number of Ways to Select Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "869df62d-8303-42e5-997c-53df759989e4",
      "code": "class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n",
      "title": "2223. Sum of Scores of Built Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2608a331-cb0d-4b50-8c2e-c1efeb48dc8f",
      "code": "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans",
      "title": "2224. Minimum Number of Operations to Convert Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7ed3fa0-b5d0-4601-88d5-003bad415595",
      "code": "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]",
      "title": "2225. Find Players With Zero or One Losses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "281b23ea-283e-466b-b395-a51ee7fdc8cc",
      "code": "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1",
      "title": "2226. Maximum Candies Allocated to K Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cceca1f-a4c4-4d3e-8a80-8e1c9ecbcbdf",
      "code": "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)",
      "title": "2229. Check if an Array Is Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3388d36-d32d-42ce-a749-a786cfa7c14f",
      "code": "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans",
      "title": "2231. Largest Number After Digit Swaps by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3b2ea6a-f701-4b9a-9314-55e2297baf80",
      "code": "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans",
      "title": "2232. Minimize Result by Adding Parentheses to Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d6c5839-3bd5-45ad-a9b4-e12443842a26",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans",
      "title": "2233. Maximum Product After K Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ba44a18-afab-4e64-ada0-7593ad5d519f",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans",
      "title": "2234. Maximum Total Beauty of the Gardens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "217a721c-054c-449d-9ddd-49bd2ccedf60",
      "code": "class Solution:\n  sum = operator.add",
      "title": "2235. Add Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55f6d256-ebcc-418c-957a-2434847e7614",
      "code": "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val",
      "title": "2236. Root Equals Sum of Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f359f334-bf75-45f2-aeae-64f4c1a76b28",
      "code": "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans",
      "title": "2237. Count Positions on Street With Required Brightness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf0de97b-42d8-45da-b769-f2acbc90010f",
      "code": "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]",
      "title": "2239. Find Closest Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a04166d1-cf46-4021-b1f8-556d32a71c2e",
      "code": "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1",
      "title": "2240. Number of Ways to Buy Pens and Pencils",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c303a30-9b47-4fb3-98ec-5c5d8fc26d43",
      "code": "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans",
      "title": "2242. Maximum Score of a Node Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b21d675-9b1a-4c1d-8f3b-2d52b7a49cfb",
      "code": "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s",
      "title": "2243. Calculate Digit Sum of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd4f1601-af7d-430b-9556-c53f4d03e1bb",
      "code": "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)",
      "title": "2244. Minimum Rounds to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bf0ff83-8476-46c4-8fce-e6c3c7b20dd7",
      "code": "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans",
      "title": "2245. Maximum Trailing Zeros in a Cornered Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53cf66b8-cea0-4b49-a513-bb50a58507d7",
      "code": "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans",
      "title": "2246. Longest Path With Different Adjacent Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ff7d82f-7bc0-484c-a9ea-1c65797a2504",
      "code": "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))",
      "title": "2247. Maximum Cost of Trip With K Highways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c4826dc-2fee-4362-a941-ada922cb1ff2",
      "code": "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]",
      "title": "2248. Intersection of Multiple Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0dd6572-5a7b-4916-8bd7-f2d49969b329",
      "code": "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)",
      "title": "2249. Count Lattice Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d28f7ae-6335-4286-991f-e7687fc9351c",
      "code": "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans",
      "title": "2250. Count Number of Rectangles Containing Each Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d703df1e-15fe-45a7-b386-5caf9936eff4",
      "code": "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]",
      "title": "2251. Number of Flowers in Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "051b7784-eba6-4c23-b431-4af833cdd60d",
      "code": "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))",
      "title": "2255. Count Prefixes of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef8438cb-18a1-4f29-94ef-66a1722888a9",
      "code": "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans",
      "title": "2256. Minimum Average Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c13860fe-ed9e-4d3a-a64a-12ca356c1a53",
      "code": "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans",
      "title": "2257. Count Unguarded Cells in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e5b3494-a6c1-4079-bdce-6af999762b9a",
      "code": "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False",
      "title": "2258. Escape the Spreading Fire",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a35a0eb3-2a57-46b7-9baa-bd604c463443",
      "code": "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans",
      "title": "2260. Minimum Consecutive Cards to Pick Up",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06ce3b82-361e-4432-b45b-c714c8620320",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans",
      "title": "2261. K Divisible Elements Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d05c7536-12ba-4398-8749-a53b837e04a1",
      "code": "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans",
      "title": "2262. Total Appeal of A String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a0cd065-2f79-40e1-b9a9-c0b5548fa015",
      "code": "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))",
      "title": "2263. Make Array Non-decreasing or Non-increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af0a185a-2657-46f8-894c-7d2b05e606ce",
      "code": "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))",
      "title": "2264. Largest 3-Same-Digit Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bae99415-70a4-4785-8f67-f2ebc5913407",
      "code": "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans",
      "title": "2265. Count Nodes Equal to Average of Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1bee8b2-2705-436e-a6d7-a9af451b7084",
      "code": "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]",
      "title": "2266. Count Number of Texts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93fb3bcb-347a-4605-9f3e-aa44ed22b99a",
      "code": "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)",
      "title": "2267. Check if There Is a Valid Parentheses String Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25e9e7ab-9434-432c-9814-e84a8a6aeff2",
      "code": "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))",
      "title": "2268. Minimum Number of Keypresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a41b100-46f2-453c-b9ca-59936dcc97ae",
      "code": "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans",
      "title": "2269. Find the K-Beauty of a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "531f3397-2a8f-4061-90ac-96ae5359c8bc",
      "code": "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans",
      "title": "2270. Number of Ways to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af67dc20-53cc-4ee4-a934-e6b7963a712f",
      "code": "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans",
      "title": "2271. Maximum White Tiles Covered by a Carpet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "292427e5-7f52-4efa-ab2d-8703a71db199",
      "code": "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)",
      "title": "2272. Substring With Largest Variance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86c81ccf-0590-43ca-b09e-d4db19f8ea95",
      "code": "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans",
      "title": "2273. Find Resultant Array After Removing Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a256be6c-8cc0-4633-94ac-c12bd97fc682",
      "code": "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])",
      "title": "2274. Maximum Consecutive Floors Without Special Floors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9607e7fb-9506-45ee-8308-d0af1194707a",
      "code": "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))",
      "title": "2275. Largest Combination With Bitwise AND Greater Than Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8807a14-10c0-4101-8518-6710fab82371",
      "code": "class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]",
      "title": "2277. Closest Node to Path in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b344274c-2c59-4e35-8a46-2e0c477f1e9b",
      "code": "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)",
      "title": "2278. Percentage of Letter in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6996d47d-76f2-4dd5-a5ba-e20b0683d23c",
      "code": "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)",
      "title": "2279. Maximum Bags With Full Capacity of Rocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bf38d6b-496d-47d1-8647-51d0e8cfd51c",
      "code": "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)",
      "title": "2280. Minimum Lines to Represent a Line Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ada409f-e396-4dda-be8d-83cdfa24e575",
      "code": "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD",
      "title": "2281. Sum of Total Strength of Wizards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34c7de06-c24f-4aca-92c6-379b1340fd2a",
      "code": "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans",
      "title": "2282. Number of People That Can Be Seen in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11dad5a7-1e03-45a9-b995-ff833d3c6194",
      "code": "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))",
      "title": "2283. Check if Number Has Equal Digit Count and Digit Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "376f1a39-bc3f-4dad-91df-076ac68bf16c",
      "code": "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans",
      "title": "2284. Sender With Largest Word Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42fd68ec-3b72-4822-9ae6-204a10986a13",
      "code": "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))",
      "title": "2285. Maximum Total Importance of Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98a3066b-c28b-49da-a93d-6d54bede5803",
      "code": "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)",
      "title": "2287. Rearrange Characters to Make Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b2f9e9e-61ef-42ec-b5b5-f3311c9e6ed8",
      "code": "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)",
      "title": "2288. Apply Discount to Prices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0a7b1f1-2d26-408c-a3b4-a11ed649c820",
      "code": "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)",
      "title": "2289. Steps to Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33ab67c5-b9f4-4664-bb67-3fd75d9fafb5",
      "code": "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]",
      "title": "2290. Minimum Obstacle Removal to Reach Corner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5126666-ebb2-47a4-b20d-c4714b829883",
      "code": "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]",
      "title": "2291. Maximum Profit From Trading Stocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c59fcc4-9506-4297-b043-1107cf1a8a6a",
      "code": "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)",
      "title": "2293. Min Max Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a21ae9c-fd89-49a0-a759-18a1ab2276ff",
      "code": "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans",
      "title": "2294. Partition Array Such That Maximum Difference Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c3365f6-be7f-4b10-b215-6dcb68fff215",
      "code": "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums",
      "title": "2295. Replace Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "223633c4-aab0-4265-be1d-ea3a2880116e",
      "code": "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]",
      "title": "2297. Jump Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c11d70b8-8c15-493c-beda-95f74bda023b",
      "code": "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))",
      "title": "2299. Strong Password Checker II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43361dd8-7e28-46f7-8f9a-e6af4ff3ecdd",
      "code": "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]",
      "title": "2300. Successful Pairs of Spells and Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a77b4367-4a06-4b2d-a45e-30b458cc136b",
      "code": "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True",
      "title": "2301. Match Substring After Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c36e5077-7e21-45f1-9177-a4bf924f6d63",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2302. Count Subarrays With Score Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07d69a47-e99f-4e7a-9702-3be5e5bc21f6",
      "code": "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans",
      "title": "2303. Calculate Amount Paid in Taxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e4c3050-1d97-442e-8049-11de15561203",
      "code": "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])",
      "title": "2304. Minimum Path Cost in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "914ef031-2efa-4a8a-88aa-4da6cae30e61",
      "code": "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans",
      "title": "2305. Fair Distribution of Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7d15808-ba46-42ff-885e-2f9fabc16144",
      "code": "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i, j in itertools.combinations(range(26), 2):\n      count = len(suffixes[i] & suffixes[j])\n      ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans",
      "title": "2306. Naming a Company",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1ee0d1a-f9fd-408c-9188-0893661804ed",
      "code": "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False",
      "title": "2307. Check for Contradictions in Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31deb361-daa3-418f-a4bd-c6292999c051",
      "code": "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''",
      "title": "2309. Greatest English Letter in Upper and Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "749833b7-7401-417f-9d3d-4fa6338a2c5d",
      "code": "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1",
      "title": "2310. Sum of Numbers With Units Digit K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db1f15fb-8674-43bb-911b-174b4d91f8d5",
      "code": "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount",
      "title": "2311. Longest Binary Subsequence Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd356e23-cdd3-4e43-a9d8-03894b65d918",
      "code": "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]",
      "title": "2312. Selling Pieces of Wood",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46b605b4-650e-4423-8453-03546069d5a4",
      "code": "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)",
      "title": "2313. Minimum Flips in Binary Tree to Get Result",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "515b9be8-725f-47b1-a7d7-e369b2bb2be3",
      "code": "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans",
      "title": "2315. Count Asterisks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fad27512-dceb-427b-bf33-b6242190d599",
      "code": "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)",
      "title": "2316. Count Unreachable Pairs of Nodes in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6cb42e-6b07-4f2b-874a-c918734f2eca",
      "code": "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)",
      "title": "2317. Maximum XOR After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce23cf18-347a-4f75-9e8b-244ae8b26ef5",
      "code": "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)",
      "title": "2318. Number of Distinct Roll Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2158034d-ebd9-48d0-bd89-3ec4cf150400",
      "code": "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True",
      "title": "2319. Check if Matrix Is X-Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8b38718-c14f-447b-8d49-50d63ac9c6a0",
      "code": "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD",
      "title": "2320. Count Number of Ways to Place Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "056571a6-b148-4ba9-8a91-cac3b57f2cc9",
      "code": "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))",
      "title": "2321. Maximum Score Of Spliced Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2549cac9-4879-4bcd-87d8-bed5ab564b02",
      "code": "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans",
      "title": "2322. Minimum Score After Removals on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d26507f-1379-4465-a661-c97df9d75d2d",
      "code": "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans",
      "title": "2323. Find Minimum Time to Finish All Jobs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e3a1d7c-cfe8-424b-8067-7e2a1c2f364d",
      "code": "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)",
      "title": "2325. Decode the Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7807165c-5c71-4745-8bae-27a382253f0d",
      "code": "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans",
      "title": "2326. Spiral Matrix IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0db16446-650e-4ebe-af24-fdf71ffc91d2",
      "code": "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD",
      "title": "2327. Number of People Aware of a Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd3d8542-c7e3-406a-8f38-86f6dac3baee",
      "code": "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD",
      "title": "2328. Number of Increasing Paths in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8104493-b8c7-4d15-ae8e-6230700f0ca7",
      "code": "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "2330. Valid Palindrome IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89e8094e-eda3-42cc-a8cd-034ca7de8fb2",
      "code": "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
      "title": "2331. Evaluate Boolean Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45b134f7-26b3-4021-9697-280763d9f162",
      "code": "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans",
      "title": "2332. The Latest Time to Catch a Bus",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "840d598c-b28f-45ec-b921-032ec83a4268",
      "code": "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1",
      "title": "2334. Subarray With Elements Greater Than Varying Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27b9e065-0e23-4254-991f-b826782ac07c",
      "code": "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)",
      "title": "2335. Minimum Amount of Time to Fill Cups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d736978f-500e-4847-8566-59b42389a667",
      "code": "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "2337. Move Pieces to Obtain a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91e8a98d-9f8b-446d-be6c-4281ff7f8299",
      "code": "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex",
      "title": "2340. Minimum Adjacent Swaps to Make a Valid Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f53f1a4b-c868-41bd-be29-d83b1d666c92",
      "code": "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans",
      "title": "2341. Maximum Number of Pairs in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f2fb8ae-e537-45e2-a39d-56988ab248bb",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2342. Max Sum of a Pair With Equal Sum of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff2bb403-78c4-4de0-b980-864761648492",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1",
      "title": "2344. Minimum Deletions to Make Array Divisible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4a736ae-3ed0-4ad0-843b-5090270665d8",
      "code": "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans",
      "title": "2345. Finding the Number of Visible Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e75eca76-f155-42c7-9d06-68e18215d4a2",
      "code": "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'",
      "title": "2347. Best Poker Hand",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f66eeda-3967-428a-a33f-f56978483715",
      "code": "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans",
      "title": "2348. Number of Zero-Filled Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfd1e327-9e5f-4e1c-888b-d72a7b8bcda5",
      "code": "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans",
      "title": "2350. Shortest Impossible Sequence of Rolls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bfc5663-824a-4ed7-b908-4c40dff026bc",
      "code": "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True",
      "title": "2351. First Letter to Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae13c28-190f-4abc-b3ef-bfaf69dd298d",
      "code": "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans",
      "title": "2352. Equal Row and Column Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1602a9b1-489c-449b-aa66-1220d31c293c",
      "code": "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)",
      "title": "2354. Number of Excellent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89acf9c2-7384-440e-a7bb-bd0235b29589",
      "code": "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)",
      "title": "2355. Maximum Number of Books You Can Take",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b85a85d1-5450-4eba-bf5e-fc01264025da",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})",
      "title": "2357. Make Array Zero by Subtracting Equal Amounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8563eb62-d015-4a58-bc1d-27a0db8b8c8c",
      "code": "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)",
      "title": "2358. Maximum Number of Groups Entering a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd0b923d-67b2-401d-be56-fe8eb64adfca",
      "code": "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist",
      "title": "2359. Find Closest Node to Given Two Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68250e5b-bf0f-43d8-93aa-c152d6931921",
      "code": "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans",
      "title": "2360. Longest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf7cca79-e958-4eb0-88de-035531ec3244",
      "code": "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans",
      "title": "2361. Minimum Costs Using the Train Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c12ad9bb-f3a4-4f23-961e-13588de0885a",
      "code": "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())",
      "title": "2363. Merge Similar Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee80c9dd-25ea-45f5-ab08-0ddb6eb539ce",
      "code": "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans",
      "title": "2364. Count Number of Bad Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80c35eee-682c-4c6e-aceb-9cdadf4cb49a",
      "code": "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans",
      "title": "2365. Task Scheduler II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a1d21af-c9a9-479f-b33b-f93ea0443755",
      "code": "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans",
      "title": "2366. Minimum Replacements to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af1d3fc6-39a7-4df6-89bb-85ef295c4214",
      "code": "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans",
      "title": "2367. Number of Arithmetic Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a28f866-0613-4f5e-a865-0e53d33cd6a9",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)",
      "title": "2368. Reachable Nodes With Restrictions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10e82732-b4cb-42d8-a4b0-7d96a0512a78",
      "code": "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]",
      "title": "2369. Check if There is a Valid Partition For The Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6abf8d2-fd9b-4e90-83d2-24b68ca2bf5a",
      "code": "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable",
      "title": "2370. Longest Ideal Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0513786-ed0a-4ffa-94d8-4c428c21f715",
      "code": "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans",
      "title": "2371. Minimize Maximum Value in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cf5f03b-d124-4e0d-8811-e7ead8ea770e",
      "code": "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans",
      "title": "2373. Largest Local Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10cdfb63-6a88-481f-9014-ac99f9e7c188",
      "code": "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))",
      "title": "2374. Node With Highest Edge Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a835b49e-c0d6-4e84-9910-53419514c6be",
      "code": "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)",
      "title": "2375. Construct Smallest Number From DI String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c434f00-0f91-4529-ba39-1ae6d1711ec9",
      "code": "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "2376. Count Special Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb039e67-4ac3-422f-ad20-743f214bbf40",
      "code": "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)",
      "title": "2378. Choose Edges to Maximize Score in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d51e717b-ef96-42c4-8cf3-7c80240189e1",
      "code": "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB",
      "title": "2379. Minimum Recolors to Get K Consecutive Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19b9c7e1-d7ca-4d49-945e-569fb8aa1090",
      "code": "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans",
      "title": "2380. Time Needed to Rearrange a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47297f63-6d81-4265-9d01-e65b016ab88c",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    line = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      line[start] += diff\n      line[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + line[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)",
      "title": "2381. Shifting Letters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e4a52b2-4c59-4f41-9073-7bb0909a73e9",
      "code": "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans",
      "title": "2382. Maximum Segment Sum After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "135fecaa-1621-4353-89f0-bb634a6954de",
      "code": "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience",
      "title": "2383. Minimum Hours of Training to Win a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb92035f-c0ba-4984-abb0-d43d69f0b131",
      "code": "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''",
      "title": "2384. Largest Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93f6e81f-e76d-4ef1-8465-9f51f0f8f5fe",
      "code": "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph",
      "title": "2385. Amount of Time for Binary Tree to Be Infected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a20511df-bf42-459e-af62-710d7763408f",
      "code": "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum",
      "title": "2386. Find the K-Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "961b662c-c2f7-4343-8392-1af00f23fef3",
      "code": "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2387. Median of a Row Wise Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea3f1ad6-7062-4051-af78-57e62f1707c8",
      "code": "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]",
      "title": "2389. Longest Subsequence With Limited Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8579cc0d-73c2-4349-9438-5a07d07c7cae",
      "code": "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "2390. Removing Stars From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6d18263-6574-416d-9281-de426a70e50c",
      "code": "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')",
      "title": "2391. Minimum Amount of Time to Collect Garbage",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c623aa3-b7ec-48f9-b08e-15438f23c26b",
      "code": "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []",
      "title": "2392. Build a Matrix With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2794a112-dbb2-48df-a069-c6de70d03e38",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans",
      "title": "2393. Count Strictly Increasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2621db-5d37-4478-921d-82864060cd98",
      "code": "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False",
      "title": "2395. Find Subarrays With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94d98a91-30da-4a3e-9cd4-91d7ffc64f32",
      "code": "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False",
      "title": "2396. Strictly Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d1d0be9-d07f-49b9-a54d-1396fb40f65d",
      "code": "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count",
      "title": "2397. Maximum Rows Covered by Columns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7771229-4605-4763-b475-be6911c48885",
      "code": "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j",
      "title": "2398. Maximum Number of Robots Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aafcd0e-940d-420a-b07a-383cad9fb9b4",
      "code": "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True",
      "title": "2399. Check Distances Between Same Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a9c77f-fde5-4a93-b14b-660b5fd43df8",
      "code": "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]",
      "title": "2400. Number of Ways to Reach a Position After Exactly k Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1df40be-c1ea-4eb9-bbe2-6336df659492",
      "code": "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2401. Longest Nice Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "863b0fdd-1a87-4939-9e66-d30e2b804ed5",
      "code": "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))",
      "title": "2402. Meeting Rooms III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85aa3f4d-be61-4515-a6fa-2ace95673422",
      "code": "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]",
      "title": "2403. Minimum Time to Kill All Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed7ebdd-639a-418c-a61c-ea3eb26c58bc",
      "code": "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans",
      "title": "2404. Most Frequent Even Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0244705a-0b45-4aad-9122-ceb9e14484c7",
      "code": "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans",
      "title": "2405. Optimal Partition of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f977e1fe-7233-4a0e-9ad1-eda34cf28c24",
      "code": "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)",
      "title": "2406. Divide Intervals Into Minimum Number of Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dea446ca-7465-4b9f-9593-2e1aab588f0a",
      "code": "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans",
      "title": "2409. Count Days Spent Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bfa7471-986a-4508-8831-d0df27b224a4",
      "code": "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans",
      "title": "2410. Maximum Matching of Players With Trainers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7591326c-4c46-472a-8d17-04d537236359",
      "code": "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans",
      "title": "2411. Smallest Subarrays With Maximum Bitwise OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242f20b5-8716-43c6-b5a0-8f0f73787888",
      "code": "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans",
      "title": "2412. Minimum Money Required Before Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dce6c21-a7fd-4826-9844-5f6defe50a79",
      "code": "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)",
      "title": "2413. Smallest Even Multiple",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8e8c998-b2f7-48b3-8e7e-6588f0031bb6",
      "code": "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans",
      "title": "2414. Length of the Longest Alphabetical Continuous Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de4d0ab5-d7b1-4f9d-a987-4315e4f43aef",
      "code": "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root",
      "title": "2415. Reverse Odd Levels of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81591357-425d-42e5-adf8-2529f2937305",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]",
      "title": "2416. Sum of Prefix Scores of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63c47144-123e-4052-8b76-d356574ad9e0",
      "code": "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0",
      "title": "2417. Closest Fair Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9e1aa39-5bd4-4de5-af84-08b023383848",
      "code": "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]",
      "title": "2418. Sort the People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "013f6f39-8b5e-43da-8049-43562153edb6",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans",
      "title": "2419. Longest Subarray With Maximum Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba789eec-869d-49a2-9350-d252368ba4de",
      "code": "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]",
      "title": "2420. Find All Good Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2eb27d0-e1f7-4cd4-980b-aea8e7e48a2a",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans",
      "title": "2422. Merge Operations to Turn Array Into a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0b68420-5a4a-4ca9-8334-12351b62817e",
      "code": "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False",
      "title": "2423. Remove Letter To Equalize Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96103ba0-2e1e-4dbc-a90e-6a639c5a35bb",
      "code": "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)",
      "title": "2425. Bitwise XOR of All Pairings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6226066-f8d2-4f97-8429-84585af604d2",
      "code": "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))",
      "title": "2427. Number of Common Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6a2d46b-9de8-41ba-827a-994214f65d71",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))",
      "title": "2428. Maximum Sum of an Hourglass",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41461cd7-7cf5-470b-a5b7-a74285fd501e",
      "code": "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans",
      "title": "2429. Minimize XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ec77c73-945b-4021-b8d6-7349cfa629fa",
      "code": "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]",
      "title": "2430. Maximum Deletions on a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1af7fe4d-3ce5-4be2-908a-e16ce38c7b0a",
      "code": "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]",
      "title": "2431. Maximize Total Tastiness of Purchased Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1e758ea-115d-4abf-886f-1c9a4feebe4b",
      "code": "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans",
      "title": "2432. The Employee That Worked on the Longest Task",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5780775f-db7e-409e-902b-0da43a9d704b",
      "code": "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans",
      "title": "2433. Find The Original Array of Prefix Xor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4abe5ef5-4ebf-4129-b69e-4892b2d927e8",
      "code": "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'",
      "title": "2434. Using a Robot to Print the Lexicographically Smallest String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6fdfaee-6129-443d-b262-f9e3613fc8a5",
      "code": "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]",
      "title": "2435. Paths in Matrix Whose Sum Is Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb7b3791-1d77-4025-b260-910cdfe7b708",
      "code": "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans",
      "title": "2436. Minimum Split Into Subarrays With GCD Greater Than One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d11a5256-d9e6-4977-aea1-6657648997ca",
      "code": "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans",
      "title": "2437. Number of Valid Clock Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f4c593d-298e-4f7e-8df0-565bae4f19c1",
      "code": "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    pows = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= pows[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans",
      "title": "2438. Range Product Queries of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50bc70f4-44ee-4bf9-9906-acdce616b14b",
      "code": "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans",
      "title": "2439. Minimize Maximum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3bd9086-fdef-4ee6-abf1-12bcc4b5870a",
      "code": "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0",
      "title": "2440. Create Components With Same Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3753a9b6-439b-403d-9fd4-5edc604d4f66",
      "code": "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans",
      "title": "2441. Largest Positive Integer That Exists With Its Negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a7c7d0f-4dfe-4b95-b504-347b6f56463a",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans",
      "title": "2444. Count Subarrays With Fixed Bounds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e636754a-2016-4ce1-92ff-a3d22b09b3fb",
      "code": "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)",
      "title": "2445. Number of Nodes With Value One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e3cbfea-270d-4825-a998-3f083dde11cf",
      "code": "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans",
      "title": "2447. Number of Subarrays With GCD Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14f6b111-44fe-421f-8dad-a3fa4e49b53f",
      "code": "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans",
      "title": "2448. Minimum Cost to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5f8155e-0c14-4f6a-886c-fbf37889c257",
      "code": "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4",
      "title": "2449. Minimum Number of Operations to Make Arrays Similar",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf4da9c0-d89e-41cf-bbc9-2dfc0988ac3c",
      "code": "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)",
      "title": "2450. Number of Distinct Binary Strings After Applying Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfd5c651-a434-4a1b-b7de-bf193cba9a5d",
      "code": "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word",
      "title": "2451. Odd String Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0318f2e5-d285-434e-9e5c-be5092fdeb95",
      "code": "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]",
      "title": "2452. Words Within Two Edits of Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06c4fb95-f17a-4441-b7e6-69734869a1ce",
      "code": "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)",
      "title": "2453. Destroy Sequential Targets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4353a91-3c72-4df0-9578-2993f3120d67",
      "code": "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans",
      "title": "2454. Next Greater Element IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23e6cc9d-642e-40fa-8904-2ee7ead9eda3",
      "code": "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count",
      "title": "2455. Average Value of Even Numbers That Are Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a11f41d8-463d-476d-bdcd-3513d3f6623e",
      "code": "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans",
      "title": "2456. Most Popular Video Creator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b322563-d921-4a60-aa51-2a8b8a1492da",
      "code": "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans",
      "title": "2457. Minimum Addition to Make Integer Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70eee31e-7df9-4897-a478-72bb0047fa79",
      "code": "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]",
      "title": "2458. Height of Binary Tree After Subtree Removal Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc72e980-7b3f-42b9-b79c-f358d085a135",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))",
      "title": "2459. Sort Array by Moving Items to Empty Space",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb1c357b-8de3-4a7f-ad0a-1f75533b247f",
      "code": "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans",
      "title": "2460. Apply Operations to an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "033120f0-acc2-4d0b-8411-f0e8c2ee29f2",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2461. Maximum Sum of Distinct Subarrays With Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "415d1ea1-dbc8-41a9-be79-b48d75630036",
      "code": "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans",
      "title": "2462. Total Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "daa5e843-6613-41d9-9208-d31f15c7a7fc",
      "code": "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)",
      "title": "2463. Minimum Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24a3317b-cb18-40be-aa52-5380e891e198",
      "code": "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "2464. Minimum Subarrays in a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2df159ce-7028-4c6c-afbd-5a501aa82e74",
      "code": "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)",
      "title": "2465. Number of Distinct Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "526b5af8-8b0d-4d22-a2d0-1a0940d2e134",
      "code": "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans",
      "title": "2466. Count Ways To Build Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fb09c35-dede-4758-9da2-bf0b63165145",
      "code": "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath",
      "title": "2467. Most Profitable Path in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea875a38-d0d3-4fbc-a768-c4ded22f240e",
      "code": "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans",
      "title": "2468. Split Message Based on Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "517e0d13-f3f0-4679-b5c5-c9d02c1002b5",
      "code": "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]",
      "title": "2469. Convert the Temperature",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08dce570-efa2-4808-8c50-5ff77512f8c3",
      "code": "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans",
      "title": "2470. Number of Subarrays With LCM Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "200ae12f-82c2-4042-af67-4ee6d52566bd",
      "code": "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans",
      "title": "2471. Minimum Number of Operations to Sort a Binary Tree by Level",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73469cb8-b7c9-4df6-8b9c-d57a5a8cb75c",
      "code": "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]",
      "title": "2472. Maximum Number of Non-overlapping Palindrome Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9308e08d-e8ea-47c0-8569-f82e048a77ad",
      "code": "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans",
      "title": "2473. Minimum Cost to Buy Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "859bd2ac-3863-418b-ac05-4e115c535778",
      "code": "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans",
      "title": "2475. Number of Unequal Triplets in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31817ed3-d3cc-450e-afc3-ca14fd10014a",
      "code": "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)",
      "title": "2476. Closest Nodes Queries in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f301ab37-504a-4046-8e7c-8368c6655c2b",
      "code": "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans",
      "title": "2477. Minimum Fuel Cost to Report to the Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c96a95b6-e47d-4c2d-a796-eacbc9b2d3ff",
      "code": "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)",
      "title": "2478. Number of Beautiful Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a52f1b9e-ad16-4a0e-a1e0-39ba85577665",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans",
      "title": "2479. Maximum XOR of Two Non-Overlapping Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "461e420b-ee44-4e53-b0e6-002610d38fb0",
      "code": "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n",
      "title": "2481. Minimum Cuts to Divide a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1add7454-5089-4a5c-8149-c115f5e80899",
      "code": "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans",
      "title": "2482. Difference Between Ones and Zeros in Row and Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3f66beb-8a0e-4370-a97f-c4b883b4b49f",
      "code": "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans",
      "title": "2483. Minimum Penalty for a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ad3b338-5ad4-4f7b-9abf-928aafce8823",
      "code": "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans",
      "title": "2484. Count Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dc65da8-1889-4f3e-a14e-1b0be7b19b12",
      "code": "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1",
      "title": "2485. Find the Pivot Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af4242f8-f9b7-4d69-a926-719671c2913e",
      "code": "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i",
      "title": "2486. Append Characters to String to Make Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af463598-4406-468a-b973-0b8d1c4a313b",
      "code": "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head",
      "title": "2487. Remove Nodes From Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32ed3eab-b59e-4576-9d33-5e7ef42e1928",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans",
      "title": "2488. Count Subarrays With Median K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b014f8f-c1c8-42b4-9599-3f5bc63f3bc1",
      "code": "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2489. Number of Substrings With Fixed Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "accf6084-9044-4c7f-a5f5-49f04e78b2ef",
      "code": "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]",
      "title": "2490. Circular Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "007f4c21-515f-4cc8-8a64-beea0c668caf",
      "code": "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2",
      "title": "2491. Divide Players Into Teams of Equal Skill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e7ac95b-753d-43a6-bea4-bfc85be64787",
      "code": "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans",
      "title": "2492. Minimum Score of a Path Between Two Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77917813-afb6-4532-9b48-4f46ac141db4",
      "code": "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans",
      "title": "2495. Number of Subarrays Having Even Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca8ccced-941d-4d79-b8c5-192a3cc1edb9",
      "code": "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)",
      "title": "2496. Maximum Value of a String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7608733d-4a54-45fb-9184-8e0ff99b7c3d",
      "code": "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans",
      "title": "2497. Maximum Star Sum of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf656cc5-0126-4a50-8d39-c964c9b201b4",
      "code": "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))",
      "title": "2498. Frog Jump II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "160ac91e-b3f8-42e9-84a0-d2868ab10901",
      "code": "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans",
      "title": "2499. Minimum Total Cost to Make Arrays Unequal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ca30350-1935-47e2-a146-a328d8a9466b",
      "code": "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))",
      "title": "2500. Delete Greatest Value in Each Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58fff320-4c29-4d1a-9ef8-36b841a1853a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans",
      "title": "2503. Maximum Number of Points From Grid Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dae7fb6-f143-4988-bfec-26dd7149a1eb",
      "code": "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans",
      "title": "2505. Bitwise OR of All Subsequence Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3280af68-2f9a-4da7-b231-6090ccb66a9c",
      "code": "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    masks = [self._getMask(word) for word in words]\n    return sum(masks[i] == masks[j]\n               for i, j in itertools.combinations(range(len(masks)), 2))\n\n  def _getMask(self, word: str) -> int:\n    mask = 0\n    for c in word:\n      mask |= 1 << ord(c) - ord('a')\n    return mask",
      "title": "2506. Count Pairs Of Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "724ab0c4-f435-4a89-ac36-ad3671ef2e4e",
      "code": "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n",
      "title": "2507. Smallest Value After Replacing With Sum of Prime Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a6555dc-51a3-4927-8c6f-71f5f7625325",
      "code": "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False",
      "title": "2508. Add Edges to Make Degrees of All Nodes Even",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e95e7b89-5f32-45c8-8d40-2ac0d84377da",
      "code": "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]",
      "title": "2509. Cycle Length Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef69b046-2017-4489-931d-b253bfc21bc4",
      "code": "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)",
      "title": "2510. Check if There is a Path With Equal Number of 0's And 1's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "224ca25c-b9a1-439d-932d-d82c13f70fdf",
      "code": "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans",
      "title": "2511. Maximum Enemy Forts That Can Be Captured",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d97732c6-8841-46b0-9269-70bf515c8895",
      "code": "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]",
      "title": "2512. Reward Top K Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "760f6cc8-746b-4cbb-9209-cc72a3c7d1a6",
      "code": "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2513. Minimize the Maximum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16c8282-41ad-4b67-875f-3c1681601342",
      "code": "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007",
      "title": "2514. Count Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f40f682-a353-4432-b665-c626ca5c6099",
      "code": "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1",
      "title": "2515. Shortest Distance to Target String in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cb70ac5-d854-4eae-9233-708b2c7a5949",
      "code": "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans",
      "title": "2516. Take K of Each Character From Left and Right",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90a83e00-093d-41c6-8a3d-6dd305308777",
      "code": "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1",
      "title": "2517. Maximum Tastiness of Candy Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "238adf1a-22b0-4b58-8f3f-6361a28bac1c",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD",
      "title": "2518. Number of Great Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af17142e-a7c6-47ef-9451-47db03a4bc32",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))",
      "title": "2519. Count the Number of K-Big Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e0cb19c-6280-4557-b425-97227f5358a9",
      "code": "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))",
      "title": "2520. Count the Digits That Divide a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bafc8258-7c2c-4af6-9643-d2b21924c6f8",
      "code": "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor",
      "title": "2521. Distinct Prime Factors of Product of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67ddd2ce-15c0-4815-ae65-f07a83618f77",
      "code": "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans",
      "title": "2522. Partition String Into Substrings With Values at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9598c996-c62c-4e8b-b8cc-2edfee5dad38",
      "code": "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2523. Closest Prime Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62677172-6831-4ca8-843c-599fa8b8fe71",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ",
      "title": "2524. Maximum Frequency Score of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9ff1af1-d1f9-4e15-bf8d-132513018e3a",
      "code": "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'",
      "title": "2525. Categorize Box According to Criteria",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1db4000-064f-40fb-afd1-89cd6c7900e2",
      "code": "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)",
      "title": "2527. Find Xor-Beauty of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19586206-b4ed-4408-94cd-499405ec1756",
      "code": "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1",
      "title": "2528. Maximize the Minimum Powered City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59e5e5de-1d4e-408b-afb8-ec8a5b315a9c",
      "code": "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))",
      "title": "2529. Maximum Count of Positive Integer and Negative Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb1ec879-f954-47ca-83a8-92bbc70cd8da",
      "code": "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans",
      "title": "2530. Maximal Score After Applying K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a09eba82-c2b5-457e-a671-e01106c86e7f",
      "code": "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False",
      "title": "2531. Make Number of Distinct Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddba687b-ce29-427c-8e48-fec14dd25fa1",
      "code": "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans",
      "title": "2532. Time to Cross a Bridge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3093d5a3-3649-4f8a-a3db-6d811861c236",
      "code": "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD",
      "title": "2533. Number of Good Binary Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91f26f02-1c59-4fdb-a500-06f65b182afd",
      "code": "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2535. Difference Between Element Sum and Digit Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3c486f1-bcf6-4ea4-98fc-17062d2a50e1",
      "code": "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans",
      "title": "2538. Difference Between Maximum and Minimum Price Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3478eee7-be05-4337-a049-4976c60d9488",
      "code": "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans",
      "title": "2539. Count the Number of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0986b402-3f07-41a2-9f09-0fd195cb2256",
      "code": "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1",
      "title": "2540. Minimum Common Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79092716-646d-4381-a8f2-d8c44bbeca12",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1",
      "title": "2541. Minimum Operations to Make Array Equal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65a3e469-6496-4747-9ad8-e7b6833f37e2",
      "code": "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans",
      "title": "2542. Maximum Subsequence Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5681b3e2-12c7-4c08-819e-006767dca27b",
      "code": "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1",
      "title": "2543. Check if Point Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62a8fe24-d551-46c7-9dd7-23ef306a5e65",
      "code": "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans",
      "title": "2544. Alternating Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e4eb243-a2d1-4fec-a358-d26fa9d7ef52",
      "code": "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])",
      "title": "2545. Sort the Students by Their Kth Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "377e0fbf-544e-4afc-8dcf-adaeafaff8c9",
      "code": "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)",
      "title": "2546. Apply Bitwise Operations to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0034da1b-fbd2-45cd-8fbc-734816fde4ea",
      "code": "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]",
      "title": "2547. Minimum Cost to Split an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df519068-1fee-4ba3-ad26-13f92d2c0aa9",
      "code": "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1",
      "title": "2548. Maximum Price to Fill a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed7ec47e-3789-42b7-9f30-397a4defe51c",
      "code": "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)",
      "title": "2549. Count Distinct Numbers on Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5426fcb-ba81-4603-bb5c-d161656346a5",
      "code": "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res",
      "title": "2550. Count Collisions of Monkeys on a Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0859b5fc-35e4-4c10-a0e6-2d22eb071145",
      "code": "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))",
      "title": "2551. Put Marbles in Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "801d2205-8a33-46bb-a436-7379adee147b",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans",
      "title": "2552. Count Increasing Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98d9b017-ce15-4d36-9285-bda8919f1eeb",
      "code": "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]",
      "title": "2553. Separate the Digits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42a12f08-1bd2-4a1e-a267-e7db81cab0f9",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans",
      "title": "2554. Maximum Number of Integers to Choose From a Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d52e3271-8e82-43cd-9520-898891666976",
      "code": "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans",
      "title": "2555. Maximize Win From Two Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a3199ae-4e72-41ab-bf66-3d33fe6b0679",
      "code": "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)",
      "title": "2556. Disconnect Path in a Binary Matrix by at Most One Flip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d497f0c-224a-4561-9c87-bdc9de9fc60a",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)",
      "title": "2557. Maximum Number of Integers to Choose From a Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "166895f8-ecd4-459b-afff-71616c724f27",
      "code": "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)",
      "title": "2558. Take Gifts From the Richest Pile",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b02247b4-49a0-46e1-86cc-761b30258fb4",
      "code": "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]",
      "title": "2559. Count Vowel Strings in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdf1822c-7706-446e-aec3-6729622acbb2",
      "code": "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)",
      "title": "2560. House Robber IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9a24900-8fa7-42ba-ac06-f34dd2250e66",
      "code": "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])",
      "title": "2561. Rearranging Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dfea7b0-dc60-4a33-b67a-bda984097e2b",
      "code": "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)",
      "title": "2563. Count the Number of Fair Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e805428-0c59-4156-ba9a-07807c1dc525",
      "code": "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]",
      "title": "2564. Substring XOR Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf2afb20-49c3-442c-9e64-629b213f4eed",
      "code": "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans",
      "title": "2565. Subsequence With the Minimum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52319e56-304d-4d74-96dc-e3b2bcf205b8",
      "code": "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0",
      "title": "2566. Maximum Difference by Remapping a Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13cf6c57-9b91-43e7-986b-39899a85d9ea",
      "code": "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)",
      "title": "2567. Minimum Score by Changing Two Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b200bc3c-f156-4e0c-b69c-761271e74d0b",
      "code": "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans",
      "title": "2568. Minimum Impossible OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48e6cac6-6f22-4426-9e6e-7aeaacce9252",
      "code": "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val",
      "title": "2570. Merge Two 2D Arrays by Summing Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa84bfbc-1faa-44f8-b738-f61c849a15dd",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans",
      "title": "2571. Minimum Operations to Reduce an Integer to 0",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddbc68d6-ec0c-483d-9fce-f0dd774e2ea9",
      "code": "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD",
      "title": "2572. Count the Number of Square-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6f2f844-1f34-4802-a4b1-22bea3245781",
      "code": "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]",
      "title": "2574. Left and Right Sum Differences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cf28a3d-23c2-4b45-9159-55d8b70c3ac3",
      "code": "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans",
      "title": "2575. Find the Divisibility Array of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79587266-726c-404e-91e3-36c76eb7756f",
      "code": "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2",
      "title": "2576. Find the Maximum Number of Marked Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26788f22-bb28-46ff-996b-f2f1381dceba",
      "code": "class Solution:\n  def minimumTime(self, grid: list[list[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]  # (time, i, j)\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))",
      "title": "2577. Minimum Time to Visit a Cell In a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c70e8a47-f8f1-4b0c-92be-8a00c7735968",
      "code": "class Solution:\n  def splitNum(self, num: int) -> int:\n    s = ''.join(sorted(str(num)))\n    return sum(map(int, (s[::2], s[1::2])))",
      "title": "2578. Split With Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce0380d-3ceb-4950-97be-da25f103955b",
      "code": "class Solution:\n  def coloredCells(self, n: int) -> int:\n    return n**2 + (n - 1)**2",
      "title": "2579. Count Total Number of Colored Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f742d148-9062-4c80-a5be-c426395563e6",
      "code": "class Solution:\n  def countWays(self, ranges: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevEnd = -1\n\n    for start, end in sorted(ranges):\n      if start > prevEnd:\n        ans = ans * 2 % MOD\n      prevEnd = max(prevEnd, end)\n\n    return ans",
      "title": "2580. Count Ways to Group Overlapping Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1c1006a-48c7-4d13-8576-503d49582727",
      "code": "class Solution:\n  def rootCount(\n      self,\n      edges: list[list[int]],\n      guesses: list[list[int]],\n      k: int,\n  ) -> int:\n    ans = 0\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    guessGraph = [set() for _ in range(n)]\n    parent = [0] * n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u, v in guesses:\n      guessGraph[u].add(v)\n\n    def dfs(u: int, prev: int) -> None:\n      parent[u] = prev\n      for v in graph[u]:\n        if v != prev:\n          dfs(v, u)\n\n    # Precalculate `parent`.\n    dfs(0, -1)\n\n    # Calculate `correctGuess` for tree rooted at 0.\n    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))\n\n    def reroot(u: int, prev: int, correctGuess: int) -> None:\n      nonlocal ans\n      if u != 0:\n        # The tree is rooted at u, so a guess edge (u, prev) will match the new\n        # `parent` relationship.\n        if prev in guessGraph[u]:\n          correctGuess += 1\n        # A guess edge (prev, u) matching the old `parent` relationship will no\n        # longer be True.\n        if u in guessGraph[prev]:\n          correctGuess -= 1\n      if correctGuess >= k:\n        ans += 1\n      for v in graph[u]:\n        if v != prev:\n          reroot(v, u, correctGuess)\n\n    reroot(0, -1, correctGuess)\n    return ans",
      "title": "2581. Count Number of Possible Root Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5cc0df4-f07b-4b6c-8566-27d1f9b1923b",
      "code": "class Solution:\n  def passThePillow(self, n: int, time: int) -> int:\n    # Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2\n    if time < n:  # Go forward from 1.\n      return 1 + time\n    return n - (time - (n - 1))  # Go backward from n.",
      "title": "2582. Pass the Pillow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb5a684d-2465-4dbc-9740-761b7ace4bb2",
      "code": "class Solution:\n  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    if len(levelSums) < k:\n      return -1\n\n    return sorted(levelSums, reverse=True)[k - 1]",
      "title": "2583. Kth Largest Sum in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e61e904a-f55f-40a1-8e2e-9862612c3550",
      "code": "class Solution:\n  def findValidSplit(self, nums: list[int]) -> int:\n    leftPrimeFactors = collections.Counter()\n    rightPrimeFactors = collections.Counter()\n\n    def getPrimeFactors(num: int) -> list[int]:\n      \"\"\"Gets the prime factors under sqrt(10^6).\"\"\"\n      primeFactors = []\n      for divisor in range(2, min(1000, num) + 1):\n        if num % divisor == 0:\n          primeFactors.append(divisor)\n          while num % divisor == 0:\n            num //= divisor\n      # Handle the case that `num` contains a prime factor > 1000.\n      if num > 1:\n        primeFactors.append(num)\n      return primeFactors\n\n    for num in nums:\n      for primeFactor in getPrimeFactors(num):\n        rightPrimeFactors[primeFactor] += 1\n\n    for i in range(len(nums) - 1):\n      for primeFactor in getPrimeFactors(nums[i]):\n        rightPrimeFactors[primeFactor] -= 1\n        if rightPrimeFactors[primeFactor] == 0:\n          # rightPrimeFactors[primeFactor] == 0, so no need to track\n          # leftPrimeFactors[primeFactor].\n          del rightPrimeFactors[primeFactor]\n          del leftPrimeFactors[primeFactor]\n        else:\n          # Otherwise, need to track leftPrimeFactors[primeFactor].\n          leftPrimeFactors[primeFactor] += 1\n      if not leftPrimeFactors:\n        return i\n\n    return -1",
      "title": "2584. Split the Array to Make Coprime Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ed69af8-2bfe-4f2c-b6c6-640cd513d416",
      "code": "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of ways to earn j points with the first i types\n    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, len(types) + 1):\n      count = types[i - 1][0]\n      mark = types[i - 1][1]\n      for j in range(target + 1):\n        for solved in range(count + 1):\n          if j - solved * mark >= 0:\n            dp[i][j] += dp[i - 1][j - solved * mark]\n            dp[i][j] %= MOD\n\n    return dp[len(types)][target]",
      "title": "2585. Number of Ways to Earn Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ebb7810-e116-44b0-9b2a-06db6ddf61ae",
      "code": "class Solution:\n  def vowelStrings(self, words: list[str], left: int, right: int) -> int:\n    VOWELS = 'aeiou'\n    return sum(word[0] in VOWELS and word[-1] in VOWELS\n               for word in words[left:right + 1])",
      "title": "2586. Count the Number of Vowel Strings in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e68eb2f5-86aa-46e6-a55b-74b52a2f9ff6",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    return sum(num > 0\n               for num in itertools.accumulate(sorted(nums, reverse=True)))",
      "title": "2587. Rearrange Array to Maximize Prefix Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb17b6dd-b570-4c3e-8eaf-a482f6a02afc",
      "code": "class Solution:\n  def beautifulSubarrays(self, nums: list[int]) -> int:\n    # A subarray is beautiful if xor(subarray) = 0.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix ^= num\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2588. Count the Number of Beautiful Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ee8202a-8116-4f45-98e1-ab45cbc30485",
      "code": "class Solution:\n  def findMinimumTime(self, tasks: list[list[int]]) -> int:\n    MAX = 2000\n    running = [False] * (MAX + 1)\n\n    # Sort tasks by end.\n    for start, end, duration in sorted(tasks, key=lambda x: x[1]):\n      neededDuration = (duration -\n                        sum(running[i] for i in range(start, end + 1)))\n      # Greedily run the task as late as possible so that later tasks can run\n      # simultaneously.\n      i = end\n      while neededDuration > 0:\n        if not running[i]:\n          running[i] = True\n          neededDuration -= 1\n        i -= 1\n\n    return sum(running)",
      "title": "2589. Minimum Time to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b936b14-bf57-4a5a-9a52-5eaff6d7d8fc",
      "code": "class Solution:\n  def distMoney(self, money: int, children: int) -> int:\n    # Everyone must receive at least 1 dollar.\n    money -= children\n    if money < 0:\n      return -1\n\n    count7 = money // 7\n    remaining = money % 7\n\n    # Distribute 8 dollars to every child.\n    if count7 == children and remaining == 0:\n      return count7\n\n    # Need to move 1 dollar from the last child with 4 dollars to one of other\n    # children. That's why we need to substract 1.\n    if count7 == children - 1 and remaining == 3:\n      return count7 - 1\n\n    # Though there might be child with 4 dollars, since count7 < children - 1,\n    # we have 'extra' spot to move money to if needed.\n    return min(children - 1, count7)",
      "title": "2591. Distribute Money to Maximum Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "250b4b5e-f255-40f3-8cb0-14330cf7816c",
      "code": "class Solution:\n  def maximizeGreatness(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for num in nums:\n      if num > nums[ans]:\n        ans += 1\n\n    return ans",
      "title": "2592. Maximize Greatness of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51f438ec-485a-4480-80fe-e9e1eb4a3413",
      "code": "class Solution:\n  def findScore(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n\n    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):\n      if i in seen:\n        continue\n      seen.add(i - 1)\n      seen.add(i + 1)\n      seen.add(i)\n      ans += num\n\n    return ans",
      "title": "2593. Find Score of an Array After Marking All Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b2bac49-0e75-4188-998d-2290506bff83",
      "code": "class Solution:\n  def repairCars(self, ranks: list[int], cars: int) -> int:\n    def numCarsFixed(minutes: int) -> int:\n      #    r * n^2 = minutes\n      # -> n = sqrt(minutes / r)\n      return sum(math.isqrt(minutes // rank) for rank in ranks)\n\n    return bisect.bisect_left(range(min(ranks) * cars**2), cars,\n                              key=numCarsFixed)",
      "title": "2594. Minimum Time to Repair Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d3e6528-4601-4cbd-9618-dfc71d8c3981",
      "code": "class Solution:\n  def evenOddBit(self, n: int) -> list[int]:\n    ans = [0] * 2\n    i = 0  # 0 := even, 1 := odd\n\n    while n > 0:\n      ans[i] += n & 1\n      n >>= 1\n      i ^= 1\n\n    return ans",
      "title": "2595. Number of Even and Odd Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcd2bae2-ceae-489d-aaa2-1e9f01304b3b",
      "code": "class Solution:\n  def checkValidGrid(self, grid: list[list[int]]) -> bool:\n    if grid[0][0] != 0:\n      return False\n\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    n = len(grid)\n    i = 0\n    j = 0\n\n    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:\n      \"\"\"\n      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n      \"\"\"\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x >= n or y < 0 or y >= n:\n          continue\n        if grid[x][y] == target:\n          return (x, y)\n      return (-1, -1)\n\n    for target in range(1, n * n):\n      x, y = nextGrid(i, j, target)\n      if x == -1 and y == -1:\n        return False\n      # Move (x, y) to (i, j).\n      i = x\n      j = y\n\n    return True",
      "title": "2596. Check Knight Tour Configuration",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9db2e3a8-ee08-4485-87c8-769b0f5d20a2",
      "code": "# e.g. nums = [2, 3, 4, 4], k = 2\n#\n# subset[0] = [2, 4, 4']\n# subset[1] = [1]\n# count = {2: 1, 4: 2, 1: 1}\n#\n# Initially, skip = len([]) = 0, pick = len([]) = 0\n#\n# * For values in subset[0]:\n#   After 2:\n#     skip = skip + pick = len([]) = 0\n#     pick = (2^count[2] - 1) * (1 + skip + pick)\n#          = len([[2]]) * len([[]])\n#          = len([[2]]) = 1\n#   After 4:\n#     skip = skip + pick = len([[2]]) = 1\n#     pick = (2^count[4] - 1) * (1 + skip)\n#          = len([[4], [4'], [4, 4']]) * len([[]])\n#          = len([[4], [4'], [4, 4']]) = 3\n#\n# * For values in subset[1]:\n#   After 1:\n#     skip = skip + pick\n#          = len([[2], [4], [4'], [4, 4']]) = 4\n#     pick = (2^count[1] - 1) * (1 + skip + pick)\n#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n#\n# So, ans = skip + pick = 9\n\nclass Solution:\n  def beautifulSubsets(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        nonEmptyCount = 2**count[num] - 1\n        skip, pick = (skip + pick,\n                      nonEmptyCount *\n                      (1 + skip + (0 if num - prevNum == k else pick)))\n        prevNum = num\n\n    return skip + pick",
      "title": "2597. The Number of Beautiful Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "702468eb-1de4-4039-be4b-86cb075fe89a",
      "code": "class Solution:\n  def findSmallestInteger(self, nums: list[int], value: int) -> int:\n    count = collections.Counter([num % value for num in nums])\n\n    for i in range(len(nums)):\n      if count[i % value] == 0:\n        return i\n      count[i % value] -= 1\n\n    return len(nums)",
      "title": "2598. Smallest Missing Non-negative Integer After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2632ae65-f30b-4c80-9138-b5887b6aedba",
      "code": "class Solution:\n  def makePrefSumNonNegative(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    minHeap = []\n\n    for num in nums:\n      prefix += num\n      if num < 0:\n        heapq.heappush(minHeap, num)\n      while prefix < 0:\n        prefix -= heapq.heappop(minHeap)\n        ans += 1\n\n    return ans",
      "title": "2599. Make the Prefix Sum Non-negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c889116-a11d-44f3-815e-f18ebc0592f3",
      "code": "class Solution:\n  def kItemsWithMaximumSum(\n      self,\n      numOnes: int,\n      numZeros: int,\n      numNegOnes: int,\n      k: int,\n  ) -> int:\n    if k <= numOnes:\n      return k\n    if k <= numOnes + numZeros:\n      return numOnes\n    return numOnes - (k - numOnes - numZeros)",
      "title": "2600. K Items With the Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "275187af-d00f-4d13-8b4c-b46aa0ef7976",
      "code": "class Solution:\n  def primeSubOperation(self, nums: list[int]) -> bool:\n    MAX = 1000\n    primes = self._sieveEratosthenes(MAX)\n\n    prevNum = 0\n    for num in nums:\n      # Make nums[i] the smallest as possible and still > nums[i - 1].\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]",
      "title": "2601. Prime Subtraction Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9f2342e-888f-44bc-bff8-83e86d33328a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    prefix = list(itertools.accumulate(nums, initial=0))\n    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]\n    return [(query * i - prefix[i]) +\n            (prefix[-1] - prefix[i] - query * (n - i))\n            for query, i in splits]",
      "title": "2602. Minimum Operations to Make All Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c1bad77-0042-4a57-afd2-fe61dc884acf",
      "code": "class Solution:\n  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      # Remove the leaves that don't have coins.\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v  # Walk up to its parent.\n      # After trimming leaves without coins, leaves with coins may satisfy\n      # `leavesToBeRemoved`.\n      if len(tree[u]) == 1:  # coins[u] must be 1.\n        leavesToBeRemoved.append(u)\n\n    # Remove each remaining leaf node and its parent. The remaining nodes are\n    # the ones that must be visited.\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:  # It's a leaf.\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)",
      "title": "2603. Collect Coins in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "223a230e-bb15-4792-8c07-8cb3949e44c6",
      "code": "class Solution:\n  def minimumTime(self, hens: list[int], grains: list[int]) -> int:\n    hens.sort()\n    grains.sort()\n\n    def canEat(time: int) -> bool:\n      \"\"\"Returns True if `hens` can eat all `grains` within `time`.\"\"\"\n      i = 0  # grains[i] := next grain to be ate\n      for hen in hens:\n        rightMoves = time\n        if grains[i] < hen:\n          # `hen` needs go back to eat `grains[i]`.\n          leftMoves = hen - grains[i]\n          if leftMoves > time:\n            return False\n          leftThenRight = time - 2 * leftMoves\n          rightThenLeft = (time - leftMoves) // 2\n          rightMoves = max(0, leftThenRight, rightThenLeft)\n        i = bisect.bisect_right(grains, hen + rightMoves)\n        if i == len(grains):\n          return True\n      return False\n\n    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))\n    return bisect.bisect_left(range(maxMoves), True, key=canEat)",
      "title": "2604. Minimum Time to Eat All Grains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fc71859-ab90-4dfa-a91d-19adb6b9a838",
      "code": "class Solution:\n  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(a if a == b else min(a, b) * 10 + max(a, b)\n               for a in nums1\n               for b in nums2)",
      "title": "2605. Form Smallest Number From Two Digit Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ef367af-00ce-4cbc-a8d0-adc73287839d",
      "code": "class Solution:\n  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:\n    ans = 0\n    cost = 0\n    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i\n\n    for c, val in zip(chars, vals):\n      costs[ord(c) - ord('a')] = val\n\n    for c in s:\n      cost = max(0, cost + costs[ord(c) - ord('a')])\n      ans = max(ans, cost)\n\n    return ans",
      "title": "2606. Find the Substring With Maximum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7429ce28-82d1-4fe6-8c00-4ffadfccb8ee",
      "code": "class Solution:\n  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:\n    # If the sum of each subarray of length k is equal, then `arr` must have a\n    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    # arr[(i + k) % n] for every i.\n    n = len(arr)\n    ans = 0\n    seen = [0] * n\n\n    for i in range(n):\n      groups = []\n      j = i\n      while not seen[j]:\n        groups.append(arr[j])\n        seen[j] = True\n        j = (j + k) % n\n      groups.sort()\n      for num in groups:\n        ans += abs(num - groups[len(groups) // 2])\n\n    return ans",
      "title": "2607. Make K-Subarray Sums Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf1af48-0c49-4693-8779-58a466e2c234",
      "code": "class Solution:\n  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:\n    INF = 1001\n    ans = INF\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(i: int) -> int:\n      \"\"\"Returns the length of the minimum cycle by starting BFS from node `i`.\n\n      Returns `INF` if there's no cycle.\n      \"\"\"\n      dist = [INF] * n\n      q = collections.deque([i])\n      dist[i] = 0\n      while q:\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            q.append(v)\n          elif dist[v] + 1 != dist[u]:   # v is not a parent u.\n            return dist[v] + dist[u] + 1\n      return INF\n\n    ans = min(map(bfs, range(n)))\n    return -1 if ans == INF else ans",
      "title": "2608. Shortest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2606c054-4802-4121-b1f9-56fd81704e5f",
      "code": "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      zeros = 0\n      ones = 0\n      while i < len(s) and s[i] == '0':\n        zeros += 1\n        i += 1\n      while i < len(s) and s[i] == '1':\n        ones += 1\n        i += 1\n      ans = max(ans, min(zeros, ones))\n\n    return ans * 2",
      "title": "2609. Find the Longest Balanced Substring of a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9b59de9-35f2-4d7f-a3ad-759420b5fab7",
      "code": "class Solution:\n  def findMatrix(self, nums: list[int]) -> list[list[int]]:\n    # The number of rows we need equals the maximum frequency.\n    ans = []\n    count = [0] * (len(nums) + 1)\n\n    for num in nums:\n      count[num] += 1\n      # Construct `ans` on demand.\n      if count[num] > len(ans):\n        ans.append([])\n      ans[count[num] - 1].append(num)\n\n    return ans",
      "title": "2610. Convert an Array Into a 2D Array With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ce54156-5c6a-4d6a-9750-d2363ce5bd34",
      "code": "class Solution:\n  def miceAndCheese(\n      self,\n      reward1: list[int],\n      reward2: list[int],\n      k: int,\n  ) -> int:\n    return (sum(reward2) +\n            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))",
      "title": "2611. Mice and Cheese",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc0dd265-2551-4c80-918b-ea3a0044a65c",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minReverseOperations(\n      self,\n      n: int,\n      p: int,\n      banned: list[int],\n      k: int,\n  ) -> list[int]:\n    bannedSet = set(banned)\n    ans = [-1] * n\n    # unseen[i] := the unseen numbers that % 2 == i\n    unseen = [SortedList(), SortedList()]\n\n    for num in range(n):\n      if num != p and num not in bannedSet:\n        unseen[num % 2].add(num)\n\n    # Perform BFS from `p`.\n    q = collections.deque([p])\n    ans[p] = 0\n\n    while q:\n      u = q.popleft()\n      lo = max(u - k + 1, k - 1 - u)\n      hi = min(u + k - 1, n - 1 - (u - (n - k)))\n      # Choose the correct set of numbers.\n      nums = unseen[lo % 2]\n      i = nums.bisect_left(lo)\n      while i < len(nums) and nums[i] <= hi:\n        num = nums[i]\n        ans[num] = ans[u] + 1\n        q.append(num)\n        nums.pop(i)\n\n    return ans",
      "title": "2612. Minimum Reverse Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb019baa-6603-4112-b78c-cd1b27924ab1",
      "code": "class Solution:\n  def diagonalPrime(self, nums: list[list[int]]) -> int:\n    def isPrime(n: int) -> bool:\n      if n <= 1:\n        return False\n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          return False\n      return True\n\n    primes1 = [row[i]\n               for i, row in enumerate(nums) if isPrime(row[i])]\n    primes2 = [row[-1 - i]\n               for i, row in enumerate(nums) if isPrime(row[-1 - i])]\n    return max(max(primes1) if primes1 else 0,\n               max(primes2) if primes2 else 0)",
      "title": "2614. Prime In Diagonal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a857af-3ea6-4995-bbac-030fef36693e",
      "code": "class Solution:\n  def distance(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      n = len(indices)\n      if n == 1:\n        continue\n      sumSoFar = sum(indices)\n      prevIndex = 0\n      for i in range(n):\n        sumSoFar += (i - 1) * (indices[i] - prevIndex)\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)\n        ans[indices[i]] = sumSoFar\n        prevIndex = indices[i]\n\n    return ans",
      "title": "2615. Sum of Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cda93fa7-620d-413a-9e77-9e86c6d2963d",
      "code": "class Solution:\n  def minimizeMax(self, nums: list[int], p: int) -> int:\n    nums.sort()\n\n    def numPairs(maxDiff: int) -> int:\n      \"\"\"\n      Returns the number of pairs that can be obtained if the difference between\n      each pair <= `maxDiff`.\n      \"\"\"\n      pairs = 0\n      i = 1\n      while i < len(nums):\n        # Greedily pair nums[i] with nums[i - 1].\n        if nums[i] - nums[i - 1] <= maxDiff:\n          pairs += 1\n          i += 2\n        else:\n          i += 1\n      return pairs\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), p, key=numPairs)",
      "title": "2616. Minimize the Maximum Difference of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60efba3c-f139-4cad-b0d7-0ecf5d46c260",
      "code": "class Solution:\n  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        skip, pick = (skip + pick,\n                      1 + skip + (0 if num - prevNum == k else pick))\n        prevNum = num\n\n    return 1 + skip + pick",
      "title": "2638. Count the Number of K-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fe6a046-1b39-4852-9639-35e7b9bbe376",
      "code": "class Solution:\n  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:\n    return [max(map(len, map(str, col))) for col in zip(*grid)]",
      "title": "2639. Find the Width of Columns of a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e45d17c-1901-43a5-88f0-4033066c2197",
      "code": "class Solution:\n  def findPrefixScore(self, nums: list[int]) -> list[int]:\n    conver = []\n    mx = 0\n\n    for num in nums:\n      mx = max(mx, num)\n      conver.append(num + mx)\n\n    return itertools.accumulate(conver)",
      "title": "2640. Find the Score of All Prefixes of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e06c970b-da06-4e04-a18d-2e0adf6c1a75",
      "code": "class Solution:\n  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    def replace(\n        root: TreeNode | None,\n        level: int, curr: TreeNode | None,\n    ) -> TreeNode | None:\n      nextLevel = level + 1\n      nextLevelCousinsSum = (\n          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -\n          (root.left.val if root.left else 0) -\n          (root.right.val if root.right else 0))\n      if root.left:\n        curr.left = TreeNode(nextLevelCousinsSum)\n        replace(root.left, level + 1, curr.left)\n      if root.right:\n        curr.right = TreeNode(nextLevelCousinsSum)\n        replace(root.right, level + 1, curr.right)\n      return curr\n\n    dfs(root, 0)\n    return replace(root, 0, TreeNode(0))",
      "title": "2641. Cousins in Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a553da6e-d45f-431b-9dee-1d60b63f328e",
      "code": "class Solution:\n  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:\n    ans = [0, 0]\n\n    for i, row in enumerate(mat):\n      ones = row.count(1)\n      if ones > ans[1]:\n        ans[0] = i\n        ans[1] = ones\n\n    return ans",
      "title": "2643. Row With Maximum Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b50f3c83-0829-42fb-8f3d-14df766ff17b",
      "code": "class Solution:\n  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:\n    ans = -1\n    maxScore = -1\n\n    for divisor in divisors:\n      score = sum([1 for num in nums if num % divisor == 0])\n      if score > maxScore:\n        ans = divisor\n        maxScore = score\n      elif score == maxScore:\n        ans = min(ans, divisor)\n\n    return ans",
      "title": "2644. Find the Maximum Divisibility Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a811d06d-31d9-4cd0-9cfa-5cbac0c96f6c",
      "code": "class Solution:\n  def addMinimum(self, word: str) -> int:\n    letters = ['a', 'b', 'c']\n    ans = 0\n    i = 0\n\n    while i < len(word):\n      for c in letters:\n        if i < len(word) and word[i] == c:\n          i += 1\n        else:\n          ans += 1\n\n    return ans",
      "title": "2645. Minimum Additions to Make Valid String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ef3af7e-21de-45bb-adb8-4da0f90ed64c",
      "code": "class Solution:\n  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],\n                        trips: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # count[i] := the number of times i is traversed\n    count = [0] * n\n\n    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:\n      path.append(u)\n      if u == end:\n        for i in path:\n          count[i] += 1\n        return\n      for v in graph[u]:\n        if v != prev:\n          dfsCount(v, u, end,  path)\n      path.pop()\n\n    for start, end in trips:\n      dfsCount(start, -1, end, [])\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, parentHalved: bool) -> int:\n      \"\"\"\n      Returns the minimum price sum for the i-th node, where its parent is\n      halved parent or not halved not.\n      \"\"\"\n      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)\n                                                  for v in graph[u]\n                                                  if v != prev)\n      if parentHalved:  # Can't halve this node if its parent was halved.\n        return sumWithFullNode\n      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)\n                                                           for v in graph[u]\n                                                           if v != prev)\n      return min(sumWithFullNode, sumWithHalvedNode)\n\n    return dfs(0, -1, False)",
      "title": "2646. Minimize the Total Price of the Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92144dc0-a331-4ea0-a385-d9cd7e456986",
      "code": "class Solution:\n  def colorRed(self, n: int) -> list[list[int]]:\n    ans = []\n    tipSize = n % 4\n\n    # The tip of the triangle is always painted red.\n    if tipSize >= 1:\n      ans.append([1, 1])\n\n    # Pamost right and most left elements at the following rows.\n    for i in range(2, tipSize + 1):\n      ans.append([i, 1])\n      ans.append([i, 2 * i - 1])\n\n    # Pa4-row chunks.\n    for i in range(tipSize + 1, n, 4):\n      # Fill the first row of the chunk.\n      ans.append([i, 1])\n      # Fill the second row.\n      for j in range(1, i + 1):\n        ans.append([i + 1, 2 * j + 1])\n      # Fill the third row.\n      ans.append([i + 2, 2])\n      # Fill the fourth row.\n      for j in range(i + 2 + 1):\n        ans.append([i + 3, 2 * j + 1])\n\n    return ans",
      "title": "2647. Color the Triangle Red",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcd47106-73b9-41cb-a1b7-d932e2057f71",
      "code": "class Solution:\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n    return (arrivalTime + delayedTime) % 24",
      "title": "2651. Calculate Delayed Arrival Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e9a7888-f46d-45a9-b3db-95cf8af0032c",
      "code": "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    def sumOfMultiples(value: int) -> int:\n      \"\"\"Returns the sum of multiples of value in [1, n].\"\"\"\n      lo = value\n      hi = (n // value) * value\n      count = (hi - lo) // value + 1\n      return (lo + hi) * count // 2\n\n    return (sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n            (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n            sumOfMultiples(105))",
      "title": "2652. Sum Multiples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8acd4cf-89e1-460f-8a7d-f00cbbe0b937",
      "code": "class Solution:\n  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    count = [0] * 50  # count[i] := the frequency of (i + 50)\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: list[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0",
      "title": "2653. Sliding Subarray Beauty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8102674b-f790-4dae-a5b9-3f6b2467b67d",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ones = nums.count(1)\n    if ones > 0:\n      return n - ones\n\n    # the minimum operations to make the shortest subarray with a gcd == 1\n    minOps = math.inf\n\n    for i, g in enumerate(nums):\n      for j in range(i + 1, n):\n        g = math.gcd(g, nums[j])\n        if g == 1:   # gcd(nums[i..j]:== 1\n          minOps = min(minOps, j - i)\n          break\n\n    # After making the shortest subarray with `minOps`, need additional n - 1\n    # operations to make the other numbers to 1.\n    return -1 if minOps == math.inf else minOps + n - 1",
      "title": "2654. Minimum Number of Operations to Make All Array Elements Equal to 1",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bc7f106-f8f2-4409-aae4-dff79c43ac5c",
      "code": "class Solution:\n  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:\n    ans = []\n    start = 0\n\n    for l, r in sorted(ranges):\n      if start < l:\n        ans.append([start, l - 1])\n      if start <= r:\n        start = r + 1\n\n    if start < n:\n      ans.append([start, n - 1])\n\n    return ans",
      "title": "2655. Find Maximal Uncovered Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01bb4ee0-921b-40cb-a444-d47a5db0dc9e",
      "code": "class Solution:\n  def maximizeSum(self, nums: list[int], k: int) -> int:\n    return max(nums) * k + k * (k - 1) // 2",
      "title": "2656. Maximum Sum With Exactly K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e85cf0c-b0eb-4af9-b961-2f95db46d783",
      "code": "class Solution:\n  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n    n = len(A)\n    prefixCommon = 0\n    ans = []\n    count = [0] * (n + 1)\n\n    for a, b in zip(A, B):\n      count[a] += 1\n      if count[a] == 2:\n        prefixCommon += 1\n      count[b] += 1\n      if count[b] == 2:\n        prefixCommon += 1\n      ans.append(prefixCommon)\n\n    return ans",
      "title": "2657. Find the Prefix Common Array of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac4956bf-72f2-4ad8-9dd7-b1f6e291a62b",
      "code": "class Solution:\n  def findMaxFish(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n      caughtFish = grid[i][j]\n      grid[i][j] = 0  # Mark 0 as visited\n      return (caughtFish +\n              dfs(i + 1, j) + dfs(i - 1, j) +\n              dfs(i, j + 1) + dfs(i, j - 1))\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "2658. Maximum Number of Fish in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b0e32b6-8ef7-4791-9abe-e375142c838d",
      "code": "class Solution:\n  def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    nums.sort()\n\n    for i in range(1, n):\n      # On the i-th step we've already removed the i - 1 smallest numbers and\n      # can ignore them. If an element nums[i] has smaller index in origin\n      # array than nums[i - 1], we should rotate the whole left array n - i\n      # times to set nums[i] element on the first position.\n      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:\n        ans += n - i\n\n    return ans",
      "title": "2659. Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd9b8947-dfe5-417f-807b-21475416652c",
      "code": "class Solution:\n  def isWinner(self, player1: list[int], player2: list[int]) -> int:\n    def getScore(player: list[int]) -> int:\n      INVALID = -3\n      score = 0\n      last10 = INVALID\n      for i, p in enumerate(player):\n        score += p if i - last10 > 2 else p * 2\n        if p == 10:\n          last10 = i\n      return score\n\n    score1 = getScore(player1)\n    score2 = getScore(player2)\n    if score1 > score2:\n      return 1\n    if score2 > score1:\n      return 2\n    return 0",
      "title": "2660. Determine the Winner of a Bowling Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d227c82c-40eb-4d0c-a741-93689fffbdb1",
      "code": "class Solution:\n  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    # rows[i] := the number of painted grid in the i-th row\n    rows = [0] * m\n    # cols[j] := the number of painted grid in the j-th column\n    cols = [0] * n\n    # numToRow[num] := the i-th row of `num` in `mat`\n    numToRow = [0] * (m * n + 1)\n    # numToCol[num] := the j-th column of `num` in `mat`\n    numToCol = [0] * (m * n + 1)\n\n    for i, row in enumerate(mat):\n      for j, num in enumerate(row):\n        numToRow[num] = i\n        numToCol[num] = j\n\n    for i, a in enumerate(arr):\n      rows[numToRow[a]] += 1\n      if rows[numToRow[a]] == n:\n        return i\n      cols[numToCol[a]] += 1\n      if cols[numToCol[a]] == m:\n        return i",
      "title": "2661. First Completely Painted Row or Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1042c203-0bee-44a5-b11d-e8e95632819c",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      start: list[int],\n      target: list[int],\n      specialRoads: list[list[int]],\n  ) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(\n      self,\n      specialRoads: list[list[int]],\n      srcX: int,\n      srcY: int,\n      dstX: int,\n      dstY: int,\n  ) -> int:\n    n = len(specialRoads)\n    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)\n    dist = [math.inf] * n\n    minHeap = []  # (d, u), where u := the i-th specialRoads\n\n    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans",
      "title": "2662. Minimum Cost of a Path With Special Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc70234c-d6e7-423f-aeaf-c0f359ac4b11",
      "code": "class Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        # If s[i] is among the first k letters, then change the letters after\n        # s[i] to the smallest ones that don't form any palindrome substring.\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: list[str], i: int) -> bool:\n    \"\"\"Returns True if chars[0..i] contains palindrome.\"\"\"\n    return ((i > 0 and chars[i] == chars[i - 1]) or\n            (i > 1 and chars[i] == chars[i - 2]))\n\n  def _changeSuffix(self, chars: list[str], i: int) -> str:\n    \"\"\"\n    Returns a string, where replacing sb[i..n) with the smallest possible\n    letters don't form any palindrome substring.\n    \"\"\"\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)",
      "title": "2663. Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf3fdd2f-92b3-4b69-8f1f-3f03ec570227",
      "code": "class Solution:\n  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    ans = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, step: int) -> bool:\n      if step == m * n:\n        return True\n      if i < 0 or i >= m or j < 0 or j >= n:\n        return False\n      if ans[i][j] != -1:\n        return False\n      ans[i][j] = step\n      for dx, dy in DIRS:\n        if dfs(i + dx, j + dy, step + 1):\n          return True\n      ans[i][j] = -1\n      return False\n\n    dfs(r, c, 0)\n    return ans",
      "title": "2664. The Knight’s Tour",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c9f224c-707f-4dd2-af47-63ba8924efbc",
      "code": "class Solution:\n  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:\n    MAX = 50\n    ans = []\n    prefixCount = [0] * (MAX + 1)\n    suffixCount = [0] * (MAX + 1)\n    distinctPrefix = 0\n    distinctSuffix = 0\n\n    for num in nums:\n      if suffixCount[num] == 0:\n        distinctSuffix += 1\n      suffixCount[num] += 1\n\n    for num in nums:\n      if prefixCount[num] == 0:\n        distinctPrefix += 1\n      prefixCount[num] += 1\n      if suffixCount[num] == 1:\n        distinctSuffix -= 1\n      suffixCount[num] -= 1\n      ans.append(distinctPrefix - distinctSuffix)\n\n    return ans",
      "title": "2670. Find the Distinct Difference Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a371fe7b-d77f-496d-80b5-bc8e3cbb9651",
      "code": "class Solution:\n  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans",
      "title": "2672. Number of Adjacent Elements With the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3100005-6bd3-4c9a-8a3d-749971601271",
      "code": "class Solution:\n  def minIncrements(self, n: int, cost: list[int]) -> int:\n    ans = 0\n\n    for i in range(n // 2 - 1, -1, -1):\n      l = i * 2 + 1\n      r = i * 2 + 2\n      ans += abs(cost[l] - cost[r])\n      # Record the information in the parent from the children. So, there's need to actually\n      # update the values in the children.\n      cost[i] += max(cost[l], cost[r])\n\n    return ans",
      "title": "2673. Make Costs of Paths Equal in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f33d6a99-fa1f-4503-bba7-e5d4576784bd",
      "code": "class Solution:\n  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:\n    slow = list\n    fast = list\n\n    # Point `slow` to the last node in the first half.\n    while fast.next != list and fast.next.next != list:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Circle back the second half.\n    secondHead = slow.next\n    if fast.next == list:\n      fast.next = secondHead\n    else:\n      fast.next.next = secondHead\n\n    # Circle back the first half.\n    slow.next = list\n\n    return [list, secondHead]",
      "title": "2674. Split a Circular Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1b51078-e2a0-4ba9-a68b-6188aa3a3f85",
      "code": "class Solution:\n  def countSeniors(self, details: list[str]) -> int:\n    return sum(int(detail[11:13]) > 60 for detail in details)",
      "title": "2678. Number of Senior Citizens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "309c994b-ebd2-4e92-a5d2-91c00bf0d2f1",
      "code": "class Solution:\n  def matrixSum(self, nums: list[list[int]]) -> int:\n    for row in nums:\n      row.sort()\n\n    return sum(max(col) for col in zip(*nums))",
      "title": "2679. Sum in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b52400b5-b226-4675-8729-eca84511eca6",
      "code": "class Solution:\n  def maximumOr(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    prefix = [0] * n\n    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    suffix = [0] * n\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] | nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n      suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    # For each num, greedily shift it left by k bits.\n    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))",
      "title": "2680. Maximum OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81e1f067-7009-4cb8-ab3e-e81fcd4a46e8",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    summ = 0\n\n    for num in sorted(nums):\n      ans += (num + summ) * num**2\n      ans %= MOD\n      summ = (summ * 2 + num) % MOD\n\n    return ans",
      "title": "2681. Power of Heroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704c29d5-9650-436e-bb03-b531a910129b",
      "code": "class Solution:\n  def circularGameLosers(self, n: int, k: int) -> list[int]:\n    seen = [False] * n\n    friendIndex = 0\n    turn = 1\n\n    while not seen[friendIndex]:\n      seen[friendIndex] = True\n      friendIndex += turn * k\n      friendIndex %= n\n      turn += 1\n\n    return [friendIndex + 1\n            for friendIndex in range(n)\n            if not seen[friendIndex]]",
      "title": "2682. Find the Losers of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15dd9b0-7f66-4173-8b54-cb3c3b888dba",
      "code": "class Solution:\n  def doesValidArrayExist(self, derived: list[int]) -> bool:\n    return functools.reduce(operator.xor, derived) == 0",
      "title": "2683. Neighboring Bitwise XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3ac34aa-9760-4c8b-b873-68fce5629fb9",
      "code": "class Solution:\n  def maxMoves(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the maximum number of moves you can perform from (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))",
      "title": "2684. Maximum Number of Moves in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8d48bb3-12f1-4b81-b3b9-7d34651bb87c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans",
      "title": "2685. Count the Number of Complete Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd38f99b-fed7-4d87-a768-dfd55ec2ad6f",
      "code": "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    if root.len == 0:\n      return root.val[k - 1]\n    leftLen = (0 if not root.left\n               else max(root.left.len, len(root.left.val)))\n    if leftLen >= k:\n      return self.getKthCharacter(root.left, k)\n    return self.getKthCharacter(root.right, k - leftLen)",
      "title": "2689. Extract Kth Character From The Rope Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "262988f5-db45-4511-a811-c6e33f6a80f9",
      "code": "class Solution:\n  def minLength(self, s: str) -> int:\n    stack = []\n\n    def match(c: str) -> bool:\n      return stack and stack[-1] == c\n\n    for c in s:\n      if c == 'B' and match('A'):\n        stack.pop()\n      elif c == 'D' and match('C'):\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return len(stack)",
      "title": "2696. Minimum String Length After Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4388c8d6-af66-42fd-bdfb-d279b44c47ec",
      "code": "class Solution:\n  def makeSmallestPalindrome(self, s: str) -> str:\n    chars = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      minChar = min(chars[i], chars[j])\n      chars[i] = minChar\n      chars[j] = minChar\n      i += 1\n      j -= 1\n\n    return ''.join(chars)",
      "title": "2697. Lexicographically Smallest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8569342-7262-43b2-891d-3145758cda90",
      "code": "class Solution:\n  def punishmentNumber(self, n: int) -> int:\n    def isPossible(\n            accumulate: int, running: int, numChars: list[str],\n            s: int, target: int) -> bool:\n      \"\"\"\n      Returns True if the sum of any split of `numChars` equals to the target.\n      \"\"\"\n      if s == len(numChars):\n        return target == accumulate + running\n      d = int(numChars[s])\n      return (\n          # Keep growing `running`.\n          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or\n          # Start a new `running`.\n          isPossible(accumulate + running, d, numChars, s + 1, target)\n      )\n\n    return sum(i * i\n               for i in range(1, n + 1)\n               if isPossible(0, 0, str(i * i), 0, i))",
      "title": "2698. Find the Punishment Number of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "759f1ca0-13f1-4cdb-a505-4cd8f8e5db64",
      "code": "class Solution:\n  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:\n    MAX = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      # Change the weights of negative edges to an impossible value.\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = MAX\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        # Change the weights of negative edges to an impossible value.\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = MAX\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]",
      "title": "2699. Modify Graph Edge Weights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e9cfbb8-1441-43e0-a4f7-6f758df7556d",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int, y: int) -> int:\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if it's possible to make all `nums` <= 0 using m operations.\n      \"\"\"\n      # If we want m operations, first decrease all the numbers by y * m. Then\n      # we have m operations to select indices to decrease them by x - y.\n      return sum(max(0, math.ceil((num - y * m) / (x - y)))\n                 for num in nums) <= m\n\n    return bisect.bisect_left(range(max(nums)), True, key=isPossible)",
      "title": "2702. Minimum Operations to Make Numbers Non-positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c53bbd03-f1d3-4d29-bde6-2e3a93efeedd",
      "code": "class Solution:\n  def buyChoco(self, prices: list[int], money: int) -> int:\n    min1 = math.inf\n    min2 = math.inf\n\n    for price in prices:\n      if price <= min1:\n        min2 = min1\n        min1 = price\n      elif price < min2:\n        min2 = price\n\n    minCost = min1 + min2\n    return money if minCost > money else money - minCost",
      "title": "2706. Buy Two Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29554cc1-ae65-4b75-9af3-397887a0ca34",
      "code": "class Solution:\n  # Similar to 139. Word Break\n  def minExtraChar(self, s: str, dictionary: list[str]) -> int:\n    n = len(s)\n    dictionarySet = set(dictionary)\n    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    dp = [0] + [n] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        if s[j:i] in dictionarySet:\n          dp[i] = min(dp[i], dp[j])\n        else:\n          dp[i] = min(dp[i], dp[j] + i - j)\n\n    return dp[n]",
      "title": "2707. Extra Characters in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "227dd3da-8531-4812-8d52-eb9621759449",
      "code": "class Solution:\n  def maxStrength(self, nums: list[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:  # num == 0\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg",
      "title": "2708. Maximum Strength of a Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fef79b5-ab53-4e67-90fc-d57b8c2384e4",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: list[int]) -> bool:\n    n = len(nums)\n    mx = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(mx + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "2709. Greatest Common Divisor Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05d9b4df-12de-4aeb-8a27-02e16533584e",
      "code": "class Solution:\n  def removeTrailingZeros(self, num: str) -> str:\n    return num.rstrip('0')",
      "title": "2710. Remove Trailing Zeros From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6a89ac0-4855-41f1-aa2b-79e6896dc3db",
      "code": "class Solution:\n  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    def fillInDiagonal(i: int, j: int) -> None:\n      topLeft = set()\n      bottomRight = set()\n\n      # Fill in the diagonal from the top-left to the bottom-right.\n      while i < len(grid) and j < len(grid[0]):\n        ans[i][j] = len(topLeft)\n        # Post-addition, so this information can be utilized in subsequent cells.\n        topLeft.add(grid[i][j])\n        i += 1\n        j += 1\n\n      i -= 1\n      j -= 1\n\n      # Fill in the diagonal from the bottom-right to the top-left.\n      while i >= 0 and j >= 0:\n        ans[i][j] = abs(ans[i][j] - len(bottomRight))\n        # Post-addition, so this information can be utilized in subsequent cells.\n        bottomRight.add(grid[i][j])\n        i -= 1\n        j -= 1\n\n    for i in range(m):\n      fillInDiagonal(i, 0)\n\n    for j in range(1, n):\n      fillInDiagonal(0, j)\n\n    return ans",
      "title": "2711. Difference of Number of Distinct Values on Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a00ff24e-465e-4d92-ad52-0eed64e13b11",
      "code": "class Solution:\n  def minimumCost(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(1, n):\n      if s[i] != s[i - 1]:\n        # Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i)\n\n    return ans",
      "title": "2712. Minimum Cost to Make All Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f02b8794-402c-4431-b074-4610c976164b",
      "code": "class Solution:\n  def maxIncreasingCells(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m  # rows[i] := the maximum path length for the i-th row\n    cols = [0] * n  # cols[j] := the maximum path length for the j-th column\n    valToIndices = collections.defaultdict(list)\n    # maxPathLength[i][j] := the maximum path length from mat[i][j]\n    maxPathLength = [[0] * n for _ in range(m)]\n    # Sort all the unique values in the matrix in non-increasing order.\n    decreasingSet = set()\n\n    for i in range(m):\n      for j in range(n):\n        val = mat[i][j]\n        valToIndices[val].append((i, j))\n        decreasingSet.add(val)\n\n    for val in sorted(decreasingSet, reverse=True):\n      for i, j in valToIndices[val]:\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1\n      for i, j in valToIndices[val]:\n        rows[i] = max(rows[i], maxPathLength[i][j])\n        cols[j] = max(cols[j], maxPathLength[i][j])\n\n    return max(max(rows), max(cols))",
      "title": "2713. Maximum Strictly Increasing Cells in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c1f0ffb-f648-4afb-840d-06996ddca0cf",
      "code": "class Solution:\n  # Similar to 787. Cheapest Flights Within K Stops\n  def shortestPathWithHops(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      d: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, s, d, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]\n\n    dist[src][k] = 0\n    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)\n\n    while minHeap:\n      d, u, hops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if dist[u][hops] > d:\n        continue\n      for v, w in graph[u]:\n        # Go from u -> v with w cost.\n        if d + w < dist[v][hops]:\n          dist[v][hops] = d + w\n          heapq.heappush(minHeap, (dist[v][hops], v, hops))\n        # Hop from u -> v with 0 cost.\n        if hops > 0 and d < dist[v][hops - 1]:\n          dist[v][hops - 1] = d\n          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))",
      "title": "2714. Find Shortest Path with K Hops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "471a42dd-b260-4a9b-b73e-612df3ccfe2e",
      "code": "class Solution:\n  def minimizedStringLength(self, s: str) -> int:\n    return len({*s})",
      "title": "2716. Minimize String Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783c173c-3a42-4449-8e09-683b7c41ac8e",
      "code": "class Solution:\n  def semiOrderedPermutation(self, nums: list[int]) -> int:\n    n = len(nums)\n    index1 = nums.index(1)\n    indexN = nums.index(n)\n    return index1 + (n - 1 - indexN) - int(index1 > indexN)",
      "title": "2717. Semi-Ordered Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11b760f5-de02-4598-b81f-9bf0a04c44c6",
      "code": "class Solution:\n  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:\n    ans = 0\n    # seen[0] := row, seen[1] := col\n    seen = [[False] * n for _ in range(2)]\n    # notSet[0] = row, notSet[1] := col\n    notSet = [n] * 2\n\n    # Late queries dominate.\n    for type, index, val in reversed(queries):\n      if not seen[type][index]:\n        ans += val * notSet[type ^ 1]\n        seen[type][index] = True\n        notSet[type] -= 1\n\n    return ans",
      "title": "2718. Sum of Matrix After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87d8aca3-0af5-4463-be66-43759bba2f0e",
      "code": "# Definition for a street.\n# class Street:\n#   def openDoor(self):\n#     pass\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\n#   def moveLeft(self):\n#     pass\n\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    for _ in range(k):\n      if street.isDoorOpen():\n        street.closeDoor()\n      street.moveRight()\n\n    for ans in range(k + 1):\n      if street.isDoorOpen():\n        return ans\n      street.openDoor()\n      street.moveRight()",
      "title": "2728. Count Houses in a Circular Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "912ae7a9-9d75-466d-9533-5114ea7599c3",
      "code": "class Solution:\n  def isFascinating(self, n):\n    s = str(n) + str(2 * n) + str(3 * n)\n    return ''.join(sorted(s)) == '123456789'",
      "title": "2729. Check if The Number is Fascinating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13f6191e-db97-4d3b-a257-c1713dc9f364",
      "code": "class Solution:\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\n    ans = 1\n    prevStart = 0\n    start = 0\n\n    for i in range(1, len(s)):\n      if s[i] == s[i - 1]:\n        if prevStart > 0:\n          start = prevStart\n        prevStart = i\n      ans = max(ans, i - start + 1)\n\n    return ans",
      "title": "2730. Find the Longest Semi-Repetitive Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a4c6473-2ee5-4d2b-9c7e-ba69fad38a54",
      "code": "class Solution:\n  def sumDistance(self, nums: list[int], s: str, d: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    pos = sorted([num - d if c == 'L' else num + d\n                  for num, c in zip(nums, s)])\n\n    for i, p in enumerate(pos):\n      ans = ((ans + i * p - prefix) % MOD + MOD) % MOD\n      prefix = ((prefix + p) % MOD + MOD) % MOD\n\n    return ans",
      "title": "2731. Movement of Robots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5897949-5fb6-4708-a94f-af8127aac80a",
      "code": "class Solution:\n  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:\n    MAX_BIT = 30\n    maskToIndex = {}\n\n    def getMask(row: list[int]) -> int:\n      mask = 0\n      for i, num in enumerate(row):\n        if num == 1:\n          mask |= 1 << i\n      return mask\n\n    for i, row in enumerate(grid):\n      mask = getMask(row)\n      if mask == 0:\n        return [i]\n      for prevMask in range(1, MAX_BIT):\n        if (mask & prevMask) == 0 and prevMask in maskToIndex:\n          return [maskToIndex[prevMask], i]\n      maskToIndex[mask] = i\n\n    return []",
      "title": "2732. Find a Good Subset of the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ba26e32-4557-4cee-9afd-caf4ee38ac30",
      "code": "class Solution:\n  def findNonMinOrMax(self, nums: list[int]) -> int:\n    return -1 if len(nums) < 3 else sorted(nums[:3])[1]",
      "title": "2733. Neither Minimum nor Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b50705b-0a98-4d6c-bd9e-bce196c1e0ae",
      "code": "class Solution:\n  def smallestString(self, s: str) -> str:\n    chars = list(s)\n    n = len(s)\n    i = 0\n\n    while i < n and chars[i] == 'a':\n      i += 1\n    if i == n:\n      chars[-1] = 'z'\n      return ''.join(chars)\n\n    while i < n and s[i] != 'a':\n      chars[i] = chr(ord(chars[i]) - 1)\n      i += 1\n\n    return ''.join(chars)",
      "title": "2734. Lexicographically Smallest String After Substring Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de84a887-7c77-4bcf-b8cc-f020223aa417",
      "code": "class Solution:\n  def minCost(self, nums: list[int], x: int) -> int:\n    n = len(nums)\n    ans = math.inf\n    # minCost[i] := the minimum cost to collect the i-th type\n    minCost = [math.inf] * n\n\n    for rotate in range(n):\n      for i in range(n):\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])\n      ans = min(ans, sum(minCost) + rotate * x)\n\n    return ans",
      "title": "2735. Collecting Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f857506a-e870-45aa-b6a9-354a3f86d3ed",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Pair:\n  x: int\n  y: int\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  minX: int\n  minY: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])\n                                          for i, query in enumerate(queries)],\n                                         key=lambda x: -x.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        # x + y is a better candidate. Given that x is decreasing, the\n        # condition \"x + y >= stack[-1][1]\" suggests that y is relatively\n        # larger, thereby making it a better candidate.\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2736. Maximum Sum Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25daff53-3abb-4ca6-bf33-940e3270411a",
      "code": "class Solution:\n  def minimumDistance(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      marked: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    dist = self._dijkstra(graph, s)\n    ans = min(dist[u] for u in marked)\n    return -1 if ans == math.inf else ans\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2737. Find the Closest Marked Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d230be3-90e9-499b-8be8-26eadc6d3f08",
      "code": "class Solution:\n  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n    # M  M M M M  A  M M M M   A\n    # 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10",
      "title": "2739. Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0eab9925-8338-43b8-b7a7-0526453abc3f",
      "code": "class Solution:\n  def findValueOfPartition(self, nums: list[int]) -> int:\n    return min(b - a for a, b in itertools.pairwise(sorted(nums)))",
      "title": "2740. Find the Value of the Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bd06a37-4db9-43ad-bb95-712cf67c1050",
      "code": "class Solution:\n  def specialPerm(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxMask = 1 << len(nums)\n\n    @functools.lru_cache(None)\n    def dp(prev: int, mask: int) -> int:\n      \"\"\"\n      Returns the number of special permutations, where the previous number is\n      nums[i] and `mask` is the bitmask of the used numbers.\n      \"\"\"\n      if mask == maxMask - 1:\n        return 1\n\n      res = 0\n\n      for i, num in enumerate(nums):\n        if mask >> i & 1:\n          continue\n        if num % nums[prev] == 0 or nums[prev] % num == 0:\n          res += dp(i, mask | 1 << i)\n          res %= MOD\n\n      return res\n\n    return sum(dp(i, 1 << i)\n               for i in range(len(nums))) % MOD",
      "title": "2741. Special Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8182c225-d394-44e5-b3d4-e93e5a54b67f",
      "code": "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    n = len(cost)\n\n    @functools.lru_cache(None)\n    def dp(i: int, walls: int) -> int:\n      \"\"\"Returns the minimum cost to paint j walls by painters[i..n).\"\"\"\n      if walls <= 0:\n        return 0\n      if i == n:\n        return math.inf\n      pick = cost[i] + dp(i + 1, walls - time[i] - 1)\n      skip = dp(i + 1, walls)\n      return min(pick, skip)\n\n    return dp(0, n)",
      "title": "2742. Painting the Walls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eca1065-2b72-450b-b089-d395194bd1d4",
      "code": "class Solution:\n  def numberOfSpecialSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == 2:\n        count[s[l]] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2743. Count Substrings Without Repeating Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1a46844-1336-4d9e-8f00-6435144e6576",
      "code": "class Solution:\n  def maximumNumberOfStringPairs(self, words: list[str]) -> int:\n    ans = 0\n    seen = [False] * (26 * 26)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for word in words:\n      if seen[val(word[1]) * 26 + val(word[0])]:\n        ans += 1\n      seen[val(word[0]) * 26 + val(word[1])] = True\n\n    return ans",
      "title": "2744. Find Maximum Number of String Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "839d6219-0e06-48b3-bbf5-568edd34d907",
      "code": "class Solution:\n  def longestString(self, x: int, y: int, z: int) -> int:\n    # 'AB' can always be easily appended within the string.\n    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'\n    # If x == y, we repeat the pattern 'AABBAABB...AABB'.\n    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'\n    mn = min(x, y)\n    if x == y:\n      return (mn * 2 + z) * 2\n    return (mn * 2 + 1 + z) * 2",
      "title": "2745. Construct the Longest New String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2b36ee8-f444-4ad9-ac40-ddf657b89bc0",
      "code": "class Solution:\n  def minimizeConcatenatedLength(self, words: list[str]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, first: str, last: str) -> int:\n      \"\"\"\n      Returns the minimum concatenated length of the first i words starting with\n      `first` and ending in `last`.\n      \"\"\"\n      if i == len(words):\n        return 0\n      nextFirst = words[i][0]\n      nextLast = words[i][-1]\n      return len(words[i]) + min(\n          # join(words[i - 1], words[i])\n          dp(i + 1, first, nextLast) - (last == nextFirst),\n          # join(words[i], words[i - 1])\n          dp(i + 1, nextFirst, last) - (first == nextLast)\n      )\n\n    return len(words[0]) + dp(1, words[0][0], words[0][-1])",
      "title": "2746. Decremental String Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa0ec134-86c4-45c2-adf3-5756fc92ce58",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(\n      self,\n      n: int,\n      logs: list[list[int]],\n      x: int,\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda x: x[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    # For each query, we care about logs[i..j].\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans",
      "title": "2747. Count Zero Request Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76ba1fdd-58e9-4431-b021-36a46807fd1d",
      "code": "class Solution:\n  def countBeautifulPairs(self, nums: list[int]) -> int:\n    def firstDigit(num: int) -> int:\n      return int(str(num)[0])\n\n    def lastDigit(num: int) -> int:\n      return num % 10\n\n    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1\n               for i, j in itertools.combinations(range(len(nums)), 2))",
      "title": "2748. Number of Beautiful Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8d182f7-3ecb-4aaf-a2f8-7c1180d39cfa",
      "code": "class Solution:\n  def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    # Note that for any number x, we can use \"x's bit count\" operations to make\n    # x equal to 0. Additionally, we can also use x operations to deduct x by\n    # 2^0 (x times), which also results in 0.\n\n    for ops in range(61):\n      target = num1 - ops * num2\n      if target.bit_count() <= ops <= target:\n        return ops\n\n    return -1",
      "title": "2749. Minimum Operations to Make the Integer Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3e66fa9-3672-4ebb-b521-c6ada6e71178",
      "code": "class Solution:\n  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:\n    if 1 not in nums:\n      return 0\n\n    MOD = 1_000_000_007\n    prev = -1  # the previous index of 1\n    ans = 1\n\n    for i, num in enumerate(nums):\n      if num == 1:\n        if prev != -1:\n          ans *= i - prev\n          ans %= MOD\n        prev = i\n\n    return ans",
      "title": "2750. Ways to Split Array Into Good Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd10d4a6-9f25-4065-b0e9-5302a5556fba",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(\n      self,\n      positions: list[int],\n      healths: list[int],\n      directions: str,\n  ) -> list[int]:\n    robots = sorted([Robot(index, position, health, direction)\n                     for index, (position, health, direction) in\n                     enumerate(zip(positions, healths, directions))],\n                    key=lambda x: x.position)\n    stack: list[Robot] = []  # running robots\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      # Collide with robots going right if any.\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:  # stack[-1].health > robot.health\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]",
      "title": "2751. Robot Collisions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0510db85-f8bf-48fe-86ab-9843e292769e",
      "code": "# Definition for a street.\n# class Street:\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    ans = 0\n\n    # Go to the first open door.\n    while not street.isDoorOpen():\n      street.moveRight()\n\n    street.moveRight()\n\n    for count in range(k):\n      # Each time we encounter an open door, there's a possibility that it's the\n      # first open door we intentionally left open.\n      if street.isDoorOpen():\n        ans = count + 1\n        street.closeDoor()\n      street.moveRight()\n\n    return ans",
      "title": "2753. Count Houses in a Circular Street II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c58790-28ce-4d0c-854c-bdf6f09afaa9",
      "code": "class Solution:\n  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:\n    ans = 0\n    dp = 0\n\n    def isOddEven(a: int, b: int) -> bool:\n      return a % 2 != b % 2\n\n    for i, num in enumerate(nums):\n      if num > threshold:\n        dp = 0\n      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):\n        # Increase the size of the subarray.\n        dp += 1\n      else:\n        # Start a new subarray if the start is valid.\n        dp = 1 if num % 2 == 0 else 0\n      ans = max(ans, dp)\n\n    return ans",
      "title": "2760. Longest Even Odd Subarray With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1247b562-c216-49e1-b38f-b3cd3a22a7ca",
      "code": "class Solution:\n  def findPrimePairs(self, n: int) -> list[list[int]]:\n    isPrime = self._sieveEratosthenes(n + 1)\n    return [[i, n - i] for i in range(2, n // 2 + 1)\n            if isPrime[i] and isPrime[n - i]]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n\n\nj",
      "title": "2761. Prime Pairs With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56a333a2-1539-4d13-956c-9cfb528cb077",
      "code": "class Solution:\n  def continuousSubarrays(self, nums: list[int]) -> int:\n    ans = 1  # [nums[0]]\n    left = nums[0] - 2\n    right = nums[0] + 2\n    l = 0\n\n    # nums[l..r] is a valid window.\n    for r in range(1, len(nums)):\n      if left <= nums[r] <= right:\n        left = max(left, nums[r] - 2)\n        right = min(right, nums[r] + 2)\n      else:\n        # nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2\n        right = nums[r] + 2\n        l = r\n        # If we consistently move leftward in each iteration, it implies that\n        # the entire left subarray satisfies the given condition. For every\n        # subarray with l in the range [0, r], the condition is met, preventing\n        # the code from reaching the final \"else\" condition. Instead, it stops\n        # at the \"if\" condition.\n        while nums[r] - 2 <= nums[l] <= nums[r] + 2:\n          left = max(left, nums[l] - 2)\n          right = min(right, nums[l] + 2)\n          l -= 1\n        l += 1\n      # nums[l..r], num[l + 1..r], ..., nums[r]\n      ans += r - l + 1\n\n    return ans",
      "title": "2762. Continuous Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1612290-5b62-44a6-9b3f-d6c5b602411d",
      "code": "class Solution:\n  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  # of determining the number of gaps in each subarray, let's find out how many\n  # subarrays contain each gap.\n  def sumImbalanceNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # Note that to avoid double counting, only `left` needs to check nums[i].\n    # This adjustment ensures that i represents the position of the leftmost\n    # element of nums[i] within the subarray.\n\n    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    left = [0] * n\n    # right[i] := the minimum index r s.t. nums[r] = nums[i]\n    right = [0] * n\n\n    numToIndex = [-1] * (n + 2)\n    for i, num in enumerate(nums):\n      left[i] = max(numToIndex[num], numToIndex[num + 1])\n      numToIndex[num] = i\n\n    numToIndex = [n] * (n + 2)\n    for i in range(n - 1, -1, -1):\n      right[i] = numToIndex[nums[i] + 1]\n      numToIndex[nums[i]] = i\n\n    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    # subarrays satisfying this condition.\n    #\n    # Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    # initially assumed to have a gap. This adjustment is necessary as the\n    # maximum element of every subarray does not have a gap.\n    return sum((i - left[i]) * (right[i] - i)\n               for i in range(n)) - n * (n + 1) // 2",
      "title": "2763. Sum of Imbalance Numbers of All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5967a494-621b-49c9-91e8-1994515e9aee",
      "code": "class Solution:\n  def isPreorder(self, nodes: list[list[int]]) -> bool:\n    stack = []  # Stores `id`s.\n\n    for id, parentId in nodes:\n      if parentId == -1:\n        stack.append(id)\n        continue\n      while stack and stack[-1] != parentId:\n        stack.pop()\n      if not stack:\n        return False\n      stack.append(id)\n\n    return True",
      "title": "2764. is Array a Preorder of Some ‌Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33296f5f-86fb-4eb4-b9de-6751c3b74925",
      "code": "class Solution:\n  def alternatingSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    dp = 1\n\n    for i in range(1, len(nums)):\n      targetDiff = -1 if dp % 2 == 0 else 1\n      # Append nums[i] to the current alternating subarray.\n      if nums[i] - nums[i - 1] == targetDiff:\n        dp += 1\n      # Reset the alternating subarray to nums[i - 1..i].\n      elif nums[i] - nums[i - 1] == 1:\n        dp = 2\n      # Reset the alternating subarray to nums[i].\n      else:\n        dp = 1\n      ans = max(ans, dp)\n\n    return -1 if ans == 1 else ans",
      "title": "2765. Longest Alternating Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6932b6d-cde6-4b2d-a50c-1b93e2aac7bd",
      "code": "class Solution:\n  def relocateMarbles(\n      self,\n      nums: list[int],\n      moveFrom: list[int],\n      moveTo: list[int],\n  ) -> list[int]:\n    numsSet = set(nums)\n\n    for f, t in zip(moveFrom, moveTo):\n      numsSet.remove(f)\n      numsSet.add(t)\n\n    return sorted(numsSet)",
      "title": "2766. Relocate Marbles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6084c6ec-dc9d-4e83-9bf1-57aaa9c3651b",
      "code": "class Solution:\n  def minimumBeautifulSubstrings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of beautiful substrings for the first i chars\n    dp = [0] + [n + 1] * n\n\n    for i in range(1, n + 1):\n      if s[i - 1] == '0':\n        continue\n      num = 0  # the number of s[i - 1..j - 1]\n      for j in range(i, n + 1):\n        num = (num << 1) + int(s[j - 1])\n        if self._isPowerOfFive(num):\n          dp[j] = min(dp[j], dp[i - 1] + 1)\n\n    return -1 if dp[n] == n + 1 else dp[n]\n\n  def _isPowerOfFive(self, num: int) -> bool:\n    while num % 5 == 0:\n      num //= 5\n    return num == 1",
      "title": "2767. Partition String Into Minimum Beautiful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "597d19a3-4e0f-4c77-a2fc-890418e2df59",
      "code": "class Solution:\n  def countBlackBlocks(\n      self,\n      m: int,\n      n: int,\n      coordinates: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * 5\n    # count[i * n + j] := the number of black cells in\n    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    count = collections.Counter()\n\n    for x, y in coordinates:\n      for i in range(x, x + 2):\n        for j in range(y, y + 2):\n          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          # current black cell (x, y).\n          if 0 < i < m and 0 < j < n:\n            count[(i, j)] += 1\n\n    for freq in count.values():\n      ans[freq] += 1\n\n    ans[0] = (m - 1) * (n - 1) - sum(ans)\n    return ans",
      "title": "2768. Number of Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b645090-d9e6-499d-a4fe-0f7c8b712477",
      "code": "class Solution:\n  def theMaximumAchievableX(self, num: int, t: int) -> int:\n    return num + 2 * t",
      "title": "2769. Find the Maximum Achievable Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58e26441-693a-4abb-8699-89d7c0cc0821",
      "code": "class Solution:\n  def maximumJumps(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i] := the maximum number of jumps to reach i from 0\n    dp = [-1] * n\n    dp[0] = 0\n\n    for j in range(1, n):\n      for i in range(j):\n        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:\n          dp[j] = max(dp[j], dp[i] + 1)\n\n    return dp[-1]",
      "title": "2770. Maximum Number of Jumps to Reach the Last Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfde550d-1c6f-4e24-a659-524e077bea0e",
      "code": "class Solution:\n  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 1\n    dp1 = 1  # the longest subarray that ends in nums1[i] so far\n    dp2 = 1  # the longest subarray that ends in nums2[i] so far\n\n    for i in range(1, len(nums1)):\n      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1\n      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1\n      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1\n      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1\n      dp1 = max(dp11, dp21)\n      dp2 = max(dp12, dp22)\n      ans = max(ans, dp1, dp2)\n\n    return ans",
      "title": "2771. Longest Non-decreasing Subarray From Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a54f532-b24a-4cfa-9109-fc54a65e9bd9",
      "code": "class Solution:\n  def checkArray(self, nums: list[int], k: int) -> bool:\n    if k == 1:\n      return True\n\n    needDecrease = 0\n    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if i >= k:\n        needDecrease -= dq.popleft()\n      if nums[i] < needDecrease:\n        return False\n      decreasedNum = nums[i] - needDecrease\n      dq.append(decreasedNum)\n      needDecrease += decreasedNum\n\n    return dq[-1] == 0",
      "title": "2772. Apply Operations to Make All Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e4ad3c2-8e25-4298-a549-d03c959f7622",
      "code": "class Solution:\n  def heightOfTree(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    # a leaf node\n    if root.left and root.left.right == root:\n      return 0\n    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))",
      "title": "2773. Height of Special Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7169e373-35ad-4043-aff7-e043ed27c32e",
      "code": "class Solution:\n  def sumOfSquares(self, nums: list[int]) -> int:\n    return sum(num**2 for i, num in enumerate(nums)\n               if len(nums) % (i + 1) == 0)",
      "title": "2778. Sum of Squares of Special Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "453bda86-01d9-4d4a-875d-ed9aaaef9a23",
      "code": "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r in range(len(nums)):\n      if nums[r] - nums[l] > 2 * k:\n        l += 1\n\n    return r - l + 1",
      "title": "2779. Maximum Beauty of an Array After Applying Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72ad6083-bf89-442f-b498-9aa1bcdaa7c3",
      "code": "class Solution:\n  def minimumIndex(self, nums: list[int]) -> int:\n    count1 = collections.Counter()\n    count2 = collections.Counter(nums)\n\n    for i, num in enumerate(nums):\n      count1[num] = count1[num] + 1\n      count2[num] = count2[num] - 1\n      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:\n        return i\n\n    return -1",
      "title": "2780. Minimum Index of a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9b8f216-3a64-4fe1-bf4b-d9c67302a9e6",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str, l: int, r: int) -> bool:\n    node: TrieNode = self.root\n    for i in range(l, r):\n      if word[i] not in node.children:\n        return False\n      node = node.children[word[i]]\n    return node.isWord\n\n\nclass Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    ans = 0\n    trie = Trie()\n\n    for s in forbidden:\n      trie.insert(s)\n\n    # r is the rightmost index to make word[l..r] a valid substring.\n    r = len(word) - 1\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if trie.search(word, l, end + 1):\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2781. Length of the Longest Valid Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8446f2a-4413-483d-b475-613b1cbaf378",
      "code": "# Definition for a category handler.\n# class CategoryHandler:\n#   def haveSameCategory(self, a: int, b: int) -> bool:\n#     pass\n\nclass Solution:\n  def numberOfCategories(\n      self,\n      n: int,\n      categoryHandler: Optional['CategoryHandler'],\n  ) -> int:\n    ans = 0\n\n    for i in range(n):\n      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):\n        ans += 1\n\n    return ans",
      "title": "2782. Number of Unique Categories",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25ab0470-66da-4c3a-a4c3-8104ac3a81bc",
      "code": "class Solution:\n  def isGood(self, nums: list[int]) -> bool:\n    n = len(nums) - 1\n    count = collections.Counter(nums)\n    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2",
      "title": "2784. Check if Array is Good",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8faec08a-61f7-4733-96e6-7e120cc3b9f8",
      "code": "class Solution:\n  def sortVowels(self, s: str) -> str:\n    VOWELS = 'aeiouAEIOU'\n    ans = []\n    vowels = sorted([c for c in s if c in VOWELS])\n\n    i = 0  # vowels' index\n    for c in s:\n      if c in VOWELS:\n        ans.append(vowels[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "2785. Sort Vowels in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7801ebcd-d5b0-4ea4-b3f7-48b60acddbd2",
      "code": "class Solution:\n  def maxScore(self, nums: list[int], x: int) -> int:\n    # Note that we always need to take nums[0], so the initial definition might\n    # not hold true.\n\n    # dp0 := the maximum score so far with `nums` ending in an even number\n    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)\n    # dp0 := the maximum score so far with `nums` ending in an odd number\n    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)\n\n    for i in range(1, len(nums)):\n      if nums[i] % 2 == 0:\n        dp0 = nums[i] + max(dp0, dp1 - x)\n      else:\n        dp1 = nums[i] + max(dp1, dp0 - x)\n\n    return max(dp0, dp1)",
      "title": "2786. Visit Array Positions to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "155c646e-9495-4844-88aa-b1227524afa7",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to express i\n    dp = [1] + [0] * n\n\n    for a in range(1, n + 1):\n      ax = a**x\n      if ax > n:\n        break\n      for i in range(n, ax - 1, -1):\n        dp[i] += dp[i - ax]\n        dp[i] %= MOD\n\n    return dp[n]",
      "title": "2787. Ways to Express an Integer as Sum of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3c7b057-d63b-4f45-83bf-e02adeda6363",
      "code": "class Solution:\n  def splitWordsBySeparator(\n      self,\n      words: list[str],\n      separator: str,\n  ) -> list[str]:\n    return [splitWord\n            for word in words\n            for splitWord in word.split(separator)\n            if splitWord]",
      "title": "2788. Split Strings by Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8808e9f4-a646-45bf-b089-3c5f361c187b",
      "code": "class Solution:\n  def maxArrayValue(self, nums: list[int]) -> int:\n    ans = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > ans:\n        ans = nums[i]\n      else:\n        ans += nums[i]\n\n    return ans",
      "title": "2789. Largest Element in an Array after Merge Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07839955-fa4b-4613-9811-27a5f012ab92",
      "code": "class Solution:\n  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:\n    ans = 1  # the next target length\n    availableLimits = 0\n\n    for usageLimit in sorted(usageLimits):\n      availableLimits += usageLimit\n      # Can create groups 1, 2, ..., ans.\n      if availableLimits >= ans * (ans + 1) // 2:\n        ans += 1\n\n    return ans - 1",
      "title": "2790. Maximum Number of Groups With Increasing Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "781c2715-8926-4ea5-b955-b07ea5c2886b",
      "code": "class Solution:\n  def countPalindromePaths(self, parent: list[int], s: str) -> int:\n    # A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    # frequency of a letter on the u-v path is equal to the sum of its\n    # frequencies on the root-u and root-v paths substract twice of its\n    # frequency on the root-LCA(u, v) path. Considering only the parity\n    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    # possible to calculate both parts easily using a simple DFS.\n    tree = [[] for _ in parent]\n    maskToCount = collections.Counter({0: 1})\n\n    for i in range(1, len(parent)):\n      tree[parent[i]].append(i)\n\n    # mask := 26 bits that represent the parity of each character in the alphabet\n    # on the path from node 0 to node u\n    def dfs(u: int, mask: int) -> int:\n      res = 0\n      if u > 0:\n        mask ^= 1 << (ord(s[u]) - ord('a'))\n        # Consider any u-v path with 1 bit set.\n        for i in range(26):\n          res += maskToCount[mask ^ (1 << i)]\n        # Consider u-v path with 0 bit set.\n        res += maskToCount[mask ^ 0]\n        maskToCount[mask] += 1\n      for v in tree[u]:\n        res += dfs(v, mask)\n      return res\n\n    return dfs(0, 0)",
      "title": "2791. Count Paths That Can Form a Palindrome in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1acb7990-97aa-4add-8c81-770dd7dc62bd",
      "code": "class Solution:\n  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> list[int]:\n      nonlocal ans\n      if not root:\n        return []\n\n      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]\n      if len(kSmallest) == k and root.val > kSmallest[-1]:\n        ans += 1\n\n      return kSmallest + [root.val]\n\n    dfs(root)\n    return ans",
      "title": "2792. Count Nodes That Are Great Enough",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bfcf984-3c33-49c6-93e3-eb65a4392e9c",
      "code": "class Solution:\n  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:\n    return sum(hour >= target for hour in hours)",
      "title": "2798. Number of Employees Who Met the Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f95343f2-c621-443c-a520-14c7f7814194",
      "code": "class Solution:\n  def countCompleteSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    distinct = len(set(nums))\n    count = collections.Counter()\n\n    l = 0\n    for num in nums:\n      count[num] += 1\n      while len(count) == distinct:\n        count[nums[l]] -= 1\n        if count[nums[l]] == 0:\n          del count[nums[l]]\n        l += 1\n      # Assume nums[r] = num,\n      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l\n\n    return ans",
      "title": "2799. Count Complete Subarrays in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0bfbb39-18bf-4a68-bd11-b34a341dc369",
      "code": "class Solution:\n  def minimumString(self, a: str, b: str, c: str) -> str:\n    def merge(a: str, b: str) -> str:\n      \"\"\"Merges a and b.\"\"\"\n      if a in b:  # a is a substring of b.\n        return b\n      for i in range(len(a)):\n        aSuffix = a[i:]\n        bPrefix = b[:len(aSuffix)]\n        if aSuffix == bPrefix:\n          return a + b[len(bPrefix):]\n      return a + b\n\n    abc = merge(a, merge(b, c))\n    acb = merge(a, merge(c, b))\n    bac = merge(b, merge(a, c))\n    bca = merge(b, merge(c, a))\n    cab = merge(c, merge(a, b))\n    cba = merge(c, merge(b, a))\n    return self._getMin([abc, acb, bac, bca, cab, cba])\n\n  def _getMin(self, words: list[str]) -> str:\n    \"\"\"Returns the lexicographically smallest string.\"\"\"\n\n    def getMin(a: str, b: str) -> str:\n      \"\"\"Returns the lexicographically smaller string.\"\"\"\n      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b\n\n    res = words[0]\n    for i in range(1, len(words)):\n      res = getMin(res, words[i])\n    return res",
      "title": "2800. Shortest String That Contains Three Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "347fadd5-5180-4b82-88e0-5b8c27eb3f99",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: str, high: str) -> int:\n    MOD = 1_000_000_007\n    low = '0' * (len(high) - len(low)) + low\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        prevDigit: int,\n        isLeadingZero: bool,\n        tight1: bool,\n        tight2: bool,\n    ) -> int:\n      \"\"\"\n      Returns the number of valid integers, considering the i-th digit, where\n      `prevDigit` is the previous digit, `tight1` indicates if the current\n      digit is tightly bound for `low`, and `tight2` indicates if the current\n      digit is tightly bound for `high`.\n      \"\"\"\n      if i == len(high):\n        return 1\n\n      res = 0\n      minDigit = int(low[i]) if tight1 else 0\n      maxDigit = int(high[i]) if tight2 else 9\n\n      for d in range(minDigit, maxDigit + 1):\n        nextTight1 = tight1 and (d == minDigit)\n        nextTight2 = tight2 and (d == maxDigit)\n        if isLeadingZero:\n          # Can place any digit in [minDigit, maxDigit].\n          res += dp(i + 1, d, isLeadingZero and d ==\n                    0, nextTight1, nextTight2)\n        elif abs(d - prevDigit) == 1:\n          res += dp(i + 1, d, False, nextTight1, nextTight2)\n        res %= MOD\n\n      return res\n\n    return dp(0, -1, True, True, True)",
      "title": "2801. Count Stepping Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd5f7f8f-d0d0-4e5a-9cdb-a18789e913f6",
      "code": "class Solution:\n  def kthLuckyNumber(self, k: int) -> str:\n    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')",
      "title": "2802. Find The K-th Lucky Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5da9c1f-4399-4a2a-9342-14dc08762fe0",
      "code": "class Solution:\n  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n    return 100 - ((purchaseAmount + 5) // 10) * 10",
      "title": "2806. Account Balance After Rounded Purchase",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbb3237d-efb9-4028-adef-498794176f61",
      "code": "class Solution:\n  def insertGreatestCommonDivisors(\n      self, head: ListNode | None\n  ) -> ListNode | None:\n    curr = head\n    while curr.next:\n      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)\n      curr.next = inserted\n      curr = inserted.next\n    return head",
      "title": "2807. Insert Greatest Common Divisors in Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a0caf0d-9939-433b-a400-474b360e9c95",
      "code": "class Solution:\n  def minimumSeconds(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    def getSeconds(i: int, j: int) -> int:\n      \"\"\"Returns the number of seconds required to make nums[i..j] the same.\"\"\"\n      return (i - j) // 2\n\n    for indices in numToIndices.values():\n      seconds = getSeconds(indices[0] + n, indices[-1])\n      for i in range(1, len(indices)):\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))\n      ans = min(ans, seconds)\n\n    return ans",
      "title": "2808. Minimum Seconds to Equalize a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf884d3a-ad50-463b-9e8d-36ebbfeaddb9",
      "code": "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[i][j] := the maximum reduced value if we do j operations on the first\n    # i numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(1, i + 1):\n        dp[i][j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[i - 1][j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[i - 1][j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[n][op] <= x:\n        return op\n\n    return -1",
      "title": "2809. Minimum Time to Make Array Sum At Most x",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f98ba25-3e0e-48e9-b80b-62d7c4e522cc",
      "code": "class Solution:\n  def finalString(self, s: str) -> str:\n    dq = collections.deque()\n    inversed = False\n\n    for c in s:\n      if c == 'i':\n        inversed = not inversed\n      elif inversed:\n        dq.appendleft(c)\n      else:\n        dq.append(c)\n\n    return ''.join(reversed(dq)) if inversed else ''.join(dq)",
      "title": "2810. Faulty Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a24c3caf-7535-4a68-97f1-4dc1eea54be3",
      "code": "class Solution:\n  def canSplitArray(self, nums: list[int], m: int) -> bool:\n    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))",
      "title": "2811. Check if it is Possible to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b065889-3034-4901-9870-c229f47fd8e5",
      "code": "class Solution:\n  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True,\n                              key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief",
      "title": "2812. Find the Safest Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14a6e8ea-f24b-460c-9332-854f61439738",
      "code": "class Solution:\n  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:\n    ans = 0\n    totalProfit = 0\n    seenCategories = set()\n    decreasingDuplicateProfits = []\n\n    items.sort(reverse=True)\n\n    for i in range(k):\n      profit, category = items[i]\n      totalProfit += profit\n      if category in seenCategories:\n        decreasingDuplicateProfits.append(profit)\n      else:\n        seenCategories.add(category)\n\n    ans = totalProfit + len(seenCategories)**2\n\n    for i in range(k, len(items)):\n      profit, category = items[i]\n      if category not in seenCategories and decreasingDuplicateProfits:\n        # If this is a new category we haven't seen before, it's worth\n        # considering taking it and replacing the one with the least profit\n        # since it will increase the distinct_categories and potentially result\n        # in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.pop()\n        totalProfit += profit\n        seenCategories.add(category)\n        ans = max(ans, totalProfit + len(seenCategories)**2)\n\n    return ans",
      "title": "2813. Maximum Elegance of a K-Length Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3cd1522-f3df-4092-931f-606b1f094e26",
      "code": "class Solution:\n  def minimumSeconds(self, land: list[list[str]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(land)\n    n = len(land[0])\n    floodDist = self._getFloodDist(land)\n    startPos = self._getStartPos(land, 'S')\n\n    q = collections.deque([startPos])\n    seen = {startPos}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] == 'D':\n            return step\n          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n\n  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:\n    m = len(land)\n    n = len(land[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    q = collections.deque()\n    seen = set()\n\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          q.append((i, j))\n          seen.add((i, j))\n\n    d = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        dist[i][j] = d\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] in 'XD' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      d += 1\n\n    return dist\n\n  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == c:\n          return i, j",
      "title": "2814. Minimum Time Takes to Reach Destination Without Drowning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fdb3cf5-f3ae-4bf0-8337-c8bd0204a095",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    ans = 0\n    # maxNum[i] := the maximum num we met so far with the maximum digit i\n    maxNum = [0] * 10\n\n    def getMaxDigit(num: int) -> int:\n      maxDigit = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        num //= 10\n      return maxDigit\n\n    for num in nums:\n      d = getMaxDigit(num)\n      if maxNum[d] > 0:\n        ans = max(ans, num + maxNum[d])\n      maxNum[d] = max(maxNum[d], num)\n\n    return -1 if ans == 0 else ans",
      "title": "2815. Max Pair Sum in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb5cf133-5fed-4fe9-be14-6700a49d8da6",
      "code": "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    def getCarry(node: ListNode | None) -> ListNode | None:\n      val = node.val * 2\n      if node.next:\n        val += getCarry(node.next)\n      node.val = val % 10\n      return val // 10\n\n    if getCarry(head) == 1:\n      return ListNode(1, head)\n    return head",
      "title": "2816. Double a Number Represented as a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dec9c22-8ba3-4978-a584-b9ada9fe55c2",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:\n    ans = math.inf\n    seen = SortedSet()\n\n    for i in range(x, len(nums)):\n      seen.add(nums[i - x])\n      it = seen.bisect_left(nums[i])\n      if it != len(seen):\n        ans = min(ans, seen[it] - nums[i])\n      if it != 0:\n        ans = min(ans, nums[i] - seen[it - 1])\n\n    return ans",
      "title": "2817. Minimum Absolute Difference Between Elements With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c43573b-d129-4fae-935e-b0f40346fc55",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    # left[i] := the next index on the left (if any)\n    #            s.t. primeScores[left[i]] >= primeScores[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. primeScores[right[i]] > primeScores[i]\n    right = [n] * n\n    stack = []\n\n    # Find the next indices on the left where `primeScores` are greater or equal.\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    # Find the next indices on the right where `primeScores` are greater.\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      # be chosen.\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= MOD\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 2 <= i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)",
      "title": "2818. Apply Operations to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e79c82b-7d1c-4dab-b3f3-07918a42893c",
      "code": "class Solution:\n  def minimumRelativeLosses(\n      self,\n      prices: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    prices.sort()\n\n    prefix = list(itertools.accumulate(prices, initial=0))\n\n    for k, m in queries:\n      countFront = self._getCountFront(k, m, prices)\n      countBack = m - countFront\n      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))\n\n    return ans\n\n  def _getCountFront(\n      self,\n      k: int,\n      m: int,\n      prices: list[int],\n  ) -> int:\n    \"\"\"Returns `countFront` for query (k, m).\n\n    Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n    and the last `m - countFront` chocolates is optimal.\n\n    Define loss[i] := the relative loss of picking `prices[i]`.\n    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n       Thus, loss[i] = prices[i] - 0 = prices[i].\n    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n    By observation, we deduce that it is always better to pick from the front\n    or the back since loss[i] is increasing for 1. and is decreasing for 2.\n\n    Assume that picking `left` chocolates from the left and `right = m - left`\n    chocolates from the right is optimal. Therefore, we are selecting\n    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n\n    To determine the optimal `left` in each iteration, we simply compare\n    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,\n    it's worth increasing `left`.\n    \"\"\"\n    n = len(prices)\n    countNoGreaterThanK = bisect.bisect_right(prices, k)\n    l = 0\n    r = min(countNoGreaterThanK, m)\n\n    while l < r:\n      mid = (l + r) // 2\n      right = m - mid\n      # Picking prices[mid] is better than picking prices[n - right].\n      if prices[mid] < 2 * k - prices[n - right]:\n        l = mid + 1\n      else:\n        r = mid\n\n    return l\n\n  def _getRelativeLoss(\n      self,\n      countFront: int,\n      countBack: int,\n      k: int,\n      prefix: list[int],\n  ) -> int:\n    \"\"\"\n    Returns the relative loss of picking `countFront` and `countBack` \n    chocolates.\n    \"\"\"\n    lossFront = prefix[countFront]\n    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])\n    return lossFront + lossBack",
      "title": "2819. Minimum Relative Loss After Buying Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e73d6004-7476-453c-85cb-baf19d61a4db",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], target: int) -> int:\n    return sum(nums[i] + nums[j] < target\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))",
      "title": "2824. Count Pairs Whose Sum is Less than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f76a553-81f5-4a51-b0a5-9754855e2feb",
      "code": "class Solution:\n  def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n    i = 0  # str2's index\n\n    for c in str1:\n      if c == str2[i] or chr(\n              ord('a') + (ord(c) - ord('a') + 1) % 26) == str2[i]:\n        i += 1\n        if i == len(str2):\n          return True\n\n    return False",
      "title": "2825. Make String a Subsequence Using Cyclic Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac789487-d15b-44a4-8267-710baeefec7d",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]\n    dp = [0] * 4\n\n    for num in nums:\n      dp[num] += 1  # Append num to the sequence so far.\n      dp[2] = max(dp[2], dp[1])\n      dp[3] = max(dp[3], dp[2])\n\n    return len(nums) - dp[3]",
      "title": "2826. Sorting Three Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3317fdc-b59b-48fe-aef2-bfbaf1cb6726",
      "code": "class Solution:\n  def isAcronym(self, words: list[str], s: str) -> bool:\n    return (len(words) == len(s) and\n            all(word[0] == c for word, c in zip(words, s)))",
      "title": "2828. Check if a String Is an Acronym of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59afd9be-0ea3-4eb5-a5c1-9c826dfb2854",
      "code": "class Solution:\n  def minimumSum(self, n: int, k: int) -> int:\n    # These are the unique pairs that sum up to k:\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = k // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))",
      "title": "2829. Determine the Minimum Sum of a k-avoiding Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9da7ceb0-18b7-4e58-8600-275a76f5796e",
      "code": "class Solution:\n  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:\n    # dp[i] := the maximum amount of gold of selling the first i houses\n    dp = [0] * (n + 1)\n    endToStartAndGolds = [[] for _ in range(n)]\n\n    for start, end, gold in offers:\n      endToStartAndGolds[end].append((start, gold))\n\n    for end in range(1, n + 1):\n      # Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1]\n      for start, gold in endToStartAndGolds[end - 1]:\n        dp[end] = max(dp[end], dp[start] + gold)\n\n    return dp[n]",
      "title": "2830. Maximize the Profit as the Salesman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad9fe19e-59f5-490a-9b44-8265bca6e2e2",
      "code": "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      if r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans",
      "title": "2831. Find the Longest Equal Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59610475-34e1-4c25-928b-f844ffa25c72",
      "code": "class Solution:\n  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    stack = []  # a decreasing stack\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):\n        index = stack.pop()\n        left = stack[-1] if stack else -1\n        ans[index] = i - left - 1\n      stack.append(i)\n\n    return ans",
      "title": "2832. Maximal Range That Each Element Is Maximum in It",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19d7ef8a-a1c5-4528-9088-c671861449c8",
      "code": "class Solution:\n  def furthestDistanceFromOrigin(self, moves: str) -> int:\n    return abs(moves.count('L') - moves.count('R')) + moves.count('_')",
      "title": "2833. Furthest Point From Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "669f01b8-e0a3-44b7-a5fd-83bbc6d76241",
      "code": "class Solution:\n  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  def minimumPossibleSum(self, n: int, target: int) -> int:\n    # These are the unique pairs that sum up to k (target):\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n    MOD = 1_000_000_007\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = target // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % MOD",
      "title": "2834. Find the Minimum Possible Sum of a Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a78036f-daf7-42c5-baa2-c02676c210cc",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], target: int) -> int:\n    NO_MISSING_BIT = 31\n    maxBit = 31\n    ans = 0\n    minMissingBit = NO_MISSING_BIT\n    # count[i] := the number of occurrences of 2^i\n    count = collections.Counter(int(math.log2(num)) for num in nums)\n\n    for bit in range(maxBit):\n      # Check if `bit` is in the target.\n      if target >> bit & 1:\n        # If there are available bits, use one bit.\n        if count[bit] > 0:\n          count[bit] -= 1\n        else:\n          minMissingBit = min(minMissingBit, bit)\n      # If we previously missed a bit and there are available bits.\n      if minMissingBit != NO_MISSING_BIT and count[bit] > 0:\n        count[bit] -= 1\n        # Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit\n        minMissingBit = NO_MISSING_BIT  # Set it to an the invalid value.\n      # Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] // 2\n\n    # Check if all target bits have been covered, otherwise return -1.\n    return ans if minMissingBit == maxBit else -1",
      "title": "2835. Minimum Operations to Form Subsequence With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ffe6900-1181-4050-850e-b43c05e3c1cf",
      "code": "class Solution:\n  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    # jump[i][j] := the the node you reach after jumping 2^j steps from i\n    jump = [[0] * m for _ in range(n)]\n    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        #   the the node you reach after jumping 2^j steps from i\n        # = the node you reach after jumping 2^(j - 1) steps from i\n        # + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1]\n        #   the sum of the first 2^j nodes you reach when jumping from i\n        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        # + the sum of another 2^(j - 1) nodes you reach\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans",
      "title": "2836. Maximize Value of Function in a Ball Passing Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef7c8ab9-cc3a-4306-a16a-051927eb3d35",
      "code": "class Solution:\n  def maximumCoins(\n      self,\n      heroes: list[int],\n      monsters: list[int],\n      coins: list[int]\n  ) -> list[int]:\n    monsterAndCoins = sorted(list(zip(monsters, coins)))\n    coinsPrefix = list(itertools.accumulate(\n        (coin for _, coin in monsterAndCoins),\n        initial=0))\n    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]\n            for hero in heroes]\n\n  def _firstGreaterEqual(\n      self,\n      monsterAndCoins: list[tuple[int, int]],\n      hero: int,\n  ) -> int:\n    l, r = 0, len(monsterAndCoins)\n    while l < r:\n      m = (l + r) // 2\n      if monsterAndCoins[m][0] > hero:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2838. Maximum Coins Heroes Can Collect",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b8fce3b-fa52-4b42-b713-bf832a924ba8",
      "code": "class Solution:\n  def canBeEqual(self, s1: str, s2: str) -> bool:\n    def swappedStrings(s: str) -> list[str]:\n      chars = list(s)\n      return [chars,\n              ''.join([chars[2], chars[1], chars[0], chars[3]]),\n              ''.join([chars[0], chars[3], chars[2], chars[1]]),\n              ''.join([chars[2], chars[3], chars[0], chars[1]])]\n\n    return any(a == b\n               for a in swappedStrings(s1)\n               for b in swappedStrings(s2))",
      "title": "2839. Check if Strings Can be Made Equal With Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0aeac9a8-1e12-4c63-add8-eac7e6da5711",
      "code": "class Solution:\n  def checkStrings(self, s1: str, s2: str) -> bool:\n    count = [collections.Counter() for _ in range(2)]\n\n    for i, (a, b) in enumerate(zip(s1, s2)):\n      count[i % 2][a] += 1\n      count[i % 2][b] -= 1\n\n    return (all(freq == 0 for freq in count[0].values()) and\n            all(freq == 0 for freq in count[1].values()))",
      "title": "2840. Check if Strings Can be Made Equal With Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35b6776a-9e67-4638-8f42-386cf4aa9a48",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], m: int, k: int) -> int:\n    ans = 0\n    summ = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if i >= k:\n        numToRemove = nums[i - k]\n        summ -= numToRemove\n        count[numToRemove] -= 1\n        if count[numToRemove] == 0:\n          del count[numToRemove]\n      if len(count) >= m:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2841. Maximum Sum of Almost Unique Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1786402a-7c7e-40a9-9555-2b854c72658d",
      "code": "class Solution:\n  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(s)\n    if len(count) < k:\n      return 0\n\n    ans = 1\n    # freqCount := (f(c), # of chars with f(c))\n    freqCount = collections.Counter(count.values())\n\n    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):\n      if numOfChars >= k:\n        ans *= math.comb(numOfChars, k) * pow(fc, k, MOD)\n        return ans % MOD\n      ans *= pow(fc, numOfChars, MOD)\n      ans %= MOD\n      k -= numOfChars",
      "title": "2842. Count K-Subsequences of a String With Maximum Beauty Solved",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f398b66a-baa6-4928-88fe-7d2ba0fe4b73",
      "code": "class Solution:\n  def countSymmetricIntegers(self, low: int, high: int) -> int:\n    def isSymmetricInteger(num: int) -> bool:\n      if num >= 10 and num <= 99:\n        return num // 10 == num % 10\n      if num >= 1000 and num <= 9999:\n        left = num // 100\n        right = num % 100\n        return left // 10 + left % 10 == right // 10 + right % 10\n      return False\n\n    return sum(isSymmetricInteger(num) for num in range(low, high + 1))",
      "title": "2843. Count Symmetric Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90c31977-fe84-4ef8-ab22-ba78dac5296c",
      "code": "class Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':  # '00'\n        return n - i - 2\n      if seenZero and num[i] == '5':  # '50'\n        return n - i - 2\n      if seenFive and num[i] == '2':  # '25'\n        return n - i - 2\n      if seenFive and num[i] == '7':  # '75'\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    return n - 1 if seenZero else n",
      "title": "2844. Minimum Operations to Make a Special Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60d8a916-350f-422a-8d9a-f026958823c2",
      "code": "class Solution:\n  def countInterestingSubarrays(\n      self,\n      nums: list[int],\n      modulo: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      if num % modulo == k:\n        prefix = (prefix + 1) % modulo\n      ans += prefixCount[(prefix - k + modulo) % modulo]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2845. Count of Interesting Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bcb98c0-79c7-4090-a536-601b34d3fe49",
      "code": "class Solution:\n  def minOperationsQueries(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    MAX = 26\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    # jump[i][j] := the 2^j-th ancestor of i\n    jump = [[0] * m for _ in range(n)]\n    # depth[i] := the depth of i\n    depth = [0] * n\n    # count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    count = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    count[0] = [0] * (MAX + 1)\n    self._dfs(graph, 0, -1, jump, depth, count)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getMinOperations(u: int, v: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to make the edge weight\n      equilibrium between (u, v).\n      \"\"\"\n      lca = self._getLCA(u, v, jump, depth)\n      # the number of edges between (u, v).\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      # the maximum frequency of edges between (u, v)\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]\n                    for j in range(1, MAX + 1))\n      return numEdges - maxFreq\n\n    return [getMinOperations(u, v) for u, v in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      count: list[list[int]]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      count[v] = count[u][:]\n      count[v][w] += 1\n      self._dfs(graph, v, u, jump, depth, count)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]",
      "title": "2846. Minimum Edge Weight Equilibrium Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baf81ce6-eb49-46b9-a0f9-73084ccbfe33",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> str:\n    if n <= 9:\n      return str(n)\n\n    ans = []\n\n    for divisor in range(9, 1, -1):\n      while n % divisor == 0:\n        ans.append(str(divisor))\n        n //= divisor\n\n    return '-1' if n > 1 else ''.join(reversed(ans))",
      "title": "2847. Smallest Number With Given Digit Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0daf6bb1-27c5-4b4d-a7e8-a624751c5f17",
      "code": "class Solution:\n  def numberOfPoints(self, nums: list[list[int]]) -> int:\n    MAX = 100\n    ans = 0\n    runningSum = 0\n    count = [0] * (MAX + 2)\n\n    for start, end in nums:\n      count[start] += 1\n      count[end + 1] -= 1\n\n    for i in range(1, MAX + 1):\n      runningSum += count[i]\n      if runningSum > 0:\n        ans += 1\n\n    return ans",
      "title": "2848. Points That Intersect With Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d4e1fd-fdf3-4110-9cd3-2d252881062c",
      "code": "class Solution:\n  def isReachableAtTime(\n      self,\n      sx: int,\n      sy: int,\n      fx: int,\n      fy: int,\n      t: int,\n  ) -> bool:\n    minStep = max(abs(sx - fx), abs(sy - fy))\n    return t != 1 if minStep == 0 else minStep <= t",
      "title": "2849. Determine if a Cell Is Reachable at a Given Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24b75618-e92a-4321-87ae-5d6b35e0f000",
      "code": "class Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) +\n                          self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans",
      "title": "2850. Minimum Moves to Spread Stones Over Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2367c17-7a72-40d2-ba24-d4bf828f6bc8",
      "code": "class Solution:\n  # This dynamic programming table dp[k][i] represents the number of ways to\n  # rearrange the String s after k steps such that it starts with s[i].\n  # A String can be rotated from 1 to n - 1 times. The transition rule is\n  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  # k = 3, the table looks like this:\n  #\n  # -----------------------------------------------------------\n  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  # -----------------------------------------------------------\n  # | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  # | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  # | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  # | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  # -----------------------------------------------------------\n  #\n  # By observation, we have\n  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  #   * dp[k][0] = dp[k][!0] + (-1)^k\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n    # indices in `s` s.t. for each `i` in the returned indices,\n    # `s[i..n) + s[0..i) = t`.\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (pow(n - 1, k, MOD) - negOnePowK) * pow(n, MOD - 2, MOD)\n    dp[0] = dp[1] + negOnePowK\n    return sum(dp[0] if index == 0 else dp[1] for index in indices) % MOD\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "2851. String Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e310fcf-8a8b-4fcc-9415-4f81a1366dc1",
      "code": "class Solution:\n  def sumRemoteness(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    summ = sum(max(0, cell) for row in grid for cell in row)\n    ans = 0\n\n    def dfs(i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (count, componentSum) of the connected component that contains\n      (x, y).\n      \"\"\"\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return (0, 0)\n      if grid[i][j] == -1:\n        return (0, 0)\n\n      count = 1\n      componentSum = grid[i][j]\n      grid[i][j] = -1  # Mark as visited.\n\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        nextCount, nextComponentSum = dfs(x, y)\n        count += nextCount\n        componentSum += nextComponentSum\n\n      return (count, componentSum)\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] > 0:\n          count, componentSum = dfs(i, j)\n          ans += (summ - componentSum) * count\n\n    return ans",
      "title": "2852. Sum of Remoteness of All Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df78bde7-ffab-4b8c-ba78-470a81790dc4",
      "code": "class Solution:\n  def minimumRightShifts(self, nums: list[int]) -> int:\n    count = 0\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      if a > b:\n        count += 1\n        pivot = i\n\n    if count == 0:\n      return 0\n    if count > 1 or nums[-1] > nums[0]:\n      return -1\n    return len(nums) - pivot - 1",
      "title": "2855. Minimum Right Shifts to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9f93555-474e-466a-a891-d35593eae521",
      "code": "class Solution:\n  def minLengthAfterRemovals(self, nums: list[int]) -> int:\n    n = len(nums)\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n\n    # The number with the maximum frequency cancel all the other numbers.\n    if maxFreq <= n / 2:\n      return n % 2\n    # The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq)",
      "title": "2856. Minimum Array Length After Pair Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e79027-3c51-4e14-9439-54a04cff0c63",
      "code": "class Solution:\n  def countPairs(self, coordinates: list[list[int]], k: int) -> int:\n    ans = 0\n\n    for x in range(k + 1):\n      y = k - x\n      count = collections.Counter()\n      for xi, yi in coordinates:\n        ans += count[(xi ^ x, yi ^ y)]\n        count[(xi, yi)] += 1\n\n    return ans",
      "title": "2857. Count Pairs of Points With Distance k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26215d08-ebc2-46e4-8f8c-a3f938ad0d1c",
      "code": "class Solution:\n  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, True))  # 1 means (u -> v)\n      graph[v].append((u, False))  # 0 means (v <- u)\n\n    seen = {0}\n\n    @functools.lru_cache(None)\n    def dp(u: int) -> int:\n      \"\"\"\n      Returns the minimum number of edge reversals so node u can reach every\n      node in its subtree.\n      \"\"\"\n      res = 0\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        res += dp(v) + (0 if isForward else 1)\n      return res\n\n    ans = [0] * n\n    ans[0] = dp(0)\n\n    def dfs(u: int) -> None:\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        ans[v] = ans[u] + (1 if isForward else -1)\n        dfs(v)\n\n    seen = {0}\n    dfs(0)\n    return ans",
      "title": "2858. Minimum Edge Reversals So Every Node Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02b02209-f706-4161-8a08-4889824332b9",
      "code": "class Solution:\n  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if i.bit_count() == k)",
      "title": "2859. Sum of Values at Indices With K Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf97d6d1-62cb-466e-a00a-be96c0e4ef84",
      "code": "class Solution:\n  def countWays(self, nums: list[int]) -> int:\n    return sum(a < i < b\n               for i, (a, b) in  # i := the number of the selected numbers\n               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))",
      "title": "2860. Happy Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "597673e4-c2dd-4546-b6de-0a3c77a4b91a",
      "code": "class Solution:\n  def maxNumberOfAlloys(self, n: int, k: int, budget: int,\n                        composition: list[list[int]], stock: list[int],\n                        costs: list[int]) -> int:\n    l = 1\n    r = 1_000_000_000\n\n    def isPossible(m: int) -> bool:\n      \"\"\"Returns True if it's possible to create `m` alloys by using any machine.\"\"\"\n      # Try all the possible machines.\n      for machine in composition:\n        requiredMoney = 0\n        for j in range(n):\n          requiredUnits = max(0, machine[j] * m - stock[j])\n          requiredMoney += requiredUnits * costs[j]\n        if requiredMoney <= budget:\n          return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "2861. Maximum Number of Alloys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f30e35f9-8b82-44ad-9e2d-e75afcfb11fb",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n    oddPowerToSum = collections.Counter()\n\n    def divideSquares(val: int) -> int:\n      for num in range(2, val + 1):\n        while val % (num * num) == 0:\n          val //= (num * num)\n      return val\n\n    for i, num in enumerate(nums):\n      oddPower = divideSquares(i + 1)\n      oddPowerToSum[oddPower] += num\n      ans = max(ans, oddPowerToSum[oddPower])\n\n    return ans",
      "title": "2862. Maximum Element-Sum of a Complete Subset of Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2796441-7cae-4d3e-b022-07590d59f164",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) - 1, -1, -1):\n      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.\n      # So, no need to append it.\n      if not stack or nums[stack[-1]] > nums[i]:\n        stack.append(i)\n\n    for i, num in enumerate(nums):\n      while stack and num > nums[stack[-1]]:\n        ans = max(ans, stack.pop() - i + 1)\n\n    return ans",
      "title": "2863. Maximum Length of Semi-Decreasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abeda210-e1fc-4519-ad81-fa700d49c3f0",
      "code": "class Solution:\n  def maximumOddBinaryNumber(self, s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'",
      "title": "2864. Maximum Odd Binary Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd487245-4186-498b-b42d-97e35ff77737",
      "code": "class Solution:\n  def maximumSumOfHeights(self, heights: list[int]) -> int:\n    n = len(heights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and heights[stack[-1]] > heights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are heights[j].\n        summ -= abs(j - stack[-1]) * heights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * heights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(heights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - heights[i]\n\n    return max(maxSum)",
      "title": "2865. Beautiful Towers I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16681467-98b3-4b40-b2a0-f58c9b3419d2",
      "code": "class Solution:\n  # Same as 2865. Beautiful Towers I\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)",
      "title": "2866. Beautiful Towers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0551bcbf-6bee-4a56-98c3-0f97226531b6",
      "code": "class Solution:\n  def countPaths(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    isPrime = self._sieveEratosthenes(n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      nonlocal ans\n      countZeroPrimePath = int(not isPrime[u])\n      countOnePrimePath = int(isPrime[u])\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)\n        ans += (countZeroPrimePath * countOnePrimeChildPath +\n                countOnePrimePath * countZeroPrimeChildPath)\n        if isPrime[u]:\n          countOnePrimePath += countZeroPrimeChildPath\n        else:\n          countZeroPrimePath += countZeroPrimeChildPath\n          countOnePrimePath += countOnePrimeChildPath\n\n      return countZeroPrimePath, countOnePrimePath\n\n    dfs(1, -1)\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2867. Count Valid Paths in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa654bdb-5861-4b09-814a-ec1c5ebeacc4",
      "code": "class Solution:\n  def canAliceWin(self, a: list[str], b: list[str]) -> bool:\n    # words[0][i] := the biggest word starting with ('a' + i) for Alice\n    # words[1][i] := the biggest word starting with ('a' + i) for Bob\n    words = [[''] * 26 for _ in range(2)]\n\n    # For each letter, only the biggest word is useful.\n    for word in a:\n      words[0][ord(word[0]) - ord('a')] = word\n\n    for word in b:\n      words[1][ord(word[0]) - ord('a')] = word\n\n    # Find Alice's smallest word.\n    i = 0\n    while not words[0][i]:\n      i += 1\n\n    # 0 := Alice, 1 := Bob\n    # Start with Alice, so it's Bob's turn now.\n    turn = 1\n\n    # Iterate through each letter until we find a winner.\n    while True:\n      # If the current player has a word that having the letter that is greater\n      # than the opponent's word, choose it.\n      if words[turn][i] and words[turn][i] > words[1 - turn][i]:\n        # Choose the current words[turn][i].\n        pass\n      elif words[turn][i + 1]:\n        # Choose the next words[turn][i + 1].\n        i += 1\n      else:\n        # Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1\n      turn = 1 - turn",
      "title": "2868. The Wording Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e46ae66-0375-4537-80e3-464c5ee12986",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    seen = set()\n\n    for i, num in enumerate(reversed(nums)):\n      if num > k:\n        continue\n      seen.add(num)\n      if len(seen) == k:\n        return i + 1",
      "title": "2869. Minimum Operations to Collect Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3519745-13b0-4628-9578-9062d2489643",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    if 1 in count.values():\n      return -1\n    return sum((freq + 2) // 3 for freq in count.values())",
      "title": "2870. Minimum Number of Operations to Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf6d3f72-eb0b-43f6-b005-073fe7a81b17",
      "code": "class Solution:\n  def maxSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n\n    for num in nums:\n      score = num if score == 0 else score & num\n      if score == 0:\n        ans += 1\n\n    return max(1, ans)",
      "title": "2871. Split Array Into Maximum Number of Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3212f6a3-aac8-4c84-9962-8428fda0488e",
      "code": "class Solution:\n  def maxKDivisibleComponents(\n      self,\n      n: int,\n      edges: list[list[int]],\n      values: list[int],\n      k: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      treeSum = values[u]\n\n      for v in graph[u]:\n        if v != prev:\n          treeSum += dfs(v, u)\n\n      if treeSum % k == 0:\n        ans += 1\n      return treeSum\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    dfs(0, -1)\n    return ans",
      "title": "2872. Maximum Number of K-Divisible Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b5475b8-d089-4fbc-b725-6d7354533b7d",
      "code": "class Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2873. Maximum Value of an Ordered Triplet I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00681ab5-4c85-4dd9-8bd9-211fdb2d2dcb",
      "code": "class Solution:\n  # Same as 2873. Maximum Value of an Ordered Triplet I\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2874. Maximum Value of an Ordered Triplet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3603db73-850d-4dab-9718-d0157bfe0eaa",
      "code": "class Solution:\n  def minSizeSubarray(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    n = len(nums)\n    remainingTarget = target % summ\n    repeatLength = (target // summ) * n\n    if remainingTarget == 0:\n      return repeatLength\n\n    suffixPlusPrefixLength = n\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i in range(2 * n):\n      prefix += nums[i % n]\n      if prefix - remainingTarget in prefixToIndex:\n        suffixPlusPrefixLength = min(\n            suffixPlusPrefixLength,\n            i - prefixToIndex[prefix - remainingTarget])\n      prefixToIndex[prefix] = i\n\n    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength",
      "title": "2875. Minimum Size Subarray in Infinite Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5559915a-3e5a-4b91-9af7-56cf59d5585d",
      "code": "class Solution:\n  def countVisitedNodes(self, edges: list[int]) -> list[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    # Push non-cyclic nodes to stack.\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    # Fill the length of cyclic nodes.\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    # Fill the length of non-cyclic nodes.\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(\n      self,\n      edges: list[int],\n      start: int,\n      seen: list[bool],\n      ans: list[int],\n  ) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]",
      "title": "2876. Count Visited Nodes in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40f13fa3-bea2-48a0-97d7-4fe49c522ef6",
      "code": "class Solution:\n  def minArrayLength(self, nums: list[int], k: int) -> int:\n    count = 0\n    prod = -1\n\n    for num in nums:\n      if num == 0:\n        return 1\n      if prod != -1 and prod * num <= k:\n        prod *= num\n      else:\n        prod = num\n        count += 1\n\n    return count",
      "title": "2892. Minimizing Array After Replacing Pairs With Their Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae67f11c-d1df-4661-927f-065d595844d1",
      "code": "class Solution:\n  def differenceOfSums(self, n: int, m: int) -> int:\n    summ = (1 + n) * n // 2\n    num2 = self._getDivisibleSum(n, m)\n    num1 = summ - num2\n    return num1 - num2\n\n  def _getDivisibleSum(self, n: int, m: int) -> int:\n    \"\"\"Returns the sum of all the integers in [1, n] that are divisible by m.\"\"\"\n    last = n // m * m\n    if last == 0:\n      return 0\n    first = m\n    count = (last - first) // m + 1\n    return (first + last) * count // 2",
      "title": "2894. Divisible and Non-divisible Sums Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "230a4e04-edda-4734-85bb-c2964ea62310",
      "code": "class Solution:\n  def minProcessingTime(\n      self,\n      processorTime: list[int],\n      tasks: list[int],\n  ) -> int:\n    return max(time + task\n               for (time, task) in zip(\n                   sorted(processorTime),\n                   sorted(tasks)[:: -4]))",
      "title": "2895. Minimum Processing Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65d10dcf-156c-47c5-b056-f21749d3386e",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    #         dp := the minimum cost to correct diffIndices[i:]\n    #     dpNext := the minimum cost to correct diffIndices[i + 1:]\n    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]\n    dpNext = x / 2\n    dpNextNext = 0\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp = min(dpNext + x / 2,\n               dpNextNext + diffIndices[i + 1] - diffIndices[i])\n      dpNextNext = dpNext\n      dpNext = dp\n\n    return int(dp)",
      "title": "2896. Apply Operations to Make Two Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3769f546-52d4-4c4a-8df7-25c60d68e035",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the minimum cost to correct diffIndices[i..n).\"\"\"\n      if i == len(diffIndices):\n        return 0\n      if i == len(diffIndices) - 1:\n        return x / 2\n      return min(dp(i + 1) + x / 2,\n                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp(0))",
      "title": "2896. Apply Operations to Make Two Strings Equal_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e4a717b-2eec-4118-81a6-2a7d1818f279",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = 0\n    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    # should be moved to\n    minIndices = [0] * MAX_BIT\n    optimalNums = [0] * len(nums)\n\n    for num in nums:\n      for i in range(MAX_BIT):\n        if num >> i & 1:\n          optimalNums[minIndices[i]] |= 1 << i\n          minIndices[i] += 1\n\n    for i in range(k):\n      ans += optimalNums[i]**2\n      ans %= MOD\n\n    return ans",
      "title": "2897. Apply Operations on Array to Maximize Sum of Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "054e9c25-ef32-41e0-9acc-b50dd102766a",
      "code": "class Solution:\n  def maxScore(self, prices: list[int]) -> int:\n    groupIdToSum = collections.defaultdict(int)\n\n    for i, price in enumerate(prices):\n      groupIdToSum[price - i] += price\n\n    return max(groupIdToSum.values())",
      "title": "2898. Maximum Linear Stock Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66f252c7-bd43-4ada-80bf-0a2cd947658a",
      "code": "class Solution:\n  def lastVisitedIntegers(self, words: list[str]) -> list[int]:\n    ans = []\n    nums = []\n    k = 0\n\n    for word in words:\n      if word == 'prev':\n        k += 1\n        ans.append(-1 if k > len(nums) else nums[-k])\n      else:\n        k = 0\n        nums.append(int(word))\n\n    return ans",
      "title": "2899. Last Visited Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42ba49c3-052d-4d39-980a-d7b1b034d0ce",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    groupId = -1\n\n    for word, group in zip(words, groups):\n      if group != groupId:\n        groupId = group\n        ans.append(word)\n\n    return ans",
      "title": "2900. Longest Unequal Adjacent Groups Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3b4cf28-5cc8-4504-bc7f-ddcff9c93007",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    # dp[i] := the length of the longest subsequence ending in `words[i]`\n    dp = [1] * n\n    # prev[i] := the best index of words[i]\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    # Find the last index of the subsequence.\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]",
      "title": "2901. Longest Unequal Adjacent Groups Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "989e3e51-5146-47aa-8882-8d25cc1c4029",
      "code": "class Solution:\n  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of submultisets of `nums` with sum i\n    dp = [1] + [0] * r\n    count = collections.Counter(nums)\n    zeros = count.pop(0, 0)\n\n    for num, freq in count.items():\n      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      stride = dp.copy()\n      for i in range(num, r + 1):\n        stride[i] += stride[i - num]\n      for i in range(r, 0, -1):\n        if i >= num * (freq + 1):\n          # dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = stride[i] - stride[i - num * (freq + 1)]\n        else:\n          dp[i] = stride[i]\n\n    return (zeros + 1) * sum(dp[l:r + 1]) % MOD",
      "title": "2902. Count of Sub-Multisets With Bounded Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d93fd68b-3f44-42c7-b914-c8f90b415f2b",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the\n    # current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the\n    # current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2903. Find Indices With Index and Value Difference I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95a5577b-f3d8-4f2d-80e4-5df40901938c",
      "code": "class Solution:\n  # Same as 76. Minimum Window Substring\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    return \"\" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]",
      "title": "2904. Shortest and Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c720457f-73d9-4961-b0de-427bb1a9c288",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2905. Find Indices With Index and Value Difference II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f3e53de-a560-41d0-8563-cbb1e980dbfd",
      "code": "class Solution:\n  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    MOD = 12345\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [1]\n    suffix = 1\n\n    for row in grid:\n      for num in row:\n        prefix.append(prefix[-1] * num % MOD)\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        ans[i][j] = prefix[i * n + j] * suffix % MOD\n        suffix = suffix * grid[i][j] % MOD\n\n    return ans",
      "title": "2906. Construct Product Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4d552da-e608-4b08-959f-e9a753881889",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2907. Maximum Profitable Triplets With Increasing Prices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca5fa394-93cf-4acd-96ad-14a970adc4ba",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2908. Minimum Sum of Mountain Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d6f7f82-dca2-47d8-9a4c-745560a86cbe",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2909. Minimum Sum of Mountain Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97ec206f-cd1d-440d-846a-5d3262ec0e66",
      "code": "class Solution:\n  def minGroupsForValidAssignment(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    minFreq = min(count.values())\n\n    for groupSize in range(minFreq, 0, -1):\n      numGroups = self.getNumGroups(count, groupSize)\n      if numGroups > 0:\n        return numGroups\n\n    raise ValueError(\"Invalid argument\")\n\n  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:\n    \"\"\"Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.\"\"\"\n    numGroups = 0\n    for freq in count.values():\n      a = freq // (groupSize + 1)\n      b = freq % (groupSize + 1)\n      if b == 0:\n        # Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        # `a + 1` groups.\n        numGroups += a\n      elif groupSize - b <= a:\n        numGroups += a + 1\n      else:\n        return 0\n    return numGroups",
      "title": "2910. Minimum Number of Groups to Create a Valid Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4aa85faf-5d71-4291-a875-6cc70a80b5df",
      "code": "class Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    # factors[i] := factors of i\n    factors = self._getFactors(n)\n    # cost[i][j] := changes to make s[i..j] a semi-palindrome\n    cost = self._getCost(s, n, factors)\n    # dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> list[list[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i, j in itertools.combinations(range(n), 2):\n      length = j - i + 1\n      minCost = length\n      for d in factors[length]:\n        minCost = min(minCost, self._getCostD(s, i, j, d))\n      cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    \"\"\"Returns the cost to make s[i..j] a semi-palindrome of `d`.\"\"\"\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost",
      "title": "2911. Minimum Changes to Make K Semi-palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f871da42-7653-4ee2-9236-93ccc7598b4a",
      "code": "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i][0] := the the number of ways of `source` to `dest` using i steps\n    # dp[i][1] := the the number of ways of `source` to dest's row using i steps\n    # dp[i][2] := the the number of ways of `source` to dest's col using i steps\n    # dp[i][3] := the the number of ways of `source` to others using i steps\n    dp = [[0] * 4 for _ in range(k + 1)]\n    if source == dest:\n      dp[0][0] = 1\n    elif source[0] == dest[0]:\n      dp[0][1] = 1\n    elif source[1] == dest[1]:\n      dp[0][2] = 1\n    else:\n      dp[0][3] = 1\n\n    for i in range(1, k + 1):\n      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD\n      dp[i][1] = (dp[i - 1][0] * (m - 1) +  # -self\n                  dp[i - 1][1] * (m - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][2] = (dp[i - 1][0] * (n - 1) +  # -self\n                  dp[i - 1][2] * (n - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][3] = (dp[i - 1][1] * (n - 1) +  # -self\n                  dp[i - 1][2] * (m - 1) +  # -self\n                  dp[i - 1][3] * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n\n    return dp[k][0]",
      "title": "2912. Number of Ways to Reach Destination in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6a6bee0-42a2-4716-9310-a0a9e23e7215",
      "code": "class Solution:\n  def minChanges(self, s: str) -> int:\n    return sum(a != b for a, b in zip(s[::2], s[1::2]))",
      "title": "2914. Minimum Number of Changes to Make Binary String Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b50154b7-8844-4e33-850e-1a7bbde379e2",
      "code": "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum length of any subsequence of the first i numbers\n    # that sum to j\n    dp = [[-1] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      dp[i][0] = 0\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(1, target + 1):\n        # 1. Skip `num`.\n        if j < num or dp[i - 1][j - num] == -1:\n          dp[i][j] = dp[i - 1][j]\n        # 2. Skip `num` or pick `num`.\n        else:\n          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])\n\n    return dp[n][target]",
      "title": "2915. Length of the Longest Subsequence That Sums to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d5501f5-12c3-45c2-ad82-1d2522cc057b",
      "code": "class Solution:\n  def findKOr(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    return sum(2**i\n               for i in range(MAX_BIT + 1)\n               if sum(num >> i & 1 for num in nums) >= k)",
      "title": "2917. Find the K-or of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "247d6c29-18d7-42a6-9914-a9d625e096df",
      "code": "class Solution:\n  def minSum(self, nums1: list[int], nums2: list[int]) -> int:\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n    zero1 = nums1.count(0)\n    zero2 = nums2.count(0)\n    if zero1 == 0 and sum1 < sum2 + zero2:\n      return -1\n    if zero2 == 0 and sum2 < sum1 + zero1:\n      return -1\n    return max(sum1 + zero1, sum2 + zero2)",
      "title": "2918. Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2c3c337-fb17-465e-907c-33e8f5368071",
      "code": "class Solution:\n  def minIncrementOperations(self, nums: list[int], k: int) -> int:\n    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    prev3 = 0\n    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    prev2 = 0\n    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    prev1 = 0\n\n    for num in nums:\n      dp = min(prev1, prev2, prev3) + max(0, k - num)\n      prev3 = prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return min(prev1, prev2, prev3)",
      "title": "2919. Minimum Increment Operations to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1b5a9c4-1707-4ed4-b4bc-1074f1a538da",
      "code": "class Solution:\n  def maximumPoints(\n      self,\n      edges: list[list[int]],\n      coins: list[int],\n      k: int,\n  ) -> int:\n    MAX_COIN = 10000\n    MAX_HALVED = int(MAX_COIN).bit_length()\n    n = len(coins)\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, halved: int) -> int:\n      # All the children will be 0, so no need to explore.\n      if halved > MAX_HALVED:\n        return 0\n\n      val = coins[u] // (1 << halved)\n      takeAll = val - k\n      takeHalf = math.floor(val / 2)\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        takeAll += dfs(v, u, halved)\n        takeHalf += dfs(v, u, halved + 1)\n\n      return max(takeAll, takeHalf)\n\n    return dfs(0, -1, 0)",
      "title": "2920. Maximum Points After Collecting Coins From All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe4e2bb-5189-43de-aeca-b7aadcf45e6d",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2921. Maximum Profitable Triplets With Increasing Prices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ff849d7-6181-4a49-8cf0-a78d8e41df97",
      "code": "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    inDegrees = [0] * n\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          continue\n        if grid[i][j] == 1:\n          inDegrees[j] += 1\n        else:\n          inDegrees[i] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2923. Find Champion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497d9701-1704-4f99-acfd-56f6674566e7",
      "code": "class Solution:\n  def findChampion(self, n: int, edges: list[list[int]]) -> int:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2924. Find Champion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47db128c-1809-4245-9cbd-9fe2897daa70",
      "code": "class Solution:\n  def maximumScoreAfterOperations(\n      self,\n      edges: list[list[int]],\n      values: list[int],\n  ) -> int:\n    tree = [[] for _ in values]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      if u > 0 and len(tree[u]) == 1:\n        return values[u]\n      childrenSum = sum(dfs(v, u)\n                        for v in tree[u]\n                        if v != prev)\n      return min(childrenSum, values[u])\n\n    return sum(values) - dfs(0, -1)",
      "title": "2925. Maximum Score After Applying Operations on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f05d267-f533-4ccb-ad3a-8651dc303c16",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    \"\"\"Updates the maximum sum of subsequence ending in (i - 1) with `val`.\"\"\"\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    \"\"\"Returns the maximum sum of subsequence ending in (i - 1).\"\"\"\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:\n    # Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    # By observation:\n    #    nums[i] - nums[j] >= i - j\n    # => nums[i] - i >= nums[j] - j\n    # So, if nums[i] - i >= nums[j] - j, where i > j,\n    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    ans = -math.inf\n    tree = FenwickTree(len(nums))\n\n    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):\n      subseqSum = tree.get(i) + nums[i]\n      tree.maximize(i + 1, subseqSum)\n      ans = max(ans, subseqSum)\n\n    return ans",
      "title": "2926. Maximum Balanced Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e90d9dab-500c-4805-b5cf-ce31ebfe8ebb",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2927. Distribute Candies Among Children III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c6f95f0-632d-4df7-9e74-fd255996250e",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2928. Distribute Candies Among Children I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9f34a9e-6b79-4520-b2e4-014ca335a32b",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2929. Distribute Candies Among Children II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bf636a5-d755-47cc-8be2-3a9225cbadda",
      "code": "class Solution:\n  def stringCount(self, n: int) -> int:\n    # There're three invalid conditions:\n    #   a. count('l') == 0\n    #   b. count('e') < 2\n    #   c. count('t') == 0\n    #\n    # By Principle of Inclusion-Exclusion (PIE):\n    #   ans = allCount - a - b - c + ab + ac + bc - abc\n    MOD = 1_000_000_007\n    allCount = pow(26, n, MOD)\n    a = pow(25, n, MOD)\n    b = pow(25, n, MOD)\n    c = pow(25, n, MOD) + n * pow(25, n - 1, MOD)\n    ab = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    ac = pow(24, n, MOD)\n    bc = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    abc = pow(23, n, MOD) + n * pow(23, n - 1, MOD)\n    return (allCount - a - b - c + ab + ac + bc - abc) % MOD",
      "title": "2930. Number of Strings Which Can Be Rearranged to Contain Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9314404-d914-4f7f-ab2f-12667ba4629b",
      "code": "class Solution:\n  def maxSpending(self, values: list[list[int]]) -> int:\n    items = sorted(item for shop in values for item in shop)\n    return sum(item * d for d, item in enumerate(items, 1))",
      "title": "2931. Maximum Spending After Buying Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b6203b7-1f06-4588-89d3-aba43c119c8b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2932. Maximum Strong Pair XOR I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b62ae8f6-a962-4554-aa2c-34a3c83ca7a5",
      "code": "class Solution:\n  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:\n    ans = set()\n\n    access_times.sort()\n\n    for i in range(len(access_times) - 2):\n      name = access_times[i][0]\n      if name in ans:\n        continue\n      if name != access_times[i + 2][0]:\n        continue\n      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:\n        ans.add(name)\n\n    return list(ans)",
      "title": "2933. High-Access Employees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71f8797a-f358-40c4-946f-b6487bbbeda1",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    mn = min(nums1[-1], nums2[-1])\n    mx = max(nums1[-1], nums2[-1])\n    # the number of the minimum operations, where nums1[n - 1] is not swapped\n    # with nums2[n - 1]\n    dp1 = 0\n    # the number of the minimum operations, where nums1[n - 1] is swapped with\n    # nums2[n - 1]\n    dp2 = 0\n\n    for a, b in zip(nums1, nums2):\n      if min(a, b) > mn:\n        return -1\n      if max(a, b) > mx:\n        return -1\n      if a > nums1[-1] or b > nums2[-1]:\n        dp1 += 1\n      if a > nums2[-1] or b > nums1[-1]:\n        dp2 += 1\n\n    return min(dp1, dp2)",
      "title": "2934. Minimum Operations to Maximize Last Elements in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b68cb31e-d0c3-4874-9f0e-e5bd98411598",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Same as 2932. Maximum Strong Pair XOR I\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2935. Maximum Strong Pair XOR II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7764c30-ab07-4935-bec4-8e34c99caf03",
      "code": "# Definition for BigArray.\n# class BigArray:\n#   def at(self, index: long) -> int:\n#     pass\n#   def size(self) -> long:\n#     pass\n\nclass Solution(object):\n  def countBlocks(self, nums: Optional['BigArray']) -> int:\n    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:\n      \"\"\"Returns the number of maximal blocks in nums[l..r].\"\"\"\n      if leftValue == rightValue:\n        return 1\n      if l + 1 == r:\n        return 2\n      m = (l + r) // 2\n      midValue = nums.at(m)\n      return (countBlocks(l, m, leftValue, midValue) +\n              countBlocks(m, r, midValue, rightValue) - 1)\n    # Substract nums[m], which will be counted twice.\n    return countBlocks(0, nums.size() - 1,\n                       nums.at(0), nums.at(nums.size() - 1))",
      "title": "2936. Number of Equal Numbers Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "378b706f-e688-4bc6-b4bf-6bd2749233ce",
      "code": "class Solution:\n  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n    minLength = min(map(len, [s1, s2, s3]))\n    i = 0\n    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:\n      i += 1\n    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3",
      "title": "2937. Make Three Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33592a95-3fac-46af-8460-4e8245e9459f",
      "code": "class Solution:\n  def minimumSteps(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for c in s:\n      if c == '1':\n        ones += 1\n      else:  # Move 1s to the front of the current '0'.\n        ans += ones\n\n    return ans",
      "title": "2938. Separate Black and White Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ecc3279-fa37-4243-b9a4-a1c0e436dee2",
      "code": "class Solution:\n  def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n    MOD = 1_000_000_007\n    for bit in (2**i for i in range(n)):\n      # Pick a bit if it makes min(a, b) larger.\n      if a * b < (a ^ bit) * (b ^ bit):\n        a ^= bit\n        b ^= bit\n    return a * b % MOD",
      "title": "2939. Maximum Xor Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad05a3db-8c85-4405-870d-4ee35393f8b5",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedQuery:\n  queryIndex: int\n  a: int  # Alice's index\n  b: int  # Bob's index\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  # Similar to 2736. Maximum Sum Queries\n  def leftmostBuildingQueries(\n      self,\n      heights: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(queries)\n    # Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    # descending order.\n    stack = []\n\n    # Iterate through queries and heights simultaneously.\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))\n                                    for i, (a, b) in enumerate(queries)],\n                                   key=lambda x: -x.b):\n      if a == b or heights[a] < heights[b]:\n        # 1. Alice and Bob are already in the same index (a == b) or\n        # 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b\n      else:\n        # Now, a < b and heights[a] >= heights[b].\n        # Gradually add heights with an index > b to the monotonic stack.\n        while heightsIndex > b:\n          # heights[heightsIndex] is a better candidate, given that\n          # heightsIndex is smaller than the indices in the stack and\n          # heights[heightsIndex] is larger or equal to the heights mapped in\n          # the stack.\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        # Binary search to find the smallest index j such that j > b and\n        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: list[int], target: int, heights: list[int]):\n    \"\"\"\n    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].\n    \"\"\"\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l",
      "title": "2940. Find Building Where Alice and Bob Can Meet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2033dae-4d43-46c7-84ca-28655d508d66",
      "code": "class Solution:\n  def maxGcdSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # [(startIndex, gcd of subarray starting at startIndex)]\n    startIndexAndGcds = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i, num in enumerate(nums):\n      nextStartIndexAndGcds = []\n      for startIndex, gcd in startIndexAndGcds:\n        nextGcd = math.gcd(gcd, nums[i])\n        if (not nextStartIndexAndGcds or\n                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.\n          nextStartIndexAndGcds.append((startIndex, nextGcd))\n      startIndexAndGcds = nextStartIndexAndGcds\n      startIndexAndGcds.append((i, nums[i]))\n      for startIndex, gcd in startIndexAndGcds:\n        if i - startIndex + 1 >= k:\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)\n\n    return ans",
      "title": "2941. Maximum GCD-Sum of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28e706d1-47b8-490f-841f-c4961aa21d0e",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2944. Minimum Number of Coins for Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc581eed-eeb5-4138-b80a-5654cb931b61",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2944. Minimum Number of Coins for Fruits_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6312a4af-f809-4253-bec2-7f70b54dcb1c",
      "code": "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # bestLeft[i] := the index l s.t. merging nums[l..i) is the\n    # optimal strategy among processing the first i nums\n    bestLeft = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])\n      # When merging nums[l, i), consider the next segment as [i, r).\n      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).\n      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].\n      #            => prefix[r] >= prefix[i] * 2 - prefix[l]\n      # Therefore, we can binary search `prefix` to find the minimum `r`.\n      l = bestLeft[i]\n      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])\n      dp[i] = dp[l] + 1\n      bestLeft[r] = i\n\n    return dp[n]",
      "title": "2945. Find Maximum Non-decreasing Array Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3431af40-0f3b-4ad3-8dfa-bb4a273a699c",
      "code": "class Solution:\n  def areSimilar(self, mat: list[list[int]], k: int) -> bool:\n    n = len(mat[0])\n    for row in mat:\n      for j in range(n):\n        if row[j] != row[(j + k) % n]:\n          return False\n    return True",
      "title": "2946. Matrix Similarity After Cyclic Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c5d2c53-b8ca-4078-91a9-b8ed3c4495b1",
      "code": "class Solution:\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2947. Count Beautiful Substrings I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b58bf38e-43e2-4450-8b7e-594bede38740",
      "code": "class Solution:\n  def lexicographicallySmallestArray(\n      self,\n      nums: list[int],\n      limit: int,\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    # [[(num, index)]], where the difference between in each pair in each\n    # `[(num, index)]` group <= `limit`\n    numAndIndexesGroups: list[list[tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if (not numAndIndexesGroups or\n              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):\n        # Start a new group.\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        # Append to the existing group.\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans",
      "title": "2948. Make Lexicographically Smallest Array by Swapping Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b25d218d-c884-40fd-af78-8ec465ae5dd1",
      "code": "class Solution:\n  # Same as 2947. Count Beautiful Substrings I\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2949. Count Beautiful Substrings II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b25e0aa-b603-4908-ac20-250a0bc43b7e",
      "code": "class Solution:\n  def countDivisibleSubstrings(self, word: str) -> int:\n    # Let f(c) = d, where d = 1, 2, ..., 9.\n    # Rephrase the question to return the number of substrings that satisfy\n    #    f(c1) + f(c2) + ... + f(ck) // k = avg\n    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    ans = 0\n\n    def f(c: str) -> int:\n      return 9 - (ord('z') - ord(c)) // 3\n\n    for avg in range(1, 10):\n      prefix = 0\n      prefixCount = collections.Counter({0: 1})\n      for c in word:\n        prefix += f(c) - avg\n        ans += prefixCount[prefix]\n        prefixCount[prefix] += 1\n\n    return ans",
      "title": "2950. Number of Divisible Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a64475c1-2b34-4afe-88bd-fa4493d15177",
      "code": "class Solution:\n  def findPeaks(self, mountain: list[int]) -> list[int]:\n    return [i for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]]",
      "title": "2951. Find the Peaks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c66657b5-d57e-44af-84d2-b4968de87c37",
      "code": "class Solution:\n  # Same as 330. Patching Array\n  def minimumAddedCoins(self, coins: list[int], target: int) -> int:\n    ans = 0\n    i = 0  # coins' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    coins.sort()\n\n    while miss <= target:\n      if i < len(coins) and coins[i] <= miss:\n        miss += coins[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "2952. Minimum Number of Coins to be Added",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e80b78-451d-49d1-ad97-25e964131a5c",
      "code": "class Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize)\n               for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    \"\"\"\n    Returns the number of complete substrings of `windowSize` of `word`.\n    \"\"\"\n    res = 0\n    countLetters = 0  # the number of letters in the running substring\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        # Start a new substring starting at word[i].\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res",
      "title": "2953. Count Complete Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fd692c2-0dda-4cf9-b35b-74673c47928f",
      "code": "class Solution:\n  def numberOfSequence(self, n: int, sick: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    ans = fact(n - len(sick))  # the number of infected children\n    prevSick = -1\n\n    for i, s in enumerate(sick):\n      # The segment [prevSick + 1, sick - 1] are the current non-infected\n      # children.\n      nonInfected = sick[i] - prevSick - 1\n      prevSick = sick[i]\n      if nonInfected == 0:\n        continue\n      ans *= inv(fact(nonInfected))\n      ans %= MOD\n      if i > 0:\n        # There're two choices per second since the children at the two\n        # endpoints can both be the infect candidates. So, there are\n        # 2^[nonInfected - 1] ways to infect all children in the current\n        # segment.\n        ans *= pow(2, nonInfected - 1, MOD)\n\n    nonInfected = n - sick[-1] - 1\n    return ans * inv(fact(nonInfected)) % MOD",
      "title": "2954. Count the Number of Infection Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb478e30-e869-4372-ae28-e56300c5ac0c",
      "code": "class Solution:\n  def sameEndSubstringCount(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[int]:\n    count = collections.Counter()\n    # counts[i] := the count of s[0..i)\n    counts = [count.copy()]\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n\n    ans = []\n\n    for l, r in queries:\n      sameEndCount = 0\n      for c in string.ascii_lowercase:\n        #   the count of s[0..r] - the count of s[0..l - 1]\n        # = the count of s[l..r]\n        freq = counts[r + 1][c] - counts[l][c]\n        #   C(freq, 2) + freq\n        # = freq * (freq - 1) / 2 + freq\n        # = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) // 2\n      ans.append(sameEndCount)\n\n    return ans",
      "title": "2955. Number of Same-End Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5591871-75e5-4c9b-a0de-6ec810274a57",
      "code": "class Solution:\n  def findIntersectionValues(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n  ) -> list[int]:\n    nums1Set = set(nums1)\n    nums2Set = set(nums2)\n    return [sum(num in nums2Set for num in nums1),\n            sum(num in nums1Set for num in nums2)]",
      "title": "2956. Find Common Elements Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6216997d-a830-4e57-a0c0-c15613883424",
      "code": "class Solution:\n  def removeAlmostEqualCharacters(self, word: str) -> int:\n    ans = 0\n    i = 1\n    while i < len(word):\n      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:\n        ans += 1\n        i += 2\n      else:\n        i += 1\n    return ans",
      "title": "2957. Remove Adjacent Almost-Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "972b2232-402f-4103-b280-345d959af689",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      while count[num] == k + 1:\n        count[nums[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2958. Length of Longest Subarray With at Most K Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6652d448-63ef-4117-8cb2-94f776a719f4",
      "code": "class Solution:\n  def numberOfSets(\n      self,\n      n: int,\n      maxDistance: int,\n      roads: list[list[int]],\n  ) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance\n               for mask in range(1 << n))\n\n  def _floydWarshall(\n      self,\n      n: int,\n      maxDistanceThreshold: int,\n      roads: list[list[int]],\n      mask: int,\n  ) -> list[list[int]]:\n    \"\"\"\n    Returns the maximum distance between any two branches, where the mask\n    represents the selected branches.\n    \"\"\"\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance",
      "title": "2959. Number of Possible Sets of Closing Branches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6b11d92-3ba5-48af-af68-f0ec6b5f2bc1",
      "code": "class Solution:\n  def countTestedDevices(self, batteryPercentages: list[int]) -> int:\n    ans = 0\n\n    for batteryPercentage in batteryPercentages:\n      if batteryPercentage - ans > 0:\n        ans += 1\n\n    return ans",
      "title": "2960. Count Tested Devices After Test Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39a0b689-8f54-4a64-9bfb-2d812c3ea6fa",
      "code": "class Solution:\n  def getGoodIndices(\n      self,\n      variables: list[list[int]],\n      target: int,\n  ) -> list[int]:\n    return [i for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target]",
      "title": "2961. Double Modular Exponentiation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62e812eb-9293-4d15-8db4-bc65e599138a",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    maxNum = max(nums)\n    ans = 0\n    count = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == maxNum:\n        count += 1\n      # Keep the window to include k - 1 times of the maxNummum number.\n      while count == k:\n        if nums[l] == maxNum:\n          count -= 1\n        l += 1\n      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any\n      # subarray nums[i:r+1], where i < l, it will have at least k times of the\n      # maxNummum number, since nums[l - 1] equals the maxNummum number.\n      ans += l\n\n    return ans",
      "title": "2962. Count Subarrays Where Max Element Appears at Least K Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ae4c858-a4d3-4f89-b417-87364d57f980",
      "code": "class Solution:\n  def numberOfGoodPartitions(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    # lastSeen[num] := the index of the last time `num` appeared\n    lastSeen = {}\n\n    for i, num in enumerate(nums):\n      lastSeen[num] = i\n\n    # Track the maximum right index of each running partition by ensuring that\n    # the first and last occurrences of a number fall within the same partition.\n    maxRight = 0\n    for i, num in enumerate(nums):\n      if i > maxRight:\n        # Start a new partition that starts from nums[i].\n        # Each partition doubles the total number of good partitions.\n        ans = ans * 2 % MOD\n      maxRight = max(maxRight, lastSeen[num])\n\n    return ans",
      "title": "2963. Count the Number of Good Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a3934f4-6e93-423d-91b2-56bc20b7fe43",
      "code": "class Solution:\n  # Similar to 1995. Count Special Quadruplets\n  def divisibleTripletCount(self, nums: list[int], d: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.\n      for i in range(j - 1, -1, -1):\n        ans += count[-(nums[i] + nums[j]) % d]\n      count[nums[j] % d] += 1  # j := k\n\n    return ans",
      "title": "2964. Number of Divisible Triplet Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "628551c2-c095-4fd1-8b4b-ff94afbab124",
      "code": "class Solution:\n  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:\n    count = [1] + [0] * len(grid)**2  # padding for 1-indexed\n\n    for row in grid:\n      for num in row:\n        count[num] += 1\n\n    return [count.index(2), count.index(0)]",
      "title": "2965. Find Missing and Repeated Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ace17fe0-acbf-4330-a04d-53dfd010c920",
      "code": "class Solution:\n  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:\n    ans = []\n\n    nums.sort()\n\n    for i in range(2, len(nums), 3):\n      if nums[i] - nums[i - 2] > k:\n        return []\n      ans.append([nums[i - 2], nums[i - 1], nums[i]])\n\n    return ans",
      "title": "2966. Divide Array Into Arrays With Max Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89922194-5984-4812-9e38-f767c4342d73",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    nums.sort()\n    median = nums[len(nums) // 2]\n    nextPalindrome = self._getPalindrome(median, delta=1)\n    prevPalindrome = self._getPalindrome(median, delta=-1)\n    return min(self._cost(nums, nextPalindrome),\n               self._cost(nums, prevPalindrome))\n\n  def _cost(self, nums: list[int], palindrome: int) -> int:\n    \"\"\"Returns the cost to change all the numbers to `palindrome`.\"\"\"\n    return sum(abs(palindrome - num) for num in nums)\n\n  def _getPalindrome(self, num: int, delta: int) -> int:\n    \"\"\"Returns the palindrome `p`, where p = num + a * delta and a > 0.\"\"\"\n    while not self._isPalindrome(num):\n      num += delta\n    return num\n\n  def _isPalindrome(self, num: int) -> int:\n    original = str(num)\n    return original == original[::-1]",
      "title": "2967. Minimum Cost to Make Array Equalindromic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9ab5b8d-3e0e-4953-986e-9b986f0d9395",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = 0\n    cost = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      cost += num - nums[(l + r) // 2]\n      while cost > k:\n        cost -= nums[(l + r + 1) // 2] - nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2968. Apply Operations to Maximize Frequency Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ffba1bb-8e6a-4d9f-86ad-bd50188a9ca9",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2969. Minimum Number of Coins for Fruits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d2a05c4-45fb-48be-a4ff-f0b5d96a919e",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2969. Minimum Number of Coins for Fruits II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53222277-66c9-4183-b0af-6baa1be371c6",
      "code": "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2970. Count the Number of Incremovable Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "576ed139-019d-443e-80eb-b6829f65482d",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    prefix = sum(nums)\n\n    for num in sorted(nums, reverse=True):\n      prefix -= num\n      # Let `num` be the longest side. Check if the sum of all the edges with\n      # length no longer than `num` > `num``.\n      if prefix > num:\n        return prefix + num\n\n    return -1",
      "title": "2971. Find Polygon With the Largest Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b02c9925-2fdc-4746-b356-863a3ef1c6ef",
      "code": "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2972. Count the Number of Incremovable Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f670d941-742d-4f4d-aacc-8e2d1ad76767",
      "code": "class ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res,\n                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans",
      "title": "2973. Find Number of Coins to Place in Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5de9d91-b10c-41a8-913d-cda7755ad95c",
      "code": "class Solution:\n  def numberGame(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    return [nums[i + 1] if i % 2 == 0\n            else nums[i - 1]\n            for i in range(len(nums))]",
      "title": "2974. Minimum Number Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f521ce0-651d-4517-94b5-b4f759068dc4",
      "code": "class Solution:\n  def maximizeSquareArea(\n      self,\n      m: int,\n      n: int,\n      hFences: list[int],\n      vFences: list[int],\n  ) -> int:\n    hFences = sorted(hFences + [1, m])\n    vFences = sorted(vFences + [1, n])\n    hGaps = {hFences[i] - hFences[j]\n             for i in range(len(hFences))\n             for j in range(i)}\n    vGaps = {vFences[i] - vFences[j]\n             for i in range(len(vFences))\n             for j in range(i)}\n    maxGap = next((hGap\n                  for hGap in sorted(hGaps, reverse=True)\n                  if hGap in vGaps), -1)\n    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)",
      "title": "2975. Maximum Square Area by Removing Fences From a Field",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "067edf76-ddf9-49c5-9f41-ee46a0725356",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    ans = 0\n    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans",
      "title": "2976. Minimum Cost to Convert String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7e2394e-67c7-4d5a-8480-f4419f59dca4",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    # dist[u][v] := the minimum distance to change the substring with id u to\n    # the substring with id v\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    # dp[i] := the minimum cost to change the first i letters of `source` into\n    # `target`, leaving the suffix untouched\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    return -1 if dp[len(source)] == math.inf else dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId",
      "title": "2977. Minimum Cost to Convert String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a758a19a-cca6-4a33-bf63-f57b6007f238",
      "code": "class Solution:\n  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n    # https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo",
      "title": "2979. Most Expensive Item That Can Not Be Bought",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "434efce2-24fa-4266-8311-1ce24fb221fa",
      "code": "class Solution:\n  def hasTrailingZeros(self, nums: list[int]) -> bool:\n    return sum(num % 2 == 0 for num in nums) >= 2",
      "title": "2980. Check if Bitwise OR Has Trailing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd204e6-84bf-4303-812b-e95d5442b916",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2981. Find Longest Special Substring That Occurs Thrice I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d1fcb63-46b5-4e17-b031-c11b417f78a1",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2982. Find Longest Special Substring That Occurs Thrice II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01d2cda3-f226-435b-a984-cee7c9dbff84",
      "code": "class Solution:\n  def canMakePalindromeQueries(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    n = len(s)\n    # mirroredDiffs[i] := the number of different letters between the first i\n    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    mirroredDiffs = self._getMirroredDiffs(s)\n    # counts[i] := the count of s[0..i)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: list[int], b: list[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      # Use left-closed, right-open intervals to facilitate the calculation.\n      #   ...... [a, b) ...|... [rb, ra) ......\n      #   .... [rd, rc) .....|..... [c, d) ....\n      b += 1\n      d += 1\n      ra = n - a  # the reflected index of a in s[n / 2..n)\n      rb = n - b  # the reflected index of b in s[n / 2..n)\n      rc = n - c  # the reflected index of c in s[n / 2..n)\n      rd = n - d  # the reflected index of d in s[n / 2..n)\n      # No difference is allowed outside the query ranges.\n      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or\n         (n // 2 > max(b, rc) and\n          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or\n         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or\n         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):\n        ans.append(False)\n      else:\n        # The `count` map of the intersection of [a, b) and [rd, rc) in\n        # s[0..n / 2) must equate to the `count` map of the intersection of\n        # [c, d) and [rb, ra) in s[n / 2..n).\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> list[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> list[list[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts",
      "title": "2983. Palindrome Rearrangement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15274e85-8e36-44bc-a825-023d2518dbcf",
      "code": "class Solution:\n  def selfDivisiblePermutationCount(self, n: int) -> int:\n    def dfs(num: int, used: int) -> int:\n      if num > n:\n        return 1\n\n      count = 0\n      for i in range(1, n + 1):\n        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):\n          count += dfs(num + 1, used | 1 << i)\n\n      return count\n\n    return dfs(1, 0)",
      "title": "2992. Number of Self-Divisible Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d8b8405-c495-4776-8f6f-016dce65be69",
      "code": "class Solution:\n  def missingInteger(self, nums: list[int]) -> int:\n    numsSet = set(nums)\n    ans = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1] + 1:\n        break\n      ans += nums[i]\n\n    while ans in numsSet:\n      ans += 1\n\n    return ans",
      "title": "2996. Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e4d7f6d-04f3-4121-a2e4-39de8678e1fe",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return functools.reduce(operator.xor, nums, k).bit_count()",
      "title": "2997. Minimum Number of Operations to Make Array XOR Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b238ce48-9e45-44c4-9945-ede7b1fa4cd0",
      "code": "class Solution:\n  def minimumOperationsToMakeEqual(self, x, y):\n    if x <= y:\n      return y - x\n\n    queue = collections.deque([x])\n    seen = set()\n\n    ans = 0\n    while queue:\n      for _ in range(len(queue)):\n        num = queue.popleft()\n        if num == y:\n          return ans\n        if num in seen:\n          continue\n        seen.add(num)\n        if num % 11 == 0:\n          queue.append(num // 11)\n        if num % 5 == 0:\n          queue.append(num // 5)\n        queue.append(num - 1)\n        queue.append(num + 1)\n      ans += 1",
      "title": "2998. Minimum Number of Operations to Make X and Y Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02bcb3c1-6284-43f3-9029-0b9c82e357bb",
      "code": "class Solution:\n  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:\n    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))\n    return a * b",
      "title": "3000. Maximum Area of Longest Diagonal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "817103fb-8f07-4450-9576-a2d18e92e59b",
      "code": "class Solution:\n  def minMovesToCaptureTheQueen(\n      self, a: int, b: int, c: int, d: int, e: int, f: int,\n  ) -> int:\n    # The rook is in the same row as the queen.\n    if a == e:\n      # The bishop blocks the rook or not.\n      return 2 if c == a and (b < d < f or b > d > f) else 1\n    # The rook is in the same column as the queen.\n    if b == f:\n      # The bishop blocks the rook or not.\n      return 2 if d == f and (a < c < e or a > c > e) else 1\n    # The bishop is in the same up-diagonal as the queen.\n    if c + d == e + f:\n      # The rook blocks the bishop or not.\n      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1\n    # The bishop is in the same down-diagonal as the queen.\n    if c - d == e - f:\n      # The rook blocks the bishop or not.\n      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1\n    # The rook can always get the green in two steps.\n    return 2",
      "title": "3001. Minimum Moves to Capture The Queen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "859cfeff-dd65-45f4-9b0d-e8b5b7d4c0d3",
      "code": "class Solution:\n  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = set1.intersection(set2)\n\n    n = len(nums1)\n    n1 = len(set1)\n    n2 = len(set2)\n    nc = len(common)\n    maxUniqueNums1 = min(n1 - nc, n // 2)\n    maxUniqueNums2 = min(n2 - nc, n // 2)\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)",
      "title": "3002. Maximum Size of a Set After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebbf579e-d40c-4206-991a-4e3877fc6873",
      "code": "class Solution:\n  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, canChange: bool, mask: int) -> int:\n      \"\"\"\n      Returns the maximum number of partitions of s[i..n), where `canChange` is\n      True if we can still change a letter, and `mask` is the bitmask of the\n      letters we've seen.\n      \"\"\"\n      if i == len(s):\n        return 0\n\n      def getRes(newBit: int, nextCanChange: bool) -> int:\n        newMask = mask | newBit\n        if newMask.bit_count() > k:\n          return 1 + dp(i + 1, nextCanChange, newBit)\n        return dp(i + 1, nextCanChange, newMask)\n\n      # Initialize the result based on the current letter.\n      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)\n\n      # If allowed, explore the option to change the current letter.\n      if canChange:\n        for j in range(26):\n          res = max(res, getRes(1 << j, False))\n      return res\n\n    return dp(0, True, 0) + 1",
      "title": "3003. Maximize the Number of Partitions After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c882392f-e516-41b4-8f85-731f13ea72fa",
      "code": "class Solution:\n  def maximumSubtreeSize(\n      self,\n      edges: list[list[int]],\n      colors: list[int],\n  ) -> int:\n    ans = 1\n    tree = [[] for _ in range(len(colors))]\n\n    for u, v in edges:\n      tree[u].append(v)\n\n    def dfs(u: int) -> int:\n      \"\"\"\n      Returns the size of subtree of u if every node in the subtree has the same\n      color. Otherwise, returns -1.\n      \"\"\"\n      nonlocal ans\n      res = 1\n      for v in tree[u]:\n        if colors[v] != colors[u]:\n          res = -1\n        # If any node in the subtree of v has a different color, the result of\n        # the subtree of u will be -1 as well.\n        subtreeSize = dfs(v)\n        if subtreeSize == -1:\n          res = -1\n        elif res != -1:\n          res += subtreeSize\n      ans = max(ans, res)\n      return res\n\n    dfs(0)\n    return ans",
      "title": "3004. Maximum Subtree of the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a69a94bb-7ad4-4d3c-94c6-c5c2c4ac36eb",
      "code": "class Solution:\n  def maxFrequencyElements(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n    return sum(freq == maxFreq for freq in count.values()) * maxFreq",
      "title": "3005. Count Elements With Maximum Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b2b7e02-73a7-4272-a0d7-6604c9bb2bab",
      "code": "class Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3006. Find Beautiful Indices in the Given Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b8537df-724b-42e8-b23c-85c839d8f8b8",
      "code": "class Solution:\n  def findMaximumNumber(self, k: int, x: int) -> int:\n    def getSumPrices(num: int) -> int:\n      \"\"\"Returns the sum of prices of all numbers from 1 to `num`.\"\"\"\n      sumPrices = 0\n      # Increment `num` to account the 0-th row in the count of groups.\n      num += 1\n      for i in range(num.bit_length(), 0, -1):\n        if i % x == 0:\n          groupSize = 1 << i\n          halfGroupSize = 1 << i - 1\n          sumPrices += num // groupSize * halfGroupSize\n          sumPrices += max(0, (num % groupSize) - halfGroupSize)\n      return sumPrices\n\n    l = 1\n    r = 10**15\n    return bisect.bisect_right(range(l, r + 1), k, key=getSumPrices) - 1 + l",
      "title": "3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5648bf4d-2ee4-4d81-b832-100643a59961",
      "code": "class Solution:\n  # Same as 3006. Find Beautiful Indices in the Given Array I\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = []\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3008. Find Beautiful Indices in the Given Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c101bbf-5384-4ffd-a16a-8ad0b0d502c8",
      "code": "class Solution:\n  def maxIntersectionCount(self, y: list[int]) -> int:\n    ans = 0\n    intersectionCount = 0\n    line = collections.Counter()\n\n    for i, (a, b) in enumerate(itertools.pairwise(y)):\n      start = 2 * a\n      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)\n      line[min(start, end)] += 1\n      line[max(start, end) + 1] -= 1\n\n    for count in sorted(line):\n      intersectionCount += line[count]\n      ans = max(ans, intersectionCount)\n\n    return ans",
      "title": "3009. Maximum Number of Intersections on the Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a763d89-1377-4e7b-a8ae-85dc247f1a59",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    MAX = 50\n    min1 = MAX\n    min2 = MAX\n\n    for i in range(1, len(nums)):\n      if nums[i] < min1:\n        min2 = min1\n        min1 = nums[i]\n      elif nums[i] < min2:\n        min2 = nums[i]\n\n    return nums[0] + min1 + min2",
      "title": "3010. Divide an Array Into Subarrays With Minimum Cost I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4132dde-1342-4d41-933e-26a7524c3738",
      "code": "class Solution:\n  def canSortArray(self, nums: list[int]) -> int:\n    # Divide the array into distinct segments where each segment is comprised\n    # of consecutive elements sharing an equal number of set bits. Ensure that\n    # for each segment, when moving from left to right, the maximum of a\n    # preceding segment is less than the minimum of the following segment.\n    prevSetBits = 0\n    prevMax = -math.inf  # the maximum of the previous segment\n    currMax = -math.inf  # the maximum of the current segment\n    currMin = math.inf   # the minimum of the current segment\n\n    for num in nums:\n      setBits = num.bit_count()\n      if setBits != prevSetBits:  # Start a new segment.\n        if prevMax > currMin:\n          return False\n        prevSetBits = setBits\n        prevMax = currMax\n        currMax = num\n        currMin = num\n      else:  # Continue with the current segment.\n        currMax = max(currMax, num)\n        currMin = min(currMin, num)\n\n    return prevMax <= currMin",
      "title": "3011. Find if Array Can Be Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52c63c0c-6579-4fef-858c-30eb0583b158",
      "code": "class Solution:\n  def minimumArrayLength(self, nums: list[int]) -> int:\n    # Let the minimum number in the array `nums` be x.\n    # * If there exists any element nums[i] where nums[i] % x > 0, a new\n    #   minimum can be generated and all other numbers can be removed.\n    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    #   generated which cannot be removed. Therefore, the result will be\n    #   (frequency of x + 1) / 2.\n    minNum = min(nums)\n    if any(num % minNum > 0 for num in nums):\n      return 1\n    return (nums.count(minNum) + 1) // 2",
      "title": "3012. Minimize Length of Array Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7a233a4-edce-4478-a82e-d14c593bf5cb",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:\n    # Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    windowSum = sum(nums[i] for i in range(1, dist + 2))\n    selected = SortedList(nums[i] for i in range(1, dist + 2))\n    candidates = SortedList()\n\n    def balance() -> int:\n      \"\"\"\n      Returns the updated `windowSum` by balancing the multiset `selected` to\n      keep the top k - 1 numbers.\n      \"\"\"\n      nonlocal windowSum\n      while len(selected) < k - 1:\n        minCandidate = candidates[0]\n        windowSum += minCandidate\n        selected.add(minCandidate)\n        candidates.remove(minCandidate)\n      while len(selected) > k - 1:\n        maxSelected = selected[-1]\n        windowSum -= maxSelected\n        selected.remove(maxSelected)\n        candidates.add(maxSelected)\n      return windowSum\n\n    windowSum = balance()\n    minWindowSum = windowSum\n\n    for i in range(dist + 2, len(nums)):\n      outOfScope = nums[i - dist - 1]\n      if outOfScope in selected:\n        windowSum -= outOfScope\n        selected.remove(outOfScope)\n      else:\n        candidates.remove(outOfScope)\n      if nums[i] < selected[-1]:  # nums[i] is a better number.\n        windowSum += nums[i]\n        selected.add(nums[i])\n      else:\n        candidates.add(nums[i])\n      windowSum = balance()\n      minWindowSum = min(minWindowSum, windowSum)\n\n    return nums[0] + minWindowSum",
      "title": "3013. Divide an Array Into Subarrays With Minimum Cost II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e6adda-51f1-4fbe-ab5f-60499926b0fe",
      "code": "class Solution:\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3014. Minimum Number of Pushes to Type Word I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd17a1d-536f-47ad-a304-63e7742729c7",
      "code": "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3015. Count the Number of Houses at a Certain Distance I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f3040e8-b298-4689-bfc8-59e8702552d9",
      "code": "class Solution:\n  # Same as 3014. Minimum Number of Pushes to Type Word I\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3016. Minimum Number of Pushes to Type Word II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bfd835b-af9a-442d-8886-7a917474d7ed",
      "code": "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3017. Count the Number of Houses at a Certain Distance II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ea441af-5e47-412c-b063-1cb6d65a64e8",
      "code": "class Solution:\n  def maximumProcessableQueries(\n      self,\n      nums: list[int],\n      queries: list[int],\n  ) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    # removed after processing dp[i][j] queries\n    dp = [[0] * n for _ in range(n)]\n\n    for d in range(n - 1, -1, -1):\n      for i in range(n):\n        j = i + d\n        if j >= n:\n          continue\n        if i > 0:\n          # Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] +\n                         (nums[i - 1] >= queries[dp[i - 1][j]]))\n        if j + 1 < n:\n          # Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] +\n                         (nums[j + 1] >= queries[dp[i][j + 1]]))\n        if dp[i][j] == len(queries):\n          return len(queries)\n\n    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])\n               for i in range(n))",
      "title": "3018. Maximum Number of Removal Queries That Can Be Processed I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57c1ccb0-43a6-4524-83ab-5e41576c318e",
      "code": "class Solution:\n  def countKeyChanges(self, s: str) -> int:\n    return sum(a.lower() != b.lower()\n               for a, b in itertools.pairwise(s))",
      "title": "3019. Number of Changing Keys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "074ce26b-37dd-4851-b00c-1e060735dba6",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    count = collections.Counter(nums)\n    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1\n\n    for num in nums:\n      if num == 1:\n        continue\n      length = 0\n      x = num\n      while x <= maxNum and x in count and count[x] >= 2:\n        length += 2\n        x *= x\n      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      # The goal is to determine if we can insert x^k in the middle of the\n      # pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      # and decrease the length by 1.\n      ans = max(ans, length + (1 if x in count else -1))\n\n    return ans",
      "title": "3020. Find the Maximum Number of Elements in Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7050ecc4-03d5-494c-ab5c-8d187aebd740",
      "code": "class Solution:\n  def flowerGame(self, n: int, m: int) -> int:\n    # Alice wins if x + y is odd, occurring when:\n    #   1. x is even and y is odd, or\n    #   2. y is even and x is odd.\n    xEven = n // 2\n    yEven = m // 2\n    xOdd = (n + 1) // 2\n    yOdd = (m + 1) // 2\n    return xEven * yOdd + yEven * xOdd",
      "title": "3021. Alice and Bob Playing Flower Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "269780a4-139f-4127-9c2c-81a11215f07e",
      "code": "class Solution:\n  def minOrAfterOperations(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111\n\n    for i in range(MAX_BIT, -1, -1):\n      # Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      # currently added bit within k operations. If it's impossible, then we\n      # add the i-th bit to the answer.\n      prefixMask |= 1 << i\n      if self._getMergeOps(nums, prefixMask, ans) > k:\n        ans |= 1 << i\n\n    return ans\n\n  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:\n    \"\"\"\n    Returns the number of merge operations to turn `prefixMask` to the target\n    by ANDing `nums`.\n    \"\"\"\n    mergeOps = 0\n    ands = prefixMask\n    for num in nums:\n      ands &= num\n      if (ands | target) == target:\n        ands = prefixMask\n      else:\n        mergeOps += 1  # Keep merging the next num\n    return mergeOps",
      "title": "3022. Minimize OR of Remaining Elements Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cad04823-a948-4ad0-a127-58ed96811689",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int],\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3023. Find Pattern in Infinite Stream I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c49aef6a-070e-42c3-999f-a04fc39408de",
      "code": "class Solution:\n  def triangleType(self, nums: list[int]) -> str:\n    nums.sort()\n    if nums[0] + nums[1] <= nums[2]:\n      return 'none'\n    if nums[0] == nums[1] and nums[1] == nums[2]:\n      return 'equilateral'\n    if nums[0] == nums[1] or nums[1] == nums[2]:\n      return 'isosceles'\n    return 'scalene'",
      "title": "3024. Type of Triangle II Easy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f00d867-e325-4864-ad59-7a8328d71af1",
      "code": "class Solution:\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3025. Find the Number of Ways to Place People I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94e361ba-b25f-4537-a72c-48c214c5e45b",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    numToMinPrefix = {}\n\n    for num in nums:\n      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:\n        numToMinPrefix[num] = prefix\n      prefix += num\n      if num + k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num + k])\n      if num - k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num - k])\n\n    return 0 if ans == -math.inf else ans",
      "title": "3026. Maximum Good Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad7f0f50-5dd0-497e-93f6-ae6ab631f8bd",
      "code": "class Solution:\n  # Same as 3025. Find the Number of Ways to Place People I\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3027. Find the Number of Ways to Place People II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8d0886-bf3b-464e-b9a4-fddeecf284e1",
      "code": "class Solution:\n  def returnToBoundaryCount(self, nums: list[int]) -> int:\n    return sum(prefix == 0 for prefix in itertools.accumulate(nums))",
      "title": "3028. Ant on the Boundary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf30af78-b825-48ae-b749-159980f075a8",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3029. Minimum Time to Revert Word to Initial State I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b028099-6751-4e91-9c1b-ec09bcbd83fd",
      "code": "class Solution:\n  def resultGrid(\n      self,\n      image: list[list[int]],\n      threshold: int,\n  ) -> list[list[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y]\n                           for x in range(i, i + 3)\n                           for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(\n      self,\n      image: list[list[int]],\n      i: int,\n      j: int,\n      threshold: int,\n  ) -> bool:\n    \"\"\"Returns True if image[i..i + 2][j..j + 2] is a region.\"\"\"\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True",
      "title": "3030. Find the Grid of Region Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdc16c5a-1f5c-4d72-ae4b-d0caa05b3eda",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3031. Minimum Time to Revert Word to Initial State II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b92d476-d8e3-457c-9594-dbd3d95e979c",
      "code": "class Solution:\n  def numberCount(self, a: int, b: int) -> int:\n    return sum(len(set(str(num))) == len(str(num))\n               for num in range(a, b + 1))",
      "title": "3032. Count Numbers With Unique Digits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74dfe98a-ff70-4016-b171-bd989ac9bf6b",
      "code": "class Solution:\n  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = matrix.copy()\n\n    for j in range(n):\n      mx = max(matrix[i][j] for i in range(m))\n      for i in range(m):\n        if matrix[i][j] == -1:\n          ans[i][j] = mx\n\n    return ans",
      "title": "3033. Modify the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0461db85-7e08-499b-a16c-42b81274961b",
      "code": "class Solution:\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3034. Number of Subarrays That Match a Pattern I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b24d28c-d0d3-4e5c-8a4d-d3b7a72bfb23",
      "code": "class Solution:\n  def maxPalindromesAfterOperations(self, words: list[str]) -> int:\n    ans = 0\n    count = collections.Counter(''.join(words))\n    pairs = sum(value // 2 for value in count.values())\n\n    for length in sorted(len(word) for word in words):\n      needPairs = length // 2\n      if pairs < needPairs:\n        return ans\n      ans += 1\n      pairs -= needPairs\n\n    return ans",
      "title": "3035. Maximum Palindromes After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a29583c-09ea-4072-8924-40fc6824beeb",
      "code": "class Solution:\n  # Same as 3034. Number of Subarrays That Match a Pattern I\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3036. Number of Subarrays That Match a Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54c5db85-7443-497f-a93d-41af15ee0fc7",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  # Same as 3023. Find Pattern in Infinite Stream I\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int]\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3037. Find Pattern in Infinite Stream II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe49e0d0-5abc-4c98-ae42-25fd2cc6c6a5",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    ans = 1\n    summ = nums[0] + nums[1]\n\n    for i in range(2, len(nums) - 1, 2):\n      if nums[i] + nums[i + 1] == summ:\n        ans += 1\n      else:\n        break\n\n    return ans",
      "title": "3038. Maximum Number of Operations With the Same Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b88a343e-7989-44f7-aaff-1a41def74d77",
      "code": "class Solution:\n  def lastNonEmptyString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    maxFreq = max(count.values())\n\n    for c in reversed(s):\n      if count[c] == maxFreq:\n        ans.append(c)\n        count[c] -= 1\n\n    return ''.join(reversed(ans))",
      "title": "3039. Apply Operations to Make String Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73bed1bf-95cc-4e11-ab41-8e850a99e492",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, score: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      nums[i..j], s.t. all operations have the same `score`.\n      \"\"\"\n      if i >= j:\n        return 0\n      deleteFirstTwo = (1 + dp(i + 2, j, score)\n                        if nums[i] + nums[i + 1] == score else 0)\n      deleteLastTwo = (1 + dp(i, j - 2, score)\n                       if nums[j] + nums[j - 1] == score else 0)\n      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)\n                            if nums[i] + nums[j] == score else 0)\n      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)\n\n    n = len(nums)\n    return max(dp(0, n - 1, nums[0] + nums[1]),\n               dp(0, n - 1, nums[-1] + nums[-2]),\n               dp(0, n - 1, nums[0] + nums[-1]))",
      "title": "3040. Maximum Number of Operations With the Same Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baea1b05-2a22-4e44-8b02-4f3e6a08f570",
      "code": "class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 1\n    prev = -math.inf\n    # the length of the longest consecutive elements (seq0) ending in the\n    # previous number\n    dp0 = 1\n    # the length of the longest consecutive elements (seq1) ending in the\n    # previous number + 1\n    dp1 = 1\n\n    for num in sorted(nums):\n      if num == prev:\n        dp1 = dp0 + 1  # Append `num + 1` to seq0.\n      elif num == prev + 1:\n        dp0 += 1  # Append `num` to seq0.\n        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.\n      elif num == prev + 2:\n        dp0 = dp1 + 1  # Append `num` to seq1.\n        dp1 = 1        # Start a new sequence [`num + 1`].\n      else:\n        dp0 = 1  # Start a new sequence [`num`].\n        dp1 = 1  # Start a new sequence [`num + 1`].\n      ans = max(ans, dp0, dp1)\n      prev = num\n\n    return ans",
      "title": "3041. Maximize Consecutive Elements in an Array After Modification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7f8bdf0-eb63-463c-bd7e-2c857b4143df",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3042. Count Prefix and Suffix Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0940166b-fcad-4844-931a-c124412aa673",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)",
      "title": "3043. Find the Length of the Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15796f68-9c35-40ce-9e5a-c75840abd43d",
      "code": "class Solution:\n  def mostFrequentPrime(self, mat: list[list[int]]) -> int:\n    DIRS = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in DIRS:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]",
      "title": "3044. Most Frequent Prime",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b79107fe-0387-4cdf-9252-66e668144157",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  # Same as 3045. Count Prefix and Suffix Pairs II\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3045. Count Prefix and Suffix Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd4a5bbb-2916-4d17-b3b9-545d24bba716",
      "code": "class Solution:\n  def isPossibleToSplit(self, nums: list[int]) -> bool:\n    return all(freq <= 2 for freq in collections.Counter(nums).values())",
      "title": "3046. Split the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e6207d2-083b-4591-ba73-c08b28d2ca35",
      "code": "class Solution:\n  def largestSquareArea(\n      self,\n      bottomLeft: list[list[int]],\n      topRight: list[list[int]],\n  ) -> int:\n    minSide = 0\n\n    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (\n            itertools.combinations(zip(bottomLeft, topRight), 2)):\n      overlapX = min(ax2, bx2) - max(ax1, bx1)\n      overlapY = min(ay2, by2) - max(ay1, by1)\n      minSide = max(minSide, min(overlapX, overlapY))\n\n    return minSide**2",
      "title": "3047. Find the Largest Area of Square Inside Two Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90094670-c973-4ffc-9cf3-3aa360fb74c9",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    def canMark(second: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `second`.\n      \"\"\"\n      numMarked = 0\n      decrement = 0\n      indexToLastSecond = {}\n\n      for i in range(second):\n        indexToLastSecond[changeIndices[i] - 1] = i\n\n      for i in range(second):\n        index = changeIndices[i] - 1  # Convert to 0-indexed\n        if i == indexToLastSecond[index]:\n          # Reach the last occurrence of the number.\n          # So, the current second will be used to mark the index.\n          if nums[index] > decrement:\n            # The decrement is less than the number to be marked.\n            return False\n          decrement -= nums[index]\n          numMarked += 1\n        else:\n          decrement += 1\n\n      return numMarked == len(nums)\n\n    l = 1\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1",
      "title": "3048. Earliest Second to Mark Indices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ab51894-069c-4d19-bad0-8e7e0625beed",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    # {the second: the index of nums can be zeroed at the current second}\n    secondToIndex = self._getSecondToIndex(nums, changeIndices)\n    numsSum = sum(nums)\n\n    def canMark(maxSecond: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `maxSecond`.\n      \"\"\"\n      # Use a min-heap to greedily pop out the minimum number, which yields the\n      # least saving.\n      minHeap = []\n      marks = 0\n\n      for second in range(maxSecond - 1, -1, -1):\n        if second in secondToIndex:\n          # The number mapped by the index is a candidate to be zeroed out.\n          index = secondToIndex[second]\n          heapq.heappush(minHeap, nums[index])\n          if marks == 0:\n            # Running out of marks, so need to pop out the minimum number.\n            # So, the current second will be used to mark an index.\n            heapq.heappop(minHeap)\n            marks += 1\n          else:\n            # There're enough marks.\n            # So, the current second will be used to zero out a number.\n            marks -= 1\n        else:\n          # There's no candidate to be zeroed out.\n          # So, the current second will be used to mark an index.\n          marks += 1\n\n      decrementAndMarkCost = ((numsSum - sum(minHeap)) +\n                              (len(nums) - len(minHeap)))\n      zeroAndMarkCost = len(minHeap) + len(minHeap)\n      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond\n\n    l = 0\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n\n  def _getSecondToIndex(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> dict[int, int]:\n    # {the `index` of nums: the earliest second to zero out nums[index]}\n    indexToFirstSecond = {}\n    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):\n      index = oneIndexedIndex - 1  # Convert to 0-indexed.\n      if nums[index] > 0 and index not in indexToFirstSecond:\n        indexToFirstSecond[index] = zeroIndexedSecond\n    return {second: index for index, second in indexToFirstSecond.items()}",
      "title": "3049. Earliest Second to Mark Indices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31a5589b-8676-4ac1-9ee7-694b3d6cf9de",
      "code": "class Solution:\n  def gameResult(self, head: ListNode | None) -> str:\n    even = 0\n    odd = 0\n\n    while head:\n      if head.val > head.next.val:\n        even += 1\n      elif head.val < head.next.val:\n        odd += 1\n      head = head.next.next\n\n    if even > odd:\n      return 'Even'\n    if even < odd:\n      return 'Odd'\n    return 'Tie'",
      "title": "3062. Winner of the Linked List Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ed837cf-7083-457e-be2b-7761aef0fbd3",
      "code": "class Solution:\n  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:\n    count = collections.Counter()\n    curr = head\n\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    for freq in count.values():\n      tail.next = ListNode(freq)\n      tail = tail.next\n\n    return dummy.next",
      "title": "3063. Linked List Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef5be656-b185-4e53-891f-76009386c032",
      "code": "# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return sum(1 << i for i in range(31)\n               if commonSetBits(1 << i) == 1)",
      "title": "3064. Guess the Number Using Bitwise Questions I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8ef67dd-ba63-456f-be74-8890848b3661",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(num < k for num in nums)",
      "title": "3065. Minimum Operations to Exceed Threshold Value I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "225b314f-04d6-4553-87c7-0ac230281d13",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    ans = 0\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    while len(minHeap) > 1 and minHeap[0] < k:\n      x = heapq.heappop(minHeap)\n      y = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))\n      ans += 1\n\n    return ans",
      "title": "3066. Minimum Operations to Exceed Threshold Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a5b047-2398-4ba3-9799-761d0f08a479",
      "code": "class Solution:\n  def countPairsOfConnectableServers(\n      self,\n      edges: list[list[int]],\n      signalSpeed: int,\n  ) -> list[int]:\n    n = len(edges) + 1\n    tree = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      tree[u].append((v, w))\n      tree[v].append((u, w))\n\n    def connectablePairsRootedAt(u: int) -> int:\n      pairs = 0\n      count = 0\n      for v, w in tree[u]:\n        childCount = dfs(v, u, w)\n        pairs += count * childCount\n        count += childCount\n      return pairs\n\n    def dfs(u: int, prev: int, dist: int) -> int:\n      return (int(dist % signalSpeed == 0) +\n              sum(dfs(v, u, dist + w)\n              for v, w in tree[u]\n              if v != prev))\n\n    return [connectablePairsRootedAt(i) for i in range(n)]",
      "title": "3067. Count Pairs of Connectable Servers in a Weighted Tree Network",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1d04cca-72f9-47a6-aa6e-c958c1cd4668",
      "code": "class Solution:\n  def maximumValueSum(\n      self,\n      nums: list[int],\n      k: int,\n      edges: list[list[int]],\n  ) -> int:\n    maxSum = sum(max(num, num ^ k) for num in nums)\n    changedCount = sum((num ^ k) > num for num in nums)\n    if changedCount % 2 == 0:\n      return maxSum\n    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)\n    return maxSum - minChangeDiff",
      "title": "3068. Find the Maximum Sum of Node Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21ae8240-7024-412c-98d8-5161a3ee3e22",
      "code": "class Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = [nums[0]]\n    arr2 = [nums[1]]\n\n    for i in range(2, len(nums)):\n      if arr1[-1] > arr2[-1]:\n        arr1.append(nums[i])\n      else:\n        arr2.append(nums[i])\n\n    return arr1 + arr2",
      "title": "3069. Distribute Elements Into Two Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b4793fd-55d2-4863-868c-b6234081c441",
      "code": "class Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n        if prefix[i + 1][j + 1] <= k:\n          ans += 1\n\n    return ans",
      "title": "3070. Count Submatrices with Top-Left Element and Sum Less Than k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f07ad1ae-2b82-4081-81ea-9b7e75fce1ca",
      "code": "class Solution:\n  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    mid = n // 2\n\n    def getOperations(a: int, b: int) -> int:\n      \"\"\"Returns the number of operations to turn Y into a and non-Y into b.\"\"\"\n      operations = 0\n      for i, row in enumerate(grid):\n        for j, num in enumerate(row):\n          # For the 'Y' pattern, before the midpoint, check the diagonal and\n          # anti-diagonal. After the midpoint, check the middle column.\n          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:\n            if num != a:\n              operations += 1\n          elif num != b:\n            operations += 1\n      return operations\n\n    return min(getOperations(0, 1), getOperations(0, 2),\n               getOperations(1, 0), getOperations(1, 2),\n               getOperations(2, 0), getOperations(2, 1))",
      "title": "3071. Minimum Operations to Write the Letter Y on a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1a110f8-e154-40f8-9bc3-7d23f7905471",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: list[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.add(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks",
      "title": "3072. Distribute Elements Into Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3cb8c61-58bd-493b-95c5-030c68b30322",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))\n    leftSortedSet = SortedSet([nums[0]])\n\n    for i in range(len(nums) - 2, -1, -1):\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1])\n\n    for j in range(1, len(nums) - 1):\n      i = bisect.bisect_left(leftSortedSet, nums[j])\n      if i > 0 and rightMax[j] > nums[j]:\n        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])\n      leftSortedSet.add(nums[j])\n\n    return ans",
      "title": "3073. Maximum Increasing Triplet Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "946fa5db-8ba3-470e-a257-6f3c6e2216be",
      "code": "class Solution:\n  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:\n    appleSum = sum(apple)\n    capacitySum = 0\n\n    for i, c in enumerate(sorted(capacity, reverse=True)):\n      capacitySum += c\n      if capacitySum >= appleSum:\n        return i + 1\n\n    return len(capacity)",
      "title": "3074. Apple Redistribution into Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0763676-2642-4bbf-b34d-d8ccc4c1c7bf",
      "code": "class Solution:\n  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:\n    ans = 0\n    decremented = 0\n\n    happiness.sort(reverse=True)\n\n    for i in range(k):\n      ans += max(0, happiness[i] - decremented)\n      decremented += 1\n\n    return ans",
      "title": "3075. Maximize Happiness of Selected Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d795ad5-512b-4adf-a061-eb55804cfdb6",
      "code": "class Solution:\n  def shortestSubstrings(self, arr: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    def getSubstrings(s: str) -> Iterator[str]:\n      for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n          yield s[i:j]\n\n    def add(s: str) -> None:\n      \"\"\"Adds all substrings of s to `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] += 1\n\n    def remove(s: str) -> None:\n      \"\"\"Removes all substrings of s from `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] -= 1\n\n    def getMinSub(s: str) -> str:\n      minSub = ''\n      for sub in getSubstrings(s):\n        if count[sub] > 0:\n          continue\n        if minSub == ('' or\n                      len(sub) < len(minSub) or\n                      len(sub) == len(minSub) and sub < minSub):\n          minSub = sub\n      return minSub\n\n    for s in arr:\n      add(s)\n\n    for s in arr:\n      remove(s)\n      ans.append(getMinSub(s))\n      add(s)\n\n    return ans",
      "title": "3076. Shortest Uncommon Substring in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02acfffc-fae7-49c8-b415-ec1bc2b16e8d",
      "code": "class Solution:\n  def maximumStrength(self, nums: list[int], k: int) -> int:\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, fresh: bool) -> int:\n      \"\"\"\n      Returns the maximum strength of nums[i..n) with k operations left, where\n      `fresh` means we're starting a new subarray.\n      \"\"\"\n      if len(nums) - i < k:\n        return -math.inf\n      if k == 0:\n        return 0\n      if i == len(nums):\n        return 0 if k == 0 else -math.inf\n      # If it's not fresh, we can't skip the current number and consider it as a\n      # fresh start, since the case where it's fresh is already covered by\n      # `includeAndFreshStart`.\n      skip = dp(i + 1, k, True) if fresh else -math.inf\n      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k\n      includeAndContinue = dp(i + 1, k, False) + gain\n      includeAndFreshStart = dp(i + 1, k - 1, True) + gain\n      return max(skip, includeAndContinue, includeAndFreshStart)\n\n    return dp(0, k, True)",
      "title": "3077. Maximum Strength of K Disjoint Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f4e5d57-99c1-45a1-889f-2c5d6fb289f2",
      "code": "class Solution:\n  def findPattern(\n      self,\n      board: list[list[int]],\n      pattern: list[str],\n  ) -> list[int]:\n    def isMatch(x: int, y: int) -> bool:\n      digitToLetter = {}\n      letterToDigit = {}\n      for i, row in enumerate(pattern):\n        for j, c in enumerate(row):\n          digit = board[i + x][j + y]\n          if c.isdigit():\n            if int(c) != digit:\n              return False\n          else:\n            if digitToLetter.get(digit, c) != c:\n              return False\n            if letterToDigit.get(c, digit) != digit:\n              return False\n            digitToLetter[digit] = c\n            letterToDigit[c] = digit\n      return True\n\n    for x in range(len(board) - len(pattern) + 1):\n      for y in range(len(board[0]) - len(pattern[0]) + 1):\n        if isMatch(x, y):\n          return [x, y]\n\n    return [-1, -1]",
      "title": "3078. Match Alphanumerical Pattern in Matrix I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb9c3dd9-3244-48b2-adbc-8b61c3205329",
      "code": "class Solution:\n  def sumOfEncryptedInt(self, nums: list[int]) -> int:\n    def getEncrypted(num: int) -> int:\n      maxDigit = 0\n      base = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        base = base * 10 + 1\n        num //= 10\n      return base * maxDigit\n\n    return sum(getEncrypted(num) for num in nums)",
      "title": "3079. Find the Sum of Encrypted Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c16dbc30-85c1-4862-b394-f128712c575d",
      "code": "class Solution:\n  def unmarkedSumArray(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    marked = set()\n    summ = sum(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for index, k in queries:\n      if index not in marked:\n        marked.add(index)\n        summ -= nums[index]\n      popped = 0\n      while popped < k and minHeap:\n        num, i = heapq.heappop(minHeap)\n        if i not in marked:\n          marked.add(i)\n          summ -= num\n          popped += 1\n      ans.append(summ)\n\n    return ans",
      "title": "3080. Mark Elements on Array by Performing Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62af718f-fcab-4b28-824c-1112183770fa",
      "code": "class Solution:\n  def minimizeStringValue(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    letters = []\n\n    del count['?']\n\n    def getMinFreqLetter(count: dict[str, int]) -> str:\n      minFreqLetter = 'a'\n      for c in string.ascii_lowercase:\n        if count[c] < count[minFreqLetter]:\n          minFreqLetter = c\n      return minFreqLetter\n\n    for c in s:\n      if c == '?':\n        minFreqLetter = getMinFreqLetter(count)\n        letters.append(minFreqLetter)\n        count[minFreqLetter] += 1\n\n    letters.sort()\n    i = 0  # letters' index\n\n    for c in s:\n      if c == '?':\n        ans.append(letters[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3081. Replace Question Marks in String to Minimize Its Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea5dffba-c0fd-4b37-816d-12d4dda90f09",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(k + 1):\n        if j < num:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2) % MOD\n        else:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          # 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % MOD\n\n    return dp[n][k]",
      "title": "3082. Find the Sum of the Power of All Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c9e5e02-89da-446a-8459-79a5999708da",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of subsequences in nums[i..n) that sums to j.\"\"\"\n      if j == 0:\n        # For each of the remaining number, we can either pick it or skip it.\n        return pow(2, len(nums) - i, MOD)\n      if i == len(nums) or j < 0:\n        return 0\n        # 1. Include nums[i] in the subsequence and pick it.\n        # 2. Include nums[i] in the subsequence and skip it.\n        # 3. Exclude nums[i] in the subsequence.\n      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % MOD\n\n    return dp(0, k)",
      "title": "3082. Find the Sum of the Power of All Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c725030-2f4a-44c1-a115-656db3818e0d",
      "code": "class Solution:\n  def isSubstringPresent(self, s: str) -> bool:\n    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))",
      "title": "3083. Existence of a Substring in a String and Its Reverse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97b229de-6740-44b4-ad4b-9db1d6734033",
      "code": "class Solution:\n  def countSubstrings(self, s: str, c: str) -> int:\n    freq = s.count(c)\n    return freq * (freq + 1) // 2",
      "title": "3084. Count Substrings Starting and Ending with Given Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48cc9e23-fa43-435c-a356-55ab3c6dabef",
      "code": "class Solution:\n  def minimumDeletions(self, word: str, k: int) -> int:\n    ans = math.inf\n    count = collections.Counter(word)\n\n    for minFreq in count.values():\n      deletions = 0\n      for freq in count.values():\n        if freq < minFreq:\n          deletions += freq\n        else:\n          deletions += max(0, freq - (minFreq + k))\n      ans = min(ans, deletions)\n\n    return ans",
      "title": "3085. Minimum Deletions to Make String K-Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdec1f54-a3cc-4093-b106-d6ab32ba332c",
      "code": "class Solution:\n  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:\n    # Dylan has two actions for collecting '1's in a sequence:\n    # Action 1: Put a '1' next to him and pick it up.\n    #           The cost is 2.\n    # Action 2: Swap a '1' towards him and collect it.\n    #           The cost equals the distance to the '1'.\n    #\n    # To minimize the swapping cost, Dylan can use a sliding window strategy,\n    # selecting the optimal position (middle '1' in the window) for efficient\n    # collection. The window's size is crucial:\n\n    # The minimum window size: min(0, k - maxChanges), ensuring the window\n    # isn't too small.\n    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    # preventing overly ambitious swaps.\n    #\n    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    # cheaper to use Action 1.\n\n    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    # a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    # should be replaced with Action 1.\n    NUM_OF_INDICES_WITHIN_ONE_DISTANCE = 3\n    ans = math.inf\n    oneIndices = [i for i, num in enumerate(nums) if num == 1]\n    prefix = list(itertools.accumulate(oneIndices, initial=0))\n\n    minOnesByTwo = max(0, k - maxChanges)\n    maxOnesByTwo = min(\n        k, minOnesByTwo + NUM_OF_INDICES_WITHIN_ONE_DISTANCE, len(oneIndices))\n\n    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):\n      for l in range(len(prefix) - onesByTwo):\n        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].\n        cost1 = (k - onesByTwo) * 2\n        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -\n                 (prefix[(l + r + 1) // 2] - prefix[l]))\n        ans = min(ans, cost1 + cost2)\n\n    return ans",
      "title": "3086. Minimum Moves to Pick K Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85f7520e-95d7-47c6-8b4a-15409b9b2ddc",
      "code": "class Solution:\n  def makeAntiPalindrome(self, s: str) -> str:\n    n = len(s)\n    i = n // 2\n    chars = sorted(list(s))\n    if chars[i] != chars[n - 1 - i]:\n      return ''.join(chars)\n\n    j = self._getFirstDiffIndexInSecondHalf(chars)\n    while chars[i] == chars[n - 1 - i]:\n      if j == n:\n        return '-1'\n      chars[i], chars[j] = chars[j], chars[i]\n      i += 1\n      j += 1\n\n    return ''.join(chars)\n\n  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:\n    \"\"\"\n    Returns the first index in chars[n / 2..n) that is different from the first\n    letter of the second half, chars[n / 2].\n    \"\"\"\n    n = len(chars)\n    firstLetter = chars[n // 2]\n    firstDiffIndex = n // 2\n    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:\n      firstDiffIndex += 1\n    return firstDiffIndex",
      "title": "3088. Make String Anti-palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96f07ffe-48d4-4f0e-abaf-6253136222f5",
      "code": "class Solution:\n  def maximumLengthSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 2:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "3090. Maximum Length Substring With Two Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6d2da72-84d9-4c08-a5b3-92adf11aa107",
      "code": "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.ceil(math.sqrt(k))\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y",
      "title": "3091. Apply Operations to Make Sum of Array Greater Than or Equal to k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0569ba7-45b0-4149-9000-a5cd6d37b094",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:\n    ans = []\n    numCount = collections.Counter()  # {num: freq}\n    freqCount = SortedDict()  # {num's freq: freq}\n\n    for num, f in zip(nums, freq):\n      if numCount[num] > 0:\n        numFreq = numCount[num]\n        freqCount[numFreq] -= 1\n        if freqCount[numFreq] == 0:\n          del freqCount[numFreq]\n      newFreq = numCount[num] + f\n      if newFreq == 0:\n        del numCount[num]\n      else:\n        numCount[num] = newFreq\n        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1\n      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)\n\n    return ans",
      "title": "3092. Most Frequent IDs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ef53e2e-452f-4d57-a488-60591671e58d",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n    self.length = math.inf\n    self.index = -1\n\n\nclass Solution:\n  def stringIndices(\n      self,\n      wordsContainer: list[str],\n      wordsQuery: list[str],\n  ) -> list[int]:\n    ans = []\n    root = TrieNode()\n    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]\n\n    def insert(word: str, index: int) -> None:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n        if node.length > len(word):\n          node.length = len(word)\n          node.index = index\n\n    def search(word: str) -> int:\n      node = root\n      for c in reversed(word):\n        if c not in node.children:\n          return node.index\n        node = node.children[c]\n      return node.index\n\n    for i, word in enumerate(wordsContainer):\n      insert(word, i)\n\n    for query in wordsQuery:\n      index = search(query)\n      ans.append(minIndex if index == -1 else index)\n\n    return ans",
      "title": "3093. Longest Common Suffix Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c53d811-d276-42ce-acc1-6389f3b49187",
      "code": "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    ans = 0\n    sameCount = commonBits(0)\n\n    for i in range(31):\n      if commonBits(1 << i) > sameCount:\n        ans |= 1 << i\n      commonBits(1 << i)  # Revert the XOR.\n\n    return ans",
      "title": "3094. Guess the Number Using Bitwise Questions II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90e0f5e3-986b-42b2-84df-72631d6325e6",
      "code": "class Solution:\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3095. Shortest Subarray With OR at Least K I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82eb5941-c009-40b1-91e1-f6f42369009e",
      "code": "class Solution:\n  def minimumLevels(self, possible: list[int]) -> int:\n    n = len(possible)\n    nums = [num if num == 1 else -1 for num in possible]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n):\n      if prefix[i] > prefix[n] - prefix[i]:\n        return i\n\n    return -1",
      "title": "3096. Minimum Levels to Gain More Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5815c11-9bf9-424b-99ab-ed8ece7efe4d",
      "code": "class Solution:\n  # Same as 3095. Shortest Subarray With OR at Least K I\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3097. Shortest Subarray With OR at Least K II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d157d03a-eee2-4f12-b722-5952ee6766cf",
      "code": "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        k: int,\n        lastPickedIndex: int,\n        firstIndex: int,\n        secondIndex: int\n    ) -> int:\n      if k == 0:\n        return nums[secondIndex] - nums[firstIndex]\n      if i == len(nums):\n        return 0\n      newFirstIndex = firstIndex\n      newSecondIndex = secondIndex\n      if firstIndex == -1:\n        newFirstIndex = i\n      elif secondIndex == -1:\n        newSecondIndex = i\n      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:\n        newFirstIndex = lastPickedIndex\n        newSecondIndex = i\n      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)\n      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, -1, -1)",
      "title": "3098. Find the Sum of Subsequence Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc665c07-4342-46e6-b03e-656bca7075b9",
      "code": "class Solution:\n  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n    digitSum = self._getDigitSum(x)\n    return digitSum if x % digitSum == 0 else -1\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3099. Harshad Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0c1b380-0f13-47e8-9b39-51f391743c3d",
      "code": "class Solution:\n  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n    ans = numBottles\n\n    while numBottles >= numExchange:\n      numBottles = numBottles - numExchange + 1\n      numExchange += 1\n      ans += 1\n\n    return ans",
      "title": "3100. Water Bottles II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aad98c0-b92b-4190-a77d-8889dfa39b52",
      "code": "class Solution:\n  def countAlternatingSubarrays(self, nums: list[int]) -> int:\n    # dp[i] := the number of alternating subarrays ending in index i\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1]:\n        dp[i] += dp[i - 1]\n\n    return sum(dp)",
      "title": "3101. Count Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0784398-2d41-46a0-93af-df84677315c3",
      "code": "class Solution:\n  def minimumDistance(self, points: list[list[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi),\n               self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(\n      self,\n      points: list[list[int]],\n      excludedIndex: int,\n  ) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff\n            else [minDiffIndex, maxDiffIndex])\n\n  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])",
      "title": "3102. Minimize Manhattan Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9b65eab-61fa-42d8-af51-d941633f9f8e",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str) -> int:\n    allCount = collections.Counter(s)\n\n    # Similar to 395. Longest Substring with At Least K Repeating Characters\n    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:\n      res = -1\n      # the number of unique letters\n      uniqueLetters = 0\n      # the number of letters that have all their frequency in the substring\n      lettersHavingAllFreq = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == allCount[c]:\n          lettersHavingAllFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == allCount[s[l]]:\n            lettersHavingAllFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having all their frequency are equal to n, this is a valid window.\n        # Implcit: uniqueLetters == n\n        if lettersHavingAllFreq == n and r - l + 1 < len(s):\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(maxSubstringLengthWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "3104. Find Longest Self-Contained Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77eaa1c8-7deb-4d82-b0e2-598a1db58ad9",
      "code": "class Solution:\n  # Similar to 978. Longest Turbulent Subarray\n  def longestMonotonicSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        increasing += 1\n        decreasing = 1\n      elif nums[i] < nums[i - 1]:\n        decreasing += 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, increasing, decreasing)\n\n    return ans",
      "title": "3105. Longest Strictly Increasing or Strictly Decreasing Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1030e8be-0449-4144-b0d7-23ee5fcfcad3",
      "code": "class Solution:\n  def getSmallestString(self, s: str, k: int) -> str:\n    ans = list(s)\n\n    for i, c in enumerate(s):\n      if k == 0:\n        break\n      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n      if k >= distToA:\n        k -= distToA\n        ans[i] = 'a'\n      else:\n        # k is not enough to change the current letter to 'a', so move as closer\n        # to 'a' as possible.\n        ans[i] = chr(ord(c) - k)\n        k = 0\n\n    return ''.join(ans)",
      "title": "3106. Lexicographically Smallest String After Operations With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c396fe50-3c2f-4857-8e87-fc68ab047c5c",
      "code": "class Solution:\n  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    for i in range(n // 2 + 1):\n      ans += max(0, nums[i] - k)\n\n    for i in range(n // 2, n):\n      ans += max(0, k - nums[i])\n\n    return ans",
      "title": "3107. Minimum Operations to Make Median of Array Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "789367c7-3ba5-42db-96b7-a1d8dca6e461",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    return self.weight[i] if i == j else -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]",
      "title": "3108. Minimum Cost Walk in Weighted Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb155a05-867b-47a5-84ae-a68e3c339dc7",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getPermutationIndex(self, perm: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(perm)\n    ans = 0\n    tree = FenwickTree(n)\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = (fact[i - 1] * i) % MOD\n\n    for i, num in enumerate(perm):\n      # the number of unused numbers less than `num`\n      unusedNums = num - 1 - tree.get(num - 1)\n      suffixLength = fact[n - 1 - i]\n      ans += unusedNums * suffixLength\n      ans %= MOD\n      tree.add(num, 1)\n\n    return ans",
      "title": "3109. Find the Index of Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60416d42-dbaa-4a37-9f84-d78dcd8f14b2",
      "code": "class Solution:\n  def scoreOfString(self, s: str) -> int:\n    return sum(abs(ord(a) - ord(b))\n               for a, b in itertools.pairwise(s))",
      "title": "3110. Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d6c2ca9-c5d4-40b0-903e-79b470b0fdd5",
      "code": "class Solution:\n  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:\n    ans = 0\n    prevX = -w - 1\n    xs = sorted([x for x, _ in points])\n\n    for x in xs:\n      if x > prevX + w:\n        ans += 1\n        prevX = x\n\n    return ans",
      "title": "3111. Minimum Rectangles to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a34b6cd-b849-4779-8bd8-f5364b579957",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      edges: list[list[int]],\n      disappear: list[int],\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      disappear: list[int],\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return [d if d != math.inf else -1\n            for d in dist]",
      "title": "3112. Minimum Time to Visit Disappearing Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a3eb480-3e68-4449-b5ce-6cf93a3ae1b4",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1][0] < num:\n        stack.pop()\n      if not stack or stack[-1][0] != num:\n        stack.append([num, 0])\n      stack[-1][1] += 1\n      ans += stack[-1][1]\n\n    return ans",
      "title": "3113. Find the Number of Subarrays Where Boundary Elements Are Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f534fc4-db69-42cb-b2a1-986f978b8b90",
      "code": "class Solution:\n  # Similar to 1736. Latest Time by Replacing Hidden Digits\n  def findLatestTime(self, s: str) -> str:\n    ans = list(s)\n    if s[0] == '?':\n      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'\n    if s[1] == '?':\n      ans[1] = '1' if ans[0] == '1' else '9'\n    if s[3] == '?':\n      ans[3] = '5'\n    if s[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "3114. Latest Time You Can Obtain After Replacing Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0170a6d3-28eb-494d-98a1-059a6cf4fde1",
      "code": "class Solution:\n  def maximumPrimeDifference(self, nums: list[int]) -> int:\n    MAX = 100\n    isPrime = self._sieveEratosthenes(MAX + 1)\n    minPrimeIndex = -1\n    maxPrimeIndex = -1\n\n    for i, num in enumerate(nums):\n      if isPrime[num]:\n        if minPrimeIndex == -1:\n          minPrimeIndex = i\n        maxPrimeIndex = i\n\n    return maxPrimeIndex - minPrimeIndex\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3115. Maximum Prime Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b2af8d3-b044-42e7-b3fd-0e99aeceda00",
      "code": "class Solution:\n  def findKthSmallest(self, coins: list[int], k: int) -> int:\n    sizeToLcms = self._getSizeToLcms(coins)\n\n    def count(m: int) -> int:\n      \"\"\"Returns the number of denominations <= m.\"\"\"\n      res = 0\n      for sz, lcms in enumerate(sizeToLcms):\n        for lcm in lcms:\n          # Principle of Inclusion-Exclusion (PIE)\n          res += m // lcm * pow(-1, sz + 1)\n      return res\n\n    return bisect.bisect_left(range(k * min(coins)), k, key=count)\n\n  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:\n    # Returns the LCMs for each number of combination of coins.\n    sizeToLcms = [[] for _ in range(len(coins) + 1)]\n    for sz in range(1, len(coins) + 1):\n      for combination in itertools.combinations(coins, sz):\n        sizeToLcms[sz].append(math.lcm(*combination))\n    return sizeToLcms",
      "title": "3116. Kth Smallest Amount With Single Denomination Combination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd9dfbf5-d75d-4d40-8956-bb16821cd8fe",
      "code": "class Solution:\n  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:\n    n = len(nums)\n    m = len(andValues)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n      `mask` is the running value of the current subarray.\n      \"\"\"\n      if i == n and j == m:\n        return 0\n      if i == n or j == m:\n        return math.inf\n      mask &= nums[i]\n      if mask < andValues[j]:\n        return math.inf\n      if mask == andValues[j]:\n        # 1. Keep going.\n        # 2. End the subarray here and pick nums[i], then fresh start.\n        return min(dp(i + 1, j, mask),\n                   nums[i] + dp(i + 1, j + 1, -1))\n      return dp(i + 1, j, mask)  # Keep going.\n\n    ans = dp(0, 0, -1)\n    return ans if ans < math.inf else -1",
      "title": "3117. Minimum Sum of Values by Dividing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "097d920c-2443-486d-b488-0b2cf098a0c9",
      "code": "class Solution:\n  def maxPotholes(self, road: str, budget: int) -> int:\n    ans = 0\n\n    for length in sorted(map(len, road.split('.')), reverse=True):\n      canRepair = max(0, budget - 1)\n      if length > canRepair:\n        return ans + canRepair\n      ans += length\n      budget -= length + 1\n\n    return ans",
      "title": "3119. Maximum Number of Potholes That Can Be Fixed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37429895-c86d-4849-8bda-d8a145457f5c",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = True\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3120. Count the Number of Special Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "230b16fa-b6ce-4d01-b47b-9370f7a7ee6a",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = not upper[c.upper()]\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3121. Count the Number of Special Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec95a1f7-eb02-4b61-b63b-6d077f29a6d5",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    count = [[0] * 10 for _ in range(n)]\n\n    for row in grid:\n      for j, num in enumerate(row):\n        count[j][num] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of minimum operations needed to make grid[:][j..n)\n      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n      \"\"\"\n      if i == n:\n        return 0\n\n      res = math.inf\n\n      for num in range(10):\n        if i == 0 or num != prev:\n          res = min(res, m - count[i][num] + dp(i + 1, num))\n\n      return res\n\n    return dp(0, 0)",
      "title": "3122. Minimum Number of Operations to Satisfy Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc423af8-229d-4ec3-bd5f-53fbc9764742",
      "code": "class Solution:\n  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or\n            from0[v] + w + from1[u] == from0[-1]\n            for u, v, w in edges]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "3123. Find Edges in Shortest Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c0630f1-9c57-4984-bc14-4ecc2701c0db",
      "code": "class Solution:\n  def maxNumber(self, n: int) -> int:\n    # assume n = 0b00...11???\n    #        x = 0b00...01111\n    #  since y = 0b00...10000 is in [x, n]\n    #    and x & y = 0\n    return (1 << n.bit_length() - 1) - 1",
      "title": "3125. Maximum Number That Makes Result of Bitwise AND Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba32725b-889f-4235-bb72-5cf59b873204",
      "code": "class Solution:\n  def canMakeSquare(self, grid: list[list[str]]) -> bool:\n    for i in range(2):\n      for j in range(2):\n        black = 0\n        white = 0\n        for x in range(2):\n          for y in range(2):\n            if grid[i + x][j + y] == 'B':\n              black += 1\n            else:\n              white += 1\n        if black >= 3 or white >= 3:\n          return True\n    return False",
      "title": "3127. Make a Square with the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1e59a9f-b2ad-4c3f-b03a-f92f3a2b7ed4",
      "code": "class Solution:\n  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    return sum((rows[i] - 1) * (cols[j] - 1)\n               for i, row in enumerate(grid)\n               for j, num in enumerate(row)\n               if num == 1)",
      "title": "3128. Right Triangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f27b904-2056-490b-a5fd-2023a8c0b121",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n           for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3129. Find All Possible Stable Binary Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2465854-fb3a-46f9-8086-7fd82434dad9",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n          for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3130. Find All Possible Stable Binary Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b16105bb-e9b3-4c5e-9a8b-bd4000ddf07a",
      "code": "class Solution:\n  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(nums2) - min(nums1)",
      "title": "3131. Find the Integer Added to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94615bee-31e0-4d7e-8685-b0acdacaad69",
      "code": "class Solution:\n  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    # After removing two elements from nums1, either nums1[0], nums1[1], or\n    # nums1[2] will persist. Therefore, the difference between nums1 (with two\n    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    # 0 <= i <= 2.\n    ans = math.inf\n\n    nums1.sort()\n    nums2.sort()\n\n    for i in range(3):\n      inc = nums2[0] - nums1[i]\n      if self._isValidDiff(nums1, nums2, inc):\n        ans = min(ans, inc)\n\n    return ans\n\n  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:\n    \"\"\"\n    Returns True if it's possible to increase nums1 (with two elements removed)\n    by `inc` to nums2.\n    \"\"\"\n    removed = 0\n    i = 0  # nums2's index\n\n    for num in nums1:\n      if num + inc == nums2[i]:\n        i += 1\n        if i == len(nums2):\n          break\n      else:\n        removed += 1\n\n    return removed <= 2",
      "title": "3132. Find the Integer Added to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5989a772-a351-4f7b-9466-11f9d64ae4c0",
      "code": "class Solution:\n  def minEnd(self, n: int, x: int) -> int:\n    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    # operation increase x for (n - 1) iterations while preserving x's 1s.\n    MAX_BIT = n.bit_length() + x.bit_length()\n    k = n - 1\n    BINARY_INDEX = 0\n\n    for i in range(MAX_BIT):\n      if x >> i & 1 == 0:\n        # Set x's 0 with k's bit if the running bit of k is 1.\n        if k >> BINARY_INDEX & 1:\n          x |= 1 << i\n        BINARY_INDEX += 1\n\n    return x",
      "title": "3133. Minimum Array End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46198fc2-1f16-43a2-86d5-77c38e53ec17",
      "code": "class Solution:\n  def medianOfUniquenessArray(self, nums: list[int]):\n    n = len(nums)\n    subarrayCount = n * (n + 1) // 2\n    medianCount = (subarrayCount + 1) // 2\n\n    # Similar to 992. Subarrays with K Different Integers\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    l = 1\n    r = n\n    return bisect.bisect_left(range(l, r), medianCount,\n                              key=subarraysWithAtMostKDistinct) + l",
      "title": "3134. Find the Median of the Uniqueness Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "193d9243-b2a6-4a42-ab58-82f237548794",
      "code": "class Solution:\n  def minOperations(self, initial: str, target: str) -> int:\n    m = len(initial)\n    n = len(target)\n    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if initial[i - 1] == target[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n\n    return m + n - 2 * max(map(max, dp))",
      "title": "3135. Equalize Strings by Adding or Removing Characters at Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a86da666-2dd8-4ddb-8b8a-5c76a57e5913",
      "code": "class Solution:\n  def isValid(self, word: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n\n    def isConsonant(c: str) -> bool:\n      return c.isalpha() and c not in VOWELS\n\n    return (len(word) >= 3 and\n            all(c.isalnum() for c in word) and\n            any(c in VOWELS for c in word) and\n            any(isConsonant(c) for c in word))",
      "title": "3136. Valid Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f070e715-b290-4b55-8a91-283427bd84d6",
      "code": "class Solution:\n  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))\n    return len(word) // k - max(count.values())",
      "title": "3137. Minimum Number of Operations to Make Word K-Periodic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa98bca9-2b19-459a-bba3-26de9a23749f",
      "code": "class Solution:\n  def minAnagramLength(self, s: str) -> int:\n    n = len(s)\n    for k in range(1, n + 1):\n      if n % k == 0 and self._canFormAnagram(s, k):\n        return k\n    return n\n\n  def _canFormAnagram(self, s: str, k: int) -> bool:\n    \"\"\"Returns True if we can concatenate an anagram of length k to s.\"\"\"\n    anagramCount = collections.Counter(s[:k])\n    return all(collections.Counter(s[i:i + k]) == anagramCount\n               for i in range(k, len(s), k))",
      "title": "3138. Minimum Length of Anagram Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6116664-f63f-4fb7-85d7-943ff124db52",
      "code": "class Solution:\n  def minCostToEqualizeArray(\n      self,\n      nums: list[int],\n      cost1: int,\n      cost2: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    minNum = min(nums)\n    maxNum = max(nums)\n    summ = sum(nums)\n\n    if cost1 * 2 <= cost2 or n < 3:\n      totalGap = maxNum * n - summ\n      return (cost1 * totalGap) % MOD\n\n    def getMinCost(target: int) -> int:\n      \"\"\"Returns the minimum cost to make all numbers equal to `target`.\"\"\"\n      maxGap = target - minNum\n      totalGap = target * n - summ\n      # Pair one shallowest number with one non-shallowest number, so the worst\n      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.\n      pairs = min(totalGap // 2, totalGap - maxGap)\n      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs\n\n    return min(getMinCost(target)\n               for target in range(maxNum, 2 * maxNum)) % MOD",
      "title": "3139. Minimum Cost to Equalize Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edc3ce3d-60dc-4940-9710-6fed5ed0b141",
      "code": "class Solution:\n  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:\n    MAX_MASK = 1 << m\n    # dp[i] := the maximum hamming distance from i to any number in `nums`\n    dp = [-math.inf] * MAX_MASK\n\n    for num in nums:\n      dp[num] = 0\n\n    for bit in range(m):\n      newDp = [0] * MAX_MASK\n      for mask in range(MAX_MASK):\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)\n      dp = newDp\n\n    return [dp[num] for num in nums]",
      "title": "3141. Maximum Hamming Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d33472b-a78d-49e5-a201-31ef8094c13d",
      "code": "class Solution:\n  def satisfiesConditions(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    return (all(grid[i][j] == grid[i + 1][j]\n                for i in range(m - 1)\n                for j in range(n)) and\n            all(grid[i][j] != grid[i][j + 1]\n                for i in range(m)\n                for j in range(n - 1)))",
      "title": "3142. Check if Grid Satisfies Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e3a7d1-cc8e-45c3-8573-4d33905f17a7",
      "code": "class Solution:\n  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:\n    secondMinSize = math.inf\n    minSizes = {}\n\n    for (x, y), c in zip(points, s):\n      sz = max(abs(x), abs(y))\n      if c not in minSizes:\n        minSizes[c] = sz\n      elif sz < minSizes[c]:\n        # This is because minSizes[j] is about to be replaced by a smaller\n        # value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[c])\n        minSizes[c] = sz\n      else:\n        # `sz` is not smaller than the current minimum size, but it could be\n        # smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz)\n\n    return sum(sz < secondMinSize for sz in minSizes.values())",
      "title": "3143. Maximum Points Inside the Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f61f0cd-60df-408c-8ab4-05dfeddfeea8",
      "code": "class Solution:\n  def minimumSubstringsInPartition(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of substrings in s[0..i]\n    dp = [n] * n\n\n    for i in range(n):\n      count = collections.Counter()\n      for j in range(i, -1, -1):\n        count[s[j]] += 1\n        # word[j..i] is balanced.\n        if min(count.values()) == max(count.values()):\n          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)\n\n    return dp[-1]",
      "title": "3144. Minimum Substring Partition of Equal Character Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "896b072a-d3bc-45fc-9fa7-002c93537a78",
      "code": "class Solution:\n  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:\n    def sumBitsTill(x: int) -> int:\n      \"\"\"Returns sum(i.bit_count()), where 1 <= i <= x.\"\"\"\n      sumBits = 0\n      powerOfTwo = 1\n      while powerOfTwo <= x:\n        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo\n        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)\n        powerOfTwo *= 2\n      return sumBits\n\n    def sumPowersTill(x: int) -> int:\n      \"\"\"Returns sum(all powers of i), where 1 <= i <= x.\"\"\"\n      sumPowers = 0\n      powerOfTwo = 1\n      for power in range(x.bit_length()):\n        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power\n        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power\n        powerOfTwo *= 2\n      return sumPowers\n\n    def sumPowersFirstKBigNums(k: int) -> int:\n      \"\"\"Returns the sum of powers of the first k numbers in `big_nums`.\"\"\"\n      # Find the first number in [1, k] that has sumBitsTill(num) >= k.\n      num = bisect.bisect_left(range(k), k, key=sumBitsTill)\n      sumPowers = sumPowersTill(num - 1)\n      remainingCount = k - sumBitsTill(num - 1)\n      for power in range(num.bit_length()):\n        if num >> power & 1:\n          sumPowers += power\n          remainingCount -= 1\n          if remainingCount == 0:\n            break\n      return sumPowers\n\n    return [pow(2,\n                sumPowersFirstKBigNums(b + 1) -\n                sumPowersFirstKBigNums(a), mod)\n            for a, b, mod in queries]",
      "title": "3145. Find Products of Elements of Big Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b9e77b8-a313-44d1-8a49-2fb13f0e744f",
      "code": "class Solution:\n  def findPermutationDifference(self, s: str, t: str) -> int:\n    indices = {c: i for i, c in enumerate(s)}\n    return sum([abs(indices[c] - i) for i, c in enumerate(t)])",
      "title": "3146. Permutation Difference between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f60161a3-064c-4a25-b2ff-8e998077e8dd",
      "code": "class Solution:\n  def maximumEnergy(self, energy: list[int], k: int) -> int:\n    # dp[i] := the sum of energy starting at i\n    dp = energy.copy()\n    for i in range(len(energy) - 1 - k, -1, -1):\n      dp[i] += dp[i + k]\n    return max(dp)",
      "title": "3147. Taking Maximum Energy From the Mystic Dungeon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "082f3bfd-5279-482b-9a64-3185bf1ec2e0",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    MAX = 200000\n    ans = -MAX\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        prevMin = min(grid[i - 1][j] if i > 0 else MAX,\n                      grid[i][j - 1] if j > 0 else MAX)\n        ans = max(ans, num - prevMin)\n        grid[i][j] = min(num, prevMin)\n\n    return ans",
      "title": "3148. Maximum Difference Score in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b95944d5-1198-44bb-a135-9b0976f0b154",
      "code": "class Solution:\n  def findPermutation(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    bestPick = [[0] * (1 << n) for _ in range(n)]\n\n    @functools.lru_cache(None)\n    def getScore(last: int, mask: int) -> int:\n      if mask.bit_count() == len(nums):\n        return abs(last - nums[0])\n\n      minScore = math.inf\n      for i in range(1, len(nums)):\n        if mask >> i & 1:\n          continue\n        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))\n        if nextMinScore < minScore:\n          minScore = nextMinScore\n          bestPick[last][mask] = i\n\n      return minScore\n\n    getScore(0, 1)\n    return self._construct(bestPick)\n\n  def _construct(self, bestPick: list[list[int]]) -> list[int]:\n    ans = []\n    last = 0\n    mask = 1\n    for _ in range(len(bestPick)):\n      ans.append(last)\n      last = bestPick[last][mask]\n      mask |= 1 << last\n    return ans",
      "title": "3149. Find the Minimum Cost Array Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d152741a-13c4-444a-ad4e-8135ae4d919b",
      "code": "class Solution:\n  def isArraySpecial(self, nums: list[int]) -> bool:\n    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))",
      "title": "3151. Special Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40c584df-25c8-4a7d-a027-345c2ca886de",
      "code": "class Solution:\n  def isArraySpecial(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    id = 0\n    # parityIds[i] := the id of the parity group that nums[i] belongs to\n    parityIds = [id]\n\n    for a, b in itertools.pairwise(nums):\n      if a % 2 == b % 2:\n        id += 1\n      parityIds.append(id)\n\n    for _from, to in queries:\n      ans.append(parityIds[_from] == parityIds[to])\n\n    return ans",
      "title": "3152. Special Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945ce522-1dcd-43e9-9a96-cb36df0865f3",
      "code": "class Solution:\n  def sumDigitDifferences(self, nums: list[int]) -> int:\n    n = len(nums)\n    digitSize = len(str(nums[0]))\n    ans = 0\n\n    denominator = 1\n    for _ in range(digitSize):\n      count = [0] * 10\n      for num in nums:\n        count[num // denominator % 10] += 1\n      ans += sum(freq * (n - freq) for freq in count)\n      denominator *= 10\n\n    return ans // 2",
      "title": "3153. Sum of Digit Differences of All Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69041ef7-5258-4b47-a9be-437359342707",
      "code": "class Solution:\n  def waysToReachStair(self, k: int) -> int:\n    # Let's say we have `down` operation 1 and `jump` operation 2.\n    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    # => 1 + (2^jump - 1) - down = k.\n    # => down = 2^jump - k.\n    # Since `down` operations cannot be used consecutively, there're jump + 1\n    # positions (before and after each `jump`) for  `down`. The maximum jump is\n    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    # being the maximum value of 10^9.\n    MAX_JUMP = 29\n    ans = 0\n\n    for jump in range(MAX_JUMP + 1):\n      down = (1 << jump) - k\n      if down < 0 or down > jump + 1:\n        continue\n      ans += math.comb(jump + 1, down)\n\n    return ans",
      "title": "3154. Find Number of Ways to Reach the K-th Stair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a3e7372-8322-412b-bb78-a0c48654b2fd",
      "code": "class Solution:\n  def maxUpgrades(\n      self,\n      count: list[int],\n      upgrade: list[int],\n      sell: list[int],\n      money: list[int],\n  ) -> list[int]:\n    # If there's enough money, upgrade all servers; otherwise, optimize by\n    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    # Therefore, x = (money + count * sell) / (sell + upgrade).\n    return [min(c, (m + c * s) // (s + u))\n            for c, u, s, m in zip(count, upgrade, sell, money)]",
      "title": "3155. Maximum Number of Upgradable Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b039320c-1b55-4707-b9f4-95bdf433178a",
      "code": "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    ans = 0\n    minLevelSum = math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum < minLevelSum:\n        minLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "3157. Find the Level of Tree with Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afb4cd37-ce43-4b4e-9410-8571f9f8551e",
      "code": "class Solution:\n  def duplicateNumbersXOR(self, nums):\n    count = collections.Counter(nums)\n    return functools.reduce(\n        operator.xor, [num for num, freq in count.items() if freq == 2],\n        0)",
      "title": "3158. Find the XOR of Numbers Which Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b05ada3a-57ee-43d1-bae9-7c032e3db1ba",
      "code": "class Solution:\n  def occurrencesOfElement(\n      self,\n      nums: list[int],\n      queries: list[int],\n      x: int,\n  ) -> list[int]:\n    indices = [i for i, num in enumerate(nums) if num == x]\n    return [indices[query - 1] if query <= len(indices) else -1\n            for query in queries]",
      "title": "3159. Find Occurrences of an Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd35c0b7-a185-4e1a-a1b2-de48efea6f0e",
      "code": "class Solution:\n  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    ballToColor = {}\n    colorCount = collections.Counter()\n\n    for ball, color in queries:\n      if ball in ballToColor:\n        prevColor = ballToColor[ball]\n        colorCount[prevColor] -= 1\n        if colorCount[prevColor] == 0:\n          del colorCount[prevColor]\n      ballToColor[ball] = color\n      colorCount[color] += 1\n      ans.append(len(colorCount))\n\n    return ans",
      "title": "3160. Find the Number of Distinct Colors Among the Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfa40ca1-9704-4380-b418-2fba5feb6da0",
      "code": "from sortedcontainers import SortedList\n\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowtree(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowtree(i)\n    return res\n\n  @staticmethod\n  def lowtree(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getResults(self, queries: list[list[int]]) -> list[bool]:\n    n = min(50000, len(queries) * 3)\n    ans = []\n    tree = FenwickTree(n + 1)\n    obstacles = SortedList([0, n])  # sentinel values\n\n    for query in queries:\n      type = query[0]\n      if type == 1:\n        x = query[1]\n        obstacles.add(x)\n\n    for x1, x2 in itertools.pairwise(obstacles):\n      tree.maximize(x2, x2 - x1)\n\n    for query in reversed(queries):\n      type = query[0]\n      x = query[1]\n      if type == 1:\n        i = obstacles.index(x)\n        next = obstacles[i + 1]\n        prev = obstacles[i - 1]\n        obstacles.remove(x)\n        tree.maximize(next, next - prev)\n      else:\n        sz = query[2]\n        i = obstacles.bisect_right(x)\n        prev = obstacles[i - 1]\n        ans.append(tree.get(prev) >= sz or x - prev >= sz)\n\n    return ans[::-1]",
      "title": "3161. Block Placement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea080363-eb17-46db-977a-7d9e69a20644",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    return sum(num1 % (num2 * k) == 0\n               for num1 in nums1\n               for num2 in nums2)",
      "title": "3162. Find the Number of Good Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eb51301-44c2-4952-bb79-2721f5ef9eff",
      "code": "class Solution:\n  def compressedString(self, word: str) -> str:\n    n = len(word)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      count = 0\n      while j < n and word[j] == word[i] and count < 9:\n        j += 1\n        count += 1\n      ans.append(str(count) + word[i])\n      i = j\n\n    return ''.join(ans)",
      "title": "3163. String Compression III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26afc4bf-2e24-4dc9-ad35-1f3b86ab8309",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    count = collections.Counter(num * k for num in nums2)\n    ans = 0\n\n    for num in nums1:\n      for divisor in range(1, int(num ** 0.5) + 1):\n        if num % divisor == 0:\n          ans += count[divisor]\n          if num // divisor != divisor:\n            ans += count[num // divisor]\n\n    return ans",
      "title": "3164. Find the Number of Good Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9e2869d-23c2-46e8-b99b-505afce35bcf",
      "code": "class Solution:\n  def betterCompression(self, compressed: str) -> str:\n    count = collections.Counter()\n    i = 0\n\n    while i < len(compressed):\n      c = compressed[i]\n      i += 1\n      freq = 0\n      while i < len(compressed) and compressed[i].isdigit():\n        freq = freq * 10 + int(compressed[i])\n        i += 1\n      count[c] += freq\n\n    return ''.join([c + str(count[c])\n                    for c in sorted(count.keys())])",
      "title": "3167. Better Compression of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0069ef6-4e9b-43d6-b82c-b8a437aadda5",
      "code": "class Solution:\n  def minimumChairs(self, s: str) -> int:\n    ans = 0\n    chairs = 0\n\n    for c in s:\n      chairs += 1 if c == 'E' else -1\n      ans = max(ans, chairs)\n\n    return ans",
      "title": "3168. Minimum Number of Chairs in a Waiting Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24daac48-0287-4f8b-9fce-6f5fdaf00f09",
      "code": "class Solution:\n  def countDays(self, days: int, meetings: list[list[int]]) -> int:\n    freeDays = 0\n    prevEnd = 0\n\n    for start, end in sorted(meetings):\n      if start > prevEnd:\n        freeDays += start - prevEnd - 1\n      prevEnd = max(prevEnd, end)\n\n    return freeDays + max(0, days - prevEnd)",
      "title": "3169. Count Days Without Meetings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fc3d00f-9197-4058-b853-3e2f53c7334b",
      "code": "class Solution:\n  def clearStars(self, s: str) -> str:\n    ans = list(s)\n    buckets = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      if c == '*':\n        ans[i] = ''\n        j = next(j for j, bucket in enumerate(buckets) if bucket)\n        ans[buckets[j].pop()] = ''\n      else:\n        buckets[ord(c) - ord('a')].append(i)\n\n    return ''.join(ans)",
      "title": "3170. Lexicographically Minimum String After Removing Stars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8d5017b-10a0-4a17-a6fa-8aaa6928494e",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in nums:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the OR operation, the size of `next_set` will be at most\n      # bin(num).count('1') + 1.\n      dp = {num} | {val | num for val in dp}\n      ans = min(ans, min(abs(k - val) for val in dp))\n\n    return ans",
      "title": "3171. Find Subarray With Bitwise AND Closest to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94fd900a-fb58-4d4d-92d0-c62405b5f3c0",
      "code": "class Solution:\n  def orArray(self, nums: list[int]) -> list[int]:\n    return [a | b for a, b in itertools.pairwise(nums)]",
      "title": "3173. Bitwise OR of Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe50bc98-54f4-4932-8617-0ad17421f2f4",
      "code": "class Solution:\n  def clearDigits(self, s: str) -> str:\n    ans = []\n\n    for c in s:\n      if c.isdigit():\n        # Since `ans` only contains non-digit characters, removing the last\n        # character is equivalent to deleting the closest non-digit character.\n        ans.pop()\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3174. Clear Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd0adf5-03d0-42cc-8a3c-197c1df46f07",
      "code": "class Solution:\n  # Similar to 1535. Find the Winner of an Array Game\n  def findWinningPlayer(self, skills: list[int], k: int) -> int:\n    ans = 0\n    wins = 0\n\n    i = 1\n    while i < len(skills) and wins < k:\n      if skills[i] > skills[ans]:\n        ans = i\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "3175. Find The First Player to win K Games in a Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98bb31ef-b0a2-4f9d-a58a-0286a1e32b4e",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3176. Find the Maximum Length of a Good Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39bdda2e-d29b-47e4-bf50-c23c722acc9e",
      "code": "class Solution:\n  # Same as 3176. Find the Maximum Length of a Good Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3177. Find the Maximum Length of a Good Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32f90167-90d6-4fb9-a9a9-2e78fcae8b09",
      "code": "class Solution:\n  def numberOfChild(self, n: int, k: int) -> int:\n    # the time for the ball to return to 0\n    roundTime = 2 * (n - 1)\n    pos = k % roundTime\n    return pos if pos < n else roundTime - pos",
      "title": "3178. Find the Child Who Has the Ball After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cc8c06a-4679-4ed6-9c8e-f61794264ecc",
      "code": "class Solution:\n  def valueAfterKSeconds(self, n: int, k: int) -> int:\n    return math.comb(n + k - 1, n - 1) % 1_000_000_007",
      "title": "3179. Find the N-th Value After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9abf6f0f-7d48-46bd-b155-e8c0f06de5b9",
      "code": "# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n# `rewardValue` is achievable in O(1).\n#\n# Let's use `rewardValues = [1, 3, 4]` as an example.\n#\n# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n# Therefore, we can set the size of the bitset to 8 to represent possible\n# total rewards from 0 to 7.\n#\n# Let's define a bitset `dp` to record whether each total reward is\n# achievable. dp[num] = true if reward `num` is achievable.\n#\n# Initially, dp = 0b00000001 := reward 0 is achievable.\n#\n# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n#   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n#\n# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n#\n# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n#\n# Therefore, the maximum total reward is 7.\n\nclass Solution:\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3180. Maximum Total Reward Using Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "475da838-1283-4465-b639-ad20cb9654c5",
      "code": "class Solution:\n  # Same as 3180. Maximum Total Reward Using Operations I\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3181. Maximum Total Reward Using Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e689de9c-fd48-4ef5-a706-f4f60759df17",
      "code": "class Solution:\n  def numberOfWays(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    dp = [1] + [0] * n\n\n    for coin in (1, 2, 6):\n      for i in range(coin, n + 1):\n        dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    ans = dp[n]\n    if n - 4 >= 0:\n      ans = (ans + dp[n - 4]) % MOD\n    if n - 8 >= 0:\n      ans = (ans + dp[n - 8]) % MOD\n    return ans",
      "title": "3183. The Number of Ways to Make the Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94e0ab23-77a6-47a7-9aee-c054e3b395c4",
      "code": "class Solution:\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3184. Count Pairs That Form a Complete Day I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d02146ec-0e89-4cda-9abe-11c06228cbc3",
      "code": "class Solution:\n  # Same as 3184. Count Pairs That Form a Complete Day I\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3185. Count Pairs That Form a Complete Day II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a681f46-8909-4092-b3e0-c22fd041b4fa",
      "code": "class Solution:\n  def maximumTotalDamage(self, power: list[int]) -> int:\n    count = collections.Counter(power)\n    uniqueDamages = sorted(count.keys())\n    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    # indicates if the i-th damage is used\n    dp = [[0] * 2 for _ in range(len(uniqueDamages))]\n\n    for i, damage in enumerate(uniqueDamages):\n      if i == 0:\n        dp[0] = [0, damage * count[damage]]\n        continue\n      dp[i][0] = max(dp[i - 1])\n      dp[i][1] = damage * count[damage]\n      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):\n        dp[i][1] += max(dp[i - 1])\n      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:\n        dp[i][1] += max(dp[i - 2])\n      elif i >= 3:\n        dp[i][1] += max(dp[i - 3])\n\n    return max(dp[-1])",
      "title": "3186. Maximum Total Damage With Spell Casting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e8b2645-3139-4b4b-b9d6-b6593ad6c3f7",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countOfPeaks(\n      self,\n      nums: list[int],\n      queries:\n      list[list[int]],\n  ) -> list[int]:\n    ans = []\n    peak = [0] + [int(a < b > c)\n                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]\n    tree = FenwickTree(len(peak))\n\n    for i, p in enumerate(peak):\n      tree.add(i + 1, p)\n\n    def update(i: int) -> None:\n      \"\"\"\n      Update the peak array and Fenwick tree if the peak status of nums[i]\n      changes.\n      \"\"\"\n      newPeak = self._isPeak(nums, i)\n      if newPeak != peak[i]:\n        tree.add(i + 1, newPeak - peak[i])\n        peak[i] = newPeak\n\n    for query in queries:\n      if query[0] == 1:\n        l = query[1]\n        r = query[2]\n        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))\n      elif query[0] == 2:\n        index = query[1]\n        val = query[2]\n        nums[index] = val\n        update(index)\n        if index > 0:\n          update(index - 1)\n        if index + 1 < len(nums):\n          update(index + 1)\n\n    return ans\n\n  def _isPeak(self, nums: list[int], i: int) -> bool:\n    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]",
      "title": "3187. Peaks in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba48dd0d-9844-47b7-91df-e42b3d907f47",
      "code": "class Solution:\n  def minMoves(self, rooks: list[list[int]]) -> int:\n    n = len(rooks)\n    sortedByRow = sorted(rooks, key=lambda x: x[0])\n    sortedByCol = sorted(rooks, key=lambda x: x[1])\n    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +\n            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))",
      "title": "3189. Minimum Moves to Get a Peaceful Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f25d0078-64e5-4859-8dd0-9ff62527c5f5",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return sum(num % 3 != 0 for num in nums)",
      "title": "3190. Find Minimum Operations to Make All Elements Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1018b4b-f75a-49cc-84d6-0de0736670ba",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2):\n      if nums[i] == 0:\n        nums[i + 1] ^= 1\n        nums[i + 2] ^= 1\n        ans += 1\n\n    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans",
      "title": "3191. Minimum Operations to Make Binary Array Elements Equal to One I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d43d3fd3-a70e-4016-8853-b2f72d5b9c7b",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    target = 1\n\n    for num in nums:\n      if num != target:\n        ans += 1\n        target ^= 1\n\n    return ans",
      "title": "3192. Minimum Operations to Make Binary Array Elements Equal to One II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598b4c3b-88dc-4ed9-a766-908fdb3bfaea",
      "code": "class Solution:\n  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    # dp[i][j] := the number of ways to arrange the first i numbers of the\n    # permutation s.t. there are j inversions\n    dp = [[0] * (MAX_INVERSIONS + 1) for _ in range(n + 1)]\n    endToCnt = {end + 1: cnt for end, cnt in requirements}\n\n    # There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1\n\n    for i in range(2, n + 1):\n      for newInversions in range(i):\n        for j in range(MAX_INVERSIONS - newInversions + 1):\n          inversionsAfterInsertion = j + newInversions\n          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:\n            continue\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j]\n          dp[i][inversionsAfterInsertion] %= MOD\n\n    return dp[n][endToCnt[n]]",
      "title": "3193. Count the Number of Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a010b3a-3972-42f3-a399-68ceef355fe2",
      "code": "class Solution:\n  def minimumAverage(self, nums: list[int]) -> float:\n    nums.sort()\n    return min((nums[i] + nums[~i]) / 2\n               for i in range(len(nums) // 2 + 1))",
      "title": "3194. Minimum Average of Smallest and Largest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52e3d2c5-ec2a-45e8-bbb5-4caf1d082a96",
      "code": "class Solution:\n  def minimumArea(self, grid: list[list[int]]) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3195. Find the Minimum Area to Cover All Ones I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fc3e9de-643a-4430-b8ac-6d15e6c71599",
      "code": "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    # A small trick so that we don't need to handle the edge case and can use\n    # ranged-based for loop.\n    keep = -math.inf  # the maximum cost if the last number is kept\n    flip = 0  # the maximum cost if the last number is flipped\n\n    for num in nums:\n      keep, flip = max(keep, flip) + num, keep - num\n\n    return max(keep, flip)",
      "title": "3196. Maximize Total Cost of Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76a61d14-3e8c-40ed-a232-d1e2f7e896b0",
      "code": "class Solution:\n  def minimumSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m * n\n\n    for i in range(m):\n      top = self._minimumArea(grid, 0, i, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, top +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for i in range(m):\n      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, bottom +\n                  self._minimumArea(grid, 0, i - 1, 0, j) +\n                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))\n\n    for j in range(n):\n      left = self._minimumArea(grid, 0, m - 1, 0, j)\n      for i in range(m):\n        ans = min(ans, left +\n                  self._minimumArea(grid, 0, i, j + 1, n - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for j in range(n):\n      right = self._minimumArea(grid, 0, m - 1, j, n - 1)\n      for i in range(m):\n        ans = min(ans, right +\n                  self._minimumArea(grid, 0, i, 0, j - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))\n\n    for i1 in range(m):\n      for i2 in range(i1 + 1, m):\n        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +\n                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))\n\n    for j1 in range(n):\n      for j2 in range(j1 + 1, n):\n        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +\n                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))\n\n    return ans\n\n  def _minimumArea(\n      self,\n      grid: list[list[int]],\n      si: int,\n      ei: int,\n      sj: int,\n      ej: int,\n  ) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n    for i in range(si, ei + 1):\n      for j in range(sj, ej + 1):\n        if grid[i][j] == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3197. Find the Minimum Area to Cover All Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2714a6cd-2601-4343-92a9-d981d4f404a7",
      "code": "class Solution:\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3199. Count Triplets with Even XOR Set Bits I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1909c459-c252-4c6d-86b7-32b2deda04bd",
      "code": "class Solution:\n  def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n    return max(self._maxHeight(red, blue),\n               self._maxHeight(blue, red))\n\n  def _maxHeight(self, n1: int, n2: int) -> int:\n    \"\"\"\n    Returns the maximum height of a triangle with the odd levels having `n1`\n    balls and the even levels having `n2` balls.\n    \"\"\"\n    #             1 + 3 + ... + h <= n1\n    # ((1 + h) * (n + 1) / 2) / 2 <= n1\n    #                           h <= sqrt(4 * n1) - 1\n    oddHeight = math.isqrt(4 * n1) - 1\n    #       2 + 4 + ... + h <= n2\n    # ((2 + h) * h / 2) / 2 <= n2\n    #                     h <= sqrt(4 * n2 + 1) - 1\n    evenHeight = math.isqrt(4 * n2 + 1) - 1\n    # If the difference between the odd and even heights is >= 1, we can add an\n    # extra level to the minimum height.\n    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1\n                                         else 0)",
      "title": "3200. Maximum Height of a Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5ef95a0-e26a-45cc-a76d-c479894476e6",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * 2 for _ in range(2)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(2):\n        dp[x % 2][y] = dp[y][x % 2] + 1\n\n    return max(map(max, dp))",
      "title": "3201. Find the Maximum Length of Valid Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b5e54eb-7dcc-41fa-9ae8-5c225d3da411",
      "code": "class Solution:\n  # Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * k for _ in range(k)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(k):\n        dp[x % k][y] = dp[y][x % k] + 1\n\n    return max(map(max, dp))",
      "title": "3202. Find the Maximum Length of Valid Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27eae645-64fe-4fc3-82ce-6e377f3cdd83",
      "code": "class Solution:\n  def minimumDiameterAfterMerge(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n  ) -> int:\n    diameter1 = self._getDiameter(edges1)\n    diameter2 = self._getDiameter(edges2)\n    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1\n    return max(diameter1, diameter2, combinedDiameter)\n\n  def _getDiameter(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    maxDiameter = [0]\n    self._maxDepth(graph, 0, -1, maxDiameter)\n    return maxDiameter[0]\n\n  # Similar to 1522. Diameter of N-Ary Tree\n  def _maxDepth(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      maxDiameter: list[int],\n  ) -> int:\n    \"\"\"Returns the maximum depth of the subtree rooted at u.\"\"\"\n    maxSubDepth1 = 0\n    maxSubDepth2 = 0\n    for v in graph[u]:\n      if v == prev:\n        continue\n      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)\n      if maxSubDepth > maxSubDepth1:\n        maxSubDepth2 = maxSubDepth1\n        maxSubDepth1 = maxSubDepth\n      elif maxSubDepth > maxSubDepth2:\n        maxSubDepth2 = maxSubDepth\n    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)\n    return 1 + maxSubDepth1",
      "title": "3203. Find Minimum Diameter After Merging Two Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e09b8512-7086-49f3-bea7-fabdac2223c7",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i] := the maximum score to jump from index i to n - 1\n    dp = [0] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        # Jump from i to j, and then jump from j to n - 1.\n        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])\n\n    return dp[0]",
      "title": "3205. Maximum Array Hopping Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f474949b-58a0-4ab2-ae4d-a36c6b5b603a",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int]) -> int:\n    n = len(colors)\n    return sum(colors[i] != colors[i - 1] and\n               colors[i] != colors[(i + 1) % n]\n               for i in range(n))",
      "title": "3206. Alternating Groups I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6921787-eb73-437a-b99d-ead675080acb",
      "code": "class Solution:\n  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:\n    minEnergy = min(enemyEnergies)\n    return (0 if currentEnergy < minEnergy\n            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)",
      "title": "3207. Maximum Points After Enemy Battles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c422bccf-7d7a-45af-beae-186b1e0c4d9a",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:\n    n = len(colors)\n    ans = 0\n    alternating = 1\n\n    for i in range(n + k - 2):\n      alternating = (1 if colors[i % n] == colors[(i - 1) % n]\n                     else alternating + 1)\n      if alternating >= k:\n        ans += 1\n\n    return ans",
      "title": "3208. Alternating Groups II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5e4ee4-107c-429c-8575-00a0aa76d170",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # the counter of all the values of subarrays that end in the previous\n    # number\n    prev = collections.Counter()\n\n    for num in nums:\n      # Extend each subarray that ends in the previous number. Due to\n      # monotonicity of the AND operation, the size of `curr` will be at most\n      # num.bit_count() + 1.\n      curr = collections.Counter({num: 1})\n      for val, freq in prev.items():\n        curr[val & num] += freq\n      ans += curr[k]\n      prev = curr\n\n    return ans",
      "title": "3209. Number of Subarrays With AND Value of K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9947436b-88b1-4fed-9f6f-b060a02f73db",
      "code": "class Solution:\n  def getEncryptedString(self, s: str, k: int) -> str:\n    k %= len(s)\n    return s[k:] + s[0:k]",
      "title": "3210. Find the Encrypted String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04646afa-31fb-4bea-9c95-b10a804026c9",
      "code": "class Solution:\n  def validStrings(self, n: int) -> list[str]:\n    ans = []\n\n    def dfs(n: int, s: list[str]) -> None:\n      if n == 0:\n        ans.append(''.join(s))\n        return\n      if not s or s[-1] == '1':\n        s.append('0')\n        dfs(n - 1, s)\n        s.pop()\n      s.append('1')\n      dfs(n - 1, s)\n      s.pop()\n\n    dfs(n, [])\n    return ans",
      "title": "3211. Generate Binary Strings Without Adjacent Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ccd31b9-cd55-4093-9155-e7f94fbfc5bc",
      "code": "class Solution:\n  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    x = [[0] * (n + 1) for _ in range(m + 1)]\n    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    y = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]\n        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]\n        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:\n          ans += 1\n\n    return ans",
      "title": "3212. Count Submatrices With Equal Frequency of X and Y",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fe9d3e5-eadf-4cac-8ac1-3507dcb02ca6",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0..i)\n    dp = [0] + [math.inf] * n\n    # minCost[c][word] := the minimum cost to construct word starting with `c`\n    minCost: dict[str, dict[str, int]] = collections.defaultdict(dict)\n\n    for word, cost in zip(words, costs):\n      c = word[0]\n      minCost[c][word] = min(minCost[c].get(word, math.inf), cost)\n\n    for i, c in enumerate(target):\n      for word, cost in minCost[c].items():\n        j = i + len(word)\n        if j <= n and cost + dp[i] < dp[j] and target[i:j] == word:\n          dp[j] = cost + dp[i]\n\n    return -1 if dp[n] == math.inf else dp[n]",
      "title": "3213. Construct String with Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b284e6bf-066a-4663-93ec-1bf973032cfc",
      "code": "class Solution:\n  # Same as 3199. Count Triplets with Even XOR Set Bits I\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3215. Count Triplets with Even XOR Set Bits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47e99645-35b0-456a-99ba-3587f043f6bd",
      "code": "class Solution:\n  def getSmallestString(self, s: str) -> str:\n    chars = list(s)\n    for i, (a, b) in enumerate(itertools.pairwise(chars)):\n      if ord(a) % 2 == ord(b) % 2 and a > b:\n        chars[i], chars[i + 1] = chars[i + 1], chars[i]\n        return ''.join(chars)\n    return s",
      "title": "3216. Lexicographically Smallest String After a Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cfd1309-b778-4855-b8ae-6386d78b5cdf",
      "code": "class Solution:\n  def modifiedList(\n      self,\n      nums: list[int],\n      head: ListNode | None,\n  ) -> ListNode | None:\n    dummy = ListNode(0, head)\n    numsSet = set(nums)\n\n    curr = dummy\n    while curr.next:\n      if curr.next.val in numsSet:\n        curr.next = curr.next.next\n      else:\n        curr = curr.next\n\n    return dummy.next",
      "title": "3217. Delete Nodes From Linked List Present in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54755c25-febc-4b56-a0e4-68b8f44d0ec7",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3218. Minimum Cost for Cutting Cake I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bddebf14-32ed-43eb-87fa-afa64c07194b",
      "code": "class Solution:\n  # Same as 3218. Minimum Cost for Cutting Cake I\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3219. Minimum Cost for Cutting Cake II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac59998b-b72f-4153-a55c-92a67c9800a2",
      "code": "class Solution:\n  # Same as 3205. Maximum Array Hopping Score I\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))",
      "title": "3221. Maximum Array Hopping Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ffdc13-aa35-4204-8176-fcda8a928a4d",
      "code": "class Solution:\n  def losingPlayer(self, x: int, y: int) -> str:\n    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'",
      "title": "3222. Find the Winning Player in Coin Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c261ec70-1172-4908-b9b9-d3f65ed32783",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    count = collections.Counter(s)\n    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())",
      "title": "3223. Minimum Length of String After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "189beb08-ad36-426f-a8c7-ae2763b67cca",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    pairSize = len(nums) // 2\n    diffCount = collections.Counter()  # {nums[-1 - i] - nums[i]: freq}\n    # oneChangeCount[i] := the number of pairs that need only one change to\n    # to achieve a difference of `i`\n    oneChangeCount = [0] * (k + 1)\n\n    for i in range(pairSize):\n      a = nums[i]\n      b = nums[-1 - i]\n      diffCount[abs(a - b)] += 1\n      oneChangeCount[max(a, b, k - a, k - b)] += 1\n\n    # prefixOneChangeCount[i] := the number of pairs that need only one change\n    # to achieve a difference >= `i`\n    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    prefixOneChangeCount = list(\n        itertools.accumulate(reversed(oneChangeCount)))[::-1]\n\n    return min(prefixOneChangeCount[diff] - freq +  # one change\n               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes\n               for diff, freq in diffCount.items())",
      "title": "3224. Minimum Array Changes to Make Differences Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "394735f6-7c4f-4959-be65-d26d0ad19220",
      "code": "class Solution:\n  def maximumScore(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    # prefix[j][i] := the sum of the first i elements in the j-th column\n    prefix = [[0] * (n + 1) for _ in range(n)]\n    # prevPick[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the previous column is in row (i - 1)\n    prevPick = [0] * (n + 1)\n    # prevSkip[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the column before the previous one is in\n    # row (i - 1)\n    prevSkip = [0] * (n + 1)\n\n    for j in range(n):\n      for i in range(n):\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j]\n\n    for j in range(1, n):\n      currPick = [0] * (n + 1)\n      currSkip = [0] * (n + 1)\n      # Consider all possible combinations of the number of current and\n      # previous selected elements.\n      for curr in range(n + 1):  # the number of current selected elements\n        for prev in range(n + 1):  # the number of previous selected elements\n          if curr > prev:\n            # 1. The current bottom is deeper than the previous bottom.\n            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.\n            score = prefix[j - 1][curr] - prefix[j - 1][prev]\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)\n          else:\n            # 2. The previous bottom is deeper than the current bottom.\n            # Get the score of grid[curr..prev)[j] for pick only.\n            score = prefix[j][prev] - prefix[j][curr]\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevPick[prev])\n      prevPick = currPick\n      prevSkip = currSkip\n\n    return max(prevPick)",
      "title": "3225. Maximum Score From Grid Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21473fe0-9712-494a-b0d9-0adeee60faee",
      "code": "class Solution:\n  def minChanges(self, n: int, k: int) -> int:\n    # n needs to be a superset of k.\n    return (n ^ k).bit_count() if (n & k) == k else -1",
      "title": "3226. Number of Bit Changes to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35b05ba0-0146-4852-b55f-2d684009faef",
      "code": "class Solution:\n  def doesAliceWin(self, s: str) -> bool:\n    # Let k be the number of vowels in s.\n    # 1. If k == 0, Bob wins since Alice has no vowels to pick.\n    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.\n    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,\n    # then Bob will either pick a substring containing 0 vowels, resulting in\n    # Alice picking the remaining entire string, or Bob couldn't pick at all\n    # (the last vowel).\n    VOWELS = 'aeiou'\n    return any(c in VOWELS for c in s)",
      "title": "3227. Vowels Game in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a108eed-e8ab-4083-a86d-cd30238a6bad",
      "code": "class Solution:\n  def maxOperations(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      elif i + 1 == len(s) or s[i + 1] == '1':\n        ans += ones\n\n    return ans",
      "title": "3228. Maximum Number of Operations to Move Ones to the End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7bc8bfc-bc25-406d-9532-b38203cf4d2a",
      "code": "class Solution:\n  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array\n  def minimumOperations(self, nums: list[int], target: list[int]) -> int:\n    ans = abs(nums[0] - target[0])\n\n    for (prevNum, prevTarget), (currNum, currTarget) in (\n        itertools.pairwise(zip(nums, target))\n    ):\n      currDiff = currTarget - currNum\n      prevDiff = prevTarget - prevNum\n      if currDiff >= 0 and prevDiff >= 0:\n        ans += max(0, currDiff - prevDiff)\n      elif currDiff <= 0 and prevDiff <= 0:\n        ans += max(0, abs(currDiff) - abs(prevDiff))\n      else:\n        ans += abs(currDiff)\n\n    return ans",
      "title": "3229. Minimum Operations to Make Array Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eb9c2a1-d98f-4222-b962-31adec66a534",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return self._lengthOfLIS(nums[::-1])\n\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num >= tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_right(tails, num)] = num\n    return len(tails)",
      "title": "3231. Minimum Number of Increasing Subsequence to Be Removed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0f91c5f-2949-4b9a-941c-b75a4d232145",
      "code": "class Solution:\n  def canAliceWin(self, nums: list[int]) -> bool:\n    return sum(num if num < 10 else -num for num in nums) != 0",
      "title": "3232. Find if Digit Game Can Be Won",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f69882b2-463b-49b8-b6b9-15c9f39303e3",
      "code": "class Solution:\n  def nonSpecialCount(self, l: int, r: int) -> int:\n    maxRoot = math.isqrt(r)\n    isPrime = self._sieveEratosthenes(maxRoot + 1)\n    specialCount = 0\n\n    for num in range(2, math.isqrt(r) + 1):\n      if isPrime[num] and l <= num**2 <= r:\n        specialCount += 1\n\n    return r - l + 1 - specialCount\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3233. Find the Count of Numbers Which Are Not Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6e4faab-2b2b-42ea-8cc1-3f2d2e569de4",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    #    z^2 + z = n.\n    # => z^2 + z - n = 0.\n    # => z = (-1 + sqrt(1 + 4n)) / 2.\n    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2\n\n    # Iterate through all possible number of 0s.\n    for zero in range(int(maxZero) + 1):\n      lastInvalidPos = -1\n      count = [0, 0]\n      l = 0\n      for r, c in enumerate(s):\n        count[int(c)] += 1\n        # Try to shrink the window to maintain the \"minimum\" length of the\n        # valid substring.\n        while l < r:\n          if s[l] == '0' and count[0] > zero:\n            count[0] -= 1  # Remove an extra '0'.\n            lastInvalidPos = l\n            l += 1\n          elif s[l] == '1' and count[1] - 1 >= zero * zero:\n            count[1] -= 1  # Remove an extra '1'.\n            l += 1\n          else:\n            break  # Cannot remove more characters.\n        if count[0] == zero and count[1] >= zero * zero:\n          # Add valid substrings ending in s[r] to the answer. They are\n          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos\n\n    return ans",
      "title": "3234. Count the Number of Substrings With Dominant Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a7fd476-2e44-4c49-885b-2d6a35522ddc",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canReachCorner(self, X: int, Y: int, circles: list[list[int]]) -> bool:\n    n = len(circles)\n    # Add two virtual nodes, where node n represents (0, 0) and node n + 1\n    # represents (X, Y).\n    uf = UnionFind(n + 2)\n\n    # Iterate through each circle.\n    for i, (x, y, r) in enumerate(circles):\n      # Union the current circle with the node (0, 0) if the circle overlaps\n      # with the left or top edges.\n      if x - r <= 0 or y + r >= Y:\n        uf.unionByRank(i, n)\n      # Union the current circle with the node (X, Y) if the circle overlaps\n      # with the right or bottom edges.\n      if x + r >= X or y - r <= 0:\n        uf.unionByRank(i, n + 1)\n      # Union the current circle with previous circles if they overlap.\n      for j in range(i):\n        x2, y2, r2 = circles[j]\n        if (x - x2)**2 + (y - y2)**2 <= (r + r2)**2:\n          uf.unionByRank(i, j)\n\n    # If nodes (0, 0) and (X, Y) are in the same union set, that means there's\n    # a path of overlapping circles that connects the left or top edges to the\n    # right or bottom edges, implying that (0, 0) cannot reach (X, Y).\n    return uf.find(n) != uf.find(n + 1)",
      "title": "3235. Check if the Rectangle Corner Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bca72fae-d3c2-47bd-a613-a1b4d3ffb47d",
      "code": "class Solution:\n  def simulationResult(\n      self,\n      windows: list[int],\n      queries: list[int],\n  ) -> list[int]:\n    ans = []\n    seen = set()\n\n    for query in reversed(queries):\n      if query not in seen:\n        ans.append(query)\n        seen.add(query)\n\n    for window in windows:\n      if window not in seen:\n        ans.append(window)\n        seen.add(window)\n\n    return ans",
      "title": "3237. Alt and Tab Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd16843d-070c-4027-ac5d-7a02a40e6251",
      "code": "class Solution:\n  def winningPlayerCount(self, n: int, pick: list[list[int]]) -> int:\n    counts = [collections.Counter() for _ in range(n)]\n    for player, color in pick:\n      counts[player][color] += 1\n    return sum(max(count.values(), default=0) > i\n               for i, count in enumerate(counts))",
      "title": "3238. Find the Number of Winning Players",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18e624e6-338d-4855-a9d8-fa76cd83415c",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    rowFlips = sum(row[i] != row[-1 - i]\n                   for row in grid for i in range(len(row) // 2))\n    colFlips = sum(col[i] != col[-1 - i] for col in zip(*grid)\n                   for i in range(len(col) // 2))\n    return min(rowFlips, colFlips)",
      "title": "3239. Minimum Number of Flips to Make Binary Grid Palindromic I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74ee0203-208f-475e-8eb3-0208a0999ec8",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    middleOnes = 0\n    mismatchedPairs = 0\n\n    # Handle top-left, top-right, bottom-left, bottom-right cells.\n    for i in range(m // 2):\n      for j in range(n // 2):\n        ones = (grid[i][j] + grid[i][n - 1 - j] +\n                grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j])\n        ans += min(ones, 4 - ones)\n\n    # Handle the middle row if the number of m is odd.\n    if m % 2 == 1:\n      for j in range(n // 2):\n        leftCell = grid[m // 2][j]\n        rightCell = grid[m // 2][n - 1 - j]\n        mismatchedPairs += leftCell ^ rightCell\n        middleOnes += leftCell + rightCell\n\n    # Handle the middle column if the number of columns is odd.\n    if n % 2 == 1:\n      for i in range(m // 2):\n        topCell = grid[i][n // 2]\n        bottomCell = grid[m - 1 - i][n // 2]\n        mismatchedPairs += topCell ^ bottomCell\n        middleOnes += topCell + bottomCell\n\n    if mismatchedPairs == 0:\n      # Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.\n      if middleOnes % 4 == 2:\n        ans += 2  # Flip two 1s to 0s.\n    else:\n      # Flip every mismatched pair 01 to 00 or 11. It doesn't matter.\n      ans += mismatchedPairs\n\n    # Handle the center cell if both dimensions are odd.\n    if m % 2 == 1 and n % 2 == 1:\n      ans += grid[m // 2][n // 2]\n\n    return ans",
      "title": "3240. Minimum Number of Flips to Make Binary Grid Palindromic II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45029197-672b-4a4c-8d93-60d73f2eea86",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time taken to mark the entire subtree rooted at the node\n\n\nclass Top2:\n  def __init__(self, top1: Node = Node(), top2: Node = Node()):\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the maximum\n    self.top1 = top1\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the second maximum\n    self.top2 = top2\n\n\nclass Solution:\n  def timeTaken(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the top two direct child nodes for subtree rooted at node i,\n    # where each node contains the time taken to mark the entire subtree rooted\n    # at the node itself\n    dp = [Top2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, 0, dp, ans)\n    return ans\n\n  def _getTime(self, u: int) -> int:\n    \"\"\"Returns the time taken to mark node u.\"\"\"\n    return 2 if u % 2 == 0 else 1\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Top2]\n  ) -> int:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the top two direct\n    child nodes, where the time taken to mark the subtree rooted at each of the\n    child nodes is maximized, and returns the top child node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    top1 = Node()\n    top2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      time = self._dfs(tree, v, u, dp) + self._getTime(v)\n      if time >= top1.time:\n        top2 = top1\n        top1 = Node(v, time)\n      elif time > top2.time:\n        top2 = Node(v, time)\n    dp[u] = Top2(top1, top2)\n    return top1.time\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      maxTime: int,\n      dp: list[Top2],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `maxTime`\n    is the longest path that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = max(maxTime, dp[u].top1.time)\n\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newMaxTime = self._getTime(u) + max(\n          maxTime,\n          dp[u].top2.time if dp[u].top1.node == v else dp[u].top1.time\n      )\n      self._reroot(tree, v, u, newMaxTime, dp, ans)",
      "title": "3241. Time Taken to Mark All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "551767bb-f61f-4e60-8cfa-d15360e46825",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    dist = list(range(n))\n    graph = [[] for _ in range(n)]\n\n    for i in range(n - 1):\n      graph[i].append(i + 1)\n\n    for u, v in queries:\n      graph[u].append(v)\n      if dist[u] + 1 < dist[v]:\n        dist[v] = dist[u] + 1\n        self._bfs(graph, v, dist)\n      ans.append(dist[n - 1])\n\n    return ans\n\n  def _bfs(self, graph: list[list[int]], start: int, dist: list[int]) -> None:\n    \"\"\"\n    Performs a BFS to update the shortest distances from the given `start` node\n    to all other reachable nodes in the graph. It updates the `dist` vector\n    with the new shortest distances.\n    \"\"\"\n    q = collections.deque([start])\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if dist[u] + 1 < dist[v]:\n          dist[v] = dist[u] + 1\n          q.append(v)",
      "title": "3243. Shortest Distance After Road Addition Queries I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d1a8f14-034d-44b2-8196-8131377296c8",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    nodeToFarthestNode = {i: i + 1 for i in range(n - 1)}\n\n    for u, v in queries:\n      # If `u` exists in the map and `v` is farther than the current farthest\n      # node for `u`, we need to update the map and remove intermediate nodes.\n      if u in nodeToFarthestNode and nodeToFarthestNode[u] < v:\n        node = nodeToFarthestNode[u]\n        while node < v:\n          node = nodeToFarthestNode.pop(node)\n        nodeToFarthestNode[u] = v\n      ans.append(len(nodeToFarthestNode))\n\n    return ans",
      "title": "3244. Shortest Distance After Road Addition Queries II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd3506c-def1-4932-b854-8bd3fda5de90",
      "code": "class Solution:\n  def subsequenceCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    even = 0  # the number of subsequences with even sum\n    odd = 0  # the number of subsequences with odd sum\n\n    for num in nums:\n      if num % 2 == 0:\n        # Appending an even number to a subsequence doesn't change the parity.\n        # The even number itself is also a valid subsequence.\n        even, odd = even + even + 1, odd + odd\n      else:\n        # Appending an odd number to a subsequence changes the parity.\n        # The odd number itself is also a valid subsequence.\n        even, odd = even + odd, odd + even + 1\n\n    return odd % MOD",
      "title": "3247. Number of Subsequences with Odd Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c56b606-6c72-4b9d-970e-5845d62887bd",
      "code": "class Solution:\n  def finalPositionOfSnake(self, n: int, commands: list[str]) -> int:\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1),\n    }\n    i = 0\n    j = 0\n\n    for command in commands:\n      dx, dy = directions[command]\n      i += dx\n      j += dy\n\n    return i * n + j",
      "title": "3248. Snake in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61f09549-186e-40d9-9300-96f4cbce93c8",
      "code": "class Solution:\n  def countGoodNodes(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    ans = 0\n\n    def dfs(u: int, prev: int) -> int:\n      \"\"\"Returns the size of the subtree rooted at u.\"\"\"\n      nonlocal ans\n      size = 1\n      childrenSizes = []\n      for v in graph[u]:\n        if v == prev:\n          continue\n        child_size = dfs(v, u)\n        size += child_size\n        childrenSizes.append(child_size)\n\n      if not childrenSizes or all(s == childrenSizes[0]\n                                  for s in childrenSizes):\n        ans += 1\n\n      return size\n\n    dfs(0, -1)\n    return ans",
      "title": "3249. Count the Number of Good Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e5431e3-538a-4081-9cdb-5909431403f9",
      "code": "class Solution:\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3250. Find the Count of Monotonic Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee8b99bd-eb13-46bd-99cf-40c8b2a0d841",
      "code": "class Solution:\n  # Same as 3250. Find the Count of Monotonic Pairs I\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3251. Find the Count of Monotonic Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9951ba0-f057-440a-94e5-98ea59c3aeb3",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0:i]\n    dp = [0] + [math.inf] * n\n\n    for i in range(1, n + 1):\n      for j, (word, cost) in enumerate(zip(words, costs)):\n        if (i >= len(word) and\n            target[i - len(word):i] == word and\n                dp[i - len(word)] != math.inf):\n          dp[i] = min(dp[i], dp[i - len(word)] + cost)\n\n    return dp[n] if dp[n] != math.inf else -1",
      "title": "3253. Construct String with Minimum Cost (Easy)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48b66d45-7109-4947-a321-496cd29426a1",
      "code": "class Solution:\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3254. Find the Power of K-Size Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7450d1f1-6a60-4349-9511-d19c9c2d207e",
      "code": "class Solution:\n  # Same as 3254. Find the Power of K-Size Subarrays I\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3255. Find the Power of K-Size Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f97f2be3-74bd-47df-a3c2-e306982b7786",
      "code": "class Solution:\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3256. Maximum Value Sum by Placing Three Rooks I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e973fe-0b53-4afa-8407-0ad5f7b6e707",
      "code": "class Solution:\n  # Same as 3256. Maximum Value Sum by Placing Three Rooks I\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3257. Maximum Value Sum by Placing Three Rooks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5aa36728-7a9f-443c-a0b3-6074664a19c4",
      "code": "class Solution:\n  def countKConstraintSubstrings(self, s: str, k: int) -> int:\n    ans = 0\n    count = [0, 0]\n\n    l = 0\n    for r, c in enumerate(s):\n      count[int(c)] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "3258. Count Substrings That Satisfy K-Constraint I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f36b6c82-a3b6-4f1a-ae7b-fab15ae5d87c",
      "code": "class Solution:\n  def maxEnergyBoost(\n      self,\n      energyDrinkA: list[int],\n      energyDrinkB: list[int]\n  ) -> int:\n    dpA = 0  # the maximum energy boost if the last drink is A\n    dpB = 0  # the maximum energy boost if the last drink is B\n\n    for a, b in zip(energyDrinkA, energyDrinkB):\n      dpA, dpB = max(dpB, dpA + a), max(dpA, dpB + b)\n\n    return max(dpA, dpB)",
      "title": "3259. Maximum Energy Boost From Two Drinks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26c40cfa-c3e3-4565-8055-2c0981516255",
      "code": "class Solution:\n  def largestPalindrome(self, n: int, k: int) -> str:\n    match k:\n      case 1:\n        return '9' * n\n      case 2:\n        return '8' * n if n <= 2 else '8' + '9' * (n - 2) + '8'\n      case 3 | 9:\n        return '9' * n\n      case 4:\n        return '8' * n if n <= 4 else '88' + '9' * (n - 4) + '88'\n      case 5:\n        return '5' * n if n <= 2 else '5' + '9' * (n - 2) + '5'\n      case 6:\n        if n <= 2:\n          return '6' * n\n        elif n % 2 == 1:\n          l = n // 2 - 1\n          return '8' + '9' * l + '8' + '9' * l + '8'\n        else:\n          l = n // 2 - 2\n          return '8' + '9' * l + '77' + '9' * l + '8'\n      case 8:\n        return '8' * n if n <= 6 else '888' + '9' * (n - 6) + '888'\n      case _:\n        middle = {\n            0: '', 1: '7', 2: '77', 3: '959', 4: '9779', 5: '99799',\n            6: '999999', 7: '9994999', 8: '99944999', 9: '999969999',\n            10: '9999449999', 11: '99999499999'\n        }\n        q, r = divmod(n, 12)\n        return '999999' * q + middle[r] + '999999' * q",
      "title": "3260. Find the Largest Palindrome Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eaeebe7b-c22f-46f4-b50a-571ef0424ad3",
      "code": "class Solution:\n  def countKConstraintSubstrings(\n      self,\n      s: str,\n      k: int,\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(s)\n    ans = []\n    count = [0, 0]\n    # leftToRight[l] := the maximum right index r s.t. s[l..r] is valid\n    leftToRight = [0] * n\n    # rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid\n    rightToLeft = [0] * n\n\n    l = 0\n    for r in range(n):\n      count[int(s[r])] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      rightToLeft[r] = l\n\n    count = [0, 0]\n    r = n - 1\n    for l in reversed(range(n)):\n      count[int(s[l])] += 1\n      while min(count) > k:\n        count[int(s[r])] -= 1\n        r -= 1\n      leftToRight[l] = r\n\n    # prefix[i] := the number of valid substrings ending in [0..i - 1].\n    prefix = list(itertools.accumulate((r - l + 1\n                                       for r, l in enumerate(rightToLeft)),\n                                       initial=0))\n\n    for l, r in queries:\n      if r > leftToRight[l]:\n        # If r is beyond leftToRight[l], compute the number of valid substrings\n        # from l to leftToRight[l] and add the number of valid substrings\n        # ending in [leftToRight[l] + 1..r].\n        #\n        # prefix[r + 1] := the number of valid substrings ending in [0..r].\n        # prefix[leftToRight[l] + 1] := the number of valid substrings ending\n        # in [0..leftToRight].\n        # => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid\n        # substrings ending in [leftToRight[l] + 1..r].\n        sz = leftToRight[l] - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2 + (\n            prefix[r + 1] - prefix[leftToRight[l] + 1])\n      else:\n        # If r is within the range of leftToRight[l], compute the number of\n        # valid substrings directly from l to r.\n        sz = r - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2\n      ans.append(numValidSubstrings)\n\n    return ans",
      "title": "3261. Count Substrings That Satisfy K-Constraint II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6390184-d5a6-4a1f-83d6-820d6ff2ef3e",
      "code": "class Solution:\n  def toArray(self, head: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = head\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3263. Convert Doubly Linked List to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bf030df-4446-4fa1-92b6-c8551c6bccc8",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n\n    for num, i in minHeap:\n      ans[i] = num\n\n    return ans",
      "title": "3264. Final Array State After K Multiplication Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff3756b9-1b2e-407f-95fa-7731245b8385",
      "code": "class Solution:\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 swap.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3265. Count Almost Equal Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce371b2d-c175-4813-aae6-78dc02b2bed4",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    if multiplier == 1:\n      return nums\n\n    MOD = 1_000_000_007\n    n = len(nums)\n    maxNum = max(nums)\n    ans = [0] * n\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n\n    heapq.heapify(minHeap)\n\n    # Keep multiplying the minimum number as close as possible to the maximum\n    # number in the array. After that, stop multiplying the minimum number\n    # because it will be greater than the maximum number in the array and break\n    # the circularity.\n    while k > 0 and minHeap[0][0] * multiplier <= maxNum:\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n      k -= 1\n\n    sortedIndexedNums = sorted(minHeap)\n    multipliesPerNum, remainingK = divmod(k, n)\n\n    # Evenly distribute the remaining multiplications to each number by using\n    # fast exponentiation.\n    for index, (num, i) in enumerate(sortedIndexedNums):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] *\n          pow(multiplier, multipliesPerNum, MOD) % MOD, i)\n\n    # Distribute the remaining multiplications to the minimum `remainingK`\n    # numbers.\n    for index in range(remainingK):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] * multiplier % MOD,\n          sortedIndexedNums[index][1])\n\n    for num, i in sortedIndexedNums:\n      ans[i] = num\n\n    return ans",
      "title": "3266. Final Array State After K Multiplication Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10fd7f96-6437-4abc-acea-e3ac20e98ce9",
      "code": "class Solution:\n  # Similar to 3265. Count Almost Equal Pairs I\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 or 2 swaps.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    # Add all numbers after 1 swap.\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    # Add all numbers after 2 swaps.\n    for (i1, j1), (i2, j2) in itertools.combinations(\n            itertools.combinations(range(n), 2), 2):\n      newDigits = digits[:]\n      newDigits[i1], newDigits[j1] = newDigits[j1], newDigits[i1]\n      newDigits[i2], newDigits[j2] = newDigits[j2], newDigits[i2]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3267. Count Almost Equal Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6df2ddd6-4711-41b4-9b51-2298fa576e87",
      "code": "class Solution:\n  def minLargest(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    # dp[i][j] := the minimum largest number for the first i nums1 and the\n    # first j nums2\n    dp = [[math.inf] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n\n    def f(prev: int, num: int) -> int:\n      \"\"\"\n      Returns the next number to fill in the array based on the previous number\n      and the current number.\n      \"\"\"\n      return prev + (2 if prev % 2 == num else 1)\n\n    for i in range(m + 1):\n      for j in range(n + 1):\n        if i > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]))\n        if j > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]))\n\n    return dp[m][n]",
      "title": "3269. Constructing Two Increasing Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83f7ef21-8a96-4205-ba32-16abe95fb02c",
      "code": "class Solution:\n  def generateKey(self, num1: int, num2: int, num3: int) -> int:\n    return int(''.join(min(a, b, c)\n                       for a, b, c in zip(str(num1).zfill(4),\n                                          str(num2).zfill(4),\n                                          str(num3).zfill(4))))",
      "title": "3270. Find the Key of the Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "990da122-106e-4fc0-975e-99503a2fc694",
      "code": "class Solution:\n  def stringHash(self, s: str, k: int) -> str:\n    ans = []\n\n    for i in range(0, len(s), k):\n      sumHash = sum(string.ascii_lowercase.index(s[j])\n                    for j in range(i, i + k))\n      ans.append(string.ascii_lowercase[sumHash % 26])\n\n    return ''.join(ans)",
      "title": "3271. Hash Divided String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce57d3e-e228-48e2-a1c9-84b7d68188d0",
      "code": "class Solution:\n  def countGoodIntegers(self, n: int, k: int) -> int:\n    halfLength = (n + 1) // 2\n    minHalf = 10**(halfLength - 1)\n    maxHalf = 10**halfLength\n    ans = 0\n    seen = set()\n\n    for num in range(minHalf, maxHalf):\n      palindrome = str(num) + str(num)[::-1][n % 2:]\n      sortedDigits = ''.join(sorted(palindrome))\n      if int(palindrome) % k != 0 or sortedDigits in seen:\n        continue\n      seen.add(sortedDigits)\n      digitCount = collections.Counter(palindrome)\n      # Leading zeros are not allowed, so the first digit is special.\n      firstDigitChoices = n - digitCount['0']\n      permutations = firstDigitChoices * math.factorial(n - 1)\n      # For each repeated digit, divide by the factorial of the frequency since\n      # permutations that swap identical digits don't create a new number.\n      for freq in digitCount.values():\n        permutations //= math.factorial(freq)\n      ans += permutations\n\n    return ans",
      "title": "3272. Find the Count of Good Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40553741-c851-48ed-b73a-03ffb2a0b964",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Enemy:\n  damage: int\n  timeTakenDown: int\n\n\nclass Solution:\n  def minDamage(self, power: int, damage: list[int], health: list[int]) -> int:\n    ans = 0\n    sumDamage = sum(damage)\n    enemies = [Enemy(d, (h + power - 1) // power)\n               for d, h in zip(damage, health)]\n\n    # It's better to take down the enemy i first if the damage dealt of taking\n    # down i first is less than the damage dealt of taking down j first. So,\n    #    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <\n    #    damage[j] * t[j] + (t[i] + t[j]) * damage[i]\n    # => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <\n    #    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]\n    # => damage[j] * t[i] < damage[i] * t[j]\n    # => damage[j] / t[j] < damage[i] / t[i]\n    enemies.sort(key=lambda x: -x.damage / x.timeTakenDown)\n\n    for enemy in enemies:\n      ans += sumDamage * enemy.timeTakenDown\n      sumDamage -= enemy.damage\n\n    return ans",
      "title": "3273. Minimum Amount of Damage Dealt to Bob",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e79412d5-fb8e-4462-a6ff-be59986aa73b",
      "code": "class Solution:\n  def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n    # Same as 1812. Determine Color of a Chessboard Square\n    def squareIsWhite(coordinate: str) -> bool:\n      letter, digit = coordinate\n      return ord(letter) % 2 != int(digit) % 2\n\n    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2)",
      "title": "3274. Check if Two Chessboard Squares Have the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caf0f152-8aab-4382-9b43-ef8605146897",
      "code": "class Solution:\n  def resultsArray(self, queries: list[list[int]], k: int) -> list[int]:\n    ans = []\n    maxHeap = []\n\n    for x, y in queries:\n      heapq.heappush(maxHeap, -(abs(x) + abs(y)))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n      ans.append(-maxHeap[0] if len(maxHeap) == k else -1)\n\n    return ans",
      "title": "3275. K-th Nearest Obstacle Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e0466ba-acf4-4158-8dbe-84c2a24d6257",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    numToIndices = collections.defaultdict(set)\n    for index, row in enumerate(grid):\n      for num in row:\n        numToIndices[num].add(index)\n    numToIndices = list(numToIndices.items())\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score by selecting numbers from numToIndices[i..],\n      where `mask` is the bitmask of the used row indices.\n      \"\"\"\n      if i == len(numToIndices):\n        return 0\n      # Skip numToIndices[i][0].\n      res = dp(i + 1, mask)\n      for index in numToIndices[i][1]:\n        if (mask >> index & 1) == 0:\n          # Take numToIndices[i][0].\n          res = max(res, numToIndices[i][0] + dp(i + 1, mask | 1 << index))\n      return res\n\n    return dp(0, 0)",
      "title": "3276. Select Cells in Grid With Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "101fb735-94d6-41ee-9d08-98b0399c3316",
      "code": "class Solution:\n  def maximumSubarrayXor(\n      self,\n      nums: list[int],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(nums)\n    # xors[i][j] := the XOR score of nums[i..j]\n    xors = [[0] * n for _ in range(n)]\n    # dp[i][j] := the maximum XOR score of nums[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, num in enumerate(nums):\n      xors[i][i] = num\n      dp[i][i] = num\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j]\n        dp[i][j] = max(xors[i][j], dp[i][j - 1], dp[i + 1][j])\n\n    return [dp[l][r] for l, r in queries]",
      "title": "3277. Maximum XOR Score Subarray Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5ce86d1-9d86-4449-a29e-3dd42ed555c5",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxArea(self, height: int, positions: list[int], directions: str) -> int:\n    area = sum(positions)\n    ans = area\n    diffPerSecond = 0\n    timeToIndices: SortedDict[int, list[int]] = SortedDict()\n\n    for i, (position, direction) in enumerate(zip(positions, directions)):\n      if direction == 'U':\n        timeToIndices.setdefault(height - position, []).append(i)\n        timeToIndices.setdefault(height - position + height, []).append(i)\n        diffPerSecond += 1\n      else:\n        timeToIndices.setdefault(position, []).append(i)\n        timeToIndices.setdefault(position + height, []).append(i)\n        diffPerSecond -= 1\n\n    prevTime = 0\n    directionsList = list(directions)\n\n    for time, indices in timeToIndices.items():\n      area += (time - prevTime) * diffPerSecond\n      ans = max(ans, area)\n      prevTime = time\n      for i in indices:\n        if directionsList[i] == 'U':\n          directionsList[i] = 'D'\n          diffPerSecond -= 2\n        else:\n          directionsList[i] = 'U'\n          diffPerSecond += 2\n\n    return ans",
      "title": "3279. Maximum Total Area Occupied by Pistons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b7856e1-cd41-4752-bc25-8415c44902f4",
      "code": "class Solution:\n  def convertDateToBinary(self, date: str) -> str:\n    year, month, day = map(int, date.split('-'))\n\n    def toBinary(value: int) -> str:\n      \"\"\"Converts an integer to binary without leading zeros.\"\"\"\n      return bin(value)[2:]\n\n    return '-'.join([toBinary(year), toBinary(month), toBinary(day)])",
      "title": "3280. Convert Date to Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a501f7d4-a43c-4e34-907e-c6c733170a2c",
      "code": "class Solution:\n  def maxPossibleScore(self, start: list[int], d: int) -> int:\n    def isPossible(m: int) -> bool:\n      lastPick = start[0]\n      for i in range(1, len(start)):\n        if lastPick + m > start[i] + d:\n          return False\n        lastPick = max(lastPick + m, start[i])\n      return True\n\n    start.sort()\n\n    maxScore = (start[-1] + d) - start[0] + 1\n    l = bisect.bisect_left(range(maxScore), True,\n                           key=lambda m: not isPossible(m))\n    return l - 1",
      "title": "3281. Maximize Score of Numbers in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8c105a-80d2-4597-8e36-a1aacbc56478",
      "code": "class Solution:\n  # Similar to 3205. Maximum Array Hopping Score I\n  def findMaximumScore(self, nums: list[int]) -> int:\n    return sum(itertools.accumulate(nums[:-1], max))",
      "title": "3282. Reach End of Array With Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "586526a0-3deb-4a7c-b8ff-1df96e8cfb72",
      "code": "class Solution:\n  def __init__(self):\n    self.SIZE = 50\n    self.MAX = 1_000_000\n    self.DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n                 (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n\n  def maxMoves(self, kx: int, ky: int, positions: list[list[int]]) -> int:\n    n = len(positions)\n    positions.append([kx, ky])\n    hashedPositionToIndex = {}\n    # dist[i][j] := the minimum distance from positions[i] to positions[j]\n    dist = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i, (x, y) in enumerate(positions):\n      hashedPositionToIndex[self._hash(x, y)] = i\n\n    for sourceIndex in range(n + 1):\n      self._bfs(positions, sourceIndex, hashedPositionToIndex, dist)\n\n    MAX_MASK = 1 << (n + 1)\n    # dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to\n    # kill all pawns, where i is the current pawn, mask is the set of pawns\n    # that have been killed, and turn is the current player's turn (0 for Alice\n    # and 1 for Bob)\n    dp = [[[0, 0]\n          for _ in range(1 << (n + 1))]\n          for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      for mask in range(MAX_MASK - 1):\n        dp[i][mask] = [-self.MAX, self.MAX]\n\n    for mask in range(MAX_MASK - 2, -1, -1):\n      for i in range(n + 1):\n        for turn in range(2):\n          for j in range(n):\n            if mask >> j & 1:\n              continue\n            moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn]\n            dp[i][mask][turn] = (max(dp[i][mask][turn], moves) if turn == 0 else\n                                 min(dp[i][mask][turn], moves))\n\n    # Returns the maximum cost to kill all pawns, i.e., the original positions\n    # array without the knight (kx, ky).\n    return dp[n][1 << n][0]\n\n  def _hash(self, x: int, y: int) -> int:\n    return x * self.SIZE + y\n\n  def _bfs(\n      self,\n      positions: list[list[int]],\n      sourceIndex: int,\n      hashedPositionToIndex: dict[int, int],\n      dist: list[list[int]]\n  ) -> None:\n    \"\"\"\n    Computes the distance between positions[sourceIndex] and other positions.\n    \"\"\"\n    sx, sy = positions[sourceIndex]\n    q = collections.deque([(sx, sy)])\n    seen = {(sx, sy)}\n    seenPositions = 0\n\n    step = 0\n    while q and seenPositions < len(positions):\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        hashedPosition = self._hash(i, j)\n        if hashedPosition in hashedPositionToIndex:\n          dist[sourceIndex][hashedPositionToIndex[hashedPosition]] = step\n          seenPositions += 1\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x >= self.SIZE or y < 0 or y >= self.SIZE:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1",
      "title": "3283. Maximum Number of Moves to Kill All Pawns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcc8d6c2-2f56-483a-a10c-f865a70a868d",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    def getSum(diff: int) -> int:\n      \"\"\"Returns the sum of all subarrays with a difference of `diff`.\"\"\"\n      res = nums[0]\n      summ = nums[0]\n      count = 1\n      for prev, num in itertools.pairwise(nums):\n        if num == prev + diff:\n          count += 1\n          summ += count * num\n        else:\n          count = 1\n          summ = num\n        res += summ\n      return res\n\n    return (getSum(1) + getSum(-1) - sum(nums)) % 1_000_000_007",
      "title": "3284. Sum of Consecutive Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "311bca1e-f5e8-40c8-9293-b9ca4f280849",
      "code": "class Solution:\n  def stableMountains(self, height: list[int], threshold: int) -> list[int]:\n    return [i for i in range(1, len(height))\n            if height[i - 1] > threshold]",
      "title": "3285. Find Indices of Stable Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "670dddbd-3516-4582-ae40-3d8413ec8a77",
      "code": "class Solution:\n  def findSafeWalk(self, grid: list[list[int]], health: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    initialHealth = health - grid[0][0]\n    q = collections.deque([(0, 0, initialHealth)])\n    seen = {(0, 0, initialHealth)}\n\n    while q:\n      for _ in range(len(q)):\n        i, j, h = q.popleft()\n        if i == m - 1 and j == n - 1 and h > 0:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          nextHealth = h - grid[x][y]\n          if nextHealth <= 0 or (x, y, nextHealth) in seen:\n            continue\n          q.append((x, y, nextHealth))\n          seen.add((x, y, nextHealth))\n\n    return False",
      "title": "3286. Find a Safe Walk Through a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d9f26ba-4d7d-42a0-a0e7-a563cfcce39d",
      "code": "class Solution:\n  def maxValue(self, nums: list[int], k: int) -> int:\n    left = self._getPossibleORs(nums, k)\n    right = self._getPossibleORs(nums[::-1], k)[::-1]\n    return max(a ^ b\n               for i in range(k - 1, len(nums) - k)\n               for a in range(128 + 1)\n               for b in range(128 + 1)\n               if left[i][k][a] and right[i + 1][k][b])\n\n  def _getPossibleORs(self, nums: list[int], k: int) -> list[list[list[bool]]]:\n    dp = [[[False] * (128 + 1)\n          for _ in range(k + 1)]\n          for _ in range(len(nums))]\n\n    dp[0][1][nums[0]] = True\n\n    for i in range(len(nums)):\n      dp[i][0][0] = True\n\n    for i in range(1, len(nums)):\n      for j in range(1, k + 1):\n        for x in range(128 + 1):\n          if dp[i - 1][j][x]:\n            dp[i][j][x] = True\n          if dp[i - 1][j - 1][x]:\n            dp[i][j][nums[i] | x] = True\n\n    return dp",
      "title": "3287. Find the Maximum Sequence Value of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "962c25c9-3e06-4e7e-8999-02154b3bad4d",
      "code": "class Solution:\n  def maxPathLength(self, coordinates: list[list[int]], k: int) -> int:\n    xk, yk = coordinates[k]\n    leftCoordinates = [(x, y) for x, y in coordinates if x < xk and y < yk]\n    rightCoordinates = [(x, y) for x, y in coordinates if x > xk and y > yk]\n    return (1 +\n            self._lengthOfLIS(leftCoordinates) +\n            self._lengthOfLIS(rightCoordinates))\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, coordinates: list[tuple[int, int]]) -> int:\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    # tail[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tail = []\n    for _, y in coordinates:\n      if not tail or y > tail[-1]:\n        tail.append(y)\n      else:\n        tail[bisect.bisect_left(tail, y)] = y\n    return len(tail)",
      "title": "3288. Length of the Longest Increasing Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57a14c3b-efbb-4f9d-be74-0cd0ef642ab0",
      "code": "class Solution:\n  def getSneakyNumbers(self, nums: list[int]) -> list[int]:\n    return [num for num, freq in collections.Counter(nums).items()\n            if freq == 2]",
      "title": "3289. The Two Sneaky Numbers of Digitville",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d77397d-aede-476f-b560-34be34f33909",
      "code": "class Solution:\n  def maxScore(self, a: list[int], b: list[int]) -> int:\n    n = len(b)\n    # dp[i][j] := the maximum score by selecting 4 - i numbers from b[j..n - 1]\n    # using the corresponding numbers from a[i..3]\n    dp = [[0] * (n + 1) for _ in range(5)]\n\n    # Run out of numbers in b but still need to select numbers from a.\n    for i in range(4):\n      dp[i][n] = -math.inf\n\n    for i in reversed(range(4)):\n      for j in reversed(range(n)):\n        # Skip b[j] or pair a[i] with b[j].\n        dp[i][j] = max(dp[i][j + 1], a[i] * b[j] + dp[i + 1][j + 1])\n\n    return -1 if dp[0][0] == -math.inf else dp[0][0]",
      "title": "3290. Maximum Multiplication Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6bf6325-9f54-405b-ba48-35b657fffe1f",
      "code": "class Solution:\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3291. Minimum Number of Valid Strings to Form Target I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57333200-ef29-48d3-a30d-e161e837fcd6",
      "code": "class Solution:\n  # 3291. Minimum Number of Valid Strings to Form Target I\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3292. Minimum Number of Valid Strings to Form Target II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17228ce0-0f64-4ebc-878f-5ae4f39d4615",
      "code": "class Solution:\n  def toArray(self, node: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = node\n\n    while curr.prev:\n      curr = curr.prev\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3294. Convert Doubly Linked List to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e68b664-d884-4b81-b06b-2ad975509ed1",
      "code": "class Solution:\n  def reportSpam(self, message: list[str], bannedWords: list[str]) -> bool:\n    bannedWordsSet = set(bannedWords)\n    return sum(word in bannedWordsSet for word in message) > 1",
      "title": "3295. Report Spam Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5da0d434-a107-46be-acbe-1b5ee23ad2a2",
      "code": "class Solution:\n  def minNumberOfSeconds(\n      self,\n      mountainHeight: int,\n      workerTimes: list[int]\n  ) -> int:\n    def getReducedHeight(m: int) -> int:\n      \"\"\"Returns the total height reduced by all workers in `m` seconds.\"\"\"\n      # The height `x` that a worker with working time `w` reduces in `m`\n      # seconds.\n      # w * (1 + 2 + ... + x) <= m\n      #       (1 + x) * x / 2 <= m / w\n      #   x^2 + x - 2 * m / w <= 0\n      #                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2\n      return sum((-1 + math.sqrt(1 + 8 * m // workerTime)) // 2\n                 for workerTime in workerTimes)\n\n    l = 1\n    r = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    return bisect.bisect_left(range(l, r), mountainHeight,\n                              key=getReducedHeight) + l",
      "title": "3296. Minimum Number of Seconds to Make Mountain Height Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aeb526e-e53b-4c2f-9f11-b0544dada392",
      "code": "class Solution:\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3297. Count Substrings That Can Be Rearranged to Contain a String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54db6532-1a0f-4611-afbd-f59f06ed63be",
      "code": "class Solution:\n  # Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3298. Count Substrings That Can Be Rearranged to Contain a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ede7a230-f676-44ee-9583-45e969111b63",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getSequenceSum(nums: list[int], direction: int) -> int:\n      \"\"\"\n      Returns the sum of all sequences in the array that are in consecutive\n      increasing order if `direction` is 1, or in consecutive decreasing order\n      if `direction` is -1.\"\"\"\n      sequenceSum = 0\n      # {num: the number of subsequences ending in `num` so far}\n      prefixCount = collections.Counter()\n      # {num: the number of subsequences starting from `num` so far}\n      suffixCount = collections.Counter()\n      # prefixSubseqs[i] := the number of subsequences ending in nums[i]\n      prefixSubseqs = [0] * n\n      # suffixSubseqs[i] := the number of subsequences starting from nums[i]\n      suffixSubseqs = [0] * n\n\n      for i, num in enumerate(nums):\n        prevNum = num - direction\n        freq = prefixCount[prevNum] + 1\n        prefixSubseqs[i] = freq\n        prefixCount[num] += freq\n        prefixCount[num] %= MOD\n\n      for i, num in reversed(list(enumerate(nums))):\n        nextNum = num + direction\n        freq = suffixCount[nextNum] + 1\n        suffixSubseqs[i] = freq\n        suffixCount[num] += freq\n        suffixCount[num] %= MOD\n\n      for num, prefixSubseq, suffixSubseq in zip(\n              nums, prefixSubseqs, suffixSubseqs):\n        sequenceSum += num * prefixSubseq * suffixSubseq\n        sequenceSum %= MOD\n\n      return sequenceSum\n\n    increasingSequenceSum = getSequenceSum(nums, 1)\n    decreasingSequenceSum = getSequenceSum(nums, -1)\n    return (increasingSequenceSum + decreasingSequenceSum - sum(nums) + MOD) % MOD",
      "title": "3299. Sum of Consecutive Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0e318ef-828f-4fbf-911c-e35a27bb8273",
      "code": "class Solution:\n  def minElement(self, nums: list[int]) -> int:\n    return min(sum(map(int, str(num))) for num in nums)",
      "title": "3300. Minimum Element After Replacement With Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "479252af-c917-4f95-a121-e5d716d9faea",
      "code": "class Solution:\n  def maximumTotalSum(self, maximumHeight: list[int]) -> int:\n    ans = 0\n    mn = math.inf\n\n    for height in sorted(maximumHeight, reverse=True):\n      assigned = min(height, mn - 1)\n      if assigned == 0:\n        return -1\n      ans += assigned\n      mn = assigned\n\n    return ans",
      "title": "3301. Maximize the Total Height of Unique Towers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7632139-2723-4a70-aad9-6f5617b05470",
      "code": "class Solution:\n  def validSequence(self, word1: str, word2: str) -> list[int]:\n    ans = []\n    # last[j] := the index i of the last occurrence in word1, where\n    # word1[i] == word2[j]\n    last = [-1] * len(word2)\n\n    i = len(word1) - 1\n    j = len(word2) - 1\n    while i >= 0 and j >= 0:\n      if word1[i] == word2[j]:\n        last[j] = i\n        j -= 1\n      i -= 1\n\n    canSkip = True\n    j = 0\n    for i, c in enumerate(word1):\n      if j == len(word2):\n        break\n      if c == word2[j]:\n        ans.append(i)\n        j += 1\n      elif canSkip and (j == len(word2) - 1 or i < last[j + 1]):\n        canSkip = False\n        ans.append(i)\n        j += 1\n\n    return ans if j == len(word2) else []",
      "title": "3302. Find the Lexicographically Smallest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61fdbf54-469f-468a-985e-391b2ca37e19",
      "code": "class Solution:\n  def minStartingIndex(self, s: str, pattern: str) -> int:\n    z1 = self._zFunction(pattern + s)\n    z2 = self._zFunction(pattern[::-1] + s[::-1])\n\n    # Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and\n    # the suffix.\n    for i in range(len(s) - len(pattern) + 1):\n      if z1[len(pattern) + i] + z2[len(s) - i] >= len(pattern) - 1:\n        return i\n\n    return -1\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3303. Find the Occurrence of First Almost Equal Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf720b28-aeff-4767-b519-3a5211a5a781",
      "code": "class Solution:\n  def kthCharacter(self, k: int) -> str:\n    return string.ascii_lowercase[(k - 1).bit_count()]",
      "title": "3304. Find the K-th Character in String Game I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04cd6436-4c93-4ea2-bb8e-701e84895c7e",
      "code": "class Solution:\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k == -1:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3305. Count of Substrings Containing Every Vowel and K Consonants I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7c200bf-9d16-4c65-9b52-75c27a9c55d8",
      "code": "class Solution:\n  # Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k < 0:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3306. Count of Substrings Containing Every Vowel and K Consonants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cf59efb-cbd0-4061-9584-7e84aeaf94a5",
      "code": "class Solution:\n  def kthCharacter(self, k: int, operations: list[int]) -> str:\n    operationsCount = math.ceil(math.log2(k))\n    increases = 0\n\n    for i in range(operationsCount - 1, -1, -1):\n      halfSize = 2**i\n      if k > halfSize:\n        k -= halfSize  # Move k from the right half to the left half.\n        increases += operations[i]\n\n    return string.ascii_lowercase[increases % 26]",
      "title": "3307. Find the K-th Character in String Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e893201a-ee82-48e0-a0d0-2f8c733ab684",
      "code": "class Solution:\n  def maxGoodNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    def concat(a: int, b: int) -> int:\n      \"\"\"Returns the concatenation of the binary representations of a and b.\"\"\"\n      return (a << b.bit_length()) + b\n\n    nums.sort(key=functools.cmp_to_key(\n        lambda a, b: concat(b, a) - concat(a, b)))\n\n    for num in nums:\n      ans = concat(ans, num)\n\n    return ans",
      "title": "3309. Maximum Possible Number by Binary Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38f75a94-c826-402e-832f-10b71a4f17a5",
      "code": "class Solution:\n  def remainingMethods(\n      self,\n      n: int,\n      k: int,\n      invocations: list[list[int]]\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(n)]\n\n    for u, v in invocations:\n      graph[u].append(v)\n\n    q = collections.deque([k])\n    seen = {k}\n\n    while q:\n      for _ in range(len(q)):\n        for v in graph[q.popleft()]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for u in range(n):\n      if u in seen:\n        continue\n      for v in graph[u]:\n        if v in seen:\n          return list(range(n))\n      ans.append(u)\n\n    return ans",
      "title": "3310. Remove Methods From Project",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "937e2477-8830-40a1-96e5-e0e6a1f86642",
      "code": "class Solution:\n  def constructGridLayout(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Randomly choose a node with the minimum degree as the corner.\n    corner = min(range(len(graph)), key=lambda x: len(graph[x]))\n\n    seen = {corner}\n    firstRow = self._getFirstRow(graph, corner, seen)\n    cols = len(firstRow)\n    rows = n // cols\n\n    ans = [[0] * cols for _ in range(rows)]\n    ans[0] = firstRow\n\n    for i in range(1, rows):\n      for j in range(cols):\n        for v in graph[ans[i - 1][j]]:\n          if v not in seen:\n            ans[i][j] = v\n            seen.add(v)\n            break\n\n    return ans\n\n  def _getFirstRow(\n      self,\n      graph: list[list[int]],\n      corner: int,\n      seen: set[int]\n  ) -> list[int]:\n    cornerDegree = len(graph[corner])\n    row = [corner]\n    # Continue appending neighbors until we hit another corner.\n    while len(row) == 1 or len(graph[row[-1]]) == cornerDegree + 1:\n      # Sort neighbors by degree to prioritize smaller ones (shortest row built first).\n      graph[row[-1]].sort(key=lambda x: len(graph[x]))\n      for v in graph[row[-1]]:\n        if v not in seen and len(graph[v]) in (cornerDegree, cornerDegree + 1):\n          row.append(v)\n          seen.add(v)\n          break\n    return row",
      "title": "3311. Construct 2D Grid Matching Graph Layout",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4699adfd-84ba-4c80-8f2d-d67fdefe229f",
      "code": "class Solution:\n  def gcdValues(self, nums: list[int], queries: list[int]) -> list[int]:\n    maxNum = max(nums)\n    # countDivisor[d] := the number of `nums` having `num % d == 0`\n    countDivisor = [0] * (maxNum + 1)\n    # countGcdPair[g] := the number of pairs having gcd == g\n    countGcdPair = [0] * (maxNum + 1)\n\n    for num in nums:\n      for i in range(1, math.isqrt(num) + 1):\n        if num % i == 0:\n          countDivisor[i] += 1\n          if i != num // i:\n            countDivisor[num // i] += 1\n\n    for gcd in range(maxNum, 0, -1):\n      # There are C(countDivisor[gcd], 2) pairs that have a common divisor\n      # that's a multiple of `gcd` (including the one that equals to `gcd`).\n      # So, substract the multiples of `gcd` to have the number of pairs with a\n      # gcd that's exactly `gcd`.\n      countGcdPair[gcd] = countDivisor[gcd] * (countDivisor[gcd] - 1) // 2\n      for largerGcd in range(2 * gcd, maxNum + 1, gcd):\n        countGcdPair[gcd] -= countGcdPair[largerGcd]\n\n    # prefixCountGcdPair[g] := the number of pairs having gcd <= g\n    prefixCountGcdPair = list(itertools.accumulate(countGcdPair))\n    return [bisect.bisect_left(prefixCountGcdPair, query + 1)\n            for query in queries]",
      "title": "3312. Sorted GCD Pair Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "422e54ec-fd70-4933-b9dc-d1141e4c959e",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time it got marked\n\n\nclass Last2:\n  def __init__(self, last1: Node = Node(), last2: Node = Node()):\n    self.last1 = last1  # the last marked node\n    self.last2 = last2  # the second last marked node\n\n\nclass Solution:\n  # Similar to 3241. Time Taken to Mark All Nodes\n  def lastMarkedNodes(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the last marked two nodes for subtree rooted at node i, where\n    # each node contains the time it got marked\n    dp = [Last2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, Node(), dp, ans)\n    return ans\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Last2]\n  ) -> Node:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the last two marked\n    nodes, and returns the last marked node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    last1 = Node(u, 0)\n    last2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      child = self._dfs(tree, v, u, dp)\n      time = child.time + 1\n      if time > last1.time:\n        last2 = last1\n        last1 = Node(child.node, time)\n      elif time > last2.time:\n        last2 = Node(child.node, time)\n    dp[u] = Last2(last1, last2)\n    return last1\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      last: Node,\n      dp: list[list[int]],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `last`\n    is the last marked node that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = last.node if last.time > dp[u].last1.time else dp[u].last1.node\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newLast = Node(last.node, last.time + 1)\n      if dp[u].last1.node == dp[v].last1.node:\n        alternativeTime = 1 + dp[u].last2.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last2.node, alternativeTime)\n      else:\n        alternativeTime = 1 + dp[u].last1.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last1.node, alternativeTime)\n      self._reroot(tree, v, u, newLast, dp, ans)",
      "title": "3313. Find the Last Marked Nodes in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43868f8e-9cf6-4e51-b069-613d0957322d",
      "code": "class Solution:\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3314. Construct the Minimum Bitwise Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1e2bc48-bb22-4070-afaa-f37c0fc7286f",
      "code": "class Solution:\n  # Same as 3314. Construct the Minimum Bitwise Array I\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3315. Construct the Minimum Bitwise Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "975adbf4-3bf2-48dc-a19f-24abb4c93dd6",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9dbbb68-783d-4195-bf55-7c72ccbf4320",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e9b00fc-b0e2-45a6-9af2-67414d04ebd9",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int, y: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    @functools.lru_cache(None)\n    def stirling(n: int, k: int) -> int:\n      \"\"\"\n      Returns the number of ways to partition a set of n objects into k\n      non-empty subsets.\n\n      https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n      \"\"\"\n      if k == 0 or n < k:\n        return 0\n      if k == 1 or n == k:\n        return 1\n      return (k * stirling(n - 1, k) + stirling(n - 1, k - 1)) % MOD\n\n    # 1. Choose `k` stages from `x` stages.\n    # 2. Partition `n` performers into `k` stages.\n    # 3. Permute `k` stages.\n    # 4. Score `k` stages with score in the range [1, y], so y^k ways.\n    return sum(nCk(x, k) * stirling(n, k) * fact(k) * pow(y, k, MOD) % MOD\n               for k in range(1, min(n, x) + 1)) % MOD",
      "title": "3317. Find the Number of Possible Ways for an Event",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae35d1ca-be45-4d00-b87a-00fce3144ded",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()\n    bot = SortedList()\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up old values.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom element to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        windowSum -= t * countT\n        top.add([countB, b])\n        windowSum += b * countB\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3318. Find X-Sum of All K-Long Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2002d4d-d2d6-4cfb-b38a-b60f2762531f",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  isPerfect: bool\n  sz: int\n\n\nclass Solution:\n  def kthLargestPerfectSubtree(self, root: TreeNode | None, k: int) -> int:\n    ans = []\n    self._dfs(root, ans)\n    if len(ans) < k:\n      return -1\n    return sorted(ans, reverse=True)[k - 1]\n\n  def _dfs(self, root: TreeNode, ans: list[int]) -> T:\n    if not root:\n      return T(True, 0)\n    l = self._dfs(root.left, ans)\n    r = self._dfs(root.right, ans)\n    if l.isPerfect and r.isPerfect and l.sz == r.sz:\n      sz = 1 + l.sz + r.sz\n      ans.append(sz)\n      return T(True, sz)\n    return T(False, 0)",
      "title": "3319. K-th Largest Perfect Subtree Size in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14334eaa-c1a0-417c-8472-441dcc605d18",
      "code": "class Solution:\n  def countWinningSequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int, bob: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences Bob can use to beat Alice for\n      s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the\n      number of points that Bob is having is `bob`.\n      \"\"\"\n      if i == len(s):\n        return int(bob > 0)\n\n      f = 0  # If Bob summons a Fire Dragon at i.\n      w = 0  # If Bob summons a Water Serpent at i.\n      e = 0  # If Bob summons a Earth Golem at i.\n\n      match s[i]:\n        case 'F':\n          if prev != 0:\n            f = dp(i + 1, 0, bob) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob + 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob - 1) % MOD\n        case 'W':\n          if prev != 0:\n            f = dp(i + 1, 0, bob - 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob + 1) % MOD\n        case 'E':\n          if prev != 0:\n            f = dp(i + 1, 0, bob + 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob - 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob) % MOD\n\n      return f + w + e\n\n    return (dp(0, 0, 0) + dp(0, 1, 0) + dp(0, 2, 0)) // 2 % MOD",
      "title": "3320. Count The Number of Winning Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "070b7844-98d6-40f1-b271-8ca3ab20d1c9",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  # Same as 3318. Find X-Sum of All K-Long Subarrays I\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()  # the top x elements\n    bot = SortedList()  # the rest of the elements\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up the old count.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom elements to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        top.add([countB, b])\n        windowSum += b * countB\n        windowSum -= t * countT\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3321. Find X-Sum of All K-Long Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe8bacb-4921-4d99-b4fb-e50aeafd94f3",
      "code": "class Solution:\n  def minConnectedGroups(self, intervals: list[list[int]], k: int) -> int:\n    mergedIntervals = 0\n    maxMergedIntervals = 0\n\n    intervals = self._merge(intervals)\n\n    i = 0\n    for _, end in intervals:\n      while i < len(intervals) and end + k >= intervals[i][0]:\n        mergedIntervals += 1\n        i += 1\n      mergedIntervals -= 1  # Exclude intervals[i].\n      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals)\n\n    return len(intervals) - maxMergedIntervals\n\n  # Same as 56. Merge Intervals\n  def _merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    res = []\n    for interval in sorted(intervals):\n      if not res or res[-1][1] < interval[0]:\n        res.append(interval)\n      else:\n        res[-1][1] = max(res[-1][1], interval[1])\n    return res",
      "title": "3323. Minimize Connected Groups by Inserting Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6fdbe63-7347-4ce3-ae9e-d983cda26610",
      "code": "class Solution:\n  def stringSequence(self, target: str) -> list[str]:\n    ans = []\n    s = []\n\n    for targetChar in target:\n      s.append('a')\n      ans.append(''.join(s))\n      for offset in range(ord('b'), ord(targetChar) + 1):\n        s[-1] = chr(offset)\n        ans.append(''.join(s))\n\n    return ans",
      "title": "3324. Find the Sequence of Strings Appeared on the Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "024c7a1c-eaac-442a-9504-2d8f486191e0",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3325. Count Substrings With K-Frequency Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d2bad5-8e73-44c6-a59c-cfc44e3c617a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > nums[i + 1]:\n        minDivisor = self._getMinDivisor(nums[i])\n        if minDivisor > nums[i + 1]:\n          return -1\n        nums[i] = minDivisor\n        ans += 1\n\n    return ans\n\n  def _getMinDivisor(self, num: int) -> int:\n    for divisor in range(2, math.isqrt(num) + 1):\n      if num % divisor == 0:\n        return divisor\n    return num",
      "title": "3326. Minimum Division Operations to Make Array Non Decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2491131f-50da-497f-a728-daee2a9a5a00",
      "code": "class Solution:\n  def findAnswer(self, parent: list[int], s: str) -> list[bool]:\n    n = len(parent)\n    tree = [[] for _ in parent]\n    start = [0] * n  # start[i] := the start index of `dfsStr` of node i\n    end = [0] * n  # end[i] := the end index of `dfsStr` of node i\n    dfsStr = []\n\n    for i in range(1, n):\n      tree[parent[i]].append(i)\n\n    self._dfs(tree, 0, 0, s, start, end, dfsStr)\n    t = '#'.join('@' + ''.join(dfsStr) + '$')\n    p = self._manacher(t)\n    return [self._isPalindrome(s, e, p)\n            for s, e in zip(start, end)]\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      index: int,\n      s: str,\n      start: list[int],\n      end: list[int],\n      dfsStr: list[str]\n  ) -> int:\n    \"\"\"Returns the start index of the \"DFS string\" of u's next node.\"\"\"\n    start[u] = index\n    for v in tree[u]:\n      index = self._dfs(tree, v, index, s, start, end, dfsStr)\n    end[u] = index\n    dfsStr.append(s[u])\n    return index + 1\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p\n\n  def _isPalindrome(self, s: int, e: int, p: list[int]) -> bool:\n    \"\"\"\n    Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed\n    array `p` from the Manacher's algorithm.\n\n    The precomputed array `p` is based on the string `t` with delimiters and\n    sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of\n    `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`\n    and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is\n    `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.\n    \"\"\"\n    length = e - s + 1\n    center = s + e + 2\n    return p[center] >= length",
      "title": "3327. Check if DFS Strings Are Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c6ed7a9-d823-47c5-b9b3-32bf4215c01c",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3329. Count Substrings With K-Frequency Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc2c2371-7a04-4bce-9590-f5e66e31d869",
      "code": "class Solution:\n  def possibleStringCount(self, word: str) -> int:\n    return 1 + sum(a == b\n                   for a, b in itertools.pairwise(word))",
      "title": "3330. Find the Original Typed String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e5f3fbe-2c2c-48ce-b115-b62655f9b535",
      "code": "class Solution:\n  def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:\n    n = len(parent)\n    ans = [0] * n\n    newParent = parent.copy()\n    tree = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      closest = self._findClosestAncestor(i, parent, s)\n      if closest != -1:\n        newParent[i] = closest\n\n    for i in range(1, n):\n      tree[newParent[i]].append(i)\n\n    self._dfs(tree, 0, ans)\n    return ans\n\n  def _findClosestAncestor(self, u: int, parent: list[int], s: str) -> int:\n    \"\"\"\n    Returns the closest ancestor of node `u` that has the same value as `u`.\n    \"\"\"\n    curr = parent[u]\n    while curr != -1:\n      if s[curr] == s[u]:\n        return curr\n      curr = parent[curr]\n    return -1\n\n  def _dfs(self, tree: list[list[int]], u: int, ans: list[int]) -> int:\n    sz = 1\n    for v in tree[u]:\n      sz += self._dfs(tree, v, ans)\n    ans[u] = sz\n    return sz",
      "title": "3331. Find Subtree Sizes After Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f4f1214-43ff-4454-8e96-956898c8b478",
      "code": "class Solution:\n  def maxScore(\n      self,\n      n: int,\n      k: int,\n      stayScore: list[list[int]],\n      travelScore: list[list[int]]\n  ) -> int:\n    # dp[i][j] := the maximum score after i days being at city j\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n      for dest in range(n):\n        # 1. Stay at the current city.\n        dp[i][dest] = dp[i - 1][dest] + stayScore[i - 1][dest]\n        # 2. Travel from any other city.\n        for curr in range(n):\n          if curr != dest:\n            dp[i][dest] = max(dp[i][dest],\n                              dp[i - 1][curr] + travelScore[curr][dest])\n\n    return max(dp[k])",
      "title": "3332. Maximum Points Tourist Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5eec4e63-12f4-4a1f-a983-e7e84621729a",
      "code": "class Solution:\n  def possibleStringCount(self, word: str, k: int) -> int:\n    MOD = 1_000_000_007\n    groups = self._getConsecutiveLetters(word)\n    totalCombinations = functools.reduce(lambda subtotal, group:\n                                         subtotal * group % MOD, groups)\n    if k <= len(groups):\n      return totalCombinations\n\n    # dp[j] := the number of ways to form strings of length j using groups[0..i]\n    dp = [0] * k\n    dp[0] = 1  # Base case: empty string\n\n    for i, group in enumerate(groups):\n      newDp = [0] * k\n      windowSum = 0\n      for j in range(i, k):\n        newDp[j] = (newDp[j] + windowSum) % MOD\n        windowSum = (windowSum + dp[j]) % MOD\n        if j >= group:\n          windowSum = (windowSum - dp[j - group] + MOD) % MOD\n      dp = newDp\n\n    return (totalCombinations - sum(dp)) % MOD\n\n  def _getConsecutiveLetters(self, word: str) -> list[int]:\n    \"\"\"\n    Returns consecutive identical letters in the input string.\n    e.g. \"aabbbc\" -> [2, 3, 1].\n    \"\"\"\n    groups = []\n    group = 1\n    for i in range(1, len(word)):\n      if word[i] == word[i - 1]:\n        group += 1\n      else:\n        groups.append(group)\n        group = 1\n    groups.append(group)\n    return groups",
      "title": "3333. Find the Original Typed String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7693e83-9548-479e-8741-fb84baa69b2e",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixGcd[i] := GCD of nums[0..i]\n    # prefixLcm[i] := LCM of nums[0..i]\n    prefixGcd, prefixLcm = self._getPrefix(nums)\n    # suffixGcd[i] := GCD of nums[i..n - 1]\n    # suffixLcm[i] := LCM of nums[i..n - 1]\n    suffixGcd, suffixLcm = self._getSuffix(nums)\n    ans = suffixGcd[0] * suffixLcm[0]\n\n    for i in range(n):\n      gcd1 = prefixGcd[i - 1] if i > 0 else 0\n      gcd2 = suffixGcd[i + 1] if i + 1 < n else 0\n      lcm1 = prefixLcm[i - 1] if i > 0 else 1\n      lcm2 = suffixLcm[i + 1] if i + 1 < n else 1\n      score = math.gcd(gcd1, gcd2) * math.lcm(lcm1, lcm2)\n      ans = max(ans, score)\n\n    return ans\n\n  def _getPrefix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the prefix GCD and LCM arrays.\"\"\"\n    prefixGcd = []\n    prefixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in nums:\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      prefixGcd.append(currGcd)\n      prefixLcm.append(currLcm)\n    return prefixGcd, prefixLcm\n\n  def _getSuffix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the suffix GCD and LCM arrays.\"\"\"\n    suffixGcd = []\n    suffixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in reversed(nums):\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      suffixGcd.append(currGcd)\n      suffixLcm.append(currLcm)\n    return list(reversed(suffixGcd)), list(reversed(suffixLcm))",
      "title": "3334. Find the Maximum Factor Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c851c35d-2029-41e1-9c45-3d976cb93afa",
      "code": "class Solution:\n  def lengthAfterTransformations(self, s: str, t: int) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix()\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    # 'z' -> 'ab'\n    T[25][0] = 1\n    T[25][1] = 1\n    # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n    for i in range(25):\n      T[i][i + 1] = 1\n    return T",
      "title": "3335. Total Characters in String After Transformations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3cdeea4-f661-4916-94c3-86010c27ea2d",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxNum = max(nums)\n    # dp[i][x][y] := number of disjoint pairs `seq1` and `seq2` of\n    # nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y\n    dp = [[[0] * (maxNum + 1)\n          for _ in range(maxNum + 1)]\n          for _ in range(len(nums) + 1)]\n    dp[0][0][0] = 1\n\n    for i, num in enumerate(nums):\n      for x in range(maxNum + 1):\n        for y in range(maxNum + 1):\n          # 1. Skip nums[i].\n          dp[i + 1][x][y] += dp[i][x][y]\n          dp[i + 1][x][y] %= MOD\n          # 2. Pick nums[i] in the first subsequence.\n          newX = math.gcd(x, num)\n          dp[i + 1][newX][y] += dp[i][x][y]\n          dp[i + 1][newX][y] %= MOD\n          # 3. Pick nums[i] in the second subsequence.\n          newY = math.gcd(y, num)\n          dp[i + 1][x][newY] += dp[i][x][y]\n          dp[i + 1][x][newY] %= MOD\n\n    return sum(dp[-1][g][g]\n               for g in range(1, maxNum + 1)) % MOD",
      "title": "3336. Find the Number of Subsequences With Equal GCD",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ca4682-c906-4864-8960-64615d65f9de",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, x: int, y: int) -> int:\n      if i == len(nums):\n        return int(x > 0 and x == y)\n      # 1. Skip nums[i]\n      skip = dp(i + 1, x, y)\n      # 2. Pick nums[i] in the first subsequence\n      take1 = dp(i + 1, math.gcd(x, nums[i]), y)\n      # 3. Pick nums[i] in the second subsequence\n      take2 = dp(i + 1, x, math.gcd(y, nums[i]))\n      return (skip + take1 + take2) % MOD\n\n    return dp(0, 0, 0)",
      "title": "3336. Find the Number of Subsequences With Equal GCD_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85551cb3-547d-4113-a9e2-6eeb6395edc1",
      "code": "class Solution:\n  # Similar to 3335. Total Characters in String After Transformations I\n  def lengthAfterTransformations(self, s: str, t: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix(nums)\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self, nums: list[int]) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    for i, steps in enumerate(nums):\n      for step in range(1, steps + 1):\n        T[i][(i + step) % 26] += 1\n    return T",
      "title": "3337. Total Characters in String After Transformations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49b52fa8-bd70-4cd6-bb06-f9d1156950e4",
      "code": "class Solution:\n  def countOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 10**9 + 7\n    even = m // 2  # the number of even numbers in [1, m]\n    odd = m - even  # the number of odd numbers in [1, m]\n    # dp[i][j][0/1] := the number of arrays of length i with j consecutive even\n    # number pairs ending in an even number (0) or an odd number (1)\n    dp = [[[0] * 2\n          for _ in range(k + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: arrays of length 1\n    # For an array of length 1, we can't have any even number pairs yet.\n    dp[1][0][0] = even\n    dp[1][0][1] = odd\n\n    for i in range(2, n + 1):\n      for j in range(k + 1):\n        # 1. Appending an even number to an array ending in an even number\n        #    creates a new consecutive even number pair.\n        # 2. Appending an even number to an array ending in an odd number.\n        dp[i][j][0] = ((dp[i - 1][j - 1][0] if j > 0 else 0) * even +\n                       dp[i - 1][j][1] * even) % MOD\n        # 3. Appending an odd number to an array.\n        dp[i][j][1] = sum(dp[i - 1][j]) * odd % MOD\n\n    return sum(dp[n][k]) % MOD",
      "title": "3339. Find the Number of K-Even Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc158990-a58a-4b7e-bec0-bb607f8af269",
      "code": "class Solution:\n  def isBalanced(self, num: str) -> bool:\n    nums = list(map(int, num))\n    return sum(nums[::2]) == sum(nums[1::2])",
      "title": "3340. Check Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2279683c-68c1-4686-b9d8-ec79b14e9fe9",
      "code": "class Solution:\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0), (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3341. Find Minimum Time to Reach Last Room I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eadcc65b-0830-475b-a761-824ba0b28edd",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0),\n                          (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, (ux, uy))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + (i + j) % 2 + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3342. Find Minimum Time to Reach Last Room II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db024d00-02e5-47d7-ad7d-b22465a82257",
      "code": "class Solution:\n  def countBalancedPermutations(self, num: str) -> int:\n    nums = list(map(int, num))\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return 0\n\n    nums.sort(reverse=True)\n\n    @functools.lru_cache(None)\n    def dp(even: int, odd: int, evenBalance: int) -> int:\n      \"\"\"\n      Returns the number of permutations where there are `even` even indices\n      left, `odd` odd indices left, and `evenBalance` is the target sum of the\n      remaining numbers to be placed in even indices.\n      \"\"\"\n      if evenBalance < 0:\n        return 0\n      if even == 0:\n        return (evenBalance == 0) * math.factorial(odd)\n      if odd == 0:\n        return (sum(nums[-(even + odd):]) == evenBalance) * math.factorial(even)\n      return (dp(even - 1, odd, evenBalance - nums[-(odd + even)]) * even +\n              dp(even, odd - 1, evenBalance) * odd)\n\n    MOD = 1_000_000_007\n    perm = functools.reduce(lambda x, y: x * math.factorial(y),\n                            collections.Counter(nums).values(), 1)\n    return (dp(even=(len(nums) + 1) // 2,\n               odd=len(nums) // 2,\n               evenBalance=summ // 2) // perm) % MOD",
      "title": "3343. Count Number of Balanced Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93119b6a-79c7-4e49-8c52-10603d96b4a7",
      "code": "class Solution:\n  def maxSizedArray(self, s: int) -> int:\n    def getNumbersWithBitSet(n: int, i: int) -> int:\n      \"\"\"\n      Returns the number of integers in [0, n - 1] with the i-th bit set.\n\n      For the i-th bit, numbers in the range [0, n - 1] can be divided into\n      groups of 2^(i + 1) numbers. In each group, exactly half of the numbers\n      have the i-th bit set.\n      \"\"\"\n      groupSize = 1 << (i + 1)\n      halfGroupSize = 1 << i\n      fullGroups = n // groupSize\n      remaining = max(0, (n % groupSize) - halfGroupSize)\n      return fullGroups * halfGroupSize + remaining\n\n    def getArraySum(n: int) -> int:\n      \"\"\"\n      Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.\n\n        sum(i * (j OR k)), where 0 <= i, j, k < n\n      = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)\n      = (0 + 1 + ... + n - 1) * sum(j OR k)\n      = (n * (n - 1) / 2) * sum(j OR k)\n      \"\"\"\n      arithmeticSum = n * (n - 1) // 2  # 0 + 1 + ... + n - 1\n      orSum = 0  # the sum of (j OR k) values in 2D arrays of size n^2\n      for i in range(n.bit_length()):\n        numbersWithoutBit = n - getNumbersWithBitSet(n, i)\n        pairsWithBit = n**2 - numbersWithoutBit**2\n        orSum += pairsWithBit * (1 << i)  # Add contribution of this bit.\n      return arithmeticSum * orSum\n\n    if s == 0:\n      return 1\n    l = 0\n    r = 1196  # when s = 10^15, n = 1196\n    return bisect.bisect_right(range(l, r + 1), s, key=getArraySum) - 1 + l",
      "title": "3344. Maximum Sized Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2da3b650-14b4-45d7-82b4-1d49fcf1cc02",
      "code": "class Solution:\n  def smallestNumber(self, n: int, t: int) -> int:\n    return next(num for num in range(n, n + 10)\n                if self._getDigitProd(num) % t == 0)\n\n  def _getDigitProd(self, num: int) -> int:\n    digitProd = 1\n    while num > 0:\n      digitProd *= num % 10\n      num //= 10\n    return digitProd",
      "title": "3345. Smallest Divisible Digit Product I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00edc750-d514-4562-ada8-040e6f7e32bf",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3346. Maximum Frequency of an Element After Performing Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fafb75f7-79ba-4fcc-b301-2ced81aa991b",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  # Same as 3346. Maximum Frequency of an Element After Performing Operations I\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3347. Maximum Frequency of an Element After Performing Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1e3ac9a-a88a-4aaa-931e-2780b99261b7",
      "code": "FACTOR_COUNTS = {\n    0: collections.Counter(),\n    1: collections.Counter(),\n    2: collections.Counter([2]),\n    3: collections.Counter([3]),\n    4: collections.Counter([2, 2]),\n    5: collections.Counter([5]),\n    6: collections.Counter([2, 3]),\n    7: collections.Counter([7]),\n    8: collections.Counter([2, 2, 2]),\n    9: collections.Counter([3, 3]),\n}\n\n\nclass Solution:\n  def smallestNumber(self, num: str, t: int) -> str:\n    primeCount, isDivisible = self._getPrimeCount(t)\n    if not isDivisible:\n      return '-1'\n\n    factorCount = self._getFactorCount(primeCount)\n    if sum(factorCount.values()) > len(num):\n      return ''.join(factor * freq for factor, freq in factorCount.items())\n\n    primeCountPrefix = sum((FACTOR_COUNTS[int(c)]\n                            for c in num), start=collections.Counter())\n    firstZeroIndex = next((i for i, d in enumerate(num) if d == '0'), len(num))\n    if firstZeroIndex == len(num) and primeCount <= primeCountPrefix:\n      return num\n\n    for i, c in reversed(list(enumerate(num))):\n      d = int(c)\n      # Remove the current digit's factors from primeCountPrefix.\n      primeCountPrefix -= FACTOR_COUNTS[d]\n      spaceAfterThisDigit = len(num) - 1 - i\n      if i <= firstZeroIndex:\n        for biggerDigit in range(d + 1, 10):\n          # Compute the required factors after replacing with a larger digit.\n          factorsAfterReplacement = self._getFactorCount(\n              primeCount - primeCountPrefix - FACTOR_COUNTS[biggerDigit]\n          )\n          # Check if the replacement is possible within the available space.\n          if sum(factorsAfterReplacement.values()) <= spaceAfterThisDigit:\n            # Fill extra space with '1', if any, and construct the result.\n            fillOnes = spaceAfterThisDigit - sum(\n                factorsAfterReplacement.values())\n            return (\n                num[:i]  # Keep the prefix unchanged.\n                + str(biggerDigit)  # Replace the current digit.\n                + '1' * fillOnes  # Fill remaining space with '1'.\n                + ''.join(factor * freq for factor,\n                          freq in factorsAfterReplacement.items())\n            )\n\n    # No solution of the same length exists, so we need to extend the number\n    # by prepending '1's and adding the required factors.\n    factorCount = self._getFactorCount(primeCount)\n    return (\n        '1' * (len(num) + 1 - sum(factorCount.values()))\n        + ''.join(factor * freq for factor, freq in factorCount.items())\n    )\n\n  def _getPrimeCount(self, t: int) -> tuple[dict[int, int], bool]:\n    \"\"\"\n    Returns the count of prime factors of t and if t is divisible by 2, 3, 5, 7.\n    \"\"\"\n    count = collections.Counter()\n    for prime in [2, 3, 5, 7]:\n      while t % prime == 0:\n        t //= prime\n        count[prime] += 1\n    return count, t == 1\n\n  def _getFactorCount(self, count: dict[int, int]) -> dict[str, int]:\n    \"\"\"Returns the required factors to form the smallest number.\"\"\"\n    count8, remaining2 = divmod(count[2], 3)  # 2^3 = 8\n    count9, count3 = divmod(count[3], 2)  # 3^2 = 9\n    count4, count2 = divmod(remaining2, 2)  # 2^2 = 4\n    # Combine 2 and 3 to 6 if both are present.\n    count2, count3, count6 = ((0, 0, 1) if count2 == 1 and count3 == 1\n                              else (count2, count3, 0))\n    # Combine 3 and 4 to 2 and 6 if both are present.\n    count2, count6, count3, count4 = ((1, 1, 0, 0)\n                                      if count3 == 1 and count4 == 1\n                                      else (count2, count6, count3, count4))\n    return {'2': count2, '3': count3, '4': count4, '5': count[5],\n            '6': count6, '7': count[7], '8': count8, '9': count9}",
      "title": "3348. Smallest Divisible Digit Product II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3ec2651-c6eb-4df4-a9a2-3df13a2810e4",
      "code": "class Solution:\n  def hasIncreasingSubarrays(self, nums: list[int], k: int) -> bool:\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      if increasing // 2 >= k or min(prevIncreasing, increasing) >= k:\n        return True\n\n    return False",
      "title": "3349. Adjacent Increasing Subarrays Detection I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fcf0aaf-a9a8-4bd5-ac28-c7af252d9290",
      "code": "class Solution:\n  # Similar to 3349. Adjacent Increasing Subarrays Detection I\n  def maxIncreasingSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      ans = max(ans, increasing // 2)\n      ans = max(ans, min(prevIncreasing, increasing))\n\n    return ans",
      "title": "3350. Adjacent Increasing Subarrays Detection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff09cea4-3723-4c9b-b588-2c34373b9a54",
      "code": "class Solution:\n  def sumOfGoodSubsequences(self, nums: list[int]) -> int:\n    MOD = 10**9 + 7\n    maxNum = max(nums)\n    # endsIn[i] := the number of good subsequences ending in i\n    endsIn = [0] * (maxNum + 2)\n    # dp[i] := the sum of good subsequences ending in i\n    dp = [0] * (maxNum + 2)\n\n    for num in nums:\n      seqsToAppend = 1 + endsIn[num - 1] + endsIn[num + 1]\n      dp[num] = (seqsToAppend * num +\n                 (dp[num] + dp[num - 1] + dp[num + 1])) % MOD\n      endsIn[num] += seqsToAppend % MOD\n\n    return sum(dp) % MOD",
      "title": "3351. Sum of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "056601fd-09b7-45ab-9c1f-2adc2b625fc5",
      "code": "class Solution:\n  def countKReducibleNumbers(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    ops = self._getOps(s)\n\n    @functools.lru_cache(None)\n    def dp(i: int, setBits: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of positive integers less than n that are k-reducible,\n      considering the i-th digit, where `setBits` is the number of set bits in\n      the current number, and `tight` indicates if the current digit is\n      tightly bound.\n      \"\"\"\n      if i == len(s):\n        return int(ops[setBits] < k and not tight)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 1\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        res += dp(i + 1, setBits + d, nextTight)\n        res %= MOD\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n\n  def _getOps(self, s: str) -> int:\n    \"\"\"Returns the number of operations to reduce a number to 0.\"\"\"\n    ops = [0] * (len(s) + 1)\n    for num in range(2, len(s) + 1):\n      ops[num] = 1 + ops[num.bit_count()]\n    return ops",
      "title": "3352. Count K-Reducible Numbers Less Than N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "336872ba-1d09-4339-b3d2-9b7a56c59e0c",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return sum(a != b for a, b in itertools.pairwise(nums))",
      "title": "3353. Minimum Total Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a9a61ff-61ed-4f2c-b3a9-2b571abd0668",
      "code": "class Solution:\n  def countValidSelections(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        continue\n      if prefix[i] == suffix[i]:\n        ans += 2  # Go to either direction.\n      if abs(prefix[i] - suffix[i]) == 1:\n        ans += 1  # Go to the direction with the larger sum.\n\n    return ans",
      "title": "3354. Make Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83909aa4-9d58-4727-9f88-11ce715b04dc",
      "code": "class Solution:\n  def isZeroArray(self, nums: list[int], queries: list[list[int]]) -> bool:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n\n    for l, r in queries:\n      line[l] += 1\n      line[r + 1] -= 1\n\n    for i, num in enumerate(nums):\n      decrement += line[i]\n      if decrement < num:\n        return False\n\n    return True",
      "title": "3355. Zero Array Transformation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0beabeaf-99d7-48ea-ba1a-1c7cb698b749",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n    k = 0\n\n    for i, num in enumerate(nums):\n      while decrement + line[i] < num:\n        if k == len(queries):\n          return -1\n        l, r, val = queries[k]\n        k += 1\n        if r < i:\n          continue\n        line[max(l, i)] += val\n        line[r + 1] -= val\n      decrement += line[i]\n\n    return k",
      "title": "3356. Zero Array Transformation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed401cc4-e276-4796-89cb-c48fb4620033",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    maxPositiveGap = 0\n    mn = 1_000_000_000\n    mx = 0\n\n    for a, b in itertools.pairwise(nums):\n      if (a == -1) != (b == -1):\n        positive = max(a, b)\n        mn = min(mn, positive)\n        mx = max(mx, positive)\n      else:\n        maxPositiveGap = max(maxPositiveGap, abs(a - b))\n\n    l = maxPositiveGap\n    r = (mx - mn + 1) // 2\n    return bisect.bisect_left(\n        range(l, r), True,\n        key=lambda m: self._check(nums, m, mn + m, mx - m)) + l\n\n  def _check(self, nums: list[int], m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns True if it's possible have `m` as maximum absolute difference\n    between adjacent numbers, where -1s are replaced with `x` or `y`.\n    \"\"\"\n    gapLength = 0\n    prev = 0\n\n    for num in nums:\n      if num == -1:\n        gapLength += 1\n        continue\n      if prev > 0 and gapLength > 0:\n        if gapLength == 1 and not self._checkSingleGap(prev, num, m, x, y):\n          return False\n        if gapLength > 1 and not self._checkMultipleGaps(prev, num, m, x, y):\n          return False\n      prev = num\n      gapLength = 0\n\n    # Check leading gaps\n    if nums[0] == -1:\n      num = next((num for num in nums if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    # Check trailing gaps\n    if nums[-1] == -1:\n      num = next((num for num in reversed(nums) if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    return True\n\n  def _checkSingleGap(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with a single -1 between two numbers.\n    e.g. [a, -1, b] can be filled with either x or y.\n    \"\"\"\n    gapWithX = max(abs(a - x), abs(b - x))  # [a, x, b]\n    gapWithY = max(abs(a - y), abs(b - y))  # [a, y, b]\n    return min(gapWithX, gapWithY) <= m\n\n  def _checkMultipleGaps(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with multiple -1s between two numbers.\n    e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.\n    \"\"\"\n    ax = abs(a - x)\n    ay = abs(a - y)\n    bx = abs(b - x)\n    by = abs(b - y)\n    xy = abs(x - y)\n    gapAllX = max(ax, bx)  # [a, x, x, ..., x, b]\n    gapAllY = max(ay, by)  # [a, y, y, ..., y, b]\n    gapXToY = max(ax, xy, by)  # [a, x, ..., y, b]\n    gapYToX = max(ay, xy, bx)  # [a, y, ..., x, b]\n    return min(gapAllX, gapAllY, gapXToY, gapYToX) <= m\n\n  def _checkBoundaryGaps(self, a: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a boundary sequence starting or ending with -1s.\n    e.g. [a, -1, -1, ...] or [..., -1, -1, a].\n    \"\"\"\n    gapAllX = abs(a - x)  # [x, x, ..., x, a]\n    gapAllY = abs(a - y)  # [y, y, ..., y, a]\n    return min(gapAllX, gapAllY) <= m",
      "title": "3357. Minimize the Maximum Adjacent Element Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75a5728c-725a-49fd-860d-93855bc879e6",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  subarrayWidth: int\n  rowIndex: int\n  accumulatedSubmatrices: int\n\n\nclass Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # dp[i][j] := the number of valid subarrays ending in grid[i][j]\n    dp = [[0] * n for _ in range(m)]\n    # stacks[j] := the stack of valid\n    # (subarray width, row index, number of accumulated submatrices) ending in\n    # column j\n    stacks: list[T] = [[T(0, -1, 0)] for _ in range(n)]\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num > k:\n          stacks[j] = [T(0, i, 0)]\n        else:\n          dp[i][j] = 1\n          if j > 0 and row[j - 1] <= k and row[j - 1] >= row[j]:\n            # Extend the valid subarrays to the current number.\n            dp[i][j] += dp[i][j - 1]\n          width = dp[i][j]\n          # Remove subarray widths greater than the current count since they\n          # will become invalid.\n          while stacks[j] and width < stacks[j][-1].subarrayWidth:\n            stacks[j].pop()\n          height = i - stacks[j][-1].rowIndex\n          newSubmatrices = width * height\n          accumulatedSubmatrices = (stacks[j][-1].accumulatedSubmatrices +\n                                    newSubmatrices)\n          ans += accumulatedSubmatrices\n          stacks[j].append(T(width, i, accumulatedSubmatrices))\n\n    return ans",
      "title": "3359. Find Sorted Submatrices With Maximum Element at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1194d930-503c-4b52-a464-32418474a1dc",
      "code": "class Solution:\n  def canAliceWin(self, n: int) -> bool:\n    for stones in range(10, -1, -1):\n      if stones > n:\n        return stones % 2 == 1\n      n -= stones",
      "title": "3360. Stone Removal Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85ff3e23-39a9-43ec-9e33-f73670dd7b90",
      "code": "class Solution:\n  def shiftDistance(\n      self,\n      s: str,\n      t: str,\n      nextCost: list[int],\n      previousCost: list[int]\n  ) -> int:\n    ans = 0\n    # prev[i][j]: the prev cost to shift from ('a' + i) to ('a' + j)\n    prev = [[0] * 26 for _ in range(26)]\n    # next[i][j]: the next cost to shift from ('a' + i) to ('a' + j)\n    next = [[0] * 26 for _ in range(26)]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        next[i][(i + j) % 26] = cost\n        cost += nextCost[(i + j) % 26]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        prev[i][(i - j + 26) % 26] = cost\n        cost += previousCost[(i - j + 26) % 26]\n\n    for a, b in zip(s, t):\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      ans += min(next[i][j], prev[i][j])\n\n    return ans",
      "title": "3361. Shift Distance Between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6581e72e-8315-4647-a350-b689af5753f8",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:\n    q = collections.deque(sorted(queries))\n    available = SortedList()  # available `r`s\n    running = SortedList()  # running `r`s\n\n    for i, num in enumerate(nums):\n      while q and q[0][0] <= i:\n        available.add(q.popleft()[1])\n      while running and running[0] < i:\n        running.pop(0)\n      while num > len(running):\n        if not available or available[-1] < i:\n          return -1\n        running.add(available.pop())\n\n    return len(available)",
      "title": "3362. Zero Array Transformation III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7342d6d4-d2de-42c5-afe8-f248c73ea98b",
      "code": "class Solution:\n  def maxCollectedFruits(self, fruits: list[list[int]]) -> int:\n    n = len(fruits)\n\n    def getTopLeft() -> int:\n      return sum(fruits[i][i] for i in range(n))\n\n    def getTopRight() -> int:\n      # dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[0][-1] = fruits[0][-1]\n      for x in range(n):\n        for y in range(n):\n          if x >= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(1, -1), (1, 0), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if i < j < n - 1 - i:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    def getBottomLeft() -> int:\n      # dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[-1][0] = fruits[-1][0]\n      for y in range(n):\n        for x in range(n):\n          if x <= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(-1, 1), (0, 1), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if j < i < n - 1 - j:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    return getTopLeft() + getTopRight() + getBottomLeft() - 2 * fruits[-1][-1]",
      "title": "3363. Find the Maximum Number of Fruits Collected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9287ff9e-383b-4f43-8f1e-4117985efd6d",
      "code": "class Solution:\n  def minimumSumSubarray(self, nums: list[int], l: int, r: int) -> int:\n    ans = math.inf\n\n    for windowSize in range(l, r + 1):\n      windowSum = sum(nums[:windowSize])\n      if windowSum > 0:\n        ans = min(ans, windowSum)\n      for i in range(windowSize, len(nums)):\n        windowSum -= nums[i - windowSize]\n        windowSum += nums[i]\n        if windowSum > 0:\n          ans = min(ans, windowSum)\n\n    return -1 if ans == math.inf else ans",
      "title": "3364. Minimum Positive Sum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83e5d1ab-17f5-443c-bd7f-d05a014d5ca5",
      "code": "class Solution:\n  def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:\n    n = len(s)\n    return (collections.Counter(s[i:i + n // k] for i in range(0, n, n // k)) ==\n            collections.Counter(t[i:i + n // k] for i in range(0, n, n // k)))",
      "title": "3365. Rearrange K Substrings to Form Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14ba09db-80e7-437d-9f1b-ec54bb1d9110",
      "code": "class Solution:\n  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:\n    n = len(nums)\n    # dp[i][j][k] := the minimum sum of nums[i..n - 1] with j operations of op1\n    # and k operations of op2\n    dp = [[[math.inf] * (op2 + 1)\n          for _ in range(op1 + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: When index reaches the end of the array, the result is 0.\n    for i in range(op1 + 1):\n      for j in range(op2 + 1):\n        dp[n][i][j] = 0\n\n    for i in range(n - 1, -1, -1):\n      for o1 in range(op1 + 1):\n        for o2 in range(op2 + 1):\n          summ = nums[i] + dp[i + 1][o1][o2]\n          if o1 > 0:\n            summ = min(summ, (nums[i] + 1) // 2 + dp[i + 1][o1 - 1][o2])\n          if o2 > 0 and nums[i] >= k:\n            summ = min(summ, nums[i] - k + dp[i + 1][o1][o2 - 1])\n          if o1 > 0 and o2 > 0:\n            if (nums[i] + 1) // 2 >= k:\n              summ = min(summ,\n                         (nums[i] + 1) // 2 - k + dp[i + 1][o1 - 1][o2 - 1])\n            if nums[i] >= k:\n              summ = min(summ,\n                         (nums[i] - k + 1) // 2 + dp[i + 1][o1 - 1][o2 - 1])\n          dp[i][o1][o2] = summ\n\n    return dp[0][op1][op2]",
      "title": "3366. Minimum Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b441ff4-7d72-416f-829c-34a8435da190",
      "code": "class Solution:\n  def maximizeSumOfWeights(self, edges: list[list[int]], k: int) -> int:\n    graph = [[] for _ in range(len(edges) + 1)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      \"\"\"\n      Returns\n      (the weight sum of the subtree rooted at u with at most k - 1 children,\n       the weight sum of the subtree rooted at u with at most k children).\n      \"\"\"\n      weightSum = 0\n      diffs = []\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        subK1, subK = dfs(v, u)\n        weightSum += subK\n        # If picking (u, v) makes the sum larger, we should pick it.\n        diffs.append(max(0, subK1 - subK + w))\n      return (weightSum + sum(heapq.nlargest(k - 1, diffs)),\n              weightSum + sum(heapq.nlargest(k, diffs)))\n\n    return dfs(0, -1)[1]",
      "title": "3367. Maximize Sum of Weights after Edge Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d826c283-0dc5-4425-9885-a97c4cf9e980",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> int:\n    return (1 << n.bit_length()) - 1",
      "title": "3370. Smallest Number With All Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f71e20a-1925-4e4c-85c6-72406ad670d5",
      "code": "class Solution:\n  def getLargestOutlier(self, nums: list[int]) -> int:\n    ans = -math.inf\n    summ = sum(nums)\n    count = collections.Counter(nums)\n\n    for num in nums:\n      withoutNum = summ - num\n      if withoutNum % 2 == 0:\n        specialSum = withoutNum // 2  # the sum of special numbers\n        if count[specialSum] > (1 if num == specialSum else 0):\n          ans = max(ans, num)\n\n    return ans",
      "title": "3371. Identify the Largest Outlier in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a54f0a5-1925-4feb-9e6e-ea745a9fc946",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n      k: int\n  ) -> list[int]:\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    maxReachableInGraph2 = 0\n\n    if k > 0:\n      for i in range(len(edges2) + 1):\n        maxReachableInGraph2 = max(maxReachableInGraph2,\n                                   self._dfs(graph2, i, -1, k - 1))\n\n    return [maxReachableInGraph2 + self._dfs(graph1, i, -1, k)\n            for i in range(len(edges1) + 1)]\n\n  def _dfs(self, graph: list[list[int]], u: int, prev: int, k: int) -> int:\n    \"\"\"Returns the number of nodes that can be reached from u with k steps.\"\"\"\n    if k == 0:\n      return 1\n    res = 0\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, k - 1)\n    return 1 + res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3372. Maximize the Number of Target Nodes After Connecting Trees I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b73cb8a-66f1-4658-a1b3-946ebbb7ca2e",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]]\n  ) -> list[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    parity1 = [False] * n\n    parity2 = [False] * m  # placeholder (parity2 is not used)\n    even1 = self._dfs(graph1, 0, -1, parity1, True)\n    even2 = self._dfs(graph2, 0, -1, parity2, True)\n    odd1 = n - even1\n    odd2 = m - even2\n\n    # Can connect the current node in tree1 to either an even node or an odd\n    # node in tree2.\n    return [(even1 if parity1[i] else odd1) + max(even2, odd2)\n            for i in range(n)]\n\n  def _dfs(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      parity: list[bool],\n      isEven: bool\n  ) -> int:\n    \"\"\"\n    Returns the number of nodes that can be reached from u with even steps.\n    \"\"\"\n    res = 1 if isEven else 0\n    parity[u] = isEven\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, parity, not isEven)\n    return res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3373. Maximize the Number of Target Nodes After Connecting Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ba6bee3-2968-408c-afc5-4f7eab31df77",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    numsSet = set(nums)\n    mn = min(nums)\n    if mn < k:\n      return -1\n    if mn > k:\n      return len(numsSet)\n    return len(numsSet) - 1",
      "title": "3375. Minimum Operations to Make Array Values Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4f5e543-aec0-4bed-90e5-74537b34a632",
      "code": "class Solution:\n  def minOperations(self, n: int, m: int) -> int:\n    isPrime = self._sieveEratosthenes(10000)\n    if isPrime[n] or isPrime[m]:\n      return -1\n    return self._dijkstra(n, m, isPrime)\n\n  def _dijkstra(self, src: int, dst: int, isPrime: list[bool]) -> int:\n    seen = {src}\n    minHeap = [(src, src)]  # (cost, num)\n\n    while minHeap:\n      cost, curr = heapq.heappop(minHeap)\n      if curr == dst:\n        return cost\n      s = list(str(curr))\n      for i, c in enumerate(s):\n        if c < '9':\n          s[i] = str(int(c) + 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n        if c > '0' and not (i == 0 and c == '1'):\n          s[i] = str(int(c) - 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n\n    return -1\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3377. Digit Operations to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d49d6b6a-b3df-4bee-a987-8eaae90d731c",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n    self.rank = collections.Counter()\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if u not in self.id:\n      self.id[u] = u\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, nums: list[int], threshold: int) -> int:\n    uf = UnionFind()\n\n    for num in nums:\n      for multiple in range(2 * num, threshold + 1, num):\n        uf.unionByRank(num, multiple)\n\n    return len(set(uf.find(num) for num in nums))",
      "title": "3378. Count Connected Components in LCM Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a49ddc4-e18b-49b2-a569-43ca29e33ef8",
      "code": "class Solution:\n  def constructTransformedArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    return [nums[(i + num % n + n) % n]\n            for i, num in enumerate(nums)]",
      "title": "3379. Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d32b25d-336e-46dd-ad8f-a6c5cb9a34b2",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    # minPrefix[i % k] := the minimum prefix sum of the first i numbers\n    minPrefix = [math.inf] * k\n    minPrefix[k - 1] = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      ans = max(ans, prefix - minPrefix[i % k])\n      minPrefix[i % k] = min(minPrefix[i % k], prefix)\n\n    return ans",
      "title": "3381. Maximum Subarray Sum With Length Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "106da807-b220-4456-a057-02567097c206",
      "code": "class Solution:\n  def minRunesToAdd(\n      self,\n      n: int,\n      crystals: list[int],\n      flowFrom: list[int],\n      flowTo: list[int]\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v in zip(flowFrom, flowTo):\n      graph[u].append(v)\n      reversedGraph[v].append(u)\n\n    # Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm.\n    seen = set()\n    orderStack = []\n    componentIds = [-1] * n\n    componentCount = 0\n\n    for i in range(n):\n      if i not in seen:\n        self._kosaraju(graph, i, seen, orderStack)\n\n    while orderStack:\n      u = orderStack.pop()\n      if componentIds[u] == -1:\n        self._identifySCC(reversedGraph, u, componentIds, componentCount)\n        componentCount += 1\n\n    # Track crystal-containing components and inter-component edges.\n    hasCrystal = [False] * componentCount\n    hasInterComponentEdge = [False] * componentCount\n\n    for u in crystals:\n      hasCrystal[componentIds[u]] = True\n\n    for u, v in zip(flowFrom, flowTo):\n      id1 = componentIds[u]\n      id2 = componentIds[v]\n      if id1 != id2:  # Edge is inter-component.\n        hasInterComponentEdge[id2] = True\n\n    return sum(not hasCrystal[i] and not hasInterComponentEdge[i]\n               for i in range(componentCount))\n\n  def _kosaraju(\n      self,\n      graph: list[list[int]],\n      u: int,\n      seen: set[int],\n      orderStack: list\n  ) -> None:\n    \"\"\"Creates a topological order stack using Kosaraju's Algorithm.\"\"\"\n    seen.add(u)\n    for v in graph[u]:\n      if v not in seen:\n        self._kosaraju(graph, v, seen, orderStack)\n    orderStack.append(u)\n\n  def _identifySCC(\n      self,\n      reversedGraph: list[list[int]],\n      u: int,\n      componentIds: list[int],\n      componentId: int\n  ) -> None:\n    \"\"\"Assigns component IDs during SCC identification in the second DFS.\"\"\"\n    if componentIds[u] != -1:\n      return\n    componentIds[u] = componentId\n    for v in reversedGraph[u]:\n      if componentIds[v] == -1:\n        self._identifySCC(reversedGraph, v, componentIds, componentId)",
      "title": "3383. Minimum Runes to Add to Cast Spell",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11e2a109-e4cf-44d5-907c-2a2d90476ead",
      "code": "class Solution:\n  def findMinimumTime(self, strength: list[int]) -> int:\n    costs = [[(s + turn - 1) // turn\n             for s in strength]\n             for turn in range(1, len(strength) + 1)]\n    return self._hungarian(costs)[-1]\n\n  def _hungarian(self, costs):\n    \"\"\"\n    Returns an array `res` of length n (costs.length), with `res[i]` equaling\n    the minimum cost to assign the first (i + 1) turns to the first (i + 1)\n    locks using Hungarian algorithm, where costs[i][j] is the energy required\n    to break j-th lock in i-th turn.\n\n    https://en.wikipedia.org/wiki/Hungarian_algorithm\n    \"\"\"\n    numLocks = len(costs)\n    turnPotentials = [0] * numLocks\n    lockPotentials = [0] * (numLocks + 1)\n    lockAssignments = [-1] * (numLocks + 1)\n    res = []\n\n    for currentTurn in range(numLocks):\n      currentLock = numLocks\n      lockAssignments[currentLock] = currentTurn\n      minReducedCosts = [math.inf] * (numLocks + 1)\n      previousLockAssignments = [-1] * (numLocks + 1)\n      locksInOptimalPath = [False] * (numLocks + 1)\n\n      while lockAssignments[currentLock] != -1:\n        locksInOptimalPath[currentLock] = True\n        assignedTurn = lockAssignments[currentLock]\n        minCostDelta = math.inf\n        nextLock = None\n\n        for lock in range(numLocks):\n          if not locksInOptimalPath[lock]:\n            reducedCost = (\n                costs[assignedTurn][lock] -\n                turnPotentials[assignedTurn] -\n                lockPotentials[lock]\n            )\n            oldMin = minReducedCosts[lock]\n            minReducedCosts[lock] = min(oldMin, reducedCost)\n            if minReducedCosts[lock] < oldMin:\n              previousLockAssignments[lock] = currentLock\n            if minReducedCosts[lock] < minCostDelta:\n              minCostDelta = minReducedCosts[lock]\n              nextLock = lock\n\n        for lock in range(numLocks + 1):\n          if locksInOptimalPath[lock]:\n            turnPotentials[lockAssignments[lock]] += minCostDelta\n            lockPotentials[lock] -= minCostDelta\n          else:\n            minReducedCosts[lock] -= minCostDelta\n\n        currentLock = nextLock\n\n      while currentLock != numLocks:\n        lockAssignments[currentLock] = lockAssignments[previousLockAssignments[currentLock]]\n        currentLock = previousLockAssignments[currentLock]\n\n      res.append(-lockPotentials[numLocks])\n\n    return res",
      "title": "3385. Minimum Time to Break Locks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bc895a-75c7-493f-b857-ab7c84973dff",
      "code": "class Solution:\n  def buttonWithLongestTime(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxTimeTaken = 0\n    prevTime = 0\n\n    for index, time in events:\n      timeTaken = time - prevTime\n      if timeTaken > maxTimeTaken or timeTaken == maxTimeTaken and index < ans:\n        maxTimeTaken = timeTaken\n        ans = index\n      prevTime = time\n\n    return ans",
      "title": "3386. Button with Longest Push Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c327cb0-b7f8-4fe1-b0bf-31445727ee7c",
      "code": "class Solution:\n  def maxAmount(\n      self,\n      initialCurrency: str,\n      pairs1: list[list[str]],\n      rates1: list[float],\n      pairs2: list[list[str]],\n      rates2: list[float]\n  ) -> float:\n    # dp[currency] := the maximum amount of money to convert to `currency`\n    dp: dict[str, float] = collections.defaultdict(float)\n    dp[initialCurrency] = 1.0\n    self._bellman(dp, pairs1, rates1)\n    self._bellman(dp, pairs2, rates2)\n    return dp[initialCurrency]\n\n  def _bellman(\n      self,\n      dp: dict[str, float],\n      pairs: list[list[str]],\n      rates: list[float]\n  ) -> None:\n    for _ in range(len(pairs)):\n      for (start, target), rate in zip(pairs, rates):\n        dp[target] = max(dp[target], dp[start] * rate)\n        dp[start] = max(dp[start], dp[target] / rate)",
      "title": "3387. Maximize Amount After Two Days of Conversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c28f00f-90ba-4721-87d3-5640a6df0cd0",
      "code": "class Solution:\n  def beautifulSplits(self, nums: list[int]) -> int:\n    n = len(nums)\n    # z[start][i] := the z array of nums[i..n) with respect to nums[start..n)\n    z = [self._zFunction(nums, start)\n         for start in range(n)]\n    # nums1 | nums2 | nums3 = nums[0..i] | nums[i + 1..j] | nums[j + 1..n - 1]\n    return sum((j - i >= i + 1 and z[0][i + 1] >= i + 1)  # nums1 is a prefix of nums2\n               or z[i + 1][j + 1] >= j - i  # nums2 is a suffix of nums3.\n               for i in range(n - 2)\n               for j in range(i + 1, n - 1))\n\n  def _zFunction(self, nums: list[int], start: int) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    nums[i..n) which is also a prefix of nums[start..n).\n    \"\"\"\n    n = len(nums)\n    z = [0] * n\n    l = start\n    r = start\n    for i in range(1 + start, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l + start])\n      while i + z[i] < n and nums[z[i] + start] == nums[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3388. Count Beautiful Splits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59c43d06-7bb4-47b4-9203-4f15fca8a8c1",
      "code": "class Solution:\n  def makeStringGood(self, s: str) -> int:\n    count = [0] * 26\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n    return min(self._getMinOperations(count, target)\n               for target in range(1, max(count) + 1))\n\n  def _getMinOperations(self, count: list[int], target: int) -> int:\n    # dp[i] represents the minimum number of operations to make the frequency of\n    # (i..25)-th (0-indexed) letters equal to `target`.\n    dp = [0] * 27\n\n    for i in range(25, -1, -1):\n      # 1. Delete all the i-th letters.\n      deleteAllToZero = count[i]\n      # 2. Insert/delete the i-th letters to have `target` number of letters.\n      deleteOrInsertToTarget = abs(target - count[i])\n      dp[i] = min(deleteAllToZero, deleteOrInsertToTarget) + dp[i + 1]\n      if i + 1 < 26 and count[i + 1] < target:\n        nextDeficit = target - count[i + 1]\n        # Make the frequency of the i-th letter equal to the `target` or 0.\n        needToChange = count[i] if count[i] <= target else count[i] - target\n        changeToTarget = (\n            # 3. Change all the i-th letters to the next letter and then\n            # insert the remaining deficit for the next letter.\n            needToChange + (nextDeficit - needToChange) if nextDeficit > needToChange\n            # 4. Change `nextDeficit` i-th letters to the next letter and\n            # then delete the remaining i-th letters.\n            else nextDeficit + (needToChange - nextDeficit)\n        )\n        dp[i] = min(dp[i], changeToTarget + dp[i + 2])\n\n    return dp[0]",
      "title": "3389. Minimum Operations to Make Character Frequencies Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63c82b9b-6c9e-411e-a910-788d47b9fa60",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    return sum(b == (a + c) * 2\n               for a, b, c in zip(nums, nums[1:], nums[2:]))",
      "title": "3392. Count Subarrays of Length Three With a Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a30c1fb-e039-4b54-bd74-066972cb4471",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid, k):\n    MOD = 1_000_000_007\n    MAX = 15\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][xors] := the number of paths from (i, j) to (m - 1, n - 1) with\n    # XOR value `xors`\n    dp = [[[0] * (MAX + 1)\n          for _ in range(n)]\n          for _ in range(m)]\n\n    dp[-1][-1][grid[-1][-1]] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        for xors in range(MAX + 1):\n          if i - 1 >= 0:\n            newXor = xors ^ grid[i - 1][j]\n            dp[i - 1][j][newXor] += dp[i][j][xors]\n            dp[i - 1][j][newXor] %= MOD\n          if j - 1 >= 0:\n            newXor = xors ^ grid[i][j - 1]\n            dp[i][j - 1][newXor] += dp[i][j][xors]\n            dp[i][j - 1][newXor] %= MOD\n\n    return dp[0][0][k]",
      "title": "3393. Count Paths With the Given XOR Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb3e723a-b313-4fd2-a851-6c61473af460",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def count(i: int, j: int, xors: int) -> int:\n      \"\"\"\n      Return the number of paths from (i, j) to (m - 1, n - 1) with XOR value\n      `xors`.\n      \"\"\"\n      if i == m or j == n:\n        return 0\n      xors ^= grid[i][j]\n      if i == m - 1 and j == n - 1:\n        return int(xors == k)\n      right = count(i, j + 1, xors)\n      down = count(i + 1, j, xors)\n      return (right + down) % MOD\n\n    return count(0, 0, 0)",
      "title": "3393. Count Paths With the Given XOR Value_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e589407f-0b97-4048-8489-55a23bc50240",
      "code": "class Solution:\n  def checkValidCuts(self, n: int, rectangles: list[list[int]]) -> bool:\n    xs = [(startX, endX) for startX, _, endX, _ in rectangles]\n    ys = [(startY, endY) for _, startY, _, endY in rectangles]\n    return max(self._countMerged(xs),\n               self._countMerged(ys)) >= 3\n\n  def _countMerged(self, intervals: list[tuple[int, int]]) -> int:\n    count = 0\n    prevEnd = 0\n    for start, end in sorted(intervals):\n      if start < prevEnd:\n        prevEnd = max(prevEnd, end)\n      else:\n        prevEnd = end\n        count += 1\n    return count",
      "title": "3394. Check if Grid can be Cut into Sections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cd69022-ff31-4783-9568-7a2e84a9858f",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3395. Subsequences with a Unique Middle Mode I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f18c4d97-5998-469d-a987-7fa9782ab6dd",
      "code": "class Solution:\n  def __init__(self):\n    self.MOD = 1_000_000_007\n\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    left = collections.Counter()\n    right = collections.Counter()\n\n    for i in range(2):\n      left[nums[i]] += 1\n\n    for i in range(2, n):\n      right[nums[i]] += 1\n\n    for i in range(2, n - 2):\n      num = nums[i]\n      right[num] -= 1\n      if right[num] == 0:\n        del right[num]\n\n      leftCount = left[num]\n      rightCount = right[num]\n      leftOther = i - leftCount\n      rightOther = n - 1 - i - rightCount\n\n      # count[mode] = 5 -- [a a] a [a a]\n      ans += math.comb(leftCount, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 4 -- [a a] a [a ?]\n      ans += math.comb(leftCount, 2) * rightCount * rightOther\n\n      # count[mode] = 4 -- [a ?] a [a a]\n      ans += leftCount * leftOther * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a a] a [? ?]\n      ans += math.comb(leftCount, 2) * math.comb(rightOther, 2)\n\n      # count[mode] = 3 -- [? ?] a [a a]\n      ans += math.comb(leftOther, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a ?] a [a ?]\n      ans += leftCount * leftOther * rightCount * rightOther\n\n      # count[mode] = 2 -- [a ?] a [? ?]\n      ans += leftCount * self._calc(num, leftOther, rightOther, left, right)\n\n      # count[mode] = 2 -- [? ?] a [a ?]\n      ans += rightCount * self._calc(num, rightOther, leftOther, right, left)\n\n      ans %= self.MOD\n      left[num] += 1\n\n    return ans\n\n  def _calc(\n      self,\n      a: int,\n      other1: int,\n      other2: int,\n      count1: dict[int, int],\n      count2: dict[int, int]\n  ) -> int:\n    \"\"\"\n    Returns the count of subsequences that have `a` as the middle number, where\n    invalid subsequences are excluded.\n    \"\"\"\n    # [a ?] a [? ?]\n    res = (other1 * math.comb(other2, 2)) % self.MOD\n\n    for b, b1 in count1.items():\n      if b == a:\n        continue\n      b2 = count2[b]\n      # Exclude triples -- [a b] a [b b].\n      res = (res - b1 * math.comb(b2, 2)) % self.MOD\n      # Exclude doubles -- [a b] a [b ?].\n      res = (res - b1 * b2 * (other2 - b2)) % self.MOD\n\n    for b, b2 in count2.items():\n      if b == a:\n        continue\n      b1 = count1[b]\n      # Exclude doubles -- [a ?] a [b b].\n      res = (res - (other1 - b1) * math.comb(b2, 2)) % self.MOD\n\n    return (res + self.MOD) % self.MOD",
      "title": "3395. Subsequences with a Unique Middle Mode I_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce680f2-e261-45d9-9b4c-38175c557105",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    seen = set()\n    for i, num in reversed(list(enumerate(nums))):\n      if num in seen:\n        return (i + 1 + 2) // 3  # ceil((i + 1) / 3)\n      seen.add(num)\n    return 0",
      "title": "3396. Minimum Number of Operations to Make Elements in Array Distinct",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b3c32de-4fd7-40b8-9489-c8c0faabb57d",
      "code": "class Solution:\n  def maxDistinctElements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    occupied = -math.inf\n\n    for num in sorted(nums):\n      if occupied < num + k:\n        occupied = max(occupied + 1, num - k)\n        ans += 1\n\n    return ans",
      "title": "3397. Maximum Number of Distinct Elements After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58dc6785-e464-4091-9ff6-a5ea037e717c",
      "code": "class Solution:\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3398. Smallest Substring With Identical Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3569e9e5-5253-4d79-8ef5-a58010e45df7",
      "code": "class Solution:\n  # Same as 3398. Smallest Substring With Identical Characters I\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3399. Smallest Substring With Identical Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "037bd0f7-2640-4f8c-ae03-261621f2e21e",
      "code": "class Solution:\n  def maximumMatchingIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n\n    for shift in range(n):\n      matches = 0\n      for i, num2 in enumerate(nums2):\n        if nums1[(i + shift) % n] == num2:\n          matches += 1\n      ans = max(ans, matches)\n\n    return ans",
      "title": "3400. Maximum Number of Matching Indices After Right Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8270b72f-ccf5-46df-ba56-181d6f686f64",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for j in range(len(grid[0])):\n      for i in range(1, len(grid)):\n        if grid[i][j] <= grid[i - 1][j]:\n          ans += grid[i - 1][j] - grid[i][j] + 1\n          grid[i][j] = grid[i - 1][j] + 1\n\n    return ans",
      "title": "3402. Minimum Operations to Make Columns Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f814705-b63c-4350-a3d6-0890616a8dd0",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3403. Find the Lexicographically Largest String From the Box I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac966374-f583-488b-8b00-54f556fec878",
      "code": "class Solution:\n  def numberOfSubsequences(self, nums: list[int]) -> int:\n    n = len(nums)\n    mx = max(nums)\n    ans = 0\n    count = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    # nums[p] * nums[r] == nums[q] * nums[s]\n    # nums[p] / nums[q] == nums[s] / nums[r]\n    for r in range(4, n - 1 - 2 + 1):\n      q = r - 2\n      for p in range(0, q - 2 + 1):\n        g = math.gcd(nums[p], nums[q])\n        count[nums[p] // g][nums[q] // g] += 1\n      for s in range(r + 2, n):\n        g = math.gcd(nums[s], nums[r])\n        ans += count[nums[s] // g][nums[r] // g]\n\n    return ans",
      "title": "3404. Count Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0449a476-85b8-4152-8661-0b2e3890101b",
      "code": "class Solution:\n  def countGoodArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    return m * pow(m - 1, n - k - 1, MOD) * math.comb(n - 1, k) % MOD",
      "title": "3405. Count the Number of Arrays with K Matching Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5324d15e-92e6-4d4b-85cb-15a7ec25612a",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3406. Find the Lexicographically Largest String From the Box II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "635450fd-914d-472e-9d3e-32b23bbdf322",
      "code": "class Solution:\n  def hasMatch(self, s: str, p: str) -> bool:\n    prefix, suffix = p.split('*')\n    i = s.find(prefix)\n    return i != -1 and s.find(suffix, i + len(prefix)) != -1",
      "title": "3407. Substring Matching Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed1dbd0c-5a61-4041-8bc2-029d3b26d5fe",
      "code": "class Solution:\n  def longestSubsequence(self, nums: list[int]) -> int:\n    mx = max(nums)\n    # dp[num][diff] := the length of the longest subsequence ending in `num`\n    # s.t. the last absolute difference between consecutive elements is `diff`\n    dp = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    for num in nums:\n      for prev in range(1, mx + 1):\n        diff = abs(num - prev)\n        dp[num][diff] = max(dp[num][diff], dp[prev][diff] + 1)\n      # dp[num][diff] := max(dp[num][j]) for j >= diff\n      for j in range(mx - 1, -1, -1):\n        dp[num][j] = max(dp[num][j], dp[num][j + 1])\n\n    return max(map(max, dp))",
      "title": "3409. Longest Subsequence With Decreasing Adjacent Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8abd7cc-a428-447d-98b9-19d42fbb5c32",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int]) -> int:\n    ans = max(nums)\n    prefix = 0\n    minPrefix = 0\n    # the minimum prefix sum that can have a negative number removed\n    modifiedMinPrefix = 0\n    count = collections.Counter()\n    # minPrefixPlusRemoval[num] := the minimum prefix sum plus removed `num`\n    minPrefixPlusRemoval = {}\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix - modifiedMinPrefix)\n      if num < 0:\n        count[num] += 1\n        minPrefixPlusRemoval[num] = (\n            min(minPrefixPlusRemoval.get(num, 0), minPrefix) + num)\n        modifiedMinPrefix = min(modifiedMinPrefix,\n                                count[num] * num,\n                                minPrefixPlusRemoval[num])\n      minPrefix = min(minPrefix, prefix)\n      modifiedMinPrefix = min(modifiedMinPrefix, minPrefix)\n\n    return ans",
      "title": "3410. Maximize Subarray Sum After Removing All Occurrences of One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "103403d2-2a92-4ae1-954b-87eb9ab4535e",
      "code": "class Solution:\n  def maxLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n\n    for i in range(n):\n      prod = 1\n      l = 1\n      g = 0\n      for j in range(i, n):\n        prod *= nums[j]\n        l = math.lcm(l, nums[j])\n        g = math.gcd(g, nums[j])\n        if prod == l * g:\n          ans = max(ans, j - i + 1)\n\n    return ans",
      "title": "3411. Maximum Subarray With Equal Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "189e3ade-b3e5-4575-8066-66b1cb5470c7",
      "code": "class Solution:\n  def calculateScore(self, s: str) -> int:\n    ans = 0\n    indices = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      oppositeIndex = 25 - index\n      if indices[oppositeIndex]:\n        ans += i - indices[oppositeIndex].pop()\n      else:\n        indices[index].append(i)\n\n    return ans",
      "title": "3412. Find Mirror Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28f1d2b6-6a0b-4aa1-af8a-58204030fa6b",
      "code": "class Solution:\n  def maximumCoins(self, coins: list[list[int]], k: int) -> int:\n    return max(self._slide(coins, k),\n               self._slide([[-r, -l, c] for l, r, c in coins], k))\n\n  def _slide(self, coins: list[list[int]], k: int) -> int:\n    coins.sort()\n    res = 0\n    windowSum = 0\n    j = 0\n    for li, ri, ci in coins:  # Consider the number line [li..li + k).\n      rightBoundary = li + k\n\n      # [lj, rj] is fully in [li..li + k).\n      while j + 1 < len(coins) and coins[j + 1][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        windowSum += (rj - lj + 1) * cj\n        j += 1\n\n      # [lj, rj] may be partially in [l..l + k).\n      last = 0\n      if j < len(coins) and coins[j][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        last = (min(rightBoundary - 1, rj) - lj + 1) * cj\n\n      res = max(res, windowSum + last)\n      windowSum -= (ri - li + 1) * ci\n    return res",
      "title": "3413. Maximum Coins From K Consecutive Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74678733-a94f-4b3e-8d55-dc011dff235e",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  weight: int\n  selected: tuple[int]\n\n  def __iter__(self):\n    yield self.weight\n    yield self.selected\n\n\nclass Solution:\n  def maximumWeight(self, intervals: list[list[int]]) -> list[int]:\n    intervals = sorted((*interval, i) for i, interval in enumerate(intervals))\n\n    @functools.lru_cache(None)\n    def dp(i: int, quota: int) -> T:\n      \"\"\"\n      Returns the maximum weight and the selected intervals for intervals[i..n),\n      where `quota` is the number of intervals that can be selected.\n      \"\"\"\n      if i == len(intervals) or quota == 0:\n        return T(0, ())\n\n      skip = dp(i + 1, quota)\n\n      _, r, weight, originalIndex = intervals[i]\n      j = bisect.bisect_right(intervals, (r, math.inf))\n      nextRes = dp(j, quota - 1)\n      pick = T(weight + nextRes.weight,\n               sorted((originalIndex, *nextRes.selected)))\n      return (pick if (pick.weight > skip.weight or\n                       pick.weight == skip.weight and pick.selected < skip.selected)\n              else skip)\n\n    return list(dp(0, 4).selected)",
      "title": "3414. Maximum Score of Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9513aea-a69a-437f-adf0-d70d193b63c2",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  # Same as 3395. Subsequences with a Unique Middle Mode I\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3416. Subsequences with a Unique Middle Mode II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b4fb7ba-db67-4da3-86bd-c5f3f976385e",
      "code": "class Solution:\n  def zigzagTraversal(self, grid: list[list[int]]) -> list[int]:\n    zigzag = [row[::-1] if i % 2 else row for i, row in enumerate(grid)]\n    return [num for row in zigzag for num in row][::2]",
      "title": "3417. Zigzag Grid Traversal With Skip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bcd3459-575e-4098-836a-55b03f306ec4",
      "code": "class Solution:\n  def maximumAmount(self, coins: list[list[int]]) -> int:\n    m = len(coins)\n    n = len(coins[0])\n    # dp[i][j][k] := the maximum profit at position (i, j) with k remaining\n    # neutralizations\n    dp = [[[-math.inf] * 4 for _ in range(n)] for _ in range(m)]\n\n    # Base case: the robot starts at the top-left corner.\n    dp[0][0][2] = coins[0][0]\n    if coins[0][0] < 0:\n      dp[0][0][1] = 0  # Neutralize the robber.\n\n    for i in range(m):\n      for j in range(n):\n        for k in range(3):  # for each number of remaining neutralizations\n          if i > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i - 1][j][k] + coins[i][j],\n                              dp[i - 1][j][k + 1])\n          if j > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i][j - 1][k] + coins[i][j],\n                              dp[i][j - 1][k + 1])\n\n    return max(dp[-1][-1])",
      "title": "3418. Maximum Amount of Money Robot Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d721db7-2385-4528-9c18-8df1ac4edc29",
      "code": "class Solution:\n  def minMaxWeight(self, n: int, edges: list[list[int]], threshold: int) -> int:\n    MAX = 1000000\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      reversedGraph[v].append((u, w))\n\n    l = 1\n    r = MAX + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if self._dfs(reversedGraph, 0, m, set()) == n:\n        r = m\n      else:\n        l = m + 1\n\n    return -1 if l == MAX + 1 else l\n\n  def _dfs(\n      self,\n      reversedGraph: list[list[tuple]],\n      u: int,\n      maxWeight: int,\n      seen: set[int]\n  ) -> int:\n    \"\"\"Returns the number of nodes reachable from u with weight <= maxWeight.\"\"\"\n    res = 1\n    seen.add(u)\n    for v, w in reversedGraph[u]:\n      if w > maxWeight or v in seen:\n        continue\n      res += self._dfs(reversedGraph, v, maxWeight, seen)\n    return res",
      "title": "3419. Minimize the Maximum Edge Weight of Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e000bfd2-b6cd-4149-bf88-92f1e2e8600f",
      "code": "class Solution:\n  def countNonDecreasingSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    cost = 0\n    # Store (number, count) pairs in non-increasing order. The numbers in the\n    # queue represent what nums[i..j] look like after adjustments.\n    dq = collections.deque()\n\n    j = len(nums) - 1\n    for i, num in reversed(list(enumerate(nums))):\n      count = 1\n      while dq and dq[-1][0] < num:\n        nextNum, nextCount = dq.pop()\n        count += nextCount\n        cost += (num - nextNum) * nextCount  # Adjust `nextNum`s to `num`.\n      dq.append((num, count))\n      while cost > k:  # Remove the rightmost number.\n        rightmostNum, rightmostCount = dq.popleft()\n        cost -= (rightmostNum - nums[j])\n        j -= 1\n        if rightmostCount > 1:\n          dq.appendleft((rightmostNum, rightmostCount - 1))\n      ans += j - i + 1\n\n    return ans",
      "title": "3420. Count Non-Decreasing Subarrays After K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "928653b3-68a9-4b80-8698-0e0b060d397e",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    window = SortedList(nums[:k])\n    median = window[(k - 1) // 2]\n    ops = sum(abs(median - nums[j]) for j in range(k))\n    ans = ops\n\n    for i in range(k, len(nums)):\n      window.remove(nums[i - k])\n      window.add(nums[i])\n      ops -= abs(median - nums[i - k])\n      ops += abs(median - nums[i])\n      newMedian = window[(k - 1) // 2]\n      medianMultiplier = (\n          2\n          if k % 2 == 0 and median <= newMedian <= window[k // 2]\n          else k % 2)\n      ops -= abs(newMedian - median) * medianMultiplier\n      median = newMedian\n      ans = min(ans, ops)\n\n    return ans",
      "title": "3422. Minimum Operations to Make Subarray Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242736fa-880d-4eb9-aa2c-fdfaf8c29dc3",
      "code": "class Solution:\n  def maxAdjacentDistance(self, nums: list[int]) -> int:\n    return max(abs(nums[i] - nums[i - 1])\n               for i in range(len(nums)))",
      "title": "3423. Maximum Difference Between Adjacent Elements in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5c0a1c-52b3-4997-8290-af70251f0f21",
      "code": "class Solution:\n  def minCost(self, arr: list[int], brr: list[int], k: int) -> int:\n    def cost(arr: list[int], brr: list[int]) -> int:\n      return sum(abs(a - b) for a, b in zip(arr, brr))\n    return min(cost(arr, brr), cost(sorted(arr), sorted(brr)) + k)",
      "title": "3424. Minimum Cost to Make Arrays Identical",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc6fdb3-6fbd-4b39-8072-11e6b9aa4655",
      "code": "class Solution:\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: int,\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n      leftBoundary = max(leftBoundary, prevDepth)\n\n      length = prefix[-1] - prefix[leftBoundary]\n      nodes = len(prefix) - leftBoundary\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=0)\n    return [maxLength, minNodes]",
      "title": "3425. Longest Special Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2b12161-df85-4d25-8916-7e3aff6f6136",
      "code": "class Solution:\n  def distanceSum(self, m: int, n: int, k: int) -> int:\n    # For each distance d, where 1 < d < m, there are `m - d` ways to choose\n    # the two columns that the two pieces are on. For each of the two pieces,\n    # there are `n` ways to choose the row that the piece is on.\n    # Therefore, the contribution of row differences is\n    #   sum(d * (m - d) * n^2), where 1 < d <= m - 1\n    # = n^2 * sum(d * m - d^2)\n    # = n^2 * (d * m * (m - 1) / 2 - m * (m - 1) * (2m - 1) / 6)\n    # = n^2 * (m^3 - m) / 6\n    # Similarly, the contribution of column differences is\n    #   m^2 * (n^3 - n) / 6\n    MOD = 1_000_000_007\n    return (n**2 * (m**3 - m) // 6 +\n            m**2 * (n**3 - n) // 6) * math.comb(m * n - 2, k - 2) % MOD",
      "title": "3426. Manhattan Distances of All Arrangements of Pieces",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1da620cb-7ad8-49b0-bd71-60745973ae32",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int]) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n    return sum(prefix[i + 1] - prefix[max(0, i - num)]\n               for i, num in enumerate((nums)))",
      "title": "3427. Sum of Variable Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0893d478-359b-43f6-a5d5-931ddb939b06",
      "code": "class Solution:\n  def minMaxSums(self, nums: list[int], k: int) -> int:\n    # In a sorted array, nums[i] will be\n    #   1. The maximum for subsequences formed by nums[0..i].\n    #   2. The minimum for subsequences formed by nums[i..n - 1].\n    #\n    # The number of times nums[i] is the maximum is the same as the number of\n    # times nums[n - 1 - i] is the minimum, due to the symmetry in subsequences\n    # derived from the sorted order.\n    #\n    # To calculate the contribution of nums[i], we need to find the number of\n    # ways to select at most (k - 1) elements from the range of indices where\n    # nums[i] is the smallest or nums[n - 1 - i] is the largest.\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getComb(n: int, k: int) -> list[list[int]]:\n      \"\"\"C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\"\"\"\n      comb = [[0] * (k + 1) for _ in range(n + 1)]\n      for i in range(n + 1):\n        comb[i][0] = 1\n      for i in range(1, n + 1):\n        for j in range(1, k + 1):\n          comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD\n      return comb\n\n    comb = getComb(n, k - 1)\n    ans = 0\n\n    nums.sort()\n\n    # i: available numbers from the left of nums[i] or\n    #    available numbers from the right of nums[-1 - i]\n    for i in range(n):\n      count = 0\n      for j in range(k):  # selected numbers\n        count = (count + comb[i][j]) % MOD\n      ans += nums[i] * count\n      ans += nums[-1 - i] * count\n      ans %= MOD\n\n    return ans",
      "title": "3428. Maximum and Minimum Sums of at Most Size K Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c8ccab1-53d0-422c-b189-45bfbbdce792",
      "code": "class Solution:\n  def minCost(self, n: int, costs: list[list[int]]) -> int:\n    INVALID_COLOR = 3\n\n    def getValidColors(prevColor: int) -> list[int]:\n      return [color for color in range(3) if color != prevColor]\n\n    @functools.lru_cache(None)\n    def minCost(i: int, prevLeftColor: int, prevRightColor: int) -> int:\n      if i == len(costs) // 2:\n        return 0\n      res = math.inf\n      for leftColor in getValidColors(prevLeftColor):\n        for rightColor in getValidColors(prevRightColor):\n          if leftColor == rightColor:\n            continue\n          leftCost = costs[i][leftColor]\n          rightCost = costs[-1 - i][rightColor]\n          res = min(res, leftCost + rightCost +\n                    minCost(i + 1, leftColor, rightColor))\n      return res\n\n    return minCost(0, INVALID_COLOR, INVALID_COLOR)",
      "title": "3429. Paint House IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2cda09f-6c94-4c80-93e3-36242fec7954",
      "code": "class Solution:\n  # Similar to 2104. Sum of Subarray Ranges\n  def minMaxSubarraySum(self, nums: list[int], k: int) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return (self._subarraySum(nums, prevGt, nextGt, k) +\n            self._subarraySum(nums, prevLt, nextLt, k))\n\n  def _subarraySum(\n      self,\n      nums: list[int],\n      prev: list[int],\n      next: list[int],\n      k: int\n  ) -> int:\n    \"\"\"\n    Returns the sum of all subarrays with a size <= k, The `prev` and `next`\n    arrays are used to store the indices of the nearest numbers that are\n    smaller or larger than the current number, respectively.\n    \"\"\"\n    res = 0\n    for i, num in enumerate(nums):\n      l = min(i - prev[i], k)\n      r = min(next[i] - i, k)\n      extra = max(0, l + r - 1 - k)\n      res += num * (l * r - extra * (extra + 1) // 2)\n    return res\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "3430. Maximum and Minimum Sums of at Most Size K Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "498a875c-cccd-4e16-ac7d-6691c136a9aa",
      "code": "class Solution:\n  def minUnlockedIndices(self, nums: list[int], locked: list[int]) -> int:\n    first2 = next((i for i, x in enumerate(nums) if x == 2), -1)\n    first3 = next((i for i, x in enumerate(nums) if x == 3), -1)\n    last1 = next((i for i, x in reversed(list(enumerate(nums))) if x == 1), -1)\n    last2 = next((i for i, x in reversed(list(enumerate(nums))) if x == 2), -1)\n    if first3 != -1 and last1 != -1 and first3 < last1:\n      return -1\n    return (sum(locked[i] == 1 for i in range(first2, last1)\n                if first2 != -1 and last1 != -1) +\n            sum(locked[i] == 1 for i in range(first3, last2)\n                if first3 != -1 and last2 != -1))",
      "title": "3431. Minimum Unlocked Indices to Sort Nums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a395ed5-b238-48b4-89da-509e2c77bcd9",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int]) -> int:\n    # If we add the same number in the left subarray and remove it from the\n    # right subarray, then the difference remains the same parity. So, just\n    # return the number of ways to partition the array into two subarrays when\n    # the array sum is even.\n    return len(nums) - 1 if sum(nums) % 2 == 0 else 0",
      "title": "3432. Count Partitions with Even Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc8318bf-faf2-434e-ba76-6e53df1ab5c3",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass OfflineUser:\n  returnTimestamp: int\n  userId: int\n\n  def __lt__(self, other):\n    return self.returnTimestamp < other.returnTimestamp\n\n\nclass Solution:\n  def countMentions(\n      self,\n      numberOfUsers: int,\n      events: list[list[str]]\n  ) -> list[int]:\n    ans = [0] * numberOfUsers\n    online = [True] * numberOfUsers\n    offlineQueue = []  # min-heap to track users that are offline\n    allMentionsCount = 0\n\n    events.sort(key=lambda x: (int(x[1]), -ord(x[0][0])))\n\n    for eventType, t, messageContent in events:\n      timestamp = int(t)\n      # Bring users back online if their offline period has ended.\n      while offlineQueue and offlineQueue[0].returnTimestamp <= timestamp:\n        user = heapq.heappop(offlineQueue)\n        online[user.userId] = True\n      if eventType == \"MESSAGE\":\n        match messageContent:\n          case \"ALL\":\n            allMentionsCount += 1\n          case \"HERE\":\n            for userId in range(numberOfUsers):\n              if online[userId]:\n                ans[userId] += 1\n          case _:\n            for userId in [int(part[2:]) for part in messageContent.split()]:\n              ans[userId] += 1\n      elif eventType == \"OFFLINE\":\n        userId = int(messageContent)\n        online[userId] = False\n        # Add to queue to bring back online after 60 units.\n        heapq.heappush(offlineQueue, OfflineUser(timestamp + 60, userId))\n\n    # Add the \"ALL\" mentions to all users.\n    for userId in range(numberOfUsers):\n      ans[userId] += allMentionsCount\n    return ans",
      "title": "3433. Count Mentions Per User",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5d0da9f-52d5-4480-8346-6c029f821221",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    return nums.count(k) + max(self._kadane(nums, target, k)\n                               for target in range(1, 51)\n                               if target != k)\n\n  def _kadane(self, nums: list[int], target: int, k: int) -> int:\n    \"\"\"\n    Returns the maximum achievable frequency of `k` by Kakane's algorithm,\n    where each `target` in subarrays is transformed to `k`.\n    \"\"\"\n    maxSum = 0\n    sum = 0\n    for num in nums:\n      if num == target:\n        sum += 1\n      elif num == k:\n        sum -= 1\n      if sum < 0:  # Reset sum if it becomes negative (Kadane's spirit).\n        sum = 0\n      maxSum = max(maxSum, sum)\n    return maxSum",
      "title": "3434. Maximum Frequency After Subarray Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63f29945-fac5-4007-9318-c7b7eef6d3ab",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def supersequences(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    edges = [(string.ascii_lowercase.index(words[0]),\n              string.ascii_lowercase.index(words[1]))\n             for words in words]\n    nodes = sorted({u for u, _ in edges} | {v for _, v in edges})\n    letterToIndex = {letter: i for i, letter in enumerate(nodes)}\n    graph = [[] for _ in range(len(nodes))]\n\n    for u, v in edges:\n      graph[letterToIndex[u]].append(letterToIndex[v])\n\n    for doubledSubset in self._getMinimumSubsets(graph):\n      freq = [0] * 26\n      for letter in nodes:\n        freq[letter] = 1\n      for index in doubledSubset:\n        freq[nodes[index]] = 2\n      ans.append(freq)\n\n    return ans\n\n  def _getMinimumSubsets(self, graph: list[list[int]]) -> list[tuple[int]]:\n    \"\"\"\n    Returns a list of the minimum subsets of nodes that do not create a cycle\n    when skipped.\n    \"\"\"\n    n = len(graph)\n    for subsetSize in range(n + 1):\n      doubleSubsets = []\n      for doubledSubset in itertools.combinations(range(n), subsetSize):\n        if not self._hasCycleSkipping(graph, set(doubledSubset)):\n          doubleSubsets.append(doubledSubset)\n      if doubleSubsets:\n        return doubleSubsets\n    return []\n\n  def _hasCycleSkipping(\n      self,\n      graph: list[list[int]],\n      doubledSubset: set[int]\n  ) -> bool:\n    \"\"\"\n    Returns True if there is a cycle in the `graph` when skipping any edges\n    whose both endpoints are in `doubledSubset`.\n    \"\"\"\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if u not in doubledSubset:\n        for v in graph[u]:\n          if v in doubledSubset:\n            continue\n          if hasCycle(v):\n            return True\n      states[u] = State.VISITED\n      return False\n\n    return any(hasCycle(i) for i in range(len(graph)))",
      "title": "3435. Frequencies of Shortest Supersequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1042236-a4ef-44e0-aa27-39328f71c84f",
      "code": "class Solution:\n  def permute(self, n: int) -> list[list[int]]:\n    ans = []\n    used = [False] * (n + 1)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == n:\n        ans.append(path.copy())\n        return\n      for num in range(1, n + 1):\n        if used[num]:\n          continue\n        if path and path[-1] % 2 == num % 2:\n          continue\n        used[num] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[num] = False\n\n    dfs([])\n    return ans",
      "title": "3437. Permutations III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f35fa2c2-b004-47da-98c6-6f90b78640d2",
      "code": "class Solution:\n  def findValidPair(self, s: str) -> str:\n    count = collections.Counter(s)\n    return next((a + b\n                for a, b in itertools.pairwise(s)\n                if a != b and count[a] == int(a) and count[b] == int(b)), '')",
      "title": "3438. Find Valid Pair of Adjacent Digits in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4604d159-72ee-4a0b-bb3e-67be68b68b35",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      k: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    windowSum = sum(gaps[:k + 1])\n    ans = windowSum\n\n    for i in range(k + 1, len(gaps)):\n      windowSum += gaps[i] - gaps[i - k - 1]\n      ans = max(ans, windowSum)\n\n    return ans",
      "title": "3439. Reschedule Meetings for Maximum Free Time I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "549910b7-29d6-4996-9068-0d5394438496",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    n = len(startTime)\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    ans = 0\n    maxLeft = [gaps[0]] + [0] * n  # maxLeft[i] := max(gaps[0..i])\n    maxRight = [0] * n + [gaps[n]]  # maxRight[i] := max(gaps[i..n])\n\n    for i in range(1, n + 1):\n      maxLeft[i] = max(gaps[i], maxLeft[i - 1])\n\n    for i in range(n - 1, -1, -1):\n      maxRight[i] = max(gaps[i], maxRight[i + 1])\n\n    for i, (start, end) in enumerate(zip(startTime, endTime)):\n      currMeetingTime = end - start\n      adjacentGapsSum = gaps[i] + gaps[i + 1]\n      canMoveMeeting = currMeetingTime <= max(\n          maxLeft[i - 1] if i > 0 else 0,\n          maxRight[i + 2] if i + 2 < n + 1 else 0\n      )\n      ans = max(ans, adjacentGapsSum +\n                (currMeetingTime if canMoveMeeting else 0))\n\n    return ans",
      "title": "3440. Reschedule Meetings for Maximum Free Time II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83a48273-ab5e-4e83-a531-483bfef907c2",
      "code": "class Solution:\n\n  def minCostGoodCaption(self, caption: str) -> str:\n    n = len(caption)\n    if n < 3:\n      return ''\n\n    MAX_COST = 1_000_000_000\n    # dp[i][j][k] := the minimum cost of caption[i..n - 1], where j is the last\n    # letter used, and k is the count of consecutive letters\n    dp = [[[MAX_COST] * 3 for _ in range(26)] for _ in range(n)]\n\n    for c in range(26):\n      dp[-1][c][0] = abs(string.ascii_lowercase.index(caption[-1]) - c)\n\n    minCost = MAX_COST\n\n    for i in range(n - 2, -1, -1):\n      newMinCost = MAX_COST\n      for c in range(26):\n        changeCost = abs(string.ascii_lowercase.index(caption[i]) - c)\n        dp[i][c][0] = changeCost + minCost\n        dp[i][c][1] = changeCost + dp[i + 1][c][0]\n        dp[i][c][2] = changeCost + min(dp[i + 1][c][1], dp[i + 1][c][2])\n        newMinCost = min(newMinCost, dp[i][c][2])\n      minCost = newMinCost\n\n    # Reconstruct the string.\n    ans = []\n    cost = MAX_COST\n    letter = -1\n\n    # Find the initial best letter.\n    for c in range(25, -1, -1):\n      if dp[0][c][2] <= cost:\n        letter = c\n        cost = dp[0][c][2]\n\n    # Add the initial triplet.\n    cost -= self._appendLetter(caption, 0, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 1, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 2, chr(ord('a') + letter), ans)\n\n    # Build the rest of the string.\n    i = 3\n    while i < n:\n      nextLetter = self._getNextLetter(dp, i, cost)\n      if nextLetter < letter or min(dp[i][letter]) > cost:\n        letter = nextLetter\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 1, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 2, chr(ord('a') + letter), ans)\n        i += 3\n      else:\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        i += 1\n\n    return ''.join(ans)\n\n  def _getNextLetter(self, dp: list[list[list[int]]], i: int, cost: int) -> int:\n    nextLetter = 26\n    for c in range(25, -1, -1):\n      if cost == dp[i][c][2]:\n        nextLetter = c\n    return nextLetter\n\n  def _appendLetter(\n      self,\n      caption: str,\n      i: int,\n      letter: str,\n      ans: list[str]\n  ) -> int:\n    ans.append(letter)\n    return abs(ord(caption[i]) - ord(letter))",
      "title": "3441. Minimum Cost Good Caption",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f2e2c41-d3b9-46c9-9d56-7c0cf0c8e389",
      "code": "class Solution:\n  def maxDifference(self, s: str) -> int:\n    count = collections.Counter(s)\n    maxOdd = max((freq for freq in count.values()\n                  if freq % 2 == 1), default=0)\n    minEven = min((freq for freq in count.values()\n                   if freq % 2 == 0), default=len(s))\n    return maxOdd - minEven",
      "title": "3442. Maximum Difference Between Even and Odd Frequency I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f24b274e-c049-420f-ba56-48bfdac84ce8",
      "code": "class Solution:\n  def maxDistance(self, s: str, k: int) -> int:\n    return max(self._flip(s, k, 'NE'), self._flip(s, k, 'NW'),\n               self._flip(s, k, 'SE'), self._flip(s, k, 'SW'))\n\n  def _flip(self, s: str, k: int, direction: str) -> int:\n    res = 0\n    pos = 0\n    opposite = 0\n\n    for c in s:\n      if c in direction:\n        pos += 1\n      else:\n        pos -= 1\n        opposite += 1\n      res = max(res, pos + 2 * min(k, opposite))\n\n    return res",
      "title": "3443. Maximum Manhattan Distance After K Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbd13d8c-b7a2-48c4-bb74-ab3e12215c14",
      "code": "class Solution:\n  def minimumIncrements(self, nums: list[int], target: list[int]) -> int:\n    maxMask = 1 << len(target)\n    maskToLcm = {}\n\n    for mask in range(1, maxMask):\n      subset = [num for i, num in enumerate(target) if mask >> i & 1]\n      maskToLcm[mask] = functools.reduce(math.lcm, subset, 1)\n\n    # dp[mask] := the minimum number of increments to make each number in the\n    # subset of target have at least one number that is a multiple in `num`,\n    # where `mask` is the bitmask of the subset of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for num in nums:\n      # maskToCost := (mask, cost), where `mask` is the bitmask of the subset\n      # of target and `cost` is the minimum number of increments to make each\n      # number in the subset of target have at least one number that is a\n      # multiple in `num`\n      maskToCost = [\n          (mask, 0 if (remainder := num % lcm) == 0 else lcm - remainder) for mask,\n          lcm in maskToLcm.items()]\n      newDp = dp[:]\n      for prevMask in range(maxMask):\n        if dp[prevMask] == float('inf'):\n          continue\n        for mask, cost in maskToCost:\n          newMask = prevMask | mask\n          newDp[newMask] = min(newDp[newMask], dp[prevMask] + cost)\n      dp = newDp\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "3444. Minimum Increments for Target Multiples in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c90bc3c-de44-4bd1-848c-2df42b5ce52a",
      "code": "class Solution:\n  def maxDifference(self, s: str, k: int) -> int:\n    ans = -math.inf\n    permutations = [(a, b) for a in '01234' for b in '01234' if a != b]\n\n    for a, b in permutations:\n      # minDiff[(parityA, parityB)] := min(a - b) of all valid windows with\n      # parityA and parityB\n      minDiff = collections.defaultdict(lambda: math.inf)\n      prefixA = [0]  # prefixA[i] := the number of 'a's in s[0..i)\n      prefixB = [0]  # prefixB[i] := the number of 'b's in s[0..i)\n\n      l = 0\n      for r, c in enumerate(s):\n        prefixA.append(prefixA[-1] + int(c == a))\n        prefixB.append(prefixB[-1] + int(c == b))\n        while (r - l + 1 >= k and  # the window size >= k\n               prefixA[l] < prefixA[-1] and  # the number of 'a's > 0\n               prefixB[l] < prefixB[-1]):  # the number of 'b's > 0\n          paritiesKey = (prefixA[l] % 2, prefixB[l] % 2)\n          minDiff[paritiesKey] = min(minDiff[paritiesKey],\n                                     prefixA[l] - prefixB[l])\n          l += 1\n        ans = max(ans, (prefixA[-1] - prefixB[-1]) -\n                  minDiff[(1 - prefixA[-1] % 2, prefixB[-1] % 2)])\n\n    return ans",
      "title": "3445. Maximum Difference Between Even and Odd Frequency II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e3aaec2-a17d-4287-b9a2-0764fd3ba5c0",
      "code": "class Solution:\n  def sortMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * n for _ in range(n)]\n    diag = collections.defaultdict(list)\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        diag[i - j].append(num)\n\n    for key in diag:\n      diag[key].sort(reverse=key < 0)\n\n    for i in range(n):\n      for j in range(n):\n        ans[i][j] = diag[i - j].pop()\n\n    return ans",
      "title": "3446. Sort Matrix by Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3da5880-55ad-4771-88dd-f66fa672a20d",
      "code": "class Solution:\n  def assignElements(self, groups: list[int], elements: list[int]) -> list[int]:\n    ans = []\n    elementToMinIndex = {}\n\n    for i, element in enumerate(elements):\n      if element not in elementToMinIndex:\n        elementToMinIndex[element] = i\n\n    for num in groups:\n      ans.append(self._getMinIndex(num, elementToMinIndex))\n\n    return ans\n\n  def _getMinIndex(self, num: int, elementToMinIndex: dict[int, int]) -> int:\n    res = math.inf\n    i = 1\n    while i * i <= num:\n      if num % i != 0:\n        continue\n      if i in elementToMinIndex:\n        res = min(res, elementToMinIndex[i])\n      if num // i != i and (num // i) in elementToMinIndex:\n        res = min(res, elementToMinIndex[num // i])\n      i += 1\n    return -1 if res == math.inf else res",
      "title": "3447. Assign Elements to Groups with Constraints",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58831607-b627-4b1b-834f-8910713d1444",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    ans = 0\n    # dp[i][num][rem] := the number of first `i` digits of s that have a\n    # remainder of `rem` when divided by `num`\n    dp = [[[0] * 10 for _ in range(10)] for _ in range(len(s) + 1)]\n\n    for i in range(1, len(s) + 1):\n      digit = int(s[i - 1])\n      for num in range(1, 10):\n        for rem in range(num):\n          dp[i][num][(rem * 10 + digit) % num] += dp[i - 1][num][rem]\n        dp[i][num][digit % num] += 1\n      ans += dp[i][digit][0]\n\n    return ans",
      "title": "3448. Count Substrings Divisible By Last Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60c09d5f-2863-4d59-bb4d-5fdbd3168f48",
      "code": "class Solution:\n  def maxScore(self, points: list[int], m: int) -> int:\n    def isPossible(minVal: int, m: int) -> bool:\n      \"\"\"\n      Returns True if it is possible to achieve the maximum minimum value `x`\n      with `m` number of moves.\n      \"\"\"\n      moves = 0\n      prevMoves = 0  # to track remaining moves from the previous point\n      for i, point in enumerate(points):\n        required = (minVal + point - 1) // point  # ceil(minVal / point)\n        required = max(0, required - prevMoves)\n        if required > 0:\n          moves += 2 * required - 1\n          prevMoves = required - 1\n        elif i + 1 < len(points):\n          moves += 1\n          prevMoves = 0\n        if moves > m:\n          return False\n      return True\n\n    l = 0\n    r = (m + 1) // 2 * points[0] + 1\n\n    while l < r:\n      mid = (l + r + 1) // 2\n      if isPossible(mid, m):\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "3449. Maximize the Minimum Game Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5972de3d-df80-432f-a16e-962d1cb03009",
      "code": "class Solution:\n  def maxStudentsOnBench(self, students: list[list[int]]) -> int:\n    benchToStudents = collections.defaultdict(set)\n    for studentId, benchId in students:\n      benchToStudents[benchId].add(studentId)\n    return max(map(len, benchToStudents.values()), default=0)",
      "title": "3450. Maximum Students on a Single Bench",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "465ee2bf-a507-482a-8f02-44e32c00523f",
      "code": "class Solution:\n  def sumOfGoodNumbers(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if (i - k < 0 or num > nums[i - k])\n               and (i + k >= len(nums) or num > nums[i + k]))",
      "title": "3452. Sum of Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cbbee1c-bd67-4bc8-804a-c0a3f51cd624",
      "code": "class Solution:\n  def separateSquares(self, squares: list[list[int]]) -> float:\n    halfArea = sum((l**2 for _, _, l in squares)) / 2\n    events = sorted([(y, True, l) for _, y, l in squares] +\n                    [(y + l, False, l) for _, y, l in squares])\n    area = 0\n    width = 0\n    prevY = 0\n\n    for y, isStart, l in events:\n      areaGain = width * (y - prevY)\n      if area + areaGain >= halfArea:\n        return prevY + (halfArea - area) / width\n      area += areaGain\n      width += l if isStart else -l\n      prevY = y",
      "title": "3453. Separate Squares I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9640e65-a4d8-467a-b2f5-a719fb5bad89",
      "code": "class Solution:\n  def shortestMatchingSubstring(self, s: str, p: str) -> int:\n    n = len(s)\n    a, b, c = p.split('*')\n    lpsA = self._getLPS(a + '#' + s)[len(a) + 1:]\n    lpsB = self._getLPS(b + '#' + s)[len(b) + 1:]\n    lpsC = self._getLPS(c + '#' + s)[len(c) + 1:]\n    ans = math.inf\n\n    i = 0  # lpsA's index\n    j = 0  # lpsB's index\n    k = 0  # lpsC's index\n    while i + len(b) + len(c) < n:\n      while i < n and lpsA[i] != len(a):\n        i += 1\n      while j < n and (j < i + len(b) or lpsB[j] != len(b)):\n        j += 1\n      while k < n and (k < j + len(c) or lpsC[k] != len(c)):\n        k += 1\n      if k == n:\n        break\n      ans = min(ans, k - i + len(a))\n      i += 1\n\n    return -1 if ans == math.inf else ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3455. Shortest Matching Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89da81b5-21a2-496a-ab46-353d3fa326dd",
      "code": "class Solution:\n  def hasSpecialSubstring(self, s: str, k: int) -> bool:\n    return any(len(list(group)) == k for _, group in groupby(s))",
      "title": "3456. Find Special Substring of Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3140091c-aa85-4620-8a38-7dd419b04fd6",
      "code": "class Solution:\n  def maxWeight(self, pizzas: list[int]) -> int:\n    eat = len(pizzas) // 4\n    odd = math.ceil(eat / 2)\n    even = eat - odd\n    pizzas.sort(reverse=True)\n    return (sum(pizzas[:odd]) +\n            sum(pizzas[odd + 1:odd + 1 + even * 2:2]))",
      "title": "3457. Eat Pizzas!",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9988be9c-15c7-4755-bb5c-77a5d20b4d88",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str, k: int) -> bool:\n    n = len(s)\n    first = [n] * 26\n    last = [-1] * 26\n    # dp[i] := the maximum disjoint special substrings for the first i letters\n    dp = [0] * (n + 1)\n    seenOrder = []\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if first[a] == n:\n        first[a] = i\n        seenOrder.append(c)\n      last[a] = i\n\n    for c in seenOrder:\n      a = ord(c) - ord('a')\n      for j in range(first[a], last[a]):\n        b = ord(s[j]) - ord('a')\n        first[a] = min(first[a], first[b])\n        last[a] = max(last[a], last[b])\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if last[a] != i or (first[a] == 0 and i == n - 1):\n        dp[i + 1] = dp[i]\n      else:  # Start a new special substring.\n        dp[i + 1] = max(dp[i], 1 + dp[first[a]])\n\n    return dp[n] >= k",
      "title": "3458. Select K Disjoint Special Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79fad4a8-55b3-4e9b-9b2d-20ba843859dc",
      "code": "class Solution:\n  def lenOfVDiagonal(self, grid: list[list[int]]) -> int:\n    DIRS = ((-1, 1), (1, 1), (1, -1), (-1, -1))\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, turned: bool, num: int, dir: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != num:\n        return 0\n\n      nextNum = 0 if num == 2 else 2\n      dx, dy = DIRS[dir]\n      res = 1 + dfs(i + dx, j + dy, turned, nextNum, dir)\n\n      if not turned:\n        nextDir = (dir + 1) % 4\n        nextDx, nextDy = DIRS[nextDir]\n        res = max(res, 1 + dfs(i + nextDx, j + nextDy, 1, nextNum, nextDir))\n\n      return res\n\n    return max((1 + dfs(i + dx, j + dy, 0, 2, d)\n                for i, row in enumerate(grid)\n                for j, num in enumerate(row)\n                if num == 1\n                for d, (dx, dy) in enumerate(DIRS)),\n               default=0)",
      "title": "3459. Length of Longest V-Shaped Diagonal Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "006209bd-4d33-4c9c-bbc3-432cf48d3d6d",
      "code": "class Solution:\n  def longestCommonPrefix(self, s: str, t: str) -> int:\n    i = 0  # s's index\n    j = 0  # t's index\n    canSkip = True\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        i += 1\n        j += 1\n      elif canSkip:\n        i += 1\n        canSkip = False\n      else:\n        return j\n\n    return j",
      "title": "3460. Longest Common Prefix After at Most One Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a03dbdb-41d4-45dd-b738-f712f59ccea4",
      "code": "class Solution:\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3461. Check If Digits Are Equal in String After Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7760489-8735-4788-925e-fb7679ceb8b4",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]], limits: list[int], k: int) -> int:\n    minHeap = []\n\n    for row, limit in zip(grid, limits):\n      row.sort(reverse=True)\n      for i in range(limit):\n        heapq.heappush(minHeap, row[i])\n        if len(minHeap) == k + 1:\n          heapq.heappop(minHeap)\n\n    return sum(minHeap)",
      "title": "3462. Maximum Sum With at Most K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f679db2-81ae-46df-88ef-68fe1e6b8774",
      "code": "class Solution:\n  # Same as 3461. Check If Digits Are Equal in String After Operations I\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3463. Check If Digits Are Equal in String After Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66ec43af-b110-4213-8ed7-b05fe93bb9fe",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Sequence:\n  startX: int\n  startY: int\n  endX: int\n  endY: int\n  length: int\n\n  def __iter__(self):\n    yield self.startX\n    yield self.startY\n    yield self.endX\n    yield self.endY\n    yield self.length\n\n\nclass Solution:\n  def maxDistance(self, side: int, points: list[list[int]], k: int) -> int:\n    ordered = self._getOrderedPoints(side, points)\n\n    def isValidDistance(m: int) -> bool:\n      \"\"\"\n      Returns True if we can select `k` points such that the minimum Manhattan\n      distance between any two consecutive chosen points is at least `m`.\n      \"\"\"\n      dq = collections.deque([Sequence(*ordered[0], *ordered[0], 1)])\n      maxLength = 1\n\n      for i in range(1, len(ordered)):\n        x, y = ordered[i]\n        startX, startY = ordered[i]\n        length = 1\n        while dq and abs(x - dq[0].endX) + abs(y - dq[0].endY) >= m:\n          if (abs(x - dq[0].startX) + abs(y - dq[0].startY) >= m\n                  and dq[0].length + 1 >= length):\n            startX = dq[0].startX\n            startY = dq[0].startY\n            length = dq[0].length + 1\n            maxLength = max(maxLength, length)\n          dq.popleft()\n        dq.append(Sequence(startX, startY, x, y, length))\n\n      return maxLength >= k\n\n    l = 0\n    r = side\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if isValidDistance(m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _getOrderedPoints(self, side: int, points: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Returns the ordered points on the perimeter of a square of side length\n    `side`, starting from left, top, right, and bottom boundaries.\n    \"\"\"\n    left = sorted([(x, y) for x, y in points if x == 0 and y > 0])\n    top = sorted([(x, y) for x, y in points if x > 0 and y == side])\n    right = sorted([(x, y) for x, y in points if x == side and y < side],\n                   reverse=True)\n    bottom = sorted([(x, y) for x, y in points if y == 0], reverse=True)\n    return left + top + right + bottom",
      "title": "3464. Maximize the Distance Between Points on a Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242985ea-b789-49e0-a746-bd7152340866",
      "code": "class Solution:\n  def maxCoins(self, lane1: list[int], lane2: list[int]) -> int:\n    n = len(lane1)\n    # dp[i][k] := the maximum number of coins at i-th mile with k switches\n    dp = [[-math.inf] * 3 for _ in range(n)]\n    dp[0][0] = lane1[0]\n    dp[0][1] = lane2[0]\n\n    for i in range(1, n):\n      dp[i][0] = max(0, dp[i - 1][0]) + lane1[i]\n      dp[i][1] = max(0, dp[i - 1][0], dp[i - 1][1]) + lane2[i]\n      dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + lane1[i]\n\n    return max(map(max, dp))",
      "title": "3466. Maximum Coin Collection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cd01f89-43c1-40c6-8e80-57e8c80c54e7",
      "code": "class Solution:\n  def transformArray(self, nums: list[int]) -> list[int]:\n    return ([0] * sum(num % 2 == 0 for num in nums) +\n            [1] * sum(num % 2 == 1 for num in nums))",
      "title": "3467. Transform Array by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c83d60cf-0d2f-4f31-8b5e-79e2bbc12965",
      "code": "class Solution:\n  def countArrays(self, original: list[int], bounds: list[list[int]]) -> int:\n    mn, mx = bounds[0]\n\n    for i in range(1, len(original)):\n      diff = original[i] - original[i - 1]\n      mn = max(mn + diff, bounds[i][0])\n      mx = min(mx + diff, bounds[i][1])\n\n    return max(0, mx - mn + 1)",
      "title": "3468. Find the Number of Copy Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "735ac7fc-c8e7-4b99-93ef-ebd55703c564",
      "code": "class Solution:\n  def minCost(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    @functools.lru_cache(None)\n    def dp(last: int, i: int) -> int:\n      if i == n:  # Single element left.\n        return nums[last]\n      if i == n - 1:  # Two elements left.\n        return max(nums[last], nums[i])\n      a = max(nums[i], nums[i + 1]) + dp(last, i + 2)\n      b = max(nums[last], nums[i]) + dp(i + 1, i + 2)\n      c = max(nums[last], nums[i + 1]) + dp(i, i + 2)\n      return min(a, b, c)\n\n    return dp(0, 1)",
      "title": "3469. Find Minimum Cost to Remove Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcd876ec-6f4f-42ff-a894-08bd2ab4dc6d",
      "code": "class Solution:\n  def permute(self, n: int, k: int) -> list[int]:\n    ans = []\n    isLookingForEven = True\n    remainingNumbers = list(range(1, n + 1))\n\n    for turn in range(n):\n      remainingPermutations = (math.factorial((n - 1 - turn) // 2) *\n                               math.factorial((n - turn) // 2))\n      found = False\n      for index, number in enumerate(remainingNumbers):\n        if number % 2 != isLookingForEven and (turn > 0 or n % 2 == 1):\n          continue\n        if k <= remainingPermutations:\n          ans.append(remainingNumbers.pop(index))\n          isLookingForEven = ans[-1] % 2 == 0\n          found = True\n          break\n        k -= remainingPermutations\n      if not found:\n        return []\n\n    return ans",
      "title": "3470. Permutations IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b6f3129-1178-4600-a963-78ad79aaaa13",
      "code": "class Solution:\n  def largestInteger(self, nums: list[int], k: int) -> int:\n    if k == len(nums):\n      return max(nums)\n    count = collections.Counter(nums)\n    if k == 1:\n      return max([num for num in nums if count[num] == 1], default=-1)\n    return max(\n        nums[0] if count[nums[0]] == 1 else -1,\n        nums[-1] if count[nums[-1]] == 1 else -1\n    )",
      "title": "3471. Find the Largest Almost Missing Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "488b2e6d-7b7d-4a58-8c72-836e1ca1cb4d",
      "code": "class Solution:\n  # Similar to 516. Longest Palindromic Subsequence\n  def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i][j][op] := the length of LPS(s[i..j]) with at most `op` operations\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      for op in range(k + 1):\n        dp[i][i][op] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for op in range(k + 1):\n          if s[i] == s[j]:\n            dp[i][j][op] = 2 + dp[i + 1][j - 1][op]\n          else:\n            dp[i][j][op] = max(dp[i + 1][j][op], dp[i][j - 1][op])\n            cost = self._getCost(s[i], s[j])\n            if cost <= op:\n              dp[i][j][op] = max(dp[i][j][op], 2 + dp[i + 1][j - 1][op - cost])\n\n    return dp[0][n - 1][k]\n\n  def _getCost(self, a: str, b: str) -> int:\n    dist = abs(ord(a) - ord(b))\n    return min(dist, 26 - dist)",
      "title": "3472. Longest Palindromic Subsequence After at Most K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82ac9c6c-992d-4013-80b3-0e9268ca5d58",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int, m: int) -> int:\n    INF = 20_000_000\n    n = len(nums)\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    # dp[i][ongoing][r] := the maximum sum of nums[i:], with `ongoing`\n    # indicating if a subarray is currently being extended (1) or not (0),\n    # and `r` segments left to choose\n    dp = [[[-INF] * (k + 1) for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case: At the end of the array, if no segments are left, score is 0\n    dp[n][0][0] = dp[n][1][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for rem in range(k + 1):\n        # When no subarray is ongoing:\n        # 1. Skip nums[i]\n        dp[i][0][rem] = dp[i + 1][0][rem]\n        # 2. Start a new segment of length m (only if rem > 0 and there're enough elements)\n        if rem > 0 and i + m <= n:\n          dp[i][0][rem] = max(\n              dp[i][0][rem],\n              dp[i + m][1][rem - 1] + (prefix[i + m] - prefix[i]))\n        # When a subarray is ongoing:\n        # 1. End the current subarray (transition to state 0, same index i)\n        # 2. Extend the current subarray by picking nums[i] and move to i + 1\n        dp[i][1][rem] = max(dp[i][0][rem], dp[i + 1][1][rem] + nums[i])\n\n    return dp[0][0][k]",
      "title": "3473. Sum of K Subarrays With Length at Least M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fd1486f-5531-45a1-9690-f5b6cde0e69a",
      "code": "class Solution:\n  def generateString(self, str1: str, str2: str) -> str:\n    n = len(str1)\n    m = len(str2)\n    sz = n + m - 1\n    ans = [None] * sz\n    modifiable = [True] * sz\n\n    # 1. Handle all 'T' positions first.\n    for i, tf in enumerate(str1):\n      if tf == 'T':\n        for j, c in enumerate(str2):\n          pos = i + j\n          if ans[pos] and ans[pos] != c:\n            return ''\n          ans[pos] = c\n          modifiable[pos] = False\n\n    # 2. Fill all remaining positions with 'a'.\n    for i in range(sz):\n      if not ans[i]:\n        ans[i] = 'a'\n\n    # 3. Handle all 'F' positions.\n    for i in range(n):\n      if str1[i] == 'F' and self._match(ans, i, str2):\n        modifiablePos = self._lastModifiablePosition(i, m, modifiable)\n        if modifiablePos == -1:\n          return ''\n        ans[modifiablePos] = 'b'\n        modifiable[modifiablePos] = False\n\n    return ''.join(ans)\n\n  def _match(self, ans: list, i: int, s: str) -> bool:\n    \"\"\"Returns True if the substring of ans starting at `i` matches `s`.\"\"\"\n    for j, c in enumerate(s):\n      if ans[i + j] != c:\n        return False\n    return True\n\n  def _lastModifiablePosition(self, i: int, m: int, modifiable: list) -> int:\n    \"\"\"\n    Finds the last modifiable position in the substring of ans starting at `i`.\n    \"\"\"\n    modifiablePos = -1\n    for j in range(m):\n      pos = i + j\n      if modifiable[pos]:\n        modifiablePos = pos\n    return modifiablePos",
      "title": "3474. Lexicographically Smallest Generated String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e81bcb71-5b94-4cfa-8bb1-720a20cdfd2c",
      "code": "class Solution:\n  def maxProfit(self, workers: list[int], tasks: list[list[int]]) -> int:\n    totalProfit = 0\n    skillToProfits = collections.defaultdict(list)\n\n    for skill, profit in tasks:\n      skillToProfits[skill].append(profit)\n\n    for skill in skillToProfits:\n      skillToProfits[skill].sort(reverse=True)\n\n    for workerSkill in workers:\n      if workerSkill in skillToProfits and skillToProfits[workerSkill]:\n        profit = skillToProfits[workerSkill][0]\n        skillToProfits[workerSkill].pop(0)\n        totalProfit += profit\n\n    return totalProfit + max(max(profits, default=0)\n                             for profits in skillToProfits.values())",
      "title": "3476. Maximize Profit from Task Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86868cb6-785d-4831-aba6-faab17720866",
      "code": "class Solution:\n  def findMaxSum(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    ans = [0] * len(nums1)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums1)])\n    minHeap = []\n\n    firstIndex = numAndIndexes[0][1]\n    heapq.heappush(minHeap, nums2[firstIndex])\n    summ = nums2[firstIndex]\n\n    for (prevNum, prevIndex), (currNum, currIndex) in itertools.pairwise(numAndIndexes):\n      if currNum == prevNum:\n        ans[currIndex] = ans[prevIndex]\n      else:\n        ans[currIndex] = summ\n      heapq.heappush(minHeap, nums2[currIndex])\n      summ += nums2[currIndex]\n      if len(minHeap) == k + 1:\n        summ -= heapq.heappop(minHeap)\n\n    return ans",
      "title": "3478. Choose K Elements With Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9ea080f-70ce-4eca-b5f1-e2fc71713983",
      "code": "class Solution:\n  def maxSubarrays(self, n: int, conflictingPairs: list[list[int]]) -> int:\n    validSubarrays = 0\n    maxLeft = 0\n    secondMaxLeft = 0\n    # gains[i] := the number of additional valid subarrays we can gain if the\n    # restriction at index `i` is removed\n    gains = [0] * (n + 1)\n    # conflicts[r] := left endpoints that conflict with subarrays ending in r\n    conflicts = [[] for _ in range(n + 1)]\n\n    for a, b in conflictingPairs:\n      conflicts[max(a, b)].append(min(a, b))\n\n    for right in range(1, n + 1):\n      for left in conflicts[right]:\n        if left > maxLeft:\n          secondMaxLeft = maxLeft\n          maxLeft = left\n        elif left > secondMaxLeft:\n          secondMaxLeft = left\n      # Subarrays [maxLeft + 1..right],\n      #           [maxLeft + 2..right],\n      #           ...\n      #           [right..right] are valid.\n      validSubarrays += right - maxLeft\n      # If we remove `maxLeft` (the most restrictive conflict), we gain\n      # `maxLeft - secondMaxLeft` new subarrays:\n      # [secondMaxLeft + 1..right],\n      # [secondMaxLeft + 2..right],\n      # ...\n      # [maxLeft..right].\n      gains[maxLeft] += maxLeft - secondMaxLeft\n\n    return validSubarrays + max(gains)",
      "title": "3480. Maximize Subarrays After Removing One Conflicting Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed33947e-4f58-45f0-995c-3f551eb32d43",
      "code": "class Solution:\n  def applySubstitutions(self, replacements: list[list[str]], text: str) -> str:\n    replaceMap = {key: value for key, value in replacements}\n\n    def evaluate(text: str) -> str:\n      \"\"\"\n      Evaluates the text and replaces the placeholders with the values\n      from the replace_map recursively.\n      \"\"\"\n      res = []\n      i = 0\n      while i < len(text):\n        if text[i] == '%':\n          j = i + 1 + text[i + 1:].find('%')\n          key = text[i + 1:j]\n          value = replaceMap[key]\n          res.append(evaluate(value))\n          i = j + 1\n        else:\n          res.append(text[i])\n          i += 1\n      return ''.join(res)\n\n    return evaluate(text)",
      "title": "3481. Apply Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d15b70f0-10df-4b79-888b-5409f3fb0512",
      "code": "class Solution:\n  def totalNumbers(self, digits: list[int]) -> int:\n    nums = set()\n\n    for a, b, c in itertools.permutations(digits, 3):\n      if a != 0 and c % 2 == 0:\n        nums.add(a * 100 + b * 10 + c)\n\n    return len(nums)",
      "title": "3483. Unique 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c05f8e47-c4bc-4054-97c1-c43451bde2df",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self, k: int):\n    self.k = k\n    self.root = TrieNode()\n    self.prefixLengthsCount = collections.Counter()\n    self.prefixLengths = SortedList()\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children.setdefault(c, TrieNode())\n      node.count += 1\n      if node.count >= self.k:\n        self.prefixLengthsCount[sz] += 1\n        if self.prefixLengthsCount[sz] == 1:\n          self.prefixLengths.add(-sz)\n\n  def erase(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children[c]\n      if node.count == self.k:\n        self.prefixLengthsCount[sz] -= 1\n        if self.prefixLengthsCount[sz] == 0:\n          self.prefixLengths.remove(-sz)\n      node.count -= 1\n\n  def getLongestCommonPrefix(self) -> int:\n    return 0 if not self.prefixLengths else -self.prefixLengths[0]\n\n\nclass Solution:\n  def longestCommonPrefix(self, words: list[str], k: int) -> list[int]:\n    ans = []\n    trie = Trie(k)\n\n    for word in words:\n      trie.insert(word)\n\n    for word in words:\n      trie.erase(word)\n      ans.append(trie.getLongestCommonPrefix())\n      trie.insert(word)\n\n    return ans",
      "title": "3485. Longest Common Prefix of K Strings After Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c05fbf67-0429-40f1-843b-61235b29179e",
      "code": "class Solution:\n  # Similar to 3425. Longest Special Path\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: list[int],\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n\n      if prevDepth != 0:\n        leftBoundary = sorted(leftBoundary + [prevDepth])[-2:]\n\n      length = prefix[-1] - prefix[leftBoundary[0]]\n      nodes = len(prefix) - leftBoundary[0]\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=[0, 0])\n    return [maxLength, minNodes]",
      "title": "3486. Longest Special Path II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad6a54a1-0b7e-4d04-ae0c-adc730fc60f2",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    mx = max(nums)\n    if mx <= 0:\n      return mx\n    return sum(max(0, num) for num in set(nums))",
      "title": "3487. Maximum Unique Subarray Sum After Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e8335f3-3c02-4c50-ae9e-236bea3c6157",
      "code": "class Solution:\n  def solveQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    # minDist[i] := the minimum distance between nums[i], and any other index j\n    # in the circular array, where nums[j] == nums[i]\n    minDist = [n] * n\n    lastSeen = {}\n\n    for i in range(n * 2):\n      index = i % n\n      num = nums[index]\n      if num in lastSeen:\n        prevIndex = lastSeen[num] % n\n        d = i - prevIndex\n        minDist[index] = min(minDist[index], d)\n        minDist[prevIndex] = min(minDist[prevIndex], d)\n      lastSeen[num] = i\n\n    return [-1 if minDist[query] == n\n            else minDist[query]\n            for query in queries]",
      "title": "3488. Closest Equal Element Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ade89177-dbbf-45a9-b189-a8e767dc2eb9",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    if all(num == 0 for num in nums):\n      return 0\n\n    n = len(nums)\n    subsetSums = [{0} for _ in range(n)]\n\n    for k, (l, r, val) in enumerate(queries):\n      for i in range(l, r + 1):\n        newSums = {subsetSum + val for subsetSum in subsetSums[i]}\n        subsetSums[i].update(newSums)\n      if all(nums[i] in subsetSums[i] for i in range(n)):\n        return k + 1\n\n    return -1",
      "title": "3489. Zero Array Transformation IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eef1908-3301-4082-816d-33df6d818feb",
      "code": "class Solution:\n  def beautifulNumbers(self, l: int, r: int) -> int:\n    @functools.lru_cache(None)\n    def dp(\n        s: str,\n        i: int,\n        tight: bool,\n        isLeadingZero: bool,\n        hasZero: bool,\n        sum: int,\n        prod: int,\n    ) -> int:\n      if i == len(s):\n        if isLeadingZero:\n          return 0\n        return 1 if hasZero or prod % sum == 0 else 0\n      if not isLeadingZero and hasZero and not tight:\n        return 10 ** (len(s) - i)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        nextIsLeadingZero = isLeadingZero and d == 0\n        nextHasZero = not nextIsLeadingZero and d == 0\n        nextProd = 1 if nextIsLeadingZero else prod * d\n        res += dp(s, i + 1, nextTight, nextIsLeadingZero,\n                  nextHasZero, sum + d, nextProd)\n\n      return res\n\n    return (dp(str(r), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1) -\n            dp(str(l - 1), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1))",
      "title": "3490. Count Beautiful Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29bdecf9-7abd-457c-b3a2-7036906d4319",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, number: str) -> None:\n    node: TrieNode = self.root\n    for d in number:\n      node = node.children.setdefault(d, TrieNode())\n    node.isWord = True\n\n  def search(self, number: str) -> bool:\n    \"\"\"\n    Returns True if the number is a prefix of any number in the trie or any\n    number in the trie is a prefix of the number.\n    \"\"\"\n    node: TrieNode = self.root\n    for d in number:\n      if d not in node.children:\n        return False\n      node = node.children[d]\n      if node.isWord:\n        return True\n    return True  # The number is a prefix of some number in the trie.\n\n\nclass Solution:\n  def phonePrefix(self, numbers: list[str]) -> bool:\n    trie = Trie()\n\n    for number in numbers:\n      if trie.search(number):\n        return False\n      trie.insert(number)\n\n    return True",
      "title": "3491. Phone Number Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3517627f-db6e-41d4-981a-0917af448f3b",
      "code": "class Solution:\n  def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n    return min(n * n, maxWeight // w)",
      "title": "3492. Maximum Containers on a Ship",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec5d5712-30bf-4de7-92bd-bd32b7e432fa",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numberOfComponents(self, properties: list[list[int]], k: int) -> int:\n    n = len(properties)\n    uf = UnionFind(n)\n    propertySets = [set(property) for property in properties]\n\n    for i, j in itertools.combinations(range(n), 2):\n      if len(propertySets[i] & propertySets[j]) >= k:\n        uf.unionByRank(i, j)\n\n    return uf.getCount()",
      "title": "3493. Properties Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783490b2-acc5-4555-a315-e9e2655eb3f0",
      "code": "class Solution:\n  def minTime(self, skill: list[int], mana: list[int]) -> int:\n    sumSkill = sum(skill)\n    prevWizardDone = sumSkill * mana[0]\n\n    for j in range(1, len(mana)):\n      prevPotionDone = prevWizardDone\n      for i in range(len(skill) - 2, -1, -1):\n        # start time for wizard i brewing potion j\n        # = max(end time for wizard i brewing potion j - 1,\n        #       the earliest start time for wizard i + 1 brewing potion j\n        #       (coming from previous iteration)\n        #       - time for wizard i brewing potion j)\n        prevPotionDone -= skill[i + 1] * mana[j - 1]\n        prevWizardDone = max(prevPotionDone,\n                             prevWizardDone - skill[i] * mana[j])\n      prevWizardDone += sumSkill * mana[j]\n\n    return prevWizardDone",
      "title": "3494. Find the Minimum Amount of Time to Brew Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1a02d89-2463-4db5-9f7f-77a4c49a8c86",
      "code": "class Solution:\n  def minOperations(self, queries: list[list[int]]) -> int:\n    return sum((self._getOperations(r) - self._getOperations(l - 1) + 1) // 2\n               for l, r in queries)\n\n  def _getOperations(self, n: int) -> int:\n    \"\"\"Returns the number of operations required for [1, n].\"\"\"\n    res = 0\n    ops = 0\n    powerOfFour = 1\n    while powerOfFour <= n:\n      l = powerOfFour\n      r = min(n, powerOfFour * 4 - 1)\n      ops += 1\n      res += (r - l + 1) * ops\n      powerOfFour *= 4\n    return res",
      "title": "3495. Minimum Operations to Make Array Elements Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d54605-9c42-447c-b397-9e2eb86cb41e",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    if len(nums) % 2 == 1:\n      return summ - min(nums)\n    return summ - min(a + b for a, b in itertools.pairwise(nums))",
      "title": "3496. Maximize Score After Pair Deletions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f03e3d35-e74a-4773-91ae-5a9ed3b6c289",
      "code": "class Solution:\n  def reverseDegree(self, s: str) -> int:\n    return sum((26 - (ord(c) - ord('a'))) * (i + 1)\n               for i, c in enumerate(s))",
      "title": "3498. Reverse Degree of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58016790-71ff-4ec6-9f93-9bd97dc82ac9",
      "code": "class Solution:\n  def maxActiveSectionsAfterTrade(self, s: str) -> int:\n    zeroGroups = [len(list(g)) for c, g in itertools.groupby(s) if c == '0']\n    return s.count('1') + max(map(sum, pairwise(zeroGroups)), default=0)",
      "title": "3499. Maximize Active Section with Trade I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fa6d316-475c-49ef-921d-39c09fac9a6c",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int], cost: list[int], k: int) -> int:\n    n = len(nums)\n    prefixNums = list(itertools.accumulate(nums, initial=0))\n    prefixCost = list(itertools.accumulate(cost, initial=0))\n    # dp[i] := the minimum cost to divide nums[i..n - 1] into subarrays\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i],\n                    prefixNums[j + 1] * (prefixCost[j + 1] - prefixCost[i]) +\n                    k * (prefixCost[n] - prefixCost[i]) + dp[j + 1])\n\n    return dp[0]",
      "title": "3500. Minimum Cost to Divide Array Into Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b4ad275-a663-4d2e-892d-94307b978e7b",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Group:\n  start: int\n  length: int\n\n\nclass SparseTable:\n  def __init__(self, nums: list[int]):\n    self.n = len(nums)\n    # st[i][j] := max(nums[j..j + 2^i - 1])\n    self.st = [[0] * (self.n + 1) for _ in range(self.n.bit_length() + 1)]\n    self.st[0] = nums.copy()\n    for i in range(1, self.n.bit_length() + 1):\n      for j in range(self.n - (1 << i) + 1):\n        self.st[i][j] = max(\n            self.st[i - 1][j],\n            self.st[i - 1][j + (1 << (i - 1))])\n\n  def query(self, l: int, r: int) -> int:\n    \"\"\"Returns max(nums[l..r]).\"\"\"\n    i = (r - l + 1).bit_length() - 1\n    return max(self.st[i][l], self.st[i][r - (1 << i) + 1])\n\n\nclass Solution:\n  def maxActiveSectionsAfterTrade(\n      self,\n      s: str,\n      queries: list[list[int]]\n  ) -> list[int]:\n    ones = s.count('1')\n    zeroGroups, zeroGroupIndex = self._getZeroGroups(s)\n    if not zeroGroups:\n      return [ones] * len(queries)\n\n    st = SparseTable(self._getZeroMergeLengths(zeroGroups))\n\n    def getMaxActiveSections(l: int, r: int) -> int:\n      left = (-1 if zeroGroupIndex[l] == -1\n              else (zeroGroups[zeroGroupIndex[l]].length -\n                    (l - zeroGroups[zeroGroupIndex[l]].start)))\n      right = (-1 if zeroGroupIndex[r] == -1\n               else (r - zeroGroups[zeroGroupIndex[r]].start + 1))\n      startAdjacentGroupIndex, endAdjacentGroupIndex = self._mapToAdjacentGroupIndices(\n          zeroGroupIndex[l] + 1, zeroGroupIndex[r] if s[r] == '1' else zeroGroupIndex[r] - 1)\n      activeSections = ones\n      if (s[l] == '0' and s[r] == '0' and\n              zeroGroupIndex[l] + 1 == zeroGroupIndex[r]):\n        activeSections = max(activeSections, ones + left + right)\n      elif startAdjacentGroupIndex <= endAdjacentGroupIndex:\n        activeSections = max(\n            activeSections,\n            ones + st.query(startAdjacentGroupIndex, endAdjacentGroupIndex))\n      if (s[l] == '0' and\n          zeroGroupIndex[l] + 1 <= (zeroGroupIndex[r]\n                                    if s[r] == '1' else zeroGroupIndex[r] - 1)):\n        activeSections = max(activeSections, ones + left +\n                             zeroGroups[zeroGroupIndex[l] + 1].length)\n      if (s[r] == '0' and zeroGroupIndex[l] < zeroGroupIndex[r] - 1):\n        activeSections = max(activeSections, ones + right +\n                             zeroGroups[zeroGroupIndex[r] - 1].length)\n      return activeSections\n\n    return [getMaxActiveSections(l, r) for l, r in queries]\n\n  def _getZeroGroups(self, s: str) -> tuple[list[Group], list[int]]:\n    \"\"\"\n    Returns the zero groups and the index of the zero group that contains the\n    i-th character.\n    \"\"\"\n    zeroGroups = []\n    zeroGroupIndex = []\n    for i in range(len(s)):\n      if s[i] == '0':\n        if i > 0 and s[i - 1] == '0':\n          zeroGroups[-1].length += 1\n        else:\n          zeroGroups.append(Group(i, 1))\n      zeroGroupIndex.append(len(zeroGroups) - 1)\n    return zeroGroups, zeroGroupIndex\n\n  def _getZeroMergeLengths(self, zeroGroups: list[Group]) -> list[int]:\n    \"\"\"Returns the sums of the lengths of the adjacent groups.\"\"\"\n    return [a.length + b.length for a, b in itertools.pairwise(zeroGroups)]\n\n  def _mapToAdjacentGroupIndices(\n      self,\n      startGroupIndex: int,\n      endGroupIndex: int\n  ) -> tuple[int, int]:\n    \"\"\"\n    Returns the indices of the adjacent groups that contain l and r completely.\n\n    e.g.    groupIndices = [0, 1, 2, 3]\n    adjacentGroupIndices = [0 (0, 1), 1 (1, 2), 2 (2, 3)]\n    map(startGroupIndex = 1, endGroupIndex = 3) -> (1, 2)\n    \"\"\"\n    return startGroupIndex, endGroupIndex - 1",
      "title": "3501. Maximize Active Section with Trade II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63ab303f-886c-4099-84fb-133676ee5cc6",
      "code": "class Solution:\n  def minCosts(self, cost: list[int]) -> list[int]:\n    return list(itertools.accumulate(cost, min))",
      "title": "3502. Minimum Cost to Reach Every Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2586ed3b-641d-48a1-8c7f-e8db940be9fa",
      "code": "class Solution:\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3503. Longest Palindrome After Substring Concatenation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "459395ed-5cf8-4282-bb27-ffcb3180f021",
      "code": "class Solution:\n  # 3503. Longest Palindrome After Substring Concatenation I\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3504. Longest Palindrome After Substring Concatenation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc203ac5-ea5b-4bfe-b22b-73b24ca04ea7",
      "code": "class Solution:\n  def minEliminationTime(self, timeReq: list[int], splitTime: int) -> int:\n    minHeap = timeReq.copy()\n    heapq.heapify(minHeap)\n    heapq.heappop(minHeap)\n\n    while True:\n      bacterial = splitTime + heapq.heappop(minHeap)\n      if not minHeap:\n        return bacterial\n      heapq.heappushpop(minHeap, bacterial)",
      "title": "3506. Find Time Required to Eliminate Bacterial Strains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6464ffec-2c54-4965-baae-9922e5507d36",
      "code": "class Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    ans = 0\n\n    while any(x > y for x, y in itertools.pairwise(nums)):\n      pairSums = [x + y for x, y in itertools.pairwise(nums)]\n      minPairSum = min(pairSums)\n      minPairIndex = pairSums.index(minPairSum)\n      nums[minPairIndex] = minPairSum\n      nums.pop(minPairIndex + 1)\n      ans += 1\n\n    return ans",
      "title": "3507. Minimum Pair Removal to Sort Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23c6d10a-1c07-4f72-8001-6578b46bbfa8",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  FIRST = 0  # first element - add to sum and start product\n  SUBTRACT = 1  # second element - subtract from sum and multiply product\n  ADD = 2  # third element - add to sum and multiply product\n\n\nclass Solution:\n  def maxProduct(self, nums: list[int], k: int, limit: int) -> int:\n    MIN = -5000\n    if abs(k) > sum(nums):\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int, product: int, state: State, k: int) -> int:\n      if i == len(nums):\n        return (product if k == 0 and state != State.FIRST and product <= limit\n                else MIN)\n      res = dp(i + 1, product, state, k)\n      if state == State.FIRST:\n        res = max(res, dp(i + 1, nums[i], State.SUBTRACT, k - nums[i]))\n      if state == State.SUBTRACT:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.ADD, k + nums[i]))\n      if state == State.ADD:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.SUBTRACT, k - nums[i]))\n      return res\n\n    ans = dp(0, 1, State.FIRST, k)\n    return -1 if ans == MIN else ans",
      "title": "3509. Maximum Product of Subsequences With an Alternating Sum Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38e9fc91-78d5-43ab-9657-bf29bb6fb909",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    inversionsCount = sum(nums[i + 1] < nums[i] for i in range(n - 1))\n    nextIndices = [i + 1 for i in range(n)]\n    prevIndices = [i - 1 for i in range(n)]\n    pairSums = SortedList((a + b, i)\n                          for i, (a, b) in enumerate(itertools.pairwise(nums)))\n\n    while inversionsCount > 0:\n      ans += 1\n      smallestPair = pairSums.pop(0)\n      pairSum, currIndex = smallestPair\n      nextIndex = nextIndices[currIndex]\n      prevIndex = prevIndices[currIndex]\n\n      if prevIndex >= 0:\n        oldPairSum = nums[prevIndex] + nums[currIndex]\n        newPairSum = nums[prevIndex] + pairSum\n        pairSums.remove((oldPairSum, prevIndex))\n        pairSums.add((newPairSum, prevIndex))\n        if nums[prevIndex] > nums[currIndex]:\n          inversionsCount -= 1\n        if nums[prevIndex] > pairSum:\n          inversionsCount += 1\n\n      if nums[nextIndex] < nums[currIndex]:\n        inversionsCount -= 1\n\n      nextNextIndex = nextIndices[nextIndex] if nextIndex < n else n\n      if nextNextIndex < n:\n        oldPairSum = nums[nextIndex] + nums[nextNextIndex]\n        newPairSum = pairSum + nums[nextNextIndex]\n        pairSums.remove((oldPairSum, nextIndex))\n        pairSums.add((newPairSum, currIndex))\n        if nums[nextNextIndex] < nums[nextIndex]:\n          inversionsCount -= 1\n        if nums[nextNextIndex] < pairSum:\n          inversionsCount += 1\n        prevIndices[nextNextIndex] = currIndex\n\n      nextIndices[currIndex] = nextNextIndex\n      nums[currIndex] = pairSum\n\n    return ans",
      "title": "3510. Minimum Pair Removal to Sort Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6847edd4-6fd7-4a6d-9880-eb219a46d6ce",
      "code": "class Solution:\n  def makeArrayPositive(self, nums: list[int]) -> int:\n    MAX = 10**18\n    ans = 0\n    minSum = nums[0] + nums[1]\n\n    for i in range(2, len(nums)):\n      a, b, c = nums[i - 2], nums[i - 1], nums[i]\n      minSum = min(minSum + c, a + b + c)\n      if minSum <= 0:\n        nums[i] = MAX\n        minSum = MAX\n        ans += 1\n\n    return ans",
      "title": "3511. Make a Positive Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d137e77-1d1f-4c27-89a6-5cb27ef607ea",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(nums) % k",
      "title": "3512. Minimum Operations to Make Array Sum Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf9e6b37-a1d7-4886-a87d-68ff770d94b4",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return n\n    return 1 << (int(math.log2(n)) + 1)",
      "title": "3513. Number of Unique XOR Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d09bdc2-1ddb-4b75-a633-67fb2ac1c954",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n == 1:\n      return 1\n    pairs = set(nums[i] ^ nums[j]\n                for i, j in itertools.combinations(range(n), 2))\n    return len(set(pair ^ num\n                   for pair in pairs\n                   for num in nums))",
      "title": "3514. Number of Unique XOR Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36735f53-3462-46c3-b698-043919f6528f",
      "code": "class Solution:\n  def findClosest(self, x: int, y: int, z: int) -> int:\n    xz = abs(x - z)\n    yz = abs(y - z)\n    if xz == yz:\n      return 0\n    return 1 if xz < yz else 2",
      "title": "3516. Find Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57c34f9f-c1a9-4b8b-b7d6-f77f384be727",
      "code": "class Solution:\n  def smallestPalindrome(self, s: str) -> str:\n    n = len(s)\n    sortedHalf = sorted(s[:n // 2])\n    return ''.join(sortedHalf +\n                   ([s[n // 2]] if n % 2 else []) +\n                   sortedHalf[::-1])",
      "title": "3517. Smallest Palindromic Rearrangement I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "674a33f5-543b-4bc0-b388-87fa6fc22b68",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX = 10**6 + 1\n\n  def smallestPalindrome(self, s: str, k: int) -> str:\n    count = collections.Counter(s)\n    if not self._isPalindromePossible(count):\n      return ''\n\n    halfCount, midLetter = self._getHalfCountAndMidLetter(count)\n    totalPerm = self._calculateTotalPermutations(halfCount)\n    if k > totalPerm:\n      return ''\n    leftHalf = self._generateLeftHalf(halfCount, k)\n    return ''.join(leftHalf) + midLetter + ''.join(reversed(leftHalf))\n\n  def _isPalindromePossible(self, count: collections.Counter) -> bool:\n    oddCount = sum(1 for count in count.values() if count % 2 == 1)\n    return oddCount <= 1\n\n  def _getHalfCountAndMidLetter(self, count: collections.Counter) -> tuple[list[int], str]:\n    halfCount = [0] * 26\n    midLetter = ''\n    for c, freq in count.items():\n      halfCount[ord(c) - ord('a')] = freq // 2\n      if freq % 2 == 1:\n        midLetter = c\n    return halfCount, midLetter\n\n  def _calculateTotalPermutations(self, halfCount: list[int]) -> int:\n    \"\"\"Calculate the total number of possible permutations.\"\"\"\n    return self._countArrangements(halfCount)\n\n  def _generateLeftHalf(self, halfCount: list[int], k: int) -> list[str]:\n    \"\"\"Generate the left half of the palindrome based on k.\"\"\"\n    halfLen = sum(halfCount)\n    left = []\n    for _ in range(halfLen):\n      for i, freq in enumerate(halfCount):\n        if freq == 0:\n          continue\n        halfCount[i] -= 1\n        arrangements = self._countArrangements(halfCount)\n        if arrangements >= k:\n          left.append(chr(i + ord('a')))\n          break\n        else:\n          k -= arrangements\n          halfCount[i] += 1\n    return left\n\n  def _countArrangements(self, count: list[int]) -> int:\n    \"\"\"Calculate the number of possible arrangements of characters.\"\"\"\n    total = sum(count)\n    res = 1\n    for freq in count:\n      res *= self._nCk(total, freq)\n      if res >= self.MAX:\n        return self.MAX\n      total -= freq\n    return res\n\n  def _nCk(self, n: int, k: int) -> int:\n    res = 1\n    for i in range(1, min(k, n - k) + 1):\n      res = res * (n - i + 1) // i\n      if res >= self.MAX:\n        return self.MAX\n    return res",
      "title": "3518. Smallest Palindromic Rearrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4bbd7a6-c810-46c8-b685-3718d6f00cd6",
      "code": "class Solution:\n  def calculateScore(self, instructions: list[str], values: list[int]) -> int:\n    n = len(instructions)\n    ans = 0\n    i = 0\n    seen = set()\n\n    while 0 <= i < n and i not in seen:\n      seen.add(i)\n      if instructions[i] == 'add':\n        ans += values[i]\n        i += 1\n      elif instructions[i] == 'jump':\n        i += values[i]\n\n    return ans",
      "title": "3522. Calculate Score After Performing Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69101fd2-f140-44f9-94a1-da2d6c4fc4a4",
      "code": "class Solution:\n  def maximumPossibleSize(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n\n    for num in nums:\n      if num >= prev:\n        prev = num\n        ans += 1\n\n    return ans",
      "title": "3523. Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ccb307a-1eb4-47a7-b3f5-0c436f197ffc",
      "code": "class Solution:\n  def resultArray(self, nums: list[int], k: int) -> list[int]:\n    ans = [0] * k\n    # dp[r] := the number of subarrays ending at current position with\n    # product % k == r\n    dp = [0] * k\n\n    for num in nums:\n      newDp = [0] * k\n      numMod = num % k\n      # Start new subarray with only `num`\n      newDp[numMod] = 1\n      # Extend all previous subarrays\n      for i in range(k):\n        newMod = (i * numMod) % k\n        newDp[newMod] += dp[i]\n      # Accumulate counts into ans\n      for i in range(k):\n        ans[i] += newDp[i]\n      dp = newDp\n\n    return ans",
      "title": "3524. Find X Value of Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c6a1b32-7a46-4b9d-a747-dcf49734162b",
      "code": "class Solution:\n  def findCommonResponse(self, responses: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for response in responses:\n      for response in set(response):\n        count[response] += 1\n\n    maxFreq = max(count.values())\n    return min([response\n                for response, count in count.items()\n                if count == maxFreq])",
      "title": "3527. Find the Most Common Response",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09018d65-a4a6-48a0-9156-c0ce5b7f5fbf",
      "code": "class Solution:\n  def baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    n = len(conversions) + 1\n    ans = [0] * n\n    ans[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        ans[v] = (ans[u] * factor) % MOD\n        q.append(v)\n\n    return ans",
      "title": "3528. Unit Conversion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a017f50-719a-40ab-b170-63df96c6ef24",
      "code": "class Solution:\n  def countCells(self, grid: list[list[str]], pattern: str) -> int:\n    BASE = 13\n    HASH = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    def markMatchedCells(flattenedGrid: str, isHorizontal: bool) -> list[list[bool]]:\n      matchMatrix = [[False] * n for _ in range(m)]\n      matchPrefix = [0] * (len(flattenedGrid) + 1)\n      pows = [1]  # pows[i] := BASE^i % HASH\n      patternHash = 0\n      runningHash = 0\n\n      for i in range(1, len(pattern)):\n        pows.append((pows[-1] * BASE) % HASH)\n\n      for c in pattern:\n        patternHash = (patternHash * BASE + (ord(c) - ord('a'))) % HASH\n\n      for i in range(len(flattenedGrid)):\n        runningHash = (\n            runningHash * BASE + (ord(flattenedGrid[i]) - ord('a'))) % HASH\n        if i >= len(pattern) - 1:\n          if runningHash == patternHash:  # Match found.\n            matchPrefix[i - len(pattern) + 1] += 1\n            matchPrefix[i + 1] -= 1\n          # Remove the contribution of the oldest letter.\n          oldestLetterHash = (\n              pows[len(pattern) - 1] *\n              (ord(flattenedGrid[i - len(pattern) + 1]) - ord('a'))) % HASH\n          runningHash = (runningHash - oldestLetterHash + HASH) % HASH\n\n      for k in range(len(flattenedGrid)):\n        if k > 0:\n          matchPrefix[k] += matchPrefix[k - 1]\n        if matchPrefix[k] > 0:\n          i = k // n if isHorizontal else k % m\n          j = k % n if isHorizontal else k // m\n          matchMatrix[i][j] = True\n\n      return matchMatrix\n\n    # Find matching positions.\n    flattenedGridRow = ''.join(cell for row in grid for cell in row)\n    flattenedGridCol = ''.join(cell for col in zip(*grid) for cell in col)\n    horizontalMatches = markMatchedCells(flattenedGridRow, True)\n    verticalMatches = markMatchedCells(flattenedGridCol, False)\n    return sum(horizontalMatches[i][j] and verticalMatches[i][j]\n               for i in range(m)\n               for j in range(n))",
      "title": "3529. Count Cells in Overlapping Horizontal and Vertical Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5044ec8f-42ca-4386-aa47-4fe4eefce4fb",
      "code": "class Solution:\n  def maxProfit(self, n: int, edges: list[list[int]], score: list[int]) -> int:\n    # need[i] := the bitmask representing all nodes that must be placed before\n    # node i\n    need = [0] * n\n    # dp[mask] := the maximum profit achievable by placing the set of nodes\n    # represented by `mask`\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n\n    for u, v in edges:\n      need[v] |= 1 << u\n\n    # Iterate over all subsets of nodes (represented by bitmask `mask`)\n    for mask in range(1 << n):\n      if dp[mask] == -1:\n        continue\n      # Determine the position of the next node to be placed (1-based).\n      pos = mask.bit_count() + 1\n      # Try to place each node `i` that hasn't been placed yet.\n      for i in range(n):\n        if mask >> i & 1:\n          continue\n        # Check if all dependencies of node `i` are already placed.\n        if (mask & need[i]) == need[i]:\n          newMask = mask | 1 << i  # Mark node `i` as placed.\n          dp[newMask] = max(dp[newMask], dp[mask] + score[i] * pos)\n\n    return dp[-1]",
      "title": "3530. Maximum Profit from Valid Topological Order in DAG",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f744cc2-1248-4ccb-8bbe-213472646e40",
      "code": "class Solution:\n  def countCoveredBuildings(self, n: int, buildings: list[list[int]]) -> int:\n    northernmost = [math.inf] * (n + 1)\n    southernmost = [0] * (n + 1)\n    westernmost = [math.inf] * (n + 1)\n    easternmost = [0] * (n + 1)\n\n    for x, y in buildings:\n      northernmost[x] = min(northernmost[x], y)\n      southernmost[x] = max(southernmost[x], y)\n      westernmost[y] = min(westernmost[y], x)\n      easternmost[y] = max(easternmost[y], x)\n\n    return sum(northernmost[x] < y < southernmost[x]\n               and westernmost[y] < x < easternmost[y]\n               for x, y in buildings)",
      "title": "3531. Count Covered Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a21a320a-de0f-44d1-93ce-a5e785326adb",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]]\n  ) -> list[bool]:\n    uf = UnionFind(n)\n\n    for i in range(1, n):\n      if abs(nums[i] - nums[i - 1]) <= maxDiff:\n        uf.unionByRank(i, i - 1)\n\n    return [uf.find(u) == uf.find(v)\n            for u, v in queries]",
      "title": "3532. Path Existence Queries in a Graph I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cedb908b-e0c3-4070-8f85-abb7edb5b88a",
      "code": "class Solution:\n  def concatenatedDivisibility(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    lengths = [len(str(num)) for num in nums]\n    pows = [pow(10, length, k) for length in lengths]\n\n    @functools.lru_cache(None)\n    def dp(mask: int, mod: int) -> bool:\n      \"\"\"\n      Returns True if there is a way to form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      if mask == (1 << n) - 1:\n        return mod == 0\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return True\n      return False\n\n    def reconstruct(mask: int, mod: int) -> list[int]:\n      \"\"\"\n      Reconstructs the numbers that form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return [nums[i]] + reconstruct(mask | 1 << i, newMod)\n      return []\n\n    return reconstruct(0, 0) if dp(0, 0) else []",
      "title": "3533. Concatenated Divisibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9fc2309-6d94-43fb-889c-d73d596bac56",
      "code": "class Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    sortedNumAndIndexes = sorted((num, i) for i, num in enumerate(nums))\n    sortedNums = [num for num, _ in sortedNumAndIndexes]\n    indexMap = {originalIndex: sortedIndex for sortedIndex,\n                (_, originalIndex) in enumerate(sortedNumAndIndexes)}\n    maxLevel = n.bit_length() + 1\n    # jump[i][j] is the index of the j-th ancestor of i\n    jump = [[0] * maxLevel for _ in range(n)]\n\n    right = 0\n    for i in range(n):\n      while right + 1 < n and sortedNums[right + 1] - sortedNums[i] <= maxDiff:\n        right += 1\n      jump[i][0] = right\n\n    for level in range(1, maxLevel):\n      for i in range(n):\n        prevJump = jump[i][level - 1]\n        jump[i][level] = jump[prevJump][level - 1]\n\n    def minJumps(start: int, end: int, level: int) -> int:\n      \"\"\"\n      Returns the minimum number of jumps from `start` to `end` using binary\n      lifting.\n      \"\"\"\n      if start == end:\n        return 0\n      if jump[start][0] >= end:\n        return 1\n      if jump[start][level] < end:\n        return math.inf\n      for j in range(level, -1, -1):\n        if jump[start][j] < end:\n          break\n      return (1 << j) + minJumps(jump[start][j], end, j)\n\n    def minDist(u: int, v: int) -> int:\n      uIndex = indexMap[u]\n      vIndex = indexMap[v]\n      start = min(uIndex, vIndex)\n      end = max(uIndex, vIndex)\n      res = minJumps(start, end, maxLevel - 1)\n      return res if res < math.inf else -1\n\n    return [minDist(u, v) for u, v in queries]",
      "title": "3534. Path Existence Queries in a Graph II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0bc0449-5cfc-4285-8ff9-22e4f498ab4c",
      "code": "class Solution:\n  def queryConversions(\n      self,\n      conversions: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    self.MOD = 1_000_000_007\n    units = self._baseUnitConversions(conversions)\n    # By Fermat's little theorem.\n    return [units[v] * self._modPow(units[u], self.MOD - 2) % self.MOD\n            for u, v in queries]\n\n  # Same as 3528. Unit Conversion I\n  def _baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    n = len(conversions) + 1\n    res = [0] * n\n    res[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        res[v] = (res[u] * factor) % self.MOD\n        q.append(v)\n\n    return res\n\n  def _modPow(self, x: int, n: int) -> int:\n    if n == 0:\n      return 1\n    if n % 2 == 1:\n      return x * self._modPow(x, n - 1) % self.MOD\n    return self._modPow(x * x % self.MOD, n // 2)",
      "title": "3535. Unit Conversion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b75b743c-2013-449d-8d7d-9d8539ae5d70",
      "code": "class Solution:\n  def maxProduct(self, n: int) -> int:\n    s = sorted(str(n))\n    return int(s[-1]) * int(s[-2])",
      "title": "3536. Maximum Product of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19d289d0-b1cc-4542-ab19-45ff035fb874",
      "code": "class Solution:\n  def specialGrid(self, n: int) -> list[list[int]]:\n    sz = 1 << n\n    grid = [[0] * sz for _ in range(sz)]\n    count = 0\n\n    def fill(x1: int, x2: int, y1: int, y2: int) -> None:\n      nonlocal count\n      if x2 - x1 == 1:\n        grid[x1][y1] = count\n        count += 1\n        return\n      midRow = (x1 + x2) // 2\n      midCol = (y1 + y2) // 2\n      fill(x1, midRow, midCol, y2)\n      fill(midRow, x2, midCol, y2)\n      fill(midRow, x2, y1, midCol)\n      fill(x1, midRow, y1, midCol)\n\n    fill(0, sz, 0, sz)\n    return grid",
      "title": "3537. Fill a Special Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e6aed0d-8e90-4d76-a1ea-3c47b039bfac",
      "code": "class Solution:\n  def minTravelTime(\n      self,\n      l: int,\n      n: int,\n      k: int,\n      position: list[int],\n      time: list[int]\n  ) -> int:\n    prefix = list(itertools.accumulate(time))\n\n    @functools.lru_cache(None)\n    def dp(i: int, skips: int, last: int) -> int:\n      \"\"\"\n      Returns the minimum travel time to reach the last stop from i-th stop,\n      with `skips` skips remaining, and the last stop being `last`.\n      \"\"\"\n      if i == n - 1:\n        return 0 if skips == 0 else math.inf\n      res = math.inf\n      rate = prefix[i] - (prefix[last - 1] if last > 0 else 0)\n      end = min(n - 1, i + skips + 1)\n      for j in range(i + 1, end + 1):\n        distance = position[j] - position[i]\n        res = min(res, distance * rate + dp(j, skips - (j - i - 1), i + 1))\n      return res\n\n    return dp(0, k, 0)",
      "title": "3538. Merge Operations for Minimum Travel Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a26f1e85-ff40-4ff4-815a-4cd88c823d1a",
      "code": "class Solution:\n  def magicalSum(self, m: int, k: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(m: int, k: int, i: int, carry: int) -> int:\n      \"\"\"\n      Returns the number of magical sequences of length `k` that can be formed\n      from the first `i` numbers in `nums` with at most `m` elements.\n      \"\"\"\n      if m < 0 or k < 0 or (m + carry.bit_count() < k):\n        return 0\n      if m == 0:\n        return int(k == carry.bit_count())\n      if i == len(nums):\n        return 0\n      res = 0\n      for count in range(m + 1):\n        contribution = math.comb(m, count) * pow(nums[i], count, MOD) % MOD\n        newCarry = carry + count\n        res += dp(m - count, k - (newCarry % 2),\n                  i + 1, newCarry // 2) * contribution\n        res %= MOD\n      return res\n\n    return dp(m, k, 0, 0)",
      "title": "3539. Find Sum of Array Product of Magical Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "394eca6b-e3dc-49c0-89f1-0364f8732611",
      "code": "class Solution:\n  def minTotalTime(\n      self,\n      forward: list[int],\n      backward: list[int],\n      queries: list[int]\n  ) -> int:\n    summ = sum(backward)\n    ans = 0\n    pos = 0\n    prefixF = [0] + list(itertools.accumulate(forward))\n    prefixB = list(itertools.accumulate(backward)) + [0]\n\n    for q in queries:\n      r = int(q < pos) * prefixF[-1] + prefixF[q] - prefixF[pos]\n      l = int(q > pos) * summ + prefixB[pos] - prefixB[q]\n      ans += min(l, r)\n      pos = q\n\n    return ans",
      "title": "3540. Minimum Time to Visit All Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ea4e81a-3422-4d4f-9e5b-e9c7db504349",
      "code": "class Solution:\n  def maxFreqSum(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    count = collections.Counter(s)\n    maxVowel = max((count[c] for c in VOWELS if c in count), default=0)\n    maxConsonant = max((count[c] for c in count if c not in VOWELS), default=0)\n    return maxVowel + maxConsonant",
      "title": "3541. Find Most Frequent Vowel and Consonant",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9b7e11d-ddf0-48c3-8476-95972ebffb51",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    stack = [0]\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      if not stack or stack[-1] < num:\n        ans += 1\n        stack.append(num)\n\n    return ans",
      "title": "3542. Minimum Operations to Convert All Elements to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10108682-0e86-4472-81c6-def2b410aa7d",
      "code": "class Solution:\n  def maxWeight(self, n: int, edges: list[list[int]], k: int, t: int) -> int:\n    graph = [[] for _ in range(n)]\n    # dp[u][i] := the set of possible path sums ending at node u with i edges\n    dp = [defaultdict(set) for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    for u in range(n):\n      dp[u][0].add(0)  # zero edges = sum 0\n\n    for i in range(k):\n      for u in range(n):\n        for currSum in dp[u][i]:\n          for v, w in graph[u]:\n            newSum = currSum + w\n            if newSum < t:\n              dp[v][i + 1].add(newSum)\n\n    ans = -1\n\n    for u in range(n):\n      if k in dp[u]:\n        ans = max(ans, max(dp[u][k]))\n\n    return ans",
      "title": "3543. Maximum Weighted K-Edge Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "364f7860-859d-4307-a7d6-e796cb1966d7",
      "code": "class Solution:\n  def subtreeInversionSum(\n      self,\n      edges: list[list[int]],\n      nums: list[int],\n      k: int\n  ) -> int:\n    n = len(edges) + 1\n    parent = [-1] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dp(u: int, stepsSinceInversion: int, inverted: bool) -> int:\n      \"\"\"\n      Returns the maximum sum for subtree rooted at u, with\n      `stepsSinceInversion` steps of inversion and `inverted` is true if the\n      subtree is inverted.\n      \"\"\"\n      num = -nums[u] if inverted else nums[u]\n      negNum = -num\n      for v in graph[u]:\n        if v == parent[u]:\n          continue\n        parent[v] = u\n        num += dp(v, min(k, stepsSinceInversion + 1), inverted)\n        if stepsSinceInversion == k:\n          negNum += dp(v, 1, not inverted)\n      return max(num, negNum) if stepsSinceInversion == k else num\n\n    return dp(0, k, False)",
      "title": "3544. Subtree Inversion Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "851fba13-1cbc-48ef-80ce-292c25fe0a0b",
      "code": "class Solution:\n  def minDeletion(self, s: str, k: int) -> int:\n    count = collections.Counter(s)\n    if len(count) <= k:\n      return 0\n    freqs = sorted(count.values())\n    return sum(freqs[:len(freqs) - k])",
      "title": "3545. Minimum Deletions for At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1600a37-ecb4-4203-9a36-2008098ce7ac",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    totalSum = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      runningSum = 0\n      for row in grid:\n        runningSum += sum(row)\n        if runningSum * 2 == totalSum:\n          return True\n      return False\n\n    return canPartition(grid) or canPartition(zip(*grid))",
      "title": "3546. Equal Sum Grid Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5817dce-8a8a-490a-a060-04e593fe5104",
      "code": "class Solution:\n  def maxScore(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    cycleSizes = []  # components where all nodes have degree 2\n    pathSizes = []  # components that are not cycleSizes\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      if i in seen:\n        continue\n      component = self._getComponent(graph, i, seen)\n      if all(len(graph[u]) == 2 for u in component):\n        cycleSizes.append(len(component))\n      elif len(component) > 1:\n        pathSizes.append(len(component))\n\n    for cycleSize in cycleSizes:\n      ans += self._calculateScore(n - cycleSize + 1, n, True)\n      n -= cycleSize\n\n    for pathSize in sorted(pathSizes, reverse=True):\n      ans += self._calculateScore(n - pathSize + 1, n, False)\n      n -= pathSize\n\n    return ans\n\n  def _getComponent(\n      self,\n      graph: list[list[int]],\n      start: int,\n      seen: set[int],\n  ) -> list[int]:\n    component = [start]\n    seen.add(start)\n    for u in component:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        component.append(v)\n        seen.add(v)\n    return component\n\n  def _calculateScore(self, left: int, right: int, isCycle: bool) -> int:\n    window = collections.deque([right, right])\n    score = 0\n    for value in range(right - 1, left - 1, -1):\n      windowValue = window.popleft()\n      score += windowValue * value\n      window.append(value)\n    return score + window[0] * window[1] * isCycle",
      "title": "3547. Maximum Sum of Edge Values in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8441111d-a8f0-4040-ba77-4346f0242e4e",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    summ = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      topSum = 0\n      seen = set()\n      for i, row in enumerate(grid):\n        topSum += sum(row)\n        botSum = summ - topSum\n        seen |= set(row)\n        if topSum - botSum in (0, grid[0][0],  grid[0][-1], row[0]):\n          return True\n        if len(grid[0]) > 1 and i > 0 and topSum - botSum in seen:\n          return True\n      return False\n\n    return (canPartition(grid) or\n            canPartition(grid[::-1]) or\n            canPartition(list(zip(*grid))[::-1]) or\n            canPartition(list(zip(*grid))))",
      "title": "3548. Equal Sum Grid Partition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67c859b5-6faf-4369-98f3-fb325d22d23c",
      "code": "from numpy import array, round\nfrom numpy.fft import fft, ifft\n\n\nclass Solution:\n  def multiply(self, poly1: list[int], poly2: list[int]) -> list[int]:\n    n1 = len(poly1)\n    n2 = len(poly2)\n    n = n1 + n2 - 1\n    sz = 1 << (n - 1).bit_length()\n    arr1 = array(poly1 + [0] * (sz - n1))\n    arr2 = array(poly2 + [0] * (sz - n2))\n    ans = ifft(fft(arr1) * fft(arr2))\n    return round(ans).astype(int).tolist()[:n]",
      "title": "3549. Multiply Two Polynomials",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "673c5398-c01e-428a-a846-459cccb1463e",
      "code": "class Solution:\n  def smallestIndex(self, nums: List[int]) -> int:\n    return next((i\n                 for i, num in enumerate(nums)\n                 if self._getDigitSum(num) == i), -1)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3550. Smallest Index With Digit Sum Equal to Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a44b6b1-1def-4d3c-b7b2-c4ff05ba6f6e",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n    sortedNums = sorted(nums, key=lambda x: (self._getDigitSum(x), x))\n    numToIndex = {num: i for i, num in enumerate(sortedNums)}\n\n    for i, num in enumerate(nums):\n      if i in seen or numToIndex[num] == i:\n        continue\n      cycleSize = 0\n      j = i\n      while j not in seen:\n        seen.add(j)\n        j = numToIndex[nums[j]]\n        cycleSize += 1\n      ans += max(cycleSize - 1, 0)\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3551. Minimum Swaps to Sort by Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1707212-9805-4c20-adb4-aefa4711dbe8",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minMoves(self, matrix: list[str]) -> int:\n    if matrix[-1][-1] == '#':\n      return -1\n\n    teleportPositions = [[] for _ in range(26)]\n\n    for i, row in enumerate(matrix):\n      for j, c in enumerate(row):\n        if c not in ('.', '#'):\n          teleportPositions[ord(c) - ord('A')].append((i, j))\n\n    return self._dijkstra(matrix, teleportPositions,\n                          (0, 0), (len(matrix) - 1, len(matrix[0]) - 1))\n\n  def _dijkstra(\n      self,\n      matrix: list[str],\n      teleportPositions: list[list[tuple[int, int]]],\n      src: tuple[int, int],\n      dst: tuple[int, int],\n  ) -> int:\n    DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    m = len(matrix)\n    n = len(matrix[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    dist[0][0] = 0\n    minHeap = [(dist[0][0], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      c = matrix[i][j]\n      if c.isupper() and c not in seen:\n        seen.add(c)\n        for x, y in teleportPositions[ord(c) - ord('A')]:\n          if d < dist[x][y]:\n            dist[x][y] = d\n            heapq.heappush(minHeap, (d, (x, y)))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if matrix[x][y] == '#':\n          continue\n        if d + 1 < dist[x][y]:\n          dist[x][y] = d + 1\n          heapq.heappush(minHeap, (d + 1, (x, y)))\n\n    return -1",
      "title": "3552. Grid Teleportation Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0e46e82-24cb-4619-bcfa-a7a173783322",
      "code": "class Solution:\n  # Similar to 2846. Minimum Edge Weight Equilibrium Queries in a Tree\n  def minimumWeight(\n      self,\n      edges: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(edges) + 1\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]  # jump[i][j] := the 2^j-th ancestor of i\n    depth = [0] * n  # depth[i] := the depth of i\n    dist = [0] * n  # dist[i] := the distance from root to i\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    self._dfs(graph, 0, -1, jump, depth, dist)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    return [(self._distance(src1, src2, jump, depth, dist) +\n             self._distance(src1, dest, jump, depth, dist) +\n             self._distance(src2, dest, jump, depth, dist)) // 2\n            for src1, src2, dest in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      dist[v] = dist[u] + w\n      self._dfs(graph, v, u, jump, depth, dist)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]\n\n  def _distance(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> int:\n    \"\"\"Returns the distance between u and v.\"\"\"\n    lca = self._getLCA(u, v, jump, depth)\n    return dist[u] + dist[v] - 2 * dist[lca]",
      "title": "3553. Minimum Weighted Subgraph With the Required Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa6ab1e3-ab91-4f8e-a081-b9fff285d805",
      "code": "class Solution:\n  def minSubarraySort(self, nums: list[int], k):\n    ans = []\n\n    for i in range(len(nums) - k + 1):\n      window = nums[i:i+k]\n      sortedWindow = sorted(window)\n      l = 0\n      r = k - 1\n      while l < k and window[l] == sortedWindow[l]:\n        l += 1\n      while r >= 0 and window[r] == sortedWindow[r]:\n        r -= 1\n      ans.append(0 if l > r else r - l + 1)\n\n    return ans",
      "title": "3555. Smallest Subarray to Sort in Every Sliding Window",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f34cc0f7-4efd-4729-9dbd-2b402549b2ee",
      "code": "class Solution:\n  def sumOfLargestPrimes(self, s: str) -> int:\n    primes = set()\n    n = len(s)\n\n    for i in range(n):\n      for j in range(i + 1, n + 1):\n        num = int(s[i:j])\n        if num not in primes and self._isPrime(num):\n          primes.add(num)\n\n    top3 = sorted(primes, reverse=True)[:3]\n    return sum(top3)\n\n  def _isPrime(self, n: int) -> bool:\n    return n > 1 and all(n % i != 0 for i in range(2, math.isqrt(n) + 1))",
      "title": "3556. Sum of Largest Prime Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54e224f9-145f-4113-9ed3-1ee27afd0e55",
      "code": "class Solution:\n  def maxSubstrings(self, word: str) -> int:\n    ans = 0\n    firstSeen = {}\n\n    for i, c in enumerate(word):\n      if c not in firstSeen:\n        firstSeen[c] = i\n      elif i - firstSeen[c] + 1 >= 4:\n        ans += 1\n        firstSeen.clear()\n\n    return ans",
      "title": "3557. Find Maximum Number of Non Intersecting Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}