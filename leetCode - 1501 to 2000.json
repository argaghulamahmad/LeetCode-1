{
  "snippets": [
    {
      "id": "c2f92af9-873b-4c8a-a5c6-8346cd795455",
      "code": "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans",
      "title": "1996. The Number of Weak Characters in the Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c5b6338-5642-412b-ace1-c0cfe745365b",
      "code": "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]",
      "title": "1997. First Day Where You Have Been in All the Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1366317-9dc6-4988-afe5-ed9c04928992",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "1998. GCD Sort of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64684ec7-f140-4fc9-8354-2c10095f20a2",
      "code": "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1",
      "title": "1999. Smallest Greater Multiple Made of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b28a24c5-fa61-4602-9305-d61cfc0faeec",
      "code": "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]",
      "title": "2000. Reverse Prefix of Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22e60d13-1722-4d01-872d-955c7584f620",
      "code": "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())",
      "title": "2001. Number of Pairs of Interchangeable Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdc9285a-750f-499c-90fa-55bf5a99b63f",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans",
      "title": "2002. Maximum Product of the Length of Two Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5399b24c-d343-4fa6-9583-2594063cc2de",
      "code": "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans",
      "title": "2003. Smallest Missing Genetic Value in Each Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b23289d6-fbf5-412f-8c53-2f47d5edceef",
      "code": "class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1",
      "title": "2005. Subtree Removal Game with Fibonacci Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ac9f38c-c03a-4617-90a4-3624a416c18d",
      "code": "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))",
      "title": "2006. Count Number of Pairs With Absolute Difference K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "814bbc39-6c32-48b7-b260-3cc887e41ef6",
      "code": "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans",
      "title": "2007. Find Original Array From Doubled Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06809f11-be2d-45d3-aef5-4a762514155f",
      "code": "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]",
      "title": "2008. Maximum Earnings From Taxi",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd76e55-cb07-4649-8245-c88f4d7ca967",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans",
      "title": "2009. Minimum Number of Operations to Make Array Continuous",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5ee1dec-3df0-49bc-b067-b601ee07056e",
      "code": "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)",
      "title": "2011. Final Value of Variable After Performing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9bc2ae3-a997-41f7-b789-dee8cd973614",
      "code": "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans",
      "title": "2012. Sum of Beauty in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "328521d9-d1fd-4dab-b6ac-f1ec26e1b053",
      "code": "class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans",
      "title": "2014. Longest Subsequence Repeated k Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb148cd5-bb40-4323-9ca9-7bbf07fe22be",
      "code": "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans",
      "title": "2015. Average Height of Buildings in Each Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8ed3896-ddfb-42b9-a72c-175f027fef79",
      "code": "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans",
      "title": "2016. Maximum Difference Between Increasing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90fc6f7c-511a-4cbd-8751-bbf38e35aaeb",
      "code": "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans",
      "title": "2017. Grid Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "933702f0-59e6-4fdc-ba3f-df1382f77d75",
      "code": "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False",
      "title": "2018. Check if Word Can Be Placed In Crossword",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07e90495-73c8-4f59-a83e-da594e4f1bff",
      "code": "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans",
      "title": "2019. The Score of Students Solving Math Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df05b1d9-2b53-49c6-b46d-0f41940f573d",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans",
      "title": "2021. Brightest Position on Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0233164d-0d0f-4d3a-be9c-79b7028703c8",
      "code": "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans",
      "title": "2022. Convert 1D Array Into 2D Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf1e2b33-a51d-46e0-9ea2-2ddb2cb00ebe",
      "code": "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans",
      "title": "2023. Number of Pairs of Strings With Concatenation Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e44a22bb-149c-4007-a646-8c216973b49b",
      "code": "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2024. Maximize the Confusion of an Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2093ac1c-9254-4c49-afd4-c3730156828c",
      "code": "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans",
      "title": "2025. Maximum Number of Ways to Partition an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31e0cbd7-3070-4a1d-84d9-869f7fbb4cb2",
      "code": "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans",
      "title": "2027. Minimum Moves to Convert String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3f4a742-d87f-4e04-94e0-8a73ef8dae52",
      "code": "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans",
      "title": "2028. Find Missing Observations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "098af294-ce08-4323-ba41-963890371939",
      "code": "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2",
      "title": "2029. Stone Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5016ecc6-718f-4a35-ae91-8092d2da99e0",
      "code": "class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)",
      "title": "2030. Smallest K-Length Subsequence With Occurrences of a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c881f8b4-a46b-45ab-87cb-b5487326cb4b",
      "code": "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans",
      "title": "2031. Count Subarrays With More Ones Than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3583a998-9bf0-4c8b-b82b-a6f29cb0e2ab",
      "code": "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]",
      "title": "2032. Two Out of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85185e6d-c298-4b51-af72-467141b3dad8",
      "code": "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans",
      "title": "2033. Minimum Operations to Make a Uni-Value Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb666b86-d69e-4079-8ee1-f22cd845f87d",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans",
      "title": "2035. Partition Array Into Two Arrays to Minimize Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dce607c-65ba-4534-a8c7-7c49a103cd25",
      "code": "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans",
      "title": "2036. Maximum Alternating Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eca956b6-e22c-45d2-9db0-a1eeb9daa2a6",
      "code": "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))",
      "title": "2037. Minimum Number of Moves to Seat Everyone",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8e58940-599c-48b7-9973-45907ce984e9",
      "code": "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB",
      "title": "2038. Remove Colored Pieces if Both Neighbors are the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "843ccd6f-c3c2-47ad-a592-211112c46fb2",
      "code": "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1",
      "title": "2039. The Time When the Network Becomes Idle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c25da17-c555-4354-9783-a6b7040890b3",
      "code": "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l",
      "title": "2040. Kth Smallest Product of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f57a5de8-c2af-4485-81e8-36e74f7a19da",
      "code": "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True",
      "title": "2042. Check if Numbers Are Ascending in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9172c130-928c-4127-84f0-35e8e759b720",
      "code": "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans",
      "title": "2044. Count Number of Maximum Bitwise-OR Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5f549d3-57bd-44ef-94e1-e389c6d2aad3",
      "code": "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))",
      "title": "2045. Second Minimum Time to Reach Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b0edadf-13de-4fd3-9365-44c09ed4a548",
      "code": "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head",
      "title": "2046. Sort Linked List Already Sorted Using Absolute Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8573be87-f4fb-4509-8057-b37b260e13eb",
      "code": "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())",
      "title": "2047. Number of Valid Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "559bddbc-2c51-420b-805c-c33c6ae7fc01",
      "code": "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n",
      "title": "2048. Next Greater Numerically Balanced Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2a64513-236f-4c39-9d2d-5b99fbc8b83f",
      "code": "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans",
      "title": "2049. Count Nodes With the Highest Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3e347d5-a5d8-48cc-b078-51afedb24b05",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)",
      "title": "2050. Parallel Courses III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "414b0119-a0d1-4843-8732-88451088cfc3",
      "code": "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])",
      "title": "2052. Minimum Cost to Separate Sentence Into Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa7ed381-cbdd-4c48-941d-63190e9eeac6",
      "code": "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''",
      "title": "2053. Kth Distinct String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45668ab6-6004-43a4-a2f6-62ca8335ad35",
      "code": "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans",
      "title": "2054. Two Best Non-Overlapping Events",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8225da69-241f-433c-be9c-ab851dc377f0",
      "code": "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans",
      "title": "2055. Plates Between Candles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dfd0fd6-b6d3-4415-9c69-736d4b6c9f16",
      "code": "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)",
      "title": "2056. Number of Valid Move Combinations On Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b71d3f0b-0028-43ed-9d5f-52f4f3cdc1fe",
      "code": "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)",
      "title": "2057. Smallest Index With Equal Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f85b14af-b8e2-4177-adc5-520442cce5d2",
      "code": "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]",
      "title": "2058. Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efb48add-9c42-48e9-a1dd-75e0de7cb9d8",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1",
      "title": "2059. Minimum Operations to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba39d6b7-4dbe-4f29-aee0-05eed6ea07df",
      "code": "class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)",
      "title": "2060. Check if an Original String Exists Given Two Encoded Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7139b45-dda4-41bc-b626-80c85659ce5b",
      "code": "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))",
      "title": "2061. Number of Spaces Cleaning Robot Cleaned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fc869bf-7943-42bf-8adf-a4337e48a4a6",
      "code": "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)",
      "title": "2062. Count Vowel Substrings of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf05c601-4f68-495a-b7b0-8dbfc9747dd0",
      "code": "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)",
      "title": "2063. Vowels of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15efa08-ec23-4029-8b4a-b7fc07b47660",
      "code": "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2064. Minimized Maximum of Products Distributed to Any Store",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75b9d339-5d62-4a35-9e81-2503b5a12da2",
      "code": "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans",
      "title": "2065. Maximum Path Quality of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48e931b9-c9ad-4620-a7b5-8df91997f146",
      "code": "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans",
      "title": "2067. Number of Equal Count Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09ac806d-17e9-40cb-94f7-db83c938a058",
      "code": "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())",
      "title": "2068. Check Whether Two Strings are Almost Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7406b4e-7d38-406a-8696-958893fc25e4",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]",
      "title": "2070. Most Beautiful Item for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56170287-c713-4ac9-a6ba-cf0f9fb4f853",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "2071. Maximum Number of Tasks You Can Assign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "999d8fe9-723c-41b7-ba72-bd30e62a0210",
      "code": "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans",
      "title": "2073. Time Needed to Buy Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "301503f2-1371-41ce-a10e-8616120215c4",
      "code": "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next",
      "title": "2074. Reverse Nodes in Even Length Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d539493-d268-4d2c-8b9c-dafcbe423686",
      "code": "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()",
      "title": "2075. Decode the Slanted Ciphertext",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1852692-3e8f-4d00-ae02-c31d0e62491a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans",
      "title": "2076. Process Restricted Friend Requests",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f57c63e-c7ed-40b0-bc47-919428c5f39c",
      "code": "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3",
      "title": "2077. Paths in Maze That Lead to Same Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfade47a-acff-4e3b-963d-b1513b8703b6",
      "code": "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)",
      "title": "2078. Two Furthest Houses With Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "423e154e-0d28-47c0-84af-f307093f0143",
      "code": "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)",
      "title": "2079. Watering Plants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebfa28e6-c110-46f8-b8a0-2bef07aca41d",
      "code": "class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans",
      "title": "2081. Sum of k-Mirror Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee3e8760-7de5-4533-a76b-3f14b35dd9fe",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans",
      "title": "2083. Substrings That Begin and End With the Same Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fe768aa-3407-44a4-ab4b-33e217cc080f",
      "code": "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())",
      "title": "2085. Count Common Words With One Occurrence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7884f90a-d61c-4de6-b8fa-a63ba7172a93",
      "code": "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')",
      "title": "2086. Minimum Number of Buckets Required to Collect Rainwater from Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa3660f9-a08a-4c78-8a39-cef97ebb4523",
      "code": "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans",
      "title": "2087. Minimum Cost Homecoming of a Robot in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80ea3767-d634-4b29-aa7c-7628daa9af22",
      "code": "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)",
      "title": "2088. Count Fertile Pyramids in a Land",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdd6a731-9021-479f-a234-75fd596a8790",
      "code": "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]",
      "title": "2089. Find Target Indices After Sorting Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f781f047-5605-4203-bd8c-e055217420e8",
      "code": "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans",
      "title": "2090. K Radius Subarray Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba6dc182-9ca4-4b99-a7ae-af9d4a0e1708",
      "code": "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)",
      "title": "2091. Removing Minimum and Maximum From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0523804f-b92f-4a4f-9e29-202a2043d17e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]",
      "title": "2092. Find All People With Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1183c88-2352-4762-98cf-14e99dd3a190",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1",
      "title": "2093. Minimum Cost to Reach City With Discounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9952088f-7515-425d-a52f-c4c4e612c937",
      "code": "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans",
      "title": "2094. Finding 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8aec75d-982b-4fa9-8f7a-8218d4dd9892",
      "code": "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next",
      "title": "2095. Delete the Middle Node of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22a24387-779a-4aeb-8569-3a8bbfd70054",
      "code": "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26ffeaac-1bde-4635-9102-a10897eb5ced",
      "code": "class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]",
      "title": "2097. Valid Arrangement of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b11cda2-d510-40b8-b35c-1ee9c75befa7",
      "code": "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans",
      "title": "2098. Subsequence of Size K With the Largest Even Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0706569-64c7-4486-bbd6-69216a05dd2c",
      "code": "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans",
      "title": "2099. Find Subsequence of Length K With the Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01b9e1b9-0f55-4a62-b2cc-908ed1e1423c",
      "code": "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]",
      "title": "2100. Find Good Days to Rob the Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "382f7adb-e62c-45cc-bb82-1f0343c9548a",
      "code": "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans",
      "title": "2101. Detonate the Maximum Bombs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83319ff0-31e0-4454-8427-e55fcaf5b284",
      "code": "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)",
      "title": "2103. Rings and Rods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0781082f-b776-4f57-b541-8fb2b41335cd",
      "code": "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "2104. Sum of Subarray Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75992f4e-f6b9-43a5-b308-5cb6405bc329",
      "code": "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])",
      "title": "2105. Watering Plants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff063498-7581-42ba-bda4-531b6946e98f",
      "code": "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans",
      "title": "2106. Maximum Fruits Harvested After at Most K Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3107ed51-e7ac-4814-ba52-1fcd92f87b87",
      "code": "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans",
      "title": "2107. Number of Unique Flavors After Sharing K Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9eeee4e-e4b5-4ead-be6a-0d65cc999683",
      "code": "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')",
      "title": "2108. Find First Palindromic String in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "083f15a0-b08d-4091-bfd5-6b1393573a7a",
      "code": "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)",
      "title": "2109. Adding Spaces to a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8de76ce-3332-461e-ad7a-58205f0c5d46",
      "code": "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans",
      "title": "2110. Number of Smooth Descent Periods of a Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6db190eb-3a16-4e9b-9b16-6a231ad1c44a",
      "code": "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))",
      "title": "2111. Minimum Operations to Make the Array K-Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8dc8134-13e3-455c-b824-e07aeb4e1bf9",
      "code": "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]",
      "title": "2113. Elements in Array After Removing and Replacing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a95f0487-4db8-49a4-b905-e1290a23371f",
      "code": "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1",
      "title": "2114. Maximum Number of Words Found in Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58996925-622f-46d4-acbd-9abab66ef2a0",
      "code": "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans",
      "title": "2115. Find All Possible Recipes from Given Supplies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0917698f-a6af-4f83-a5bc-84d6aaf7a716",
      "code": "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)",
      "title": "2116. Check if a Parentheses String Can Be Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4280ed34-ddb5-45c5-a7d9-205cf4e62338",
      "code": "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)",
      "title": "2117. Abbreviating the Product of a Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b97c1c90-639a-4a12-9f5d-de361e12aa8f",
      "code": "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num",
      "title": "2119. A Number After a Double Reversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abe75c1c-bc0d-4013-95b3-98c0007498b9",
      "code": "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans",
      "title": "2120. Execution of All Suffix Instructions Staying in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea90b64c-1a83-49b3-8877-03cc1b5bb2b4",
      "code": "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]",
      "title": "2121. Intervals Between Identical Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "136ac50e-9e61-487e-b325-55f55d583e21",
      "code": "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr",
      "title": "2122. Recover the Original Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dcb0219-3dea-4896-98cf-f6f9dc7e472f",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans",
      "title": "2123. Minimum Operations to Remove Adjacent Ones in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f6d2570-b698-4711-8000-6cfb4222c92c",
      "code": "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s",
      "title": "2124. Check if All A's Appears Before All B's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5aee4711-a737-4f76-ac1d-abb95a928fc2",
      "code": "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans",
      "title": "2125. Number of Laser Beams in a Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3341792f-eba9-4810-bd89-003a0357680d",
      "code": "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True",
      "title": "2126. Destroying Asteroids",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3683be82-c2e5-44b1-a27e-981d646a1401",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)",
      "title": "2127. Maximum Employees to Be Invited to a Meeting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c335ddb-2f97-4884-b901-b18bf20d6a9c",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)",
      "title": "2128. Remove All Ones With Row and Column Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f3f8479-4041-472f-91b7-c416ccfbf0f3",
      "code": "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())",
      "title": "2129. Capitalize the Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75849c18-1dc3-497c-907f-151fe4ed2587",
      "code": "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans",
      "title": "2130. Maximum Twin Sum of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd2deaa2-0507-4342-a72d-aacee014383f",
      "code": "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans",
      "title": "2131. Longest Palindrome by Concatenating Two Letter Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7d7338d-6df8-454d-9eed-11413fcf2a8b",
      "code": "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True",
      "title": "2132. Stamping the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fdc9ed5-7adc-4a15-9394-f21b87550437",
      "code": "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))",
      "title": "2133. Check if Every Row and Column Contains All Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94f193f8-9b52-476a-9425-7d231cbd8d66",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "2134. Minimum Swaps to Group All 1's Together II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fe0077f-14d7-4adf-b00b-f22ee06fcf0a",
      "code": "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans",
      "title": "2135. Count Words Obtained After Adding a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac95808a-fe25-4fa3-82f4-8cefb14457be",
      "code": "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans",
      "title": "2136. Earliest Possible Day of Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b297004a-b6ae-4377-a027-5b73ff87f960",
      "code": "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "2137. Pour Water Between Buckets to Make Water Levels Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84b080ca-7f59-46a0-a388-eecead4e1875",
      "code": "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]",
      "title": "2138. Divide a String Into Groups of Size k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9011f378-b379-45f5-bab0-413faeec9606",
      "code": "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1",
      "title": "2139. Minimum Moves to Reach Target Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44b29926-a708-49d4-8072-2d9ecd4c0e74",
      "code": "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]",
      "title": "2140. Solving Questions With Brainpower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee57cae0-54ed-487c-83a2-e8c4f471db87",
      "code": "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n",
      "title": "2141. Maximum Running Time of N Computers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "275cb49d-41f9-450c-9db9-13684346cec1",
      "code": "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans",
      "title": "2143. Choose Numbers From Two Arrays in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b868d049-9a63-4861-8bf3-7508ee644ce7",
      "code": "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])",
      "title": "2144. Minimum Cost of Buying Candies With Discount",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "174a9996-f5b0-48d1-b2be-57e99c1cc58f",
      "code": "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)",
      "title": "2145. Count the Hidden Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8e12a02-404a-4471-9aec-b762968bf6c2",
      "code": "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans",
      "title": "2146. K Highest Ranked Items Within a Price Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46298cb4-e188-46ba-9346-f072692d4930",
      "code": "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0",
      "title": "2147. Number of Ways to Divide a Long Corridor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc94325e-5e75-481c-b376-556b59140627",
      "code": "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)",
      "title": "2148. Count Elements With Strictly Smaller and Greater Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0227aa16-c451-46cc-95bd-628808de0ca9",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans",
      "title": "2149. Rearrange Array Elements by Sign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4856624e-7708-4473-b658-a901d2a0ce5b",
      "code": "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]",
      "title": "2150. Find All Lonely Numbers in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67292b31-0abd-4349-9edf-e69ab90a9045",
      "code": "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans",
      "title": "2151. Maximum Good People Based on Statements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "573b0be6-d92b-48dd-9086-32d52b2dea44",
      "code": "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)",
      "title": "2152. Minimum Number of Lines to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb37d48f-fc68-4f11-a2ea-75bd88cae275",
      "code": "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original",
      "title": "2154. Keep Multiplying Found Values by Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a7ba54e-2e38-4767-91d1-642500874972",
      "code": "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans",
      "title": "2155. All Divisions With the Highest Score of a Binary Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6bd3a99-ba97-4cca-8b06-b1dded97391c",
      "code": "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]",
      "title": "2156. Find Substring With Given Hash Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87739926-0ba9-43cb-bf21-e625cd21b737",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]",
      "title": "2157. Groups of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa63a96c-b628-4318-be66-d3b4134b04a5",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans",
      "title": "2158. Amount of New Area Painted Each Day",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a409dbf-0d63-4f00-abbe-672a9eff8685",
      "code": "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])",
      "title": "2160. Minimum Sum of Four Digit Number After Splitting Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e98a6a1c-a34e-4e62-b301-bdff4f065687",
      "code": "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])",
      "title": "2161. Partition Array According to Given Pivot",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5675aa6-68f3-40eb-b4d0-451c7da77d4a",
      "code": "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans",
      "title": "2162. Minimum Cost to Set Cooking Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c57fd3ed-b280-4f82-88c6-d0615b845047",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans",
      "title": "2163. Minimum Difference in Sums After Removal of Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0be4f062-9202-43d5-a492-28bb4a9d41d5",
      "code": "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans",
      "title": "2164. Sort Even and Odd Indices Independently",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83974979-4fdc-4a67-a8e6-ae5a4d5b0b87",
      "code": "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)",
      "title": "2165. Smallest Value of the Rearranged Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02bc3b3b-547e-4e6c-ae0a-786cfb21dd83",
      "code": "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)",
      "title": "2167. Minimum Time to Remove All Cars Containing Illegal Goods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25c5dea6-21f7-46a3-bd31-efe0e61299e6",
      "code": "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())",
      "title": "2168. Unique Substrings With Equal Digit Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43872612-2209-436b-b78a-6dac989b1e9d",
      "code": "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans",
      "title": "2169. Count Operations to Obtain Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99cf3560-ca46-4781-b019-12423a7d322c",
      "code": "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)",
      "title": "2170. Minimum Operations to Make the Array Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8d3aa5b-b769-4185-92d6-13370f2cf51f",
      "code": "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))",
      "title": "2171. Removing Minimum Number of Magic Beans",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d77c7bbe-4b0f-4d70-9b65-c89866d6dd76",
      "code": "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]",
      "title": "2172. Maximum AND Sum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bd639c1-f640-467a-87fa-970ad643dc3b",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            newMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              newMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              newMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(newMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded",
      "title": "2174. Remove All Ones With Row and Column Flips II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37cd1550-0a8d-4af6-9488-102019974eec",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans",
      "title": "2176. Count Equal and Divisible Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4af3d38d-0171-4a02-b8fd-165e42cb62ea",
      "code": "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]",
      "title": "2177. Find Three Consecutive Integers That Sum to a Given Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "714ee5c4-562a-4886-b3a2-93b618573305",
      "code": "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]",
      "title": "2178. Maximum Split of Positive Even Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8fe8389-a753-4602-8c46-6e5c2d0b986c",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))",
      "title": "2179. Count Good Triplets in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bce920bf-f9fc-4ec3-97db-e0aa9ae78318",
      "code": "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2180. Count Integers With Even Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee7d5457-90d1-4ac2-b90a-3be3cb8fd1fc",
      "code": "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next",
      "title": "2181. Merge Nodes in Between Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2bf7cb9-e2d4-4adc-987f-bebdf5d1f07c",
      "code": "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '",
      "title": "2182. Construct String With Repeat Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3ad4409-c483-411f-bb63-aa6a68872ee1",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans",
      "title": "2183. Count Array Pairs Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f1737bc-fc3d-488c-9a46-c70b1dca75ef",
      "code": "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)",
      "title": "2184. Number of Ways to Build Sturdy Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82b8d4fa-41ca-44b0-9b79-a3274930b23f",
      "code": "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)",
      "title": "2185. Counting Words With a Given Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cce6142-c3c5-4851-9cf8-c03a800ff403",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])",
      "title": "2186. Minimum Number of Steps to Make Two Strings Anagram II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99006ed0-89d4-4be7-b1bb-5f1cbfa6a682",
      "code": "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2187. Minimum Time to Complete Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "946312f4-b67d-483c-af57-376704793d34",
      "code": "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime",
      "title": "2188. Minimum Time to Finish the Race",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf4b5251-704e-46af-8906-f25073d97f35",
      "code": "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]",
      "title": "2189. Number of Ways to Build House of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56c66f04-bffd-49ad-b166-32e925e4ef8e",
      "code": "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])",
      "title": "2190. Most Frequent Number Following Key In an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8fe31d2-07bf-4e45-8d58-759741797246",
      "code": "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]",
      "title": "2191. Sort the Jumbled Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f761dd6-f665-41b4-bef2-0871c7cf870c",
      "code": "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]",
      "title": "2192. All Ancestors of a Node in a Directed Acyclic Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a294c29a-71d8-4afd-a757-81c89a355b32",
      "code": "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans",
      "title": "2193. Minimum Number of Moves to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50cd8dd1-795f-486d-848e-ab6abe0ab0bb",
      "code": "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans",
      "title": "2194. Cells in a Range on an Excel Sheet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35bd74fa-e61d-4c09-a1c6-e8491a141734",
      "code": "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans",
      "title": "2195. Append K Integers With Minimal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87794781-fce0-4955-ac87-c54aec14de5d",
      "code": "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]",
      "title": "2196. Create Binary Tree From Descriptions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05e34ebb-5af7-44d4-95be-eb9b431f8412",
      "code": "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans",
      "title": "2197. Replace Non-Coprime Numbers in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15ed0fd-c127-4ee7-a157-7f999149e947",
      "code": "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6",
      "title": "2198. Number of Single Divisor Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac050e1b-955c-4a20-8a1a-8a734f4c55a5",
      "code": "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans",
      "title": "2200. Find All K-Distant Indices in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92699381-a6ad-4979-b6c6-a1ddb92002bd",
      "code": "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)",
      "title": "2201. Count Artifacts That Can Be Extracted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba77d3b2-2d31-4f6b-986c-be4fc8fc7de6",
      "code": "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])",
      "title": "2202. Maximize the Topmost Element After K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59d7cc93-5173-467d-8b20-198bf6b6f668",
      "code": "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2203. Minimum Weighted Subgraph With the Required Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56817dcd-6bfb-4599-a49b-09f7e1a9b6f9",
      "code": "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans",
      "title": "2204. Distance to a Cycle in Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8c8e484-93ff-496a-9c58-8fd6ffed934f",
      "code": "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())",
      "title": "2206. Divide Array Into Equal Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "935db980-8ad6-4d3d-bc54-c36914c2fa23",
      "code": "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)",
      "title": "2207. Maximize Number of Subsequences in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd0cab7c-381a-4fa7-9415-7aa2210fca65",
      "code": "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans",
      "title": "2208. Minimum Operations to Halve Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dac7376-b7f5-4396-b355-1e5d64a2bb1d",
      "code": "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]",
      "title": "2209. Minimum White Tiles After Covering With Carpets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d17f52e-a92e-44ad-a635-ffba2eaae330",
      "code": "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans",
      "title": "2210. Count Hills and Valleys in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fe100a8-df63-41a6-8c47-fe5435a5886b",
      "code": "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])",
      "title": "2211. Count Collisions on a Road",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36de2a01-5041-4efe-a53b-0313200d5c74",
      "code": "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)",
      "title": "2212. Maximum Points in an Archery Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91c97924-1e96-422b-a33f-01701a8c1937",
      "code": "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)",
      "title": "2214. Minimum Health to Beat Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffbcd7d0-edda-45fd-9cba-6ee5700af400",
      "code": "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]",
      "title": "2215. Find the Difference of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19917b4d-1f5b-402b-9bf4-4d06cee8ec6b",
      "code": "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)",
      "title": "2216. Minimum Deletions to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b173fc0d-f6ef-4b28-a360-35d6b63b4344",
      "code": "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]",
      "title": "2217. Find Palindrome With Fixed Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbe6e25a-1413-43c5-9ce4-663ed01039c7",
      "code": "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)",
      "title": "2218. Maximum Value of K Coins From Piles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87af1491-6a63-4ccd-abd5-d5760604a482",
      "code": "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans",
      "title": "2219. Maximum Sum Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "260d9bc4-465e-4d2d-8990-93e4e69b9952",
      "code": "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()",
      "title": "2220. Minimum Bit Flips to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "647407ed-7a1a-48e6-9eae-f295122acbc4",
      "code": "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]",
      "title": "2221. Find Triangular Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1066b9a-05a7-4e38-a49b-a2ebe4896a83",
      "code": "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans",
      "title": "2222. Number of Ways to Select Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "869df62d-8303-42e5-997c-53df759989e4",
      "code": "class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n",
      "title": "2223. Sum of Scores of Built Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2608a331-cb0d-4b50-8c2e-c1efeb48dc8f",
      "code": "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans",
      "title": "2224. Minimum Number of Operations to Convert Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7ed3fa0-b5d0-4601-88d5-003bad415595",
      "code": "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]",
      "title": "2225. Find Players With Zero or One Losses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "281b23ea-283e-466b-b395-a51ee7fdc8cc",
      "code": "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1",
      "title": "2226. Maximum Candies Allocated to K Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cceca1f-a4c4-4d3e-8a80-8e1c9ecbcbdf",
      "code": "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)",
      "title": "2229. Check if an Array Is Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3388d36-d32d-42ce-a749-a786cfa7c14f",
      "code": "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans",
      "title": "2231. Largest Number After Digit Swaps by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3b2ea6a-f701-4b9a-9314-55e2297baf80",
      "code": "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans",
      "title": "2232. Minimize Result by Adding Parentheses to Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d6c5839-3bd5-45ad-a9b4-e12443842a26",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans",
      "title": "2233. Maximum Product After K Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ba44a18-afab-4e64-ada0-7593ad5d519f",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans",
      "title": "2234. Maximum Total Beauty of the Gardens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "217a721c-054c-449d-9ddd-49bd2ccedf60",
      "code": "class Solution:\n  sum = operator.add",
      "title": "2235. Add Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55f6d256-ebcc-418c-957a-2434847e7614",
      "code": "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val",
      "title": "2236. Root Equals Sum of Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f359f334-bf75-45f2-aeae-64f4c1a76b28",
      "code": "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans",
      "title": "2237. Count Positions on Street With Required Brightness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf0de97b-42d8-45da-b769-f2acbc90010f",
      "code": "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]",
      "title": "2239. Find Closest Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a04166d1-cf46-4021-b1f8-556d32a71c2e",
      "code": "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1",
      "title": "2240. Number of Ways to Buy Pens and Pencils",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c303a30-9b47-4fb3-98ec-5c5d8fc26d43",
      "code": "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans",
      "title": "2242. Maximum Score of a Node Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b21d675-9b1a-4c1d-8f3b-2d52b7a49cfb",
      "code": "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s",
      "title": "2243. Calculate Digit Sum of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd4f1601-af7d-430b-9556-c53f4d03e1bb",
      "code": "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)",
      "title": "2244. Minimum Rounds to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bf0ff83-8476-46c4-8fce-e6c3c7b20dd7",
      "code": "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans",
      "title": "2245. Maximum Trailing Zeros in a Cornered Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53cf66b8-cea0-4b49-a513-bb50a58507d7",
      "code": "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans",
      "title": "2246. Longest Path With Different Adjacent Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ff7d82f-7bc0-484c-a9ea-1c65797a2504",
      "code": "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))",
      "title": "2247. Maximum Cost of Trip With K Highways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c4826dc-2fee-4362-a941-ada922cb1ff2",
      "code": "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]",
      "title": "2248. Intersection of Multiple Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0dd6572-5a7b-4916-8bd7-f2d49969b329",
      "code": "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)",
      "title": "2249. Count Lattice Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d28f7ae-6335-4286-991f-e7687fc9351c",
      "code": "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans",
      "title": "2250. Count Number of Rectangles Containing Each Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d703df1e-15fe-45a7-b386-5caf9936eff4",
      "code": "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]",
      "title": "2251. Number of Flowers in Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "051b7784-eba6-4c23-b431-4af833cdd60d",
      "code": "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))",
      "title": "2255. Count Prefixes of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef8438cb-18a1-4f29-94ef-66a1722888a9",
      "code": "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans",
      "title": "2256. Minimum Average Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c13860fe-ed9e-4d3a-a64a-12ca356c1a53",
      "code": "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans",
      "title": "2257. Count Unguarded Cells in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e5b3494-a6c1-4079-bdce-6af999762b9a",
      "code": "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False",
      "title": "2258. Escape the Spreading Fire",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a35a0eb3-2a57-46b7-9baa-bd604c463443",
      "code": "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans",
      "title": "2260. Minimum Consecutive Cards to Pick Up",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06ce3b82-361e-4432-b45b-c714c8620320",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans",
      "title": "2261. K Divisible Elements Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d05c7536-12ba-4398-8749-a53b837e04a1",
      "code": "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans",
      "title": "2262. Total Appeal of A String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a0cd065-2f79-40e1-b9a9-c0b5548fa015",
      "code": "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))",
      "title": "2263. Make Array Non-decreasing or Non-increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af0a185a-2657-46f8-894c-7d2b05e606ce",
      "code": "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))",
      "title": "2264. Largest 3-Same-Digit Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bae99415-70a4-4785-8f67-f2ebc5913407",
      "code": "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans",
      "title": "2265. Count Nodes Equal to Average of Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1bee8b2-2705-436e-a6d7-a9af451b7084",
      "code": "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]",
      "title": "2266. Count Number of Texts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93fb3bcb-347a-4605-9f3e-aa44ed22b99a",
      "code": "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)",
      "title": "2267. Check if There Is a Valid Parentheses String Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25e9e7ab-9434-432c-9814-e84a8a6aeff2",
      "code": "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))",
      "title": "2268. Minimum Number of Keypresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a41b100-46f2-453c-b9ca-59936dcc97ae",
      "code": "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans",
      "title": "2269. Find the K-Beauty of a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "531f3397-2a8f-4061-90ac-96ae5359c8bc",
      "code": "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans",
      "title": "2270. Number of Ways to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af67dc20-53cc-4ee4-a934-e6b7963a712f",
      "code": "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans",
      "title": "2271. Maximum White Tiles Covered by a Carpet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "292427e5-7f52-4efa-ab2d-8703a71db199",
      "code": "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)",
      "title": "2272. Substring With Largest Variance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86c81ccf-0590-43ca-b09e-d4db19f8ea95",
      "code": "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans",
      "title": "2273. Find Resultant Array After Removing Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a256be6c-8cc0-4633-94ac-c12bd97fc682",
      "code": "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])",
      "title": "2274. Maximum Consecutive Floors Without Special Floors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9607e7fb-9506-45ee-8308-d0af1194707a",
      "code": "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))",
      "title": "2275. Largest Combination With Bitwise AND Greater Than Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8807a14-10c0-4101-8518-6710fab82371",
      "code": "class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]",
      "title": "2277. Closest Node to Path in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b344274c-2c59-4e35-8a46-2e0c477f1e9b",
      "code": "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)",
      "title": "2278. Percentage of Letter in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6996d47d-76f2-4dd5-a5ba-e20b0683d23c",
      "code": "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)",
      "title": "2279. Maximum Bags With Full Capacity of Rocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bf38d6b-496d-47d1-8647-51d0e8cfd51c",
      "code": "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)",
      "title": "2280. Minimum Lines to Represent a Line Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ada409f-e396-4dda-be8d-83cdfa24e575",
      "code": "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD",
      "title": "2281. Sum of Total Strength of Wizards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34c7de06-c24f-4aca-92c6-379b1340fd2a",
      "code": "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans",
      "title": "2282. Number of People That Can Be Seen in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11dad5a7-1e03-45a9-b995-ff833d3c6194",
      "code": "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))",
      "title": "2283. Check if Number Has Equal Digit Count and Digit Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "376f1a39-bc3f-4dad-91df-076ac68bf16c",
      "code": "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans",
      "title": "2284. Sender With Largest Word Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42fd68ec-3b72-4822-9ae6-204a10986a13",
      "code": "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))",
      "title": "2285. Maximum Total Importance of Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98a3066b-c28b-49da-a93d-6d54bede5803",
      "code": "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)",
      "title": "2287. Rearrange Characters to Make Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b2f9e9e-61ef-42ec-b5b5-f3311c9e6ed8",
      "code": "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)",
      "title": "2288. Apply Discount to Prices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0a7b1f1-2d26-408c-a3b4-a11ed649c820",
      "code": "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)",
      "title": "2289. Steps to Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33ab67c5-b9f4-4664-bb67-3fd75d9fafb5",
      "code": "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]",
      "title": "2290. Minimum Obstacle Removal to Reach Corner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5126666-ebb2-47a4-b20d-c4714b829883",
      "code": "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]",
      "title": "2291. Maximum Profit From Trading Stocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c59fcc4-9506-4297-b043-1107cf1a8a6a",
      "code": "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)",
      "title": "2293. Min Max Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a21ae9c-fd89-49a0-a759-18a1ab2276ff",
      "code": "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans",
      "title": "2294. Partition Array Such That Maximum Difference Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c3365f6-be7f-4b10-b215-6dcb68fff215",
      "code": "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums",
      "title": "2295. Replace Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "223633c4-aab0-4265-be1d-ea3a2880116e",
      "code": "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]",
      "title": "2297. Jump Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c11d70b8-8c15-493c-beda-95f74bda023b",
      "code": "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))",
      "title": "2299. Strong Password Checker II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43361dd8-7e28-46f7-8f9a-e6af4ff3ecdd",
      "code": "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]",
      "title": "2300. Successful Pairs of Spells and Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a77b4367-4a06-4b2d-a45e-30b458cc136b",
      "code": "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True",
      "title": "2301. Match Substring After Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c36e5077-7e21-45f1-9177-a4bf924f6d63",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2302. Count Subarrays With Score Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07d69a47-e99f-4e7a-9702-3be5e5bc21f6",
      "code": "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans",
      "title": "2303. Calculate Amount Paid in Taxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e4c3050-1d97-442e-8049-11de15561203",
      "code": "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])",
      "title": "2304. Minimum Path Cost in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "914ef031-2efa-4a8a-88aa-4da6cae30e61",
      "code": "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans",
      "title": "2305. Fair Distribution of Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7d15808-ba46-42ff-885e-2f9fabc16144",
      "code": "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i, j in itertools.combinations(range(26), 2):\n      count = len(suffixes[i] & suffixes[j])\n      ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans",
      "title": "2306. Naming a Company",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1ee0d1a-f9fd-408c-9188-0893661804ed",
      "code": "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False",
      "title": "2307. Check for Contradictions in Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31deb361-daa3-418f-a4bd-c6292999c051",
      "code": "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''",
      "title": "2309. Greatest English Letter in Upper and Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "749833b7-7401-417f-9d3d-4fa6338a2c5d",
      "code": "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1",
      "title": "2310. Sum of Numbers With Units Digit K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db1f15fb-8674-43bb-911b-174b4d91f8d5",
      "code": "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount",
      "title": "2311. Longest Binary Subsequence Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd356e23-cdd3-4e43-a9d8-03894b65d918",
      "code": "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]",
      "title": "2312. Selling Pieces of Wood",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46b605b4-650e-4423-8453-03546069d5a4",
      "code": "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)",
      "title": "2313. Minimum Flips in Binary Tree to Get Result",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "515b9be8-725f-47b1-a7d7-e369b2bb2be3",
      "code": "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans",
      "title": "2315. Count Asterisks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fad27512-dceb-427b-bf33-b6242190d599",
      "code": "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)",
      "title": "2316. Count Unreachable Pairs of Nodes in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6cb42e-6b07-4f2b-874a-c918734f2eca",
      "code": "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)",
      "title": "2317. Maximum XOR After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce23cf18-347a-4f75-9e8b-244ae8b26ef5",
      "code": "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)",
      "title": "2318. Number of Distinct Roll Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2158034d-ebd9-48d0-bd89-3ec4cf150400",
      "code": "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True",
      "title": "2319. Check if Matrix Is X-Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8b38718-c14f-447b-8d49-50d63ac9c6a0",
      "code": "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD",
      "title": "2320. Count Number of Ways to Place Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "056571a6-b148-4ba9-8a91-cac3b57f2cc9",
      "code": "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))",
      "title": "2321. Maximum Score Of Spliced Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2549cac9-4879-4bcd-87d8-bed5ab564b02",
      "code": "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans",
      "title": "2322. Minimum Score After Removals on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d26507f-1379-4465-a661-c97df9d75d2d",
      "code": "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans",
      "title": "2323. Find Minimum Time to Finish All Jobs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e3a1d7c-cfe8-424b-8067-7e2a1c2f364d",
      "code": "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)",
      "title": "2325. Decode the Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7807165c-5c71-4745-8bae-27a382253f0d",
      "code": "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans",
      "title": "2326. Spiral Matrix IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0db16446-650e-4ebe-af24-fdf71ffc91d2",
      "code": "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD",
      "title": "2327. Number of People Aware of a Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd3d8542-c7e3-406a-8f38-86f6dac3baee",
      "code": "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD",
      "title": "2328. Number of Increasing Paths in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8104493-b8c7-4d15-ae8e-6230700f0ca7",
      "code": "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "2330. Valid Palindrome IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89e8094e-eda3-42cc-a8cd-034ca7de8fb2",
      "code": "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
      "title": "2331. Evaluate Boolean Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45b134f7-26b3-4021-9697-280763d9f162",
      "code": "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans",
      "title": "2332. The Latest Time to Catch a Bus",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "840d598c-b28f-45ec-b921-032ec83a4268",
      "code": "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1",
      "title": "2334. Subarray With Elements Greater Than Varying Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27b9e065-0e23-4254-991f-b826782ac07c",
      "code": "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)",
      "title": "2335. Minimum Amount of Time to Fill Cups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d736978f-500e-4847-8566-59b42389a667",
      "code": "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "2337. Move Pieces to Obtain a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91e8a98d-9f8b-446d-be6c-4281ff7f8299",
      "code": "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex",
      "title": "2340. Minimum Adjacent Swaps to Make a Valid Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f53f1a4b-c868-41bd-be29-d83b1d666c92",
      "code": "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans",
      "title": "2341. Maximum Number of Pairs in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f2fb8ae-e537-45e2-a39d-56988ab248bb",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2342. Max Sum of a Pair With Equal Sum of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff2bb403-78c4-4de0-b980-864761648492",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1",
      "title": "2344. Minimum Deletions to Make Array Divisible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4a736ae-3ed0-4ad0-843b-5090270665d8",
      "code": "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans",
      "title": "2345. Finding the Number of Visible Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e75eca76-f155-42c7-9d06-68e18215d4a2",
      "code": "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'",
      "title": "2347. Best Poker Hand",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f66eeda-3967-428a-a33f-f56978483715",
      "code": "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans",
      "title": "2348. Number of Zero-Filled Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfd1e327-9e5f-4e1c-888b-d72a7b8bcda5",
      "code": "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans",
      "title": "2350. Shortest Impossible Sequence of Rolls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bfc5663-824a-4ed7-b908-4c40dff026bc",
      "code": "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True",
      "title": "2351. First Letter to Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae13c28-190f-4abc-b3ef-bfaf69dd298d",
      "code": "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans",
      "title": "2352. Equal Row and Column Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1602a9b1-489c-449b-aa66-1220d31c293c",
      "code": "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)",
      "title": "2354. Number of Excellent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89acf9c2-7384-440e-a7bb-bd0235b29589",
      "code": "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)",
      "title": "2355. Maximum Number of Books You Can Take",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b85a85d1-5450-4eba-bf5e-fc01264025da",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})",
      "title": "2357. Make Array Zero by Subtracting Equal Amounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8563eb62-d015-4a58-bc1d-27a0db8b8c8c",
      "code": "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)",
      "title": "2358. Maximum Number of Groups Entering a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd0b923d-67b2-401d-be56-fe8eb64adfca",
      "code": "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist",
      "title": "2359. Find Closest Node to Given Two Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68250e5b-bf0f-43d8-93aa-c152d6931921",
      "code": "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans",
      "title": "2360. Longest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf7cca79-e958-4eb0-88de-035531ec3244",
      "code": "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans",
      "title": "2361. Minimum Costs Using the Train Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c12ad9bb-f3a4-4f23-961e-13588de0885a",
      "code": "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())",
      "title": "2363. Merge Similar Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee80c9dd-25ea-45f5-ab08-0ddb6eb539ce",
      "code": "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans",
      "title": "2364. Count Number of Bad Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80c35eee-682c-4c6e-aceb-9cdadf4cb49a",
      "code": "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans",
      "title": "2365. Task Scheduler II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a1d21af-c9a9-479f-b33b-f93ea0443755",
      "code": "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans",
      "title": "2366. Minimum Replacements to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af1d3fc6-39a7-4df6-89bb-85ef295c4214",
      "code": "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans",
      "title": "2367. Number of Arithmetic Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a28f866-0613-4f5e-a865-0e53d33cd6a9",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)",
      "title": "2368. Reachable Nodes With Restrictions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10e82732-b4cb-42d8-a4b0-7d96a0512a78",
      "code": "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]",
      "title": "2369. Check if There is a Valid Partition For The Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6abf8d2-fd9b-4e90-83d2-24b68ca2bf5a",
      "code": "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable",
      "title": "2370. Longest Ideal Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0513786-ed0a-4ffa-94d8-4c428c21f715",
      "code": "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans",
      "title": "2371. Minimize Maximum Value in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cf5f03b-d124-4e0d-8811-e7ead8ea770e",
      "code": "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans",
      "title": "2373. Largest Local Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10cdfb63-6a88-481f-9014-ac99f9e7c188",
      "code": "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))",
      "title": "2374. Node With Highest Edge Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a835b49e-c0d6-4e84-9910-53419514c6be",
      "code": "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)",
      "title": "2375. Construct Smallest Number From DI String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c434f00-0f91-4529-ba39-1ae6d1711ec9",
      "code": "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "2376. Count Special Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb039e67-4ac3-422f-ad20-743f214bbf40",
      "code": "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)",
      "title": "2378. Choose Edges to Maximize Score in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d51e717b-ef96-42c4-8cf3-7c80240189e1",
      "code": "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB",
      "title": "2379. Minimum Recolors to Get K Consecutive Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19b9c7e1-d7ca-4d49-945e-569fb8aa1090",
      "code": "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans",
      "title": "2380. Time Needed to Rearrange a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47297f63-6d81-4265-9d01-e65b016ab88c",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    line = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      line[start] += diff\n      line[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + line[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)",
      "title": "2381. Shifting Letters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e4a52b2-4c59-4f41-9073-7bb0909a73e9",
      "code": "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans",
      "title": "2382. Maximum Segment Sum After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "135fecaa-1621-4353-89f0-bb634a6954de",
      "code": "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience",
      "title": "2383. Minimum Hours of Training to Win a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb92035f-c0ba-4984-abb0-d43d69f0b131",
      "code": "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''",
      "title": "2384. Largest Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93f6e81f-e76d-4ef1-8465-9f51f0f8f5fe",
      "code": "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph",
      "title": "2385. Amount of Time for Binary Tree to Be Infected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a20511df-bf42-459e-af62-710d7763408f",
      "code": "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum",
      "title": "2386. Find the K-Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "961b662c-c2f7-4343-8392-1af00f23fef3",
      "code": "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2387. Median of a Row Wise Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea3f1ad6-7062-4051-af78-57e62f1707c8",
      "code": "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]",
      "title": "2389. Longest Subsequence With Limited Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8579cc0d-73c2-4349-9438-5a07d07c7cae",
      "code": "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "2390. Removing Stars From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6d18263-6574-416d-9281-de426a70e50c",
      "code": "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')",
      "title": "2391. Minimum Amount of Time to Collect Garbage",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c623aa3-b7ec-48f9-b08e-15438f23c26b",
      "code": "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []",
      "title": "2392. Build a Matrix With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2794a112-dbb2-48df-a069-c6de70d03e38",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans",
      "title": "2393. Count Strictly Increasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2621db-5d37-4478-921d-82864060cd98",
      "code": "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False",
      "title": "2395. Find Subarrays With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94d98a91-30da-4a3e-9cd4-91d7ffc64f32",
      "code": "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False",
      "title": "2396. Strictly Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d1d0be9-d07f-49b9-a54d-1396fb40f65d",
      "code": "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count",
      "title": "2397. Maximum Rows Covered by Columns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7771229-4605-4763-b475-be6911c48885",
      "code": "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j",
      "title": "2398. Maximum Number of Robots Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aafcd0e-940d-420a-b07a-383cad9fb9b4",
      "code": "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True",
      "title": "2399. Check Distances Between Same Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a9c77f-fde5-4a93-b14b-660b5fd43df8",
      "code": "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]",
      "title": "2400. Number of Ways to Reach a Position After Exactly k Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1df40be-c1ea-4eb9-bbe2-6336df659492",
      "code": "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2401. Longest Nice Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "863b0fdd-1a87-4939-9e66-d30e2b804ed5",
      "code": "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))",
      "title": "2402. Meeting Rooms III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85aa3f4d-be61-4515-a6fa-2ace95673422",
      "code": "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]",
      "title": "2403. Minimum Time to Kill All Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed7ebdd-639a-418c-a61c-ea3eb26c58bc",
      "code": "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans",
      "title": "2404. Most Frequent Even Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0244705a-0b45-4aad-9122-ceb9e14484c7",
      "code": "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans",
      "title": "2405. Optimal Partition of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f977e1fe-7233-4a0e-9ad1-eda34cf28c24",
      "code": "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)",
      "title": "2406. Divide Intervals Into Minimum Number of Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dea446ca-7465-4b9f-9593-2e1aab588f0a",
      "code": "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans",
      "title": "2409. Count Days Spent Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bfa7471-986a-4508-8831-d0df27b224a4",
      "code": "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans",
      "title": "2410. Maximum Matching of Players With Trainers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7591326c-4c46-472a-8d17-04d537236359",
      "code": "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans",
      "title": "2411. Smallest Subarrays With Maximum Bitwise OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242f20b5-8716-43c6-b5a0-8f0f73787888",
      "code": "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans",
      "title": "2412. Minimum Money Required Before Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dce6c21-a7fd-4826-9844-5f6defe50a79",
      "code": "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)",
      "title": "2413. Smallest Even Multiple",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8e8c998-b2f7-48b3-8e7e-6588f0031bb6",
      "code": "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans",
      "title": "2414. Length of the Longest Alphabetical Continuous Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de4d0ab5-d7b1-4f9d-a987-4315e4f43aef",
      "code": "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root",
      "title": "2415. Reverse Odd Levels of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81591357-425d-42e5-adf8-2529f2937305",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]",
      "title": "2416. Sum of Prefix Scores of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63c47144-123e-4052-8b76-d356574ad9e0",
      "code": "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0",
      "title": "2417. Closest Fair Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9e1aa39-5bd4-4de5-af84-08b023383848",
      "code": "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]",
      "title": "2418. Sort the People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "013f6f39-8b5e-43da-8049-43562153edb6",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans",
      "title": "2419. Longest Subarray With Maximum Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba789eec-869d-49a2-9350-d252368ba4de",
      "code": "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]",
      "title": "2420. Find All Good Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2eb27d0-e1f7-4cd4-980b-aea8e7e48a2a",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans",
      "title": "2422. Merge Operations to Turn Array Into a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0b68420-5a4a-4ca9-8334-12351b62817e",
      "code": "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False",
      "title": "2423. Remove Letter To Equalize Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96103ba0-2e1e-4dbc-a90e-6a639c5a35bb",
      "code": "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)",
      "title": "2425. Bitwise XOR of All Pairings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6226066-f8d2-4f97-8429-84585af604d2",
      "code": "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))",
      "title": "2427. Number of Common Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6a2d46b-9de8-41ba-827a-994214f65d71",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))",
      "title": "2428. Maximum Sum of an Hourglass",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41461cd7-7cf5-470b-a5b7-a74285fd501e",
      "code": "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans",
      "title": "2429. Minimize XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ec77c73-945b-4021-b8d6-7349cfa629fa",
      "code": "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]",
      "title": "2430. Maximum Deletions on a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1af7fe4d-3ce5-4be2-908a-e16ce38c7b0a",
      "code": "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]",
      "title": "2431. Maximize Total Tastiness of Purchased Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1e758ea-115d-4abf-886f-1c9a4feebe4b",
      "code": "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans",
      "title": "2432. The Employee That Worked on the Longest Task",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5780775f-db7e-409e-902b-0da43a9d704b",
      "code": "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans",
      "title": "2433. Find The Original Array of Prefix Xor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4abe5ef5-4ebf-4129-b69e-4892b2d927e8",
      "code": "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'",
      "title": "2434. Using a Robot to Print the Lexicographically Smallest String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6fdfaee-6129-443d-b262-f9e3613fc8a5",
      "code": "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]",
      "title": "2435. Paths in Matrix Whose Sum Is Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb7b3791-1d77-4025-b260-910cdfe7b708",
      "code": "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans",
      "title": "2436. Minimum Split Into Subarrays With GCD Greater Than One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d11a5256-d9e6-4977-aea1-6657648997ca",
      "code": "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans",
      "title": "2437. Number of Valid Clock Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f4c593d-298e-4f7e-8df0-565bae4f19c1",
      "code": "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    pows = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= pows[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans",
      "title": "2438. Range Product Queries of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50bc70f4-44ee-4bf9-9906-acdce616b14b",
      "code": "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans",
      "title": "2439. Minimize Maximum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3bd9086-fdef-4ee6-abf1-12bcc4b5870a",
      "code": "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0",
      "title": "2440. Create Components With Same Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3753a9b6-439b-403d-9fd4-5edc604d4f66",
      "code": "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans",
      "title": "2441. Largest Positive Integer That Exists With Its Negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a7c7d0f-4dfe-4b95-b504-347b6f56463a",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans",
      "title": "2444. Count Subarrays With Fixed Bounds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e636754a-2016-4ce1-92ff-a3d22b09b3fb",
      "code": "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)",
      "title": "2445. Number of Nodes With Value One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e3cbfea-270d-4825-a998-3f083dde11cf",
      "code": "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans",
      "title": "2447. Number of Subarrays With GCD Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14f6b111-44fe-421f-8dad-a3fa4e49b53f",
      "code": "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans",
      "title": "2448. Minimum Cost to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5f8155e-0c14-4f6a-886c-fbf37889c257",
      "code": "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4",
      "title": "2449. Minimum Number of Operations to Make Arrays Similar",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf4da9c0-d89e-41cf-bbc9-2dfc0988ac3c",
      "code": "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)",
      "title": "2450. Number of Distinct Binary Strings After Applying Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfd5c651-a434-4a1b-b7de-bf193cba9a5d",
      "code": "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word",
      "title": "2451. Odd String Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0318f2e5-d285-434e-9e5c-be5092fdeb95",
      "code": "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]",
      "title": "2452. Words Within Two Edits of Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06c4fb95-f17a-4441-b7e6-69734869a1ce",
      "code": "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)",
      "title": "2453. Destroy Sequential Targets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4353a91-3c72-4df0-9578-2993f3120d67",
      "code": "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans",
      "title": "2454. Next Greater Element IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23e6cc9d-642e-40fa-8904-2ee7ead9eda3",
      "code": "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count",
      "title": "2455. Average Value of Even Numbers That Are Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a11f41d8-463d-476d-bdcd-3513d3f6623e",
      "code": "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans",
      "title": "2456. Most Popular Video Creator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b322563-d921-4a60-aa51-2a8b8a1492da",
      "code": "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans",
      "title": "2457. Minimum Addition to Make Integer Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70eee31e-7df9-4897-a478-72bb0047fa79",
      "code": "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]",
      "title": "2458. Height of Binary Tree After Subtree Removal Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc72e980-7b3f-42b9-b79c-f358d085a135",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))",
      "title": "2459. Sort Array by Moving Items to Empty Space",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb1c357b-8de3-4a7f-ad0a-1f75533b247f",
      "code": "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans",
      "title": "2460. Apply Operations to an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "033120f0-acc2-4d0b-8411-f0e8c2ee29f2",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2461. Maximum Sum of Distinct Subarrays With Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "415d1ea1-dbc8-41a9-be79-b48d75630036",
      "code": "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans",
      "title": "2462. Total Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "daa5e843-6613-41d9-9208-d31f15c7a7fc",
      "code": "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)",
      "title": "2463. Minimum Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24a3317b-cb18-40be-aa52-5380e891e198",
      "code": "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "2464. Minimum Subarrays in a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2df159ce-7028-4c6c-afbd-5a501aa82e74",
      "code": "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)",
      "title": "2465. Number of Distinct Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "526b5af8-8b0d-4d22-a2d0-1a0940d2e134",
      "code": "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans",
      "title": "2466. Count Ways To Build Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fb09c35-dede-4758-9da2-bf0b63165145",
      "code": "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath",
      "title": "2467. Most Profitable Path in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea875a38-d0d3-4fbc-a768-c4ded22f240e",
      "code": "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans",
      "title": "2468. Split Message Based on Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "517e0d13-f3f0-4679-b5c5-c9d02c1002b5",
      "code": "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]",
      "title": "2469. Convert the Temperature",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08dce570-efa2-4808-8c50-5ff77512f8c3",
      "code": "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans",
      "title": "2470. Number of Subarrays With LCM Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "200ae12f-82c2-4042-af67-4ee6d52566bd",
      "code": "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans",
      "title": "2471. Minimum Number of Operations to Sort a Binary Tree by Level",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73469cb8-b7c9-4df6-8b9c-d57a5a8cb75c",
      "code": "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]",
      "title": "2472. Maximum Number of Non-overlapping Palindrome Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9308e08d-e8ea-47c0-8569-f82e048a77ad",
      "code": "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans",
      "title": "2473. Minimum Cost to Buy Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "859bd2ac-3863-418b-ac05-4e115c535778",
      "code": "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans",
      "title": "2475. Number of Unequal Triplets in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31817ed3-d3cc-450e-afc3-ca14fd10014a",
      "code": "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)",
      "title": "2476. Closest Nodes Queries in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f301ab37-504a-4046-8e7c-8368c6655c2b",
      "code": "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans",
      "title": "2477. Minimum Fuel Cost to Report to the Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c96a95b6-e47d-4c2d-a796-eacbc9b2d3ff",
      "code": "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)",
      "title": "2478. Number of Beautiful Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a52f1b9e-ad16-4a0e-a1e0-39ba85577665",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans",
      "title": "2479. Maximum XOR of Two Non-Overlapping Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "461e420b-ee44-4e53-b0e6-002610d38fb0",
      "code": "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n",
      "title": "2481. Minimum Cuts to Divide a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1add7454-5089-4a5c-8149-c115f5e80899",
      "code": "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans",
      "title": "2482. Difference Between Ones and Zeros in Row and Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3f66beb-8a0e-4370-a97f-c4b883b4b49f",
      "code": "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans",
      "title": "2483. Minimum Penalty for a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ad3b338-5ad4-4f7b-9abf-928aafce8823",
      "code": "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans",
      "title": "2484. Count Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dc65da8-1889-4f3e-a14e-1b0be7b19b12",
      "code": "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1",
      "title": "2485. Find the Pivot Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af4242f8-f9b7-4d69-a926-719671c2913e",
      "code": "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i",
      "title": "2486. Append Characters to String to Make Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af463598-4406-468a-b973-0b8d1c4a313b",
      "code": "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head",
      "title": "2487. Remove Nodes From Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32ed3eab-b59e-4576-9d33-5e7ef42e1928",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans",
      "title": "2488. Count Subarrays With Median K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b014f8f-c1c8-42b4-9599-3f5bc63f3bc1",
      "code": "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2489. Number of Substrings With Fixed Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "accf6084-9044-4c7f-a5f5-49f04e78b2ef",
      "code": "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]",
      "title": "2490. Circular Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "007f4c21-515f-4cc8-8a64-beea0c668caf",
      "code": "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2",
      "title": "2491. Divide Players Into Teams of Equal Skill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e7ac95b-753d-43a6-bea4-bfc85be64787",
      "code": "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans",
      "title": "2492. Minimum Score of a Path Between Two Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77917813-afb6-4532-9b48-4f46ac141db4",
      "code": "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans",
      "title": "2495. Number of Subarrays Having Even Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca8ccced-941d-4d79-b8c5-192a3cc1edb9",
      "code": "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)",
      "title": "2496. Maximum Value of a String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7608733d-4a54-45fb-9184-8e0ff99b7c3d",
      "code": "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans",
      "title": "2497. Maximum Star Sum of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf656cc5-0126-4a50-8d39-c964c9b201b4",
      "code": "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))",
      "title": "2498. Frog Jump II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "160ac91e-b3f8-42e9-84a0-d2868ab10901",
      "code": "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans",
      "title": "2499. Minimum Total Cost to Make Arrays Unequal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ca30350-1935-47e2-a146-a328d8a9466b",
      "code": "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))",
      "title": "2500. Delete Greatest Value in Each Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58fff320-4c29-4d1a-9ef8-36b841a1853a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans",
      "title": "2503. Maximum Number of Points From Grid Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dae7fb6-f143-4988-bfec-26dd7149a1eb",
      "code": "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans",
      "title": "2505. Bitwise OR of All Subsequence Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3280af68-2f9a-4da7-b231-6090ccb66a9c",
      "code": "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    masks = [self._getMask(word) for word in words]\n    return sum(masks[i] == masks[j]\n               for i, j in itertools.combinations(range(len(masks)), 2))\n\n  def _getMask(self, word: str) -> int:\n    mask = 0\n    for c in word:\n      mask |= 1 << ord(c) - ord('a')\n    return mask",
      "title": "2506. Count Pairs Of Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "724ab0c4-f435-4a89-ac36-ad3671ef2e4e",
      "code": "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n",
      "title": "2507. Smallest Value After Replacing With Sum of Prime Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a6555dc-51a3-4927-8c6f-71f5f7625325",
      "code": "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False",
      "title": "2508. Add Edges to Make Degrees of All Nodes Even",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e95e7b89-5f32-45c8-8d40-2ac0d84377da",
      "code": "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]",
      "title": "2509. Cycle Length Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef69b046-2017-4489-931d-b253bfc21bc4",
      "code": "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)",
      "title": "2510. Check if There is a Path With Equal Number of 0's And 1's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "224ca25c-b9a1-439d-932d-d82c13f70fdf",
      "code": "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans",
      "title": "2511. Maximum Enemy Forts That Can Be Captured",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d97732c6-8841-46b0-9269-70bf515c8895",
      "code": "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]",
      "title": "2512. Reward Top K Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "760f6cc8-746b-4cbb-9209-cc72a3c7d1a6",
      "code": "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2513. Minimize the Maximum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16c8282-41ad-4b67-875f-3c1681601342",
      "code": "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007",
      "title": "2514. Count Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f40f682-a353-4432-b665-c626ca5c6099",
      "code": "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1",
      "title": "2515. Shortest Distance to Target String in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cb70ac5-d854-4eae-9233-708b2c7a5949",
      "code": "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans",
      "title": "2516. Take K of Each Character From Left and Right",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90a83e00-093d-41c6-8a3d-6dd305308777",
      "code": "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1",
      "title": "2517. Maximum Tastiness of Candy Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "238adf1a-22b0-4b58-8f3f-6361a28bac1c",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD",
      "title": "2518. Number of Great Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af17142e-a7c6-47ef-9451-47db03a4bc32",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))",
      "title": "2519. Count the Number of K-Big Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e0cb19c-6280-4557-b425-97227f5358a9",
      "code": "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))",
      "title": "2520. Count the Digits That Divide a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bafc8258-7c2c-4af6-9643-d2b21924c6f8",
      "code": "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor",
      "title": "2521. Distinct Prime Factors of Product of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67ddd2ce-15c0-4815-ae65-f07a83618f77",
      "code": "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans",
      "title": "2522. Partition String Into Substrings With Values at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9598c996-c62c-4e8b-b8cc-2edfee5dad38",
      "code": "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2523. Closest Prime Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62677172-6831-4ca8-843c-599fa8b8fe71",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ",
      "title": "2524. Maximum Frequency Score of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9ff1af1-d1f9-4e15-bf8d-132513018e3a",
      "code": "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'",
      "title": "2525. Categorize Box According to Criteria",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1db4000-064f-40fb-afd1-89cd6c7900e2",
      "code": "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)",
      "title": "2527. Find Xor-Beauty of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19586206-b4ed-4408-94cd-499405ec1756",
      "code": "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1",
      "title": "2528. Maximize the Minimum Powered City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59e5e5de-1d4e-408b-afb8-ec8a5b315a9c",
      "code": "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))",
      "title": "2529. Maximum Count of Positive Integer and Negative Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb1ec879-f954-47ca-83a8-92bbc70cd8da",
      "code": "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans",
      "title": "2530. Maximal Score After Applying K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a09eba82-c2b5-457e-a671-e01106c86e7f",
      "code": "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False",
      "title": "2531. Make Number of Distinct Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddba687b-ce29-427c-8e48-fec14dd25fa1",
      "code": "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans",
      "title": "2532. Time to Cross a Bridge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3093d5a3-3649-4f8a-a3db-6d811861c236",
      "code": "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD",
      "title": "2533. Number of Good Binary Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91f26f02-1c59-4fdb-a500-06f65b182afd",
      "code": "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2535. Difference Between Element Sum and Digit Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3c486f1-bcf6-4ea4-98fc-17062d2a50e1",
      "code": "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans",
      "title": "2538. Difference Between Maximum and Minimum Price Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3478eee7-be05-4337-a049-4976c60d9488",
      "code": "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans",
      "title": "2539. Count the Number of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0986b402-3f07-41a2-9f09-0fd195cb2256",
      "code": "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1",
      "title": "2540. Minimum Common Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79092716-646d-4381-a8f2-d8c44bbeca12",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1",
      "title": "2541. Minimum Operations to Make Array Equal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65a3e469-6496-4747-9ad8-e7b6833f37e2",
      "code": "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans",
      "title": "2542. Maximum Subsequence Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5681b3e2-12c7-4c08-819e-006767dca27b",
      "code": "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1",
      "title": "2543. Check if Point Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62a8fe24-d551-46c7-9dd7-23ef306a5e65",
      "code": "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans",
      "title": "2544. Alternating Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e4eb243-a2d1-4fec-a358-d26fa9d7ef52",
      "code": "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])",
      "title": "2545. Sort the Students by Their Kth Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "377e0fbf-544e-4afc-8dcf-adaeafaff8c9",
      "code": "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)",
      "title": "2546. Apply Bitwise Operations to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0034da1b-fbd2-45cd-8fbc-734816fde4ea",
      "code": "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]",
      "title": "2547. Minimum Cost to Split an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df519068-1fee-4ba3-ad26-13f92d2c0aa9",
      "code": "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1",
      "title": "2548. Maximum Price to Fill a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed7ec47e-3789-42b7-9f30-397a4defe51c",
      "code": "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)",
      "title": "2549. Count Distinct Numbers on Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5426fcb-ba81-4603-bb5c-d161656346a5",
      "code": "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res",
      "title": "2550. Count Collisions of Monkeys on a Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0859b5fc-35e4-4c10-a0e6-2d22eb071145",
      "code": "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))",
      "title": "2551. Put Marbles in Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "801d2205-8a33-46bb-a436-7379adee147b",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans",
      "title": "2552. Count Increasing Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98d9b017-ce15-4d36-9285-bda8919f1eeb",
      "code": "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]",
      "title": "2553. Separate the Digits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42a12f08-1bd2-4a1e-a267-e7db81cab0f9",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans",
      "title": "2554. Maximum Number of Integers to Choose From a Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d52e3271-8e82-43cd-9520-898891666976",
      "code": "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans",
      "title": "2555. Maximize Win From Two Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a3199ae-4e72-41ab-bf66-3d33fe6b0679",
      "code": "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)",
      "title": "2556. Disconnect Path in a Binary Matrix by at Most One Flip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d497f0c-224a-4561-9c87-bdc9de9fc60a",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)",
      "title": "2557. Maximum Number of Integers to Choose From a Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "166895f8-ecd4-459b-afff-71616c724f27",
      "code": "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)",
      "title": "2558. Take Gifts From the Richest Pile",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b02247b4-49a0-46e1-86cc-761b30258fb4",
      "code": "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]",
      "title": "2559. Count Vowel Strings in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdf1822c-7706-446e-aec3-6729622acbb2",
      "code": "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)",
      "title": "2560. House Robber IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9a24900-8fa7-42ba-ac06-f34dd2250e66",
      "code": "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])",
      "title": "2561. Rearranging Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dfea7b0-dc60-4a33-b67a-bda984097e2b",
      "code": "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)",
      "title": "2563. Count the Number of Fair Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e805428-0c59-4156-ba9a-07807c1dc525",
      "code": "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]",
      "title": "2564. Substring XOR Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf2afb20-49c3-442c-9e64-629b213f4eed",
      "code": "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans",
      "title": "2565. Subsequence With the Minimum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52319e56-304d-4d74-96dc-e3b2bcf205b8",
      "code": "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0",
      "title": "2566. Maximum Difference by Remapping a Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13cf6c57-9b91-43e7-986b-39899a85d9ea",
      "code": "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)",
      "title": "2567. Minimum Score by Changing Two Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b200bc3c-f156-4e0c-b69c-761271e74d0b",
      "code": "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans",
      "title": "2568. Minimum Impossible OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48e6cac6-6f22-4426-9e6e-7aeaacce9252",
      "code": "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val",
      "title": "2570. Merge Two 2D Arrays by Summing Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa84bfbc-1faa-44f8-b738-f61c849a15dd",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans",
      "title": "2571. Minimum Operations to Reduce an Integer to 0",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddbc68d6-ec0c-483d-9fce-f0dd774e2ea9",
      "code": "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD",
      "title": "2572. Count the Number of Square-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6f2f844-1f34-4802-a4b1-22bea3245781",
      "code": "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]",
      "title": "2574. Left and Right Sum Differences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cf28a3d-23c2-4b45-9159-55d8b70c3ac3",
      "code": "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans",
      "title": "2575. Find the Divisibility Array of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79587266-726c-404e-91e3-36c76eb7756f",
      "code": "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2",
      "title": "2576. Find the Maximum Number of Marked Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}