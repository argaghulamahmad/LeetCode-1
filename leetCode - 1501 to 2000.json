{
  "snippets": [
    {
      "id": "5796cc41-acb2-42b2-8d2a-67758cb7144d",
      "code": "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans",
      "title": "1996. The Number of Weak Characters in the Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "493d5463-efd0-4a4e-a1e3-8fd1c77d641a",
      "code": "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]",
      "title": "1997. First Day Where You Have Been in All the Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76ed68a8-9bd2-44d3-90c4-178dd3625567",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "1998. GCD Sort of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3f5550c-4666-4cb4-b082-c4dd37833085",
      "code": "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1",
      "title": "1999. Smallest Greater Multiple Made of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "815966d8-d6e8-4e14-ae00-4545c583feac",
      "code": "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]",
      "title": "2000. Reverse Prefix of Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c74cec82-711f-40b9-a2e0-74254e592e23",
      "code": "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())",
      "title": "2001. Number of Pairs of Interchangeable Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80eae896-1e00-48b8-b25e-accfbbb002cb",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans",
      "title": "2002. Maximum Product of the Length of Two Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2915cefa-cce2-450b-98ae-999312395fcc",
      "code": "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans",
      "title": "2003. Smallest Missing Genetic Value in Each Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "094df04b-3ac4-4d6b-8234-37b31971e03f",
      "code": "class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1",
      "title": "2005. Subtree Removal Game with Fibonacci Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62f4f9b9-8a0c-4c26-9024-b202dfeb2b06",
      "code": "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))",
      "title": "2006. Count Number of Pairs With Absolute Difference K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ffc807e-482b-47b8-93f8-c5758a5f4ea9",
      "code": "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans",
      "title": "2007. Find Original Array From Doubled Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad74390b-4afc-4392-996f-2df9f20e8c73",
      "code": "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]",
      "title": "2008. Maximum Earnings From Taxi",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "543a7c3e-dd45-4dfe-b58d-944c5121f4d2",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans",
      "title": "2009. Minimum Number of Operations to Make Array Continuous",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9489801-b8f9-4120-82cb-e48120ab4db3",
      "code": "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)",
      "title": "2011. Final Value of Variable After Performing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82381b5a-9b44-446a-868c-6e9a838a63f1",
      "code": "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans",
      "title": "2012. Sum of Beauty in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9623ee6-61b8-43a3-b4f1-ccaf886a9310",
      "code": "class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans",
      "title": "2014. Longest Subsequence Repeated k Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a0c25d3-0e9f-453f-a776-3733d0e5f7c4",
      "code": "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans",
      "title": "2015. Average Height of Buildings in Each Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0684de73-01d7-4270-bc16-108726f47814",
      "code": "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans",
      "title": "2016. Maximum Difference Between Increasing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb462ce9-421c-4597-98e2-d8d7b760961e",
      "code": "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans",
      "title": "2017. Grid Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c2885c3-adb6-457e-8738-b25452076dd7",
      "code": "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False",
      "title": "2018. Check if Word Can Be Placed In Crossword",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcc058ad-2867-4063-9b41-f9d2bde7a3ea",
      "code": "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans",
      "title": "2019. The Score of Students Solving Math Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2f93bab-6f2e-4c67-9047-dfb59eef2d77",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans",
      "title": "2021. Brightest Position on Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26c31581-8263-4d18-b53b-564d0630bb14",
      "code": "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans",
      "title": "2022. Convert 1D Array Into 2D Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00fb75c1-406b-464c-b980-1e808283b9c6",
      "code": "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans",
      "title": "2023. Number of Pairs of Strings With Concatenation Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21cf459a-26cb-44af-8ca9-c09d91a26c5c",
      "code": "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2024. Maximize the Confusion of an Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5383cd37-d58f-4ca8-b822-552ada65854e",
      "code": "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans",
      "title": "2025. Maximum Number of Ways to Partition an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "466de4b7-fdbf-4c1f-90e3-7379d9e6aef1",
      "code": "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans",
      "title": "2027. Minimum Moves to Convert String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21b6fae5-a2e0-4baf-8e26-762d84824715",
      "code": "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans",
      "title": "2028. Find Missing Observations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5946747e-4a31-4fbd-8387-4e64a431361a",
      "code": "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2",
      "title": "2029. Stone Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31b27d17-80f7-4de9-b044-75e1ffe5c095",
      "code": "class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)",
      "title": "2030. Smallest K-Length Subsequence With Occurrences of a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f996447d-3d1a-4e16-b42b-0d4b9ba20dbc",
      "code": "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans",
      "title": "2031. Count Subarrays With More Ones Than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b332277-24ec-4085-98d9-904bb4a2656b",
      "code": "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]",
      "title": "2032. Two Out of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "567b42c7-7fbf-425f-91c4-2976f180c248",
      "code": "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans",
      "title": "2033. Minimum Operations to Make a Uni-Value Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b45aa6b-9280-4389-99f1-2f09a421250a",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans",
      "title": "2035. Partition Array Into Two Arrays to Minimize Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad15f841-8e4e-47a9-b14a-8ce3d38af6af",
      "code": "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans",
      "title": "2036. Maximum Alternating Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42179e53-f6e7-4510-a689-8587b6c42a24",
      "code": "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))",
      "title": "2037. Minimum Number of Moves to Seat Everyone",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de6decc9-9754-477c-ba91-005fff76311b",
      "code": "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB",
      "title": "2038. Remove Colored Pieces if Both Neighbors are the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1507394d-21b1-4b36-bb15-f2aee8910c6c",
      "code": "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1",
      "title": "2039. The Time When the Network Becomes Idle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e39d8c88-6bb7-42ef-9a97-08e28e4a7014",
      "code": "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l",
      "title": "2040. Kth Smallest Product of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18d14ba3-4857-488d-a756-318e4a1a91f8",
      "code": "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True",
      "title": "2042. Check if Numbers Are Ascending in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "523b1242-1b58-4758-ade2-62ae8ff556bb",
      "code": "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans",
      "title": "2044. Count Number of Maximum Bitwise-OR Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e8677f3-14d1-4764-b8ba-e398e17b57d3",
      "code": "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))",
      "title": "2045. Second Minimum Time to Reach Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4139992c-bada-446c-a568-4827f0f88d15",
      "code": "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head",
      "title": "2046. Sort Linked List Already Sorted Using Absolute Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "532815a0-b8f3-44de-bbee-475ddfc0b402",
      "code": "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())",
      "title": "2047. Number of Valid Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2baf993-7c7d-4d00-b162-e16fe6c0e0a7",
      "code": "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n",
      "title": "2048. Next Greater Numerically Balanced Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2a79d34-d7f4-4ecd-af65-35cf9d88dc16",
      "code": "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans",
      "title": "2049. Count Nodes With the Highest Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c45171c9-2c29-45b8-bdd1-49c12f17e18b",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)",
      "title": "2050. Parallel Courses III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20b53e12-d9fe-4f92-a86e-93d75a6a7e32",
      "code": "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])",
      "title": "2052. Minimum Cost to Separate Sentence Into Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a6f7bb6-10b2-4772-a251-6961189ce77c",
      "code": "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''",
      "title": "2053. Kth Distinct String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1bb6d7a-1483-40cb-b044-2d6b672242d4",
      "code": "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans",
      "title": "2054. Two Best Non-Overlapping Events",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1878cffd-bd4d-4a4a-a6fc-48d06879d1ce",
      "code": "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans",
      "title": "2055. Plates Between Candles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b7fe3e5-aba2-4b25-a353-ace264207771",
      "code": "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)",
      "title": "2056. Number of Valid Move Combinations On Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71ca1f00-61a3-4532-ba72-3c462125b8b7",
      "code": "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)",
      "title": "2057. Smallest Index With Equal Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5042b8b6-0cab-4314-a757-8fb1559d909c",
      "code": "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]",
      "title": "2058. Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b81c4beb-1a41-4c8f-9ce5-4a7cec9fab72",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1",
      "title": "2059. Minimum Operations to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a6e291f-19fe-41a1-85af-c81625b902d9",
      "code": "class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)",
      "title": "2060. Check if an Original String Exists Given Two Encoded Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a6ebcc6-29c7-41f3-a33e-d4112befc71c",
      "code": "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))",
      "title": "2061. Number of Spaces Cleaning Robot Cleaned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecaf5887-0e65-4d8d-a50b-5fd2ebb12f59",
      "code": "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)",
      "title": "2062. Count Vowel Substrings of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a9898ce-e7d0-4d32-aada-50f6e1dc183d",
      "code": "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)",
      "title": "2063. Vowels of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d139a3d2-cd49-4cdf-b555-9dbfbf17f2df",
      "code": "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2064. Minimized Maximum of Products Distributed to Any Store",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2be4341-4b93-4412-bef6-9a3468c34d57",
      "code": "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans",
      "title": "2065. Maximum Path Quality of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc57813c-b18b-4463-b86e-6ab6274c5b78",
      "code": "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans",
      "title": "2067. Number of Equal Count Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b25ac03-4425-4372-a22f-bb3f47a47d4d",
      "code": "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())",
      "title": "2068. Check Whether Two Strings are Almost Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3c57343-9e21-4614-81eb-3a0bbe9ba9be",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]",
      "title": "2070. Most Beautiful Item for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4421ef0b-0163-425b-b8f2-a10aa21885ba",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "2071. Maximum Number of Tasks You Can Assign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ffa43b6-0ad0-47d3-9ef3-945aab150cb1",
      "code": "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans",
      "title": "2073. Time Needed to Buy Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bab1d20-cc8d-4f99-b2c8-bd28562ecd94",
      "code": "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next",
      "title": "2074. Reverse Nodes in Even Length Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c4021d7-72d2-4c6c-b6a5-81ae06b6e631",
      "code": "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()",
      "title": "2075. Decode the Slanted Ciphertext",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22980ced-edfd-4490-b61a-34da85843874",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans",
      "title": "2076. Process Restricted Friend Requests",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0896839e-c4e0-4cdb-9eb5-a0bb4d1802bc",
      "code": "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3",
      "title": "2077. Paths in Maze That Lead to Same Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fffe324e-b837-43ba-87d3-f35309fe5821",
      "code": "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)",
      "title": "2078. Two Furthest Houses With Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6c2e9a8-d775-4125-bfe2-ea40621c89cd",
      "code": "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)",
      "title": "2079. Watering Plants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "644e1fde-6086-4f7f-995a-0ad96a6a18e0",
      "code": "class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans",
      "title": "2081. Sum of k-Mirror Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cb520e2-8518-43fd-b091-5aa7f03d7887",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans",
      "title": "2083. Substrings That Begin and End With the Same Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d05fd8d-cc99-4109-8f18-fed1abb730fd",
      "code": "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())",
      "title": "2085. Count Common Words With One Occurrence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44e65b12-7a86-4f9a-b1b0-d025b396b744",
      "code": "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')",
      "title": "2086. Minimum Number of Buckets Required to Collect Rainwater from Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f668e32-8af5-4852-80e2-40e3778798f1",
      "code": "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans",
      "title": "2087. Minimum Cost Homecoming of a Robot in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2f76c56-d8a4-4768-8f0a-5d27b29aec71",
      "code": "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)",
      "title": "2088. Count Fertile Pyramids in a Land",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc9ae33d-29dd-45f2-b6a8-9717e75f7bad",
      "code": "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]",
      "title": "2089. Find Target Indices After Sorting Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40603669-76ec-43f3-a156-e685eb2ffc7c",
      "code": "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans",
      "title": "2090. K Radius Subarray Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7edd2c4d-9ded-491b-85a7-920596c19204",
      "code": "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)",
      "title": "2091. Removing Minimum and Maximum From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed0fcf4e-9fd4-4c5e-85e7-ba7280efce02",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]",
      "title": "2092. Find All People With Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94ab7b08-c3ac-482c-a746-b5fd6304190d",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1",
      "title": "2093. Minimum Cost to Reach City With Discounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa40d604-5d9a-4617-ab00-39d52303a729",
      "code": "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans",
      "title": "2094. Finding 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "147b07cd-d577-4488-8baf-d3e6f8a48997",
      "code": "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next",
      "title": "2095. Delete the Middle Node of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9816dd4-5d29-4151-956c-80a3d30aaf1f",
      "code": "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99c2fc65-6fd2-4fe0-86af-c56e3a79a86b",
      "code": "class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]",
      "title": "2097. Valid Arrangement of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7980170-52f5-49e4-9c90-61d3d93bfff2",
      "code": "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans",
      "title": "2098. Subsequence of Size K With the Largest Even Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afcee1bb-b9c5-4b7d-8f2b-dee15dcb4ac0",
      "code": "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans",
      "title": "2099. Find Subsequence of Length K With the Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc683f5f-fbe3-4b33-8631-1bd0dcc35d2c",
      "code": "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]",
      "title": "2100. Find Good Days to Rob the Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4625382-100e-4f47-b5a3-0b078d84f50a",
      "code": "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans",
      "title": "2101. Detonate the Maximum Bombs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27743bc1-2cf6-4040-a32d-cb941dbe20f1",
      "code": "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)",
      "title": "2103. Rings and Rods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1341ad2b-ae73-43c1-9242-fea3d42346d8",
      "code": "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "2104. Sum of Subarray Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c22cd3a-edc9-4719-acd0-95a2392fdbca",
      "code": "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])",
      "title": "2105. Watering Plants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd455fed-abff-4cf8-87c9-fa361e23546e",
      "code": "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans",
      "title": "2106. Maximum Fruits Harvested After at Most K Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cb1fd2c-a9ba-4c20-8d20-7fa73c6107c0",
      "code": "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans",
      "title": "2107. Number of Unique Flavors After Sharing K Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "034aa88b-44d6-4877-96a1-1967d7f679a1",
      "code": "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')",
      "title": "2108. Find First Palindromic String in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd3ba321-048b-4888-8731-7b317ff615d1",
      "code": "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)",
      "title": "2109. Adding Spaces to a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f07d999d-9a43-4b5c-b532-4c8d8dd1339f",
      "code": "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans",
      "title": "2110. Number of Smooth Descent Periods of a Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad26e131-5a25-4853-9634-4bc9be480ccd",
      "code": "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))",
      "title": "2111. Minimum Operations to Make the Array K-Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6e7ad23-2177-4d01-be9b-151d9aacac69",
      "code": "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]",
      "title": "2113. Elements in Array After Removing and Replacing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0734438-da90-4fcb-bc6d-17e8a846fa6b",
      "code": "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1",
      "title": "2114. Maximum Number of Words Found in Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "809e22e5-d20c-476d-80be-db1a97c25a69",
      "code": "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans",
      "title": "2115. Find All Possible Recipes from Given Supplies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26e77e27-b708-4357-b542-ed063d4b89be",
      "code": "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)",
      "title": "2116. Check if a Parentheses String Can Be Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c553a3b6-bc0b-4a0d-8d99-0c81a9ded146",
      "code": "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)",
      "title": "2117. Abbreviating the Product of a Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8020d2f-dfc8-47f7-9777-9f88c9f79423",
      "code": "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num",
      "title": "2119. A Number After a Double Reversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a862182-0c57-489d-bc76-ff5cda05eef5",
      "code": "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans",
      "title": "2120. Execution of All Suffix Instructions Staying in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "344fcbdc-28af-451d-8a41-93e3617d80d4",
      "code": "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]",
      "title": "2121. Intervals Between Identical Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b559e12-de1a-4af5-84e1-996786224962",
      "code": "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr",
      "title": "2122. Recover the Original Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "482e8cb0-dacf-4185-8faf-6f4b8bd3cc7b",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans",
      "title": "2123. Minimum Operations to Remove Adjacent Ones in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8c2d8a4-1dc5-4816-9a7a-d019f7412291",
      "code": "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s",
      "title": "2124. Check if All A's Appears Before All B's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50f284d5-c955-4c20-879d-4c850b27b095",
      "code": "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans",
      "title": "2125. Number of Laser Beams in a Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aea0bf24-3765-41c3-931f-4800300f736f",
      "code": "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True",
      "title": "2126. Destroying Asteroids",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b651188e-b9bc-42b0-ac6f-e7a475e36f11",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)",
      "title": "2127. Maximum Employees to Be Invited to a Meeting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f7a8649-25ad-4c6b-aa57-bdb590a1bfb1",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)",
      "title": "2128. Remove All Ones With Row and Column Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac40e575-70d1-453d-8865-f25fded9efc3",
      "code": "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())",
      "title": "2129. Capitalize the Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5b8ddfd-dc3e-45c1-ab2c-b355a4ffd50e",
      "code": "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans",
      "title": "2130. Maximum Twin Sum of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dec8e0eb-a21b-4509-8212-c678ff1e5474",
      "code": "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans",
      "title": "2131. Longest Palindrome by Concatenating Two Letter Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d280e1d9-573b-473e-a189-9c6e2047b8ab",
      "code": "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True",
      "title": "2132. Stamping the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87c1fd7c-738d-4811-8cd9-c2a546c10357",
      "code": "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))",
      "title": "2133. Check if Every Row and Column Contains All Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95847fec-a892-42fd-8b19-fc88008a8dea",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "2134. Minimum Swaps to Group All 1's Together II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c7169a5-fecb-4d14-93a4-bb6d547dcb30",
      "code": "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans",
      "title": "2135. Count Words Obtained After Adding a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a183793-422d-4b26-9b88-85d535085c34",
      "code": "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans",
      "title": "2136. Earliest Possible Day of Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04ab8317-2733-482d-a8fe-4265474ce698",
      "code": "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "2137. Pour Water Between Buckets to Make Water Levels Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1f69ee7-8942-4e99-8158-5528ed77dd99",
      "code": "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]",
      "title": "2138. Divide a String Into Groups of Size k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b26c22ec-f427-4954-b611-d0113ff37d7b",
      "code": "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1",
      "title": "2139. Minimum Moves to Reach Target Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "301ccbf3-c03d-4f70-ace9-9f3f5a9c0014",
      "code": "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]",
      "title": "2140. Solving Questions With Brainpower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10194e18-141d-47f1-95e3-7001fab57ce2",
      "code": "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n",
      "title": "2141. Maximum Running Time of N Computers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53bc87ca-061d-4d99-a427-d1bcc20c3d35",
      "code": "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans",
      "title": "2143. Choose Numbers From Two Arrays in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d0a842-a490-451c-8c08-e6397f80d6f6",
      "code": "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])",
      "title": "2144. Minimum Cost of Buying Candies With Discount",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e9a7c05-d93c-4d24-b5c0-2e077341146b",
      "code": "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)",
      "title": "2145. Count the Hidden Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13d70d5d-cbb3-41dc-bd2e-0a48d0ea02d4",
      "code": "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans",
      "title": "2146. K Highest Ranked Items Within a Price Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "441e4fa1-2235-4788-bd49-58f52c58b3a1",
      "code": "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0",
      "title": "2147. Number of Ways to Divide a Long Corridor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9a936db-13cf-41a6-8048-8839330d6605",
      "code": "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)",
      "title": "2148. Count Elements With Strictly Smaller and Greater Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f561bd90-df20-4983-ab4c-b67ac97b764b",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans",
      "title": "2149. Rearrange Array Elements by Sign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77d159a1-cbb1-4495-a0c0-15f53aee6cfd",
      "code": "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]",
      "title": "2150. Find All Lonely Numbers in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff570ecf-f174-468a-aa83-f05a99c96e0e",
      "code": "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans",
      "title": "2151. Maximum Good People Based on Statements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ca8a245-ed58-4953-8965-1b654cd2af31",
      "code": "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)",
      "title": "2152. Minimum Number of Lines to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59d67330-7b61-463c-b7cb-5b91a4553cf1",
      "code": "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original",
      "title": "2154. Keep Multiplying Found Values by Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "586a5c64-ae94-477e-ba08-cc32b3f3c38a",
      "code": "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans",
      "title": "2155. All Divisions With the Highest Score of a Binary Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f862a75-038f-4f8e-a9fc-80198f69b343",
      "code": "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]",
      "title": "2156. Find Substring With Given Hash Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1330a053-adbc-49b4-aa00-5413249487dc",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]",
      "title": "2157. Groups of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dfe44ac-ac5a-437f-ba66-c4e1769ae363",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans",
      "title": "2158. Amount of New Area Painted Each Day",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c12cdf2f-b7d3-465e-ae75-6e69a073711a",
      "code": "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])",
      "title": "2160. Minimum Sum of Four Digit Number After Splitting Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b095d1f-550b-49f1-b7e4-f7c705da5847",
      "code": "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])",
      "title": "2161. Partition Array According to Given Pivot",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0fb89c5-9564-4526-99ba-3fcd57ab80d2",
      "code": "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans",
      "title": "2162. Minimum Cost to Set Cooking Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87a50f7e-f989-419d-b2e5-db00b9da7599",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans",
      "title": "2163. Minimum Difference in Sums After Removal of Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6183fcc8-662b-4627-8840-90cfe84a9ad9",
      "code": "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans",
      "title": "2164. Sort Even and Odd Indices Independently",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f73952b9-1efe-4c5d-943b-959788400e0a",
      "code": "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)",
      "title": "2165. Smallest Value of the Rearranged Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df587514-3e83-44fb-b808-a6a495da6457",
      "code": "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)",
      "title": "2167. Minimum Time to Remove All Cars Containing Illegal Goods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "133ca239-b43a-4bb6-9637-09fbf3027340",
      "code": "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())",
      "title": "2168. Unique Substrings With Equal Digit Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c2cf75-9883-4a6d-af55-c68393dd09eb",
      "code": "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans",
      "title": "2169. Count Operations to Obtain Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7110bc41-8928-409f-b6e7-ab5cd17c2ddc",
      "code": "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)",
      "title": "2170. Minimum Operations to Make the Array Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1552eb8e-0e75-42df-b513-14268a2a0a20",
      "code": "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))",
      "title": "2171. Removing Minimum Number of Magic Beans",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c8492ac-7e78-4984-bb72-5c4332a8e139",
      "code": "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]",
      "title": "2172. Maximum AND Sum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e481a64a-5394-4a83-b151-fba02c991ec6",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            newMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              newMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              newMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(newMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded",
      "title": "2174. Remove All Ones With Row and Column Flips II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c8db93b-dec3-48d1-8d47-5b6d743f9c75",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans",
      "title": "2176. Count Equal and Divisible Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cdabf98-2d32-4ee8-9c57-02bd96715a01",
      "code": "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]",
      "title": "2177. Find Three Consecutive Integers That Sum to a Given Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14a41e02-56b3-4419-ab72-9cf50a0c53f5",
      "code": "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]",
      "title": "2178. Maximum Split of Positive Even Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e87b1d26-09f2-4157-a4b7-4b25455cbb43",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))",
      "title": "2179. Count Good Triplets in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5e60faa-226a-459e-8630-b79349d1cbd9",
      "code": "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2180. Count Integers With Even Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d182087d-9159-41c8-9bd2-7eac136e3f2e",
      "code": "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next",
      "title": "2181. Merge Nodes in Between Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f52aa4dc-c500-4c22-afeb-4771f640fb78",
      "code": "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '",
      "title": "2182. Construct String With Repeat Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55951be9-69bf-4fff-9914-6b8d2c5421a2",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans",
      "title": "2183. Count Array Pairs Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dd4d22d-0774-4989-b77a-83a2b6f60dfe",
      "code": "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)",
      "title": "2184. Number of Ways to Build Sturdy Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed781eef-958f-4231-bdf1-71bbefa71020",
      "code": "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)",
      "title": "2185. Counting Words With a Given Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f341363-b6f6-447b-a686-514c65b9c8fe",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])",
      "title": "2186. Minimum Number of Steps to Make Two Strings Anagram II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8785d960-7abb-43e3-8471-6ea00ccc9539",
      "code": "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2187. Minimum Time to Complete Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "022246ca-5138-4a31-99a9-2deb5ef2e552",
      "code": "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime",
      "title": "2188. Minimum Time to Finish the Race",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00d516ae-5ea4-429e-b905-ca46cfee91de",
      "code": "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]",
      "title": "2189. Number of Ways to Build House of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ff93736-9212-45ad-897a-17373619937e",
      "code": "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])",
      "title": "2190. Most Frequent Number Following Key In an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1db132b1-6751-4104-a1b9-ce08ffbfd6e8",
      "code": "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]",
      "title": "2191. Sort the Jumbled Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10a25ec5-5208-402b-a4db-c18eb0a88429",
      "code": "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]",
      "title": "2192. All Ancestors of a Node in a Directed Acyclic Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4a74776-2ac8-4f12-ab22-b578cdd125b3",
      "code": "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans",
      "title": "2193. Minimum Number of Moves to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "debaa4d4-c087-4075-89cc-b1b9c9580166",
      "code": "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans",
      "title": "2194. Cells in a Range on an Excel Sheet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f37d4cdf-3225-4f35-a8d1-9b3671372e58",
      "code": "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans",
      "title": "2195. Append K Integers With Minimal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05573411-c989-474e-a0ef-ab731e782f67",
      "code": "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]",
      "title": "2196. Create Binary Tree From Descriptions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0860bbe7-6529-40c7-8a7c-934e36111245",
      "code": "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans",
      "title": "2197. Replace Non-Coprime Numbers in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f7e8010-9ee5-4adb-9894-935a0fb7e035",
      "code": "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6",
      "title": "2198. Number of Single Divisor Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85d6af90-da4e-424e-9e5a-1ef6860847cd",
      "code": "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans",
      "title": "2200. Find All K-Distant Indices in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5414bb7-4abb-41b1-9902-947b1412a9c2",
      "code": "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)",
      "title": "2201. Count Artifacts That Can Be Extracted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99c8661d-8179-4a24-a0ce-2ddbe5b7766f",
      "code": "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])",
      "title": "2202. Maximize the Topmost Element After K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9430f57-6d85-4afc-923b-df4355601e6e",
      "code": "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2203. Minimum Weighted Subgraph With the Required Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a3c7073-257d-48b8-94ed-61a8ee809dfe",
      "code": "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans",
      "title": "2204. Distance to a Cycle in Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c31e30be-7354-4618-8a25-f4f7979d9aad",
      "code": "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())",
      "title": "2206. Divide Array Into Equal Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45553c45-cca8-4ed1-8f11-1284cb4d0137",
      "code": "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)",
      "title": "2207. Maximize Number of Subsequences in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86cfcc47-b17e-4f81-90f2-2095aa898f22",
      "code": "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans",
      "title": "2208. Minimum Operations to Halve Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bb7dec3-4ac4-4549-8ac5-084bb0c1692e",
      "code": "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]",
      "title": "2209. Minimum White Tiles After Covering With Carpets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a679b0d2-1a6b-45e7-8a64-b70cd7ec4585",
      "code": "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans",
      "title": "2210. Count Hills and Valleys in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84094822-25b4-4acc-b722-99cc8714e433",
      "code": "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])",
      "title": "2211. Count Collisions on a Road",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30759984-5d06-44d9-bcd1-1fb81b12cd3d",
      "code": "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)",
      "title": "2212. Maximum Points in an Archery Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "313cb92e-5b54-4775-ab68-cef030c3e15b",
      "code": "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)",
      "title": "2214. Minimum Health to Beat Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "098e3b03-a2d0-42fe-86ac-0d34687a5c4e",
      "code": "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]",
      "title": "2215. Find the Difference of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3015dd3-f625-4954-ac9b-588ce4f84278",
      "code": "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)",
      "title": "2216. Minimum Deletions to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c6199e2-a5f2-413a-b154-e4f68cfcd459",
      "code": "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]",
      "title": "2217. Find Palindrome With Fixed Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c6010ef-b87a-49c8-8e86-1134ebfbb07e",
      "code": "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)",
      "title": "2218. Maximum Value of K Coins From Piles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "342f7b32-901b-47e5-9e1b-dd0a9781ffd6",
      "code": "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans",
      "title": "2219. Maximum Sum Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b12f88f-5d5c-4965-aed3-9c77f6c7d2d1",
      "code": "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()",
      "title": "2220. Minimum Bit Flips to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b27ee26f-4325-4562-bc87-144ad7e1a988",
      "code": "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]",
      "title": "2221. Find Triangular Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02e12d57-f058-40e8-820a-2ca2667e5dd5",
      "code": "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans",
      "title": "2222. Number of Ways to Select Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a0dd2ea-5847-4164-8216-cb3396cd3b44",
      "code": "class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n",
      "title": "2223. Sum of Scores of Built Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef3ceeb2-a121-451f-a63d-b7348fcf7987",
      "code": "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans",
      "title": "2224. Minimum Number of Operations to Convert Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aa7699c-575b-4d73-b7d3-238dfb1c4561",
      "code": "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]",
      "title": "2225. Find Players With Zero or One Losses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "863a2b56-2c16-4c85-b6e5-69f205408d36",
      "code": "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1",
      "title": "2226. Maximum Candies Allocated to K Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1411fbd-4e12-48e4-8d9d-e5cdb256e12f",
      "code": "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)",
      "title": "2229. Check if an Array Is Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c71a72-9d5b-4a00-b3cb-d24e30476f4d",
      "code": "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans",
      "title": "2231. Largest Number After Digit Swaps by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24ff883b-bb1c-4f10-aed2-a7206402248b",
      "code": "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans",
      "title": "2232. Minimize Result by Adding Parentheses to Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26aeea91-5fc6-43b1-b3fb-e37a629788f8",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans",
      "title": "2233. Maximum Product After K Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e83caf-e635-4760-afef-37b73a220820",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans",
      "title": "2234. Maximum Total Beauty of the Gardens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a27a838-3a5c-4c92-9e89-14d7b65b6a95",
      "code": "class Solution:\n  sum = operator.add",
      "title": "2235. Add Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ec6ca94-e1fd-45c7-a8dd-f3f8d50c9a1c",
      "code": "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val",
      "title": "2236. Root Equals Sum of Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a4aba3a-f8a4-4c08-b9ce-ea7af3e9d447",
      "code": "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans",
      "title": "2237. Count Positions on Street With Required Brightness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eac98bd4-988a-480f-973a-b6334d3b3bb9",
      "code": "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]",
      "title": "2239. Find Closest Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20931d14-8fed-4fe5-a9e9-9070218498db",
      "code": "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1",
      "title": "2240. Number of Ways to Buy Pens and Pencils",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8be1686e-6e5e-42ca-91bc-e649f563de58",
      "code": "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans",
      "title": "2242. Maximum Score of a Node Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b9724e1-6809-4d41-a052-746e87fec878",
      "code": "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s",
      "title": "2243. Calculate Digit Sum of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cc4d7f7-76a5-46f5-a139-8c823e4dbeb6",
      "code": "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)",
      "title": "2244. Minimum Rounds to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "137d7617-8cf0-478b-b1cf-b58e682c8d36",
      "code": "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans",
      "title": "2245. Maximum Trailing Zeros in a Cornered Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33ddd8d5-6551-482f-8344-ff2ded2da839",
      "code": "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans",
      "title": "2246. Longest Path With Different Adjacent Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75352dc8-36fa-42b1-bbf4-08308d66b17a",
      "code": "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))",
      "title": "2247. Maximum Cost of Trip With K Highways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9be2c58a-2401-41a0-b3a7-caab8ee871a5",
      "code": "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]",
      "title": "2248. Intersection of Multiple Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d4930f0-4c92-4d8a-bc12-5ac608af22b7",
      "code": "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)",
      "title": "2249. Count Lattice Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31b22ff1-9630-4124-ae76-161ff4da6cb8",
      "code": "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans",
      "title": "2250. Count Number of Rectangles Containing Each Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec518c9b-6881-4574-b6b2-cd1d9cfac77c",
      "code": "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]",
      "title": "2251. Number of Flowers in Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d56964a-2307-4e6d-8caa-a1e6c33657e6",
      "code": "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))",
      "title": "2255. Count Prefixes of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dde9118-beae-49ef-a820-516d728d2566",
      "code": "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans",
      "title": "2256. Minimum Average Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a82531e-e4e0-45cb-bf2b-d11f1fa34f30",
      "code": "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans",
      "title": "2257. Count Unguarded Cells in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d631595-bc71-4ef3-9170-1eab091f41b2",
      "code": "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False",
      "title": "2258. Escape the Spreading Fire",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4c0c1e5-1680-4519-9c00-c37d000087bc",
      "code": "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans",
      "title": "2260. Minimum Consecutive Cards to Pick Up",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "084609ef-72c7-4ec9-b7d8-f02834308b2d",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans",
      "title": "2261. K Divisible Elements Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88fc6ec9-f373-4dbf-bb85-4fa7455f6ac3",
      "code": "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans",
      "title": "2262. Total Appeal of A String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36311975-10ab-4009-b921-28fa948a6b71",
      "code": "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))",
      "title": "2263. Make Array Non-decreasing or Non-increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e6a5672-e2ad-4121-96be-218b505952ee",
      "code": "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))",
      "title": "2264. Largest 3-Same-Digit Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3315494-0205-4582-b123-7bdfea3a08fa",
      "code": "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans",
      "title": "2265. Count Nodes Equal to Average of Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "258dc219-4bc9-4d4f-82eb-1307707ba738",
      "code": "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]",
      "title": "2266. Count Number of Texts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fed77d8-72fa-4337-a85c-ad2b9426593d",
      "code": "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)",
      "title": "2267. Check if There Is a Valid Parentheses String Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55e49ea4-4736-495c-9f3b-cf52c1f065df",
      "code": "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))",
      "title": "2268. Minimum Number of Keypresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6980ee5b-4142-4551-b041-c85ee81d865f",
      "code": "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans",
      "title": "2269. Find the K-Beauty of a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cafb4876-f766-4426-8a0d-7781ceb4e2f6",
      "code": "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans",
      "title": "2270. Number of Ways to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a82d1344-fd50-4e16-bc2b-2e45d6b8f6f8",
      "code": "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans",
      "title": "2271. Maximum White Tiles Covered by a Carpet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dedb73ad-0772-4c85-ba76-027f8c35db1f",
      "code": "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)",
      "title": "2272. Substring With Largest Variance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4a55a49-0278-462b-969b-6bef0f66d55c",
      "code": "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans",
      "title": "2273. Find Resultant Array After Removing Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "041dde43-94d4-4e28-9c97-3e46948027f2",
      "code": "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])",
      "title": "2274. Maximum Consecutive Floors Without Special Floors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad5cd9fc-deb7-4c19-86f2-4bacd36f77d9",
      "code": "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))",
      "title": "2275. Largest Combination With Bitwise AND Greater Than Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd7f0794-76df-4d3b-8eae-ab2d15585503",
      "code": "class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]",
      "title": "2277. Closest Node to Path in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a01dde54-b437-4688-a249-38bc0cea15d1",
      "code": "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)",
      "title": "2278. Percentage of Letter in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d0fa132-9102-4d93-be20-4cf5e9be9a73",
      "code": "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)",
      "title": "2279. Maximum Bags With Full Capacity of Rocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5a1e047-5aa2-4752-9e5f-54307c4b785d",
      "code": "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)",
      "title": "2280. Minimum Lines to Represent a Line Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53b68c18-d02d-434c-abef-a013fd1c72b0",
      "code": "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD",
      "title": "2281. Sum of Total Strength of Wizards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8146afc7-3aaf-414a-850b-ed5c72dbc12c",
      "code": "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans",
      "title": "2282. Number of People That Can Be Seen in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89d806c6-732b-4727-b4fa-edfdd2fc43dc",
      "code": "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))",
      "title": "2283. Check if Number Has Equal Digit Count and Digit Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0441e43-a859-41bc-bdaf-5311244e8bbf",
      "code": "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans",
      "title": "2284. Sender With Largest Word Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb39c1f3-ab81-4aa2-a45d-596cb37b5137",
      "code": "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))",
      "title": "2285. Maximum Total Importance of Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "820486d5-29ba-49f9-b3f2-3e585e2a32a0",
      "code": "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)",
      "title": "2287. Rearrange Characters to Make Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1841d9d-6ef8-4f0b-9d8e-a3bfc15cb3c4",
      "code": "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)",
      "title": "2288. Apply Discount to Prices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "604ad8bb-f66e-422a-a5b4-4b4338f736d6",
      "code": "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)",
      "title": "2289. Steps to Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1bccfea-3458-41b0-b251-5776c1478338",
      "code": "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]",
      "title": "2290. Minimum Obstacle Removal to Reach Corner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "263706ad-85b2-445b-9068-c53f38cd8a1c",
      "code": "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]",
      "title": "2291. Maximum Profit From Trading Stocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7cbeb42-87be-4e13-b90a-ec4b2c2bf2dc",
      "code": "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)",
      "title": "2293. Min Max Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "751997b6-7732-4daa-8640-1e91eba0a378",
      "code": "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans",
      "title": "2294. Partition Array Such That Maximum Difference Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd622809-e95a-4f40-bd8c-ec9282c1814f",
      "code": "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums",
      "title": "2295. Replace Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "768ce4a6-43aa-4c45-805b-b03526f9a38f",
      "code": "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]",
      "title": "2297. Jump Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "235f1dd8-a501-4637-8e14-9e892e3e5cff",
      "code": "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))",
      "title": "2299. Strong Password Checker II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e427bad1-ad30-4170-a079-e8b6f3465f4b",
      "code": "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]",
      "title": "2300. Successful Pairs of Spells and Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a1a1e6b-b3a8-4b89-a2b9-35673a422bcc",
      "code": "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True",
      "title": "2301. Match Substring After Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93ff6fdb-4060-48f1-b79b-b0eba8597775",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2302. Count Subarrays With Score Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db0ff27e-2316-4563-9651-b8da5b57e8bc",
      "code": "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans",
      "title": "2303. Calculate Amount Paid in Taxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "034ed8a9-5761-41bc-9c01-f685fa223f7b",
      "code": "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])",
      "title": "2304. Minimum Path Cost in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd86fdcf-4135-491a-8bab-d9bb810015d8",
      "code": "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans",
      "title": "2305. Fair Distribution of Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63671e7a-2c3f-4416-8abb-c9adff020ebc",
      "code": "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i, j in itertools.combinations(range(26), 2):\n      count = len(suffixes[i] & suffixes[j])\n      ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans",
      "title": "2306. Naming a Company",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4582d37-951a-4973-bb70-1dfa90a47acc",
      "code": "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False",
      "title": "2307. Check for Contradictions in Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "502b7e91-da1b-4d69-b9ea-078a6e5a3bd7",
      "code": "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''",
      "title": "2309. Greatest English Letter in Upper and Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bf7b594-4322-4b47-a2a1-6a3b794be2f2",
      "code": "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1",
      "title": "2310. Sum of Numbers With Units Digit K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6290204-1c83-441f-a602-c82217ff9d9f",
      "code": "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount",
      "title": "2311. Longest Binary Subsequence Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ef544f0-8475-4d84-b471-c537a44fb067",
      "code": "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]",
      "title": "2312. Selling Pieces of Wood",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7390e75-2357-4bbb-8545-5e7ca46e2416",
      "code": "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)",
      "title": "2313. Minimum Flips in Binary Tree to Get Result",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ff45f7a-0dcb-4843-9515-2a05533b88b8",
      "code": "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans",
      "title": "2315. Count Asterisks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5fb7cfe3-f544-4b42-a6d3-a55190b8fb31",
      "code": "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)",
      "title": "2316. Count Unreachable Pairs of Nodes in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97f54a1f-c6bc-4090-ad31-6bd1c57cb4c3",
      "code": "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)",
      "title": "2317. Maximum XOR After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5f536d8-1045-4f32-8156-e5b54a1f21bc",
      "code": "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)",
      "title": "2318. Number of Distinct Roll Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a91642aa-b7e8-41d3-a1d6-905c6fd849b8",
      "code": "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True",
      "title": "2319. Check if Matrix Is X-Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "232b8d67-f88e-4455-ad4e-b2c21293e517",
      "code": "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD",
      "title": "2320. Count Number of Ways to Place Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dee8063e-8a96-4490-848a-adc8ff4afb25",
      "code": "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))",
      "title": "2321. Maximum Score Of Spliced Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6246f82-64b9-4e34-91f9-3b323c25372f",
      "code": "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans",
      "title": "2322. Minimum Score After Removals on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51c98286-209d-48f7-a25d-db5199a85f76",
      "code": "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans",
      "title": "2323. Find Minimum Time to Finish All Jobs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f039071-493a-40ef-8829-b14215bf622e",
      "code": "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)",
      "title": "2325. Decode the Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0512c3d8-9f37-492e-b979-73188913d3ec",
      "code": "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans",
      "title": "2326. Spiral Matrix IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97b89899-c82b-4b53-9f8d-3bcf7d734bee",
      "code": "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD",
      "title": "2327. Number of People Aware of a Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45ec5dbf-1197-426d-a4c0-98fac3bc2afb",
      "code": "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD",
      "title": "2328. Number of Increasing Paths in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02c7e0e7-0a6f-4575-907e-20185d5acafa",
      "code": "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "2330. Valid Palindrome IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c98a22f1-2646-439e-9793-7157732908cb",
      "code": "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
      "title": "2331. Evaluate Boolean Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0557068f-b336-4288-b9fa-172843ed066d",
      "code": "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans",
      "title": "2332. The Latest Time to Catch a Bus",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9869436c-07f4-4662-a1ef-c41385233f43",
      "code": "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1",
      "title": "2334. Subarray With Elements Greater Than Varying Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05353edf-a977-453c-b51c-4264de2d022a",
      "code": "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)",
      "title": "2335. Minimum Amount of Time to Fill Cups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a1bd10d-c79f-4c22-a537-23f014bf6675",
      "code": "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "2337. Move Pieces to Obtain a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36a58c55-8599-4923-886a-7be8f3bdcfce",
      "code": "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex",
      "title": "2340. Minimum Adjacent Swaps to Make a Valid Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35117ca3-166b-4687-ac5c-e34786667047",
      "code": "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans",
      "title": "2341. Maximum Number of Pairs in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8377023e-7782-40ec-953e-deb7d355071a",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2342. Max Sum of a Pair With Equal Sum of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2a27420-716f-4043-a034-231fc0e5be95",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1",
      "title": "2344. Minimum Deletions to Make Array Divisible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8faab282-f0a7-4157-b309-91f3df1b5d07",
      "code": "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans",
      "title": "2345. Finding the Number of Visible Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "579e332f-e1c2-4dee-85d0-5788fc67ef78",
      "code": "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'",
      "title": "2347. Best Poker Hand",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba860225-6c41-4b05-8672-999eeb008055",
      "code": "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans",
      "title": "2348. Number of Zero-Filled Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3aa611d-8a79-43ed-a6a5-e96def5a0d33",
      "code": "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans",
      "title": "2350. Shortest Impossible Sequence of Rolls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3aa5f32b-7d9a-4ba3-8f66-947a97740796",
      "code": "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True",
      "title": "2351. First Letter to Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e264fc0-f174-46b0-842f-cef5a6cc61b0",
      "code": "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans",
      "title": "2352. Equal Row and Column Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfd0dbf6-f51d-4c87-a25d-332dc411c1ed",
      "code": "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)",
      "title": "2354. Number of Excellent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bdbdd12-fb3e-4e98-898c-a75e7157fec9",
      "code": "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)",
      "title": "2355. Maximum Number of Books You Can Take",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37062743-3276-47ad-8e73-71178170e357",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})",
      "title": "2357. Make Array Zero by Subtracting Equal Amounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc193942-ed87-4dbe-8aff-8106745dcb6a",
      "code": "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)",
      "title": "2358. Maximum Number of Groups Entering a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c181e3a-9032-4150-bae5-5daf1c23f18d",
      "code": "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist",
      "title": "2359. Find Closest Node to Given Two Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab9f6236-22ec-4ac2-b50e-6ba96d2b239c",
      "code": "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans",
      "title": "2360. Longest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e034773-cc38-4e2b-88d6-81557ff3ba16",
      "code": "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans",
      "title": "2361. Minimum Costs Using the Train Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4736ed8f-b89b-4097-af95-f353b889f111",
      "code": "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())",
      "title": "2363. Merge Similar Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3efe9cb7-9cfb-4142-b73c-607b418f8338",
      "code": "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans",
      "title": "2364. Count Number of Bad Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "718140b9-5945-4ad7-9a0a-ffee5f3dc1eb",
      "code": "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans",
      "title": "2365. Task Scheduler II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19a998a8-a82f-4f5b-935f-9af57f95b7dd",
      "code": "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans",
      "title": "2366. Minimum Replacements to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d53d1abc-d3fe-402e-844f-3e78ce9e32cb",
      "code": "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans",
      "title": "2367. Number of Arithmetic Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d614e56-86f8-41e9-a5f4-f18e113eb748",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)",
      "title": "2368. Reachable Nodes With Restrictions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e49a953e-fb0f-4ffe-87e1-bf0d66394894",
      "code": "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]",
      "title": "2369. Check if There is a Valid Partition For The Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf845775-71d9-42c7-9fd3-e0ce83a4a49a",
      "code": "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable",
      "title": "2370. Longest Ideal Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cec1e2b-f021-48eb-9d60-a24e3296eb2c",
      "code": "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans",
      "title": "2371. Minimize Maximum Value in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35f7b29d-1373-4724-9548-b50b007d868a",
      "code": "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans",
      "title": "2373. Largest Local Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9c03275-caad-45fd-b6b2-bd8b328d1504",
      "code": "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))",
      "title": "2374. Node With Highest Edge Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4f5635d-e83e-4f9f-8024-282c373dac17",
      "code": "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)",
      "title": "2375. Construct Smallest Number From DI String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704dd348-a44b-44de-9126-57173828d692",
      "code": "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "2376. Count Special Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e38b5abd-bcca-4096-9d15-2136a36bf127",
      "code": "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)",
      "title": "2378. Choose Edges to Maximize Score in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba5d6dc-6442-4e64-b802-024c6e9d366c",
      "code": "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB",
      "title": "2379. Minimum Recolors to Get K Consecutive Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db78e743-d30e-4fef-a1c6-ebd449f60fee",
      "code": "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans",
      "title": "2380. Time Needed to Rearrange a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e232b57-c0bf-48b9-b4b9-cf7038a69ce9",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    line = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      line[start] += diff\n      line[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + line[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)",
      "title": "2381. Shifting Letters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d17c1772-ec0c-4e9a-b179-c005a5ed1f4f",
      "code": "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans",
      "title": "2382. Maximum Segment Sum After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38a6b8a9-7482-4eb7-80b2-038a7ddbc115",
      "code": "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience",
      "title": "2383. Minimum Hours of Training to Win a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e0c631b-67a0-4cc2-acbf-25591eaaedf5",
      "code": "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''",
      "title": "2384. Largest Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4fbe7fa-3edc-4b7e-94be-9bae707df787",
      "code": "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph",
      "title": "2385. Amount of Time for Binary Tree to Be Infected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e598683c-99f6-4832-ac1f-c82eb389782d",
      "code": "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum",
      "title": "2386. Find the K-Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0ae8356-f434-47d6-b00e-b4b52ab64d67",
      "code": "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2387. Median of a Row Wise Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d603ff19-08f9-4129-823a-b46349096723",
      "code": "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]",
      "title": "2389. Longest Subsequence With Limited Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "deea34f3-efbb-48ae-88fe-2e4a69ba3576",
      "code": "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "2390. Removing Stars From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f6fe1a1-5dc7-4af4-816e-2e0f1161ac32",
      "code": "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')",
      "title": "2391. Minimum Amount of Time to Collect Garbage",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8786d6e6-ab59-4222-9029-1f70e63e2e72",
      "code": "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []",
      "title": "2392. Build a Matrix With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8139ba15-2cf4-456a-95fb-bdc9998053ac",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans",
      "title": "2393. Count Strictly Increasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28f93bbe-77ac-4ea8-8a74-4e8a81a7894b",
      "code": "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False",
      "title": "2395. Find Subarrays With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5b031bd-759a-4a52-865c-aad65a830308",
      "code": "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False",
      "title": "2396. Strictly Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "559adbc6-2cc0-4df5-b9a5-0ed09926b349",
      "code": "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count",
      "title": "2397. Maximum Rows Covered by Columns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5111bd0-bbec-456d-a46d-1ced4065ee62",
      "code": "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j",
      "title": "2398. Maximum Number of Robots Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffcfaa78-a6e4-48a1-95db-04c55d4b8fa8",
      "code": "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True",
      "title": "2399. Check Distances Between Same Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e7b8f1a-59fd-40f1-98c6-a742af81a1fb",
      "code": "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]",
      "title": "2400. Number of Ways to Reach a Position After Exactly k Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac8ba458-2b2b-4151-ace3-305b9369e95b",
      "code": "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2401. Longest Nice Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eab58e90-02b3-42ef-b2f9-92189ab4d4ad",
      "code": "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))",
      "title": "2402. Meeting Rooms III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd675cc5-7564-49cc-8a09-118317457cc9",
      "code": "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]",
      "title": "2403. Minimum Time to Kill All Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19dfe7ed-602a-4b05-bafa-a49367da325e",
      "code": "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans",
      "title": "2404. Most Frequent Even Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50d2ccbb-07ea-4207-92cb-e1e8396723ca",
      "code": "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans",
      "title": "2405. Optimal Partition of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe3c1812-2690-46a4-9c17-2144dd14b4c4",
      "code": "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)",
      "title": "2406. Divide Intervals Into Minimum Number of Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8464c6f6-ed4d-444d-ac44-b735c0d1e0c1",
      "code": "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans",
      "title": "2409. Count Days Spent Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2fcfedb-fb3e-4146-b2ff-43a66d48a827",
      "code": "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans",
      "title": "2410. Maximum Matching of Players With Trainers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83c6be68-5437-4bf2-a24c-41fdf0b147d7",
      "code": "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans",
      "title": "2411. Smallest Subarrays With Maximum Bitwise OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1346f115-4261-4bcd-84d1-473a120386c4",
      "code": "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans",
      "title": "2412. Minimum Money Required Before Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0632962-5fa0-4044-b8ff-7585999ea05c",
      "code": "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)",
      "title": "2413. Smallest Even Multiple",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f87945a6-b545-4b3a-af91-9d6b73fac46f",
      "code": "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans",
      "title": "2414. Length of the Longest Alphabetical Continuous Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6d24802-5c9d-4598-a745-fed6e072f5c3",
      "code": "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root",
      "title": "2415. Reverse Odd Levels of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38b41236-73f2-4b42-8310-438e55a6e733",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]",
      "title": "2416. Sum of Prefix Scores of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef3a632a-eb9f-4b8e-a272-f88140176406",
      "code": "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0",
      "title": "2417. Closest Fair Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5acda8a1-e6d7-4731-aaf0-ad6cd6dbc830",
      "code": "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]",
      "title": "2418. Sort the People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29f44ac0-0f40-4c5f-8bf6-d760f07d99af",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans",
      "title": "2419. Longest Subarray With Maximum Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "019e613b-7d46-4131-94cc-28fbf3d9fdfb",
      "code": "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]",
      "title": "2420. Find All Good Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6e32cc7-0124-4aec-95b4-83d5e1d3eecb",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans",
      "title": "2422. Merge Operations to Turn Array Into a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cb7ce06-f23f-4ad5-95a5-b417f712ff86",
      "code": "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False",
      "title": "2423. Remove Letter To Equalize Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0790ecd1-2463-4a74-baa2-98a7ff435492",
      "code": "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)",
      "title": "2425. Bitwise XOR of All Pairings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c009243-f4cc-44e3-b12a-896b225432a6",
      "code": "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))",
      "title": "2427. Number of Common Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d0e92e9-3ed7-4fb4-85b8-0e2fa8252bb6",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))",
      "title": "2428. Maximum Sum of an Hourglass",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8437220-adc1-488c-a343-d34a75dc4697",
      "code": "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans",
      "title": "2429. Minimize XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a810149c-4769-4bb3-bd07-d553f196c34e",
      "code": "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]",
      "title": "2430. Maximum Deletions on a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8148420-1a44-4b65-a0f4-0bcb8c50a75b",
      "code": "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]",
      "title": "2431. Maximize Total Tastiness of Purchased Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2129fb7-4dc7-4f06-b54e-7c54fcd971ce",
      "code": "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans",
      "title": "2432. The Employee That Worked on the Longest Task",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74bfacb9-2f45-498a-9d4f-cfb178f8dd51",
      "code": "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans",
      "title": "2433. Find The Original Array of Prefix Xor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05285429-7e96-4605-bb1d-c68f626caf2b",
      "code": "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'",
      "title": "2434. Using a Robot to Print the Lexicographically Smallest String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29d1e1bd-7c4b-48a5-b72d-9e6303166449",
      "code": "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]",
      "title": "2435. Paths in Matrix Whose Sum Is Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "229e7218-58fb-468a-93f3-58ef4c5eb149",
      "code": "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans",
      "title": "2436. Minimum Split Into Subarrays With GCD Greater Than One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d4d620d-9531-4f49-b0fd-9b9d0163a480",
      "code": "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans",
      "title": "2437. Number of Valid Clock Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7fb9ff8-4516-45c5-a4da-2236688a2e63",
      "code": "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    pows = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= pows[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans",
      "title": "2438. Range Product Queries of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8fe602d-98c0-4b14-839b-caee330d24cb",
      "code": "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans",
      "title": "2439. Minimize Maximum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a52931c-57f9-46a6-b16d-7a0b6a0456ae",
      "code": "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0",
      "title": "2440. Create Components With Same Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c390fbd6-9fab-4008-bbac-d00515228d77",
      "code": "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans",
      "title": "2441. Largest Positive Integer That Exists With Its Negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1db8c5a-90b0-4772-a918-2f1ffca801ad",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans",
      "title": "2444. Count Subarrays With Fixed Bounds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa520948-c19d-42aa-8d35-17aa91d43842",
      "code": "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)",
      "title": "2445. Number of Nodes With Value One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97498d6e-1337-45ac-9955-83584aa38a15",
      "code": "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans",
      "title": "2447. Number of Subarrays With GCD Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cd831f3-ea16-44a0-862b-cc577be0313a",
      "code": "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans",
      "title": "2448. Minimum Cost to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fde8d25c-fb70-4ccb-9a0a-a633365153f2",
      "code": "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4",
      "title": "2449. Minimum Number of Operations to Make Arrays Similar",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c67d982-7360-4fc6-ae36-d8d537d6dbad",
      "code": "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)",
      "title": "2450. Number of Distinct Binary Strings After Applying Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0a9ab57-5f1e-44bb-93ca-68f816bee722",
      "code": "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word",
      "title": "2451. Odd String Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c39e346-7999-46a2-8a94-19b0772104c8",
      "code": "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]",
      "title": "2452. Words Within Two Edits of Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1b002d1-b1b1-48a6-8c84-6600875e612a",
      "code": "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)",
      "title": "2453. Destroy Sequential Targets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17ab14f9-2eac-422c-8ebc-d32e4275cf96",
      "code": "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans",
      "title": "2454. Next Greater Element IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "036b9de2-7c8d-4998-a94f-273b1a18060b",
      "code": "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count",
      "title": "2455. Average Value of Even Numbers That Are Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5b95afc-21ea-48c1-9751-3579a2468084",
      "code": "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans",
      "title": "2456. Most Popular Video Creator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43cb8be0-422b-4010-8d78-1e628aba4e72",
      "code": "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans",
      "title": "2457. Minimum Addition to Make Integer Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81867a0f-d3eb-499a-baf8-2cea0fa2fe6e",
      "code": "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]",
      "title": "2458. Height of Binary Tree After Subtree Removal Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "adfc5baa-a915-4a2e-bd80-ac6fac197b98",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))",
      "title": "2459. Sort Array by Moving Items to Empty Space",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de0c76e1-026d-428e-81b2-7208b1d28a0b",
      "code": "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans",
      "title": "2460. Apply Operations to an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9421b521-68ef-416f-a3ed-25cfd87c0f01",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2461. Maximum Sum of Distinct Subarrays With Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccbe7c9f-c05f-4074-a629-7a93b1914491",
      "code": "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans",
      "title": "2462. Total Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a9fb23c-07b3-45b6-a91d-781741d062e8",
      "code": "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)",
      "title": "2463. Minimum Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b95cd986-73e1-46ac-9a0c-f28d826319c4",
      "code": "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "2464. Minimum Subarrays in a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43c786f9-09d1-477d-a44c-415e22151b78",
      "code": "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)",
      "title": "2465. Number of Distinct Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08b61911-33c8-4ec5-959c-9018a8d77b8f",
      "code": "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans",
      "title": "2466. Count Ways To Build Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d929f0a-1b39-454c-b061-82a27b8e9008",
      "code": "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath",
      "title": "2467. Most Profitable Path in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1d7fe01-9663-4d2c-8ff2-ed019b416c65",
      "code": "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans",
      "title": "2468. Split Message Based on Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d53828a4-9c24-4b50-b288-b60287497262",
      "code": "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]",
      "title": "2469. Convert the Temperature",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cd442b9-14a5-4cc4-aa6f-bae066e19c85",
      "code": "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans",
      "title": "2470. Number of Subarrays With LCM Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4bd1023-c0fb-4b41-8b8b-2859b043c118",
      "code": "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans",
      "title": "2471. Minimum Number of Operations to Sort a Binary Tree by Level",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704e8ddb-2ac7-48ba-a523-fad25e5466bf",
      "code": "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]",
      "title": "2472. Maximum Number of Non-overlapping Palindrome Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26a36037-760c-46e7-9837-46a5cdbcd011",
      "code": "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans",
      "title": "2473. Minimum Cost to Buy Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6255563-4458-40c1-936c-8a86472682db",
      "code": "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans",
      "title": "2475. Number of Unequal Triplets in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3162129-c487-4099-a804-7849014888ca",
      "code": "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)",
      "title": "2476. Closest Nodes Queries in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "955e55e2-f322-4a39-9d75-048cf7f37c34",
      "code": "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans",
      "title": "2477. Minimum Fuel Cost to Report to the Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb67d7ea-3aab-4e3d-b96b-2ae12a5524b0",
      "code": "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)",
      "title": "2478. Number of Beautiful Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26e4ecf6-7cb4-42d5-8c53-ad655bf365d1",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans",
      "title": "2479. Maximum XOR of Two Non-Overlapping Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e06b792d-4449-43b0-af7a-509bcc98b4eb",
      "code": "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n",
      "title": "2481. Minimum Cuts to Divide a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6716d39f-121d-4edd-9f2a-8f4379869edd",
      "code": "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans",
      "title": "2482. Difference Between Ones and Zeros in Row and Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf98581e-8c71-4ffd-8f88-0afc9844bdd3",
      "code": "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans",
      "title": "2483. Minimum Penalty for a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52e6a360-980c-43e2-bd27-33061d9dab4d",
      "code": "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans",
      "title": "2484. Count Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2830ba12-f6e8-402f-ac11-0c00dc70d8a1",
      "code": "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1",
      "title": "2485. Find the Pivot Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a21c16d-4e0a-4f40-ac62-895befc823ac",
      "code": "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i",
      "title": "2486. Append Characters to String to Make Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aefca5a7-fd41-4a5a-8755-a53e3dbf4fd8",
      "code": "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head",
      "title": "2487. Remove Nodes From Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "540ac4af-dc37-4226-9526-7d37f783ac3c",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans",
      "title": "2488. Count Subarrays With Median K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a39b0b2-8b36-4a54-9580-ce0bef5e7db7",
      "code": "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2489. Number of Substrings With Fixed Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74da37c1-cd76-4627-9ed1-acc9896aa46c",
      "code": "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]",
      "title": "2490. Circular Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e746d7a3-bc8b-4681-819d-0a08881b2ce6",
      "code": "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2",
      "title": "2491. Divide Players Into Teams of Equal Skill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f95b2d5f-3ae9-4ba5-9a61-377377e5d5dc",
      "code": "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans",
      "title": "2492. Minimum Score of a Path Between Two Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7e25008-ce7e-4584-abb7-6ac0639c2a46",
      "code": "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans",
      "title": "2495. Number of Subarrays Having Even Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a9922f2-f266-4cf3-9496-59e51e48297c",
      "code": "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)",
      "title": "2496. Maximum Value of a String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d36819d-dd4b-4a15-9824-339caa7b7a3b",
      "code": "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans",
      "title": "2497. Maximum Star Sum of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11d07399-0de1-49de-b573-abce571552ed",
      "code": "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))",
      "title": "2498. Frog Jump II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ee51e30-8798-43d3-9a27-53ffa8762ddf",
      "code": "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans",
      "title": "2499. Minimum Total Cost to Make Arrays Unequal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b167748-af0a-40df-89b2-f48b859471e3",
      "code": "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))",
      "title": "2500. Delete Greatest Value in Each Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8e7f960-5844-4c6c-85f9-22cd593aca2a",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans",
      "title": "2503. Maximum Number of Points From Grid Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "004543e9-be53-4d76-b41d-93afbd9e9bea",
      "code": "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans",
      "title": "2505. Bitwise OR of All Subsequence Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9f9b5c7-356b-4a0c-87e9-79abaf1a044a",
      "code": "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    masks = [self._getMask(word) for word in words]\n    return sum(masks[i] == masks[j]\n               for i, j in itertools.combinations(range(len(masks)), 2))\n\n  def _getMask(self, word: str) -> int:\n    mask = 0\n    for c in word:\n      mask |= 1 << ord(c) - ord('a')\n    return mask",
      "title": "2506. Count Pairs Of Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c6e92b1-f19c-4ad7-a2b5-dc6ef8300cb3",
      "code": "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n",
      "title": "2507. Smallest Value After Replacing With Sum of Prime Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60914488-e934-4724-8ed3-3928163c295b",
      "code": "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False",
      "title": "2508. Add Edges to Make Degrees of All Nodes Even",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c91939b1-5e4d-47b8-bbf7-66d9e4b206b3",
      "code": "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]",
      "title": "2509. Cycle Length Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9c6f611-d2c7-44f0-9119-26631657776a",
      "code": "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)",
      "title": "2510. Check if There is a Path With Equal Number of 0's And 1's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "844b6972-70bd-48f3-b3fe-6ff6158ab12b",
      "code": "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans",
      "title": "2511. Maximum Enemy Forts That Can Be Captured",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6cbcc42-9397-4b12-b493-b8334953d06c",
      "code": "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]",
      "title": "2512. Reward Top K Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e0df4f2-7e05-4335-8b91-086b447574ec",
      "code": "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2513. Minimize the Maximum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d621b2c2-47b7-4c5a-b225-311135a7e46a",
      "code": "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007",
      "title": "2514. Count Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c42dace2-a89a-45e3-ab04-4d187f05f23c",
      "code": "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1",
      "title": "2515. Shortest Distance to Target String in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "395afce2-c745-4d40-9097-42eb13cf9514",
      "code": "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans",
      "title": "2516. Take K of Each Character From Left and Right",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4fe976e-4818-4d20-a8d5-52f24dbdfc79",
      "code": "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1",
      "title": "2517. Maximum Tastiness of Candy Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a95dcdd7-2919-4a8f-ba9d-36f2db959931",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD",
      "title": "2518. Number of Great Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bda870c1-1a85-41ef-956a-cb65ddbc8f17",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))",
      "title": "2519. Count the Number of K-Big Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a3c005e-ef5f-4f4e-a97c-e727f77c919f",
      "code": "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))",
      "title": "2520. Count the Digits That Divide a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f8469b2-50c8-4cce-8f38-66144ad05862",
      "code": "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor",
      "title": "2521. Distinct Prime Factors of Product of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3342c517-c420-4c40-8fe0-703b9b0e511e",
      "code": "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans",
      "title": "2522. Partition String Into Substrings With Values at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a6c01a6-3092-4aa7-b9f0-c699e90ec7a2",
      "code": "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2523. Closest Prime Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37128daa-976e-4c0b-87de-7a7b0730f98a",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ",
      "title": "2524. Maximum Frequency Score of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d545a33a-708e-4a88-b78e-1edddc533ad4",
      "code": "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'",
      "title": "2525. Categorize Box According to Criteria",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae574383-4ad4-48df-963b-08d0abad6c33",
      "code": "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)",
      "title": "2527. Find Xor-Beauty of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d386f3c0-5101-484d-be72-a3945378dbd8",
      "code": "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1",
      "title": "2528. Maximize the Minimum Powered City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24930c07-8baa-45dd-a188-e6e9b43f2d1f",
      "code": "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))",
      "title": "2529. Maximum Count of Positive Integer and Negative Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7429c28-d0c9-4ac9-90dc-184ec20ac215",
      "code": "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans",
      "title": "2530. Maximal Score After Applying K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0148814-9413-40b8-b92e-d82438979ea0",
      "code": "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False",
      "title": "2531. Make Number of Distinct Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f3856e1-36cb-44c5-9281-a69eec654d74",
      "code": "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans",
      "title": "2532. Time to Cross a Bridge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "147d9348-8467-44b3-84fa-4bc30427ba44",
      "code": "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD",
      "title": "2533. Number of Good Binary Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3be396a-11e3-4d31-a6f3-76d6af692961",
      "code": "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2535. Difference Between Element Sum and Digit Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b19465e3-5200-48a4-9806-4722f537cfec",
      "code": "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans",
      "title": "2538. Difference Between Maximum and Minimum Price Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "111de592-6635-4022-9bb4-71aac01026ea",
      "code": "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans",
      "title": "2539. Count the Number of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "192f9e69-e43f-4912-a41b-f39360e66e26",
      "code": "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1",
      "title": "2540. Minimum Common Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52118f9c-aca6-4d59-921b-60e83f9e70cf",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1",
      "title": "2541. Minimum Operations to Make Array Equal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d521c318-960e-48f4-8274-0681f9eefa0c",
      "code": "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans",
      "title": "2542. Maximum Subsequence Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5928229-1835-469f-9ad3-a1bca3fed8dd",
      "code": "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1",
      "title": "2543. Check if Point Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "149b12a8-17a5-4171-9c39-bbf490b56fa8",
      "code": "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans",
      "title": "2544. Alternating Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "908b9fbc-c31e-4871-9041-a0af088c126b",
      "code": "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])",
      "title": "2545. Sort the Students by Their Kth Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd3a93bf-6d06-41c7-a504-df64788405f9",
      "code": "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)",
      "title": "2546. Apply Bitwise Operations to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efef4638-92ae-4fc0-9329-7f3ace6d3bc8",
      "code": "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]",
      "title": "2547. Minimum Cost to Split an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dccb1d1-69bc-405b-8de8-5a8dbc7b526d",
      "code": "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1",
      "title": "2548. Maximum Price to Fill a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac1e3f52-81bf-4b33-8ba7-df7604fcf6cf",
      "code": "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)",
      "title": "2549. Count Distinct Numbers on Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86167daf-a8d9-41d3-974e-23716d292ed1",
      "code": "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res",
      "title": "2550. Count Collisions of Monkeys on a Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7b04492-fcb1-494d-bf24-05dbf95a1077",
      "code": "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))",
      "title": "2551. Put Marbles in Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83951de3-5557-4e1b-a576-1894ef10a7ca",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans",
      "title": "2552. Count Increasing Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d101dc0-9afa-4394-bde1-119d061d2801",
      "code": "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]",
      "title": "2553. Separate the Digits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b186b26b-8c15-4e38-a1e6-1870d8b19982",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans",
      "title": "2554. Maximum Number of Integers to Choose From a Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16126664-f2db-4cc0-b597-5bff13235490",
      "code": "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans",
      "title": "2555. Maximize Win From Two Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3753457-2686-49c0-b9be-5e3b96e1c51a",
      "code": "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)",
      "title": "2556. Disconnect Path in a Binary Matrix by at Most One Flip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0278be0d-502c-40f9-a803-5b7ec4b59380",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)",
      "title": "2557. Maximum Number of Integers to Choose From a Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50d5fb19-a781-41a8-8245-3c96c7a54b16",
      "code": "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)",
      "title": "2558. Take Gifts From the Richest Pile",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28a486e2-616f-4655-8d99-79e214bb4c99",
      "code": "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]",
      "title": "2559. Count Vowel Strings in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1ed7adf-2e05-4c9b-945a-d6968a762285",
      "code": "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)",
      "title": "2560. House Robber IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "961c5d7d-8b13-4c2d-8343-d3944afe00d9",
      "code": "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])",
      "title": "2561. Rearranging Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "930b9c46-8047-4341-bf15-d59d815752d2",
      "code": "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)",
      "title": "2563. Count the Number of Fair Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5533df73-1615-4ae7-ad29-121a0f621af3",
      "code": "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]",
      "title": "2564. Substring XOR Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ab999d0-6303-4b41-b5b6-3c638cce36bf",
      "code": "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans",
      "title": "2565. Subsequence With the Minimum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8823deae-f162-45f0-9c65-8b101d666848",
      "code": "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0",
      "title": "2566. Maximum Difference by Remapping a Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5050e041-ac96-4e9f-acf2-6a0becabf335",
      "code": "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)",
      "title": "2567. Minimum Score by Changing Two Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a30b6256-fa35-471e-baa5-2c37ac902e24",
      "code": "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans",
      "title": "2568. Minimum Impossible OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11ed8af8-bb95-4ce0-9369-1083b7668dd2",
      "code": "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val",
      "title": "2570. Merge Two 2D Arrays by Summing Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d40a064-7566-4278-883e-d1dbef5f9743",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans",
      "title": "2571. Minimum Operations to Reduce an Integer to 0",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a46da3d2-41c4-4921-bd2e-88ae2a4ab338",
      "code": "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD",
      "title": "2572. Count the Number of Square-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a46588f3-f6e5-4d03-a2c7-a11590402503",
      "code": "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]",
      "title": "2574. Left and Right Sum Differences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2782cb31-c45e-422f-abc7-dc8e0941bf56",
      "code": "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans",
      "title": "2575. Find the Divisibility Array of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81352f4c-0725-48c5-91a9-915185896a60",
      "code": "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2",
      "title": "2576. Find the Maximum Number of Marked Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}