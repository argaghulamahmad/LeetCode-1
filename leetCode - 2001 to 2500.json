{
  "snippets": [
    {
      "id": "c310f50c-d8e6-404d-a9c0-d7395d5f09d1",
      "code": "class Solution:\n  def minimumTime(self, grid: list[list[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]  # (time, i, j)\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))",
      "title": "2577. Minimum Time to Visit a Cell In a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c48a5e8c-b1b0-474f-82cb-475f8f9692d4",
      "code": "class Solution:\n  def splitNum(self, num: int) -> int:\n    s = ''.join(sorted(str(num)))\n    return sum(map(int, (s[::2], s[1::2])))",
      "title": "2578. Split With Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56fa74c0-5e00-4608-bc6a-d907132bc93d",
      "code": "class Solution:\n  def coloredCells(self, n: int) -> int:\n    return n**2 + (n - 1)**2",
      "title": "2579. Count Total Number of Colored Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc87babe-6f3e-49af-9427-7b30dba7912a",
      "code": "class Solution:\n  def countWays(self, ranges: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevEnd = -1\n\n    for start, end in sorted(ranges):\n      if start > prevEnd:\n        ans = ans * 2 % MOD\n      prevEnd = max(prevEnd, end)\n\n    return ans",
      "title": "2580. Count Ways to Group Overlapping Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7b64485-8a62-4a8d-8cac-97da67186ffd",
      "code": "class Solution:\n  def rootCount(\n      self,\n      edges: list[list[int]],\n      guesses: list[list[int]],\n      k: int,\n  ) -> int:\n    ans = 0\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    guessGraph = [set() for _ in range(n)]\n    parent = [0] * n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u, v in guesses:\n      guessGraph[u].add(v)\n\n    def dfs(u: int, prev: int) -> None:\n      parent[u] = prev\n      for v in graph[u]:\n        if v != prev:\n          dfs(v, u)\n\n    # Precalculate `parent`.\n    dfs(0, -1)\n\n    # Calculate `correctGuess` for tree rooted at 0.\n    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))\n\n    def reroot(u: int, prev: int, correctGuess: int) -> None:\n      nonlocal ans\n      if u != 0:\n        # The tree is rooted at u, so a guess edge (u, prev) will match the new\n        # `parent` relationship.\n        if prev in guessGraph[u]:\n          correctGuess += 1\n        # A guess edge (prev, u) matching the old `parent` relationship will no\n        # longer be True.\n        if u in guessGraph[prev]:\n          correctGuess -= 1\n      if correctGuess >= k:\n        ans += 1\n      for v in graph[u]:\n        if v != prev:\n          reroot(v, u, correctGuess)\n\n    reroot(0, -1, correctGuess)\n    return ans",
      "title": "2581. Count Number of Possible Root Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "434eb29d-cccd-40d3-8009-f2a5cbe09671",
      "code": "class Solution:\n  def passThePillow(self, n: int, time: int) -> int:\n    # Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2\n    if time < n:  # Go forward from 1.\n      return 1 + time\n    return n - (time - (n - 1))  # Go backward from n.",
      "title": "2582. Pass the Pillow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d504ec6c-4fba-4d63-929d-eb80139ed31b",
      "code": "class Solution:\n  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    if len(levelSums) < k:\n      return -1\n\n    return sorted(levelSums, reverse=True)[k - 1]",
      "title": "2583. Kth Largest Sum in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1523213a-6b63-48d5-ad12-6728acf38651",
      "code": "class Solution:\n  def findValidSplit(self, nums: list[int]) -> int:\n    leftPrimeFactors = collections.Counter()\n    rightPrimeFactors = collections.Counter()\n\n    def getPrimeFactors(num: int) -> list[int]:\n      \"\"\"Gets the prime factors under sqrt(10^6).\"\"\"\n      primeFactors = []\n      for divisor in range(2, min(1000, num) + 1):\n        if num % divisor == 0:\n          primeFactors.append(divisor)\n          while num % divisor == 0:\n            num //= divisor\n      # Handle the case that `num` contains a prime factor > 1000.\n      if num > 1:\n        primeFactors.append(num)\n      return primeFactors\n\n    for num in nums:\n      for primeFactor in getPrimeFactors(num):\n        rightPrimeFactors[primeFactor] += 1\n\n    for i in range(len(nums) - 1):\n      for primeFactor in getPrimeFactors(nums[i]):\n        rightPrimeFactors[primeFactor] -= 1\n        if rightPrimeFactors[primeFactor] == 0:\n          # rightPrimeFactors[primeFactor] == 0, so no need to track\n          # leftPrimeFactors[primeFactor].\n          del rightPrimeFactors[primeFactor]\n          del leftPrimeFactors[primeFactor]\n        else:\n          # Otherwise, need to track leftPrimeFactors[primeFactor].\n          leftPrimeFactors[primeFactor] += 1\n      if not leftPrimeFactors:\n        return i\n\n    return -1",
      "title": "2584. Split the Array to Make Coprime Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abaa4f8f-90d8-4278-8660-dd5ae69ebaf4",
      "code": "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of ways to earn j points with the first i types\n    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, len(types) + 1):\n      count = types[i - 1][0]\n      mark = types[i - 1][1]\n      for j in range(target + 1):\n        for solved in range(count + 1):\n          if j - solved * mark >= 0:\n            dp[i][j] += dp[i - 1][j - solved * mark]\n            dp[i][j] %= MOD\n\n    return dp[len(types)][target]",
      "title": "2585. Number of Ways to Earn Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d332c1de-86c1-48b7-aa00-8dff8dae497d",
      "code": "class Solution:\n  def vowelStrings(self, words: list[str], left: int, right: int) -> int:\n    VOWELS = 'aeiou'\n    return sum(word[0] in VOWELS and word[-1] in VOWELS\n               for word in words[left:right + 1])",
      "title": "2586. Count the Number of Vowel Strings in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9e1581c-f3a8-4da9-8fd1-ae9f1d6fcb9c",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    return sum(num > 0\n               for num in itertools.accumulate(sorted(nums, reverse=True)))",
      "title": "2587. Rearrange Array to Maximize Prefix Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd540d50-4ea7-4a45-8033-6db02386c179",
      "code": "class Solution:\n  def beautifulSubarrays(self, nums: list[int]) -> int:\n    # A subarray is beautiful if xor(subarray) = 0.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix ^= num\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2588. Count the Number of Beautiful Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a79e4611-bfb2-4509-a3b8-6c60c96eb19e",
      "code": "class Solution:\n  def findMinimumTime(self, tasks: list[list[int]]) -> int:\n    MAX = 2000\n    running = [False] * (MAX + 1)\n\n    # Sort tasks by end.\n    for start, end, duration in sorted(tasks, key=lambda x: x[1]):\n      neededDuration = (duration -\n                        sum(running[i] for i in range(start, end + 1)))\n      # Greedily run the task as late as possible so that later tasks can run\n      # simultaneously.\n      i = end\n      while neededDuration > 0:\n        if not running[i]:\n          running[i] = True\n          neededDuration -= 1\n        i -= 1\n\n    return sum(running)",
      "title": "2589. Minimum Time to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca4bc824-ce09-409c-b6df-b153343524c7",
      "code": "class Solution:\n  def distMoney(self, money: int, children: int) -> int:\n    # Everyone must receive at least 1 dollar.\n    money -= children\n    if money < 0:\n      return -1\n\n    count7 = money // 7\n    remaining = money % 7\n\n    # Distribute 8 dollars to every child.\n    if count7 == children and remaining == 0:\n      return count7\n\n    # Need to move 1 dollar from the last child with 4 dollars to one of other\n    # children. That's why we need to substract 1.\n    if count7 == children - 1 and remaining == 3:\n      return count7 - 1\n\n    # Though there might be child with 4 dollars, since count7 < children - 1,\n    # we have 'extra' spot to move money to if needed.\n    return min(children - 1, count7)",
      "title": "2591. Distribute Money to Maximum Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd491078-581f-4e76-af91-74875cd94b51",
      "code": "class Solution:\n  def maximizeGreatness(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for num in nums:\n      if num > nums[ans]:\n        ans += 1\n\n    return ans",
      "title": "2592. Maximize Greatness of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6243e4d-df3f-4443-b5c3-1c63af230a53",
      "code": "class Solution:\n  def findScore(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n\n    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):\n      if i in seen:\n        continue\n      seen.add(i - 1)\n      seen.add(i + 1)\n      seen.add(i)\n      ans += num\n\n    return ans",
      "title": "2593. Find Score of an Array After Marking All Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9982dc8-d88c-44e6-82a2-5b33a7f3a290",
      "code": "class Solution:\n  def repairCars(self, ranks: list[int], cars: int) -> int:\n    def numCarsFixed(minutes: int) -> int:\n      #    r * n^2 = minutes\n      # -> n = sqrt(minutes / r)\n      return sum(math.isqrt(minutes // rank) for rank in ranks)\n\n    return bisect.bisect_left(range(min(ranks) * cars**2), cars,\n                              key=numCarsFixed)",
      "title": "2594. Minimum Time to Repair Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "778efae2-9126-4f2e-a83b-efb9c3668306",
      "code": "class Solution:\n  def evenOddBit(self, n: int) -> list[int]:\n    ans = [0] * 2\n    i = 0  # 0 := even, 1 := odd\n\n    while n > 0:\n      ans[i] += n & 1\n      n >>= 1\n      i ^= 1\n\n    return ans",
      "title": "2595. Number of Even and Odd Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4374ba97-56c9-4cb9-969c-e09d185ef1b3",
      "code": "class Solution:\n  def checkValidGrid(self, grid: list[list[int]]) -> bool:\n    if grid[0][0] != 0:\n      return False\n\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    n = len(grid)\n    i = 0\n    j = 0\n\n    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:\n      \"\"\"\n      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n      \"\"\"\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x >= n or y < 0 or y >= n:\n          continue\n        if grid[x][y] == target:\n          return (x, y)\n      return (-1, -1)\n\n    for target in range(1, n * n):\n      x, y = nextGrid(i, j, target)\n      if x == -1 and y == -1:\n        return False\n      # Move (x, y) to (i, j).\n      i = x\n      j = y\n\n    return True",
      "title": "2596. Check Knight Tour Configuration",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93a28d9a-2818-479d-b328-d8b164f82a0d",
      "code": "# e.g. nums = [2, 3, 4, 4], k = 2\n#\n# subset[0] = [2, 4, 4']\n# subset[1] = [1]\n# count = {2: 1, 4: 2, 1: 1}\n#\n# Initially, skip = len([]) = 0, pick = len([]) = 0\n#\n# * For values in subset[0]:\n#   After 2:\n#     skip = skip + pick = len([]) = 0\n#     pick = (2^count[2] - 1) * (1 + skip + pick)\n#          = len([[2]]) * len([[]])\n#          = len([[2]]) = 1\n#   After 4:\n#     skip = skip + pick = len([[2]]) = 1\n#     pick = (2^count[4] - 1) * (1 + skip)\n#          = len([[4], [4'], [4, 4']]) * len([[]])\n#          = len([[4], [4'], [4, 4']]) = 3\n#\n# * For values in subset[1]:\n#   After 1:\n#     skip = skip + pick\n#          = len([[2], [4], [4'], [4, 4']]) = 4\n#     pick = (2^count[1] - 1) * (1 + skip + pick)\n#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n#\n# So, ans = skip + pick = 9\n\nclass Solution:\n  def beautifulSubsets(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        nonEmptyCount = 2**count[num] - 1\n        skip, pick = (skip + pick,\n                      nonEmptyCount *\n                      (1 + skip + (0 if num - prevNum == k else pick)))\n        prevNum = num\n\n    return skip + pick",
      "title": "2597. The Number of Beautiful Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73cc263e-ff18-4602-b9fe-5cfb58f44ba3",
      "code": "class Solution:\n  def findSmallestInteger(self, nums: list[int], value: int) -> int:\n    count = collections.Counter([num % value for num in nums])\n\n    for i in range(len(nums)):\n      if count[i % value] == 0:\n        return i\n      count[i % value] -= 1\n\n    return len(nums)",
      "title": "2598. Smallest Missing Non-negative Integer After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4876f471-65c9-400e-9577-b687c2fdb3eb",
      "code": "class Solution:\n  def makePrefSumNonNegative(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    minHeap = []\n\n    for num in nums:\n      prefix += num\n      if num < 0:\n        heapq.heappush(minHeap, num)\n      while prefix < 0:\n        prefix -= heapq.heappop(minHeap)\n        ans += 1\n\n    return ans",
      "title": "2599. Make the Prefix Sum Non-negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db3912df-a1cd-49a0-8418-0343c0400675",
      "code": "class Solution:\n  def kItemsWithMaximumSum(\n      self,\n      numOnes: int,\n      numZeros: int,\n      numNegOnes: int,\n      k: int,\n  ) -> int:\n    if k <= numOnes:\n      return k\n    if k <= numOnes + numZeros:\n      return numOnes\n    return numOnes - (k - numOnes - numZeros)",
      "title": "2600. K Items With the Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f26d13a-1cb5-410e-ac23-1cb967ac9e29",
      "code": "class Solution:\n  def primeSubOperation(self, nums: list[int]) -> bool:\n    MAX = 1000\n    primes = self._sieveEratosthenes(MAX)\n\n    prevNum = 0\n    for num in nums:\n      # Make nums[i] the smallest as possible and still > nums[i - 1].\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]",
      "title": "2601. Prime Subtraction Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4387ce33-1c95-4f0a-886b-6f64cda39f21",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    prefix = list(itertools.accumulate(nums, initial=0))\n    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]\n    return [(query * i - prefix[i]) +\n            (prefix[-1] - prefix[i] - query * (n - i))\n            for query, i in splits]",
      "title": "2602. Minimum Operations to Make All Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad294898-0bdc-406b-9beb-8ba10b6dabe0",
      "code": "class Solution:\n  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      # Remove the leaves that don't have coins.\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v  # Walk up to its parent.\n      # After trimming leaves without coins, leaves with coins may satisfy\n      # `leavesToBeRemoved`.\n      if len(tree[u]) == 1:  # coins[u] must be 1.\n        leavesToBeRemoved.append(u)\n\n    # Remove each remaining leaf node and its parent. The remaining nodes are\n    # the ones that must be visited.\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:  # It's a leaf.\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)",
      "title": "2603. Collect Coins in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba595e85-1f18-4aad-a004-277a08280529",
      "code": "class Solution:\n  def minimumTime(self, hens: list[int], grains: list[int]) -> int:\n    hens.sort()\n    grains.sort()\n\n    def canEat(time: int) -> bool:\n      \"\"\"Returns True if `hens` can eat all `grains` within `time`.\"\"\"\n      i = 0  # grains[i] := next grain to be ate\n      for hen in hens:\n        rightMoves = time\n        if grains[i] < hen:\n          # `hen` needs go back to eat `grains[i]`.\n          leftMoves = hen - grains[i]\n          if leftMoves > time:\n            return False\n          leftThenRight = time - 2 * leftMoves\n          rightThenLeft = (time - leftMoves) // 2\n          rightMoves = max(0, leftThenRight, rightThenLeft)\n        i = bisect.bisect_right(grains, hen + rightMoves)\n        if i == len(grains):\n          return True\n      return False\n\n    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))\n    return bisect.bisect_left(range(maxMoves), True, key=canEat)",
      "title": "2604. Minimum Time to Eat All Grains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ec34c60-db42-4f6d-b228-83b32df149d9",
      "code": "class Solution:\n  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(a if a == b else min(a, b) * 10 + max(a, b)\n               for a in nums1\n               for b in nums2)",
      "title": "2605. Form Smallest Number From Two Digit Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db3fecc2-2ce9-40c7-84a2-0e5d3e7be598",
      "code": "class Solution:\n  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:\n    ans = 0\n    cost = 0\n    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i\n\n    for c, val in zip(chars, vals):\n      costs[ord(c) - ord('a')] = val\n\n    for c in s:\n      cost = max(0, cost + costs[ord(c) - ord('a')])\n      ans = max(ans, cost)\n\n    return ans",
      "title": "2606. Find the Substring With Maximum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a561232d-d615-4bc8-ad98-325a02aa9a81",
      "code": "class Solution:\n  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:\n    # If the sum of each subarray of length k is equal, then `arr` must have a\n    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    # arr[(i + k) % n] for every i.\n    n = len(arr)\n    ans = 0\n    seen = [0] * n\n\n    for i in range(n):\n      groups = []\n      j = i\n      while not seen[j]:\n        groups.append(arr[j])\n        seen[j] = True\n        j = (j + k) % n\n      groups.sort()\n      for num in groups:\n        ans += abs(num - groups[len(groups) // 2])\n\n    return ans",
      "title": "2607. Make K-Subarray Sums Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9954d6bf-da1e-40df-9c07-4a4f5b01f2b1",
      "code": "class Solution:\n  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:\n    INF = 1001\n    ans = INF\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(i: int) -> int:\n      \"\"\"Returns the length of the minimum cycle by starting BFS from node `i`.\n\n      Returns `INF` if there's no cycle.\n      \"\"\"\n      dist = [INF] * n\n      q = collections.deque([i])\n      dist[i] = 0\n      while q:\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            q.append(v)\n          elif dist[v] + 1 != dist[u]:   # v is not a parent u.\n            return dist[v] + dist[u] + 1\n      return INF\n\n    ans = min(map(bfs, range(n)))\n    return -1 if ans == INF else ans",
      "title": "2608. Shortest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d3ef778-4298-4e2d-a4b8-e07755733a99",
      "code": "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      zeros = 0\n      ones = 0\n      while i < len(s) and s[i] == '0':\n        zeros += 1\n        i += 1\n      while i < len(s) and s[i] == '1':\n        ones += 1\n        i += 1\n      ans = max(ans, min(zeros, ones))\n\n    return ans * 2",
      "title": "2609. Find the Longest Balanced Substring of a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e95bd24-7bde-4b50-b1f3-ab22ffd998e6",
      "code": "class Solution:\n  def findMatrix(self, nums: list[int]) -> list[list[int]]:\n    # The number of rows we need equals the maximum frequency.\n    ans = []\n    count = [0] * (len(nums) + 1)\n\n    for num in nums:\n      count[num] += 1\n      # Construct `ans` on demand.\n      if count[num] > len(ans):\n        ans.append([])\n      ans[count[num] - 1].append(num)\n\n    return ans",
      "title": "2610. Convert an Array Into a 2D Array With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55187a27-6883-41ac-a121-b8dd22112bf2",
      "code": "class Solution:\n  def miceAndCheese(\n      self,\n      reward1: list[int],\n      reward2: list[int],\n      k: int,\n  ) -> int:\n    return (sum(reward2) +\n            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))",
      "title": "2611. Mice and Cheese",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78b75049-e169-4afa-85ed-f0dd5425b572",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minReverseOperations(\n      self,\n      n: int,\n      p: int,\n      banned: list[int],\n      k: int,\n  ) -> list[int]:\n    bannedSet = set(banned)\n    ans = [-1] * n\n    # unseen[i] := the unseen numbers that % 2 == i\n    unseen = [SortedList(), SortedList()]\n\n    for num in range(n):\n      if num != p and num not in bannedSet:\n        unseen[num % 2].add(num)\n\n    # Perform BFS from `p`.\n    q = collections.deque([p])\n    ans[p] = 0\n\n    while q:\n      u = q.popleft()\n      lo = max(u - k + 1, k - 1 - u)\n      hi = min(u + k - 1, n - 1 - (u - (n - k)))\n      # Choose the correct set of numbers.\n      nums = unseen[lo % 2]\n      i = nums.bisect_left(lo)\n      while i < len(nums) and nums[i] <= hi:\n        num = nums[i]\n        ans[num] = ans[u] + 1\n        q.append(num)\n        nums.pop(i)\n\n    return ans",
      "title": "2612. Minimum Reverse Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9a647f0-2764-47ff-8672-862a9c262580",
      "code": "class Solution:\n  def diagonalPrime(self, nums: list[list[int]]) -> int:\n    def isPrime(n: int) -> bool:\n      if n <= 1:\n        return False\n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          return False\n      return True\n\n    primes1 = [row[i]\n               for i, row in enumerate(nums) if isPrime(row[i])]\n    primes2 = [row[-1 - i]\n               for i, row in enumerate(nums) if isPrime(row[-1 - i])]\n    return max(max(primes1) if primes1 else 0,\n               max(primes2) if primes2 else 0)",
      "title": "2614. Prime In Diagonal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce06868e-b8a0-413b-b666-791766c84ed6",
      "code": "class Solution:\n  def distance(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      n = len(indices)\n      if n == 1:\n        continue\n      sumSoFar = sum(indices)\n      prevIndex = 0\n      for i in range(n):\n        sumSoFar += (i - 1) * (indices[i] - prevIndex)\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)\n        ans[indices[i]] = sumSoFar\n        prevIndex = indices[i]\n\n    return ans",
      "title": "2615. Sum of Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a325644b-4298-417d-90c1-ff9181106846",
      "code": "class Solution:\n  def minimizeMax(self, nums: list[int], p: int) -> int:\n    nums.sort()\n\n    def numPairs(maxDiff: int) -> int:\n      \"\"\"\n      Returns the number of pairs that can be obtained if the difference between\n      each pair <= `maxDiff`.\n      \"\"\"\n      pairs = 0\n      i = 1\n      while i < len(nums):\n        # Greedily pair nums[i] with nums[i - 1].\n        if nums[i] - nums[i - 1] <= maxDiff:\n          pairs += 1\n          i += 2\n        else:\n          i += 1\n      return pairs\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), p, key=numPairs)",
      "title": "2616. Minimize the Maximum Difference of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42d64ba5-fd28-446d-af91-97d365f90522",
      "code": "class Solution:\n  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        skip, pick = (skip + pick,\n                      1 + skip + (0 if num - prevNum == k else pick))\n        prevNum = num\n\n    return 1 + skip + pick",
      "title": "2638. Count the Number of K-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b2702a4-5cd9-4f01-ac55-f72653dcd581",
      "code": "class Solution:\n  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:\n    return [max(map(len, map(str, col))) for col in zip(*grid)]",
      "title": "2639. Find the Width of Columns of a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37394584-5850-42e6-bed0-44a72b0c2890",
      "code": "class Solution:\n  def findPrefixScore(self, nums: list[int]) -> list[int]:\n    conver = []\n    mx = 0\n\n    for num in nums:\n      mx = max(mx, num)\n      conver.append(num + mx)\n\n    return itertools.accumulate(conver)",
      "title": "2640. Find the Score of All Prefixes of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c291b0db-0b2c-497d-b0ce-e7148e9643ef",
      "code": "class Solution:\n  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    def replace(\n        root: TreeNode | None,\n        level: int, curr: TreeNode | None,\n    ) -> TreeNode | None:\n      nextLevel = level + 1\n      nextLevelCousinsSum = (\n          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -\n          (root.left.val if root.left else 0) -\n          (root.right.val if root.right else 0))\n      if root.left:\n        curr.left = TreeNode(nextLevelCousinsSum)\n        replace(root.left, level + 1, curr.left)\n      if root.right:\n        curr.right = TreeNode(nextLevelCousinsSum)\n        replace(root.right, level + 1, curr.right)\n      return curr\n\n    dfs(root, 0)\n    return replace(root, 0, TreeNode(0))",
      "title": "2641. Cousins in Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbc88dbb-45f5-4dbe-aa35-5c1c8ed1ab37",
      "code": "class Solution:\n  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:\n    ans = [0, 0]\n\n    for i, row in enumerate(mat):\n      ones = row.count(1)\n      if ones > ans[1]:\n        ans[0] = i\n        ans[1] = ones\n\n    return ans",
      "title": "2643. Row With Maximum Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca80be4f-2324-42c8-af6c-b78a5303eb4f",
      "code": "class Solution:\n  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:\n    ans = -1\n    maxScore = -1\n\n    for divisor in divisors:\n      score = sum([1 for num in nums if num % divisor == 0])\n      if score > maxScore:\n        ans = divisor\n        maxScore = score\n      elif score == maxScore:\n        ans = min(ans, divisor)\n\n    return ans",
      "title": "2644. Find the Maximum Divisibility Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9a58fb1-a78d-4cf7-ae98-e43462bdc59b",
      "code": "class Solution:\n  def addMinimum(self, word: str) -> int:\n    letters = ['a', 'b', 'c']\n    ans = 0\n    i = 0\n\n    while i < len(word):\n      for c in letters:\n        if i < len(word) and word[i] == c:\n          i += 1\n        else:\n          ans += 1\n\n    return ans",
      "title": "2645. Minimum Additions to Make Valid String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccba68f4-b318-47e3-8da0-0038cb4a67e4",
      "code": "class Solution:\n  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],\n                        trips: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # count[i] := the number of times i is traversed\n    count = [0] * n\n\n    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:\n      path.append(u)\n      if u == end:\n        for i in path:\n          count[i] += 1\n        return\n      for v in graph[u]:\n        if v != prev:\n          dfsCount(v, u, end,  path)\n      path.pop()\n\n    for start, end in trips:\n      dfsCount(start, -1, end, [])\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, parentHalved: bool) -> int:\n      \"\"\"\n      Returns the minimum price sum for the i-th node, where its parent is\n      halved parent or not halved not.\n      \"\"\"\n      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)\n                                                  for v in graph[u]\n                                                  if v != prev)\n      if parentHalved:  # Can't halve this node if its parent was halved.\n        return sumWithFullNode\n      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)\n                                                           for v in graph[u]\n                                                           if v != prev)\n      return min(sumWithFullNode, sumWithHalvedNode)\n\n    return dfs(0, -1, False)",
      "title": "2646. Minimize the Total Price of the Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83fbd663-2e20-44c3-9b74-b2d9df024d40",
      "code": "class Solution:\n  def colorRed(self, n: int) -> list[list[int]]:\n    ans = []\n    tipSize = n % 4\n\n    # The tip of the triangle is always painted red.\n    if tipSize >= 1:\n      ans.append([1, 1])\n\n    # Pamost right and most left elements at the following rows.\n    for i in range(2, tipSize + 1):\n      ans.append([i, 1])\n      ans.append([i, 2 * i - 1])\n\n    # Pa4-row chunks.\n    for i in range(tipSize + 1, n, 4):\n      # Fill the first row of the chunk.\n      ans.append([i, 1])\n      # Fill the second row.\n      for j in range(1, i + 1):\n        ans.append([i + 1, 2 * j + 1])\n      # Fill the third row.\n      ans.append([i + 2, 2])\n      # Fill the fourth row.\n      for j in range(i + 2 + 1):\n        ans.append([i + 3, 2 * j + 1])\n\n    return ans",
      "title": "2647. Color the Triangle Red",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cdb1898-93a7-4374-b11e-310805dbeea5",
      "code": "class Solution:\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n    return (arrivalTime + delayedTime) % 24",
      "title": "2651. Calculate Delayed Arrival Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7461c475-e405-4b4a-aaf8-6098567db7ff",
      "code": "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    def sumOfMultiples(value: int) -> int:\n      \"\"\"Returns the sum of multiples of value in [1, n].\"\"\"\n      lo = value\n      hi = (n // value) * value\n      count = (hi - lo) // value + 1\n      return (lo + hi) * count // 2\n\n    return (sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n            (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n            sumOfMultiples(105))",
      "title": "2652. Sum Multiples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9982973c-1f7e-424f-8c23-c492a50a73dc",
      "code": "class Solution:\n  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    count = [0] * 50  # count[i] := the frequency of (i + 50)\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: list[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0",
      "title": "2653. Sliding Subarray Beauty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3c933ed-100a-41b1-a2d4-1ca7880322bf",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ones = nums.count(1)\n    if ones > 0:\n      return n - ones\n\n    # the minimum operations to make the shortest subarray with a gcd == 1\n    minOps = math.inf\n\n    for i, g in enumerate(nums):\n      for j in range(i + 1, n):\n        g = math.gcd(g, nums[j])\n        if g == 1:   # gcd(nums[i..j]:== 1\n          minOps = min(minOps, j - i)\n          break\n\n    # After making the shortest subarray with `minOps`, need additional n - 1\n    # operations to make the other numbers to 1.\n    return -1 if minOps == math.inf else minOps + n - 1",
      "title": "2654. Minimum Number of Operations to Make All Array Elements Equal to 1",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5413e15f-1579-49a0-8674-76fb12519729",
      "code": "class Solution:\n  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:\n    ans = []\n    start = 0\n\n    for l, r in sorted(ranges):\n      if start < l:\n        ans.append([start, l - 1])\n      if start <= r:\n        start = r + 1\n\n    if start < n:\n      ans.append([start, n - 1])\n\n    return ans",
      "title": "2655. Find Maximal Uncovered Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67e350e9-0592-48c9-b9f5-275381298d33",
      "code": "class Solution:\n  def maximizeSum(self, nums: list[int], k: int) -> int:\n    return max(nums) * k + k * (k - 1) // 2",
      "title": "2656. Maximum Sum With Exactly K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18887070-6e8b-49b5-b417-c9fa8de09109",
      "code": "class Solution:\n  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n    n = len(A)\n    prefixCommon = 0\n    ans = []\n    count = [0] * (n + 1)\n\n    for a, b in zip(A, B):\n      count[a] += 1\n      if count[a] == 2:\n        prefixCommon += 1\n      count[b] += 1\n      if count[b] == 2:\n        prefixCommon += 1\n      ans.append(prefixCommon)\n\n    return ans",
      "title": "2657. Find the Prefix Common Array of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdbe6b4f-88f0-4396-b5be-70871c73a445",
      "code": "class Solution:\n  def findMaxFish(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n      caughtFish = grid[i][j]\n      grid[i][j] = 0  # Mark 0 as visited\n      return (caughtFish +\n              dfs(i + 1, j) + dfs(i - 1, j) +\n              dfs(i, j + 1) + dfs(i, j - 1))\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "2658. Maximum Number of Fish in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75121c71-453d-44aa-8358-27a35d589c7f",
      "code": "class Solution:\n  def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    nums.sort()\n\n    for i in range(1, n):\n      # On the i-th step we've already removed the i - 1 smallest numbers and\n      # can ignore them. If an element nums[i] has smaller index in origin\n      # array than nums[i - 1], we should rotate the whole left array n - i\n      # times to set nums[i] element on the first position.\n      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:\n        ans += n - i\n\n    return ans",
      "title": "2659. Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4df80aca-d74d-4cdd-b04d-067fa22d9bd9",
      "code": "class Solution:\n  def isWinner(self, player1: list[int], player2: list[int]) -> int:\n    def getScore(player: list[int]) -> int:\n      INVALID = -3\n      score = 0\n      last10 = INVALID\n      for i, p in enumerate(player):\n        score += p if i - last10 > 2 else p * 2\n        if p == 10:\n          last10 = i\n      return score\n\n    score1 = getScore(player1)\n    score2 = getScore(player2)\n    if score1 > score2:\n      return 1\n    if score2 > score1:\n      return 2\n    return 0",
      "title": "2660. Determine the Winner of a Bowling Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d27a9390-4876-4b52-a0b8-d26e7b60568b",
      "code": "class Solution:\n  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    # rows[i] := the number of painted grid in the i-th row\n    rows = [0] * m\n    # cols[j] := the number of painted grid in the j-th column\n    cols = [0] * n\n    # numToRow[num] := the i-th row of `num` in `mat`\n    numToRow = [0] * (m * n + 1)\n    # numToCol[num] := the j-th column of `num` in `mat`\n    numToCol = [0] * (m * n + 1)\n\n    for i, row in enumerate(mat):\n      for j, num in enumerate(row):\n        numToRow[num] = i\n        numToCol[num] = j\n\n    for i, a in enumerate(arr):\n      rows[numToRow[a]] += 1\n      if rows[numToRow[a]] == n:\n        return i\n      cols[numToCol[a]] += 1\n      if cols[numToCol[a]] == m:\n        return i",
      "title": "2661. First Completely Painted Row or Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d19433aa-fa0a-4ec2-b29f-a51ad34d409a",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      start: list[int],\n      target: list[int],\n      specialRoads: list[list[int]],\n  ) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(\n      self,\n      specialRoads: list[list[int]],\n      srcX: int,\n      srcY: int,\n      dstX: int,\n      dstY: int,\n  ) -> int:\n    n = len(specialRoads)\n    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)\n    dist = [math.inf] * n\n    minHeap = []  # (d, u), where u := the i-th specialRoads\n\n    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans",
      "title": "2662. Minimum Cost of a Path With Special Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50eb712-6d67-4568-ba78-38174f95e71a",
      "code": "class Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        # If s[i] is among the first k letters, then change the letters after\n        # s[i] to the smallest ones that don't form any palindrome substring.\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: list[str], i: int) -> bool:\n    \"\"\"Returns True if chars[0..i] contains palindrome.\"\"\"\n    return ((i > 0 and chars[i] == chars[i - 1]) or\n            (i > 1 and chars[i] == chars[i - 2]))\n\n  def _changeSuffix(self, chars: list[str], i: int) -> str:\n    \"\"\"\n    Returns a string, where replacing sb[i..n) with the smallest possible\n    letters don't form any palindrome substring.\n    \"\"\"\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)",
      "title": "2663. Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5e7a63d-46ed-4846-bd8a-40d14d5f9bd0",
      "code": "class Solution:\n  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    ans = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, step: int) -> bool:\n      if step == m * n:\n        return True\n      if i < 0 or i >= m or j < 0 or j >= n:\n        return False\n      if ans[i][j] != -1:\n        return False\n      ans[i][j] = step\n      for dx, dy in DIRS:\n        if dfs(i + dx, j + dy, step + 1):\n          return True\n      ans[i][j] = -1\n      return False\n\n    dfs(r, c, 0)\n    return ans",
      "title": "2664. The Knightâ€™s Tour",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "240787e0-c721-4c4d-b785-6cbb41f47701",
      "code": "class Solution:\n  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:\n    MAX = 50\n    ans = []\n    prefixCount = [0] * (MAX + 1)\n    suffixCount = [0] * (MAX + 1)\n    distinctPrefix = 0\n    distinctSuffix = 0\n\n    for num in nums:\n      if suffixCount[num] == 0:\n        distinctSuffix += 1\n      suffixCount[num] += 1\n\n    for num in nums:\n      if prefixCount[num] == 0:\n        distinctPrefix += 1\n      prefixCount[num] += 1\n      if suffixCount[num] == 1:\n        distinctSuffix -= 1\n      suffixCount[num] -= 1\n      ans.append(distinctPrefix - distinctSuffix)\n\n    return ans",
      "title": "2670. Find the Distinct Difference Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "052ad8ab-f2b8-4e0e-94bd-00e246c9a350",
      "code": "class Solution:\n  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans",
      "title": "2672. Number of Adjacent Elements With the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eeecfa8-497c-48b2-8ce3-c2856dca1f87",
      "code": "class Solution:\n  def minIncrements(self, n: int, cost: list[int]) -> int:\n    ans = 0\n\n    for i in range(n // 2 - 1, -1, -1):\n      l = i * 2 + 1\n      r = i * 2 + 2\n      ans += abs(cost[l] - cost[r])\n      # Record the information in the parent from the children. So, there's need to actually\n      # update the values in the children.\n      cost[i] += max(cost[l], cost[r])\n\n    return ans",
      "title": "2673. Make Costs of Paths Equal in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33e1cd49-8008-4199-8eae-3dbfe0f3f044",
      "code": "class Solution:\n  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:\n    slow = list\n    fast = list\n\n    # Point `slow` to the last node in the first half.\n    while fast.next != list and fast.next.next != list:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Circle back the second half.\n    secondHead = slow.next\n    if fast.next == list:\n      fast.next = secondHead\n    else:\n      fast.next.next = secondHead\n\n    # Circle back the first half.\n    slow.next = list\n\n    return [list, secondHead]",
      "title": "2674. Split a Circular Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52609495-1fc3-4fda-8fc5-8ba55da8b1ad",
      "code": "class Solution:\n  def countSeniors(self, details: list[str]) -> int:\n    return sum(int(detail[11:13]) > 60 for detail in details)",
      "title": "2678. Number of Senior Citizens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3d36893-4db6-4f47-9351-57348f434b7b",
      "code": "class Solution:\n  def matrixSum(self, nums: list[list[int]]) -> int:\n    for row in nums:\n      row.sort()\n\n    return sum(max(col) for col in zip(*nums))",
      "title": "2679. Sum in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cd687a9-2f54-4f63-899a-5c35a3728a1a",
      "code": "class Solution:\n  def maximumOr(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    prefix = [0] * n\n    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    suffix = [0] * n\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] | nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n      suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    # For each num, greedily shift it left by k bits.\n    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))",
      "title": "2680. Maximum OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfae9369-7823-46fc-a8c1-9f03954601f5",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    summ = 0\n\n    for num in sorted(nums):\n      ans += (num + summ) * num**2\n      ans %= MOD\n      summ = (summ * 2 + num) % MOD\n\n    return ans",
      "title": "2681. Power of Heroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c269000-9c62-42a2-8319-5b0b2aac2117",
      "code": "class Solution:\n  def circularGameLosers(self, n: int, k: int) -> list[int]:\n    seen = [False] * n\n    friendIndex = 0\n    turn = 1\n\n    while not seen[friendIndex]:\n      seen[friendIndex] = True\n      friendIndex += turn * k\n      friendIndex %= n\n      turn += 1\n\n    return [friendIndex + 1\n            for friendIndex in range(n)\n            if not seen[friendIndex]]",
      "title": "2682. Find the Losers of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02f09cd8-d85d-422f-9ede-61e5b7e4ff4b",
      "code": "class Solution:\n  def doesValidArrayExist(self, derived: list[int]) -> bool:\n    return functools.reduce(operator.xor, derived) == 0",
      "title": "2683. Neighboring Bitwise XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "208b1991-6610-4258-b526-246b32a23bab",
      "code": "class Solution:\n  def maxMoves(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the maximum number of moves you can perform from (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))",
      "title": "2684. Maximum Number of Moves in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bdb4a6a-77da-4b69-913f-bea1da175c99",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans",
      "title": "2685. Count the Number of Complete Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e906508a-4db0-4b97-a176-75c9171c9120",
      "code": "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    if root.len == 0:\n      return root.val[k - 1]\n    leftLen = (0 if not root.left\n               else max(root.left.len, len(root.left.val)))\n    if leftLen >= k:\n      return self.getKthCharacter(root.left, k)\n    return self.getKthCharacter(root.right, k - leftLen)",
      "title": "2689. Extract Kth Character From The Rope Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebdac175-06fe-4098-96a8-42a248753cba",
      "code": "class Solution:\n  def minLength(self, s: str) -> int:\n    stack = []\n\n    def match(c: str) -> bool:\n      return stack and stack[-1] == c\n\n    for c in s:\n      if c == 'B' and match('A'):\n        stack.pop()\n      elif c == 'D' and match('C'):\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return len(stack)",
      "title": "2696. Minimum String Length After Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "709e9af0-bad4-4595-a096-781bfc534f4d",
      "code": "class Solution:\n  def makeSmallestPalindrome(self, s: str) -> str:\n    chars = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      minChar = min(chars[i], chars[j])\n      chars[i] = minChar\n      chars[j] = minChar\n      i += 1\n      j -= 1\n\n    return ''.join(chars)",
      "title": "2697. Lexicographically Smallest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe1b3a74-4e74-4a72-9aaa-3e6c4cbc039f",
      "code": "class Solution:\n  def punishmentNumber(self, n: int) -> int:\n    def isPossible(\n            accumulate: int, running: int, numChars: list[str],\n            s: int, target: int) -> bool:\n      \"\"\"\n      Returns True if the sum of any split of `numChars` equals to the target.\n      \"\"\"\n      if s == len(numChars):\n        return target == accumulate + running\n      d = int(numChars[s])\n      return (\n          # Keep growing `running`.\n          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or\n          # Start a new `running`.\n          isPossible(accumulate + running, d, numChars, s + 1, target)\n      )\n\n    return sum(i * i\n               for i in range(1, n + 1)\n               if isPossible(0, 0, str(i * i), 0, i))",
      "title": "2698. Find the Punishment Number of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e950494-cbc4-4cd2-a7d3-9003a90f4c51",
      "code": "class Solution:\n  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:\n    MAX = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      # Change the weights of negative edges to an impossible value.\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = MAX\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        # Change the weights of negative edges to an impossible value.\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = MAX\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]",
      "title": "2699. Modify Graph Edge Weights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cb8539d-84b0-4803-9939-ecc77d885c85",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int, y: int) -> int:\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if it's possible to make all `nums` <= 0 using m operations.\n      \"\"\"\n      # If we want m operations, first decrease all the numbers by y * m. Then\n      # we have m operations to select indices to decrease them by x - y.\n      return sum(max(0, math.ceil((num - y * m) / (x - y)))\n                 for num in nums) <= m\n\n    return bisect.bisect_left(range(max(nums)), True, key=isPossible)",
      "title": "2702. Minimum Operations to Make Numbers Non-positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fcf1633-e4b5-4ed6-a978-7c7a2bae8882",
      "code": "class Solution:\n  def buyChoco(self, prices: list[int], money: int) -> int:\n    min1 = math.inf\n    min2 = math.inf\n\n    for price in prices:\n      if price <= min1:\n        min2 = min1\n        min1 = price\n      elif price < min2:\n        min2 = price\n\n    minCost = min1 + min2\n    return money if minCost > money else money - minCost",
      "title": "2706. Buy Two Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "311c4143-1590-4d4f-93b1-4bc4efe7813e",
      "code": "class Solution:\n  # Similar to 139. Word Break\n  def minExtraChar(self, s: str, dictionary: list[str]) -> int:\n    n = len(s)\n    dictionarySet = set(dictionary)\n    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    dp = [0] + [n] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        if s[j:i] in dictionarySet:\n          dp[i] = min(dp[i], dp[j])\n        else:\n          dp[i] = min(dp[i], dp[j] + i - j)\n\n    return dp[n]",
      "title": "2707. Extra Characters in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3454c4c2-0f6e-46f4-831d-66349c1870e3",
      "code": "class Solution:\n  def maxStrength(self, nums: list[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:  # num == 0\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg",
      "title": "2708. Maximum Strength of a Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66b1834c-ac14-4ada-b37d-7970c8169cad",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: list[int]) -> bool:\n    n = len(nums)\n    mx = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(mx + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "2709. Greatest Common Divisor Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7223ff3-5af8-4112-b2af-d2ff8c1ced75",
      "code": "class Solution:\n  def removeTrailingZeros(self, num: str) -> str:\n    return num.rstrip('0')",
      "title": "2710. Remove Trailing Zeros From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee28a464-e53b-4ee8-a09b-99f38c9e6833",
      "code": "class Solution:\n  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    def fillInDiagonal(i: int, j: int) -> None:\n      topLeft = set()\n      bottomRight = set()\n\n      # Fill in the diagonal from the top-left to the bottom-right.\n      while i < len(grid) and j < len(grid[0]):\n        ans[i][j] = len(topLeft)\n        # Post-addition, so this information can be utilized in subsequent cells.\n        topLeft.add(grid[i][j])\n        i += 1\n        j += 1\n\n      i -= 1\n      j -= 1\n\n      # Fill in the diagonal from the bottom-right to the top-left.\n      while i >= 0 and j >= 0:\n        ans[i][j] = abs(ans[i][j] - len(bottomRight))\n        # Post-addition, so this information can be utilized in subsequent cells.\n        bottomRight.add(grid[i][j])\n        i -= 1\n        j -= 1\n\n    for i in range(m):\n      fillInDiagonal(i, 0)\n\n    for j in range(1, n):\n      fillInDiagonal(0, j)\n\n    return ans",
      "title": "2711. Difference of Number of Distinct Values on Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7614d73-debd-4a4b-b18d-08f72e7f790b",
      "code": "class Solution:\n  def minimumCost(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(1, n):\n      if s[i] != s[i - 1]:\n        # Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i)\n\n    return ans",
      "title": "2712. Minimum Cost to Make All Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d66f439b-8ebf-4e71-ae46-bb940935772b",
      "code": "class Solution:\n  def maxIncreasingCells(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m  # rows[i] := the maximum path length for the i-th row\n    cols = [0] * n  # cols[j] := the maximum path length for the j-th column\n    valToIndices = collections.defaultdict(list)\n    # maxPathLength[i][j] := the maximum path length from mat[i][j]\n    maxPathLength = [[0] * n for _ in range(m)]\n    # Sort all the unique values in the matrix in non-increasing order.\n    decreasingSet = set()\n\n    for i in range(m):\n      for j in range(n):\n        val = mat[i][j]\n        valToIndices[val].append((i, j))\n        decreasingSet.add(val)\n\n    for val in sorted(decreasingSet, reverse=True):\n      for i, j in valToIndices[val]:\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1\n      for i, j in valToIndices[val]:\n        rows[i] = max(rows[i], maxPathLength[i][j])\n        cols[j] = max(cols[j], maxPathLength[i][j])\n\n    return max(max(rows), max(cols))",
      "title": "2713. Maximum Strictly Increasing Cells in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78c1d05c-7d05-4e0f-be51-ea65658fcf73",
      "code": "class Solution:\n  # Similar to 787. Cheapest Flights Within K Stops\n  def shortestPathWithHops(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      d: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, s, d, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]\n\n    dist[src][k] = 0\n    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)\n\n    while minHeap:\n      d, u, hops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if dist[u][hops] > d:\n        continue\n      for v, w in graph[u]:\n        # Go from u -> v with w cost.\n        if d + w < dist[v][hops]:\n          dist[v][hops] = d + w\n          heapq.heappush(minHeap, (dist[v][hops], v, hops))\n        # Hop from u -> v with 0 cost.\n        if hops > 0 and d < dist[v][hops - 1]:\n          dist[v][hops - 1] = d\n          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))",
      "title": "2714. Find Shortest Path with K Hops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b9f139b-18fa-4a88-ac31-0d0d1452839b",
      "code": "class Solution:\n  def minimizedStringLength(self, s: str) -> int:\n    return len({*s})",
      "title": "2716. Minimize String Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9db2cfe-a9be-422d-807d-8b90f3a7f48e",
      "code": "class Solution:\n  def semiOrderedPermutation(self, nums: list[int]) -> int:\n    n = len(nums)\n    index1 = nums.index(1)\n    indexN = nums.index(n)\n    return index1 + (n - 1 - indexN) - int(index1 > indexN)",
      "title": "2717. Semi-Ordered Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4bdc97a-1e6e-4d80-bd1e-417ddd0ee3b0",
      "code": "class Solution:\n  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:\n    ans = 0\n    # seen[0] := row, seen[1] := col\n    seen = [[False] * n for _ in range(2)]\n    # notSet[0] = row, notSet[1] := col\n    notSet = [n] * 2\n\n    # Late queries dominate.\n    for type, index, val in reversed(queries):\n      if not seen[type][index]:\n        ans += val * notSet[type ^ 1]\n        seen[type][index] = True\n        notSet[type] -= 1\n\n    return ans",
      "title": "2718. Sum of Matrix After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8d78622-ebab-4921-9347-f9dd827ec1d0",
      "code": "# Definition for a street.\n# class Street:\n#   def openDoor(self):\n#     pass\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\n#   def moveLeft(self):\n#     pass\n\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    for _ in range(k):\n      if street.isDoorOpen():\n        street.closeDoor()\n      street.moveRight()\n\n    for ans in range(k + 1):\n      if street.isDoorOpen():\n        return ans\n      street.openDoor()\n      street.moveRight()",
      "title": "2728. Count Houses in a Circular Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08eea387-2e55-45ad-9fd4-19bbb8341c3f",
      "code": "class Solution:\n  def isFascinating(self, n):\n    s = str(n) + str(2 * n) + str(3 * n)\n    return ''.join(sorted(s)) == '123456789'",
      "title": "2729. Check if The Number is Fascinating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fc90f1f-bb02-47c3-88a8-1da630bffa82",
      "code": "class Solution:\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\n    ans = 1\n    prevStart = 0\n    start = 0\n\n    for i in range(1, len(s)):\n      if s[i] == s[i - 1]:\n        if prevStart > 0:\n          start = prevStart\n        prevStart = i\n      ans = max(ans, i - start + 1)\n\n    return ans",
      "title": "2730. Find the Longest Semi-Repetitive Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7292b2f-5e6d-44d6-9e55-782e640a529d",
      "code": "class Solution:\n  def sumDistance(self, nums: list[int], s: str, d: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    pos = sorted([num - d if c == 'L' else num + d\n                  for num, c in zip(nums, s)])\n\n    for i, p in enumerate(pos):\n      ans = ((ans + i * p - prefix) % MOD + MOD) % MOD\n      prefix = ((prefix + p) % MOD + MOD) % MOD\n\n    return ans",
      "title": "2731. Movement of Robots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fc7b7b8-4161-4083-86ba-f96f747d8e55",
      "code": "class Solution:\n  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:\n    MAX_BIT = 30\n    maskToIndex = {}\n\n    def getMask(row: list[int]) -> int:\n      mask = 0\n      for i, num in enumerate(row):\n        if num == 1:\n          mask |= 1 << i\n      return mask\n\n    for i, row in enumerate(grid):\n      mask = getMask(row)\n      if mask == 0:\n        return [i]\n      for prevMask in range(1, MAX_BIT):\n        if (mask & prevMask) == 0 and prevMask in maskToIndex:\n          return [maskToIndex[prevMask], i]\n      maskToIndex[mask] = i\n\n    return []",
      "title": "2732. Find a Good Subset of the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5df7f704-ea6d-49f5-8bc3-3487d75e2922",
      "code": "class Solution:\n  def findNonMinOrMax(self, nums: list[int]) -> int:\n    return -1 if len(nums) < 3 else sorted(nums[:3])[1]",
      "title": "2733. Neither Minimum nor Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86d8652b-f433-4e86-8105-c41b958b5222",
      "code": "class Solution:\n  def smallestString(self, s: str) -> str:\n    chars = list(s)\n    n = len(s)\n    i = 0\n\n    while i < n and chars[i] == 'a':\n      i += 1\n    if i == n:\n      chars[-1] = 'z'\n      return ''.join(chars)\n\n    while i < n and s[i] != 'a':\n      chars[i] = chr(ord(chars[i]) - 1)\n      i += 1\n\n    return ''.join(chars)",
      "title": "2734. Lexicographically Smallest String After Substring Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37b62ab3-ca46-43f7-9bee-56abf4222dc5",
      "code": "class Solution:\n  def minCost(self, nums: list[int], x: int) -> int:\n    n = len(nums)\n    ans = math.inf\n    # minCost[i] := the minimum cost to collect the i-th type\n    minCost = [math.inf] * n\n\n    for rotate in range(n):\n      for i in range(n):\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])\n      ans = min(ans, sum(minCost) + rotate * x)\n\n    return ans",
      "title": "2735. Collecting Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "acb8839e-f348-47da-8be5-e6dda782b770",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Pair:\n  x: int\n  y: int\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  minX: int\n  minY: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])\n                                          for i, query in enumerate(queries)],\n                                         key=lambda x: -x.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        # x + y is a better candidate. Given that x is decreasing, the\n        # condition \"x + y >= stack[-1][1]\" suggests that y is relatively\n        # larger, thereby making it a better candidate.\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2736. Maximum Sum Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "517ba101-0fb6-40cf-b67e-5d6b6f3e733e",
      "code": "class Solution:\n  def minimumDistance(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      marked: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    dist = self._dijkstra(graph, s)\n    ans = min(dist[u] for u in marked)\n    return -1 if ans == math.inf else ans\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2737. Find the Closest Marked Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42ff1f59-210e-4ea1-be51-51d3fd6dd873",
      "code": "class Solution:\n  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n    # M  M M M M  A  M M M M   A\n    # 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10",
      "title": "2739. Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94d54c48-3682-4f1e-9dd6-e6b49e258bb0",
      "code": "class Solution:\n  def findValueOfPartition(self, nums: list[int]) -> int:\n    return min(b - a for a, b in itertools.pairwise(sorted(nums)))",
      "title": "2740. Find the Value of the Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ab0226f-e267-4023-8de5-477eb3b528b6",
      "code": "class Solution:\n  def specialPerm(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxMask = 1 << len(nums)\n\n    @functools.lru_cache(None)\n    def dp(prev: int, mask: int) -> int:\n      \"\"\"\n      Returns the number of special permutations, where the previous number is\n      nums[i] and `mask` is the bitmask of the used numbers.\n      \"\"\"\n      if mask == maxMask - 1:\n        return 1\n\n      res = 0\n\n      for i, num in enumerate(nums):\n        if mask >> i & 1:\n          continue\n        if num % nums[prev] == 0 or nums[prev] % num == 0:\n          res += dp(i, mask | 1 << i)\n          res %= MOD\n\n      return res\n\n    return sum(dp(i, 1 << i)\n               for i in range(len(nums))) % MOD",
      "title": "2741. Special Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbe3b592-250d-4ccc-a0fa-880b43f04ba9",
      "code": "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    n = len(cost)\n\n    @functools.lru_cache(None)\n    def dp(i: int, walls: int) -> int:\n      \"\"\"Returns the minimum cost to paint j walls by painters[i..n).\"\"\"\n      if walls <= 0:\n        return 0\n      if i == n:\n        return math.inf\n      pick = cost[i] + dp(i + 1, walls - time[i] - 1)\n      skip = dp(i + 1, walls)\n      return min(pick, skip)\n\n    return dp(0, n)",
      "title": "2742. Painting the Walls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abdf4cc9-61ea-4920-a98c-844d0673ca6e",
      "code": "class Solution:\n  def numberOfSpecialSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == 2:\n        count[s[l]] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2743. Count Substrings Without Repeating Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2926d5dd-bd42-49fe-b7f3-beed4b38ad66",
      "code": "class Solution:\n  def maximumNumberOfStringPairs(self, words: list[str]) -> int:\n    ans = 0\n    seen = [False] * (26 * 26)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for word in words:\n      if seen[val(word[1]) * 26 + val(word[0])]:\n        ans += 1\n      seen[val(word[0]) * 26 + val(word[1])] = True\n\n    return ans",
      "title": "2744. Find Maximum Number of String Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "666db267-be99-43b4-a7fd-bf416bc352da",
      "code": "class Solution:\n  def longestString(self, x: int, y: int, z: int) -> int:\n    # 'AB' can always be easily appended within the string.\n    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'\n    # If x == y, we repeat the pattern 'AABBAABB...AABB'.\n    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'\n    mn = min(x, y)\n    if x == y:\n      return (mn * 2 + z) * 2\n    return (mn * 2 + 1 + z) * 2",
      "title": "2745. Construct the Longest New String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e305fc9-05bf-418f-b660-22dcb18e815a",
      "code": "class Solution:\n  def minimizeConcatenatedLength(self, words: list[str]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, first: str, last: str) -> int:\n      \"\"\"\n      Returns the minimum concatenated length of the first i words starting with\n      `first` and ending in `last`.\n      \"\"\"\n      if i == len(words):\n        return 0\n      nextFirst = words[i][0]\n      nextLast = words[i][-1]\n      return len(words[i]) + min(\n          # join(words[i - 1], words[i])\n          dp(i + 1, first, nextLast) - (last == nextFirst),\n          # join(words[i], words[i - 1])\n          dp(i + 1, nextFirst, last) - (first == nextLast)\n      )\n\n    return len(words[0]) + dp(1, words[0][0], words[0][-1])",
      "title": "2746. Decremental String Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35187a37-4d80-4f0f-8f29-76204a954beb",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(\n      self,\n      n: int,\n      logs: list[list[int]],\n      x: int,\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda x: x[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    # For each query, we care about logs[i..j].\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans",
      "title": "2747. Count Zero Request Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d3128d-4cc4-4bea-8984-a739a42d4b24",
      "code": "class Solution:\n  def countBeautifulPairs(self, nums: list[int]) -> int:\n    def firstDigit(num: int) -> int:\n      return int(str(num)[0])\n\n    def lastDigit(num: int) -> int:\n      return num % 10\n\n    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1\n               for i, j in itertools.combinations(range(len(nums)), 2))",
      "title": "2748. Number of Beautiful Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55831261-5269-45e3-8c4a-c790c6e779b3",
      "code": "class Solution:\n  def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    # Note that for any number x, we can use \"x's bit count\" operations to make\n    # x equal to 0. Additionally, we can also use x operations to deduct x by\n    # 2^0 (x times), which also results in 0.\n\n    for ops in range(61):\n      target = num1 - ops * num2\n      if target.bit_count() <= ops <= target:\n        return ops\n\n    return -1",
      "title": "2749. Minimum Operations to Make the Integer Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "549c56f2-fefc-4f24-b533-f735682d8896",
      "code": "class Solution:\n  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:\n    if 1 not in nums:\n      return 0\n\n    MOD = 1_000_000_007\n    prev = -1  # the previous index of 1\n    ans = 1\n\n    for i, num in enumerate(nums):\n      if num == 1:\n        if prev != -1:\n          ans *= i - prev\n          ans %= MOD\n        prev = i\n\n    return ans",
      "title": "2750. Ways to Split Array Into Good Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0f6b552-7cd8-4dbb-b637-b8f63e261716",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(\n      self,\n      positions: list[int],\n      healths: list[int],\n      directions: str,\n  ) -> list[int]:\n    robots = sorted([Robot(index, position, health, direction)\n                     for index, (position, health, direction) in\n                     enumerate(zip(positions, healths, directions))],\n                    key=lambda x: x.position)\n    stack: list[Robot] = []  # running robots\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      # Collide with robots going right if any.\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:  # stack[-1].health > robot.health\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]",
      "title": "2751. Robot Collisions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98581a50-13a8-48bf-9d7b-33dd3953590d",
      "code": "# Definition for a street.\n# class Street:\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    ans = 0\n\n    # Go to the first open door.\n    while not street.isDoorOpen():\n      street.moveRight()\n\n    street.moveRight()\n\n    for count in range(k):\n      # Each time we encounter an open door, there's a possibility that it's the\n      # first open door we intentionally left open.\n      if street.isDoorOpen():\n        ans = count + 1\n        street.closeDoor()\n      street.moveRight()\n\n    return ans",
      "title": "2753. Count Houses in a Circular Street II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f8cd1b8-fa5c-4c26-a444-c01ae6b27f89",
      "code": "class Solution:\n  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:\n    ans = 0\n    dp = 0\n\n    def isOddEven(a: int, b: int) -> bool:\n      return a % 2 != b % 2\n\n    for i, num in enumerate(nums):\n      if num > threshold:\n        dp = 0\n      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):\n        # Increase the size of the subarray.\n        dp += 1\n      else:\n        # Start a new subarray if the start is valid.\n        dp = 1 if num % 2 == 0 else 0\n      ans = max(ans, dp)\n\n    return ans",
      "title": "2760. Longest Even Odd Subarray With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8c3f79e-6251-4ff2-bca2-044135f2c3fd",
      "code": "class Solution:\n  def findPrimePairs(self, n: int) -> list[list[int]]:\n    isPrime = self._sieveEratosthenes(n + 1)\n    return [[i, n - i] for i in range(2, n // 2 + 1)\n            if isPrime[i] and isPrime[n - i]]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n\n\nj",
      "title": "2761. Prime Pairs With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2769d44a-b4f6-407f-aa73-c95e48a45a9c",
      "code": "class Solution:\n  def continuousSubarrays(self, nums: list[int]) -> int:\n    ans = 1  # [nums[0]]\n    left = nums[0] - 2\n    right = nums[0] + 2\n    l = 0\n\n    # nums[l..r] is a valid window.\n    for r in range(1, len(nums)):\n      if left <= nums[r] <= right:\n        left = max(left, nums[r] - 2)\n        right = min(right, nums[r] + 2)\n      else:\n        # nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2\n        right = nums[r] + 2\n        l = r\n        # If we consistently move leftward in each iteration, it implies that\n        # the entire left subarray satisfies the given condition. For every\n        # subarray with l in the range [0, r], the condition is met, preventing\n        # the code from reaching the final \"else\" condition. Instead, it stops\n        # at the \"if\" condition.\n        while nums[r] - 2 <= nums[l] <= nums[r] + 2:\n          left = max(left, nums[l] - 2)\n          right = min(right, nums[l] + 2)\n          l -= 1\n        l += 1\n      # nums[l..r], num[l + 1..r], ..., nums[r]\n      ans += r - l + 1\n\n    return ans",
      "title": "2762. Continuous Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "991d196f-5dc9-4678-bac4-f4d63f1f3537",
      "code": "class Solution:\n  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  # of determining the number of gaps in each subarray, let's find out how many\n  # subarrays contain each gap.\n  def sumImbalanceNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # Note that to avoid double counting, only `left` needs to check nums[i].\n    # This adjustment ensures that i represents the position of the leftmost\n    # element of nums[i] within the subarray.\n\n    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    left = [0] * n\n    # right[i] := the minimum index r s.t. nums[r] = nums[i]\n    right = [0] * n\n\n    numToIndex = [-1] * (n + 2)\n    for i, num in enumerate(nums):\n      left[i] = max(numToIndex[num], numToIndex[num + 1])\n      numToIndex[num] = i\n\n    numToIndex = [n] * (n + 2)\n    for i in range(n - 1, -1, -1):\n      right[i] = numToIndex[nums[i] + 1]\n      numToIndex[nums[i]] = i\n\n    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    # subarrays satisfying this condition.\n    #\n    # Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    # initially assumed to have a gap. This adjustment is necessary as the\n    # maximum element of every subarray does not have a gap.\n    return sum((i - left[i]) * (right[i] - i)\n               for i in range(n)) - n * (n + 1) // 2",
      "title": "2763. Sum of Imbalance Numbers of All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "034b0ae7-ea62-4bcf-9029-b662dc31efeb",
      "code": "class Solution:\n  def isPreorder(self, nodes: list[list[int]]) -> bool:\n    stack = []  # Stores `id`s.\n\n    for id, parentId in nodes:\n      if parentId == -1:\n        stack.append(id)\n        continue\n      while stack and stack[-1] != parentId:\n        stack.pop()\n      if not stack:\n        return False\n      stack.append(id)\n\n    return True",
      "title": "2764. is Array a Preorder of Some â€ŒBinary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c42d4690-4426-471d-b609-d1eae5da7452",
      "code": "class Solution:\n  def alternatingSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    dp = 1\n\n    for i in range(1, len(nums)):\n      targetDiff = -1 if dp % 2 == 0 else 1\n      # Append nums[i] to the current alternating subarray.\n      if nums[i] - nums[i - 1] == targetDiff:\n        dp += 1\n      # Reset the alternating subarray to nums[i - 1..i].\n      elif nums[i] - nums[i - 1] == 1:\n        dp = 2\n      # Reset the alternating subarray to nums[i].\n      else:\n        dp = 1\n      ans = max(ans, dp)\n\n    return -1 if ans == 1 else ans",
      "title": "2765. Longest Alternating Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa6b5d4e-bd62-40bc-ae66-230624cabdcc",
      "code": "class Solution:\n  def relocateMarbles(\n      self,\n      nums: list[int],\n      moveFrom: list[int],\n      moveTo: list[int],\n  ) -> list[int]:\n    numsSet = set(nums)\n\n    for f, t in zip(moveFrom, moveTo):\n      numsSet.remove(f)\n      numsSet.add(t)\n\n    return sorted(numsSet)",
      "title": "2766. Relocate Marbles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c20f0fec-7b4b-49d9-975c-aa4d1adc8b38",
      "code": "class Solution:\n  def minimumBeautifulSubstrings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of beautiful substrings for the first i chars\n    dp = [0] + [n + 1] * n\n\n    for i in range(1, n + 1):\n      if s[i - 1] == '0':\n        continue\n      num = 0  # the number of s[i - 1..j - 1]\n      for j in range(i, n + 1):\n        num = (num << 1) + int(s[j - 1])\n        if self._isPowerOfFive(num):\n          dp[j] = min(dp[j], dp[i - 1] + 1)\n\n    return -1 if dp[n] == n + 1 else dp[n]\n\n  def _isPowerOfFive(self, num: int) -> bool:\n    while num % 5 == 0:\n      num //= 5\n    return num == 1",
      "title": "2767. Partition String Into Minimum Beautiful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "250635dc-28f8-449f-a906-52e6012bcc4e",
      "code": "class Solution:\n  def countBlackBlocks(\n      self,\n      m: int,\n      n: int,\n      coordinates: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * 5\n    # count[i * n + j] := the number of black cells in\n    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    count = collections.Counter()\n\n    for x, y in coordinates:\n      for i in range(x, x + 2):\n        for j in range(y, y + 2):\n          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          # current black cell (x, y).\n          if 0 < i < m and 0 < j < n:\n            count[(i, j)] += 1\n\n    for freq in count.values():\n      ans[freq] += 1\n\n    ans[0] = (m - 1) * (n - 1) - sum(ans)\n    return ans",
      "title": "2768. Number of Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cf6d83f-e79c-48e1-bc95-3c270f5bfb1f",
      "code": "class Solution:\n  def theMaximumAchievableX(self, num: int, t: int) -> int:\n    return num + 2 * t",
      "title": "2769. Find the Maximum Achievable Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c89e6bf3-0b4d-4e40-942c-9424cd8e0b0e",
      "code": "class Solution:\n  def maximumJumps(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i] := the maximum number of jumps to reach i from 0\n    dp = [-1] * n\n    dp[0] = 0\n\n    for j in range(1, n):\n      for i in range(j):\n        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:\n          dp[j] = max(dp[j], dp[i] + 1)\n\n    return dp[-1]",
      "title": "2770. Maximum Number of Jumps to Reach the Last Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2242e84e-d067-4a4e-900f-558f34b86ae2",
      "code": "class Solution:\n  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 1\n    dp1 = 1  # the longest subarray that ends in nums1[i] so far\n    dp2 = 1  # the longest subarray that ends in nums2[i] so far\n\n    for i in range(1, len(nums1)):\n      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1\n      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1\n      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1\n      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1\n      dp1 = max(dp11, dp21)\n      dp2 = max(dp12, dp22)\n      ans = max(ans, dp1, dp2)\n\n    return ans",
      "title": "2771. Longest Non-decreasing Subarray From Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69791eb6-cad4-4da6-95f1-f150c7af2d92",
      "code": "class Solution:\n  def checkArray(self, nums: list[int], k: int) -> bool:\n    if k == 1:\n      return True\n\n    needDecrease = 0\n    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if i >= k:\n        needDecrease -= dq.popleft()\n      if nums[i] < needDecrease:\n        return False\n      decreasedNum = nums[i] - needDecrease\n      dq.append(decreasedNum)\n      needDecrease += decreasedNum\n\n    return dq[-1] == 0",
      "title": "2772. Apply Operations to Make All Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "746ccce8-8325-4a1e-9fd2-2e9369e9de43",
      "code": "class Solution:\n  def heightOfTree(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    # a leaf node\n    if root.left and root.left.right == root:\n      return 0\n    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))",
      "title": "2773. Height of Special Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac296fc0-e32a-4f73-b518-7fa11bf0d768",
      "code": "class Solution:\n  def sumOfSquares(self, nums: list[int]) -> int:\n    return sum(num**2 for i, num in enumerate(nums)\n               if len(nums) % (i + 1) == 0)",
      "title": "2778. Sum of Squares of Special Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e86e7321-4b97-4c4d-bab7-f44c29d5aa54",
      "code": "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r in range(len(nums)):\n      if nums[r] - nums[l] > 2 * k:\n        l += 1\n\n    return r - l + 1",
      "title": "2779. Maximum Beauty of an Array After Applying Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb1f37a5-a023-4755-b810-3c6c19cf436e",
      "code": "class Solution:\n  def minimumIndex(self, nums: list[int]) -> int:\n    count1 = collections.Counter()\n    count2 = collections.Counter(nums)\n\n    for i, num in enumerate(nums):\n      count1[num] = count1[num] + 1\n      count2[num] = count2[num] - 1\n      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:\n        return i\n\n    return -1",
      "title": "2780. Minimum Index of a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2d36b09-1185-4239-899d-3b7d7bb8dac8",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str, l: int, r: int) -> bool:\n    node: TrieNode = self.root\n    for i in range(l, r):\n      if word[i] not in node.children:\n        return False\n      node = node.children[word[i]]\n    return node.isWord\n\n\nclass Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    ans = 0\n    trie = Trie()\n\n    for s in forbidden:\n      trie.insert(s)\n\n    # r is the rightmost index to make word[l..r] a valid substring.\n    r = len(word) - 1\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if trie.search(word, l, end + 1):\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2781. Length of the Longest Valid Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bba967cf-6397-423f-b723-8dd383e1d5f8",
      "code": "# Definition for a category handler.\n# class CategoryHandler:\n#   def haveSameCategory(self, a: int, b: int) -> bool:\n#     pass\n\nclass Solution:\n  def numberOfCategories(\n      self,\n      n: int,\n      categoryHandler: Optional['CategoryHandler'],\n  ) -> int:\n    ans = 0\n\n    for i in range(n):\n      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):\n        ans += 1\n\n    return ans",
      "title": "2782. Number of Unique Categories",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fa5ae96-0402-4aa8-bc41-e11261c4ab98",
      "code": "class Solution:\n  def isGood(self, nums: list[int]) -> bool:\n    n = len(nums) - 1\n    count = collections.Counter(nums)\n    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2",
      "title": "2784. Check if Array is Good",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6dafd6d-d455-4368-a83e-d4357195f867",
      "code": "class Solution:\n  def sortVowels(self, s: str) -> str:\n    VOWELS = 'aeiouAEIOU'\n    ans = []\n    vowels = sorted([c for c in s if c in VOWELS])\n\n    i = 0  # vowels' index\n    for c in s:\n      if c in VOWELS:\n        ans.append(vowels[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "2785. Sort Vowels in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c69551f-6622-4e5b-8467-f5e06a4e6bdb",
      "code": "class Solution:\n  def maxScore(self, nums: list[int], x: int) -> int:\n    # Note that we always need to take nums[0], so the initial definition might\n    # not hold true.\n\n    # dp0 := the maximum score so far with `nums` ending in an even number\n    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)\n    # dp0 := the maximum score so far with `nums` ending in an odd number\n    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)\n\n    for i in range(1, len(nums)):\n      if nums[i] % 2 == 0:\n        dp0 = nums[i] + max(dp0, dp1 - x)\n      else:\n        dp1 = nums[i] + max(dp1, dp0 - x)\n\n    return max(dp0, dp1)",
      "title": "2786. Visit Array Positions to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c35b7d6f-a50c-4298-ab49-50bb357a7b33",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to express i\n    dp = [1] + [0] * n\n\n    for a in range(1, n + 1):\n      ax = a**x\n      if ax > n:\n        break\n      for i in range(n, ax - 1, -1):\n        dp[i] += dp[i - ax]\n        dp[i] %= MOD\n\n    return dp[n]",
      "title": "2787. Ways to Express an Integer as Sum of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc94ba8f-bb1d-479a-9c24-87adf79a19f7",
      "code": "class Solution:\n  def splitWordsBySeparator(\n      self,\n      words: list[str],\n      separator: str,\n  ) -> list[str]:\n    return [splitWord\n            for word in words\n            for splitWord in word.split(separator)\n            if splitWord]",
      "title": "2788. Split Strings by Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e67e0222-3625-49e6-9bbf-66988b514d0e",
      "code": "class Solution:\n  def maxArrayValue(self, nums: list[int]) -> int:\n    ans = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > ans:\n        ans = nums[i]\n      else:\n        ans += nums[i]\n\n    return ans",
      "title": "2789. Largest Element in an Array after Merge Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0162df21-63af-4143-9ec6-249b8820dbca",
      "code": "class Solution:\n  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:\n    ans = 1  # the next target length\n    availableLimits = 0\n\n    for usageLimit in sorted(usageLimits):\n      availableLimits += usageLimit\n      # Can create groups 1, 2, ..., ans.\n      if availableLimits >= ans * (ans + 1) // 2:\n        ans += 1\n\n    return ans - 1",
      "title": "2790. Maximum Number of Groups With Increasing Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a99deb4f-eae4-4ab7-9416-b0796d450169",
      "code": "class Solution:\n  def countPalindromePaths(self, parent: list[int], s: str) -> int:\n    # A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    # frequency of a letter on the u-v path is equal to the sum of its\n    # frequencies on the root-u and root-v paths substract twice of its\n    # frequency on the root-LCA(u, v) path. Considering only the parity\n    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    # possible to calculate both parts easily using a simple DFS.\n    tree = [[] for _ in parent]\n    maskToCount = collections.Counter({0: 1})\n\n    for i in range(1, len(parent)):\n      tree[parent[i]].append(i)\n\n    # mask := 26 bits that represent the parity of each character in the alphabet\n    # on the path from node 0 to node u\n    def dfs(u: int, mask: int) -> int:\n      res = 0\n      if u > 0:\n        mask ^= 1 << (ord(s[u]) - ord('a'))\n        # Consider any u-v path with 1 bit set.\n        for i in range(26):\n          res += maskToCount[mask ^ (1 << i)]\n        # Consider u-v path with 0 bit set.\n        res += maskToCount[mask ^ 0]\n        maskToCount[mask] += 1\n      for v in tree[u]:\n        res += dfs(v, mask)\n      return res\n\n    return dfs(0, 0)",
      "title": "2791. Count Paths That Can Form a Palindrome in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eeca8b5f-74c3-47f6-bb87-a3d138cfc880",
      "code": "class Solution:\n  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> list[int]:\n      nonlocal ans\n      if not root:\n        return []\n\n      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]\n      if len(kSmallest) == k and root.val > kSmallest[-1]:\n        ans += 1\n\n      return kSmallest + [root.val]\n\n    dfs(root)\n    return ans",
      "title": "2792. Count Nodes That Are Great Enough",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1270a419-a885-4db3-b30d-b7a6801a7d3f",
      "code": "class Solution:\n  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:\n    return sum(hour >= target for hour in hours)",
      "title": "2798. Number of Employees Who Met the Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eadc0bcc-03d7-4267-b5fc-400ccc0485b3",
      "code": "class Solution:\n  def countCompleteSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    distinct = len(set(nums))\n    count = collections.Counter()\n\n    l = 0\n    for num in nums:\n      count[num] += 1\n      while len(count) == distinct:\n        count[nums[l]] -= 1\n        if count[nums[l]] == 0:\n          del count[nums[l]]\n        l += 1\n      # Assume nums[r] = num,\n      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l\n\n    return ans",
      "title": "2799. Count Complete Subarrays in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e97892f-f47d-44ee-8628-dabfd65d3756",
      "code": "class Solution:\n  def minimumString(self, a: str, b: str, c: str) -> str:\n    def merge(a: str, b: str) -> str:\n      \"\"\"Merges a and b.\"\"\"\n      if a in b:  # a is a substring of b.\n        return b\n      for i in range(len(a)):\n        aSuffix = a[i:]\n        bPrefix = b[:len(aSuffix)]\n        if aSuffix == bPrefix:\n          return a + b[len(bPrefix):]\n      return a + b\n\n    abc = merge(a, merge(b, c))\n    acb = merge(a, merge(c, b))\n    bac = merge(b, merge(a, c))\n    bca = merge(b, merge(c, a))\n    cab = merge(c, merge(a, b))\n    cba = merge(c, merge(b, a))\n    return self._getMin([abc, acb, bac, bca, cab, cba])\n\n  def _getMin(self, words: list[str]) -> str:\n    \"\"\"Returns the lexicographically smallest string.\"\"\"\n\n    def getMin(a: str, b: str) -> str:\n      \"\"\"Returns the lexicographically smaller string.\"\"\"\n      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b\n\n    res = words[0]\n    for i in range(1, len(words)):\n      res = getMin(res, words[i])\n    return res",
      "title": "2800. Shortest String That Contains Three Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8905f252-aa43-42e3-b834-8b4c37530185",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: str, high: str) -> int:\n    MOD = 1_000_000_007\n    low = '0' * (len(high) - len(low)) + low\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        prevDigit: int,\n        isLeadingZero: bool,\n        tight1: bool,\n        tight2: bool,\n    ) -> int:\n      \"\"\"\n      Returns the number of valid integers, considering the i-th digit, where\n      `prevDigit` is the previous digit, `tight1` indicates if the current\n      digit is tightly bound for `low`, and `tight2` indicates if the current\n      digit is tightly bound for `high`.\n      \"\"\"\n      if i == len(high):\n        return 1\n\n      res = 0\n      minDigit = int(low[i]) if tight1 else 0\n      maxDigit = int(high[i]) if tight2 else 9\n\n      for d in range(minDigit, maxDigit + 1):\n        nextTight1 = tight1 and (d == minDigit)\n        nextTight2 = tight2 and (d == maxDigit)\n        if isLeadingZero:\n          # Can place any digit in [minDigit, maxDigit].\n          res += dp(i + 1, d, isLeadingZero and d ==\n                    0, nextTight1, nextTight2)\n        elif abs(d - prevDigit) == 1:\n          res += dp(i + 1, d, False, nextTight1, nextTight2)\n        res %= MOD\n\n      return res\n\n    return dp(0, -1, True, True, True)",
      "title": "2801. Count Stepping Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497c2a25-b628-4855-93ef-ad7826113c58",
      "code": "class Solution:\n  def kthLuckyNumber(self, k: int) -> str:\n    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')",
      "title": "2802. Find The K-th Lucky Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "485d87c5-2040-471d-8036-f14bb9058bca",
      "code": "class Solution:\n  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n    return 100 - ((purchaseAmount + 5) // 10) * 10",
      "title": "2806. Account Balance After Rounded Purchase",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e0a083c-7895-4b03-ad13-3b3b0d03f1f2",
      "code": "class Solution:\n  def insertGreatestCommonDivisors(\n      self, head: ListNode | None\n  ) -> ListNode | None:\n    curr = head\n    while curr.next:\n      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)\n      curr.next = inserted\n      curr = inserted.next\n    return head",
      "title": "2807. Insert Greatest Common Divisors in Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdbac7b7-d184-482e-83cb-383fe26fc5c8",
      "code": "class Solution:\n  def minimumSeconds(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    def getSeconds(i: int, j: int) -> int:\n      \"\"\"Returns the number of seconds required to make nums[i..j] the same.\"\"\"\n      return (i - j) // 2\n\n    for indices in numToIndices.values():\n      seconds = getSeconds(indices[0] + n, indices[-1])\n      for i in range(1, len(indices)):\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))\n      ans = min(ans, seconds)\n\n    return ans",
      "title": "2808. Minimum Seconds to Equalize a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be2430ed-d53b-43c3-8370-22599ccabcbc",
      "code": "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[i][j] := the maximum reduced value if we do j operations on the first\n    # i numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(1, i + 1):\n        dp[i][j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[i - 1][j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[i - 1][j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[n][op] <= x:\n        return op\n\n    return -1",
      "title": "2809. Minimum Time to Make Array Sum At Most x",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cca18e2f-ec4b-4ac8-817b-18a557c7cfda",
      "code": "class Solution:\n  def finalString(self, s: str) -> str:\n    dq = collections.deque()\n    inversed = False\n\n    for c in s:\n      if c == 'i':\n        inversed = not inversed\n      elif inversed:\n        dq.appendleft(c)\n      else:\n        dq.append(c)\n\n    return ''.join(reversed(dq)) if inversed else ''.join(dq)",
      "title": "2810. Faulty Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b40daa31-4928-45b3-b41d-cbccf37dcdc8",
      "code": "class Solution:\n  def canSplitArray(self, nums: list[int], m: int) -> bool:\n    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))",
      "title": "2811. Check if it is Possible to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff7fe51f-dd10-4274-9ade-204c1a121e9e",
      "code": "class Solution:\n  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True,\n                              key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief",
      "title": "2812. Find the Safest Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f9c257c-0775-434b-9ff3-6fae7133bbfa",
      "code": "class Solution:\n  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:\n    ans = 0\n    totalProfit = 0\n    seenCategories = set()\n    decreasingDuplicateProfits = []\n\n    items.sort(reverse=True)\n\n    for i in range(k):\n      profit, category = items[i]\n      totalProfit += profit\n      if category in seenCategories:\n        decreasingDuplicateProfits.append(profit)\n      else:\n        seenCategories.add(category)\n\n    ans = totalProfit + len(seenCategories)**2\n\n    for i in range(k, len(items)):\n      profit, category = items[i]\n      if category not in seenCategories and decreasingDuplicateProfits:\n        # If this is a new category we haven't seen before, it's worth\n        # considering taking it and replacing the one with the least profit\n        # since it will increase the distinct_categories and potentially result\n        # in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.pop()\n        totalProfit += profit\n        seenCategories.add(category)\n        ans = max(ans, totalProfit + len(seenCategories)**2)\n\n    return ans",
      "title": "2813. Maximum Elegance of a K-Length Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b50b2dd0-3434-4224-824c-4d04655ca1e7",
      "code": "class Solution:\n  def minimumSeconds(self, land: list[list[str]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(land)\n    n = len(land[0])\n    floodDist = self._getFloodDist(land)\n    startPos = self._getStartPos(land, 'S')\n\n    q = collections.deque([startPos])\n    seen = {startPos}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] == 'D':\n            return step\n          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n\n  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:\n    m = len(land)\n    n = len(land[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    q = collections.deque()\n    seen = set()\n\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          q.append((i, j))\n          seen.add((i, j))\n\n    d = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        dist[i][j] = d\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] in 'XD' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      d += 1\n\n    return dist\n\n  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == c:\n          return i, j",
      "title": "2814. Minimum Time Takes to Reach Destination Without Drowning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e2c8b10-2fad-48c0-8b15-e7ec319445e3",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    ans = 0\n    # maxNum[i] := the maximum num we met so far with the maximum digit i\n    maxNum = [0] * 10\n\n    def getMaxDigit(num: int) -> int:\n      maxDigit = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        num //= 10\n      return maxDigit\n\n    for num in nums:\n      d = getMaxDigit(num)\n      if maxNum[d] > 0:\n        ans = max(ans, num + maxNum[d])\n      maxNum[d] = max(maxNum[d], num)\n\n    return -1 if ans == 0 else ans",
      "title": "2815. Max Pair Sum in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "984583bb-76c4-415a-9572-c511fa5901bb",
      "code": "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    def getCarry(node: ListNode | None) -> ListNode | None:\n      val = node.val * 2\n      if node.next:\n        val += getCarry(node.next)\n      node.val = val % 10\n      return val // 10\n\n    if getCarry(head) == 1:\n      return ListNode(1, head)\n    return head",
      "title": "2816. Double a Number Represented as a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88c4eeaf-ab11-4447-bcbd-8cb74f435b7d",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:\n    ans = math.inf\n    seen = SortedSet()\n\n    for i in range(x, len(nums)):\n      seen.add(nums[i - x])\n      it = seen.bisect_left(nums[i])\n      if it != len(seen):\n        ans = min(ans, seen[it] - nums[i])\n      if it != 0:\n        ans = min(ans, nums[i] - seen[it - 1])\n\n    return ans",
      "title": "2817. Minimum Absolute Difference Between Elements With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81e466ef-2a07-49b8-8555-070f7e70224c",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    # left[i] := the next index on the left (if any)\n    #            s.t. primeScores[left[i]] >= primeScores[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. primeScores[right[i]] > primeScores[i]\n    right = [n] * n\n    stack = []\n\n    # Find the next indices on the left where `primeScores` are greater or equal.\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    # Find the next indices on the right where `primeScores` are greater.\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      # be chosen.\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= MOD\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 2 <= i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)",
      "title": "2818. Apply Operations to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5a5ce58-1ff7-4dc7-8315-c04e4db22966",
      "code": "class Solution:\n  def minimumRelativeLosses(\n      self,\n      prices: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    prices.sort()\n\n    prefix = list(itertools.accumulate(prices, initial=0))\n\n    for k, m in queries:\n      countFront = self._getCountFront(k, m, prices)\n      countBack = m - countFront\n      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))\n\n    return ans\n\n  def _getCountFront(\n      self,\n      k: int,\n      m: int,\n      prices: list[int],\n  ) -> int:\n    \"\"\"Returns `countFront` for query (k, m).\n\n    Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n    and the last `m - countFront` chocolates is optimal.\n\n    Define loss[i] := the relative loss of picking `prices[i]`.\n    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n       Thus, loss[i] = prices[i] - 0 = prices[i].\n    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n    By observation, we deduce that it is always better to pick from the front\n    or the back since loss[i] is increasing for 1. and is decreasing for 2.\n\n    Assume that picking `left` chocolates from the left and `right = m - left`\n    chocolates from the right is optimal. Therefore, we are selecting\n    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n\n    To determine the optimal `left` in each iteration, we simply compare\n    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,\n    it's worth increasing `left`.\n    \"\"\"\n    n = len(prices)\n    countNoGreaterThanK = bisect.bisect_right(prices, k)\n    l = 0\n    r = min(countNoGreaterThanK, m)\n\n    while l < r:\n      mid = (l + r) // 2\n      right = m - mid\n      # Picking prices[mid] is better than picking prices[n - right].\n      if prices[mid] < 2 * k - prices[n - right]:\n        l = mid + 1\n      else:\n        r = mid\n\n    return l\n\n  def _getRelativeLoss(\n      self,\n      countFront: int,\n      countBack: int,\n      k: int,\n      prefix: list[int],\n  ) -> int:\n    \"\"\"\n    Returns the relative loss of picking `countFront` and `countBack` \n    chocolates.\n    \"\"\"\n    lossFront = prefix[countFront]\n    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])\n    return lossFront + lossBack",
      "title": "2819. Minimum Relative Loss After Buying Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f2b016d-9ba7-4637-b8fc-f7b3ce5bc48b",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], target: int) -> int:\n    return sum(nums[i] + nums[j] < target\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))",
      "title": "2824. Count Pairs Whose Sum is Less than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e59f88e-7381-4aca-8291-e17b57edc41c",
      "code": "class Solution:\n  def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n    i = 0  # str2's index\n\n    for c in str1:\n      if c == str2[i] or chr(\n              ord('a') + (ord(c) - ord('a') + 1) % 26) == str2[i]:\n        i += 1\n        if i == len(str2):\n          return True\n\n    return False",
      "title": "2825. Make String a Subsequence Using Cyclic Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e9515df-138d-4f64-810d-2b41e5edebec",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]\n    dp = [0] * 4\n\n    for num in nums:\n      dp[num] += 1  # Append num to the sequence so far.\n      dp[2] = max(dp[2], dp[1])\n      dp[3] = max(dp[3], dp[2])\n\n    return len(nums) - dp[3]",
      "title": "2826. Sorting Three Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86cf9f98-a479-4e1f-b47c-2827a55f5022",
      "code": "class Solution:\n  def isAcronym(self, words: list[str], s: str) -> bool:\n    return (len(words) == len(s) and\n            all(word[0] == c for word, c in zip(words, s)))",
      "title": "2828. Check if a String Is an Acronym of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "653fe1d2-1145-4ccd-a3f5-820fe8a78eca",
      "code": "class Solution:\n  def minimumSum(self, n: int, k: int) -> int:\n    # These are the unique pairs that sum up to k:\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = k // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))",
      "title": "2829. Determine the Minimum Sum of a k-avoiding Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70fdd6a5-c765-48bf-8ea7-172108c1d0d3",
      "code": "class Solution:\n  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:\n    # dp[i] := the maximum amount of gold of selling the first i houses\n    dp = [0] * (n + 1)\n    endToStartAndGolds = [[] for _ in range(n)]\n\n    for start, end, gold in offers:\n      endToStartAndGolds[end].append((start, gold))\n\n    for end in range(1, n + 1):\n      # Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1]\n      for start, gold in endToStartAndGolds[end - 1]:\n        dp[end] = max(dp[end], dp[start] + gold)\n\n    return dp[n]",
      "title": "2830. Maximize the Profit as the Salesman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "321ec17c-1a95-4977-8547-2932eb743e52",
      "code": "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      if r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans",
      "title": "2831. Find the Longest Equal Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dd09b88-362d-4105-834f-51589dbbee39",
      "code": "class Solution:\n  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    stack = []  # a decreasing stack\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):\n        index = stack.pop()\n        left = stack[-1] if stack else -1\n        ans[index] = i - left - 1\n      stack.append(i)\n\n    return ans",
      "title": "2832. Maximal Range That Each Element Is Maximum in It",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1f4ded2-391d-482a-a0cd-0b48786e515e",
      "code": "class Solution:\n  def furthestDistanceFromOrigin(self, moves: str) -> int:\n    return abs(moves.count('L') - moves.count('R')) + moves.count('_')",
      "title": "2833. Furthest Point From Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66191665-592d-4d0d-9063-66408846be45",
      "code": "class Solution:\n  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  def minimumPossibleSum(self, n: int, target: int) -> int:\n    # These are the unique pairs that sum up to k (target):\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n    MOD = 1_000_000_007\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = target // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % MOD",
      "title": "2834. Find the Minimum Possible Sum of a Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05254d71-2924-4332-b567-6a70da3ba521",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], target: int) -> int:\n    NO_MISSING_BIT = 31\n    maxBit = 31\n    ans = 0\n    minMissingBit = NO_MISSING_BIT\n    # count[i] := the number of occurrences of 2^i\n    count = collections.Counter(int(math.log2(num)) for num in nums)\n\n    for bit in range(maxBit):\n      # Check if `bit` is in the target.\n      if target >> bit & 1:\n        # If there are available bits, use one bit.\n        if count[bit] > 0:\n          count[bit] -= 1\n        else:\n          minMissingBit = min(minMissingBit, bit)\n      # If we previously missed a bit and there are available bits.\n      if minMissingBit != NO_MISSING_BIT and count[bit] > 0:\n        count[bit] -= 1\n        # Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit\n        minMissingBit = NO_MISSING_BIT  # Set it to an the invalid value.\n      # Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] // 2\n\n    # Check if all target bits have been covered, otherwise return -1.\n    return ans if minMissingBit == maxBit else -1",
      "title": "2835. Minimum Operations to Form Subsequence With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13b07bfa-f7a5-4064-b4ff-1872c2b94a12",
      "code": "class Solution:\n  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    # jump[i][j] := the the node you reach after jumping 2^j steps from i\n    jump = [[0] * m for _ in range(n)]\n    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        #   the the node you reach after jumping 2^j steps from i\n        # = the node you reach after jumping 2^(j - 1) steps from i\n        # + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1]\n        #   the sum of the first 2^j nodes you reach when jumping from i\n        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        # + the sum of another 2^(j - 1) nodes you reach\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans",
      "title": "2836. Maximize Value of Function in a Ball Passing Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcb00cf8-1c23-4be1-8610-60afbd53ba9b",
      "code": "class Solution:\n  def maximumCoins(\n      self,\n      heroes: list[int],\n      monsters: list[int],\n      coins: list[int]\n  ) -> list[int]:\n    monsterAndCoins = sorted(list(zip(monsters, coins)))\n    coinsPrefix = list(itertools.accumulate(\n        (coin for _, coin in monsterAndCoins),\n        initial=0))\n    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]\n            for hero in heroes]\n\n  def _firstGreaterEqual(\n      self,\n      monsterAndCoins: list[tuple[int, int]],\n      hero: int,\n  ) -> int:\n    l, r = 0, len(monsterAndCoins)\n    while l < r:\n      m = (l + r) // 2\n      if monsterAndCoins[m][0] > hero:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2838. Maximum Coins Heroes Can Collect",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "420048f3-7f8f-4961-b0a9-256f05fd2c87",
      "code": "class Solution:\n  def canBeEqual(self, s1: str, s2: str) -> bool:\n    def swappedStrings(s: str) -> list[str]:\n      chars = list(s)\n      return [chars,\n              ''.join([chars[2], chars[1], chars[0], chars[3]]),\n              ''.join([chars[0], chars[3], chars[2], chars[1]]),\n              ''.join([chars[2], chars[3], chars[0], chars[1]])]\n\n    return any(a == b\n               for a in swappedStrings(s1)\n               for b in swappedStrings(s2))",
      "title": "2839. Check if Strings Can be Made Equal With Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64d74007-7c5d-45fc-aa85-13fe26d76e05",
      "code": "class Solution:\n  def checkStrings(self, s1: str, s2: str) -> bool:\n    count = [collections.Counter() for _ in range(2)]\n\n    for i, (a, b) in enumerate(zip(s1, s2)):\n      count[i % 2][a] += 1\n      count[i % 2][b] -= 1\n\n    return (all(freq == 0 for freq in count[0].values()) and\n            all(freq == 0 for freq in count[1].values()))",
      "title": "2840. Check if Strings Can be Made Equal With Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b08f515-1e5d-4844-850e-7c681fb6fb0e",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], m: int, k: int) -> int:\n    ans = 0\n    summ = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if i >= k:\n        numToRemove = nums[i - k]\n        summ -= numToRemove\n        count[numToRemove] -= 1\n        if count[numToRemove] == 0:\n          del count[numToRemove]\n      if len(count) >= m:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2841. Maximum Sum of Almost Unique Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d8f6fde-4319-4c7a-88a6-d5523d2e11fd",
      "code": "class Solution:\n  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(s)\n    if len(count) < k:\n      return 0\n\n    ans = 1\n    # freqCount := (f(c), # of chars with f(c))\n    freqCount = collections.Counter(count.values())\n\n    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):\n      if numOfChars >= k:\n        ans *= math.comb(numOfChars, k) * pow(fc, k, MOD)\n        return ans % MOD\n      ans *= pow(fc, numOfChars, MOD)\n      ans %= MOD\n      k -= numOfChars",
      "title": "2842. Count K-Subsequences of a String With Maximum Beauty Solved",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6364fb-c823-4528-9fa2-89d202074cd6",
      "code": "class Solution:\n  def countSymmetricIntegers(self, low: int, high: int) -> int:\n    def isSymmetricInteger(num: int) -> bool:\n      if num >= 10 and num <= 99:\n        return num // 10 == num % 10\n      if num >= 1000 and num <= 9999:\n        left = num // 100\n        right = num % 100\n        return left // 10 + left % 10 == right // 10 + right % 10\n      return False\n\n    return sum(isSymmetricInteger(num) for num in range(low, high + 1))",
      "title": "2843. Count Symmetric Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a2fbe44-3a3b-4264-a75a-4333b035b974",
      "code": "class Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':  # '00'\n        return n - i - 2\n      if seenZero and num[i] == '5':  # '50'\n        return n - i - 2\n      if seenFive and num[i] == '2':  # '25'\n        return n - i - 2\n      if seenFive and num[i] == '7':  # '75'\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    return n - 1 if seenZero else n",
      "title": "2844. Minimum Operations to Make a Special Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fa6ec55-64c6-43ea-837a-727820680ba8",
      "code": "class Solution:\n  def countInterestingSubarrays(\n      self,\n      nums: list[int],\n      modulo: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      if num % modulo == k:\n        prefix = (prefix + 1) % modulo\n      ans += prefixCount[(prefix - k + modulo) % modulo]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2845. Count of Interesting Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e27ef791-b698-4b8b-b464-1c2346e59db9",
      "code": "class Solution:\n  def minOperationsQueries(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    MAX = 26\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    # jump[i][j] := the 2^j-th ancestor of i\n    jump = [[0] * m for _ in range(n)]\n    # depth[i] := the depth of i\n    depth = [0] * n\n    # count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    count = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    count[0] = [0] * (MAX + 1)\n    self._dfs(graph, 0, -1, jump, depth, count)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getMinOperations(u: int, v: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to make the edge weight\n      equilibrium between (u, v).\n      \"\"\"\n      lca = self._getLCA(u, v, jump, depth)\n      # the number of edges between (u, v).\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      # the maximum frequency of edges between (u, v)\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]\n                    for j in range(1, MAX + 1))\n      return numEdges - maxFreq\n\n    return [getMinOperations(u, v) for u, v in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      count: list[list[int]]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      count[v] = count[u][:]\n      count[v][w] += 1\n      self._dfs(graph, v, u, jump, depth, count)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]",
      "title": "2846. Minimum Edge Weight Equilibrium Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57da28b3-4078-434e-9f3a-b9b4cbe2f413",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> str:\n    if n <= 9:\n      return str(n)\n\n    ans = []\n\n    for divisor in range(9, 1, -1):\n      while n % divisor == 0:\n        ans.append(str(divisor))\n        n //= divisor\n\n    return '-1' if n > 1 else ''.join(reversed(ans))",
      "title": "2847. Smallest Number With Given Digit Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb02231d-994b-481a-a7cd-ecd4ef192fb0",
      "code": "class Solution:\n  def numberOfPoints(self, nums: list[list[int]]) -> int:\n    MAX = 100\n    ans = 0\n    runningSum = 0\n    count = [0] * (MAX + 2)\n\n    for start, end in nums:\n      count[start] += 1\n      count[end + 1] -= 1\n\n    for i in range(1, MAX + 1):\n      runningSum += count[i]\n      if runningSum > 0:\n        ans += 1\n\n    return ans",
      "title": "2848. Points That Intersect With Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf948d12-9003-4313-aa2b-1e908169dfc6",
      "code": "class Solution:\n  def isReachableAtTime(\n      self,\n      sx: int,\n      sy: int,\n      fx: int,\n      fy: int,\n      t: int,\n  ) -> bool:\n    minStep = max(abs(sx - fx), abs(sy - fy))\n    return t != 1 if minStep == 0 else minStep <= t",
      "title": "2849. Determine if a Cell Is Reachable at a Given Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d62fd17f-bb49-475b-b385-4752ce1655e2",
      "code": "class Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) +\n                          self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans",
      "title": "2850. Minimum Moves to Spread Stones Over Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc4de5cd-2d9f-4ff3-96cd-4af93309f855",
      "code": "class Solution:\n  # This dynamic programming table dp[k][i] represents the number of ways to\n  # rearrange the String s after k steps such that it starts with s[i].\n  # A String can be rotated from 1 to n - 1 times. The transition rule is\n  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  # k = 3, the table looks like this:\n  #\n  # -----------------------------------------------------------\n  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  # -----------------------------------------------------------\n  # | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  # | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  # | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  # | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  # -----------------------------------------------------------\n  #\n  # By observation, we have\n  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  #   * dp[k][0] = dp[k][!0] + (-1)^k\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n    # indices in `s` s.t. for each `i` in the returned indices,\n    # `s[i..n) + s[0..i) = t`.\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (pow(n - 1, k, MOD) - negOnePowK) * pow(n, MOD - 2, MOD)\n    dp[0] = dp[1] + negOnePowK\n    return sum(dp[0] if index == 0 else dp[1] for index in indices) % MOD\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "2851. String Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "519daaba-2f86-4709-a156-c21ce9c776a8",
      "code": "class Solution:\n  def sumRemoteness(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    summ = sum(max(0, cell) for row in grid for cell in row)\n    ans = 0\n\n    def dfs(i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (count, componentSum) of the connected component that contains\n      (x, y).\n      \"\"\"\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return (0, 0)\n      if grid[i][j] == -1:\n        return (0, 0)\n\n      count = 1\n      componentSum = grid[i][j]\n      grid[i][j] = -1  # Mark as visited.\n\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        nextCount, nextComponentSum = dfs(x, y)\n        count += nextCount\n        componentSum += nextComponentSum\n\n      return (count, componentSum)\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] > 0:\n          count, componentSum = dfs(i, j)\n          ans += (summ - componentSum) * count\n\n    return ans",
      "title": "2852. Sum of Remoteness of All Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a57e4171-b216-403b-8894-8018a7612008",
      "code": "class Solution:\n  def minimumRightShifts(self, nums: list[int]) -> int:\n    count = 0\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      if a > b:\n        count += 1\n        pivot = i\n\n    if count == 0:\n      return 0\n    if count > 1 or nums[-1] > nums[0]:\n      return -1\n    return len(nums) - pivot - 1",
      "title": "2855. Minimum Right Shifts to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b5632b7-8b37-4488-b644-578963308434",
      "code": "class Solution:\n  def minLengthAfterRemovals(self, nums: list[int]) -> int:\n    n = len(nums)\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n\n    # The number with the maximum frequency cancel all the other numbers.\n    if maxFreq <= n / 2:\n      return n % 2\n    # The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq)",
      "title": "2856. Minimum Array Length After Pair Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0222eb1-aa99-47ef-b4ee-721f1886571c",
      "code": "class Solution:\n  def countPairs(self, coordinates: list[list[int]], k: int) -> int:\n    ans = 0\n\n    for x in range(k + 1):\n      y = k - x\n      count = collections.Counter()\n      for xi, yi in coordinates:\n        ans += count[(xi ^ x, yi ^ y)]\n        count[(xi, yi)] += 1\n\n    return ans",
      "title": "2857. Count Pairs of Points With Distance k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3bcfd9b-9b34-4305-a55b-edfaff209db5",
      "code": "class Solution:\n  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, True))  # 1 means (u -> v)\n      graph[v].append((u, False))  # 0 means (v <- u)\n\n    seen = {0}\n\n    @functools.lru_cache(None)\n    def dp(u: int) -> int:\n      \"\"\"\n      Returns the minimum number of edge reversals so node u can reach every\n      node in its subtree.\n      \"\"\"\n      res = 0\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        res += dp(v) + (0 if isForward else 1)\n      return res\n\n    ans = [0] * n\n    ans[0] = dp(0)\n\n    def dfs(u: int) -> None:\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        ans[v] = ans[u] + (1 if isForward else -1)\n        dfs(v)\n\n    seen = {0}\n    dfs(0)\n    return ans",
      "title": "2858. Minimum Edge Reversals So Every Node Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bafc284-6be6-43bd-90c5-6db17bb365e9",
      "code": "class Solution:\n  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if i.bit_count() == k)",
      "title": "2859. Sum of Values at Indices With K Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bca1b6e-aca4-4518-8439-52286997a235",
      "code": "class Solution:\n  def countWays(self, nums: list[int]) -> int:\n    return sum(a < i < b\n               for i, (a, b) in  # i := the number of the selected numbers\n               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))",
      "title": "2860. Happy Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "173425d8-abb2-4982-9a41-27044c9627d6",
      "code": "class Solution:\n  def maxNumberOfAlloys(self, n: int, k: int, budget: int,\n                        composition: list[list[int]], stock: list[int],\n                        costs: list[int]) -> int:\n    l = 1\n    r = 1_000_000_000\n\n    def isPossible(m: int) -> bool:\n      \"\"\"Returns True if it's possible to create `m` alloys by using any machine.\"\"\"\n      # Try all the possible machines.\n      for machine in composition:\n        requiredMoney = 0\n        for j in range(n):\n          requiredUnits = max(0, machine[j] * m - stock[j])\n          requiredMoney += requiredUnits * costs[j]\n        if requiredMoney <= budget:\n          return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "2861. Maximum Number of Alloys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33a57285-9a4e-4915-ae5a-a32a165c9283",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n    oddPowerToSum = collections.Counter()\n\n    def divideSquares(val: int) -> int:\n      for num in range(2, val + 1):\n        while val % (num * num) == 0:\n          val //= (num * num)\n      return val\n\n    for i, num in enumerate(nums):\n      oddPower = divideSquares(i + 1)\n      oddPowerToSum[oddPower] += num\n      ans = max(ans, oddPowerToSum[oddPower])\n\n    return ans",
      "title": "2862. Maximum Element-Sum of a Complete Subset of Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54e888b5-e03d-4860-b405-adc8571b998a",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) - 1, -1, -1):\n      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.\n      # So, no need to append it.\n      if not stack or nums[stack[-1]] > nums[i]:\n        stack.append(i)\n\n    for i, num in enumerate(nums):\n      while stack and num > nums[stack[-1]]:\n        ans = max(ans, stack.pop() - i + 1)\n\n    return ans",
      "title": "2863. Maximum Length of Semi-Decreasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f99da9f-9364-4195-965d-00fe543ad929",
      "code": "class Solution:\n  def maximumOddBinaryNumber(self, s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'",
      "title": "2864. Maximum Odd Binary Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab1c93c1-d7a1-4376-a32c-93f02dd774d1",
      "code": "class Solution:\n  def maximumSumOfHeights(self, heights: list[int]) -> int:\n    n = len(heights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and heights[stack[-1]] > heights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are heights[j].\n        summ -= abs(j - stack[-1]) * heights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * heights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(heights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - heights[i]\n\n    return max(maxSum)",
      "title": "2865. Beautiful Towers I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4fad80c0-1371-4b47-a323-7e60ea7c710d",
      "code": "class Solution:\n  # Same as 2865. Beautiful Towers I\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)",
      "title": "2866. Beautiful Towers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8dec6c6-9b3a-4a85-998a-44af9133c037",
      "code": "class Solution:\n  def countPaths(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    isPrime = self._sieveEratosthenes(n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      nonlocal ans\n      countZeroPrimePath = int(not isPrime[u])\n      countOnePrimePath = int(isPrime[u])\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)\n        ans += (countZeroPrimePath * countOnePrimeChildPath +\n                countOnePrimePath * countZeroPrimeChildPath)\n        if isPrime[u]:\n          countOnePrimePath += countZeroPrimeChildPath\n        else:\n          countZeroPrimePath += countZeroPrimeChildPath\n          countOnePrimePath += countOnePrimeChildPath\n\n      return countZeroPrimePath, countOnePrimePath\n\n    dfs(1, -1)\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2867. Count Valid Paths in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3373778-e6e8-418d-8e2a-b211d84b9c08",
      "code": "class Solution:\n  def canAliceWin(self, a: list[str], b: list[str]) -> bool:\n    # words[0][i] := the biggest word starting with ('a' + i) for Alice\n    # words[1][i] := the biggest word starting with ('a' + i) for Bob\n    words = [[''] * 26 for _ in range(2)]\n\n    # For each letter, only the biggest word is useful.\n    for word in a:\n      words[0][ord(word[0]) - ord('a')] = word\n\n    for word in b:\n      words[1][ord(word[0]) - ord('a')] = word\n\n    # Find Alice's smallest word.\n    i = 0\n    while not words[0][i]:\n      i += 1\n\n    # 0 := Alice, 1 := Bob\n    # Start with Alice, so it's Bob's turn now.\n    turn = 1\n\n    # Iterate through each letter until we find a winner.\n    while True:\n      # If the current player has a word that having the letter that is greater\n      # than the opponent's word, choose it.\n      if words[turn][i] and words[turn][i] > words[1 - turn][i]:\n        # Choose the current words[turn][i].\n        pass\n      elif words[turn][i + 1]:\n        # Choose the next words[turn][i + 1].\n        i += 1\n      else:\n        # Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1\n      turn = 1 - turn",
      "title": "2868. The Wording Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74837bd2-9a61-4b7e-91c9-19cc1adaa7ba",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    seen = set()\n\n    for i, num in enumerate(reversed(nums)):\n      if num > k:\n        continue\n      seen.add(num)\n      if len(seen) == k:\n        return i + 1",
      "title": "2869. Minimum Operations to Collect Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52ef42fe-3617-4d01-8b7f-54a6850e5830",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    if 1 in count.values():\n      return -1\n    return sum((freq + 2) // 3 for freq in count.values())",
      "title": "2870. Minimum Number of Operations to Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce4699e3-9cff-41bf-ac42-8a4c61f973b8",
      "code": "class Solution:\n  def maxSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n\n    for num in nums:\n      score = num if score == 0 else score & num\n      if score == 0:\n        ans += 1\n\n    return max(1, ans)",
      "title": "2871. Split Array Into Maximum Number of Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a4918a1-4d2e-4e32-b984-db4cfa4f201f",
      "code": "class Solution:\n  def maxKDivisibleComponents(\n      self,\n      n: int,\n      edges: list[list[int]],\n      values: list[int],\n      k: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      treeSum = values[u]\n\n      for v in graph[u]:\n        if v != prev:\n          treeSum += dfs(v, u)\n\n      if treeSum % k == 0:\n        ans += 1\n      return treeSum\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    dfs(0, -1)\n    return ans",
      "title": "2872. Maximum Number of K-Divisible Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fba21c0e-1335-41eb-91d7-5b337503e405",
      "code": "class Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2873. Maximum Value of an Ordered Triplet I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dceedd93-2ff5-46ac-b5c4-f827ac0077b9",
      "code": "class Solution:\n  # Same as 2873. Maximum Value of an Ordered Triplet I\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2874. Maximum Value of an Ordered Triplet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af1881b8-9de4-4ec4-b42e-ebb61c1d48fc",
      "code": "class Solution:\n  def minSizeSubarray(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    n = len(nums)\n    remainingTarget = target % summ\n    repeatLength = (target // summ) * n\n    if remainingTarget == 0:\n      return repeatLength\n\n    suffixPlusPrefixLength = n\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i in range(2 * n):\n      prefix += nums[i % n]\n      if prefix - remainingTarget in prefixToIndex:\n        suffixPlusPrefixLength = min(\n            suffixPlusPrefixLength,\n            i - prefixToIndex[prefix - remainingTarget])\n      prefixToIndex[prefix] = i\n\n    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength",
      "title": "2875. Minimum Size Subarray in Infinite Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a57d6bd6-bcc8-430a-a0cb-2c83ee70c1c0",
      "code": "class Solution:\n  def countVisitedNodes(self, edges: list[int]) -> list[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    # Push non-cyclic nodes to stack.\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    # Fill the length of cyclic nodes.\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    # Fill the length of non-cyclic nodes.\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(\n      self,\n      edges: list[int],\n      start: int,\n      seen: list[bool],\n      ans: list[int],\n  ) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]",
      "title": "2876. Count Visited Nodes in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9caf8e2d-e993-4709-8cc4-eda54ccc8bc0",
      "code": "class Solution:\n  def minArrayLength(self, nums: list[int], k: int) -> int:\n    count = 0\n    prod = -1\n\n    for num in nums:\n      if num == 0:\n        return 1\n      if prod != -1 and prod * num <= k:\n        prod *= num\n      else:\n        prod = num\n        count += 1\n\n    return count",
      "title": "2892. Minimizing Array After Replacing Pairs With Their Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "757ebfa0-d332-4446-9d97-e9c9908380a0",
      "code": "class Solution:\n  def differenceOfSums(self, n: int, m: int) -> int:\n    summ = (1 + n) * n // 2\n    num2 = self._getDivisibleSum(n, m)\n    num1 = summ - num2\n    return num1 - num2\n\n  def _getDivisibleSum(self, n: int, m: int) -> int:\n    \"\"\"Returns the sum of all the integers in [1, n] that are divisible by m.\"\"\"\n    last = n // m * m\n    if last == 0:\n      return 0\n    first = m\n    count = (last - first) // m + 1\n    return (first + last) * count // 2",
      "title": "2894. Divisible and Non-divisible Sums Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46d66aeb-7370-4933-b29b-f2691968fb07",
      "code": "class Solution:\n  def minProcessingTime(\n      self,\n      processorTime: list[int],\n      tasks: list[int],\n  ) -> int:\n    return max(time + task\n               for (time, task) in zip(\n                   sorted(processorTime),\n                   sorted(tasks)[:: -4]))",
      "title": "2895. Minimum Processing Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5119670f-8d8e-4668-8287-eee54febb2ff",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    #         dp := the minimum cost to correct diffIndices[i:]\n    #     dpNext := the minimum cost to correct diffIndices[i + 1:]\n    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]\n    dpNext = x / 2\n    dpNextNext = 0\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp = min(dpNext + x / 2,\n               dpNextNext + diffIndices[i + 1] - diffIndices[i])\n      dpNextNext = dpNext\n      dpNext = dp\n\n    return int(dp)",
      "title": "2896. Apply Operations to Make Two Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2ee904d-e239-43bd-b6ed-d9c4f15c2e6e",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the minimum cost to correct diffIndices[i..n).\"\"\"\n      if i == len(diffIndices):\n        return 0\n      if i == len(diffIndices) - 1:\n        return x / 2\n      return min(dp(i + 1) + x / 2,\n                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp(0))",
      "title": "2896. Apply Operations to Make Two Strings Equal_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "014b67c5-46b9-4e92-8148-870800ecd8e9",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = 0\n    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    # should be moved to\n    minIndices = [0] * MAX_BIT\n    optimalNums = [0] * len(nums)\n\n    for num in nums:\n      for i in range(MAX_BIT):\n        if num >> i & 1:\n          optimalNums[minIndices[i]] |= 1 << i\n          minIndices[i] += 1\n\n    for i in range(k):\n      ans += optimalNums[i]**2\n      ans %= MOD\n\n    return ans",
      "title": "2897. Apply Operations on Array to Maximize Sum of Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9113e4f8-aa31-42fe-9528-16dea6cbccb2",
      "code": "class Solution:\n  def maxScore(self, prices: list[int]) -> int:\n    groupIdToSum = collections.defaultdict(int)\n\n    for i, price in enumerate(prices):\n      groupIdToSum[price - i] += price\n\n    return max(groupIdToSum.values())",
      "title": "2898. Maximum Linear Stock Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d9ae36f-e75f-4576-8ae9-1737fbf5adea",
      "code": "class Solution:\n  def lastVisitedIntegers(self, words: list[str]) -> list[int]:\n    ans = []\n    nums = []\n    k = 0\n\n    for word in words:\n      if word == 'prev':\n        k += 1\n        ans.append(-1 if k > len(nums) else nums[-k])\n      else:\n        k = 0\n        nums.append(int(word))\n\n    return ans",
      "title": "2899. Last Visited Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd54a72f-adfc-44a8-ae4c-a5340d245a4b",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    groupId = -1\n\n    for word, group in zip(words, groups):\n      if group != groupId:\n        groupId = group\n        ans.append(word)\n\n    return ans",
      "title": "2900. Longest Unequal Adjacent Groups Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddd00b56-3cc8-4eb1-a1ee-63256f74923e",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    # dp[i] := the length of the longest subsequence ending in `words[i]`\n    dp = [1] * n\n    # prev[i] := the best index of words[i]\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    # Find the last index of the subsequence.\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]",
      "title": "2901. Longest Unequal Adjacent Groups Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5068db6f-c4c7-41e5-814f-53e073243b43",
      "code": "class Solution:\n  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of submultisets of `nums` with sum i\n    dp = [1] + [0] * r\n    count = collections.Counter(nums)\n    zeros = count.pop(0, 0)\n\n    for num, freq in count.items():\n      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      stride = dp.copy()\n      for i in range(num, r + 1):\n        stride[i] += stride[i - num]\n      for i in range(r, 0, -1):\n        if i >= num * (freq + 1):\n          # dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = stride[i] - stride[i - num * (freq + 1)]\n        else:\n          dp[i] = stride[i]\n\n    return (zeros + 1) * sum(dp[l:r + 1]) % MOD",
      "title": "2902. Count of Sub-Multisets With Bounded Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c314b13-3db1-4c6c-a35d-e38e22dec601",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the\n    # current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the\n    # current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2903. Find Indices With Index and Value Difference I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07c5b3af-8c13-4baf-8396-9363f498c554",
      "code": "class Solution:\n  # Same as 76. Minimum Window Substring\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    return \"\" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]",
      "title": "2904. Shortest and Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b36cef4a-7a0e-4b4f-82ba-78c405df47ed",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2905. Find Indices With Index and Value Difference II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2463bb4c-de23-4089-8df2-4afb8e6c219b",
      "code": "class Solution:\n  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    MOD = 12345\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [1]\n    suffix = 1\n\n    for row in grid:\n      for num in row:\n        prefix.append(prefix[-1] * num % MOD)\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        ans[i][j] = prefix[i * n + j] * suffix % MOD\n        suffix = suffix * grid[i][j] % MOD\n\n    return ans",
      "title": "2906. Construct Product Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5568e81e-eb36-44b2-83de-dbc63d546bdc",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2907. Maximum Profitable Triplets With Increasing Prices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27c63c4c-9abc-4af3-9c17-cd14ed94144a",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2908. Minimum Sum of Mountain Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96d0adc3-0fe2-40b4-9196-0061d7fa0625",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2909. Minimum Sum of Mountain Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7fa6748-57a2-4b75-b534-d61fac0c3517",
      "code": "class Solution:\n  def minGroupsForValidAssignment(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    minFreq = min(count.values())\n\n    for groupSize in range(minFreq, 0, -1):\n      numGroups = self.getNumGroups(count, groupSize)\n      if numGroups > 0:\n        return numGroups\n\n    raise ValueError(\"Invalid argument\")\n\n  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:\n    \"\"\"Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.\"\"\"\n    numGroups = 0\n    for freq in count.values():\n      a = freq // (groupSize + 1)\n      b = freq % (groupSize + 1)\n      if b == 0:\n        # Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        # `a + 1` groups.\n        numGroups += a\n      elif groupSize - b <= a:\n        numGroups += a + 1\n      else:\n        return 0\n    return numGroups",
      "title": "2910. Minimum Number of Groups to Create a Valid Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba0e250-3ac1-4a03-83a0-a8bc44c52b18",
      "code": "class Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    # factors[i] := factors of i\n    factors = self._getFactors(n)\n    # cost[i][j] := changes to make s[i..j] a semi-palindrome\n    cost = self._getCost(s, n, factors)\n    # dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> list[list[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i, j in itertools.combinations(range(n), 2):\n      length = j - i + 1\n      minCost = length\n      for d in factors[length]:\n        minCost = min(minCost, self._getCostD(s, i, j, d))\n      cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    \"\"\"Returns the cost to make s[i..j] a semi-palindrome of `d`.\"\"\"\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost",
      "title": "2911. Minimum Changes to Make K Semi-palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9165a8a5-4377-4485-80c6-676ffb299b9e",
      "code": "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i][0] := the the number of ways of `source` to `dest` using i steps\n    # dp[i][1] := the the number of ways of `source` to dest's row using i steps\n    # dp[i][2] := the the number of ways of `source` to dest's col using i steps\n    # dp[i][3] := the the number of ways of `source` to others using i steps\n    dp = [[0] * 4 for _ in range(k + 1)]\n    if source == dest:\n      dp[0][0] = 1\n    elif source[0] == dest[0]:\n      dp[0][1] = 1\n    elif source[1] == dest[1]:\n      dp[0][2] = 1\n    else:\n      dp[0][3] = 1\n\n    for i in range(1, k + 1):\n      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD\n      dp[i][1] = (dp[i - 1][0] * (m - 1) +  # -self\n                  dp[i - 1][1] * (m - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][2] = (dp[i - 1][0] * (n - 1) +  # -self\n                  dp[i - 1][2] * (n - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][3] = (dp[i - 1][1] * (n - 1) +  # -self\n                  dp[i - 1][2] * (m - 1) +  # -self\n                  dp[i - 1][3] * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n\n    return dp[k][0]",
      "title": "2912. Number of Ways to Reach Destination in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69061b04-543e-4685-8926-56f6ba84e303",
      "code": "class Solution:\n  def minChanges(self, s: str) -> int:\n    return sum(a != b for a, b in zip(s[::2], s[1::2]))",
      "title": "2914. Minimum Number of Changes to Make Binary String Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6513751e-445a-47fc-bf3b-6641f5da3c71",
      "code": "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum length of any subsequence of the first i numbers\n    # that sum to j\n    dp = [[-1] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      dp[i][0] = 0\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(1, target + 1):\n        # 1. Skip `num`.\n        if j < num or dp[i - 1][j - num] == -1:\n          dp[i][j] = dp[i - 1][j]\n        # 2. Skip `num` or pick `num`.\n        else:\n          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])\n\n    return dp[n][target]",
      "title": "2915. Length of the Longest Subsequence That Sums to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72f16978-278d-4f57-bb90-d373fadd020d",
      "code": "class Solution:\n  def findKOr(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    return sum(2**i\n               for i in range(MAX_BIT + 1)\n               if sum(num >> i & 1 for num in nums) >= k)",
      "title": "2917. Find the K-or of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b23d07ce-7e71-4ec7-a948-325193c16181",
      "code": "class Solution:\n  def minSum(self, nums1: list[int], nums2: list[int]) -> int:\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n    zero1 = nums1.count(0)\n    zero2 = nums2.count(0)\n    if zero1 == 0 and sum1 < sum2 + zero2:\n      return -1\n    if zero2 == 0 and sum2 < sum1 + zero1:\n      return -1\n    return max(sum1 + zero1, sum2 + zero2)",
      "title": "2918. Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fafff61-fa3e-4e90-acd4-7f1cbf52f084",
      "code": "class Solution:\n  def minIncrementOperations(self, nums: list[int], k: int) -> int:\n    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    prev3 = 0\n    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    prev2 = 0\n    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    prev1 = 0\n\n    for num in nums:\n      dp = min(prev1, prev2, prev3) + max(0, k - num)\n      prev3 = prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return min(prev1, prev2, prev3)",
      "title": "2919. Minimum Increment Operations to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c94558d-b186-433a-8979-5b75de63cf18",
      "code": "class Solution:\n  def maximumPoints(\n      self,\n      edges: list[list[int]],\n      coins: list[int],\n      k: int,\n  ) -> int:\n    MAX_COIN = 10000\n    MAX_HALVED = int(MAX_COIN).bit_length()\n    n = len(coins)\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, halved: int) -> int:\n      # All the children will be 0, so no need to explore.\n      if halved > MAX_HALVED:\n        return 0\n\n      val = coins[u] // (1 << halved)\n      takeAll = val - k\n      takeHalf = math.floor(val / 2)\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        takeAll += dfs(v, u, halved)\n        takeHalf += dfs(v, u, halved + 1)\n\n      return max(takeAll, takeHalf)\n\n    return dfs(0, -1, 0)",
      "title": "2920. Maximum Points After Collecting Coins From All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1a390d0-e981-4e5f-88bf-9d81b419ffe9",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2921. Maximum Profitable Triplets With Increasing Prices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68a73b74-01b4-4c16-99ce-c11954b90030",
      "code": "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    inDegrees = [0] * n\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          continue\n        if grid[i][j] == 1:\n          inDegrees[j] += 1\n        else:\n          inDegrees[i] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2923. Find Champion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8977ec0-9237-457b-976a-45316597628e",
      "code": "class Solution:\n  def findChampion(self, n: int, edges: list[list[int]]) -> int:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2924. Find Champion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "825f74f3-9fe4-428d-a5c9-f9c68de0a6bd",
      "code": "class Solution:\n  def maximumScoreAfterOperations(\n      self,\n      edges: list[list[int]],\n      values: list[int],\n  ) -> int:\n    tree = [[] for _ in values]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      if u > 0 and len(tree[u]) == 1:\n        return values[u]\n      childrenSum = sum(dfs(v, u)\n                        for v in tree[u]\n                        if v != prev)\n      return min(childrenSum, values[u])\n\n    return sum(values) - dfs(0, -1)",
      "title": "2925. Maximum Score After Applying Operations on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8eb61be4-cec9-4aef-92b7-e1ef3c1db4b0",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    \"\"\"Updates the maximum sum of subsequence ending in (i - 1) with `val`.\"\"\"\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    \"\"\"Returns the maximum sum of subsequence ending in (i - 1).\"\"\"\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:\n    # Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    # By observation:\n    #    nums[i] - nums[j] >= i - j\n    # => nums[i] - i >= nums[j] - j\n    # So, if nums[i] - i >= nums[j] - j, where i > j,\n    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    ans = -math.inf\n    tree = FenwickTree(len(nums))\n\n    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):\n      subseqSum = tree.get(i) + nums[i]\n      tree.maximize(i + 1, subseqSum)\n      ans = max(ans, subseqSum)\n\n    return ans",
      "title": "2926. Maximum Balanced Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ce27348-3a9b-45b0-b2c7-c8273a0ed3fb",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2927. Distribute Candies Among Children III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1db617d1-b895-47ab-bbd1-cf928495412c",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2928. Distribute Candies Among Children I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11695c0e-b7cc-4b85-874a-c214ce01f58d",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2929. Distribute Candies Among Children II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d3f76c-397b-4c7e-a86c-a09156fa2727",
      "code": "class Solution:\n  def stringCount(self, n: int) -> int:\n    # There're three invalid conditions:\n    #   a. count('l') == 0\n    #   b. count('e') < 2\n    #   c. count('t') == 0\n    #\n    # By Principle of Inclusion-Exclusion (PIE):\n    #   ans = allCount - a - b - c + ab + ac + bc - abc\n    MOD = 1_000_000_007\n    allCount = pow(26, n, MOD)\n    a = pow(25, n, MOD)\n    b = pow(25, n, MOD)\n    c = pow(25, n, MOD) + n * pow(25, n - 1, MOD)\n    ab = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    ac = pow(24, n, MOD)\n    bc = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    abc = pow(23, n, MOD) + n * pow(23, n - 1, MOD)\n    return (allCount - a - b - c + ab + ac + bc - abc) % MOD",
      "title": "2930. Number of Strings Which Can Be Rearranged to Contain Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "773b9339-9351-442c-9927-7ac8e24a8bb6",
      "code": "class Solution:\n  def maxSpending(self, values: list[list[int]]) -> int:\n    items = sorted(item for shop in values for item in shop)\n    return sum(item * d for d, item in enumerate(items, 1))",
      "title": "2931. Maximum Spending After Buying Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6f904e6-b919-4edb-b3c4-5db7069c54ea",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2932. Maximum Strong Pair XOR I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "236f5b5b-243b-4bc2-978a-eaeea6c6c4ac",
      "code": "class Solution:\n  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:\n    ans = set()\n\n    access_times.sort()\n\n    for i in range(len(access_times) - 2):\n      name = access_times[i][0]\n      if name in ans:\n        continue\n      if name != access_times[i + 2][0]:\n        continue\n      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:\n        ans.add(name)\n\n    return list(ans)",
      "title": "2933. High-Access Employees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c56d6a1-cfd5-4b0f-8cd8-de6b0f0a81cd",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    mn = min(nums1[-1], nums2[-1])\n    mx = max(nums1[-1], nums2[-1])\n    # the number of the minimum operations, where nums1[n - 1] is not swapped\n    # with nums2[n - 1]\n    dp1 = 0\n    # the number of the minimum operations, where nums1[n - 1] is swapped with\n    # nums2[n - 1]\n    dp2 = 0\n\n    for a, b in zip(nums1, nums2):\n      if min(a, b) > mn:\n        return -1\n      if max(a, b) > mx:\n        return -1\n      if a > nums1[-1] or b > nums2[-1]:\n        dp1 += 1\n      if a > nums2[-1] or b > nums1[-1]:\n        dp2 += 1\n\n    return min(dp1, dp2)",
      "title": "2934. Minimum Operations to Maximize Last Elements in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33856b2c-b4be-40de-8a3d-e11d97126139",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Same as 2932. Maximum Strong Pair XOR I\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2935. Maximum Strong Pair XOR II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be2dabd3-c2a1-4a03-9bb0-57e8d149b18b",
      "code": "# Definition for BigArray.\n# class BigArray:\n#   def at(self, index: long) -> int:\n#     pass\n#   def size(self) -> long:\n#     pass\n\nclass Solution(object):\n  def countBlocks(self, nums: Optional['BigArray']) -> int:\n    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:\n      \"\"\"Returns the number of maximal blocks in nums[l..r].\"\"\"\n      if leftValue == rightValue:\n        return 1\n      if l + 1 == r:\n        return 2\n      m = (l + r) // 2\n      midValue = nums.at(m)\n      return (countBlocks(l, m, leftValue, midValue) +\n              countBlocks(m, r, midValue, rightValue) - 1)\n    # Substract nums[m], which will be counted twice.\n    return countBlocks(0, nums.size() - 1,\n                       nums.at(0), nums.at(nums.size() - 1))",
      "title": "2936. Number of Equal Numbers Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aebf09aa-7718-42db-90de-212723794ea4",
      "code": "class Solution:\n  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n    minLength = min(map(len, [s1, s2, s3]))\n    i = 0\n    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:\n      i += 1\n    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3",
      "title": "2937. Make Three Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "541e7514-5b39-42cd-9501-b357a6ddc51e",
      "code": "class Solution:\n  def minimumSteps(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for c in s:\n      if c == '1':\n        ones += 1\n      else:  # Move 1s to the front of the current '0'.\n        ans += ones\n\n    return ans",
      "title": "2938. Separate Black and White Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e81d81f-64e5-4eec-8581-9831456e7053",
      "code": "class Solution:\n  def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n    MOD = 1_000_000_007\n    for bit in (2**i for i in range(n)):\n      # Pick a bit if it makes min(a, b) larger.\n      if a * b < (a ^ bit) * (b ^ bit):\n        a ^= bit\n        b ^= bit\n    return a * b % MOD",
      "title": "2939. Maximum Xor Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "657d7b44-2c14-49a9-b60a-d24a48e6ba13",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedQuery:\n  queryIndex: int\n  a: int  # Alice's index\n  b: int  # Bob's index\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  # Similar to 2736. Maximum Sum Queries\n  def leftmostBuildingQueries(\n      self,\n      heights: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(queries)\n    # Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    # descending order.\n    stack = []\n\n    # Iterate through queries and heights simultaneously.\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))\n                                    for i, (a, b) in enumerate(queries)],\n                                   key=lambda x: -x.b):\n      if a == b or heights[a] < heights[b]:\n        # 1. Alice and Bob are already in the same index (a == b) or\n        # 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b\n      else:\n        # Now, a < b and heights[a] >= heights[b].\n        # Gradually add heights with an index > b to the monotonic stack.\n        while heightsIndex > b:\n          # heights[heightsIndex] is a better candidate, given that\n          # heightsIndex is smaller than the indices in the stack and\n          # heights[heightsIndex] is larger or equal to the heights mapped in\n          # the stack.\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        # Binary search to find the smallest index j such that j > b and\n        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: list[int], target: int, heights: list[int]):\n    \"\"\"\n    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].\n    \"\"\"\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l",
      "title": "2940. Find Building Where Alice and Bob Can Meet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2cdf634-b241-437d-932d-f3bb672fde61",
      "code": "class Solution:\n  def maxGcdSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # [(startIndex, gcd of subarray starting at startIndex)]\n    startIndexAndGcds = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i, num in enumerate(nums):\n      nextStartIndexAndGcds = []\n      for startIndex, gcd in startIndexAndGcds:\n        nextGcd = math.gcd(gcd, nums[i])\n        if (not nextStartIndexAndGcds or\n                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.\n          nextStartIndexAndGcds.append((startIndex, nextGcd))\n      startIndexAndGcds = nextStartIndexAndGcds\n      startIndexAndGcds.append((i, nums[i]))\n      for startIndex, gcd in startIndexAndGcds:\n        if i - startIndex + 1 >= k:\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)\n\n    return ans",
      "title": "2941. Maximum GCD-Sum of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e65cd4f-457f-4a0c-bd67-d39477c180f7",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2944. Minimum Number of Coins for Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25b3daad-47df-465d-885b-1d5d3dfc80ad",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2944. Minimum Number of Coins for Fruits_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3dd2749b-5a7e-41b0-b889-dbcc0d6d16b2",
      "code": "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # bestLeft[i] := the index l s.t. merging nums[l..i) is the\n    # optimal strategy among processing the first i nums\n    bestLeft = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])\n      # When merging nums[l, i), consider the next segment as [i, r).\n      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).\n      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].\n      #            => prefix[r] >= prefix[i] * 2 - prefix[l]\n      # Therefore, we can binary search `prefix` to find the minimum `r`.\n      l = bestLeft[i]\n      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])\n      dp[i] = dp[l] + 1\n      bestLeft[r] = i\n\n    return dp[n]",
      "title": "2945. Find Maximum Non-decreasing Array Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9c811cb-8903-4980-84bb-57d1e3e47810",
      "code": "class Solution:\n  def areSimilar(self, mat: list[list[int]], k: int) -> bool:\n    n = len(mat[0])\n    for row in mat:\n      for j in range(n):\n        if row[j] != row[(j + k) % n]:\n          return False\n    return True",
      "title": "2946. Matrix Similarity After Cyclic Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aefb87e-585c-4d7a-849d-55153cbe071b",
      "code": "class Solution:\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2947. Count Beautiful Substrings I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b742c305-ec06-4582-9491-5e18d7abc39c",
      "code": "class Solution:\n  def lexicographicallySmallestArray(\n      self,\n      nums: list[int],\n      limit: int,\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    # [[(num, index)]], where the difference between in each pair in each\n    # `[(num, index)]` group <= `limit`\n    numAndIndexesGroups: list[list[tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if (not numAndIndexesGroups or\n              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):\n        # Start a new group.\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        # Append to the existing group.\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans",
      "title": "2948. Make Lexicographically Smallest Array by Swapping Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf85f753-0e6c-4b54-8a33-8c33317e739d",
      "code": "class Solution:\n  # Same as 2947. Count Beautiful Substrings I\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2949. Count Beautiful Substrings II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38afca77-7218-4199-85ec-b59791d197a8",
      "code": "class Solution:\n  def countDivisibleSubstrings(self, word: str) -> int:\n    # Let f(c) = d, where d = 1, 2, ..., 9.\n    # Rephrase the question to return the number of substrings that satisfy\n    #    f(c1) + f(c2) + ... + f(ck) // k = avg\n    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    ans = 0\n\n    def f(c: str) -> int:\n      return 9 - (ord('z') - ord(c)) // 3\n\n    for avg in range(1, 10):\n      prefix = 0\n      prefixCount = collections.Counter({0: 1})\n      for c in word:\n        prefix += f(c) - avg\n        ans += prefixCount[prefix]\n        prefixCount[prefix] += 1\n\n    return ans",
      "title": "2950. Number of Divisible Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e5ae213-5a95-4d11-a299-5466d117b211",
      "code": "class Solution:\n  def findPeaks(self, mountain: list[int]) -> list[int]:\n    return [i for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]]",
      "title": "2951. Find the Peaks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48271285-de59-48e5-8a9f-edb92969a0d4",
      "code": "class Solution:\n  # Same as 330. Patching Array\n  def minimumAddedCoins(self, coins: list[int], target: int) -> int:\n    ans = 0\n    i = 0  # coins' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    coins.sort()\n\n    while miss <= target:\n      if i < len(coins) and coins[i] <= miss:\n        miss += coins[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "2952. Minimum Number of Coins to be Added",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d6cc5bf-936d-42af-800d-5a70484a9e01",
      "code": "class Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize)\n               for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    \"\"\"\n    Returns the number of complete substrings of `windowSize` of `word`.\n    \"\"\"\n    res = 0\n    countLetters = 0  # the number of letters in the running substring\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        # Start a new substring starting at word[i].\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res",
      "title": "2953. Count Complete Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61f5dee2-47c3-45c3-9e1d-12d82ae92395",
      "code": "class Solution:\n  def numberOfSequence(self, n: int, sick: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    ans = fact(n - len(sick))  # the number of infected children\n    prevSick = -1\n\n    for i, s in enumerate(sick):\n      # The segment [prevSick + 1, sick - 1] are the current non-infected\n      # children.\n      nonInfected = sick[i] - prevSick - 1\n      prevSick = sick[i]\n      if nonInfected == 0:\n        continue\n      ans *= inv(fact(nonInfected))\n      ans %= MOD\n      if i > 0:\n        # There're two choices per second since the children at the two\n        # endpoints can both be the infect candidates. So, there are\n        # 2^[nonInfected - 1] ways to infect all children in the current\n        # segment.\n        ans *= pow(2, nonInfected - 1, MOD)\n\n    nonInfected = n - sick[-1] - 1\n    return ans * inv(fact(nonInfected)) % MOD",
      "title": "2954. Count the Number of Infection Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b828375e-be83-4b03-b795-025bb7981cce",
      "code": "class Solution:\n  def sameEndSubstringCount(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[int]:\n    count = collections.Counter()\n    # counts[i] := the count of s[0..i)\n    counts = [count.copy()]\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n\n    ans = []\n\n    for l, r in queries:\n      sameEndCount = 0\n      for c in string.ascii_lowercase:\n        #   the count of s[0..r] - the count of s[0..l - 1]\n        # = the count of s[l..r]\n        freq = counts[r + 1][c] - counts[l][c]\n        #   C(freq, 2) + freq\n        # = freq * (freq - 1) / 2 + freq\n        # = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) // 2\n      ans.append(sameEndCount)\n\n    return ans",
      "title": "2955. Number of Same-End Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81e4c77b-f36b-4f6a-8784-4c3b1250e8a9",
      "code": "class Solution:\n  def findIntersectionValues(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n  ) -> list[int]:\n    nums1Set = set(nums1)\n    nums2Set = set(nums2)\n    return [sum(num in nums2Set for num in nums1),\n            sum(num in nums1Set for num in nums2)]",
      "title": "2956. Find Common Elements Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f0c012d-50ad-4161-88e4-c7229d195e91",
      "code": "class Solution:\n  def removeAlmostEqualCharacters(self, word: str) -> int:\n    ans = 0\n    i = 1\n    while i < len(word):\n      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:\n        ans += 1\n        i += 2\n      else:\n        i += 1\n    return ans",
      "title": "2957. Remove Adjacent Almost-Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bca36f30-e482-454d-898a-83a10f102263",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      while count[num] == k + 1:\n        count[nums[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2958. Length of Longest Subarray With at Most K Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ae0339-5cac-47d6-a98b-32ab48b3b2f9",
      "code": "class Solution:\n  def numberOfSets(\n      self,\n      n: int,\n      maxDistance: int,\n      roads: list[list[int]],\n  ) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance\n               for mask in range(1 << n))\n\n  def _floydWarshall(\n      self,\n      n: int,\n      maxDistanceThreshold: int,\n      roads: list[list[int]],\n      mask: int,\n  ) -> list[list[int]]:\n    \"\"\"\n    Returns the maximum distance between any two branches, where the mask\n    represents the selected branches.\n    \"\"\"\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance",
      "title": "2959. Number of Possible Sets of Closing Branches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed97ac79-9f2a-45f1-a358-cddecdb03afd",
      "code": "class Solution:\n  def countTestedDevices(self, batteryPercentages: list[int]) -> int:\n    ans = 0\n\n    for batteryPercentage in batteryPercentages:\n      if batteryPercentage - ans > 0:\n        ans += 1\n\n    return ans",
      "title": "2960. Count Tested Devices After Test Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89273687-b419-4098-9fa9-0fc8018b6312",
      "code": "class Solution:\n  def getGoodIndices(\n      self,\n      variables: list[list[int]],\n      target: int,\n  ) -> list[int]:\n    return [i for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target]",
      "title": "2961. Double Modular Exponentiation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08532d4c-8e77-4092-832f-a5503955ef11",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    maxNum = max(nums)\n    ans = 0\n    count = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == maxNum:\n        count += 1\n      # Keep the window to include k - 1 times of the maxNummum number.\n      while count == k:\n        if nums[l] == maxNum:\n          count -= 1\n        l += 1\n      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any\n      # subarray nums[i:r+1], where i < l, it will have at least k times of the\n      # maxNummum number, since nums[l - 1] equals the maxNummum number.\n      ans += l\n\n    return ans",
      "title": "2962. Count Subarrays Where Max Element Appears at Least K Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83087700-114d-48c0-a51f-561c0d150078",
      "code": "class Solution:\n  def numberOfGoodPartitions(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    # lastSeen[num] := the index of the last time `num` appeared\n    lastSeen = {}\n\n    for i, num in enumerate(nums):\n      lastSeen[num] = i\n\n    # Track the maximum right index of each running partition by ensuring that\n    # the first and last occurrences of a number fall within the same partition.\n    maxRight = 0\n    for i, num in enumerate(nums):\n      if i > maxRight:\n        # Start a new partition that starts from nums[i].\n        # Each partition doubles the total number of good partitions.\n        ans = ans * 2 % MOD\n      maxRight = max(maxRight, lastSeen[num])\n\n    return ans",
      "title": "2963. Count the Number of Good Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d14553fc-32a5-47b2-bcec-cdb612e078be",
      "code": "class Solution:\n  # Similar to 1995. Count Special Quadruplets\n  def divisibleTripletCount(self, nums: list[int], d: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.\n      for i in range(j - 1, -1, -1):\n        ans += count[-(nums[i] + nums[j]) % d]\n      count[nums[j] % d] += 1  # j := k\n\n    return ans",
      "title": "2964. Number of Divisible Triplet Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4adb038c-f907-4925-a23c-ced23a3881a7",
      "code": "class Solution:\n  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:\n    count = [1] + [0] * len(grid)**2  # padding for 1-indexed\n\n    for row in grid:\n      for num in row:\n        count[num] += 1\n\n    return [count.index(2), count.index(0)]",
      "title": "2965. Find Missing and Repeated Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdb6df39-3a53-44e1-bf31-fb4e699493ac",
      "code": "class Solution:\n  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:\n    ans = []\n\n    nums.sort()\n\n    for i in range(2, len(nums), 3):\n      if nums[i] - nums[i - 2] > k:\n        return []\n      ans.append([nums[i - 2], nums[i - 1], nums[i]])\n\n    return ans",
      "title": "2966. Divide Array Into Arrays With Max Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "689dcae6-8792-4e71-baf5-da48dfb8fb31",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    nums.sort()\n    median = nums[len(nums) // 2]\n    nextPalindrome = self._getPalindrome(median, delta=1)\n    prevPalindrome = self._getPalindrome(median, delta=-1)\n    return min(self._cost(nums, nextPalindrome),\n               self._cost(nums, prevPalindrome))\n\n  def _cost(self, nums: list[int], palindrome: int) -> int:\n    \"\"\"Returns the cost to change all the numbers to `palindrome`.\"\"\"\n    return sum(abs(palindrome - num) for num in nums)\n\n  def _getPalindrome(self, num: int, delta: int) -> int:\n    \"\"\"Returns the palindrome `p`, where p = num + a * delta and a > 0.\"\"\"\n    while not self._isPalindrome(num):\n      num += delta\n    return num\n\n  def _isPalindrome(self, num: int) -> int:\n    original = str(num)\n    return original == original[::-1]",
      "title": "2967. Minimum Cost to Make Array Equalindromic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "079c6daf-648d-4170-a8e8-d824f17acf4e",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = 0\n    cost = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      cost += num - nums[(l + r) // 2]\n      while cost > k:\n        cost -= nums[(l + r + 1) // 2] - nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2968. Apply Operations to Maximize Frequency Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9425182f-60f3-4df6-aa5a-35878413b03d",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2969. Minimum Number of Coins for Fruits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f059ab2-357c-4c43-a0b5-8667b9ebee10",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2969. Minimum Number of Coins for Fruits II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f5a69db-25a4-4384-a81f-195c32088f20",
      "code": "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2970. Count the Number of Incremovable Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d380486-0309-4588-9d53-0a64f3946eb2",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    prefix = sum(nums)\n\n    for num in sorted(nums, reverse=True):\n      prefix -= num\n      # Let `num` be the longest side. Check if the sum of all the edges with\n      # length no longer than `num` > `num``.\n      if prefix > num:\n        return prefix + num\n\n    return -1",
      "title": "2971. Find Polygon With the Largest Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c15ed135-72a4-468a-9d15-669431c9e982",
      "code": "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2972. Count the Number of Incremovable Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "975d35bb-f3b7-4da1-aefe-de10c77522e5",
      "code": "class ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res,\n                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans",
      "title": "2973. Find Number of Coins to Place in Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76f0e5e7-59d9-472d-b576-4fe738c3b063",
      "code": "class Solution:\n  def numberGame(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    return [nums[i + 1] if i % 2 == 0\n            else nums[i - 1]\n            for i in range(len(nums))]",
      "title": "2974. Minimum Number Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab082f6c-a0c2-44fc-a4de-48bf33409862",
      "code": "class Solution:\n  def maximizeSquareArea(\n      self,\n      m: int,\n      n: int,\n      hFences: list[int],\n      vFences: list[int],\n  ) -> int:\n    hFences = sorted(hFences + [1, m])\n    vFences = sorted(vFences + [1, n])\n    hGaps = {hFences[i] - hFences[j]\n             for i in range(len(hFences))\n             for j in range(i)}\n    vGaps = {vFences[i] - vFences[j]\n             for i in range(len(vFences))\n             for j in range(i)}\n    maxGap = next((hGap\n                  for hGap in sorted(hGaps, reverse=True)\n                  if hGap in vGaps), -1)\n    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)",
      "title": "2975. Maximum Square Area by Removing Fences From a Field",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b622c919-a084-495e-b6fa-047bd21ab524",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    ans = 0\n    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans",
      "title": "2976. Minimum Cost to Convert String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d190e4f-8be2-4472-88c0-449ab8e98b08",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    # dist[u][v] := the minimum distance to change the substring with id u to\n    # the substring with id v\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    # dp[i] := the minimum cost to change the first i letters of `source` into\n    # `target`, leaving the suffix untouched\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    return -1 if dp[len(source)] == math.inf else dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId",
      "title": "2977. Minimum Cost to Convert String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07311a13-4361-4f71-b057-6bbfb2ee5611",
      "code": "class Solution:\n  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n    # https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo",
      "title": "2979. Most Expensive Item That Can Not Be Bought",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ca4db40-3bf5-4655-91bb-edb92b4317c7",
      "code": "class Solution:\n  def hasTrailingZeros(self, nums: list[int]) -> bool:\n    return sum(num % 2 == 0 for num in nums) >= 2",
      "title": "2980. Check if Bitwise OR Has Trailing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ab7be14-87f9-457d-8a84-b32803561d2a",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2981. Find Longest Special Substring That Occurs Thrice I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf9a01d9-9884-4eaa-a130-91437aeebced",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2982. Find Longest Special Substring That Occurs Thrice II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9c67392-eacf-4d2e-8169-f1a24ff1ec4c",
      "code": "class Solution:\n  def canMakePalindromeQueries(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    n = len(s)\n    # mirroredDiffs[i] := the number of different letters between the first i\n    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    mirroredDiffs = self._getMirroredDiffs(s)\n    # counts[i] := the count of s[0..i)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: list[int], b: list[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      # Use left-closed, right-open intervals to facilitate the calculation.\n      #   ...... [a, b) ...|... [rb, ra) ......\n      #   .... [rd, rc) .....|..... [c, d) ....\n      b += 1\n      d += 1\n      ra = n - a  # the reflected index of a in s[n / 2..n)\n      rb = n - b  # the reflected index of b in s[n / 2..n)\n      rc = n - c  # the reflected index of c in s[n / 2..n)\n      rd = n - d  # the reflected index of d in s[n / 2..n)\n      # No difference is allowed outside the query ranges.\n      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or\n         (n // 2 > max(b, rc) and\n          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or\n         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or\n         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):\n        ans.append(False)\n      else:\n        # The `count` map of the intersection of [a, b) and [rd, rc) in\n        # s[0..n / 2) must equate to the `count` map of the intersection of\n        # [c, d) and [rb, ra) in s[n / 2..n).\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> list[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> list[list[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts",
      "title": "2983. Palindrome Rearrangement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cb3f75a-1c47-41b1-8e64-233aafe68f0b",
      "code": "class Solution:\n  def selfDivisiblePermutationCount(self, n: int) -> int:\n    def dfs(num: int, used: int) -> int:\n      if num > n:\n        return 1\n\n      count = 0\n      for i in range(1, n + 1):\n        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):\n          count += dfs(num + 1, used | 1 << i)\n\n      return count\n\n    return dfs(1, 0)",
      "title": "2992. Number of Self-Divisible Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d54b7a6d-0d3c-4bf8-9d8c-6f5cffbfc5d1",
      "code": "class Solution:\n  def missingInteger(self, nums: list[int]) -> int:\n    numsSet = set(nums)\n    ans = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1] + 1:\n        break\n      ans += nums[i]\n\n    while ans in numsSet:\n      ans += 1\n\n    return ans",
      "title": "2996. Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8ca6a0e-0bda-4ccf-ac33-40f8fcf09dc6",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return functools.reduce(operator.xor, nums, k).bit_count()",
      "title": "2997. Minimum Number of Operations to Make Array XOR Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8ab80a8-f856-4c3a-bbd5-47f3e082cb91",
      "code": "class Solution:\n  def minimumOperationsToMakeEqual(self, x, y):\n    if x <= y:\n      return y - x\n\n    queue = collections.deque([x])\n    seen = set()\n\n    ans = 0\n    while queue:\n      for _ in range(len(queue)):\n        num = queue.popleft()\n        if num == y:\n          return ans\n        if num in seen:\n          continue\n        seen.add(num)\n        if num % 11 == 0:\n          queue.append(num // 11)\n        if num % 5 == 0:\n          queue.append(num // 5)\n        queue.append(num - 1)\n        queue.append(num + 1)\n      ans += 1",
      "title": "2998. Minimum Number of Operations to Make X and Y Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b40322b1-2ff7-4534-92ae-aa7dfc2f9c27",
      "code": "class Solution:\n  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:\n    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))\n    return a * b",
      "title": "3000. Maximum Area of Longest Diagonal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca2fed16-0b0c-4643-87e8-ae4fdb95e4b7",
      "code": "class Solution:\n  def minMovesToCaptureTheQueen(\n      self, a: int, b: int, c: int, d: int, e: int, f: int,\n  ) -> int:\n    # The rook is in the same row as the queen.\n    if a == e:\n      # The bishop blocks the rook or not.\n      return 2 if c == a and (b < d < f or b > d > f) else 1\n    # The rook is in the same column as the queen.\n    if b == f:\n      # The bishop blocks the rook or not.\n      return 2 if d == f and (a < c < e or a > c > e) else 1\n    # The bishop is in the same up-diagonal as the queen.\n    if c + d == e + f:\n      # The rook blocks the bishop or not.\n      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1\n    # The bishop is in the same down-diagonal as the queen.\n    if c - d == e - f:\n      # The rook blocks the bishop or not.\n      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1\n    # The rook can always get the green in two steps.\n    return 2",
      "title": "3001. Minimum Moves to Capture The Queen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f5a2c9e-94f2-44a9-a32d-71f09400e8a5",
      "code": "class Solution:\n  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = set1.intersection(set2)\n\n    n = len(nums1)\n    n1 = len(set1)\n    n2 = len(set2)\n    nc = len(common)\n    maxUniqueNums1 = min(n1 - nc, n // 2)\n    maxUniqueNums2 = min(n2 - nc, n // 2)\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)",
      "title": "3002. Maximum Size of a Set After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3b6b074-25ee-408f-b6a1-0a9350e2c299",
      "code": "class Solution:\n  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, canChange: bool, mask: int) -> int:\n      \"\"\"\n      Returns the maximum number of partitions of s[i..n), where `canChange` is\n      True if we can still change a letter, and `mask` is the bitmask of the\n      letters we've seen.\n      \"\"\"\n      if i == len(s):\n        return 0\n\n      def getRes(newBit: int, nextCanChange: bool) -> int:\n        newMask = mask | newBit\n        if newMask.bit_count() > k:\n          return 1 + dp(i + 1, nextCanChange, newBit)\n        return dp(i + 1, nextCanChange, newMask)\n\n      # Initialize the result based on the current letter.\n      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)\n\n      # If allowed, explore the option to change the current letter.\n      if canChange:\n        for j in range(26):\n          res = max(res, getRes(1 << j, False))\n      return res\n\n    return dp(0, True, 0) + 1",
      "title": "3003. Maximize the Number of Partitions After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de0f6f79-1ff5-40b3-a18c-fdee9d517eb6",
      "code": "class Solution:\n  def maximumSubtreeSize(\n      self,\n      edges: list[list[int]],\n      colors: list[int],\n  ) -> int:\n    ans = 1\n    tree = [[] for _ in range(len(colors))]\n\n    for u, v in edges:\n      tree[u].append(v)\n\n    def dfs(u: int) -> int:\n      \"\"\"\n      Returns the size of subtree of u if every node in the subtree has the same\n      color. Otherwise, returns -1.\n      \"\"\"\n      nonlocal ans\n      res = 1\n      for v in tree[u]:\n        if colors[v] != colors[u]:\n          res = -1\n        # If any node in the subtree of v has a different color, the result of\n        # the subtree of u will be -1 as well.\n        subtreeSize = dfs(v)\n        if subtreeSize == -1:\n          res = -1\n        elif res != -1:\n          res += subtreeSize\n      ans = max(ans, res)\n      return res\n\n    dfs(0)\n    return ans",
      "title": "3004. Maximum Subtree of the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "657b7166-fb49-4d6c-83cf-3968d29826a6",
      "code": "class Solution:\n  def maxFrequencyElements(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n    return sum(freq == maxFreq for freq in count.values()) * maxFreq",
      "title": "3005. Count Elements With Maximum Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21ca7759-dd06-4b50-9561-17e5a5819a6c",
      "code": "class Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3006. Find Beautiful Indices in the Given Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e187b97-d815-4dbd-bab0-4daa3babaf87",
      "code": "class Solution:\n  def findMaximumNumber(self, k: int, x: int) -> int:\n    def getSumPrices(num: int) -> int:\n      \"\"\"Returns the sum of prices of all numbers from 1 to `num`.\"\"\"\n      sumPrices = 0\n      # Increment `num` to account the 0-th row in the count of groups.\n      num += 1\n      for i in range(num.bit_length(), 0, -1):\n        if i % x == 0:\n          groupSize = 1 << i\n          halfGroupSize = 1 << i - 1\n          sumPrices += num // groupSize * halfGroupSize\n          sumPrices += max(0, (num % groupSize) - halfGroupSize)\n      return sumPrices\n\n    l = 1\n    r = 10**15\n    return bisect.bisect_right(range(l, r + 1), k, key=getSumPrices) - 1 + l",
      "title": "3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0102d1e9-4cc3-4aa3-8c6a-e520d0a91841",
      "code": "class Solution:\n  # Same as 3006. Find Beautiful Indices in the Given Array I\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = []\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3008. Find Beautiful Indices in the Given Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43ad1d23-979c-4465-aa31-54bc8396713f",
      "code": "class Solution:\n  def maxIntersectionCount(self, y: list[int]) -> int:\n    ans = 0\n    intersectionCount = 0\n    line = collections.Counter()\n\n    for i, (a, b) in enumerate(itertools.pairwise(y)):\n      start = 2 * a\n      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)\n      line[min(start, end)] += 1\n      line[max(start, end) + 1] -= 1\n\n    for count in sorted(line):\n      intersectionCount += line[count]\n      ans = max(ans, intersectionCount)\n\n    return ans",
      "title": "3009. Maximum Number of Intersections on the Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "466ef657-4919-4d59-ad95-6263389e8d7e",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    MAX = 50\n    min1 = MAX\n    min2 = MAX\n\n    for i in range(1, len(nums)):\n      if nums[i] < min1:\n        min2 = min1\n        min1 = nums[i]\n      elif nums[i] < min2:\n        min2 = nums[i]\n\n    return nums[0] + min1 + min2",
      "title": "3010. Divide an Array Into Subarrays With Minimum Cost I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be4eb848-aa5f-4016-9482-d5d714d5778c",
      "code": "class Solution:\n  def canSortArray(self, nums: list[int]) -> int:\n    # Divide the array into distinct segments where each segment is comprised\n    # of consecutive elements sharing an equal number of set bits. Ensure that\n    # for each segment, when moving from left to right, the maximum of a\n    # preceding segment is less than the minimum of the following segment.\n    prevSetBits = 0\n    prevMax = -math.inf  # the maximum of the previous segment\n    currMax = -math.inf  # the maximum of the current segment\n    currMin = math.inf   # the minimum of the current segment\n\n    for num in nums:\n      setBits = num.bit_count()\n      if setBits != prevSetBits:  # Start a new segment.\n        if prevMax > currMin:\n          return False\n        prevSetBits = setBits\n        prevMax = currMax\n        currMax = num\n        currMin = num\n      else:  # Continue with the current segment.\n        currMax = max(currMax, num)\n        currMin = min(currMin, num)\n\n    return prevMax <= currMin",
      "title": "3011. Find if Array Can Be Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6b9a2c7-983b-454b-8fb1-ef5b05330a74",
      "code": "class Solution:\n  def minimumArrayLength(self, nums: list[int]) -> int:\n    # Let the minimum number in the array `nums` be x.\n    # * If there exists any element nums[i] where nums[i] % x > 0, a new\n    #   minimum can be generated and all other numbers can be removed.\n    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    #   generated which cannot be removed. Therefore, the result will be\n    #   (frequency of x + 1) / 2.\n    minNum = min(nums)\n    if any(num % minNum > 0 for num in nums):\n      return 1\n    return (nums.count(minNum) + 1) // 2",
      "title": "3012. Minimize Length of Array Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8de7e72-499b-425f-94ec-27828f2152fe",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:\n    # Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    windowSum = sum(nums[i] for i in range(1, dist + 2))\n    selected = SortedList(nums[i] for i in range(1, dist + 2))\n    candidates = SortedList()\n\n    def balance() -> int:\n      \"\"\"\n      Returns the updated `windowSum` by balancing the multiset `selected` to\n      keep the top k - 1 numbers.\n      \"\"\"\n      nonlocal windowSum\n      while len(selected) < k - 1:\n        minCandidate = candidates[0]\n        windowSum += minCandidate\n        selected.add(minCandidate)\n        candidates.remove(minCandidate)\n      while len(selected) > k - 1:\n        maxSelected = selected[-1]\n        windowSum -= maxSelected\n        selected.remove(maxSelected)\n        candidates.add(maxSelected)\n      return windowSum\n\n    windowSum = balance()\n    minWindowSum = windowSum\n\n    for i in range(dist + 2, len(nums)):\n      outOfScope = nums[i - dist - 1]\n      if outOfScope in selected:\n        windowSum -= outOfScope\n        selected.remove(outOfScope)\n      else:\n        candidates.remove(outOfScope)\n      if nums[i] < selected[-1]:  # nums[i] is a better number.\n        windowSum += nums[i]\n        selected.add(nums[i])\n      else:\n        candidates.add(nums[i])\n      windowSum = balance()\n      minWindowSum = min(minWindowSum, windowSum)\n\n    return nums[0] + minWindowSum",
      "title": "3013. Divide an Array Into Subarrays With Minimum Cost II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8409dafd-dbb2-43e7-9fb4-366129d65330",
      "code": "class Solution:\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3014. Minimum Number of Pushes to Type Word I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83e85829-0d29-4de8-acdd-f69af42f50a4",
      "code": "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3015. Count the Number of Houses at a Certain Distance I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2634ace8-73c6-405c-8b3b-8ef864302ca6",
      "code": "class Solution:\n  # Same as 3014. Minimum Number of Pushes to Type Word I\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3016. Minimum Number of Pushes to Type Word II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b442576-be5b-4515-b205-d022ac9f8fc6",
      "code": "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3017. Count the Number of Houses at a Certain Distance II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02d178f6-4ff1-46e0-a806-27064f1bfb5b",
      "code": "class Solution:\n  def maximumProcessableQueries(\n      self,\n      nums: list[int],\n      queries: list[int],\n  ) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    # removed after processing dp[i][j] queries\n    dp = [[0] * n for _ in range(n)]\n\n    for d in range(n - 1, -1, -1):\n      for i in range(n):\n        j = i + d\n        if j >= n:\n          continue\n        if i > 0:\n          # Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] +\n                         (nums[i - 1] >= queries[dp[i - 1][j]]))\n        if j + 1 < n:\n          # Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] +\n                         (nums[j + 1] >= queries[dp[i][j + 1]]))\n        if dp[i][j] == len(queries):\n          return len(queries)\n\n    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])\n               for i in range(n))",
      "title": "3018. Maximum Number of Removal Queries That Can Be Processed I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f61de60-d842-4fb4-a664-43616ee37a37",
      "code": "class Solution:\n  def countKeyChanges(self, s: str) -> int:\n    return sum(a.lower() != b.lower()\n               for a, b in itertools.pairwise(s))",
      "title": "3019. Number of Changing Keys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70cbf549-3957-436e-8c63-b2c47304f884",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    count = collections.Counter(nums)\n    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1\n\n    for num in nums:\n      if num == 1:\n        continue\n      length = 0\n      x = num\n      while x <= maxNum and x in count and count[x] >= 2:\n        length += 2\n        x *= x\n      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      # The goal is to determine if we can insert x^k in the middle of the\n      # pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      # and decrease the length by 1.\n      ans = max(ans, length + (1 if x in count else -1))\n\n    return ans",
      "title": "3020. Find the Maximum Number of Elements in Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f73f58c-b834-4612-a5bf-b4b45658f1cc",
      "code": "class Solution:\n  def flowerGame(self, n: int, m: int) -> int:\n    # Alice wins if x + y is odd, occurring when:\n    #   1. x is even and y is odd, or\n    #   2. y is even and x is odd.\n    xEven = n // 2\n    yEven = m // 2\n    xOdd = (n + 1) // 2\n    yOdd = (m + 1) // 2\n    return xEven * yOdd + yEven * xOdd",
      "title": "3021. Alice and Bob Playing Flower Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3625595a-d7f5-4ed8-b95c-cacc175b8c41",
      "code": "class Solution:\n  def minOrAfterOperations(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111\n\n    for i in range(MAX_BIT, -1, -1):\n      # Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      # currently added bit within k operations. If it's impossible, then we\n      # add the i-th bit to the answer.\n      prefixMask |= 1 << i\n      if self._getMergeOps(nums, prefixMask, ans) > k:\n        ans |= 1 << i\n\n    return ans\n\n  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:\n    \"\"\"\n    Returns the number of merge operations to turn `prefixMask` to the target\n    by ANDing `nums`.\n    \"\"\"\n    mergeOps = 0\n    ands = prefixMask\n    for num in nums:\n      ands &= num\n      if (ands | target) == target:\n        ands = prefixMask\n      else:\n        mergeOps += 1  # Keep merging the next num\n    return mergeOps",
      "title": "3022. Minimize OR of Remaining Elements Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "023ed42b-ea5e-46d9-9139-9c7666618fb1",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int],\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3023. Find Pattern in Infinite Stream I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16397aaf-5c7e-4c29-950a-fc09ba877b4d",
      "code": "class Solution:\n  def triangleType(self, nums: list[int]) -> str:\n    nums.sort()\n    if nums[0] + nums[1] <= nums[2]:\n      return 'none'\n    if nums[0] == nums[1] and nums[1] == nums[2]:\n      return 'equilateral'\n    if nums[0] == nums[1] or nums[1] == nums[2]:\n      return 'isosceles'\n    return 'scalene'",
      "title": "3024. Type of Triangle II Easy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b688a6c-7efc-4008-9010-04bce679a3c3",
      "code": "class Solution:\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3025. Find the Number of Ways to Place People I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d06c33f-1b50-465a-894c-d84602d46aee",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    numToMinPrefix = {}\n\n    for num in nums:\n      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:\n        numToMinPrefix[num] = prefix\n      prefix += num\n      if num + k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num + k])\n      if num - k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num - k])\n\n    return 0 if ans == -math.inf else ans",
      "title": "3026. Maximum Good Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "097d7960-308f-42ed-992c-d9450b2eb139",
      "code": "class Solution:\n  # Same as 3025. Find the Number of Ways to Place People I\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3027. Find the Number of Ways to Place People II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5236ed3a-7ded-48eb-92ff-b4a4c42a5c5c",
      "code": "class Solution:\n  def returnToBoundaryCount(self, nums: list[int]) -> int:\n    return sum(prefix == 0 for prefix in itertools.accumulate(nums))",
      "title": "3028. Ant on the Boundary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06ca2e01-5dbe-4883-a5a7-202b53421c04",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3029. Minimum Time to Revert Word to Initial State I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2842fec7-cd96-49fd-b5f4-ea28d80e25af",
      "code": "class Solution:\n  def resultGrid(\n      self,\n      image: list[list[int]],\n      threshold: int,\n  ) -> list[list[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y]\n                           for x in range(i, i + 3)\n                           for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(\n      self,\n      image: list[list[int]],\n      i: int,\n      j: int,\n      threshold: int,\n  ) -> bool:\n    \"\"\"Returns True if image[i..i + 2][j..j + 2] is a region.\"\"\"\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True",
      "title": "3030. Find the Grid of Region Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7ee6f2b-6b3f-4f78-971d-be4d8a7a7918",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3031. Minimum Time to Revert Word to Initial State II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d87f6507-29f3-4fe2-a8b7-c393bc7a6b37",
      "code": "class Solution:\n  def numberCount(self, a: int, b: int) -> int:\n    return sum(len(set(str(num))) == len(str(num))\n               for num in range(a, b + 1))",
      "title": "3032. Count Numbers With Unique Digits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d0649be-4402-4476-8ed3-6194441a6d2a",
      "code": "class Solution:\n  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = matrix.copy()\n\n    for j in range(n):\n      mx = max(matrix[i][j] for i in range(m))\n      for i in range(m):\n        if matrix[i][j] == -1:\n          ans[i][j] = mx\n\n    return ans",
      "title": "3033. Modify the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a3f19b9-2119-463f-9c00-38a8e299e3a2",
      "code": "class Solution:\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3034. Number of Subarrays That Match a Pattern I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78ed1117-908b-47c9-b510-bb0b95a55d1e",
      "code": "class Solution:\n  def maxPalindromesAfterOperations(self, words: list[str]) -> int:\n    ans = 0\n    count = collections.Counter(''.join(words))\n    pairs = sum(value // 2 for value in count.values())\n\n    for length in sorted(len(word) for word in words):\n      needPairs = length // 2\n      if pairs < needPairs:\n        return ans\n      ans += 1\n      pairs -= needPairs\n\n    return ans",
      "title": "3035. Maximum Palindromes After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5071ca8-0d66-4377-9947-ecf2f4c55c21",
      "code": "class Solution:\n  # Same as 3034. Number of Subarrays That Match a Pattern I\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3036. Number of Subarrays That Match a Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f02d0ec0-62ee-4dbf-a5a8-104d614de2a2",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  # Same as 3023. Find Pattern in Infinite Stream I\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int]\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3037. Find Pattern in Infinite Stream II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "023ace4c-5f25-48bf-9a78-ea3620d830b8",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    ans = 1\n    summ = nums[0] + nums[1]\n\n    for i in range(2, len(nums) - 1, 2):\n      if nums[i] + nums[i + 1] == summ:\n        ans += 1\n      else:\n        break\n\n    return ans",
      "title": "3038. Maximum Number of Operations With the Same Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb0a4b0e-e227-4019-97c6-fc4c9882f42e",
      "code": "class Solution:\n  def lastNonEmptyString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    maxFreq = max(count.values())\n\n    for c in reversed(s):\n      if count[c] == maxFreq:\n        ans.append(c)\n        count[c] -= 1\n\n    return ''.join(reversed(ans))",
      "title": "3039. Apply Operations to Make String Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecb231ce-4551-4296-943a-34750c7e8a7c",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, score: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      nums[i..j], s.t. all operations have the same `score`.\n      \"\"\"\n      if i >= j:\n        return 0\n      deleteFirstTwo = (1 + dp(i + 2, j, score)\n                        if nums[i] + nums[i + 1] == score else 0)\n      deleteLastTwo = (1 + dp(i, j - 2, score)\n                       if nums[j] + nums[j - 1] == score else 0)\n      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)\n                            if nums[i] + nums[j] == score else 0)\n      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)\n\n    n = len(nums)\n    return max(dp(0, n - 1, nums[0] + nums[1]),\n               dp(0, n - 1, nums[-1] + nums[-2]),\n               dp(0, n - 1, nums[0] + nums[-1]))",
      "title": "3040. Maximum Number of Operations With the Same Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e49d72c-18a9-466b-b4c9-22845d2e3dd9",
      "code": "class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 1\n    prev = -math.inf\n    # the length of the longest consecutive elements (seq0) ending in the\n    # previous number\n    dp0 = 1\n    # the length of the longest consecutive elements (seq1) ending in the\n    # previous number + 1\n    dp1 = 1\n\n    for num in sorted(nums):\n      if num == prev:\n        dp1 = dp0 + 1  # Append `num + 1` to seq0.\n      elif num == prev + 1:\n        dp0 += 1  # Append `num` to seq0.\n        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.\n      elif num == prev + 2:\n        dp0 = dp1 + 1  # Append `num` to seq1.\n        dp1 = 1        # Start a new sequence [`num + 1`].\n      else:\n        dp0 = 1  # Start a new sequence [`num`].\n        dp1 = 1  # Start a new sequence [`num + 1`].\n      ans = max(ans, dp0, dp1)\n      prev = num\n\n    return ans",
      "title": "3041. Maximize Consecutive Elements in an Array After Modification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5c1cbbf-3f68-4046-9131-802a24821acd",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3042. Count Prefix and Suffix Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee6b810b-831e-489f-be98-6839268dcdb3",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)",
      "title": "3043. Find the Length of the Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7629038e-aa53-47e0-aaf3-89a6361a32a4",
      "code": "class Solution:\n  def mostFrequentPrime(self, mat: list[list[int]]) -> int:\n    DIRS = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in DIRS:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]",
      "title": "3044. Most Frequent Prime",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "789bbc84-f4a9-47c9-b1fa-271f79b9c0e8",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  # Same as 3045. Count Prefix and Suffix Pairs II\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3045. Count Prefix and Suffix Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d573134a-6afb-42c9-aae3-049e420907ba",
      "code": "class Solution:\n  def isPossibleToSplit(self, nums: list[int]) -> bool:\n    return all(freq <= 2 for freq in collections.Counter(nums).values())",
      "title": "3046. Split the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "218612bf-d80b-4cb3-9605-5cc07e3cd565",
      "code": "class Solution:\n  def largestSquareArea(\n      self,\n      bottomLeft: list[list[int]],\n      topRight: list[list[int]],\n  ) -> int:\n    minSide = 0\n\n    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (\n            itertools.combinations(zip(bottomLeft, topRight), 2)):\n      overlapX = min(ax2, bx2) - max(ax1, bx1)\n      overlapY = min(ay2, by2) - max(ay1, by1)\n      minSide = max(minSide, min(overlapX, overlapY))\n\n    return minSide**2",
      "title": "3047. Find the Largest Area of Square Inside Two Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f52a5c24-93a5-48c0-a34e-ad36e7e9a7ba",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    def canMark(second: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `second`.\n      \"\"\"\n      numMarked = 0\n      decrement = 0\n      indexToLastSecond = {}\n\n      for i in range(second):\n        indexToLastSecond[changeIndices[i] - 1] = i\n\n      for i in range(second):\n        index = changeIndices[i] - 1  # Convert to 0-indexed\n        if i == indexToLastSecond[index]:\n          # Reach the last occurrence of the number.\n          # So, the current second will be used to mark the index.\n          if nums[index] > decrement:\n            # The decrement is less than the number to be marked.\n            return False\n          decrement -= nums[index]\n          numMarked += 1\n        else:\n          decrement += 1\n\n      return numMarked == len(nums)\n\n    l = 1\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1",
      "title": "3048. Earliest Second to Mark Indices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f5436ca-a747-4b9c-b56e-0a8bb5ad9168",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    # {the second: the index of nums can be zeroed at the current second}\n    secondToIndex = self._getSecondToIndex(nums, changeIndices)\n    numsSum = sum(nums)\n\n    def canMark(maxSecond: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `maxSecond`.\n      \"\"\"\n      # Use a min-heap to greedily pop out the minimum number, which yields the\n      # least saving.\n      minHeap = []\n      marks = 0\n\n      for second in range(maxSecond - 1, -1, -1):\n        if second in secondToIndex:\n          # The number mapped by the index is a candidate to be zeroed out.\n          index = secondToIndex[second]\n          heapq.heappush(minHeap, nums[index])\n          if marks == 0:\n            # Running out of marks, so need to pop out the minimum number.\n            # So, the current second will be used to mark an index.\n            heapq.heappop(minHeap)\n            marks += 1\n          else:\n            # There're enough marks.\n            # So, the current second will be used to zero out a number.\n            marks -= 1\n        else:\n          # There's no candidate to be zeroed out.\n          # So, the current second will be used to mark an index.\n          marks += 1\n\n      decrementAndMarkCost = ((numsSum - sum(minHeap)) +\n                              (len(nums) - len(minHeap)))\n      zeroAndMarkCost = len(minHeap) + len(minHeap)\n      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond\n\n    l = 0\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n\n  def _getSecondToIndex(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> dict[int, int]:\n    # {the `index` of nums: the earliest second to zero out nums[index]}\n    indexToFirstSecond = {}\n    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):\n      index = oneIndexedIndex - 1  # Convert to 0-indexed.\n      if nums[index] > 0 and index not in indexToFirstSecond:\n        indexToFirstSecond[index] = zeroIndexedSecond\n    return {second: index for index, second in indexToFirstSecond.items()}",
      "title": "3049. Earliest Second to Mark Indices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e1f8d8e-7359-403e-a47c-f0fe6aff4892",
      "code": "class Solution:\n  def gameResult(self, head: ListNode | None) -> str:\n    even = 0\n    odd = 0\n\n    while head:\n      if head.val > head.next.val:\n        even += 1\n      elif head.val < head.next.val:\n        odd += 1\n      head = head.next.next\n\n    if even > odd:\n      return 'Even'\n    if even < odd:\n      return 'Odd'\n    return 'Tie'",
      "title": "3062. Winner of the Linked List Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ff84303-b6af-40b2-9e58-7d7ec74086ca",
      "code": "class Solution:\n  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:\n    count = collections.Counter()\n    curr = head\n\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    for freq in count.values():\n      tail.next = ListNode(freq)\n      tail = tail.next\n\n    return dummy.next",
      "title": "3063. Linked List Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4762a6b-aa02-444a-91e5-8c021051d2e6",
      "code": "# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return sum(1 << i for i in range(31)\n               if commonSetBits(1 << i) == 1)",
      "title": "3064. Guess the Number Using Bitwise Questions I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56cf54a5-14b6-4c2b-a5fb-b639a66bf337",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(num < k for num in nums)",
      "title": "3065. Minimum Operations to Exceed Threshold Value I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43dac697-0ce2-43b1-9f7c-4de6ed72f095",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    ans = 0\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    while len(minHeap) > 1 and minHeap[0] < k:\n      x = heapq.heappop(minHeap)\n      y = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))\n      ans += 1\n\n    return ans",
      "title": "3066. Minimum Operations to Exceed Threshold Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8806b089-1aa5-42b6-abb5-826822a940bb",
      "code": "class Solution:\n  def countPairsOfConnectableServers(\n      self,\n      edges: list[list[int]],\n      signalSpeed: int,\n  ) -> list[int]:\n    n = len(edges) + 1\n    tree = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      tree[u].append((v, w))\n      tree[v].append((u, w))\n\n    def connectablePairsRootedAt(u: int) -> int:\n      pairs = 0\n      count = 0\n      for v, w in tree[u]:\n        childCount = dfs(v, u, w)\n        pairs += count * childCount\n        count += childCount\n      return pairs\n\n    def dfs(u: int, prev: int, dist: int) -> int:\n      return (int(dist % signalSpeed == 0) +\n              sum(dfs(v, u, dist + w)\n              for v, w in tree[u]\n              if v != prev))\n\n    return [connectablePairsRootedAt(i) for i in range(n)]",
      "title": "3067. Count Pairs of Connectable Servers in a Weighted Tree Network",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8592a26f-f1b7-478d-8c7b-e9111bf27343",
      "code": "class Solution:\n  def maximumValueSum(\n      self,\n      nums: list[int],\n      k: int,\n      edges: list[list[int]],\n  ) -> int:\n    maxSum = sum(max(num, num ^ k) for num in nums)\n    changedCount = sum((num ^ k) > num for num in nums)\n    if changedCount % 2 == 0:\n      return maxSum\n    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)\n    return maxSum - minChangeDiff",
      "title": "3068. Find the Maximum Sum of Node Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39925924-83c6-49f8-8fc2-6531c01c45c7",
      "code": "class Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = [nums[0]]\n    arr2 = [nums[1]]\n\n    for i in range(2, len(nums)):\n      if arr1[-1] > arr2[-1]:\n        arr1.append(nums[i])\n      else:\n        arr2.append(nums[i])\n\n    return arr1 + arr2",
      "title": "3069. Distribute Elements Into Two Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc8100ff-b9d0-49e2-b4ae-d600b78ca0f7",
      "code": "class Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n        if prefix[i + 1][j + 1] <= k:\n          ans += 1\n\n    return ans",
      "title": "3070. Count Submatrices with Top-Left Element and Sum Less Than k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "655c2020-abed-429f-b3fe-b76aaa00a005",
      "code": "class Solution:\n  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    mid = n // 2\n\n    def getOperations(a: int, b: int) -> int:\n      \"\"\"Returns the number of operations to turn Y into a and non-Y into b.\"\"\"\n      operations = 0\n      for i, row in enumerate(grid):\n        for j, num in enumerate(row):\n          # For the 'Y' pattern, before the midpoint, check the diagonal and\n          # anti-diagonal. After the midpoint, check the middle column.\n          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:\n            if num != a:\n              operations += 1\n          elif num != b:\n            operations += 1\n      return operations\n\n    return min(getOperations(0, 1), getOperations(0, 2),\n               getOperations(1, 0), getOperations(1, 2),\n               getOperations(2, 0), getOperations(2, 1))",
      "title": "3071. Minimum Operations to Write the Letter Y on a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c5474b3-e243-46e0-817f-24ca34ff1f40",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: list[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.add(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks",
      "title": "3072. Distribute Elements Into Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82e39fb9-975a-4eff-8952-69a8edb57fd0",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))\n    leftSortedSet = SortedSet([nums[0]])\n\n    for i in range(len(nums) - 2, -1, -1):\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1])\n\n    for j in range(1, len(nums) - 1):\n      i = bisect.bisect_left(leftSortedSet, nums[j])\n      if i > 0 and rightMax[j] > nums[j]:\n        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])\n      leftSortedSet.add(nums[j])\n\n    return ans",
      "title": "3073. Maximum Increasing Triplet Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e57b71a6-ea91-4b4f-ac15-4939b9a083c8",
      "code": "class Solution:\n  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:\n    appleSum = sum(apple)\n    capacitySum = 0\n\n    for i, c in enumerate(sorted(capacity, reverse=True)):\n      capacitySum += c\n      if capacitySum >= appleSum:\n        return i + 1\n\n    return len(capacity)",
      "title": "3074. Apple Redistribution into Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58f48006-af04-4832-a259-68e301b075ab",
      "code": "class Solution:\n  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:\n    ans = 0\n    decremented = 0\n\n    happiness.sort(reverse=True)\n\n    for i in range(k):\n      ans += max(0, happiness[i] - decremented)\n      decremented += 1\n\n    return ans",
      "title": "3075. Maximize Happiness of Selected Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e150a3ea-fa06-4d91-831b-f201e0f530a9",
      "code": "class Solution:\n  def shortestSubstrings(self, arr: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    def getSubstrings(s: str) -> Iterator[str]:\n      for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n          yield s[i:j]\n\n    def add(s: str) -> None:\n      \"\"\"Adds all substrings of s to `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] += 1\n\n    def remove(s: str) -> None:\n      \"\"\"Removes all substrings of s from `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] -= 1\n\n    def getMinSub(s: str) -> str:\n      minSub = ''\n      for sub in getSubstrings(s):\n        if count[sub] > 0:\n          continue\n        if minSub == ('' or\n                      len(sub) < len(minSub) or\n                      len(sub) == len(minSub) and sub < minSub):\n          minSub = sub\n      return minSub\n\n    for s in arr:\n      add(s)\n\n    for s in arr:\n      remove(s)\n      ans.append(getMinSub(s))\n      add(s)\n\n    return ans",
      "title": "3076. Shortest Uncommon Substring in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25b5481d-62d3-4f2b-9b01-e91e91ccf938",
      "code": "class Solution:\n  def maximumStrength(self, nums: list[int], k: int) -> int:\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, fresh: bool) -> int:\n      \"\"\"\n      Returns the maximum strength of nums[i..n) with k operations left, where\n      `fresh` means we're starting a new subarray.\n      \"\"\"\n      if len(nums) - i < k:\n        return -math.inf\n      if k == 0:\n        return 0\n      if i == len(nums):\n        return 0 if k == 0 else -math.inf\n      # If it's not fresh, we can't skip the current number and consider it as a\n      # fresh start, since the case where it's fresh is already covered by\n      # `includeAndFreshStart`.\n      skip = dp(i + 1, k, True) if fresh else -math.inf\n      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k\n      includeAndContinue = dp(i + 1, k, False) + gain\n      includeAndFreshStart = dp(i + 1, k - 1, True) + gain\n      return max(skip, includeAndContinue, includeAndFreshStart)\n\n    return dp(0, k, True)",
      "title": "3077. Maximum Strength of K Disjoint Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78c607aa-170e-4a82-9af0-5f529e58a052",
      "code": "class Solution:\n  def findPattern(\n      self,\n      board: list[list[int]],\n      pattern: list[str],\n  ) -> list[int]:\n    def isMatch(x: int, y: int) -> bool:\n      digitToLetter = {}\n      letterToDigit = {}\n      for i, row in enumerate(pattern):\n        for j, c in enumerate(row):\n          digit = board[i + x][j + y]\n          if c.isdigit():\n            if int(c) != digit:\n              return False\n          else:\n            if digitToLetter.get(digit, c) != c:\n              return False\n            if letterToDigit.get(c, digit) != digit:\n              return False\n            digitToLetter[digit] = c\n            letterToDigit[c] = digit\n      return True\n\n    for x in range(len(board) - len(pattern) + 1):\n      for y in range(len(board[0]) - len(pattern[0]) + 1):\n        if isMatch(x, y):\n          return [x, y]\n\n    return [-1, -1]",
      "title": "3078. Match Alphanumerical Pattern in Matrix I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3080c0a1-bcd9-431c-b5a7-a9b509197e6d",
      "code": "class Solution:\n  def sumOfEncryptedInt(self, nums: list[int]) -> int:\n    def getEncrypted(num: int) -> int:\n      maxDigit = 0\n      base = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        base = base * 10 + 1\n        num //= 10\n      return base * maxDigit\n\n    return sum(getEncrypted(num) for num in nums)",
      "title": "3079. Find the Sum of Encrypted Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f17fd103-9807-403b-8470-4a78f9f331ef",
      "code": "class Solution:\n  def unmarkedSumArray(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    marked = set()\n    summ = sum(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for index, k in queries:\n      if index not in marked:\n        marked.add(index)\n        summ -= nums[index]\n      popped = 0\n      while popped < k and minHeap:\n        num, i = heapq.heappop(minHeap)\n        if i not in marked:\n          marked.add(i)\n          summ -= num\n          popped += 1\n      ans.append(summ)\n\n    return ans",
      "title": "3080. Mark Elements on Array by Performing Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86f97419-781e-4f50-bee6-5816102b7dbe",
      "code": "class Solution:\n  def minimizeStringValue(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    letters = []\n\n    del count['?']\n\n    def getMinFreqLetter(count: dict[str, int]) -> str:\n      minFreqLetter = 'a'\n      for c in string.ascii_lowercase:\n        if count[c] < count[minFreqLetter]:\n          minFreqLetter = c\n      return minFreqLetter\n\n    for c in s:\n      if c == '?':\n        minFreqLetter = getMinFreqLetter(count)\n        letters.append(minFreqLetter)\n        count[minFreqLetter] += 1\n\n    letters.sort()\n    i = 0  # letters' index\n\n    for c in s:\n      if c == '?':\n        ans.append(letters[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3081. Replace Question Marks in String to Minimize Its Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa06c21e-eeb7-45ed-a602-0b40156c1027",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(k + 1):\n        if j < num:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2) % MOD\n        else:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          # 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % MOD\n\n    return dp[n][k]",
      "title": "3082. Find the Sum of the Power of All Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e546837-06aa-4c39-a115-1985365e9d3d",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of subsequences in nums[i..n) that sums to j.\"\"\"\n      if j == 0:\n        # For each of the remaining number, we can either pick it or skip it.\n        return pow(2, len(nums) - i, MOD)\n      if i == len(nums) or j < 0:\n        return 0\n        # 1. Include nums[i] in the subsequence and pick it.\n        # 2. Include nums[i] in the subsequence and skip it.\n        # 3. Exclude nums[i] in the subsequence.\n      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % MOD\n\n    return dp(0, k)",
      "title": "3082. Find the Sum of the Power of All Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2730d5a1-eea2-4251-9573-0de8cd06dfe8",
      "code": "class Solution:\n  def isSubstringPresent(self, s: str) -> bool:\n    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))",
      "title": "3083. Existence of a Substring in a String and Its Reverse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9e20df6-5a67-4727-b69f-aa7734a2ade8",
      "code": "class Solution:\n  def countSubstrings(self, s: str, c: str) -> int:\n    freq = s.count(c)\n    return freq * (freq + 1) // 2",
      "title": "3084. Count Substrings Starting and Ending with Given Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6178133c-f308-4765-8a99-0132b22e1cef",
      "code": "class Solution:\n  def minimumDeletions(self, word: str, k: int) -> int:\n    ans = math.inf\n    count = collections.Counter(word)\n\n    for minFreq in count.values():\n      deletions = 0\n      for freq in count.values():\n        if freq < minFreq:\n          deletions += freq\n        else:\n          deletions += max(0, freq - (minFreq + k))\n      ans = min(ans, deletions)\n\n    return ans",
      "title": "3085. Minimum Deletions to Make String K-Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4497f23e-4eed-4afd-a330-2ec121bb9a9b",
      "code": "class Solution:\n  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:\n    # Dylan has two actions for collecting '1's in a sequence:\n    # Action 1: Put a '1' next to him and pick it up.\n    #           The cost is 2.\n    # Action 2: Swap a '1' towards him and collect it.\n    #           The cost equals the distance to the '1'.\n    #\n    # To minimize the swapping cost, Dylan can use a sliding window strategy,\n    # selecting the optimal position (middle '1' in the window) for efficient\n    # collection. The window's size is crucial:\n\n    # The minimum window size: min(0, k - maxChanges), ensuring the window\n    # isn't too small.\n    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    # preventing overly ambitious swaps.\n    #\n    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    # cheaper to use Action 1.\n\n    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    # a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    # should be replaced with Action 1.\n    NUM_OF_INDICES_WITHIN_ONE_DISTANCE = 3\n    ans = math.inf\n    oneIndices = [i for i, num in enumerate(nums) if num == 1]\n    prefix = list(itertools.accumulate(oneIndices, initial=0))\n\n    minOnesByTwo = max(0, k - maxChanges)\n    maxOnesByTwo = min(\n        k, minOnesByTwo + NUM_OF_INDICES_WITHIN_ONE_DISTANCE, len(oneIndices))\n\n    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):\n      for l in range(len(prefix) - onesByTwo):\n        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].\n        cost1 = (k - onesByTwo) * 2\n        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -\n                 (prefix[(l + r + 1) // 2] - prefix[l]))\n        ans = min(ans, cost1 + cost2)\n\n    return ans",
      "title": "3086. Minimum Moves to Pick K Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8bf4f27-4cc3-420c-a32c-954879a10196",
      "code": "class Solution:\n  def makeAntiPalindrome(self, s: str) -> str:\n    n = len(s)\n    i = n // 2\n    chars = sorted(list(s))\n    if chars[i] != chars[n - 1 - i]:\n      return ''.join(chars)\n\n    j = self._getFirstDiffIndexInSecondHalf(chars)\n    while chars[i] == chars[n - 1 - i]:\n      if j == n:\n        return '-1'\n      chars[i], chars[j] = chars[j], chars[i]\n      i += 1\n      j += 1\n\n    return ''.join(chars)\n\n  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:\n    \"\"\"\n    Returns the first index in chars[n / 2..n) that is different from the first\n    letter of the second half, chars[n / 2].\n    \"\"\"\n    n = len(chars)\n    firstLetter = chars[n // 2]\n    firstDiffIndex = n // 2\n    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:\n      firstDiffIndex += 1\n    return firstDiffIndex",
      "title": "3088. Make String Anti-palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c5055f7-5f66-406e-8181-a03f39af2db7",
      "code": "class Solution:\n  def maximumLengthSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 2:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "3090. Maximum Length Substring With Two Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b78c370-2f07-41ad-9dad-08694878e138",
      "code": "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.ceil(math.sqrt(k))\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y",
      "title": "3091. Apply Operations to Make Sum of Array Greater Than or Equal to k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e689b5b5-18e6-406f-9513-33f37ee71971",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:\n    ans = []\n    numCount = collections.Counter()  # {num: freq}\n    freqCount = SortedDict()  # {num's freq: freq}\n\n    for num, f in zip(nums, freq):\n      if numCount[num] > 0:\n        numFreq = numCount[num]\n        freqCount[numFreq] -= 1\n        if freqCount[numFreq] == 0:\n          del freqCount[numFreq]\n      newFreq = numCount[num] + f\n      if newFreq == 0:\n        del numCount[num]\n      else:\n        numCount[num] = newFreq\n        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1\n      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)\n\n    return ans",
      "title": "3092. Most Frequent IDs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7716d15-dfd1-4ad8-8e4d-c0ff93423ea3",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n    self.length = math.inf\n    self.index = -1\n\n\nclass Solution:\n  def stringIndices(\n      self,\n      wordsContainer: list[str],\n      wordsQuery: list[str],\n  ) -> list[int]:\n    ans = []\n    root = TrieNode()\n    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]\n\n    def insert(word: str, index: int) -> None:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n        if node.length > len(word):\n          node.length = len(word)\n          node.index = index\n\n    def search(word: str) -> int:\n      node = root\n      for c in reversed(word):\n        if c not in node.children:\n          return node.index\n        node = node.children[c]\n      return node.index\n\n    for i, word in enumerate(wordsContainer):\n      insert(word, i)\n\n    for query in wordsQuery:\n      index = search(query)\n      ans.append(minIndex if index == -1 else index)\n\n    return ans",
      "title": "3093. Longest Common Suffix Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f40ad9c2-13f7-4e88-91f4-919c995e1555",
      "code": "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    ans = 0\n    sameCount = commonBits(0)\n\n    for i in range(31):\n      if commonBits(1 << i) > sameCount:\n        ans |= 1 << i\n      commonBits(1 << i)  # Revert the XOR.\n\n    return ans",
      "title": "3094. Guess the Number Using Bitwise Questions II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbe4828e-c06e-4821-9df2-57fd05fe9d95",
      "code": "class Solution:\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3095. Shortest Subarray With OR at Least K I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd90262b-83d7-42e1-91d7-b349f56b5a39",
      "code": "class Solution:\n  def minimumLevels(self, possible: list[int]) -> int:\n    n = len(possible)\n    nums = [num if num == 1 else -1 for num in possible]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n):\n      if prefix[i] > prefix[n] - prefix[i]:\n        return i\n\n    return -1",
      "title": "3096. Minimum Levels to Gain More Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f7dd64a-b4b3-4b32-a97c-1e13df8b8ffd",
      "code": "class Solution:\n  # Same as 3095. Shortest Subarray With OR at Least K I\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3097. Shortest Subarray With OR at Least K II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4db9beba-8739-4279-9cf6-0734d7f6f6f7",
      "code": "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        k: int,\n        lastPickedIndex: int,\n        firstIndex: int,\n        secondIndex: int\n    ) -> int:\n      if k == 0:\n        return nums[secondIndex] - nums[firstIndex]\n      if i == len(nums):\n        return 0\n      newFirstIndex = firstIndex\n      newSecondIndex = secondIndex\n      if firstIndex == -1:\n        newFirstIndex = i\n      elif secondIndex == -1:\n        newSecondIndex = i\n      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:\n        newFirstIndex = lastPickedIndex\n        newSecondIndex = i\n      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)\n      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, -1, -1)",
      "title": "3098. Find the Sum of Subsequence Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ccf4ec5-6e69-4499-8732-68acb39d1226",
      "code": "class Solution:\n  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n    digitSum = self._getDigitSum(x)\n    return digitSum if x % digitSum == 0 else -1\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3099. Harshad Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ea1e835-a79c-4d47-8c69-9db8358ea0c7",
      "code": "class Solution:\n  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n    ans = numBottles\n\n    while numBottles >= numExchange:\n      numBottles = numBottles - numExchange + 1\n      numExchange += 1\n      ans += 1\n\n    return ans",
      "title": "3100. Water Bottles II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0d64a70-1ac8-436f-b2fa-30a97d11bf2b",
      "code": "class Solution:\n  def countAlternatingSubarrays(self, nums: list[int]) -> int:\n    # dp[i] := the number of alternating subarrays ending in index i\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1]:\n        dp[i] += dp[i - 1]\n\n    return sum(dp)",
      "title": "3101. Count Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7d79bba-ce34-4645-bad0-6613066024c1",
      "code": "class Solution:\n  def minimumDistance(self, points: list[list[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi),\n               self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(\n      self,\n      points: list[list[int]],\n      excludedIndex: int,\n  ) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff\n            else [minDiffIndex, maxDiffIndex])\n\n  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])",
      "title": "3102. Minimize Manhattan Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9d5b537-c0be-4d50-9a14-824cbdfcfbd3",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str) -> int:\n    allCount = collections.Counter(s)\n\n    # Similar to 395. Longest Substring with At Least K Repeating Characters\n    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:\n      res = -1\n      # the number of unique letters\n      uniqueLetters = 0\n      # the number of letters that have all their frequency in the substring\n      lettersHavingAllFreq = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == allCount[c]:\n          lettersHavingAllFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == allCount[s[l]]:\n            lettersHavingAllFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having all their frequency are equal to n, this is a valid window.\n        # Implcit: uniqueLetters == n\n        if lettersHavingAllFreq == n and r - l + 1 < len(s):\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(maxSubstringLengthWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "3104. Find Longest Self-Contained Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7dfb670f-fe22-4ffa-8c11-b7116be3afbd",
      "code": "class Solution:\n  # Similar to 978. Longest Turbulent Subarray\n  def longestMonotonicSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        increasing += 1\n        decreasing = 1\n      elif nums[i] < nums[i - 1]:\n        decreasing += 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, increasing, decreasing)\n\n    return ans",
      "title": "3105. Longest Strictly Increasing or Strictly Decreasing Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f400f919-dd42-45f0-b251-3a57ec50cce2",
      "code": "class Solution:\n  def getSmallestString(self, s: str, k: int) -> str:\n    ans = list(s)\n\n    for i, c in enumerate(s):\n      if k == 0:\n        break\n      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n      if k >= distToA:\n        k -= distToA\n        ans[i] = 'a'\n      else:\n        # k is not enough to change the current letter to 'a', so move as closer\n        # to 'a' as possible.\n        ans[i] = chr(ord(c) - k)\n        k = 0\n\n    return ''.join(ans)",
      "title": "3106. Lexicographically Smallest String After Operations With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d1ec909-7b25-4d71-a96d-67693e3293e1",
      "code": "class Solution:\n  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    for i in range(n // 2 + 1):\n      ans += max(0, nums[i] - k)\n\n    for i in range(n // 2, n):\n      ans += max(0, k - nums[i])\n\n    return ans",
      "title": "3107. Minimum Operations to Make Median of Array Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c03352a-0a95-4957-a828-c190447015b0",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    return self.weight[i] if i == j else -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]",
      "title": "3108. Minimum Cost Walk in Weighted Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc099ae-f07b-4c73-af9b-1635b9a1bfb8",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getPermutationIndex(self, perm: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(perm)\n    ans = 0\n    tree = FenwickTree(n)\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = (fact[i - 1] * i) % MOD\n\n    for i, num in enumerate(perm):\n      # the number of unused numbers less than `num`\n      unusedNums = num - 1 - tree.get(num - 1)\n      suffixLength = fact[n - 1 - i]\n      ans += unusedNums * suffixLength\n      ans %= MOD\n      tree.add(num, 1)\n\n    return ans",
      "title": "3109. Find the Index of Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "834b63b5-1523-4d56-9a44-c669e51da582",
      "code": "class Solution:\n  def scoreOfString(self, s: str) -> int:\n    return sum(abs(ord(a) - ord(b))\n               for a, b in itertools.pairwise(s))",
      "title": "3110. Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "357aebd4-4e9f-425c-bd02-a9559e4c81bb",
      "code": "class Solution:\n  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:\n    ans = 0\n    prevX = -w - 1\n    xs = sorted([x for x, _ in points])\n\n    for x in xs:\n      if x > prevX + w:\n        ans += 1\n        prevX = x\n\n    return ans",
      "title": "3111. Minimum Rectangles to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cbb1697-6d94-4709-9215-b21db1aea500",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      edges: list[list[int]],\n      disappear: list[int],\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      disappear: list[int],\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return [d if d != math.inf else -1\n            for d in dist]",
      "title": "3112. Minimum Time to Visit Disappearing Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05a39097-52c8-45d7-9b61-b980a11956d2",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1][0] < num:\n        stack.pop()\n      if not stack or stack[-1][0] != num:\n        stack.append([num, 0])\n      stack[-1][1] += 1\n      ans += stack[-1][1]\n\n    return ans",
      "title": "3113. Find the Number of Subarrays Where Boundary Elements Are Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c2c359c-d649-4397-9cbf-b334eb4803f1",
      "code": "class Solution:\n  # Similar to 1736. Latest Time by Replacing Hidden Digits\n  def findLatestTime(self, s: str) -> str:\n    ans = list(s)\n    if s[0] == '?':\n      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'\n    if s[1] == '?':\n      ans[1] = '1' if ans[0] == '1' else '9'\n    if s[3] == '?':\n      ans[3] = '5'\n    if s[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "3114. Latest Time You Can Obtain After Replacing Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46146b20-1eac-48a7-bb34-397fa21b9dc9",
      "code": "class Solution:\n  def maximumPrimeDifference(self, nums: list[int]) -> int:\n    MAX = 100\n    isPrime = self._sieveEratosthenes(MAX + 1)\n    minPrimeIndex = -1\n    maxPrimeIndex = -1\n\n    for i, num in enumerate(nums):\n      if isPrime[num]:\n        if minPrimeIndex == -1:\n          minPrimeIndex = i\n        maxPrimeIndex = i\n\n    return maxPrimeIndex - minPrimeIndex\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3115. Maximum Prime Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c9308a3-8464-4598-b3b2-20f20bf72e2a",
      "code": "class Solution:\n  def findKthSmallest(self, coins: list[int], k: int) -> int:\n    sizeToLcms = self._getSizeToLcms(coins)\n\n    def count(m: int) -> int:\n      \"\"\"Returns the number of denominations <= m.\"\"\"\n      res = 0\n      for sz, lcms in enumerate(sizeToLcms):\n        for lcm in lcms:\n          # Principle of Inclusion-Exclusion (PIE)\n          res += m // lcm * pow(-1, sz + 1)\n      return res\n\n    return bisect.bisect_left(range(k * min(coins)), k, key=count)\n\n  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:\n    # Returns the LCMs for each number of combination of coins.\n    sizeToLcms = [[] for _ in range(len(coins) + 1)]\n    for sz in range(1, len(coins) + 1):\n      for combination in itertools.combinations(coins, sz):\n        sizeToLcms[sz].append(math.lcm(*combination))\n    return sizeToLcms",
      "title": "3116. Kth Smallest Amount With Single Denomination Combination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c8260f0-8aca-435f-8cd6-b8c86d13edf4",
      "code": "class Solution:\n  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:\n    n = len(nums)\n    m = len(andValues)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n      `mask` is the running value of the current subarray.\n      \"\"\"\n      if i == n and j == m:\n        return 0\n      if i == n or j == m:\n        return math.inf\n      mask &= nums[i]\n      if mask < andValues[j]:\n        return math.inf\n      if mask == andValues[j]:\n        # 1. Keep going.\n        # 2. End the subarray here and pick nums[i], then fresh start.\n        return min(dp(i + 1, j, mask),\n                   nums[i] + dp(i + 1, j + 1, -1))\n      return dp(i + 1, j, mask)  # Keep going.\n\n    ans = dp(0, 0, -1)\n    return ans if ans < math.inf else -1",
      "title": "3117. Minimum Sum of Values by Dividing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a494dbd-39fd-4993-a9f7-e252db2bb3a3",
      "code": "class Solution:\n  def maxPotholes(self, road: str, budget: int) -> int:\n    ans = 0\n\n    for length in sorted(map(len, road.split('.')), reverse=True):\n      canRepair = max(0, budget - 1)\n      if length > canRepair:\n        return ans + canRepair\n      ans += length\n      budget -= length + 1\n\n    return ans",
      "title": "3119. Maximum Number of Potholes That Can Be Fixed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a078b51-c818-4f5f-8888-d488a91f6829",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = True\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3120. Count the Number of Special Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4c371ce-1531-4981-88cf-dd05d6dd3df9",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = not upper[c.upper()]\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3121. Count the Number of Special Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f45378b-b48d-480d-b574-e8f34e7295ac",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    count = [[0] * 10 for _ in range(n)]\n\n    for row in grid:\n      for j, num in enumerate(row):\n        count[j][num] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of minimum operations needed to make grid[:][j..n)\n      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n      \"\"\"\n      if i == n:\n        return 0\n\n      res = math.inf\n\n      for num in range(10):\n        if i == 0 or num != prev:\n          res = min(res, m - count[i][num] + dp(i + 1, num))\n\n      return res\n\n    return dp(0, 0)",
      "title": "3122. Minimum Number of Operations to Satisfy Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "273da751-d111-4e37-8d24-c624f429303a",
      "code": "class Solution:\n  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or\n            from0[v] + w + from1[u] == from0[-1]\n            for u, v, w in edges]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "3123. Find Edges in Shortest Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f4fe224-3539-40e0-8c0a-9e4cbc0f0cea",
      "code": "class Solution:\n  def maxNumber(self, n: int) -> int:\n    # assume n = 0b00...11???\n    #        x = 0b00...01111\n    #  since y = 0b00...10000 is in [x, n]\n    #    and x & y = 0\n    return (1 << n.bit_length() - 1) - 1",
      "title": "3125. Maximum Number That Makes Result of Bitwise AND Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e2ab217-d532-4af9-86c6-1ee96a5be614",
      "code": "class Solution:\n  def canMakeSquare(self, grid: list[list[str]]) -> bool:\n    for i in range(2):\n      for j in range(2):\n        black = 0\n        white = 0\n        for x in range(2):\n          for y in range(2):\n            if grid[i + x][j + y] == 'B':\n              black += 1\n            else:\n              white += 1\n        if black >= 3 or white >= 3:\n          return True\n    return False",
      "title": "3127. Make a Square with the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7927fa4-02d8-464a-983d-6eb251a751ab",
      "code": "class Solution:\n  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    return sum((rows[i] - 1) * (cols[j] - 1)\n               for i, row in enumerate(grid)\n               for j, num in enumerate(row)\n               if num == 1)",
      "title": "3128. Right Triangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96142d8b-9939-4111-9069-f10807a2a2b1",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n           for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3129. Find All Possible Stable Binary Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5193c70-2f3e-41f5-9bd6-36e4e0638f61",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n          for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3130. Find All Possible Stable Binary Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f957fd9-ae5a-4cf2-9548-d0efdea0478e",
      "code": "class Solution:\n  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(nums2) - min(nums1)",
      "title": "3131. Find the Integer Added to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47a58bd9-16ba-4474-93e3-3eab864beac1",
      "code": "class Solution:\n  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    # After removing two elements from nums1, either nums1[0], nums1[1], or\n    # nums1[2] will persist. Therefore, the difference between nums1 (with two\n    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    # 0 <= i <= 2.\n    ans = math.inf\n\n    nums1.sort()\n    nums2.sort()\n\n    for i in range(3):\n      inc = nums2[0] - nums1[i]\n      if self._isValidDiff(nums1, nums2, inc):\n        ans = min(ans, inc)\n\n    return ans\n\n  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:\n    \"\"\"\n    Returns True if it's possible to increase nums1 (with two elements removed)\n    by `inc` to nums2.\n    \"\"\"\n    removed = 0\n    i = 0  # nums2's index\n\n    for num in nums1:\n      if num + inc == nums2[i]:\n        i += 1\n        if i == len(nums2):\n          break\n      else:\n        removed += 1\n\n    return removed <= 2",
      "title": "3132. Find the Integer Added to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10b51abb-cd8a-4d07-9bfb-4efd8a7127b6",
      "code": "class Solution:\n  def minEnd(self, n: int, x: int) -> int:\n    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    # operation increase x for (n - 1) iterations while preserving x's 1s.\n    MAX_BIT = n.bit_length() + x.bit_length()\n    k = n - 1\n    BINARY_INDEX = 0\n\n    for i in range(MAX_BIT):\n      if x >> i & 1 == 0:\n        # Set x's 0 with k's bit if the running bit of k is 1.\n        if k >> BINARY_INDEX & 1:\n          x |= 1 << i\n        BINARY_INDEX += 1\n\n    return x",
      "title": "3133. Minimum Array End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22873037-198c-436e-81ba-46dee3632d90",
      "code": "class Solution:\n  def medianOfUniquenessArray(self, nums: list[int]):\n    n = len(nums)\n    subarrayCount = n * (n + 1) // 2\n    medianCount = (subarrayCount + 1) // 2\n\n    # Similar to 992. Subarrays with K Different Integers\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    l = 1\n    r = n\n    return bisect.bisect_left(range(l, r), medianCount,\n                              key=subarraysWithAtMostKDistinct) + l",
      "title": "3134. Find the Median of the Uniqueness Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2baf864-cb9d-4364-88f0-d2d65f1f2039",
      "code": "class Solution:\n  def minOperations(self, initial: str, target: str) -> int:\n    m = len(initial)\n    n = len(target)\n    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if initial[i - 1] == target[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n\n    return m + n - 2 * max(map(max, dp))",
      "title": "3135. Equalize Strings by Adding or Removing Characters at Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afbd5c25-edf0-4914-b2ba-873722d1c96b",
      "code": "class Solution:\n  def isValid(self, word: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n\n    def isConsonant(c: str) -> bool:\n      return c.isalpha() and c not in VOWELS\n\n    return (len(word) >= 3 and\n            all(c.isalnum() for c in word) and\n            any(c in VOWELS for c in word) and\n            any(isConsonant(c) for c in word))",
      "title": "3136. Valid Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b83470da-5f80-421d-9ab1-4ee32cbd621d",
      "code": "class Solution:\n  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))\n    return len(word) // k - max(count.values())",
      "title": "3137. Minimum Number of Operations to Make Word K-Periodic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8af8bbe-5a1a-4bc5-b9da-1f16dcfb4573",
      "code": "class Solution:\n  def minAnagramLength(self, s: str) -> int:\n    n = len(s)\n    for k in range(1, n + 1):\n      if n % k == 0 and self._canFormAnagram(s, k):\n        return k\n    return n\n\n  def _canFormAnagram(self, s: str, k: int) -> bool:\n    \"\"\"Returns True if we can concatenate an anagram of length k to s.\"\"\"\n    anagramCount = collections.Counter(s[:k])\n    return all(collections.Counter(s[i:i + k]) == anagramCount\n               for i in range(k, len(s), k))",
      "title": "3138. Minimum Length of Anagram Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d700629d-23a7-4720-88e8-ad30deb11d0a",
      "code": "class Solution:\n  def minCostToEqualizeArray(\n      self,\n      nums: list[int],\n      cost1: int,\n      cost2: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    minNum = min(nums)\n    maxNum = max(nums)\n    summ = sum(nums)\n\n    if cost1 * 2 <= cost2 or n < 3:\n      totalGap = maxNum * n - summ\n      return (cost1 * totalGap) % MOD\n\n    def getMinCost(target: int) -> int:\n      \"\"\"Returns the minimum cost to make all numbers equal to `target`.\"\"\"\n      maxGap = target - minNum\n      totalGap = target * n - summ\n      # Pair one shallowest number with one non-shallowest number, so the worst\n      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.\n      pairs = min(totalGap // 2, totalGap - maxGap)\n      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs\n\n    return min(getMinCost(target)\n               for target in range(maxNum, 2 * maxNum)) % MOD",
      "title": "3139. Minimum Cost to Equalize Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44c22b44-865f-47e4-aaa9-b6903da2e839",
      "code": "class Solution:\n  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:\n    MAX_MASK = 1 << m\n    # dp[i] := the maximum hamming distance from i to any number in `nums`\n    dp = [-math.inf] * MAX_MASK\n\n    for num in nums:\n      dp[num] = 0\n\n    for bit in range(m):\n      newDp = [0] * MAX_MASK\n      for mask in range(MAX_MASK):\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)\n      dp = newDp\n\n    return [dp[num] for num in nums]",
      "title": "3141. Maximum Hamming Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ece4f11-f36d-4c72-bf07-89178902b17e",
      "code": "class Solution:\n  def satisfiesConditions(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    return (all(grid[i][j] == grid[i + 1][j]\n                for i in range(m - 1)\n                for j in range(n)) and\n            all(grid[i][j] != grid[i][j + 1]\n                for i in range(m)\n                for j in range(n - 1)))",
      "title": "3142. Check if Grid Satisfies Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7eb4cf57-d620-48be-aa32-510ba9e1c537",
      "code": "class Solution:\n  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:\n    secondMinSize = math.inf\n    minSizes = {}\n\n    for (x, y), c in zip(points, s):\n      sz = max(abs(x), abs(y))\n      if c not in minSizes:\n        minSizes[c] = sz\n      elif sz < minSizes[c]:\n        # This is because minSizes[j] is about to be replaced by a smaller\n        # value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[c])\n        minSizes[c] = sz\n      else:\n        # `sz` is not smaller than the current minimum size, but it could be\n        # smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz)\n\n    return sum(sz < secondMinSize for sz in minSizes.values())",
      "title": "3143. Maximum Points Inside the Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c694d08-12bd-43be-b346-5d412c6ce7db",
      "code": "class Solution:\n  def minimumSubstringsInPartition(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of substrings in s[0..i]\n    dp = [n] * n\n\n    for i in range(n):\n      count = collections.Counter()\n      for j in range(i, -1, -1):\n        count[s[j]] += 1\n        # word[j..i] is balanced.\n        if min(count.values()) == max(count.values()):\n          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)\n\n    return dp[-1]",
      "title": "3144. Minimum Substring Partition of Equal Character Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24ee9605-35a5-48e1-b5c5-504d7e87fa11",
      "code": "class Solution:\n  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:\n    def sumBitsTill(x: int) -> int:\n      \"\"\"Returns sum(i.bit_count()), where 1 <= i <= x.\"\"\"\n      sumBits = 0\n      powerOfTwo = 1\n      while powerOfTwo <= x:\n        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo\n        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)\n        powerOfTwo *= 2\n      return sumBits\n\n    def sumPowersTill(x: int) -> int:\n      \"\"\"Returns sum(all powers of i), where 1 <= i <= x.\"\"\"\n      sumPowers = 0\n      powerOfTwo = 1\n      for power in range(x.bit_length()):\n        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power\n        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power\n        powerOfTwo *= 2\n      return sumPowers\n\n    def sumPowersFirstKBigNums(k: int) -> int:\n      \"\"\"Returns the sum of powers of the first k numbers in `big_nums`.\"\"\"\n      # Find the first number in [1, k] that has sumBitsTill(num) >= k.\n      num = bisect.bisect_left(range(k), k, key=sumBitsTill)\n      sumPowers = sumPowersTill(num - 1)\n      remainingCount = k - sumBitsTill(num - 1)\n      for power in range(num.bit_length()):\n        if num >> power & 1:\n          sumPowers += power\n          remainingCount -= 1\n          if remainingCount == 0:\n            break\n      return sumPowers\n\n    return [pow(2,\n                sumPowersFirstKBigNums(b + 1) -\n                sumPowersFirstKBigNums(a), mod)\n            for a, b, mod in queries]",
      "title": "3145. Find Products of Elements of Big Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4aac72f-b8e6-4200-89ed-5b3133b2002d",
      "code": "class Solution:\n  def findPermutationDifference(self, s: str, t: str) -> int:\n    indices = {c: i for i, c in enumerate(s)}\n    return sum([abs(indices[c] - i) for i, c in enumerate(t)])",
      "title": "3146. Permutation Difference between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "378628a9-2122-40ac-a6b1-05643eb16dfc",
      "code": "class Solution:\n  def maximumEnergy(self, energy: list[int], k: int) -> int:\n    # dp[i] := the sum of energy starting at i\n    dp = energy.copy()\n    for i in range(len(energy) - 1 - k, -1, -1):\n      dp[i] += dp[i + k]\n    return max(dp)",
      "title": "3147. Taking Maximum Energy From the Mystic Dungeon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c3b7bfd-f670-4422-832a-9b4509d3510c",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    MAX = 200000\n    ans = -MAX\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        prevMin = min(grid[i - 1][j] if i > 0 else MAX,\n                      grid[i][j - 1] if j > 0 else MAX)\n        ans = max(ans, num - prevMin)\n        grid[i][j] = min(num, prevMin)\n\n    return ans",
      "title": "3148. Maximum Difference Score in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c6baa9b-9d2b-4f17-89e1-5b8012ec65ab",
      "code": "class Solution:\n  def findPermutation(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    bestPick = [[0] * (1 << n) for _ in range(n)]\n\n    @functools.lru_cache(None)\n    def getScore(last: int, mask: int) -> int:\n      if mask.bit_count() == len(nums):\n        return abs(last - nums[0])\n\n      minScore = math.inf\n      for i in range(1, len(nums)):\n        if mask >> i & 1:\n          continue\n        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))\n        if nextMinScore < minScore:\n          minScore = nextMinScore\n          bestPick[last][mask] = i\n\n      return minScore\n\n    getScore(0, 1)\n    return self._construct(bestPick)\n\n  def _construct(self, bestPick: list[list[int]]) -> list[int]:\n    ans = []\n    last = 0\n    mask = 1\n    for _ in range(len(bestPick)):\n      ans.append(last)\n      last = bestPick[last][mask]\n      mask |= 1 << last\n    return ans",
      "title": "3149. Find the Minimum Cost Array Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6df05c10-629e-442c-902f-d48f1056b2ed",
      "code": "class Solution:\n  def isArraySpecial(self, nums: list[int]) -> bool:\n    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))",
      "title": "3151. Special Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e621ee49-66ad-4ac9-8037-ef5679af00bf",
      "code": "class Solution:\n  def isArraySpecial(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    id = 0\n    # parityIds[i] := the id of the parity group that nums[i] belongs to\n    parityIds = [id]\n\n    for a, b in itertools.pairwise(nums):\n      if a % 2 == b % 2:\n        id += 1\n      parityIds.append(id)\n\n    for _from, to in queries:\n      ans.append(parityIds[_from] == parityIds[to])\n\n    return ans",
      "title": "3152. Special Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9187e6b6-ccba-4adb-a614-dca56cc1c2d4",
      "code": "class Solution:\n  def sumDigitDifferences(self, nums: list[int]) -> int:\n    n = len(nums)\n    digitSize = len(str(nums[0]))\n    ans = 0\n\n    denominator = 1\n    for _ in range(digitSize):\n      count = [0] * 10\n      for num in nums:\n        count[num // denominator % 10] += 1\n      ans += sum(freq * (n - freq) for freq in count)\n      denominator *= 10\n\n    return ans // 2",
      "title": "3153. Sum of Digit Differences of All Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a95e6bc-d606-4f2f-8684-07634c26f01c",
      "code": "class Solution:\n  def waysToReachStair(self, k: int) -> int:\n    # Let's say we have `down` operation 1 and `jump` operation 2.\n    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    # => 1 + (2^jump - 1) - down = k.\n    # => down = 2^jump - k.\n    # Since `down` operations cannot be used consecutively, there're jump + 1\n    # positions (before and after each `jump`) for  `down`. The maximum jump is\n    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    # being the maximum value of 10^9.\n    MAX_JUMP = 29\n    ans = 0\n\n    for jump in range(MAX_JUMP + 1):\n      down = (1 << jump) - k\n      if down < 0 or down > jump + 1:\n        continue\n      ans += math.comb(jump + 1, down)\n\n    return ans",
      "title": "3154. Find Number of Ways to Reach the K-th Stair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b990a2b-3dd5-48b8-80be-dbc53c932ecb",
      "code": "class Solution:\n  def maxUpgrades(\n      self,\n      count: list[int],\n      upgrade: list[int],\n      sell: list[int],\n      money: list[int],\n  ) -> list[int]:\n    # If there's enough money, upgrade all servers; otherwise, optimize by\n    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    # Therefore, x = (money + count * sell) / (sell + upgrade).\n    return [min(c, (m + c * s) // (s + u))\n            for c, u, s, m in zip(count, upgrade, sell, money)]",
      "title": "3155. Maximum Number of Upgradable Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a534ac8-ba8a-4504-8b2e-15be579bbd70",
      "code": "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    ans = 0\n    minLevelSum = math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum < minLevelSum:\n        minLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "3157. Find the Level of Tree with Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "190a204e-71a9-4fb5-8c5f-cca37bd95b79",
      "code": "class Solution:\n  def duplicateNumbersXOR(self, nums):\n    count = collections.Counter(nums)\n    return functools.reduce(\n        operator.xor, [num for num, freq in count.items() if freq == 2],\n        0)",
      "title": "3158. Find the XOR of Numbers Which Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2056a2-c366-42cc-a324-16ae85612278",
      "code": "class Solution:\n  def occurrencesOfElement(\n      self,\n      nums: list[int],\n      queries: list[int],\n      x: int,\n  ) -> list[int]:\n    indices = [i for i, num in enumerate(nums) if num == x]\n    return [indices[query - 1] if query <= len(indices) else -1\n            for query in queries]",
      "title": "3159. Find Occurrences of an Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c2a59df-e873-47df-9016-dd46849e64ea",
      "code": "class Solution:\n  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    ballToColor = {}\n    colorCount = collections.Counter()\n\n    for ball, color in queries:\n      if ball in ballToColor:\n        prevColor = ballToColor[ball]\n        colorCount[prevColor] -= 1\n        if colorCount[prevColor] == 0:\n          del colorCount[prevColor]\n      ballToColor[ball] = color\n      colorCount[color] += 1\n      ans.append(len(colorCount))\n\n    return ans",
      "title": "3160. Find the Number of Distinct Colors Among the Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ac2291b-7fed-4d10-bea1-fd083651a9d1",
      "code": "from sortedcontainers import SortedList\n\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowtree(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowtree(i)\n    return res\n\n  @staticmethod\n  def lowtree(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getResults(self, queries: list[list[int]]) -> list[bool]:\n    n = min(50000, len(queries) * 3)\n    ans = []\n    tree = FenwickTree(n + 1)\n    obstacles = SortedList([0, n])  # sentinel values\n\n    for query in queries:\n      type = query[0]\n      if type == 1:\n        x = query[1]\n        obstacles.add(x)\n\n    for x1, x2 in itertools.pairwise(obstacles):\n      tree.maximize(x2, x2 - x1)\n\n    for query in reversed(queries):\n      type = query[0]\n      x = query[1]\n      if type == 1:\n        i = obstacles.index(x)\n        next = obstacles[i + 1]\n        prev = obstacles[i - 1]\n        obstacles.remove(x)\n        tree.maximize(next, next - prev)\n      else:\n        sz = query[2]\n        i = obstacles.bisect_right(x)\n        prev = obstacles[i - 1]\n        ans.append(tree.get(prev) >= sz or x - prev >= sz)\n\n    return ans[::-1]",
      "title": "3161. Block Placement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e16bb6f7-290c-43eb-9776-e955354af3f8",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    return sum(num1 % (num2 * k) == 0\n               for num1 in nums1\n               for num2 in nums2)",
      "title": "3162. Find the Number of Good Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bb24682-2080-4d90-b167-147dfd09a15f",
      "code": "class Solution:\n  def compressedString(self, word: str) -> str:\n    n = len(word)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      count = 0\n      while j < n and word[j] == word[i] and count < 9:\n        j += 1\n        count += 1\n      ans.append(str(count) + word[i])\n      i = j\n\n    return ''.join(ans)",
      "title": "3163. String Compression III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6993c4af-3be3-466b-a984-20cdd0e3aaa6",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    count = collections.Counter(num * k for num in nums2)\n    ans = 0\n\n    for num in nums1:\n      for divisor in range(1, int(num ** 0.5) + 1):\n        if num % divisor == 0:\n          ans += count[divisor]\n          if num // divisor != divisor:\n            ans += count[num // divisor]\n\n    return ans",
      "title": "3164. Find the Number of Good Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4477faf3-e93b-491a-8d03-598a4e22dfe8",
      "code": "class Solution:\n  def betterCompression(self, compressed: str) -> str:\n    count = collections.Counter()\n    i = 0\n\n    while i < len(compressed):\n      c = compressed[i]\n      i += 1\n      freq = 0\n      while i < len(compressed) and compressed[i].isdigit():\n        freq = freq * 10 + int(compressed[i])\n        i += 1\n      count[c] += freq\n\n    return ''.join([c + str(count[c])\n                    for c in sorted(count.keys())])",
      "title": "3167. Better Compression of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7cf758a-ef69-4c27-8303-145c021b4f3c",
      "code": "class Solution:\n  def minimumChairs(self, s: str) -> int:\n    ans = 0\n    chairs = 0\n\n    for c in s:\n      chairs += 1 if c == 'E' else -1\n      ans = max(ans, chairs)\n\n    return ans",
      "title": "3168. Minimum Number of Chairs in a Waiting Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7001f07-9bbe-444e-9b08-87c0f4dc68e0",
      "code": "class Solution:\n  def countDays(self, days: int, meetings: list[list[int]]) -> int:\n    freeDays = 0\n    prevEnd = 0\n\n    for start, end in sorted(meetings):\n      if start > prevEnd:\n        freeDays += start - prevEnd - 1\n      prevEnd = max(prevEnd, end)\n\n    return freeDays + max(0, days - prevEnd)",
      "title": "3169. Count Days Without Meetings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3c63920-f537-4858-b400-0e4070e2de95",
      "code": "class Solution:\n  def clearStars(self, s: str) -> str:\n    ans = list(s)\n    buckets = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      if c == '*':\n        ans[i] = ''\n        j = next(j for j, bucket in enumerate(buckets) if bucket)\n        ans[buckets[j].pop()] = ''\n      else:\n        buckets[ord(c) - ord('a')].append(i)\n\n    return ''.join(ans)",
      "title": "3170. Lexicographically Minimum String After Removing Stars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e451eef1-b858-4244-95b8-25b02f91ed8d",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in nums:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the OR operation, the size of `next_set` will be at most\n      # bin(num).count('1') + 1.\n      dp = {num} | {val | num for val in dp}\n      ans = min(ans, min(abs(k - val) for val in dp))\n\n    return ans",
      "title": "3171. Find Subarray With Bitwise AND Closest to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bea061a-f93e-4a5d-b509-75283962c1d9",
      "code": "class Solution:\n  def orArray(self, nums: list[int]) -> list[int]:\n    return [a | b for a, b in itertools.pairwise(nums)]",
      "title": "3173. Bitwise OR of Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a19293-e27f-4f2d-b5fe-e9d0b9f2707e",
      "code": "class Solution:\n  def clearDigits(self, s: str) -> str:\n    ans = []\n\n    for c in s:\n      if c.isdigit():\n        # Since `ans` only contains non-digit characters, removing the last\n        # character is equivalent to deleting the closest non-digit character.\n        ans.pop()\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3174. Clear Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d29ce9c-c71f-4ab7-b769-91d8649533a9",
      "code": "class Solution:\n  # Similar to 1535. Find the Winner of an Array Game\n  def findWinningPlayer(self, skills: list[int], k: int) -> int:\n    ans = 0\n    wins = 0\n\n    i = 1\n    while i < len(skills) and wins < k:\n      if skills[i] > skills[ans]:\n        ans = i\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "3175. Find The First Player to win K Games in a Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ab632f4-9aa6-49db-9698-916477e7b542",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3176. Find the Maximum Length of a Good Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25f061cb-e397-4672-96ba-f810464a4d15",
      "code": "class Solution:\n  # Same as 3176. Find the Maximum Length of a Good Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3177. Find the Maximum Length of a Good Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96fbbbc9-3111-46f4-aa63-b88501797ea3",
      "code": "class Solution:\n  def numberOfChild(self, n: int, k: int) -> int:\n    # the time for the ball to return to 0\n    roundTime = 2 * (n - 1)\n    pos = k % roundTime\n    return pos if pos < n else roundTime - pos",
      "title": "3178. Find the Child Who Has the Ball After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbb43a22-c044-4862-9981-56e9d8e89ffb",
      "code": "class Solution:\n  def valueAfterKSeconds(self, n: int, k: int) -> int:\n    return math.comb(n + k - 1, n - 1) % 1_000_000_007",
      "title": "3179. Find the N-th Value After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69014539-0a35-4053-a44f-c98585575502",
      "code": "# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n# `rewardValue` is achievable in O(1).\n#\n# Let's use `rewardValues = [1, 3, 4]` as an example.\n#\n# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n# Therefore, we can set the size of the bitset to 8 to represent possible\n# total rewards from 0 to 7.\n#\n# Let's define a bitset `dp` to record whether each total reward is\n# achievable. dp[num] = true if reward `num` is achievable.\n#\n# Initially, dp = 0b00000001 := reward 0 is achievable.\n#\n# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n#   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n#\n# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n#\n# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n#\n# Therefore, the maximum total reward is 7.\n\nclass Solution:\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3180. Maximum Total Reward Using Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef8e45d7-8e03-4804-9ca3-370fad15881d",
      "code": "class Solution:\n  # Same as 3180. Maximum Total Reward Using Operations I\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3181. Maximum Total Reward Using Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dbebcae-3cd6-4a9e-90e8-b2bf970851c6",
      "code": "class Solution:\n  def numberOfWays(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    dp = [1] + [0] * n\n\n    for coin in (1, 2, 6):\n      for i in range(coin, n + 1):\n        dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    ans = dp[n]\n    if n - 4 >= 0:\n      ans = (ans + dp[n - 4]) % MOD\n    if n - 8 >= 0:\n      ans = (ans + dp[n - 8]) % MOD\n    return ans",
      "title": "3183. The Number of Ways to Make the Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6635b327-c22d-49ca-982f-395f36306458",
      "code": "class Solution:\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3184. Count Pairs That Form a Complete Day I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6230a3d1-e1af-4cd9-9cd7-02d889a2a2c9",
      "code": "class Solution:\n  # Same as 3184. Count Pairs That Form a Complete Day I\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3185. Count Pairs That Form a Complete Day II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f8cb871-52be-4b05-ae79-4175c7feb08a",
      "code": "class Solution:\n  def maximumTotalDamage(self, power: list[int]) -> int:\n    count = collections.Counter(power)\n    uniqueDamages = sorted(count.keys())\n    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    # indicates if the i-th damage is used\n    dp = [[0] * 2 for _ in range(len(uniqueDamages))]\n\n    for i, damage in enumerate(uniqueDamages):\n      if i == 0:\n        dp[0] = [0, damage * count[damage]]\n        continue\n      dp[i][0] = max(dp[i - 1])\n      dp[i][1] = damage * count[damage]\n      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):\n        dp[i][1] += max(dp[i - 1])\n      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:\n        dp[i][1] += max(dp[i - 2])\n      elif i >= 3:\n        dp[i][1] += max(dp[i - 3])\n\n    return max(dp[-1])",
      "title": "3186. Maximum Total Damage With Spell Casting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9ffc489-4a28-468a-b644-38596701e682",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countOfPeaks(\n      self,\n      nums: list[int],\n      queries:\n      list[list[int]],\n  ) -> list[int]:\n    ans = []\n    peak = [0] + [int(a < b > c)\n                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]\n    tree = FenwickTree(len(peak))\n\n    for i, p in enumerate(peak):\n      tree.add(i + 1, p)\n\n    def update(i: int) -> None:\n      \"\"\"\n      Update the peak array and Fenwick tree if the peak status of nums[i]\n      changes.\n      \"\"\"\n      newPeak = self._isPeak(nums, i)\n      if newPeak != peak[i]:\n        tree.add(i + 1, newPeak - peak[i])\n        peak[i] = newPeak\n\n    for query in queries:\n      if query[0] == 1:\n        l = query[1]\n        r = query[2]\n        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))\n      elif query[0] == 2:\n        index = query[1]\n        val = query[2]\n        nums[index] = val\n        update(index)\n        if index > 0:\n          update(index - 1)\n        if index + 1 < len(nums):\n          update(index + 1)\n\n    return ans\n\n  def _isPeak(self, nums: list[int], i: int) -> bool:\n    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]",
      "title": "3187. Peaks in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f38a09e7-e3bf-47f5-bc18-732f07506c81",
      "code": "class Solution:\n  def minMoves(self, rooks: list[list[int]]) -> int:\n    n = len(rooks)\n    sortedByRow = sorted(rooks, key=lambda x: x[0])\n    sortedByCol = sorted(rooks, key=lambda x: x[1])\n    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +\n            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))",
      "title": "3189. Minimum Moves to Get a Peaceful Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d09c6327-09bc-4644-9602-27f0ab514373",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return sum(num % 3 != 0 for num in nums)",
      "title": "3190. Find Minimum Operations to Make All Elements Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6023cdae-d49d-4f55-a3c2-e22c91e00830",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2):\n      if nums[i] == 0:\n        nums[i + 1] ^= 1\n        nums[i + 2] ^= 1\n        ans += 1\n\n    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans",
      "title": "3191. Minimum Operations to Make Binary Array Elements Equal to One I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aadeb838-1c19-4336-8aaf-323bceb95557",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    target = 1\n\n    for num in nums:\n      if num != target:\n        ans += 1\n        target ^= 1\n\n    return ans",
      "title": "3192. Minimum Operations to Make Binary Array Elements Equal to One II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "554e332f-1a54-49c0-93f2-98d4e6fe7b43",
      "code": "class Solution:\n  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    # dp[i][j] := the number of ways to arrange the first i numbers of the\n    # permutation s.t. there are j inversions\n    dp = [[0] * (MAX_INVERSIONS + 1) for _ in range(n + 1)]\n    endToCnt = {end + 1: cnt for end, cnt in requirements}\n\n    # There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1\n\n    for i in range(2, n + 1):\n      for newInversions in range(i):\n        for j in range(MAX_INVERSIONS - newInversions + 1):\n          inversionsAfterInsertion = j + newInversions\n          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:\n            continue\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j]\n          dp[i][inversionsAfterInsertion] %= MOD\n\n    return dp[n][endToCnt[n]]",
      "title": "3193. Count the Number of Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c7f765e-c0da-4b04-85f5-9efa6eb6c01a",
      "code": "class Solution:\n  def minimumAverage(self, nums: list[int]) -> float:\n    nums.sort()\n    return min((nums[i] + nums[~i]) / 2\n               for i in range(len(nums) // 2 + 1))",
      "title": "3194. Minimum Average of Smallest and Largest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c04cd314-c674-428f-a5da-f7a587e1d4f3",
      "code": "class Solution:\n  def minimumArea(self, grid: list[list[int]]) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3195. Find the Minimum Area to Cover All Ones I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05d655a4-afee-47b7-aeb7-8221dda17da7",
      "code": "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    # A small trick so that we don't need to handle the edge case and can use\n    # ranged-based for loop.\n    keep = -math.inf  # the maximum cost if the last number is kept\n    flip = 0  # the maximum cost if the last number is flipped\n\n    for num in nums:\n      keep, flip = max(keep, flip) + num, keep - num\n\n    return max(keep, flip)",
      "title": "3196. Maximize Total Cost of Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a76ca3d-0a25-4280-80cb-40d250bdbe46",
      "code": "class Solution:\n  def minimumSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m * n\n\n    for i in range(m):\n      top = self._minimumArea(grid, 0, i, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, top +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for i in range(m):\n      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, bottom +\n                  self._minimumArea(grid, 0, i - 1, 0, j) +\n                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))\n\n    for j in range(n):\n      left = self._minimumArea(grid, 0, m - 1, 0, j)\n      for i in range(m):\n        ans = min(ans, left +\n                  self._minimumArea(grid, 0, i, j + 1, n - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for j in range(n):\n      right = self._minimumArea(grid, 0, m - 1, j, n - 1)\n      for i in range(m):\n        ans = min(ans, right +\n                  self._minimumArea(grid, 0, i, 0, j - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))\n\n    for i1 in range(m):\n      for i2 in range(i1 + 1, m):\n        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +\n                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))\n\n    for j1 in range(n):\n      for j2 in range(j1 + 1, n):\n        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +\n                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))\n\n    return ans\n\n  def _minimumArea(\n      self,\n      grid: list[list[int]],\n      si: int,\n      ei: int,\n      sj: int,\n      ej: int,\n  ) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n    for i in range(si, ei + 1):\n      for j in range(sj, ej + 1):\n        if grid[i][j] == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3197. Find the Minimum Area to Cover All Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "415ad7a4-9cd9-48a4-bfc7-8b2fa50af117",
      "code": "class Solution:\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3199. Count Triplets with Even XOR Set Bits I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ba6e118-06e6-4e67-9af3-e0a6b28fb4dd",
      "code": "class Solution:\n  def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n    return max(self._maxHeight(red, blue),\n               self._maxHeight(blue, red))\n\n  def _maxHeight(self, n1: int, n2: int) -> int:\n    \"\"\"\n    Returns the maximum height of a triangle with the odd levels having `n1`\n    balls and the even levels having `n2` balls.\n    \"\"\"\n    #             1 + 3 + ... + h <= n1\n    # ((1 + h) * (n + 1) / 2) / 2 <= n1\n    #                           h <= sqrt(4 * n1) - 1\n    oddHeight = math.isqrt(4 * n1) - 1\n    #       2 + 4 + ... + h <= n2\n    # ((2 + h) * h / 2) / 2 <= n2\n    #                     h <= sqrt(4 * n2 + 1) - 1\n    evenHeight = math.isqrt(4 * n2 + 1) - 1\n    # If the difference between the odd and even heights is >= 1, we can add an\n    # extra level to the minimum height.\n    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1\n                                         else 0)",
      "title": "3200. Maximum Height of a Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1b1df6e-1046-40f4-ae0b-22e2ca079610",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * 2 for _ in range(2)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(2):\n        dp[x % 2][y] = dp[y][x % 2] + 1\n\n    return max(map(max, dp))",
      "title": "3201. Find the Maximum Length of Valid Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6fc5344-2ffb-4a3e-b1a9-ad0c1715ad4c",
      "code": "class Solution:\n  # Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * k for _ in range(k)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(k):\n        dp[x % k][y] = dp[y][x % k] + 1\n\n    return max(map(max, dp))",
      "title": "3202. Find the Maximum Length of Valid Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9298855d-d110-4a7a-90f2-20f1321b2b56",
      "code": "class Solution:\n  def minimumDiameterAfterMerge(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n  ) -> int:\n    diameter1 = self._getDiameter(edges1)\n    diameter2 = self._getDiameter(edges2)\n    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1\n    return max(diameter1, diameter2, combinedDiameter)\n\n  def _getDiameter(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    maxDiameter = [0]\n    self._maxDepth(graph, 0, -1, maxDiameter)\n    return maxDiameter[0]\n\n  # Similar to 1522. Diameter of N-Ary Tree\n  def _maxDepth(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      maxDiameter: list[int],\n  ) -> int:\n    \"\"\"Returns the maximum depth of the subtree rooted at u.\"\"\"\n    maxSubDepth1 = 0\n    maxSubDepth2 = 0\n    for v in graph[u]:\n      if v == prev:\n        continue\n      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)\n      if maxSubDepth > maxSubDepth1:\n        maxSubDepth2 = maxSubDepth1\n        maxSubDepth1 = maxSubDepth\n      elif maxSubDepth > maxSubDepth2:\n        maxSubDepth2 = maxSubDepth\n    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)\n    return 1 + maxSubDepth1",
      "title": "3203. Find Minimum Diameter After Merging Two Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9adf1737-4804-4553-926e-422d70be8621",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i] := the maximum score to jump from index i to n - 1\n    dp = [0] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        # Jump from i to j, and then jump from j to n - 1.\n        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])\n\n    return dp[0]",
      "title": "3205. Maximum Array Hopping Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8a4916b-8586-462e-b4b1-cce98226b893",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int]) -> int:\n    n = len(colors)\n    return sum(colors[i] != colors[i - 1] and\n               colors[i] != colors[(i + 1) % n]\n               for i in range(n))",
      "title": "3206. Alternating Groups I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cb63b9e-6b47-47d7-a0f1-1d7968ea7aa3",
      "code": "class Solution:\n  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:\n    minEnergy = min(enemyEnergies)\n    return (0 if currentEnergy < minEnergy\n            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)",
      "title": "3207. Maximum Points After Enemy Battles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf461742-1628-46e1-98d4-3ccb3a95a2ef",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:\n    n = len(colors)\n    ans = 0\n    alternating = 1\n\n    for i in range(n + k - 2):\n      alternating = (1 if colors[i % n] == colors[(i - 1) % n]\n                     else alternating + 1)\n      if alternating >= k:\n        ans += 1\n\n    return ans",
      "title": "3208. Alternating Groups II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9317e986-65f0-47da-8ea8-f59b1c0564c6",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # the counter of all the values of subarrays that end in the previous\n    # number\n    prev = collections.Counter()\n\n    for num in nums:\n      # Extend each subarray that ends in the previous number. Due to\n      # monotonicity of the AND operation, the size of `curr` will be at most\n      # num.bit_count() + 1.\n      curr = collections.Counter({num: 1})\n      for val, freq in prev.items():\n        curr[val & num] += freq\n      ans += curr[k]\n      prev = curr\n\n    return ans",
      "title": "3209. Number of Subarrays With AND Value of K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95655dda-b122-4397-813c-8b64b2fe5059",
      "code": "class Solution:\n  def getEncryptedString(self, s: str, k: int) -> str:\n    k %= len(s)\n    return s[k:] + s[0:k]",
      "title": "3210. Find the Encrypted String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae17fc45-0fa3-47da-90c0-a560509f644e",
      "code": "class Solution:\n  def validStrings(self, n: int) -> list[str]:\n    ans = []\n\n    def dfs(n: int, s: list[str]) -> None:\n      if n == 0:\n        ans.append(''.join(s))\n        return\n      if not s or s[-1] == '1':\n        s.append('0')\n        dfs(n - 1, s)\n        s.pop()\n      s.append('1')\n      dfs(n - 1, s)\n      s.pop()\n\n    dfs(n, [])\n    return ans",
      "title": "3211. Generate Binary Strings Without Adjacent Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3b8f3e2-b8e2-41b5-b7e4-47b9c4749942",
      "code": "class Solution:\n  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    x = [[0] * (n + 1) for _ in range(m + 1)]\n    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    y = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]\n        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]\n        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:\n          ans += 1\n\n    return ans",
      "title": "3212. Count Submatrices With Equal Frequency of X and Y",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91130a99-e9fd-4c38-af98-b027faa4dd28",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0..i)\n    dp = [0] + [math.inf] * n\n    # minCost[c][word] := the minimum cost to construct word starting with `c`\n    minCost: dict[str, dict[str, int]] = collections.defaultdict(dict)\n\n    for word, cost in zip(words, costs):\n      c = word[0]\n      minCost[c][word] = min(minCost[c].get(word, math.inf), cost)\n\n    for i, c in enumerate(target):\n      for word, cost in minCost[c].items():\n        j = i + len(word)\n        if j <= n and cost + dp[i] < dp[j] and target[i:j] == word:\n          dp[j] = cost + dp[i]\n\n    return -1 if dp[n] == math.inf else dp[n]",
      "title": "3213. Construct String with Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3967da9-f900-4a14-97d7-c144e1d16fcd",
      "code": "class Solution:\n  # Same as 3199. Count Triplets with Even XOR Set Bits I\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3215. Count Triplets with Even XOR Set Bits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d77c22e6-60b6-4f18-a3f9-119a33efd783",
      "code": "class Solution:\n  def getSmallestString(self, s: str) -> str:\n    chars = list(s)\n    for i, (a, b) in enumerate(itertools.pairwise(chars)):\n      if ord(a) % 2 == ord(b) % 2 and a > b:\n        chars[i], chars[i + 1] = chars[i + 1], chars[i]\n        return ''.join(chars)\n    return s",
      "title": "3216. Lexicographically Smallest String After a Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60351409-a2eb-46b5-a444-d0e27361b80a",
      "code": "class Solution:\n  def modifiedList(\n      self,\n      nums: list[int],\n      head: ListNode | None,\n  ) -> ListNode | None:\n    dummy = ListNode(0, head)\n    numsSet = set(nums)\n\n    curr = dummy\n    while curr.next:\n      if curr.next.val in numsSet:\n        curr.next = curr.next.next\n      else:\n        curr = curr.next\n\n    return dummy.next",
      "title": "3217. Delete Nodes From Linked List Present in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75897e23-f62d-455a-ac7f-f85e24fc70f8",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3218. Minimum Cost for Cutting Cake I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17881891-ae3b-4086-b2a8-ca28a5533f70",
      "code": "class Solution:\n  # Same as 3218. Minimum Cost for Cutting Cake I\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3219. Minimum Cost for Cutting Cake II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15c3c629-cbf1-4e6c-8ebd-688565474638",
      "code": "class Solution:\n  # Same as 3205. Maximum Array Hopping Score I\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))",
      "title": "3221. Maximum Array Hopping Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be95ce0e-ffe0-4f67-b9a1-9832013a56fe",
      "code": "class Solution:\n  def losingPlayer(self, x: int, y: int) -> str:\n    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'",
      "title": "3222. Find the Winning Player in Coin Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed93ebda-a9a6-4824-958d-a922ff95154a",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    count = collections.Counter(s)\n    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())",
      "title": "3223. Minimum Length of String After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9cf5b63-f172-4608-9a26-98e892e13c87",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    pairSize = len(nums) // 2\n    diffCount = collections.Counter()  # {nums[-1 - i] - nums[i]: freq}\n    # oneChangeCount[i] := the number of pairs that need only one change to\n    # to achieve a difference of `i`\n    oneChangeCount = [0] * (k + 1)\n\n    for i in range(pairSize):\n      a = nums[i]\n      b = nums[-1 - i]\n      diffCount[abs(a - b)] += 1\n      oneChangeCount[max(a, b, k - a, k - b)] += 1\n\n    # prefixOneChangeCount[i] := the number of pairs that need only one change\n    # to achieve a difference >= `i`\n    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    prefixOneChangeCount = list(\n        itertools.accumulate(reversed(oneChangeCount)))[::-1]\n\n    return min(prefixOneChangeCount[diff] - freq +  # one change\n               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes\n               for diff, freq in diffCount.items())",
      "title": "3224. Minimum Array Changes to Make Differences Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27fbb980-27d2-472b-8bde-2d15af130df1",
      "code": "class Solution:\n  def maximumScore(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    # prefix[j][i] := the sum of the first i elements in the j-th column\n    prefix = [[0] * (n + 1) for _ in range(n)]\n    # prevPick[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the previous column is in row (i - 1)\n    prevPick = [0] * (n + 1)\n    # prevSkip[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the column before the previous one is in\n    # row (i - 1)\n    prevSkip = [0] * (n + 1)\n\n    for j in range(n):\n      for i in range(n):\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j]\n\n    for j in range(1, n):\n      currPick = [0] * (n + 1)\n      currSkip = [0] * (n + 1)\n      # Consider all possible combinations of the number of current and\n      # previous selected elements.\n      for curr in range(n + 1):  # the number of current selected elements\n        for prev in range(n + 1):  # the number of previous selected elements\n          if curr > prev:\n            # 1. The current bottom is deeper than the previous bottom.\n            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.\n            score = prefix[j - 1][curr] - prefix[j - 1][prev]\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)\n          else:\n            # 2. The previous bottom is deeper than the current bottom.\n            # Get the score of grid[curr..prev)[j] for pick only.\n            score = prefix[j][prev] - prefix[j][curr]\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevPick[prev])\n      prevPick = currPick\n      prevSkip = currSkip\n\n    return max(prevPick)",
      "title": "3225. Maximum Score From Grid Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}