{
  "snippets": [
    {
      "id": "26788f22-bb28-46ff-996b-f2f1381dceba",
      "code": "class Solution:\n  def minimumTime(self, grid: list[list[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]  # (time, i, j)\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))",
      "title": "2577. Minimum Time to Visit a Cell In a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c70e8a47-f8f1-4b0c-92be-8a00c7735968",
      "code": "class Solution:\n  def splitNum(self, num: int) -> int:\n    s = ''.join(sorted(str(num)))\n    return sum(map(int, (s[::2], s[1::2])))",
      "title": "2578. Split With Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce0380d-3ceb-4950-97be-da25f103955b",
      "code": "class Solution:\n  def coloredCells(self, n: int) -> int:\n    return n**2 + (n - 1)**2",
      "title": "2579. Count Total Number of Colored Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f742d148-9062-4c80-a5be-c426395563e6",
      "code": "class Solution:\n  def countWays(self, ranges: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevEnd = -1\n\n    for start, end in sorted(ranges):\n      if start > prevEnd:\n        ans = ans * 2 % MOD\n      prevEnd = max(prevEnd, end)\n\n    return ans",
      "title": "2580. Count Ways to Group Overlapping Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1c1006a-48c7-4d13-8576-503d49582727",
      "code": "class Solution:\n  def rootCount(\n      self,\n      edges: list[list[int]],\n      guesses: list[list[int]],\n      k: int,\n  ) -> int:\n    ans = 0\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    guessGraph = [set() for _ in range(n)]\n    parent = [0] * n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u, v in guesses:\n      guessGraph[u].add(v)\n\n    def dfs(u: int, prev: int) -> None:\n      parent[u] = prev\n      for v in graph[u]:\n        if v != prev:\n          dfs(v, u)\n\n    # Precalculate `parent`.\n    dfs(0, -1)\n\n    # Calculate `correctGuess` for tree rooted at 0.\n    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))\n\n    def reroot(u: int, prev: int, correctGuess: int) -> None:\n      nonlocal ans\n      if u != 0:\n        # The tree is rooted at u, so a guess edge (u, prev) will match the new\n        # `parent` relationship.\n        if prev in guessGraph[u]:\n          correctGuess += 1\n        # A guess edge (prev, u) matching the old `parent` relationship will no\n        # longer be True.\n        if u in guessGraph[prev]:\n          correctGuess -= 1\n      if correctGuess >= k:\n        ans += 1\n      for v in graph[u]:\n        if v != prev:\n          reroot(v, u, correctGuess)\n\n    reroot(0, -1, correctGuess)\n    return ans",
      "title": "2581. Count Number of Possible Root Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5cc0df4-f07b-4b6c-8566-27d1f9b1923b",
      "code": "class Solution:\n  def passThePillow(self, n: int, time: int) -> int:\n    # Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2\n    if time < n:  # Go forward from 1.\n      return 1 + time\n    return n - (time - (n - 1))  # Go backward from n.",
      "title": "2582. Pass the Pillow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb5a684d-2465-4dbc-9740-761b7ace4bb2",
      "code": "class Solution:\n  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    if len(levelSums) < k:\n      return -1\n\n    return sorted(levelSums, reverse=True)[k - 1]",
      "title": "2583. Kth Largest Sum in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e61e904a-f55f-40a1-8e2e-9862612c3550",
      "code": "class Solution:\n  def findValidSplit(self, nums: list[int]) -> int:\n    leftPrimeFactors = collections.Counter()\n    rightPrimeFactors = collections.Counter()\n\n    def getPrimeFactors(num: int) -> list[int]:\n      \"\"\"Gets the prime factors under sqrt(10^6).\"\"\"\n      primeFactors = []\n      for divisor in range(2, min(1000, num) + 1):\n        if num % divisor == 0:\n          primeFactors.append(divisor)\n          while num % divisor == 0:\n            num //= divisor\n      # Handle the case that `num` contains a prime factor > 1000.\n      if num > 1:\n        primeFactors.append(num)\n      return primeFactors\n\n    for num in nums:\n      for primeFactor in getPrimeFactors(num):\n        rightPrimeFactors[primeFactor] += 1\n\n    for i in range(len(nums) - 1):\n      for primeFactor in getPrimeFactors(nums[i]):\n        rightPrimeFactors[primeFactor] -= 1\n        if rightPrimeFactors[primeFactor] == 0:\n          # rightPrimeFactors[primeFactor] == 0, so no need to track\n          # leftPrimeFactors[primeFactor].\n          del rightPrimeFactors[primeFactor]\n          del leftPrimeFactors[primeFactor]\n        else:\n          # Otherwise, need to track leftPrimeFactors[primeFactor].\n          leftPrimeFactors[primeFactor] += 1\n      if not leftPrimeFactors:\n        return i\n\n    return -1",
      "title": "2584. Split the Array to Make Coprime Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ed69af8-2bfe-4f2c-b6c6-640cd513d416",
      "code": "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of ways to earn j points with the first i types\n    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, len(types) + 1):\n      count = types[i - 1][0]\n      mark = types[i - 1][1]\n      for j in range(target + 1):\n        for solved in range(count + 1):\n          if j - solved * mark >= 0:\n            dp[i][j] += dp[i - 1][j - solved * mark]\n            dp[i][j] %= MOD\n\n    return dp[len(types)][target]",
      "title": "2585. Number of Ways to Earn Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ebb7810-e116-44b0-9b2a-06db6ddf61ae",
      "code": "class Solution:\n  def vowelStrings(self, words: list[str], left: int, right: int) -> int:\n    VOWELS = 'aeiou'\n    return sum(word[0] in VOWELS and word[-1] in VOWELS\n               for word in words[left:right + 1])",
      "title": "2586. Count the Number of Vowel Strings in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e68eb2f5-86aa-46e6-a55b-74b52a2f9ff6",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    return sum(num > 0\n               for num in itertools.accumulate(sorted(nums, reverse=True)))",
      "title": "2587. Rearrange Array to Maximize Prefix Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb17b6dd-b570-4c3e-8eaf-a482f6a02afc",
      "code": "class Solution:\n  def beautifulSubarrays(self, nums: list[int]) -> int:\n    # A subarray is beautiful if xor(subarray) = 0.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix ^= num\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2588. Count the Number of Beautiful Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ee8202a-8116-4f45-98e1-ab45cbc30485",
      "code": "class Solution:\n  def findMinimumTime(self, tasks: list[list[int]]) -> int:\n    MAX = 2000\n    running = [False] * (MAX + 1)\n\n    # Sort tasks by end.\n    for start, end, duration in sorted(tasks, key=lambda x: x[1]):\n      neededDuration = (duration -\n                        sum(running[i] for i in range(start, end + 1)))\n      # Greedily run the task as late as possible so that later tasks can run\n      # simultaneously.\n      i = end\n      while neededDuration > 0:\n        if not running[i]:\n          running[i] = True\n          neededDuration -= 1\n        i -= 1\n\n    return sum(running)",
      "title": "2589. Minimum Time to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b936b14-bf57-4a5a-9a52-5eaff6d7d8fc",
      "code": "class Solution:\n  def distMoney(self, money: int, children: int) -> int:\n    # Everyone must receive at least 1 dollar.\n    money -= children\n    if money < 0:\n      return -1\n\n    count7 = money // 7\n    remaining = money % 7\n\n    # Distribute 8 dollars to every child.\n    if count7 == children and remaining == 0:\n      return count7\n\n    # Need to move 1 dollar from the last child with 4 dollars to one of other\n    # children. That's why we need to substract 1.\n    if count7 == children - 1 and remaining == 3:\n      return count7 - 1\n\n    # Though there might be child with 4 dollars, since count7 < children - 1,\n    # we have 'extra' spot to move money to if needed.\n    return min(children - 1, count7)",
      "title": "2591. Distribute Money to Maximum Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "250b4b5e-f255-40f3-8cb0-14330cf7816c",
      "code": "class Solution:\n  def maximizeGreatness(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for num in nums:\n      if num > nums[ans]:\n        ans += 1\n\n    return ans",
      "title": "2592. Maximize Greatness of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51f438ec-485a-4480-80fe-e9e1eb4a3413",
      "code": "class Solution:\n  def findScore(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n\n    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):\n      if i in seen:\n        continue\n      seen.add(i - 1)\n      seen.add(i + 1)\n      seen.add(i)\n      ans += num\n\n    return ans",
      "title": "2593. Find Score of an Array After Marking All Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b2bac49-0e75-4188-998d-2290506bff83",
      "code": "class Solution:\n  def repairCars(self, ranks: list[int], cars: int) -> int:\n    def numCarsFixed(minutes: int) -> int:\n      #    r * n^2 = minutes\n      # -> n = sqrt(minutes / r)\n      return sum(math.isqrt(minutes // rank) for rank in ranks)\n\n    return bisect.bisect_left(range(min(ranks) * cars**2), cars,\n                              key=numCarsFixed)",
      "title": "2594. Minimum Time to Repair Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d3e6528-4601-4cbd-9618-dfc71d8c3981",
      "code": "class Solution:\n  def evenOddBit(self, n: int) -> list[int]:\n    ans = [0] * 2\n    i = 0  # 0 := even, 1 := odd\n\n    while n > 0:\n      ans[i] += n & 1\n      n >>= 1\n      i ^= 1\n\n    return ans",
      "title": "2595. Number of Even and Odd Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcd2bae2-ceae-489d-aaa2-1e9f01304b3b",
      "code": "class Solution:\n  def checkValidGrid(self, grid: list[list[int]]) -> bool:\n    if grid[0][0] != 0:\n      return False\n\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    n = len(grid)\n    i = 0\n    j = 0\n\n    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:\n      \"\"\"\n      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n      \"\"\"\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x >= n or y < 0 or y >= n:\n          continue\n        if grid[x][y] == target:\n          return (x, y)\n      return (-1, -1)\n\n    for target in range(1, n * n):\n      x, y = nextGrid(i, j, target)\n      if x == -1 and y == -1:\n        return False\n      # Move (x, y) to (i, j).\n      i = x\n      j = y\n\n    return True",
      "title": "2596. Check Knight Tour Configuration",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9db2e3a8-ee08-4485-87c8-769b0f5d20a2",
      "code": "# e.g. nums = [2, 3, 4, 4], k = 2\n#\n# subset[0] = [2, 4, 4']\n# subset[1] = [1]\n# count = {2: 1, 4: 2, 1: 1}\n#\n# Initially, skip = len([]) = 0, pick = len([]) = 0\n#\n# * For values in subset[0]:\n#   After 2:\n#     skip = skip + pick = len([]) = 0\n#     pick = (2^count[2] - 1) * (1 + skip + pick)\n#          = len([[2]]) * len([[]])\n#          = len([[2]]) = 1\n#   After 4:\n#     skip = skip + pick = len([[2]]) = 1\n#     pick = (2^count[4] - 1) * (1 + skip)\n#          = len([[4], [4'], [4, 4']]) * len([[]])\n#          = len([[4], [4'], [4, 4']]) = 3\n#\n# * For values in subset[1]:\n#   After 1:\n#     skip = skip + pick\n#          = len([[2], [4], [4'], [4, 4']]) = 4\n#     pick = (2^count[1] - 1) * (1 + skip + pick)\n#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n#\n# So, ans = skip + pick = 9\n\nclass Solution:\n  def beautifulSubsets(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        nonEmptyCount = 2**count[num] - 1\n        skip, pick = (skip + pick,\n                      nonEmptyCount *\n                      (1 + skip + (0 if num - prevNum == k else pick)))\n        prevNum = num\n\n    return skip + pick",
      "title": "2597. The Number of Beautiful Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "702468eb-1de4-4039-be4b-86cb075fe89a",
      "code": "class Solution:\n  def findSmallestInteger(self, nums: list[int], value: int) -> int:\n    count = collections.Counter([num % value for num in nums])\n\n    for i in range(len(nums)):\n      if count[i % value] == 0:\n        return i\n      count[i % value] -= 1\n\n    return len(nums)",
      "title": "2598. Smallest Missing Non-negative Integer After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2632ae65-f30b-4c80-9138-b5887b6aedba",
      "code": "class Solution:\n  def makePrefSumNonNegative(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    minHeap = []\n\n    for num in nums:\n      prefix += num\n      if num < 0:\n        heapq.heappush(minHeap, num)\n      while prefix < 0:\n        prefix -= heapq.heappop(minHeap)\n        ans += 1\n\n    return ans",
      "title": "2599. Make the Prefix Sum Non-negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c889116-a11d-44f3-815e-f18ebc0592f3",
      "code": "class Solution:\n  def kItemsWithMaximumSum(\n      self,\n      numOnes: int,\n      numZeros: int,\n      numNegOnes: int,\n      k: int,\n  ) -> int:\n    if k <= numOnes:\n      return k\n    if k <= numOnes + numZeros:\n      return numOnes\n    return numOnes - (k - numOnes - numZeros)",
      "title": "2600. K Items With the Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "275187af-d00f-4d13-8b4c-b46aa0ef7976",
      "code": "class Solution:\n  def primeSubOperation(self, nums: list[int]) -> bool:\n    MAX = 1000\n    primes = self._sieveEratosthenes(MAX)\n\n    prevNum = 0\n    for num in nums:\n      # Make nums[i] the smallest as possible and still > nums[i - 1].\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]",
      "title": "2601. Prime Subtraction Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9f2342e-888f-44bc-bff8-83e86d33328a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    prefix = list(itertools.accumulate(nums, initial=0))\n    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]\n    return [(query * i - prefix[i]) +\n            (prefix[-1] - prefix[i] - query * (n - i))\n            for query, i in splits]",
      "title": "2602. Minimum Operations to Make All Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c1bad77-0042-4a57-afd2-fe61dc884acf",
      "code": "class Solution:\n  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      # Remove the leaves that don't have coins.\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v  # Walk up to its parent.\n      # After trimming leaves without coins, leaves with coins may satisfy\n      # `leavesToBeRemoved`.\n      if len(tree[u]) == 1:  # coins[u] must be 1.\n        leavesToBeRemoved.append(u)\n\n    # Remove each remaining leaf node and its parent. The remaining nodes are\n    # the ones that must be visited.\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:  # It's a leaf.\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)",
      "title": "2603. Collect Coins in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "223a230e-bb15-4792-8c07-8cb3949e44c6",
      "code": "class Solution:\n  def minimumTime(self, hens: list[int], grains: list[int]) -> int:\n    hens.sort()\n    grains.sort()\n\n    def canEat(time: int) -> bool:\n      \"\"\"Returns True if `hens` can eat all `grains` within `time`.\"\"\"\n      i = 0  # grains[i] := next grain to be ate\n      for hen in hens:\n        rightMoves = time\n        if grains[i] < hen:\n          # `hen` needs go back to eat `grains[i]`.\n          leftMoves = hen - grains[i]\n          if leftMoves > time:\n            return False\n          leftThenRight = time - 2 * leftMoves\n          rightThenLeft = (time - leftMoves) // 2\n          rightMoves = max(0, leftThenRight, rightThenLeft)\n        i = bisect.bisect_right(grains, hen + rightMoves)\n        if i == len(grains):\n          return True\n      return False\n\n    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))\n    return bisect.bisect_left(range(maxMoves), True, key=canEat)",
      "title": "2604. Minimum Time to Eat All Grains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fc71859-ab90-4dfa-a91d-19adb6b9a838",
      "code": "class Solution:\n  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(a if a == b else min(a, b) * 10 + max(a, b)\n               for a in nums1\n               for b in nums2)",
      "title": "2605. Form Smallest Number From Two Digit Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ef367af-00ce-4cbc-a8d0-adc73287839d",
      "code": "class Solution:\n  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:\n    ans = 0\n    cost = 0\n    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i\n\n    for c, val in zip(chars, vals):\n      costs[ord(c) - ord('a')] = val\n\n    for c in s:\n      cost = max(0, cost + costs[ord(c) - ord('a')])\n      ans = max(ans, cost)\n\n    return ans",
      "title": "2606. Find the Substring With Maximum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7429ce28-82d1-4fe6-8c00-4ffadfccb8ee",
      "code": "class Solution:\n  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:\n    # If the sum of each subarray of length k is equal, then `arr` must have a\n    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    # arr[(i + k) % n] for every i.\n    n = len(arr)\n    ans = 0\n    seen = [0] * n\n\n    for i in range(n):\n      groups = []\n      j = i\n      while not seen[j]:\n        groups.append(arr[j])\n        seen[j] = True\n        j = (j + k) % n\n      groups.sort()\n      for num in groups:\n        ans += abs(num - groups[len(groups) // 2])\n\n    return ans",
      "title": "2607. Make K-Subarray Sums Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf1af48-0c49-4693-8779-58a466e2c234",
      "code": "class Solution:\n  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:\n    INF = 1001\n    ans = INF\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(i: int) -> int:\n      \"\"\"Returns the length of the minimum cycle by starting BFS from node `i`.\n\n      Returns `INF` if there's no cycle.\n      \"\"\"\n      dist = [INF] * n\n      q = collections.deque([i])\n      dist[i] = 0\n      while q:\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            q.append(v)\n          elif dist[v] + 1 != dist[u]:   # v is not a parent u.\n            return dist[v] + dist[u] + 1\n      return INF\n\n    ans = min(map(bfs, range(n)))\n    return -1 if ans == INF else ans",
      "title": "2608. Shortest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2606c054-4802-4121-b1f9-56fd81704e5f",
      "code": "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      zeros = 0\n      ones = 0\n      while i < len(s) and s[i] == '0':\n        zeros += 1\n        i += 1\n      while i < len(s) and s[i] == '1':\n        ones += 1\n        i += 1\n      ans = max(ans, min(zeros, ones))\n\n    return ans * 2",
      "title": "2609. Find the Longest Balanced Substring of a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9b59de9-35f2-4d7f-a3ad-759420b5fab7",
      "code": "class Solution:\n  def findMatrix(self, nums: list[int]) -> list[list[int]]:\n    # The number of rows we need equals the maximum frequency.\n    ans = []\n    count = [0] * (len(nums) + 1)\n\n    for num in nums:\n      count[num] += 1\n      # Construct `ans` on demand.\n      if count[num] > len(ans):\n        ans.append([])\n      ans[count[num] - 1].append(num)\n\n    return ans",
      "title": "2610. Convert an Array Into a 2D Array With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ce54156-5c6a-4d6a-9750-d2363ce5bd34",
      "code": "class Solution:\n  def miceAndCheese(\n      self,\n      reward1: list[int],\n      reward2: list[int],\n      k: int,\n  ) -> int:\n    return (sum(reward2) +\n            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))",
      "title": "2611. Mice and Cheese",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc0dd265-2551-4c80-918b-ea3a0044a65c",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minReverseOperations(\n      self,\n      n: int,\n      p: int,\n      banned: list[int],\n      k: int,\n  ) -> list[int]:\n    bannedSet = set(banned)\n    ans = [-1] * n\n    # unseen[i] := the unseen numbers that % 2 == i\n    unseen = [SortedList(), SortedList()]\n\n    for num in range(n):\n      if num != p and num not in bannedSet:\n        unseen[num % 2].add(num)\n\n    # Perform BFS from `p`.\n    q = collections.deque([p])\n    ans[p] = 0\n\n    while q:\n      u = q.popleft()\n      lo = max(u - k + 1, k - 1 - u)\n      hi = min(u + k - 1, n - 1 - (u - (n - k)))\n      # Choose the correct set of numbers.\n      nums = unseen[lo % 2]\n      i = nums.bisect_left(lo)\n      while i < len(nums) and nums[i] <= hi:\n        num = nums[i]\n        ans[num] = ans[u] + 1\n        q.append(num)\n        nums.pop(i)\n\n    return ans",
      "title": "2612. Minimum Reverse Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb019baa-6603-4112-b78c-cd1b27924ab1",
      "code": "class Solution:\n  def diagonalPrime(self, nums: list[list[int]]) -> int:\n    def isPrime(n: int) -> bool:\n      if n <= 1:\n        return False\n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          return False\n      return True\n\n    primes1 = [row[i]\n               for i, row in enumerate(nums) if isPrime(row[i])]\n    primes2 = [row[-1 - i]\n               for i, row in enumerate(nums) if isPrime(row[-1 - i])]\n    return max(max(primes1) if primes1 else 0,\n               max(primes2) if primes2 else 0)",
      "title": "2614. Prime In Diagonal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a857af-3ea6-4995-bbac-030fef36693e",
      "code": "class Solution:\n  def distance(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      n = len(indices)\n      if n == 1:\n        continue\n      sumSoFar = sum(indices)\n      prevIndex = 0\n      for i in range(n):\n        sumSoFar += (i - 1) * (indices[i] - prevIndex)\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)\n        ans[indices[i]] = sumSoFar\n        prevIndex = indices[i]\n\n    return ans",
      "title": "2615. Sum of Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cda93fa7-620d-413a-9e77-9e86c6d2963d",
      "code": "class Solution:\n  def minimizeMax(self, nums: list[int], p: int) -> int:\n    nums.sort()\n\n    def numPairs(maxDiff: int) -> int:\n      \"\"\"\n      Returns the number of pairs that can be obtained if the difference between\n      each pair <= `maxDiff`.\n      \"\"\"\n      pairs = 0\n      i = 1\n      while i < len(nums):\n        # Greedily pair nums[i] with nums[i - 1].\n        if nums[i] - nums[i - 1] <= maxDiff:\n          pairs += 1\n          i += 2\n        else:\n          i += 1\n      return pairs\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), p, key=numPairs)",
      "title": "2616. Minimize the Maximum Difference of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60efba3c-f139-4cad-b0d7-0ecf5d46c260",
      "code": "class Solution:\n  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        skip, pick = (skip + pick,\n                      1 + skip + (0 if num - prevNum == k else pick))\n        prevNum = num\n\n    return 1 + skip + pick",
      "title": "2638. Count the Number of K-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fe6a046-1b39-4852-9639-35e7b9bbe376",
      "code": "class Solution:\n  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:\n    return [max(map(len, map(str, col))) for col in zip(*grid)]",
      "title": "2639. Find the Width of Columns of a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e45d17c-1901-43a5-88f0-4033066c2197",
      "code": "class Solution:\n  def findPrefixScore(self, nums: list[int]) -> list[int]:\n    conver = []\n    mx = 0\n\n    for num in nums:\n      mx = max(mx, num)\n      conver.append(num + mx)\n\n    return itertools.accumulate(conver)",
      "title": "2640. Find the Score of All Prefixes of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e06c970b-da06-4e04-a18d-2e0adf6c1a75",
      "code": "class Solution:\n  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    def replace(\n        root: TreeNode | None,\n        level: int, curr: TreeNode | None,\n    ) -> TreeNode | None:\n      nextLevel = level + 1\n      nextLevelCousinsSum = (\n          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -\n          (root.left.val if root.left else 0) -\n          (root.right.val if root.right else 0))\n      if root.left:\n        curr.left = TreeNode(nextLevelCousinsSum)\n        replace(root.left, level + 1, curr.left)\n      if root.right:\n        curr.right = TreeNode(nextLevelCousinsSum)\n        replace(root.right, level + 1, curr.right)\n      return curr\n\n    dfs(root, 0)\n    return replace(root, 0, TreeNode(0))",
      "title": "2641. Cousins in Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a553da6e-d45f-431b-9dee-1d60b63f328e",
      "code": "class Solution:\n  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:\n    ans = [0, 0]\n\n    for i, row in enumerate(mat):\n      ones = row.count(1)\n      if ones > ans[1]:\n        ans[0] = i\n        ans[1] = ones\n\n    return ans",
      "title": "2643. Row With Maximum Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b50f3c83-0829-42fb-8f3d-14df766ff17b",
      "code": "class Solution:\n  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:\n    ans = -1\n    maxScore = -1\n\n    for divisor in divisors:\n      score = sum([1 for num in nums if num % divisor == 0])\n      if score > maxScore:\n        ans = divisor\n        maxScore = score\n      elif score == maxScore:\n        ans = min(ans, divisor)\n\n    return ans",
      "title": "2644. Find the Maximum Divisibility Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a811d06d-31d9-4cd0-9cfa-5cbac0c96f6c",
      "code": "class Solution:\n  def addMinimum(self, word: str) -> int:\n    letters = ['a', 'b', 'c']\n    ans = 0\n    i = 0\n\n    while i < len(word):\n      for c in letters:\n        if i < len(word) and word[i] == c:\n          i += 1\n        else:\n          ans += 1\n\n    return ans",
      "title": "2645. Minimum Additions to Make Valid String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ef3af7e-21de-45bb-adb8-4da0f90ed64c",
      "code": "class Solution:\n  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],\n                        trips: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # count[i] := the number of times i is traversed\n    count = [0] * n\n\n    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:\n      path.append(u)\n      if u == end:\n        for i in path:\n          count[i] += 1\n        return\n      for v in graph[u]:\n        if v != prev:\n          dfsCount(v, u, end,  path)\n      path.pop()\n\n    for start, end in trips:\n      dfsCount(start, -1, end, [])\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, parentHalved: bool) -> int:\n      \"\"\"\n      Returns the minimum price sum for the i-th node, where its parent is\n      halved parent or not halved not.\n      \"\"\"\n      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)\n                                                  for v in graph[u]\n                                                  if v != prev)\n      if parentHalved:  # Can't halve this node if its parent was halved.\n        return sumWithFullNode\n      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)\n                                                           for v in graph[u]\n                                                           if v != prev)\n      return min(sumWithFullNode, sumWithHalvedNode)\n\n    return dfs(0, -1, False)",
      "title": "2646. Minimize the Total Price of the Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92144dc0-a331-4ea0-a385-d9cd7e456986",
      "code": "class Solution:\n  def colorRed(self, n: int) -> list[list[int]]:\n    ans = []\n    tipSize = n % 4\n\n    # The tip of the triangle is always painted red.\n    if tipSize >= 1:\n      ans.append([1, 1])\n\n    # Pamost right and most left elements at the following rows.\n    for i in range(2, tipSize + 1):\n      ans.append([i, 1])\n      ans.append([i, 2 * i - 1])\n\n    # Pa4-row chunks.\n    for i in range(tipSize + 1, n, 4):\n      # Fill the first row of the chunk.\n      ans.append([i, 1])\n      # Fill the second row.\n      for j in range(1, i + 1):\n        ans.append([i + 1, 2 * j + 1])\n      # Fill the third row.\n      ans.append([i + 2, 2])\n      # Fill the fourth row.\n      for j in range(i + 2 + 1):\n        ans.append([i + 3, 2 * j + 1])\n\n    return ans",
      "title": "2647. Color the Triangle Red",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcd47106-73b9-41cb-a1b7-d932e2057f71",
      "code": "class Solution:\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n    return (arrivalTime + delayedTime) % 24",
      "title": "2651. Calculate Delayed Arrival Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e9a7888-f46d-45a9-b3db-95cf8af0032c",
      "code": "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    def sumOfMultiples(value: int) -> int:\n      \"\"\"Returns the sum of multiples of value in [1, n].\"\"\"\n      lo = value\n      hi = (n // value) * value\n      count = (hi - lo) // value + 1\n      return (lo + hi) * count // 2\n\n    return (sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n            (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n            sumOfMultiples(105))",
      "title": "2652. Sum Multiples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8acd4cf-89e1-460f-8a7d-f00cbbe0b937",
      "code": "class Solution:\n  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    count = [0] * 50  # count[i] := the frequency of (i + 50)\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: list[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0",
      "title": "2653. Sliding Subarray Beauty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8102674b-f790-4dae-a5b9-3f6b2467b67d",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ones = nums.count(1)\n    if ones > 0:\n      return n - ones\n\n    # the minimum operations to make the shortest subarray with a gcd == 1\n    minOps = math.inf\n\n    for i, g in enumerate(nums):\n      for j in range(i + 1, n):\n        g = math.gcd(g, nums[j])\n        if g == 1:   # gcd(nums[i..j]:== 1\n          minOps = min(minOps, j - i)\n          break\n\n    # After making the shortest subarray with `minOps`, need additional n - 1\n    # operations to make the other numbers to 1.\n    return -1 if minOps == math.inf else minOps + n - 1",
      "title": "2654. Minimum Number of Operations to Make All Array Elements Equal to 1",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bc7f106-f8f2-4409-aae4-dff79c43ac5c",
      "code": "class Solution:\n  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:\n    ans = []\n    start = 0\n\n    for l, r in sorted(ranges):\n      if start < l:\n        ans.append([start, l - 1])\n      if start <= r:\n        start = r + 1\n\n    if start < n:\n      ans.append([start, n - 1])\n\n    return ans",
      "title": "2655. Find Maximal Uncovered Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01bb4ee0-921b-40cb-a444-d47a5db0dc9e",
      "code": "class Solution:\n  def maximizeSum(self, nums: list[int], k: int) -> int:\n    return max(nums) * k + k * (k - 1) // 2",
      "title": "2656. Maximum Sum With Exactly K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e85cf0c-b0eb-4af9-b961-2f95db46d783",
      "code": "class Solution:\n  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n    n = len(A)\n    prefixCommon = 0\n    ans = []\n    count = [0] * (n + 1)\n\n    for a, b in zip(A, B):\n      count[a] += 1\n      if count[a] == 2:\n        prefixCommon += 1\n      count[b] += 1\n      if count[b] == 2:\n        prefixCommon += 1\n      ans.append(prefixCommon)\n\n    return ans",
      "title": "2657. Find the Prefix Common Array of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac4956bf-72f2-4ad8-9dd7-b1f6e291a62b",
      "code": "class Solution:\n  def findMaxFish(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n      caughtFish = grid[i][j]\n      grid[i][j] = 0  # Mark 0 as visited\n      return (caughtFish +\n              dfs(i + 1, j) + dfs(i - 1, j) +\n              dfs(i, j + 1) + dfs(i, j - 1))\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "2658. Maximum Number of Fish in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b0e32b6-8ef7-4791-9abe-e375142c838d",
      "code": "class Solution:\n  def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    nums.sort()\n\n    for i in range(1, n):\n      # On the i-th step we've already removed the i - 1 smallest numbers and\n      # can ignore them. If an element nums[i] has smaller index in origin\n      # array than nums[i - 1], we should rotate the whole left array n - i\n      # times to set nums[i] element on the first position.\n      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:\n        ans += n - i\n\n    return ans",
      "title": "2659. Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd9b8947-dfe5-417f-807b-21475416652c",
      "code": "class Solution:\n  def isWinner(self, player1: list[int], player2: list[int]) -> int:\n    def getScore(player: list[int]) -> int:\n      INVALID = -3\n      score = 0\n      last10 = INVALID\n      for i, p in enumerate(player):\n        score += p if i - last10 > 2 else p * 2\n        if p == 10:\n          last10 = i\n      return score\n\n    score1 = getScore(player1)\n    score2 = getScore(player2)\n    if score1 > score2:\n      return 1\n    if score2 > score1:\n      return 2\n    return 0",
      "title": "2660. Determine the Winner of a Bowling Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d227c82c-40eb-4d0c-a741-93689fffbdb1",
      "code": "class Solution:\n  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    # rows[i] := the number of painted grid in the i-th row\n    rows = [0] * m\n    # cols[j] := the number of painted grid in the j-th column\n    cols = [0] * n\n    # numToRow[num] := the i-th row of `num` in `mat`\n    numToRow = [0] * (m * n + 1)\n    # numToCol[num] := the j-th column of `num` in `mat`\n    numToCol = [0] * (m * n + 1)\n\n    for i, row in enumerate(mat):\n      for j, num in enumerate(row):\n        numToRow[num] = i\n        numToCol[num] = j\n\n    for i, a in enumerate(arr):\n      rows[numToRow[a]] += 1\n      if rows[numToRow[a]] == n:\n        return i\n      cols[numToCol[a]] += 1\n      if cols[numToCol[a]] == m:\n        return i",
      "title": "2661. First Completely Painted Row or Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1042c203-0bee-44a5-b11d-e8e95632819c",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      start: list[int],\n      target: list[int],\n      specialRoads: list[list[int]],\n  ) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(\n      self,\n      specialRoads: list[list[int]],\n      srcX: int,\n      srcY: int,\n      dstX: int,\n      dstY: int,\n  ) -> int:\n    n = len(specialRoads)\n    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)\n    dist = [math.inf] * n\n    minHeap = []  # (d, u), where u := the i-th specialRoads\n\n    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans",
      "title": "2662. Minimum Cost of a Path With Special Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc70234c-d6e7-423f-aeaf-c0f359ac4b11",
      "code": "class Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        # If s[i] is among the first k letters, then change the letters after\n        # s[i] to the smallest ones that don't form any palindrome substring.\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: list[str], i: int) -> bool:\n    \"\"\"Returns True if chars[0..i] contains palindrome.\"\"\"\n    return ((i > 0 and chars[i] == chars[i - 1]) or\n            (i > 1 and chars[i] == chars[i - 2]))\n\n  def _changeSuffix(self, chars: list[str], i: int) -> str:\n    \"\"\"\n    Returns a string, where replacing sb[i..n) with the smallest possible\n    letters don't form any palindrome substring.\n    \"\"\"\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)",
      "title": "2663. Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf3fdd2f-92b3-4b69-8f1f-3f03ec570227",
      "code": "class Solution:\n  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    ans = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, step: int) -> bool:\n      if step == m * n:\n        return True\n      if i < 0 or i >= m or j < 0 or j >= n:\n        return False\n      if ans[i][j] != -1:\n        return False\n      ans[i][j] = step\n      for dx, dy in DIRS:\n        if dfs(i + dx, j + dy, step + 1):\n          return True\n      ans[i][j] = -1\n      return False\n\n    dfs(r, c, 0)\n    return ans",
      "title": "2664. The Knight’s Tour",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c9f224c-707f-4dd2-af47-63ba8924efbc",
      "code": "class Solution:\n  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:\n    MAX = 50\n    ans = []\n    prefixCount = [0] * (MAX + 1)\n    suffixCount = [0] * (MAX + 1)\n    distinctPrefix = 0\n    distinctSuffix = 0\n\n    for num in nums:\n      if suffixCount[num] == 0:\n        distinctSuffix += 1\n      suffixCount[num] += 1\n\n    for num in nums:\n      if prefixCount[num] == 0:\n        distinctPrefix += 1\n      prefixCount[num] += 1\n      if suffixCount[num] == 1:\n        distinctSuffix -= 1\n      suffixCount[num] -= 1\n      ans.append(distinctPrefix - distinctSuffix)\n\n    return ans",
      "title": "2670. Find the Distinct Difference Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a371fe7b-d77f-496d-80b5-bc8e3cbb9651",
      "code": "class Solution:\n  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans",
      "title": "2672. Number of Adjacent Elements With the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3100005-6bd3-4c9a-8a3d-749971601271",
      "code": "class Solution:\n  def minIncrements(self, n: int, cost: list[int]) -> int:\n    ans = 0\n\n    for i in range(n // 2 - 1, -1, -1):\n      l = i * 2 + 1\n      r = i * 2 + 2\n      ans += abs(cost[l] - cost[r])\n      # Record the information in the parent from the children. So, there's need to actually\n      # update the values in the children.\n      cost[i] += max(cost[l], cost[r])\n\n    return ans",
      "title": "2673. Make Costs of Paths Equal in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f33d6a99-fa1f-4503-bba7-e5d4576784bd",
      "code": "class Solution:\n  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:\n    slow = list\n    fast = list\n\n    # Point `slow` to the last node in the first half.\n    while fast.next != list and fast.next.next != list:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Circle back the second half.\n    secondHead = slow.next\n    if fast.next == list:\n      fast.next = secondHead\n    else:\n      fast.next.next = secondHead\n\n    # Circle back the first half.\n    slow.next = list\n\n    return [list, secondHead]",
      "title": "2674. Split a Circular Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1b51078-e2a0-4ba9-a68b-6188aa3a3f85",
      "code": "class Solution:\n  def countSeniors(self, details: list[str]) -> int:\n    return sum(int(detail[11:13]) > 60 for detail in details)",
      "title": "2678. Number of Senior Citizens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "309c994b-ebd2-4e92-a5d2-91c00bf0d2f1",
      "code": "class Solution:\n  def matrixSum(self, nums: list[list[int]]) -> int:\n    for row in nums:\n      row.sort()\n\n    return sum(max(col) for col in zip(*nums))",
      "title": "2679. Sum in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b52400b5-b226-4675-8729-eca84511eca6",
      "code": "class Solution:\n  def maximumOr(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    prefix = [0] * n\n    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    suffix = [0] * n\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] | nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n      suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    # For each num, greedily shift it left by k bits.\n    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))",
      "title": "2680. Maximum OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81e1f067-7009-4cb8-ab3e-e81fcd4a46e8",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    summ = 0\n\n    for num in sorted(nums):\n      ans += (num + summ) * num**2\n      ans %= MOD\n      summ = (summ * 2 + num) % MOD\n\n    return ans",
      "title": "2681. Power of Heroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "704c29d5-9650-436e-bb03-b531a910129b",
      "code": "class Solution:\n  def circularGameLosers(self, n: int, k: int) -> list[int]:\n    seen = [False] * n\n    friendIndex = 0\n    turn = 1\n\n    while not seen[friendIndex]:\n      seen[friendIndex] = True\n      friendIndex += turn * k\n      friendIndex %= n\n      turn += 1\n\n    return [friendIndex + 1\n            for friendIndex in range(n)\n            if not seen[friendIndex]]",
      "title": "2682. Find the Losers of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e15dd9b0-7f66-4173-8b54-cb3c3b888dba",
      "code": "class Solution:\n  def doesValidArrayExist(self, derived: list[int]) -> bool:\n    return functools.reduce(operator.xor, derived) == 0",
      "title": "2683. Neighboring Bitwise XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3ac34aa-9760-4c8b-b873-68fce5629fb9",
      "code": "class Solution:\n  def maxMoves(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the maximum number of moves you can perform from (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))",
      "title": "2684. Maximum Number of Moves in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8d48bb3-12f1-4b81-b3b9-7d34651bb87c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans",
      "title": "2685. Count the Number of Complete Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd38f99b-fed7-4d87-a768-dfd55ec2ad6f",
      "code": "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    if root.len == 0:\n      return root.val[k - 1]\n    leftLen = (0 if not root.left\n               else max(root.left.len, len(root.left.val)))\n    if leftLen >= k:\n      return self.getKthCharacter(root.left, k)\n    return self.getKthCharacter(root.right, k - leftLen)",
      "title": "2689. Extract Kth Character From The Rope Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "262988f5-db45-4511-a811-c6e33f6a80f9",
      "code": "class Solution:\n  def minLength(self, s: str) -> int:\n    stack = []\n\n    def match(c: str) -> bool:\n      return stack and stack[-1] == c\n\n    for c in s:\n      if c == 'B' and match('A'):\n        stack.pop()\n      elif c == 'D' and match('C'):\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return len(stack)",
      "title": "2696. Minimum String Length After Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4388c8d6-af66-42fd-bdfb-d279b44c47ec",
      "code": "class Solution:\n  def makeSmallestPalindrome(self, s: str) -> str:\n    chars = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      minChar = min(chars[i], chars[j])\n      chars[i] = minChar\n      chars[j] = minChar\n      i += 1\n      j -= 1\n\n    return ''.join(chars)",
      "title": "2697. Lexicographically Smallest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8569342-7262-43b2-891d-3145758cda90",
      "code": "class Solution:\n  def punishmentNumber(self, n: int) -> int:\n    def isPossible(\n            accumulate: int, running: int, numChars: list[str],\n            s: int, target: int) -> bool:\n      \"\"\"\n      Returns True if the sum of any split of `numChars` equals to the target.\n      \"\"\"\n      if s == len(numChars):\n        return target == accumulate + running\n      d = int(numChars[s])\n      return (\n          # Keep growing `running`.\n          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or\n          # Start a new `running`.\n          isPossible(accumulate + running, d, numChars, s + 1, target)\n      )\n\n    return sum(i * i\n               for i in range(1, n + 1)\n               if isPossible(0, 0, str(i * i), 0, i))",
      "title": "2698. Find the Punishment Number of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "759f1ca0-13f1-4cdb-a505-4cd8f8e5db64",
      "code": "class Solution:\n  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:\n    MAX = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      # Change the weights of negative edges to an impossible value.\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = MAX\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        # Change the weights of negative edges to an impossible value.\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = MAX\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]",
      "title": "2699. Modify Graph Edge Weights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e9cfbb8-1441-43e0-a4f7-6f758df7556d",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int, y: int) -> int:\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if it's possible to make all `nums` <= 0 using m operations.\n      \"\"\"\n      # If we want m operations, first decrease all the numbers by y * m. Then\n      # we have m operations to select indices to decrease them by x - y.\n      return sum(max(0, math.ceil((num - y * m) / (x - y)))\n                 for num in nums) <= m\n\n    return bisect.bisect_left(range(max(nums)), True, key=isPossible)",
      "title": "2702. Minimum Operations to Make Numbers Non-positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c53bbd03-f1d3-4d29-bde6-2e3a93efeedd",
      "code": "class Solution:\n  def buyChoco(self, prices: list[int], money: int) -> int:\n    min1 = math.inf\n    min2 = math.inf\n\n    for price in prices:\n      if price <= min1:\n        min2 = min1\n        min1 = price\n      elif price < min2:\n        min2 = price\n\n    minCost = min1 + min2\n    return money if minCost > money else money - minCost",
      "title": "2706. Buy Two Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29554cc1-ae65-4b75-9af3-397887a0ca34",
      "code": "class Solution:\n  # Similar to 139. Word Break\n  def minExtraChar(self, s: str, dictionary: list[str]) -> int:\n    n = len(s)\n    dictionarySet = set(dictionary)\n    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    dp = [0] + [n] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        if s[j:i] in dictionarySet:\n          dp[i] = min(dp[i], dp[j])\n        else:\n          dp[i] = min(dp[i], dp[j] + i - j)\n\n    return dp[n]",
      "title": "2707. Extra Characters in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "227dd3da-8531-4812-8d52-eb9621759449",
      "code": "class Solution:\n  def maxStrength(self, nums: list[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:  # num == 0\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg",
      "title": "2708. Maximum Strength of a Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fef79b5-ab53-4e67-90fc-d57b8c2384e4",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: list[int]) -> bool:\n    n = len(nums)\n    mx = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(mx + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "2709. Greatest Common Divisor Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05d9b4df-12de-4aeb-8a27-02e16533584e",
      "code": "class Solution:\n  def removeTrailingZeros(self, num: str) -> str:\n    return num.rstrip('0')",
      "title": "2710. Remove Trailing Zeros From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6a89ac0-4855-41f1-aa2b-79e6896dc3db",
      "code": "class Solution:\n  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    def fillInDiagonal(i: int, j: int) -> None:\n      topLeft = set()\n      bottomRight = set()\n\n      # Fill in the diagonal from the top-left to the bottom-right.\n      while i < len(grid) and j < len(grid[0]):\n        ans[i][j] = len(topLeft)\n        # Post-addition, so this information can be utilized in subsequent cells.\n        topLeft.add(grid[i][j])\n        i += 1\n        j += 1\n\n      i -= 1\n      j -= 1\n\n      # Fill in the diagonal from the bottom-right to the top-left.\n      while i >= 0 and j >= 0:\n        ans[i][j] = abs(ans[i][j] - len(bottomRight))\n        # Post-addition, so this information can be utilized in subsequent cells.\n        bottomRight.add(grid[i][j])\n        i -= 1\n        j -= 1\n\n    for i in range(m):\n      fillInDiagonal(i, 0)\n\n    for j in range(1, n):\n      fillInDiagonal(0, j)\n\n    return ans",
      "title": "2711. Difference of Number of Distinct Values on Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a00ff24e-465e-4d92-ad52-0eed64e13b11",
      "code": "class Solution:\n  def minimumCost(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(1, n):\n      if s[i] != s[i - 1]:\n        # Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i)\n\n    return ans",
      "title": "2712. Minimum Cost to Make All Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f02b8794-402c-4431-b074-4610c976164b",
      "code": "class Solution:\n  def maxIncreasingCells(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m  # rows[i] := the maximum path length for the i-th row\n    cols = [0] * n  # cols[j] := the maximum path length for the j-th column\n    valToIndices = collections.defaultdict(list)\n    # maxPathLength[i][j] := the maximum path length from mat[i][j]\n    maxPathLength = [[0] * n for _ in range(m)]\n    # Sort all the unique values in the matrix in non-increasing order.\n    decreasingSet = set()\n\n    for i in range(m):\n      for j in range(n):\n        val = mat[i][j]\n        valToIndices[val].append((i, j))\n        decreasingSet.add(val)\n\n    for val in sorted(decreasingSet, reverse=True):\n      for i, j in valToIndices[val]:\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1\n      for i, j in valToIndices[val]:\n        rows[i] = max(rows[i], maxPathLength[i][j])\n        cols[j] = max(cols[j], maxPathLength[i][j])\n\n    return max(max(rows), max(cols))",
      "title": "2713. Maximum Strictly Increasing Cells in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c1f0ffb-f648-4afb-840d-06996ddca0cf",
      "code": "class Solution:\n  # Similar to 787. Cheapest Flights Within K Stops\n  def shortestPathWithHops(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      d: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, s, d, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]\n\n    dist[src][k] = 0\n    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)\n\n    while minHeap:\n      d, u, hops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if dist[u][hops] > d:\n        continue\n      for v, w in graph[u]:\n        # Go from u -> v with w cost.\n        if d + w < dist[v][hops]:\n          dist[v][hops] = d + w\n          heapq.heappush(minHeap, (dist[v][hops], v, hops))\n        # Hop from u -> v with 0 cost.\n        if hops > 0 and d < dist[v][hops - 1]:\n          dist[v][hops - 1] = d\n          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))",
      "title": "2714. Find Shortest Path with K Hops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "471a42dd-b260-4a9b-b73e-612df3ccfe2e",
      "code": "class Solution:\n  def minimizedStringLength(self, s: str) -> int:\n    return len({*s})",
      "title": "2716. Minimize String Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783c173c-3a42-4449-8e09-683b7c41ac8e",
      "code": "class Solution:\n  def semiOrderedPermutation(self, nums: list[int]) -> int:\n    n = len(nums)\n    index1 = nums.index(1)\n    indexN = nums.index(n)\n    return index1 + (n - 1 - indexN) - int(index1 > indexN)",
      "title": "2717. Semi-Ordered Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11b760f5-de02-4598-b81f-9bf0a04c44c6",
      "code": "class Solution:\n  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:\n    ans = 0\n    # seen[0] := row, seen[1] := col\n    seen = [[False] * n for _ in range(2)]\n    # notSet[0] = row, notSet[1] := col\n    notSet = [n] * 2\n\n    # Late queries dominate.\n    for type, index, val in reversed(queries):\n      if not seen[type][index]:\n        ans += val * notSet[type ^ 1]\n        seen[type][index] = True\n        notSet[type] -= 1\n\n    return ans",
      "title": "2718. Sum of Matrix After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87d8aca3-0af5-4463-be66-43759bba2f0e",
      "code": "# Definition for a street.\n# class Street:\n#   def openDoor(self):\n#     pass\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\n#   def moveLeft(self):\n#     pass\n\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    for _ in range(k):\n      if street.isDoorOpen():\n        street.closeDoor()\n      street.moveRight()\n\n    for ans in range(k + 1):\n      if street.isDoorOpen():\n        return ans\n      street.openDoor()\n      street.moveRight()",
      "title": "2728. Count Houses in a Circular Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "912ae7a9-9d75-466d-9533-5114ea7599c3",
      "code": "class Solution:\n  def isFascinating(self, n):\n    s = str(n) + str(2 * n) + str(3 * n)\n    return ''.join(sorted(s)) == '123456789'",
      "title": "2729. Check if The Number is Fascinating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13f6191e-db97-4d3b-a257-c1713dc9f364",
      "code": "class Solution:\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\n    ans = 1\n    prevStart = 0\n    start = 0\n\n    for i in range(1, len(s)):\n      if s[i] == s[i - 1]:\n        if prevStart > 0:\n          start = prevStart\n        prevStart = i\n      ans = max(ans, i - start + 1)\n\n    return ans",
      "title": "2730. Find the Longest Semi-Repetitive Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a4c6473-2ee5-4d2b-9c7e-ba69fad38a54",
      "code": "class Solution:\n  def sumDistance(self, nums: list[int], s: str, d: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    pos = sorted([num - d if c == 'L' else num + d\n                  for num, c in zip(nums, s)])\n\n    for i, p in enumerate(pos):\n      ans = ((ans + i * p - prefix) % MOD + MOD) % MOD\n      prefix = ((prefix + p) % MOD + MOD) % MOD\n\n    return ans",
      "title": "2731. Movement of Robots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5897949-5fb6-4708-a94f-af8127aac80a",
      "code": "class Solution:\n  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:\n    MAX_BIT = 30\n    maskToIndex = {}\n\n    def getMask(row: list[int]) -> int:\n      mask = 0\n      for i, num in enumerate(row):\n        if num == 1:\n          mask |= 1 << i\n      return mask\n\n    for i, row in enumerate(grid):\n      mask = getMask(row)\n      if mask == 0:\n        return [i]\n      for prevMask in range(1, MAX_BIT):\n        if (mask & prevMask) == 0 and prevMask in maskToIndex:\n          return [maskToIndex[prevMask], i]\n      maskToIndex[mask] = i\n\n    return []",
      "title": "2732. Find a Good Subset of the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ba26e32-4557-4cee-9afd-caf4ee38ac30",
      "code": "class Solution:\n  def findNonMinOrMax(self, nums: list[int]) -> int:\n    return -1 if len(nums) < 3 else sorted(nums[:3])[1]",
      "title": "2733. Neither Minimum nor Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b50705b-0a98-4d6c-bd9e-bce196c1e0ae",
      "code": "class Solution:\n  def smallestString(self, s: str) -> str:\n    chars = list(s)\n    n = len(s)\n    i = 0\n\n    while i < n and chars[i] == 'a':\n      i += 1\n    if i == n:\n      chars[-1] = 'z'\n      return ''.join(chars)\n\n    while i < n and s[i] != 'a':\n      chars[i] = chr(ord(chars[i]) - 1)\n      i += 1\n\n    return ''.join(chars)",
      "title": "2734. Lexicographically Smallest String After Substring Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de84a887-7c77-4bcf-b8cc-f020223aa417",
      "code": "class Solution:\n  def minCost(self, nums: list[int], x: int) -> int:\n    n = len(nums)\n    ans = math.inf\n    # minCost[i] := the minimum cost to collect the i-th type\n    minCost = [math.inf] * n\n\n    for rotate in range(n):\n      for i in range(n):\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])\n      ans = min(ans, sum(minCost) + rotate * x)\n\n    return ans",
      "title": "2735. Collecting Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f857506a-e870-45aa-b6a9-354a3f86d3ed",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Pair:\n  x: int\n  y: int\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  minX: int\n  minY: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])\n                                          for i, query in enumerate(queries)],\n                                         key=lambda x: -x.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        # x + y is a better candidate. Given that x is decreasing, the\n        # condition \"x + y >= stack[-1][1]\" suggests that y is relatively\n        # larger, thereby making it a better candidate.\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2736. Maximum Sum Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25daff53-3abb-4ca6-bf33-940e3270411a",
      "code": "class Solution:\n  def minimumDistance(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      marked: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    dist = self._dijkstra(graph, s)\n    ans = min(dist[u] for u in marked)\n    return -1 if ans == math.inf else ans\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2737. Find the Closest Marked Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d230be3-90e9-499b-8be8-26eadc6d3f08",
      "code": "class Solution:\n  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n    # M  M M M M  A  M M M M   A\n    # 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10",
      "title": "2739. Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0eab9925-8338-43b8-b7a7-0526453abc3f",
      "code": "class Solution:\n  def findValueOfPartition(self, nums: list[int]) -> int:\n    return min(b - a for a, b in itertools.pairwise(sorted(nums)))",
      "title": "2740. Find the Value of the Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bd06a37-4db9-43ad-bb95-712cf67c1050",
      "code": "class Solution:\n  def specialPerm(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxMask = 1 << len(nums)\n\n    @functools.lru_cache(None)\n    def dp(prev: int, mask: int) -> int:\n      \"\"\"\n      Returns the number of special permutations, where the previous number is\n      nums[i] and `mask` is the bitmask of the used numbers.\n      \"\"\"\n      if mask == maxMask - 1:\n        return 1\n\n      res = 0\n\n      for i, num in enumerate(nums):\n        if mask >> i & 1:\n          continue\n        if num % nums[prev] == 0 or nums[prev] % num == 0:\n          res += dp(i, mask | 1 << i)\n          res %= MOD\n\n      return res\n\n    return sum(dp(i, 1 << i)\n               for i in range(len(nums))) % MOD",
      "title": "2741. Special Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8182c225-d394-44e5-b3d4-e93e5a54b67f",
      "code": "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    n = len(cost)\n\n    @functools.lru_cache(None)\n    def dp(i: int, walls: int) -> int:\n      \"\"\"Returns the minimum cost to paint j walls by painters[i..n).\"\"\"\n      if walls <= 0:\n        return 0\n      if i == n:\n        return math.inf\n      pick = cost[i] + dp(i + 1, walls - time[i] - 1)\n      skip = dp(i + 1, walls)\n      return min(pick, skip)\n\n    return dp(0, n)",
      "title": "2742. Painting the Walls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eca1065-2b72-450b-b089-d395194bd1d4",
      "code": "class Solution:\n  def numberOfSpecialSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == 2:\n        count[s[l]] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2743. Count Substrings Without Repeating Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1a46844-1336-4d9e-8f00-6435144e6576",
      "code": "class Solution:\n  def maximumNumberOfStringPairs(self, words: list[str]) -> int:\n    ans = 0\n    seen = [False] * (26 * 26)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for word in words:\n      if seen[val(word[1]) * 26 + val(word[0])]:\n        ans += 1\n      seen[val(word[0]) * 26 + val(word[1])] = True\n\n    return ans",
      "title": "2744. Find Maximum Number of String Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "839d6219-0e06-48b3-bbf5-568edd34d907",
      "code": "class Solution:\n  def longestString(self, x: int, y: int, z: int) -> int:\n    # 'AB' can always be easily appended within the string.\n    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'\n    # If x == y, we repeat the pattern 'AABBAABB...AABB'.\n    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'\n    mn = min(x, y)\n    if x == y:\n      return (mn * 2 + z) * 2\n    return (mn * 2 + 1 + z) * 2",
      "title": "2745. Construct the Longest New String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2b36ee8-f444-4ad9-ac40-ddf657b89bc0",
      "code": "class Solution:\n  def minimizeConcatenatedLength(self, words: list[str]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, first: str, last: str) -> int:\n      \"\"\"\n      Returns the minimum concatenated length of the first i words starting with\n      `first` and ending in `last`.\n      \"\"\"\n      if i == len(words):\n        return 0\n      nextFirst = words[i][0]\n      nextLast = words[i][-1]\n      return len(words[i]) + min(\n          # join(words[i - 1], words[i])\n          dp(i + 1, first, nextLast) - (last == nextFirst),\n          # join(words[i], words[i - 1])\n          dp(i + 1, nextFirst, last) - (first == nextLast)\n      )\n\n    return len(words[0]) + dp(1, words[0][0], words[0][-1])",
      "title": "2746. Decremental String Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa0ec134-86c4-45c2-adf3-5756fc92ce58",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(\n      self,\n      n: int,\n      logs: list[list[int]],\n      x: int,\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda x: x[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    # For each query, we care about logs[i..j].\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans",
      "title": "2747. Count Zero Request Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76ba1fdd-58e9-4431-b021-36a46807fd1d",
      "code": "class Solution:\n  def countBeautifulPairs(self, nums: list[int]) -> int:\n    def firstDigit(num: int) -> int:\n      return int(str(num)[0])\n\n    def lastDigit(num: int) -> int:\n      return num % 10\n\n    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1\n               for i, j in itertools.combinations(range(len(nums)), 2))",
      "title": "2748. Number of Beautiful Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8d182f7-3ecb-4aaf-a2f8-7c1180d39cfa",
      "code": "class Solution:\n  def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    # Note that for any number x, we can use \"x's bit count\" operations to make\n    # x equal to 0. Additionally, we can also use x operations to deduct x by\n    # 2^0 (x times), which also results in 0.\n\n    for ops in range(61):\n      target = num1 - ops * num2\n      if target.bit_count() <= ops <= target:\n        return ops\n\n    return -1",
      "title": "2749. Minimum Operations to Make the Integer Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3e66fa9-3672-4ebb-b521-c6ada6e71178",
      "code": "class Solution:\n  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:\n    if 1 not in nums:\n      return 0\n\n    MOD = 1_000_000_007\n    prev = -1  # the previous index of 1\n    ans = 1\n\n    for i, num in enumerate(nums):\n      if num == 1:\n        if prev != -1:\n          ans *= i - prev\n          ans %= MOD\n        prev = i\n\n    return ans",
      "title": "2750. Ways to Split Array Into Good Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd10d4a6-9f25-4065-b0e9-5302a5556fba",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(\n      self,\n      positions: list[int],\n      healths: list[int],\n      directions: str,\n  ) -> list[int]:\n    robots = sorted([Robot(index, position, health, direction)\n                     for index, (position, health, direction) in\n                     enumerate(zip(positions, healths, directions))],\n                    key=lambda x: x.position)\n    stack: list[Robot] = []  # running robots\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      # Collide with robots going right if any.\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:  # stack[-1].health > robot.health\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]",
      "title": "2751. Robot Collisions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0510db85-f8bf-48fe-86ab-9843e292769e",
      "code": "# Definition for a street.\n# class Street:\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    ans = 0\n\n    # Go to the first open door.\n    while not street.isDoorOpen():\n      street.moveRight()\n\n    street.moveRight()\n\n    for count in range(k):\n      # Each time we encounter an open door, there's a possibility that it's the\n      # first open door we intentionally left open.\n      if street.isDoorOpen():\n        ans = count + 1\n        street.closeDoor()\n      street.moveRight()\n\n    return ans",
      "title": "2753. Count Houses in a Circular Street II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c58790-28ce-4d0c-854c-bdf6f09afaa9",
      "code": "class Solution:\n  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:\n    ans = 0\n    dp = 0\n\n    def isOddEven(a: int, b: int) -> bool:\n      return a % 2 != b % 2\n\n    for i, num in enumerate(nums):\n      if num > threshold:\n        dp = 0\n      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):\n        # Increase the size of the subarray.\n        dp += 1\n      else:\n        # Start a new subarray if the start is valid.\n        dp = 1 if num % 2 == 0 else 0\n      ans = max(ans, dp)\n\n    return ans",
      "title": "2760. Longest Even Odd Subarray With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1247b562-c216-49e1-b38f-b3cd3a22a7ca",
      "code": "class Solution:\n  def findPrimePairs(self, n: int) -> list[list[int]]:\n    isPrime = self._sieveEratosthenes(n + 1)\n    return [[i, n - i] for i in range(2, n // 2 + 1)\n            if isPrime[i] and isPrime[n - i]]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n\n\nj",
      "title": "2761. Prime Pairs With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56a333a2-1539-4d13-956c-9cfb528cb077",
      "code": "class Solution:\n  def continuousSubarrays(self, nums: list[int]) -> int:\n    ans = 1  # [nums[0]]\n    left = nums[0] - 2\n    right = nums[0] + 2\n    l = 0\n\n    # nums[l..r] is a valid window.\n    for r in range(1, len(nums)):\n      if left <= nums[r] <= right:\n        left = max(left, nums[r] - 2)\n        right = min(right, nums[r] + 2)\n      else:\n        # nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2\n        right = nums[r] + 2\n        l = r\n        # If we consistently move leftward in each iteration, it implies that\n        # the entire left subarray satisfies the given condition. For every\n        # subarray with l in the range [0, r], the condition is met, preventing\n        # the code from reaching the final \"else\" condition. Instead, it stops\n        # at the \"if\" condition.\n        while nums[r] - 2 <= nums[l] <= nums[r] + 2:\n          left = max(left, nums[l] - 2)\n          right = min(right, nums[l] + 2)\n          l -= 1\n        l += 1\n      # nums[l..r], num[l + 1..r], ..., nums[r]\n      ans += r - l + 1\n\n    return ans",
      "title": "2762. Continuous Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1612290-5b62-44a6-9b3f-d6c5b602411d",
      "code": "class Solution:\n  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  # of determining the number of gaps in each subarray, let's find out how many\n  # subarrays contain each gap.\n  def sumImbalanceNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # Note that to avoid double counting, only `left` needs to check nums[i].\n    # This adjustment ensures that i represents the position of the leftmost\n    # element of nums[i] within the subarray.\n\n    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    left = [0] * n\n    # right[i] := the minimum index r s.t. nums[r] = nums[i]\n    right = [0] * n\n\n    numToIndex = [-1] * (n + 2)\n    for i, num in enumerate(nums):\n      left[i] = max(numToIndex[num], numToIndex[num + 1])\n      numToIndex[num] = i\n\n    numToIndex = [n] * (n + 2)\n    for i in range(n - 1, -1, -1):\n      right[i] = numToIndex[nums[i] + 1]\n      numToIndex[nums[i]] = i\n\n    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    # subarrays satisfying this condition.\n    #\n    # Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    # initially assumed to have a gap. This adjustment is necessary as the\n    # maximum element of every subarray does not have a gap.\n    return sum((i - left[i]) * (right[i] - i)\n               for i in range(n)) - n * (n + 1) // 2",
      "title": "2763. Sum of Imbalance Numbers of All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5967a494-621b-49c9-91e8-1994515e9aee",
      "code": "class Solution:\n  def isPreorder(self, nodes: list[list[int]]) -> bool:\n    stack = []  # Stores `id`s.\n\n    for id, parentId in nodes:\n      if parentId == -1:\n        stack.append(id)\n        continue\n      while stack and stack[-1] != parentId:\n        stack.pop()\n      if not stack:\n        return False\n      stack.append(id)\n\n    return True",
      "title": "2764. is Array a Preorder of Some ‌Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33296f5f-86fb-4eb4-b9de-6751c3b74925",
      "code": "class Solution:\n  def alternatingSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    dp = 1\n\n    for i in range(1, len(nums)):\n      targetDiff = -1 if dp % 2 == 0 else 1\n      # Append nums[i] to the current alternating subarray.\n      if nums[i] - nums[i - 1] == targetDiff:\n        dp += 1\n      # Reset the alternating subarray to nums[i - 1..i].\n      elif nums[i] - nums[i - 1] == 1:\n        dp = 2\n      # Reset the alternating subarray to nums[i].\n      else:\n        dp = 1\n      ans = max(ans, dp)\n\n    return -1 if ans == 1 else ans",
      "title": "2765. Longest Alternating Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6932b6d-cde6-4b2d-a50c-1b93e2aac7bd",
      "code": "class Solution:\n  def relocateMarbles(\n      self,\n      nums: list[int],\n      moveFrom: list[int],\n      moveTo: list[int],\n  ) -> list[int]:\n    numsSet = set(nums)\n\n    for f, t in zip(moveFrom, moveTo):\n      numsSet.remove(f)\n      numsSet.add(t)\n\n    return sorted(numsSet)",
      "title": "2766. Relocate Marbles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6084c6ec-dc9d-4e83-9bf1-57aaa9c3651b",
      "code": "class Solution:\n  def minimumBeautifulSubstrings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of beautiful substrings for the first i chars\n    dp = [0] + [n + 1] * n\n\n    for i in range(1, n + 1):\n      if s[i - 1] == '0':\n        continue\n      num = 0  # the number of s[i - 1..j - 1]\n      for j in range(i, n + 1):\n        num = (num << 1) + int(s[j - 1])\n        if self._isPowerOfFive(num):\n          dp[j] = min(dp[j], dp[i - 1] + 1)\n\n    return -1 if dp[n] == n + 1 else dp[n]\n\n  def _isPowerOfFive(self, num: int) -> bool:\n    while num % 5 == 0:\n      num //= 5\n    return num == 1",
      "title": "2767. Partition String Into Minimum Beautiful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "597d19a3-4e0f-4c77-a2fc-890418e2df59",
      "code": "class Solution:\n  def countBlackBlocks(\n      self,\n      m: int,\n      n: int,\n      coordinates: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * 5\n    # count[i * n + j] := the number of black cells in\n    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    count = collections.Counter()\n\n    for x, y in coordinates:\n      for i in range(x, x + 2):\n        for j in range(y, y + 2):\n          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          # current black cell (x, y).\n          if 0 < i < m and 0 < j < n:\n            count[(i, j)] += 1\n\n    for freq in count.values():\n      ans[freq] += 1\n\n    ans[0] = (m - 1) * (n - 1) - sum(ans)\n    return ans",
      "title": "2768. Number of Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b645090-d9e6-499d-a4fe-0f7c8b712477",
      "code": "class Solution:\n  def theMaximumAchievableX(self, num: int, t: int) -> int:\n    return num + 2 * t",
      "title": "2769. Find the Maximum Achievable Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58e26441-693a-4abb-8699-89d7c0cc0821",
      "code": "class Solution:\n  def maximumJumps(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i] := the maximum number of jumps to reach i from 0\n    dp = [-1] * n\n    dp[0] = 0\n\n    for j in range(1, n):\n      for i in range(j):\n        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:\n          dp[j] = max(dp[j], dp[i] + 1)\n\n    return dp[-1]",
      "title": "2770. Maximum Number of Jumps to Reach the Last Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfde550d-1c6f-4e24-a659-524e077bea0e",
      "code": "class Solution:\n  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 1\n    dp1 = 1  # the longest subarray that ends in nums1[i] so far\n    dp2 = 1  # the longest subarray that ends in nums2[i] so far\n\n    for i in range(1, len(nums1)):\n      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1\n      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1\n      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1\n      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1\n      dp1 = max(dp11, dp21)\n      dp2 = max(dp12, dp22)\n      ans = max(ans, dp1, dp2)\n\n    return ans",
      "title": "2771. Longest Non-decreasing Subarray From Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a54f532-b24a-4cfa-9109-fc54a65e9bd9",
      "code": "class Solution:\n  def checkArray(self, nums: list[int], k: int) -> bool:\n    if k == 1:\n      return True\n\n    needDecrease = 0\n    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if i >= k:\n        needDecrease -= dq.popleft()\n      if nums[i] < needDecrease:\n        return False\n      decreasedNum = nums[i] - needDecrease\n      dq.append(decreasedNum)\n      needDecrease += decreasedNum\n\n    return dq[-1] == 0",
      "title": "2772. Apply Operations to Make All Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e4ad3c2-8e25-4298-a549-d03c959f7622",
      "code": "class Solution:\n  def heightOfTree(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    # a leaf node\n    if root.left and root.left.right == root:\n      return 0\n    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))",
      "title": "2773. Height of Special Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7169e373-35ad-4043-aff7-e043ed27c32e",
      "code": "class Solution:\n  def sumOfSquares(self, nums: list[int]) -> int:\n    return sum(num**2 for i, num in enumerate(nums)\n               if len(nums) % (i + 1) == 0)",
      "title": "2778. Sum of Squares of Special Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "453bda86-01d9-4d4a-875d-ed9aaaef9a23",
      "code": "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r in range(len(nums)):\n      if nums[r] - nums[l] > 2 * k:\n        l += 1\n\n    return r - l + 1",
      "title": "2779. Maximum Beauty of an Array After Applying Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72ad6083-bf89-442f-b498-9aa1bcdaa7c3",
      "code": "class Solution:\n  def minimumIndex(self, nums: list[int]) -> int:\n    count1 = collections.Counter()\n    count2 = collections.Counter(nums)\n\n    for i, num in enumerate(nums):\n      count1[num] = count1[num] + 1\n      count2[num] = count2[num] - 1\n      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:\n        return i\n\n    return -1",
      "title": "2780. Minimum Index of a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9b8f216-3a64-4fe1-bf4b-d9c67302a9e6",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str, l: int, r: int) -> bool:\n    node: TrieNode = self.root\n    for i in range(l, r):\n      if word[i] not in node.children:\n        return False\n      node = node.children[word[i]]\n    return node.isWord\n\n\nclass Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    ans = 0\n    trie = Trie()\n\n    for s in forbidden:\n      trie.insert(s)\n\n    # r is the rightmost index to make word[l..r] a valid substring.\n    r = len(word) - 1\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if trie.search(word, l, end + 1):\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2781. Length of the Longest Valid Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8446f2a-4413-483d-b475-613b1cbaf378",
      "code": "# Definition for a category handler.\n# class CategoryHandler:\n#   def haveSameCategory(self, a: int, b: int) -> bool:\n#     pass\n\nclass Solution:\n  def numberOfCategories(\n      self,\n      n: int,\n      categoryHandler: Optional['CategoryHandler'],\n  ) -> int:\n    ans = 0\n\n    for i in range(n):\n      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):\n        ans += 1\n\n    return ans",
      "title": "2782. Number of Unique Categories",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25ab0470-66da-4c3a-a4c3-8104ac3a81bc",
      "code": "class Solution:\n  def isGood(self, nums: list[int]) -> bool:\n    n = len(nums) - 1\n    count = collections.Counter(nums)\n    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2",
      "title": "2784. Check if Array is Good",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8faec08a-61f7-4733-96e6-7e120cc3b9f8",
      "code": "class Solution:\n  def sortVowels(self, s: str) -> str:\n    VOWELS = 'aeiouAEIOU'\n    ans = []\n    vowels = sorted([c for c in s if c in VOWELS])\n\n    i = 0  # vowels' index\n    for c in s:\n      if c in VOWELS:\n        ans.append(vowels[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "2785. Sort Vowels in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7801ebcd-d5b0-4ea4-b3f7-48b60acddbd2",
      "code": "class Solution:\n  def maxScore(self, nums: list[int], x: int) -> int:\n    # Note that we always need to take nums[0], so the initial definition might\n    # not hold true.\n\n    # dp0 := the maximum score so far with `nums` ending in an even number\n    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)\n    # dp0 := the maximum score so far with `nums` ending in an odd number\n    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)\n\n    for i in range(1, len(nums)):\n      if nums[i] % 2 == 0:\n        dp0 = nums[i] + max(dp0, dp1 - x)\n      else:\n        dp1 = nums[i] + max(dp1, dp0 - x)\n\n    return max(dp0, dp1)",
      "title": "2786. Visit Array Positions to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "155c646e-9495-4844-88aa-b1227524afa7",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to express i\n    dp = [1] + [0] * n\n\n    for a in range(1, n + 1):\n      ax = a**x\n      if ax > n:\n        break\n      for i in range(n, ax - 1, -1):\n        dp[i] += dp[i - ax]\n        dp[i] %= MOD\n\n    return dp[n]",
      "title": "2787. Ways to Express an Integer as Sum of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3c7b057-d63b-4f45-83bf-e02adeda6363",
      "code": "class Solution:\n  def splitWordsBySeparator(\n      self,\n      words: list[str],\n      separator: str,\n  ) -> list[str]:\n    return [splitWord\n            for word in words\n            for splitWord in word.split(separator)\n            if splitWord]",
      "title": "2788. Split Strings by Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8808e9f4-a646-45bf-b089-3c5f361c187b",
      "code": "class Solution:\n  def maxArrayValue(self, nums: list[int]) -> int:\n    ans = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > ans:\n        ans = nums[i]\n      else:\n        ans += nums[i]\n\n    return ans",
      "title": "2789. Largest Element in an Array after Merge Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07839955-fa4b-4613-9811-27a5f012ab92",
      "code": "class Solution:\n  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:\n    ans = 1  # the next target length\n    availableLimits = 0\n\n    for usageLimit in sorted(usageLimits):\n      availableLimits += usageLimit\n      # Can create groups 1, 2, ..., ans.\n      if availableLimits >= ans * (ans + 1) // 2:\n        ans += 1\n\n    return ans - 1",
      "title": "2790. Maximum Number of Groups With Increasing Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "781c2715-8926-4ea5-b955-b07ea5c2886b",
      "code": "class Solution:\n  def countPalindromePaths(self, parent: list[int], s: str) -> int:\n    # A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    # frequency of a letter on the u-v path is equal to the sum of its\n    # frequencies on the root-u and root-v paths substract twice of its\n    # frequency on the root-LCA(u, v) path. Considering only the parity\n    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    # possible to calculate both parts easily using a simple DFS.\n    tree = [[] for _ in parent]\n    maskToCount = collections.Counter({0: 1})\n\n    for i in range(1, len(parent)):\n      tree[parent[i]].append(i)\n\n    # mask := 26 bits that represent the parity of each character in the alphabet\n    # on the path from node 0 to node u\n    def dfs(u: int, mask: int) -> int:\n      res = 0\n      if u > 0:\n        mask ^= 1 << (ord(s[u]) - ord('a'))\n        # Consider any u-v path with 1 bit set.\n        for i in range(26):\n          res += maskToCount[mask ^ (1 << i)]\n        # Consider u-v path with 0 bit set.\n        res += maskToCount[mask ^ 0]\n        maskToCount[mask] += 1\n      for v in tree[u]:\n        res += dfs(v, mask)\n      return res\n\n    return dfs(0, 0)",
      "title": "2791. Count Paths That Can Form a Palindrome in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1acb7990-97aa-4add-8c81-770dd7dc62bd",
      "code": "class Solution:\n  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> list[int]:\n      nonlocal ans\n      if not root:\n        return []\n\n      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]\n      if len(kSmallest) == k and root.val > kSmallest[-1]:\n        ans += 1\n\n      return kSmallest + [root.val]\n\n    dfs(root)\n    return ans",
      "title": "2792. Count Nodes That Are Great Enough",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bfcf984-3c33-49c6-93e3-eb65a4392e9c",
      "code": "class Solution:\n  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:\n    return sum(hour >= target for hour in hours)",
      "title": "2798. Number of Employees Who Met the Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f95343f2-c621-443c-a520-14c7f7814194",
      "code": "class Solution:\n  def countCompleteSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    distinct = len(set(nums))\n    count = collections.Counter()\n\n    l = 0\n    for num in nums:\n      count[num] += 1\n      while len(count) == distinct:\n        count[nums[l]] -= 1\n        if count[nums[l]] == 0:\n          del count[nums[l]]\n        l += 1\n      # Assume nums[r] = num,\n      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l\n\n    return ans",
      "title": "2799. Count Complete Subarrays in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0bfbb39-18bf-4a68-bd11-b34a341dc369",
      "code": "class Solution:\n  def minimumString(self, a: str, b: str, c: str) -> str:\n    def merge(a: str, b: str) -> str:\n      \"\"\"Merges a and b.\"\"\"\n      if a in b:  # a is a substring of b.\n        return b\n      for i in range(len(a)):\n        aSuffix = a[i:]\n        bPrefix = b[:len(aSuffix)]\n        if aSuffix == bPrefix:\n          return a + b[len(bPrefix):]\n      return a + b\n\n    abc = merge(a, merge(b, c))\n    acb = merge(a, merge(c, b))\n    bac = merge(b, merge(a, c))\n    bca = merge(b, merge(c, a))\n    cab = merge(c, merge(a, b))\n    cba = merge(c, merge(b, a))\n    return self._getMin([abc, acb, bac, bca, cab, cba])\n\n  def _getMin(self, words: list[str]) -> str:\n    \"\"\"Returns the lexicographically smallest string.\"\"\"\n\n    def getMin(a: str, b: str) -> str:\n      \"\"\"Returns the lexicographically smaller string.\"\"\"\n      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b\n\n    res = words[0]\n    for i in range(1, len(words)):\n      res = getMin(res, words[i])\n    return res",
      "title": "2800. Shortest String That Contains Three Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "347fadd5-5180-4b82-88e0-5b8c27eb3f99",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: str, high: str) -> int:\n    MOD = 1_000_000_007\n    low = '0' * (len(high) - len(low)) + low\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        prevDigit: int,\n        isLeadingZero: bool,\n        tight1: bool,\n        tight2: bool,\n    ) -> int:\n      \"\"\"\n      Returns the number of valid integers, considering the i-th digit, where\n      `prevDigit` is the previous digit, `tight1` indicates if the current\n      digit is tightly bound for `low`, and `tight2` indicates if the current\n      digit is tightly bound for `high`.\n      \"\"\"\n      if i == len(high):\n        return 1\n\n      res = 0\n      minDigit = int(low[i]) if tight1 else 0\n      maxDigit = int(high[i]) if tight2 else 9\n\n      for d in range(minDigit, maxDigit + 1):\n        nextTight1 = tight1 and (d == minDigit)\n        nextTight2 = tight2 and (d == maxDigit)\n        if isLeadingZero:\n          # Can place any digit in [minDigit, maxDigit].\n          res += dp(i + 1, d, isLeadingZero and d ==\n                    0, nextTight1, nextTight2)\n        elif abs(d - prevDigit) == 1:\n          res += dp(i + 1, d, False, nextTight1, nextTight2)\n        res %= MOD\n\n      return res\n\n    return dp(0, -1, True, True, True)",
      "title": "2801. Count Stepping Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd5f7f8f-d0d0-4e5a-9cdb-a18789e913f6",
      "code": "class Solution:\n  def kthLuckyNumber(self, k: int) -> str:\n    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')",
      "title": "2802. Find The K-th Lucky Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5da9c1f-4399-4a2a-9342-14dc08762fe0",
      "code": "class Solution:\n  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n    return 100 - ((purchaseAmount + 5) // 10) * 10",
      "title": "2806. Account Balance After Rounded Purchase",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbb3237d-efb9-4028-adef-498794176f61",
      "code": "class Solution:\n  def insertGreatestCommonDivisors(\n      self, head: ListNode | None\n  ) -> ListNode | None:\n    curr = head\n    while curr.next:\n      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)\n      curr.next = inserted\n      curr = inserted.next\n    return head",
      "title": "2807. Insert Greatest Common Divisors in Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a0caf0d-9939-433b-a400-474b360e9c95",
      "code": "class Solution:\n  def minimumSeconds(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    def getSeconds(i: int, j: int) -> int:\n      \"\"\"Returns the number of seconds required to make nums[i..j] the same.\"\"\"\n      return (i - j) // 2\n\n    for indices in numToIndices.values():\n      seconds = getSeconds(indices[0] + n, indices[-1])\n      for i in range(1, len(indices)):\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))\n      ans = min(ans, seconds)\n\n    return ans",
      "title": "2808. Minimum Seconds to Equalize a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf884d3a-ad50-463b-9e8d-36ebbfeaddb9",
      "code": "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[i][j] := the maximum reduced value if we do j operations on the first\n    # i numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(1, i + 1):\n        dp[i][j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[i - 1][j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[i - 1][j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[n][op] <= x:\n        return op\n\n    return -1",
      "title": "2809. Minimum Time to Make Array Sum At Most x",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f98ba25-3e0e-48e9-b80b-62d7c4e522cc",
      "code": "class Solution:\n  def finalString(self, s: str) -> str:\n    dq = collections.deque()\n    inversed = False\n\n    for c in s:\n      if c == 'i':\n        inversed = not inversed\n      elif inversed:\n        dq.appendleft(c)\n      else:\n        dq.append(c)\n\n    return ''.join(reversed(dq)) if inversed else ''.join(dq)",
      "title": "2810. Faulty Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a24c3caf-7535-4a68-97f1-4dc1eea54be3",
      "code": "class Solution:\n  def canSplitArray(self, nums: list[int], m: int) -> bool:\n    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))",
      "title": "2811. Check if it is Possible to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b065889-3034-4901-9870-c229f47fd8e5",
      "code": "class Solution:\n  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True,\n                              key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief",
      "title": "2812. Find the Safest Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14a6e8ea-f24b-460c-9332-854f61439738",
      "code": "class Solution:\n  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:\n    ans = 0\n    totalProfit = 0\n    seenCategories = set()\n    decreasingDuplicateProfits = []\n\n    items.sort(reverse=True)\n\n    for i in range(k):\n      profit, category = items[i]\n      totalProfit += profit\n      if category in seenCategories:\n        decreasingDuplicateProfits.append(profit)\n      else:\n        seenCategories.add(category)\n\n    ans = totalProfit + len(seenCategories)**2\n\n    for i in range(k, len(items)):\n      profit, category = items[i]\n      if category not in seenCategories and decreasingDuplicateProfits:\n        # If this is a new category we haven't seen before, it's worth\n        # considering taking it and replacing the one with the least profit\n        # since it will increase the distinct_categories and potentially result\n        # in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.pop()\n        totalProfit += profit\n        seenCategories.add(category)\n        ans = max(ans, totalProfit + len(seenCategories)**2)\n\n    return ans",
      "title": "2813. Maximum Elegance of a K-Length Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3cd1522-f3df-4092-931f-606b1f094e26",
      "code": "class Solution:\n  def minimumSeconds(self, land: list[list[str]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(land)\n    n = len(land[0])\n    floodDist = self._getFloodDist(land)\n    startPos = self._getStartPos(land, 'S')\n\n    q = collections.deque([startPos])\n    seen = {startPos}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] == 'D':\n            return step\n          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n\n  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:\n    m = len(land)\n    n = len(land[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    q = collections.deque()\n    seen = set()\n\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          q.append((i, j))\n          seen.add((i, j))\n\n    d = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        dist[i][j] = d\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] in 'XD' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      d += 1\n\n    return dist\n\n  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == c:\n          return i, j",
      "title": "2814. Minimum Time Takes to Reach Destination Without Drowning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fdb3cf5-f3ae-4bf0-8337-c8bd0204a095",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    ans = 0\n    # maxNum[i] := the maximum num we met so far with the maximum digit i\n    maxNum = [0] * 10\n\n    def getMaxDigit(num: int) -> int:\n      maxDigit = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        num //= 10\n      return maxDigit\n\n    for num in nums:\n      d = getMaxDigit(num)\n      if maxNum[d] > 0:\n        ans = max(ans, num + maxNum[d])\n      maxNum[d] = max(maxNum[d], num)\n\n    return -1 if ans == 0 else ans",
      "title": "2815. Max Pair Sum in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb5cf133-5fed-4fe9-be14-6700a49d8da6",
      "code": "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    def getCarry(node: ListNode | None) -> ListNode | None:\n      val = node.val * 2\n      if node.next:\n        val += getCarry(node.next)\n      node.val = val % 10\n      return val // 10\n\n    if getCarry(head) == 1:\n      return ListNode(1, head)\n    return head",
      "title": "2816. Double a Number Represented as a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dec9c22-8ba3-4978-a584-b9ada9fe55c2",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:\n    ans = math.inf\n    seen = SortedSet()\n\n    for i in range(x, len(nums)):\n      seen.add(nums[i - x])\n      it = seen.bisect_left(nums[i])\n      if it != len(seen):\n        ans = min(ans, seen[it] - nums[i])\n      if it != 0:\n        ans = min(ans, nums[i] - seen[it - 1])\n\n    return ans",
      "title": "2817. Minimum Absolute Difference Between Elements With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c43573b-d129-4fae-935e-b0f40346fc55",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    # left[i] := the next index on the left (if any)\n    #            s.t. primeScores[left[i]] >= primeScores[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. primeScores[right[i]] > primeScores[i]\n    right = [n] * n\n    stack = []\n\n    # Find the next indices on the left where `primeScores` are greater or equal.\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    # Find the next indices on the right where `primeScores` are greater.\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      # be chosen.\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= MOD\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 2 <= i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)",
      "title": "2818. Apply Operations to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e79c82b-7d1c-4dab-b3f3-07918a42893c",
      "code": "class Solution:\n  def minimumRelativeLosses(\n      self,\n      prices: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    prices.sort()\n\n    prefix = list(itertools.accumulate(prices, initial=0))\n\n    for k, m in queries:\n      countFront = self._getCountFront(k, m, prices)\n      countBack = m - countFront\n      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))\n\n    return ans\n\n  def _getCountFront(\n      self,\n      k: int,\n      m: int,\n      prices: list[int],\n  ) -> int:\n    \"\"\"Returns `countFront` for query (k, m).\n\n    Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n    and the last `m - countFront` chocolates is optimal.\n\n    Define loss[i] := the relative loss of picking `prices[i]`.\n    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n       Thus, loss[i] = prices[i] - 0 = prices[i].\n    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n    By observation, we deduce that it is always better to pick from the front\n    or the back since loss[i] is increasing for 1. and is decreasing for 2.\n\n    Assume that picking `left` chocolates from the left and `right = m - left`\n    chocolates from the right is optimal. Therefore, we are selecting\n    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n\n    To determine the optimal `left` in each iteration, we simply compare\n    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,\n    it's worth increasing `left`.\n    \"\"\"\n    n = len(prices)\n    countNoGreaterThanK = bisect.bisect_right(prices, k)\n    l = 0\n    r = min(countNoGreaterThanK, m)\n\n    while l < r:\n      mid = (l + r) // 2\n      right = m - mid\n      # Picking prices[mid] is better than picking prices[n - right].\n      if prices[mid] < 2 * k - prices[n - right]:\n        l = mid + 1\n      else:\n        r = mid\n\n    return l\n\n  def _getRelativeLoss(\n      self,\n      countFront: int,\n      countBack: int,\n      k: int,\n      prefix: list[int],\n  ) -> int:\n    \"\"\"\n    Returns the relative loss of picking `countFront` and `countBack` \n    chocolates.\n    \"\"\"\n    lossFront = prefix[countFront]\n    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])\n    return lossFront + lossBack",
      "title": "2819. Minimum Relative Loss After Buying Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e73d6004-7476-453c-85cb-baf19d61a4db",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], target: int) -> int:\n    return sum(nums[i] + nums[j] < target\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))",
      "title": "2824. Count Pairs Whose Sum is Less than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f76a553-81f5-4a51-b0a5-9754855e2feb",
      "code": "class Solution:\n  def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n    i = 0  # str2's index\n\n    for c in str1:\n      if c == str2[i] or chr(\n              ord('a') + (ord(c) - ord('a') + 1) % 26) == str2[i]:\n        i += 1\n        if i == len(str2):\n          return True\n\n    return False",
      "title": "2825. Make String a Subsequence Using Cyclic Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac789487-d15b-44a4-8267-710baeefec7d",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]\n    dp = [0] * 4\n\n    for num in nums:\n      dp[num] += 1  # Append num to the sequence so far.\n      dp[2] = max(dp[2], dp[1])\n      dp[3] = max(dp[3], dp[2])\n\n    return len(nums) - dp[3]",
      "title": "2826. Sorting Three Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3317fdc-b59b-48fe-aef2-bfbaf1cb6726",
      "code": "class Solution:\n  def isAcronym(self, words: list[str], s: str) -> bool:\n    return (len(words) == len(s) and\n            all(word[0] == c for word, c in zip(words, s)))",
      "title": "2828. Check if a String Is an Acronym of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59afd9be-0ea3-4eb5-a5c1-9c826dfb2854",
      "code": "class Solution:\n  def minimumSum(self, n: int, k: int) -> int:\n    # These are the unique pairs that sum up to k:\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = k // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))",
      "title": "2829. Determine the Minimum Sum of a k-avoiding Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9da7ceb0-18b7-4e58-8600-275a76f5796e",
      "code": "class Solution:\n  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:\n    # dp[i] := the maximum amount of gold of selling the first i houses\n    dp = [0] * (n + 1)\n    endToStartAndGolds = [[] for _ in range(n)]\n\n    for start, end, gold in offers:\n      endToStartAndGolds[end].append((start, gold))\n\n    for end in range(1, n + 1):\n      # Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1]\n      for start, gold in endToStartAndGolds[end - 1]:\n        dp[end] = max(dp[end], dp[start] + gold)\n\n    return dp[n]",
      "title": "2830. Maximize the Profit as the Salesman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad9fe19e-59f5-490a-9b44-8265bca6e2e2",
      "code": "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      if r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans",
      "title": "2831. Find the Longest Equal Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59610475-34e1-4c25-928b-f844ffa25c72",
      "code": "class Solution:\n  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    stack = []  # a decreasing stack\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):\n        index = stack.pop()\n        left = stack[-1] if stack else -1\n        ans[index] = i - left - 1\n      stack.append(i)\n\n    return ans",
      "title": "2832. Maximal Range That Each Element Is Maximum in It",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19d7ef8a-a1c5-4528-9088-c671861449c8",
      "code": "class Solution:\n  def furthestDistanceFromOrigin(self, moves: str) -> int:\n    return abs(moves.count('L') - moves.count('R')) + moves.count('_')",
      "title": "2833. Furthest Point From Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "669f01b8-e0a3-44b7-a5fd-83bbc6d76241",
      "code": "class Solution:\n  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  def minimumPossibleSum(self, n: int, target: int) -> int:\n    # These are the unique pairs that sum up to k (target):\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n    MOD = 1_000_000_007\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = target // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % MOD",
      "title": "2834. Find the Minimum Possible Sum of a Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a78036f-daf7-42c5-baa2-c02676c210cc",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], target: int) -> int:\n    NO_MISSING_BIT = 31\n    maxBit = 31\n    ans = 0\n    minMissingBit = NO_MISSING_BIT\n    # count[i] := the number of occurrences of 2^i\n    count = collections.Counter(int(math.log2(num)) for num in nums)\n\n    for bit in range(maxBit):\n      # Check if `bit` is in the target.\n      if target >> bit & 1:\n        # If there are available bits, use one bit.\n        if count[bit] > 0:\n          count[bit] -= 1\n        else:\n          minMissingBit = min(minMissingBit, bit)\n      # If we previously missed a bit and there are available bits.\n      if minMissingBit != NO_MISSING_BIT and count[bit] > 0:\n        count[bit] -= 1\n        # Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit\n        minMissingBit = NO_MISSING_BIT  # Set it to an the invalid value.\n      # Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] // 2\n\n    # Check if all target bits have been covered, otherwise return -1.\n    return ans if minMissingBit == maxBit else -1",
      "title": "2835. Minimum Operations to Form Subsequence With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ffe6900-1181-4050-850e-b43c05e3c1cf",
      "code": "class Solution:\n  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    # jump[i][j] := the the node you reach after jumping 2^j steps from i\n    jump = [[0] * m for _ in range(n)]\n    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        #   the the node you reach after jumping 2^j steps from i\n        # = the node you reach after jumping 2^(j - 1) steps from i\n        # + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1]\n        #   the sum of the first 2^j nodes you reach when jumping from i\n        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        # + the sum of another 2^(j - 1) nodes you reach\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans",
      "title": "2836. Maximize Value of Function in a Ball Passing Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef7c8ab9-cc3a-4306-a16a-051927eb3d35",
      "code": "class Solution:\n  def maximumCoins(\n      self,\n      heroes: list[int],\n      monsters: list[int],\n      coins: list[int]\n  ) -> list[int]:\n    monsterAndCoins = sorted(list(zip(monsters, coins)))\n    coinsPrefix = list(itertools.accumulate(\n        (coin for _, coin in monsterAndCoins),\n        initial=0))\n    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]\n            for hero in heroes]\n\n  def _firstGreaterEqual(\n      self,\n      monsterAndCoins: list[tuple[int, int]],\n      hero: int,\n  ) -> int:\n    l, r = 0, len(monsterAndCoins)\n    while l < r:\n      m = (l + r) // 2\n      if monsterAndCoins[m][0] > hero:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2838. Maximum Coins Heroes Can Collect",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b8fce3b-fa52-4b42-b713-bf832a924ba8",
      "code": "class Solution:\n  def canBeEqual(self, s1: str, s2: str) -> bool:\n    def swappedStrings(s: str) -> list[str]:\n      chars = list(s)\n      return [chars,\n              ''.join([chars[2], chars[1], chars[0], chars[3]]),\n              ''.join([chars[0], chars[3], chars[2], chars[1]]),\n              ''.join([chars[2], chars[3], chars[0], chars[1]])]\n\n    return any(a == b\n               for a in swappedStrings(s1)\n               for b in swappedStrings(s2))",
      "title": "2839. Check if Strings Can be Made Equal With Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0aeac9a8-1e12-4c63-add8-eac7e6da5711",
      "code": "class Solution:\n  def checkStrings(self, s1: str, s2: str) -> bool:\n    count = [collections.Counter() for _ in range(2)]\n\n    for i, (a, b) in enumerate(zip(s1, s2)):\n      count[i % 2][a] += 1\n      count[i % 2][b] -= 1\n\n    return (all(freq == 0 for freq in count[0].values()) and\n            all(freq == 0 for freq in count[1].values()))",
      "title": "2840. Check if Strings Can be Made Equal With Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35b6776a-9e67-4638-8f42-386cf4aa9a48",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], m: int, k: int) -> int:\n    ans = 0\n    summ = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if i >= k:\n        numToRemove = nums[i - k]\n        summ -= numToRemove\n        count[numToRemove] -= 1\n        if count[numToRemove] == 0:\n          del count[numToRemove]\n      if len(count) >= m:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2841. Maximum Sum of Almost Unique Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1786402a-7c7e-40a9-9555-2b854c72658d",
      "code": "class Solution:\n  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(s)\n    if len(count) < k:\n      return 0\n\n    ans = 1\n    # freqCount := (f(c), # of chars with f(c))\n    freqCount = collections.Counter(count.values())\n\n    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):\n      if numOfChars >= k:\n        ans *= math.comb(numOfChars, k) * pow(fc, k, MOD)\n        return ans % MOD\n      ans *= pow(fc, numOfChars, MOD)\n      ans %= MOD\n      k -= numOfChars",
      "title": "2842. Count K-Subsequences of a String With Maximum Beauty Solved",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f398b66a-baa6-4928-88fe-7d2ba0fe4b73",
      "code": "class Solution:\n  def countSymmetricIntegers(self, low: int, high: int) -> int:\n    def isSymmetricInteger(num: int) -> bool:\n      if num >= 10 and num <= 99:\n        return num // 10 == num % 10\n      if num >= 1000 and num <= 9999:\n        left = num // 100\n        right = num % 100\n        return left // 10 + left % 10 == right // 10 + right % 10\n      return False\n\n    return sum(isSymmetricInteger(num) for num in range(low, high + 1))",
      "title": "2843. Count Symmetric Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90c31977-fe84-4ef8-ab22-ba78dac5296c",
      "code": "class Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':  # '00'\n        return n - i - 2\n      if seenZero and num[i] == '5':  # '50'\n        return n - i - 2\n      if seenFive and num[i] == '2':  # '25'\n        return n - i - 2\n      if seenFive and num[i] == '7':  # '75'\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    return n - 1 if seenZero else n",
      "title": "2844. Minimum Operations to Make a Special Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60d8a916-350f-422a-8d9a-f026958823c2",
      "code": "class Solution:\n  def countInterestingSubarrays(\n      self,\n      nums: list[int],\n      modulo: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      if num % modulo == k:\n        prefix = (prefix + 1) % modulo\n      ans += prefixCount[(prefix - k + modulo) % modulo]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2845. Count of Interesting Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bcb98c0-79c7-4090-a536-601b34d3fe49",
      "code": "class Solution:\n  def minOperationsQueries(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    MAX = 26\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    # jump[i][j] := the 2^j-th ancestor of i\n    jump = [[0] * m for _ in range(n)]\n    # depth[i] := the depth of i\n    depth = [0] * n\n    # count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    count = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    count[0] = [0] * (MAX + 1)\n    self._dfs(graph, 0, -1, jump, depth, count)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getMinOperations(u: int, v: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to make the edge weight\n      equilibrium between (u, v).\n      \"\"\"\n      lca = self._getLCA(u, v, jump, depth)\n      # the number of edges between (u, v).\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      # the maximum frequency of edges between (u, v)\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]\n                    for j in range(1, MAX + 1))\n      return numEdges - maxFreq\n\n    return [getMinOperations(u, v) for u, v in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      count: list[list[int]]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      count[v] = count[u][:]\n      count[v][w] += 1\n      self._dfs(graph, v, u, jump, depth, count)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]",
      "title": "2846. Minimum Edge Weight Equilibrium Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baf81ce6-eb49-46b9-a0f9-73084ccbfe33",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> str:\n    if n <= 9:\n      return str(n)\n\n    ans = []\n\n    for divisor in range(9, 1, -1):\n      while n % divisor == 0:\n        ans.append(str(divisor))\n        n //= divisor\n\n    return '-1' if n > 1 else ''.join(reversed(ans))",
      "title": "2847. Smallest Number With Given Digit Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0daf6bb1-27c5-4b4d-a7e8-a624751c5f17",
      "code": "class Solution:\n  def numberOfPoints(self, nums: list[list[int]]) -> int:\n    MAX = 100\n    ans = 0\n    runningSum = 0\n    count = [0] * (MAX + 2)\n\n    for start, end in nums:\n      count[start] += 1\n      count[end + 1] -= 1\n\n    for i in range(1, MAX + 1):\n      runningSum += count[i]\n      if runningSum > 0:\n        ans += 1\n\n    return ans",
      "title": "2848. Points That Intersect With Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d4e1fd-fdf3-4110-9cd3-2d252881062c",
      "code": "class Solution:\n  def isReachableAtTime(\n      self,\n      sx: int,\n      sy: int,\n      fx: int,\n      fy: int,\n      t: int,\n  ) -> bool:\n    minStep = max(abs(sx - fx), abs(sy - fy))\n    return t != 1 if minStep == 0 else minStep <= t",
      "title": "2849. Determine if a Cell Is Reachable at a Given Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24b75618-e92a-4321-87ae-5d6b35e0f000",
      "code": "class Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) +\n                          self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans",
      "title": "2850. Minimum Moves to Spread Stones Over Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2367c17-7a72-40d2-ba24-d4bf828f6bc8",
      "code": "class Solution:\n  # This dynamic programming table dp[k][i] represents the number of ways to\n  # rearrange the String s after k steps such that it starts with s[i].\n  # A String can be rotated from 1 to n - 1 times. The transition rule is\n  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  # k = 3, the table looks like this:\n  #\n  # -----------------------------------------------------------\n  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  # -----------------------------------------------------------\n  # | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  # | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  # | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  # | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  # -----------------------------------------------------------\n  #\n  # By observation, we have\n  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  #   * dp[k][0] = dp[k][!0] + (-1)^k\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n    # indices in `s` s.t. for each `i` in the returned indices,\n    # `s[i..n) + s[0..i) = t`.\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (pow(n - 1, k, MOD) - negOnePowK) * pow(n, MOD - 2, MOD)\n    dp[0] = dp[1] + negOnePowK\n    return sum(dp[0] if index == 0 else dp[1] for index in indices) % MOD\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "2851. String Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e310fcf-8a8b-4fcc-9415-4f81a1366dc1",
      "code": "class Solution:\n  def sumRemoteness(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    summ = sum(max(0, cell) for row in grid for cell in row)\n    ans = 0\n\n    def dfs(i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (count, componentSum) of the connected component that contains\n      (x, y).\n      \"\"\"\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return (0, 0)\n      if grid[i][j] == -1:\n        return (0, 0)\n\n      count = 1\n      componentSum = grid[i][j]\n      grid[i][j] = -1  # Mark as visited.\n\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        nextCount, nextComponentSum = dfs(x, y)\n        count += nextCount\n        componentSum += nextComponentSum\n\n      return (count, componentSum)\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] > 0:\n          count, componentSum = dfs(i, j)\n          ans += (summ - componentSum) * count\n\n    return ans",
      "title": "2852. Sum of Remoteness of All Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df78bde7-ffab-4b8c-ba78-470a81790dc4",
      "code": "class Solution:\n  def minimumRightShifts(self, nums: list[int]) -> int:\n    count = 0\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      if a > b:\n        count += 1\n        pivot = i\n\n    if count == 0:\n      return 0\n    if count > 1 or nums[-1] > nums[0]:\n      return -1\n    return len(nums) - pivot - 1",
      "title": "2855. Minimum Right Shifts to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9f93555-474e-466a-a891-d35593eae521",
      "code": "class Solution:\n  def minLengthAfterRemovals(self, nums: list[int]) -> int:\n    n = len(nums)\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n\n    # The number with the maximum frequency cancel all the other numbers.\n    if maxFreq <= n / 2:\n      return n % 2\n    # The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq)",
      "title": "2856. Minimum Array Length After Pair Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e79027-3c51-4e14-9439-54a04cff0c63",
      "code": "class Solution:\n  def countPairs(self, coordinates: list[list[int]], k: int) -> int:\n    ans = 0\n\n    for x in range(k + 1):\n      y = k - x\n      count = collections.Counter()\n      for xi, yi in coordinates:\n        ans += count[(xi ^ x, yi ^ y)]\n        count[(xi, yi)] += 1\n\n    return ans",
      "title": "2857. Count Pairs of Points With Distance k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26215d08-ebc2-46e4-8f8c-a3f938ad0d1c",
      "code": "class Solution:\n  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, True))  # 1 means (u -> v)\n      graph[v].append((u, False))  # 0 means (v <- u)\n\n    seen = {0}\n\n    @functools.lru_cache(None)\n    def dp(u: int) -> int:\n      \"\"\"\n      Returns the minimum number of edge reversals so node u can reach every\n      node in its subtree.\n      \"\"\"\n      res = 0\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        res += dp(v) + (0 if isForward else 1)\n      return res\n\n    ans = [0] * n\n    ans[0] = dp(0)\n\n    def dfs(u: int) -> None:\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        ans[v] = ans[u] + (1 if isForward else -1)\n        dfs(v)\n\n    seen = {0}\n    dfs(0)\n    return ans",
      "title": "2858. Minimum Edge Reversals So Every Node Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02b02209-f706-4161-8a08-4889824332b9",
      "code": "class Solution:\n  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if i.bit_count() == k)",
      "title": "2859. Sum of Values at Indices With K Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf97d6d1-62cb-466e-a00a-be96c0e4ef84",
      "code": "class Solution:\n  def countWays(self, nums: list[int]) -> int:\n    return sum(a < i < b\n               for i, (a, b) in  # i := the number of the selected numbers\n               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))",
      "title": "2860. Happy Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "597673e4-c2dd-4546-b6de-0a3c77a4b91a",
      "code": "class Solution:\n  def maxNumberOfAlloys(self, n: int, k: int, budget: int,\n                        composition: list[list[int]], stock: list[int],\n                        costs: list[int]) -> int:\n    l = 1\n    r = 1_000_000_000\n\n    def isPossible(m: int) -> bool:\n      \"\"\"Returns True if it's possible to create `m` alloys by using any machine.\"\"\"\n      # Try all the possible machines.\n      for machine in composition:\n        requiredMoney = 0\n        for j in range(n):\n          requiredUnits = max(0, machine[j] * m - stock[j])\n          requiredMoney += requiredUnits * costs[j]\n        if requiredMoney <= budget:\n          return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "2861. Maximum Number of Alloys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f30e35f9-8b82-44ad-9e2d-e75afcfb11fb",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n    oddPowerToSum = collections.Counter()\n\n    def divideSquares(val: int) -> int:\n      for num in range(2, val + 1):\n        while val % (num * num) == 0:\n          val //= (num * num)\n      return val\n\n    for i, num in enumerate(nums):\n      oddPower = divideSquares(i + 1)\n      oddPowerToSum[oddPower] += num\n      ans = max(ans, oddPowerToSum[oddPower])\n\n    return ans",
      "title": "2862. Maximum Element-Sum of a Complete Subset of Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2796441-7cae-4d3e-b022-07590d59f164",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) - 1, -1, -1):\n      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.\n      # So, no need to append it.\n      if not stack or nums[stack[-1]] > nums[i]:\n        stack.append(i)\n\n    for i, num in enumerate(nums):\n      while stack and num > nums[stack[-1]]:\n        ans = max(ans, stack.pop() - i + 1)\n\n    return ans",
      "title": "2863. Maximum Length of Semi-Decreasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abeda210-e1fc-4519-ad81-fa700d49c3f0",
      "code": "class Solution:\n  def maximumOddBinaryNumber(self, s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'",
      "title": "2864. Maximum Odd Binary Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd487245-4186-498b-b42d-97e35ff77737",
      "code": "class Solution:\n  def maximumSumOfHeights(self, heights: list[int]) -> int:\n    n = len(heights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and heights[stack[-1]] > heights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are heights[j].\n        summ -= abs(j - stack[-1]) * heights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * heights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(heights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - heights[i]\n\n    return max(maxSum)",
      "title": "2865. Beautiful Towers I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16681467-98b3-4b40-b2a0-f58c9b3419d2",
      "code": "class Solution:\n  # Same as 2865. Beautiful Towers I\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)",
      "title": "2866. Beautiful Towers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0551bcbf-6bee-4a56-98c3-0f97226531b6",
      "code": "class Solution:\n  def countPaths(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    isPrime = self._sieveEratosthenes(n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      nonlocal ans\n      countZeroPrimePath = int(not isPrime[u])\n      countOnePrimePath = int(isPrime[u])\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)\n        ans += (countZeroPrimePath * countOnePrimeChildPath +\n                countOnePrimePath * countZeroPrimeChildPath)\n        if isPrime[u]:\n          countOnePrimePath += countZeroPrimeChildPath\n        else:\n          countZeroPrimePath += countZeroPrimeChildPath\n          countOnePrimePath += countOnePrimeChildPath\n\n      return countZeroPrimePath, countOnePrimePath\n\n    dfs(1, -1)\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2867. Count Valid Paths in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa654bdb-5861-4b09-814a-ec1c5ebeacc4",
      "code": "class Solution:\n  def canAliceWin(self, a: list[str], b: list[str]) -> bool:\n    # words[0][i] := the biggest word starting with ('a' + i) for Alice\n    # words[1][i] := the biggest word starting with ('a' + i) for Bob\n    words = [[''] * 26 for _ in range(2)]\n\n    # For each letter, only the biggest word is useful.\n    for word in a:\n      words[0][ord(word[0]) - ord('a')] = word\n\n    for word in b:\n      words[1][ord(word[0]) - ord('a')] = word\n\n    # Find Alice's smallest word.\n    i = 0\n    while not words[0][i]:\n      i += 1\n\n    # 0 := Alice, 1 := Bob\n    # Start with Alice, so it's Bob's turn now.\n    turn = 1\n\n    # Iterate through each letter until we find a winner.\n    while True:\n      # If the current player has a word that having the letter that is greater\n      # than the opponent's word, choose it.\n      if words[turn][i] and words[turn][i] > words[1 - turn][i]:\n        # Choose the current words[turn][i].\n        pass\n      elif words[turn][i + 1]:\n        # Choose the next words[turn][i + 1].\n        i += 1\n      else:\n        # Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1\n      turn = 1 - turn",
      "title": "2868. The Wording Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e46ae66-0375-4537-80e3-464c5ee12986",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    seen = set()\n\n    for i, num in enumerate(reversed(nums)):\n      if num > k:\n        continue\n      seen.add(num)\n      if len(seen) == k:\n        return i + 1",
      "title": "2869. Minimum Operations to Collect Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3519745-13b0-4628-9578-9062d2489643",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    if 1 in count.values():\n      return -1\n    return sum((freq + 2) // 3 for freq in count.values())",
      "title": "2870. Minimum Number of Operations to Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf6d3f72-eb0b-43f6-b005-073fe7a81b17",
      "code": "class Solution:\n  def maxSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n\n    for num in nums:\n      score = num if score == 0 else score & num\n      if score == 0:\n        ans += 1\n\n    return max(1, ans)",
      "title": "2871. Split Array Into Maximum Number of Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3212f6a3-aac8-4c84-9962-8428fda0488e",
      "code": "class Solution:\n  def maxKDivisibleComponents(\n      self,\n      n: int,\n      edges: list[list[int]],\n      values: list[int],\n      k: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      treeSum = values[u]\n\n      for v in graph[u]:\n        if v != prev:\n          treeSum += dfs(v, u)\n\n      if treeSum % k == 0:\n        ans += 1\n      return treeSum\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    dfs(0, -1)\n    return ans",
      "title": "2872. Maximum Number of K-Divisible Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b5475b8-d089-4fbc-b725-6d7354533b7d",
      "code": "class Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2873. Maximum Value of an Ordered Triplet I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00681ab5-4c85-4dd9-8bd9-211fdb2d2dcb",
      "code": "class Solution:\n  # Same as 2873. Maximum Value of an Ordered Triplet I\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2874. Maximum Value of an Ordered Triplet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3603db73-850d-4dab-9718-d0157bfe0eaa",
      "code": "class Solution:\n  def minSizeSubarray(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    n = len(nums)\n    remainingTarget = target % summ\n    repeatLength = (target // summ) * n\n    if remainingTarget == 0:\n      return repeatLength\n\n    suffixPlusPrefixLength = n\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i in range(2 * n):\n      prefix += nums[i % n]\n      if prefix - remainingTarget in prefixToIndex:\n        suffixPlusPrefixLength = min(\n            suffixPlusPrefixLength,\n            i - prefixToIndex[prefix - remainingTarget])\n      prefixToIndex[prefix] = i\n\n    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength",
      "title": "2875. Minimum Size Subarray in Infinite Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5559915a-3e5a-4b91-9af7-56cf59d5585d",
      "code": "class Solution:\n  def countVisitedNodes(self, edges: list[int]) -> list[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    # Push non-cyclic nodes to stack.\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    # Fill the length of cyclic nodes.\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    # Fill the length of non-cyclic nodes.\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(\n      self,\n      edges: list[int],\n      start: int,\n      seen: list[bool],\n      ans: list[int],\n  ) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]",
      "title": "2876. Count Visited Nodes in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40f13fa3-bea2-48a0-97d7-4fe49c522ef6",
      "code": "class Solution:\n  def minArrayLength(self, nums: list[int], k: int) -> int:\n    count = 0\n    prod = -1\n\n    for num in nums:\n      if num == 0:\n        return 1\n      if prod != -1 and prod * num <= k:\n        prod *= num\n      else:\n        prod = num\n        count += 1\n\n    return count",
      "title": "2892. Minimizing Array After Replacing Pairs With Their Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae67f11c-d1df-4661-927f-065d595844d1",
      "code": "class Solution:\n  def differenceOfSums(self, n: int, m: int) -> int:\n    summ = (1 + n) * n // 2\n    num2 = self._getDivisibleSum(n, m)\n    num1 = summ - num2\n    return num1 - num2\n\n  def _getDivisibleSum(self, n: int, m: int) -> int:\n    \"\"\"Returns the sum of all the integers in [1, n] that are divisible by m.\"\"\"\n    last = n // m * m\n    if last == 0:\n      return 0\n    first = m\n    count = (last - first) // m + 1\n    return (first + last) * count // 2",
      "title": "2894. Divisible and Non-divisible Sums Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "230a4e04-edda-4734-85bb-c2964ea62310",
      "code": "class Solution:\n  def minProcessingTime(\n      self,\n      processorTime: list[int],\n      tasks: list[int],\n  ) -> int:\n    return max(time + task\n               for (time, task) in zip(\n                   sorted(processorTime),\n                   sorted(tasks)[:: -4]))",
      "title": "2895. Minimum Processing Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65d10dcf-156c-47c5-b056-f21749d3386e",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    #         dp := the minimum cost to correct diffIndices[i:]\n    #     dpNext := the minimum cost to correct diffIndices[i + 1:]\n    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]\n    dpNext = x / 2\n    dpNextNext = 0\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp = min(dpNext + x / 2,\n               dpNextNext + diffIndices[i + 1] - diffIndices[i])\n      dpNextNext = dpNext\n      dpNext = dp\n\n    return int(dp)",
      "title": "2896. Apply Operations to Make Two Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3769f546-52d4-4c4a-8df7-25c60d68e035",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the minimum cost to correct diffIndices[i..n).\"\"\"\n      if i == len(diffIndices):\n        return 0\n      if i == len(diffIndices) - 1:\n        return x / 2\n      return min(dp(i + 1) + x / 2,\n                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp(0))",
      "title": "2896. Apply Operations to Make Two Strings Equal_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e4a717b-2eec-4118-81a6-2a7d1818f279",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = 0\n    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    # should be moved to\n    minIndices = [0] * MAX_BIT\n    optimalNums = [0] * len(nums)\n\n    for num in nums:\n      for i in range(MAX_BIT):\n        if num >> i & 1:\n          optimalNums[minIndices[i]] |= 1 << i\n          minIndices[i] += 1\n\n    for i in range(k):\n      ans += optimalNums[i]**2\n      ans %= MOD\n\n    return ans",
      "title": "2897. Apply Operations on Array to Maximize Sum of Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "054e9c25-ef32-41e0-9acc-b50dd102766a",
      "code": "class Solution:\n  def maxScore(self, prices: list[int]) -> int:\n    groupIdToSum = collections.defaultdict(int)\n\n    for i, price in enumerate(prices):\n      groupIdToSum[price - i] += price\n\n    return max(groupIdToSum.values())",
      "title": "2898. Maximum Linear Stock Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66f252c7-bd43-4ada-80bf-0a2cd947658a",
      "code": "class Solution:\n  def lastVisitedIntegers(self, words: list[str]) -> list[int]:\n    ans = []\n    nums = []\n    k = 0\n\n    for word in words:\n      if word == 'prev':\n        k += 1\n        ans.append(-1 if k > len(nums) else nums[-k])\n      else:\n        k = 0\n        nums.append(int(word))\n\n    return ans",
      "title": "2899. Last Visited Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42ba49c3-052d-4d39-980a-d7b1b034d0ce",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    groupId = -1\n\n    for word, group in zip(words, groups):\n      if group != groupId:\n        groupId = group\n        ans.append(word)\n\n    return ans",
      "title": "2900. Longest Unequal Adjacent Groups Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3b4cf28-5cc8-4504-bc7f-ddcff9c93007",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    # dp[i] := the length of the longest subsequence ending in `words[i]`\n    dp = [1] * n\n    # prev[i] := the best index of words[i]\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    # Find the last index of the subsequence.\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]",
      "title": "2901. Longest Unequal Adjacent Groups Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "989e3e51-5146-47aa-8882-8d25cc1c4029",
      "code": "class Solution:\n  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of submultisets of `nums` with sum i\n    dp = [1] + [0] * r\n    count = collections.Counter(nums)\n    zeros = count.pop(0, 0)\n\n    for num, freq in count.items():\n      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      stride = dp.copy()\n      for i in range(num, r + 1):\n        stride[i] += stride[i - num]\n      for i in range(r, 0, -1):\n        if i >= num * (freq + 1):\n          # dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = stride[i] - stride[i - num * (freq + 1)]\n        else:\n          dp[i] = stride[i]\n\n    return (zeros + 1) * sum(dp[l:r + 1]) % MOD",
      "title": "2902. Count of Sub-Multisets With Bounded Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d93fd68b-3f44-42c7-b914-c8f90b415f2b",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the\n    # current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the\n    # current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2903. Find Indices With Index and Value Difference I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95a5577b-f3d8-4f2d-80e4-5df40901938c",
      "code": "class Solution:\n  # Same as 76. Minimum Window Substring\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    return \"\" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]",
      "title": "2904. Shortest and Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c720457f-73d9-4961-b0de-427bb1a9c288",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2905. Find Indices With Index and Value Difference II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f3e53de-a560-41d0-8563-cbb1e980dbfd",
      "code": "class Solution:\n  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    MOD = 12345\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [1]\n    suffix = 1\n\n    for row in grid:\n      for num in row:\n        prefix.append(prefix[-1] * num % MOD)\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        ans[i][j] = prefix[i * n + j] * suffix % MOD\n        suffix = suffix * grid[i][j] % MOD\n\n    return ans",
      "title": "2906. Construct Product Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4d552da-e608-4b08-959f-e9a753881889",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2907. Maximum Profitable Triplets With Increasing Prices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca5fa394-93cf-4acd-96ad-14a970adc4ba",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2908. Minimum Sum of Mountain Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d6f7f82-dca2-47d8-9a4c-745560a86cbe",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2909. Minimum Sum of Mountain Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97ec206f-cd1d-440d-846a-5d3262ec0e66",
      "code": "class Solution:\n  def minGroupsForValidAssignment(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    minFreq = min(count.values())\n\n    for groupSize in range(minFreq, 0, -1):\n      numGroups = self.getNumGroups(count, groupSize)\n      if numGroups > 0:\n        return numGroups\n\n    raise ValueError(\"Invalid argument\")\n\n  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:\n    \"\"\"Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.\"\"\"\n    numGroups = 0\n    for freq in count.values():\n      a = freq // (groupSize + 1)\n      b = freq % (groupSize + 1)\n      if b == 0:\n        # Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        # `a + 1` groups.\n        numGroups += a\n      elif groupSize - b <= a:\n        numGroups += a + 1\n      else:\n        return 0\n    return numGroups",
      "title": "2910. Minimum Number of Groups to Create a Valid Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4aa85faf-5d71-4291-a875-6cc70a80b5df",
      "code": "class Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    # factors[i] := factors of i\n    factors = self._getFactors(n)\n    # cost[i][j] := changes to make s[i..j] a semi-palindrome\n    cost = self._getCost(s, n, factors)\n    # dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> list[list[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i, j in itertools.combinations(range(n), 2):\n      length = j - i + 1\n      minCost = length\n      for d in factors[length]:\n        minCost = min(minCost, self._getCostD(s, i, j, d))\n      cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    \"\"\"Returns the cost to make s[i..j] a semi-palindrome of `d`.\"\"\"\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost",
      "title": "2911. Minimum Changes to Make K Semi-palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f871da42-7653-4ee2-9236-93ccc7598b4a",
      "code": "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i][0] := the the number of ways of `source` to `dest` using i steps\n    # dp[i][1] := the the number of ways of `source` to dest's row using i steps\n    # dp[i][2] := the the number of ways of `source` to dest's col using i steps\n    # dp[i][3] := the the number of ways of `source` to others using i steps\n    dp = [[0] * 4 for _ in range(k + 1)]\n    if source == dest:\n      dp[0][0] = 1\n    elif source[0] == dest[0]:\n      dp[0][1] = 1\n    elif source[1] == dest[1]:\n      dp[0][2] = 1\n    else:\n      dp[0][3] = 1\n\n    for i in range(1, k + 1):\n      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD\n      dp[i][1] = (dp[i - 1][0] * (m - 1) +  # -self\n                  dp[i - 1][1] * (m - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][2] = (dp[i - 1][0] * (n - 1) +  # -self\n                  dp[i - 1][2] * (n - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][3] = (dp[i - 1][1] * (n - 1) +  # -self\n                  dp[i - 1][2] * (m - 1) +  # -self\n                  dp[i - 1][3] * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n\n    return dp[k][0]",
      "title": "2912. Number of Ways to Reach Destination in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6a6bee0-42a2-4716-9310-a0a9e23e7215",
      "code": "class Solution:\n  def minChanges(self, s: str) -> int:\n    return sum(a != b for a, b in zip(s[::2], s[1::2]))",
      "title": "2914. Minimum Number of Changes to Make Binary String Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b50154b7-8844-4e33-850e-1a7bbde379e2",
      "code": "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum length of any subsequence of the first i numbers\n    # that sum to j\n    dp = [[-1] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      dp[i][0] = 0\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(1, target + 1):\n        # 1. Skip `num`.\n        if j < num or dp[i - 1][j - num] == -1:\n          dp[i][j] = dp[i - 1][j]\n        # 2. Skip `num` or pick `num`.\n        else:\n          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])\n\n    return dp[n][target]",
      "title": "2915. Length of the Longest Subsequence That Sums to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d5501f5-12c3-45c2-ad82-1d2522cc057b",
      "code": "class Solution:\n  def findKOr(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    return sum(2**i\n               for i in range(MAX_BIT + 1)\n               if sum(num >> i & 1 for num in nums) >= k)",
      "title": "2917. Find the K-or of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "247d6c29-18d7-42a6-9914-a9d625e096df",
      "code": "class Solution:\n  def minSum(self, nums1: list[int], nums2: list[int]) -> int:\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n    zero1 = nums1.count(0)\n    zero2 = nums2.count(0)\n    if zero1 == 0 and sum1 < sum2 + zero2:\n      return -1\n    if zero2 == 0 and sum2 < sum1 + zero1:\n      return -1\n    return max(sum1 + zero1, sum2 + zero2)",
      "title": "2918. Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2c3c337-fb17-465e-907c-33e8f5368071",
      "code": "class Solution:\n  def minIncrementOperations(self, nums: list[int], k: int) -> int:\n    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    prev3 = 0\n    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    prev2 = 0\n    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    prev1 = 0\n\n    for num in nums:\n      dp = min(prev1, prev2, prev3) + max(0, k - num)\n      prev3 = prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return min(prev1, prev2, prev3)",
      "title": "2919. Minimum Increment Operations to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1b5a9c4-1707-4ed4-b4bc-1074f1a538da",
      "code": "class Solution:\n  def maximumPoints(\n      self,\n      edges: list[list[int]],\n      coins: list[int],\n      k: int,\n  ) -> int:\n    MAX_COIN = 10000\n    MAX_HALVED = int(MAX_COIN).bit_length()\n    n = len(coins)\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, halved: int) -> int:\n      # All the children will be 0, so no need to explore.\n      if halved > MAX_HALVED:\n        return 0\n\n      val = coins[u] // (1 << halved)\n      takeAll = val - k\n      takeHalf = math.floor(val / 2)\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        takeAll += dfs(v, u, halved)\n        takeHalf += dfs(v, u, halved + 1)\n\n      return max(takeAll, takeHalf)\n\n    return dfs(0, -1, 0)",
      "title": "2920. Maximum Points After Collecting Coins From All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe4e2bb-5189-43de-aeca-b7aadcf45e6d",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2921. Maximum Profitable Triplets With Increasing Prices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ff849d7-6181-4a49-8cf0-a78d8e41df97",
      "code": "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    inDegrees = [0] * n\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          continue\n        if grid[i][j] == 1:\n          inDegrees[j] += 1\n        else:\n          inDegrees[i] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2923. Find Champion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497d9701-1704-4f99-acfd-56f6674566e7",
      "code": "class Solution:\n  def findChampion(self, n: int, edges: list[list[int]]) -> int:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2924. Find Champion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47db128c-1809-4245-9cbd-9fe2897daa70",
      "code": "class Solution:\n  def maximumScoreAfterOperations(\n      self,\n      edges: list[list[int]],\n      values: list[int],\n  ) -> int:\n    tree = [[] for _ in values]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      if u > 0 and len(tree[u]) == 1:\n        return values[u]\n      childrenSum = sum(dfs(v, u)\n                        for v in tree[u]\n                        if v != prev)\n      return min(childrenSum, values[u])\n\n    return sum(values) - dfs(0, -1)",
      "title": "2925. Maximum Score After Applying Operations on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f05d267-f533-4ccb-ad3a-8651dc303c16",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    \"\"\"Updates the maximum sum of subsequence ending in (i - 1) with `val`.\"\"\"\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    \"\"\"Returns the maximum sum of subsequence ending in (i - 1).\"\"\"\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:\n    # Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    # By observation:\n    #    nums[i] - nums[j] >= i - j\n    # => nums[i] - i >= nums[j] - j\n    # So, if nums[i] - i >= nums[j] - j, where i > j,\n    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    ans = -math.inf\n    tree = FenwickTree(len(nums))\n\n    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):\n      subseqSum = tree.get(i) + nums[i]\n      tree.maximize(i + 1, subseqSum)\n      ans = max(ans, subseqSum)\n\n    return ans",
      "title": "2926. Maximum Balanced Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e90d9dab-500c-4805-b5cf-ce31ebfe8ebb",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2927. Distribute Candies Among Children III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c6f95f0-632d-4df7-9e74-fd255996250e",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2928. Distribute Candies Among Children I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9f34a9e-6b79-4520-b2e4-014ca335a32b",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2929. Distribute Candies Among Children II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bf636a5-d755-47cc-8be2-3a9225cbadda",
      "code": "class Solution:\n  def stringCount(self, n: int) -> int:\n    # There're three invalid conditions:\n    #   a. count('l') == 0\n    #   b. count('e') < 2\n    #   c. count('t') == 0\n    #\n    # By Principle of Inclusion-Exclusion (PIE):\n    #   ans = allCount - a - b - c + ab + ac + bc - abc\n    MOD = 1_000_000_007\n    allCount = pow(26, n, MOD)\n    a = pow(25, n, MOD)\n    b = pow(25, n, MOD)\n    c = pow(25, n, MOD) + n * pow(25, n - 1, MOD)\n    ab = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    ac = pow(24, n, MOD)\n    bc = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    abc = pow(23, n, MOD) + n * pow(23, n - 1, MOD)\n    return (allCount - a - b - c + ab + ac + bc - abc) % MOD",
      "title": "2930. Number of Strings Which Can Be Rearranged to Contain Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9314404-d914-4f7f-ab2f-12667ba4629b",
      "code": "class Solution:\n  def maxSpending(self, values: list[list[int]]) -> int:\n    items = sorted(item for shop in values for item in shop)\n    return sum(item * d for d, item in enumerate(items, 1))",
      "title": "2931. Maximum Spending After Buying Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b6203b7-1f06-4588-89d3-aba43c119c8b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2932. Maximum Strong Pair XOR I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b62ae8f6-a962-4554-aa2c-34a3c83ca7a5",
      "code": "class Solution:\n  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:\n    ans = set()\n\n    access_times.sort()\n\n    for i in range(len(access_times) - 2):\n      name = access_times[i][0]\n      if name in ans:\n        continue\n      if name != access_times[i + 2][0]:\n        continue\n      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:\n        ans.add(name)\n\n    return list(ans)",
      "title": "2933. High-Access Employees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71f8797a-f358-40c4-946f-b6487bbbeda1",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    mn = min(nums1[-1], nums2[-1])\n    mx = max(nums1[-1], nums2[-1])\n    # the number of the minimum operations, where nums1[n - 1] is not swapped\n    # with nums2[n - 1]\n    dp1 = 0\n    # the number of the minimum operations, where nums1[n - 1] is swapped with\n    # nums2[n - 1]\n    dp2 = 0\n\n    for a, b in zip(nums1, nums2):\n      if min(a, b) > mn:\n        return -1\n      if max(a, b) > mx:\n        return -1\n      if a > nums1[-1] or b > nums2[-1]:\n        dp1 += 1\n      if a > nums2[-1] or b > nums1[-1]:\n        dp2 += 1\n\n    return min(dp1, dp2)",
      "title": "2934. Minimum Operations to Maximize Last Elements in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b68cb31e-d0c3-4874-9f0e-e5bd98411598",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Same as 2932. Maximum Strong Pair XOR I\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2935. Maximum Strong Pair XOR II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7764c30-ab07-4935-bec4-8e34c99caf03",
      "code": "# Definition for BigArray.\n# class BigArray:\n#   def at(self, index: long) -> int:\n#     pass\n#   def size(self) -> long:\n#     pass\n\nclass Solution(object):\n  def countBlocks(self, nums: Optional['BigArray']) -> int:\n    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:\n      \"\"\"Returns the number of maximal blocks in nums[l..r].\"\"\"\n      if leftValue == rightValue:\n        return 1\n      if l + 1 == r:\n        return 2\n      m = (l + r) // 2\n      midValue = nums.at(m)\n      return (countBlocks(l, m, leftValue, midValue) +\n              countBlocks(m, r, midValue, rightValue) - 1)\n    # Substract nums[m], which will be counted twice.\n    return countBlocks(0, nums.size() - 1,\n                       nums.at(0), nums.at(nums.size() - 1))",
      "title": "2936. Number of Equal Numbers Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "378b706f-e688-4bc6-b4bf-6bd2749233ce",
      "code": "class Solution:\n  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n    minLength = min(map(len, [s1, s2, s3]))\n    i = 0\n    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:\n      i += 1\n    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3",
      "title": "2937. Make Three Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33592a95-3fac-46af-8460-4e8245e9459f",
      "code": "class Solution:\n  def minimumSteps(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for c in s:\n      if c == '1':\n        ones += 1\n      else:  # Move 1s to the front of the current '0'.\n        ans += ones\n\n    return ans",
      "title": "2938. Separate Black and White Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ecc3279-fa37-4243-b9a4-a1c0e436dee2",
      "code": "class Solution:\n  def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n    MOD = 1_000_000_007\n    for bit in (2**i for i in range(n)):\n      # Pick a bit if it makes min(a, b) larger.\n      if a * b < (a ^ bit) * (b ^ bit):\n        a ^= bit\n        b ^= bit\n    return a * b % MOD",
      "title": "2939. Maximum Xor Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad05a3db-8c85-4405-870d-4ee35393f8b5",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedQuery:\n  queryIndex: int\n  a: int  # Alice's index\n  b: int  # Bob's index\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  # Similar to 2736. Maximum Sum Queries\n  def leftmostBuildingQueries(\n      self,\n      heights: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(queries)\n    # Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    # descending order.\n    stack = []\n\n    # Iterate through queries and heights simultaneously.\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))\n                                    for i, (a, b) in enumerate(queries)],\n                                   key=lambda x: -x.b):\n      if a == b or heights[a] < heights[b]:\n        # 1. Alice and Bob are already in the same index (a == b) or\n        # 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b\n      else:\n        # Now, a < b and heights[a] >= heights[b].\n        # Gradually add heights with an index > b to the monotonic stack.\n        while heightsIndex > b:\n          # heights[heightsIndex] is a better candidate, given that\n          # heightsIndex is smaller than the indices in the stack and\n          # heights[heightsIndex] is larger or equal to the heights mapped in\n          # the stack.\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        # Binary search to find the smallest index j such that j > b and\n        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: list[int], target: int, heights: list[int]):\n    \"\"\"\n    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].\n    \"\"\"\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l",
      "title": "2940. Find Building Where Alice and Bob Can Meet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2033dae-4d43-46c7-84ca-28655d508d66",
      "code": "class Solution:\n  def maxGcdSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # [(startIndex, gcd of subarray starting at startIndex)]\n    startIndexAndGcds = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i, num in enumerate(nums):\n      nextStartIndexAndGcds = []\n      for startIndex, gcd in startIndexAndGcds:\n        nextGcd = math.gcd(gcd, nums[i])\n        if (not nextStartIndexAndGcds or\n                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.\n          nextStartIndexAndGcds.append((startIndex, nextGcd))\n      startIndexAndGcds = nextStartIndexAndGcds\n      startIndexAndGcds.append((i, nums[i]))\n      for startIndex, gcd in startIndexAndGcds:\n        if i - startIndex + 1 >= k:\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)\n\n    return ans",
      "title": "2941. Maximum GCD-Sum of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28e706d1-47b8-490f-841f-c4961aa21d0e",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2944. Minimum Number of Coins for Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc581eed-eeb5-4138-b80a-5654cb931b61",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2944. Minimum Number of Coins for Fruits_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6312a4af-f809-4253-bec2-7f70b54dcb1c",
      "code": "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # bestLeft[i] := the index l s.t. merging nums[l..i) is the\n    # optimal strategy among processing the first i nums\n    bestLeft = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])\n      # When merging nums[l, i), consider the next segment as [i, r).\n      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).\n      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].\n      #            => prefix[r] >= prefix[i] * 2 - prefix[l]\n      # Therefore, we can binary search `prefix` to find the minimum `r`.\n      l = bestLeft[i]\n      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])\n      dp[i] = dp[l] + 1\n      bestLeft[r] = i\n\n    return dp[n]",
      "title": "2945. Find Maximum Non-decreasing Array Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3431af40-0f3b-4ad3-8dfa-bb4a273a699c",
      "code": "class Solution:\n  def areSimilar(self, mat: list[list[int]], k: int) -> bool:\n    n = len(mat[0])\n    for row in mat:\n      for j in range(n):\n        if row[j] != row[(j + k) % n]:\n          return False\n    return True",
      "title": "2946. Matrix Similarity After Cyclic Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c5d2c53-b8ca-4078-91a9-b8ed3c4495b1",
      "code": "class Solution:\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2947. Count Beautiful Substrings I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b58bf38e-43e2-4450-8b7e-594bede38740",
      "code": "class Solution:\n  def lexicographicallySmallestArray(\n      self,\n      nums: list[int],\n      limit: int,\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    # [[(num, index)]], where the difference between in each pair in each\n    # `[(num, index)]` group <= `limit`\n    numAndIndexesGroups: list[list[tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if (not numAndIndexesGroups or\n              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):\n        # Start a new group.\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        # Append to the existing group.\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans",
      "title": "2948. Make Lexicographically Smallest Array by Swapping Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b25d218d-c884-40fd-af78-8ec465ae5dd1",
      "code": "class Solution:\n  # Same as 2947. Count Beautiful Substrings I\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2949. Count Beautiful Substrings II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b25e0aa-b603-4908-ac20-250a0bc43b7e",
      "code": "class Solution:\n  def countDivisibleSubstrings(self, word: str) -> int:\n    # Let f(c) = d, where d = 1, 2, ..., 9.\n    # Rephrase the question to return the number of substrings that satisfy\n    #    f(c1) + f(c2) + ... + f(ck) // k = avg\n    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    ans = 0\n\n    def f(c: str) -> int:\n      return 9 - (ord('z') - ord(c)) // 3\n\n    for avg in range(1, 10):\n      prefix = 0\n      prefixCount = collections.Counter({0: 1})\n      for c in word:\n        prefix += f(c) - avg\n        ans += prefixCount[prefix]\n        prefixCount[prefix] += 1\n\n    return ans",
      "title": "2950. Number of Divisible Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a64475c1-2b34-4afe-88bd-fa4493d15177",
      "code": "class Solution:\n  def findPeaks(self, mountain: list[int]) -> list[int]:\n    return [i for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]]",
      "title": "2951. Find the Peaks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c66657b5-d57e-44af-84d2-b4968de87c37",
      "code": "class Solution:\n  # Same as 330. Patching Array\n  def minimumAddedCoins(self, coins: list[int], target: int) -> int:\n    ans = 0\n    i = 0  # coins' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    coins.sort()\n\n    while miss <= target:\n      if i < len(coins) and coins[i] <= miss:\n        miss += coins[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "2952. Minimum Number of Coins to be Added",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e80b78-451d-49d1-ad97-25e964131a5c",
      "code": "class Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize)\n               for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    \"\"\"\n    Returns the number of complete substrings of `windowSize` of `word`.\n    \"\"\"\n    res = 0\n    countLetters = 0  # the number of letters in the running substring\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        # Start a new substring starting at word[i].\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res",
      "title": "2953. Count Complete Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fd692c2-0dda-4cf9-b35b-74673c47928f",
      "code": "class Solution:\n  def numberOfSequence(self, n: int, sick: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    ans = fact(n - len(sick))  # the number of infected children\n    prevSick = -1\n\n    for i, s in enumerate(sick):\n      # The segment [prevSick + 1, sick - 1] are the current non-infected\n      # children.\n      nonInfected = sick[i] - prevSick - 1\n      prevSick = sick[i]\n      if nonInfected == 0:\n        continue\n      ans *= inv(fact(nonInfected))\n      ans %= MOD\n      if i > 0:\n        # There're two choices per second since the children at the two\n        # endpoints can both be the infect candidates. So, there are\n        # 2^[nonInfected - 1] ways to infect all children in the current\n        # segment.\n        ans *= pow(2, nonInfected - 1, MOD)\n\n    nonInfected = n - sick[-1] - 1\n    return ans * inv(fact(nonInfected)) % MOD",
      "title": "2954. Count the Number of Infection Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb478e30-e869-4372-ae28-e56300c5ac0c",
      "code": "class Solution:\n  def sameEndSubstringCount(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[int]:\n    count = collections.Counter()\n    # counts[i] := the count of s[0..i)\n    counts = [count.copy()]\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n\n    ans = []\n\n    for l, r in queries:\n      sameEndCount = 0\n      for c in string.ascii_lowercase:\n        #   the count of s[0..r] - the count of s[0..l - 1]\n        # = the count of s[l..r]\n        freq = counts[r + 1][c] - counts[l][c]\n        #   C(freq, 2) + freq\n        # = freq * (freq - 1) / 2 + freq\n        # = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) // 2\n      ans.append(sameEndCount)\n\n    return ans",
      "title": "2955. Number of Same-End Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5591871-75e5-4c9b-a0de-6ec810274a57",
      "code": "class Solution:\n  def findIntersectionValues(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n  ) -> list[int]:\n    nums1Set = set(nums1)\n    nums2Set = set(nums2)\n    return [sum(num in nums2Set for num in nums1),\n            sum(num in nums1Set for num in nums2)]",
      "title": "2956. Find Common Elements Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6216997d-a830-4e57-a0c0-c15613883424",
      "code": "class Solution:\n  def removeAlmostEqualCharacters(self, word: str) -> int:\n    ans = 0\n    i = 1\n    while i < len(word):\n      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:\n        ans += 1\n        i += 2\n      else:\n        i += 1\n    return ans",
      "title": "2957. Remove Adjacent Almost-Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "972b2232-402f-4103-b280-345d959af689",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      while count[num] == k + 1:\n        count[nums[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2958. Length of Longest Subarray With at Most K Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6652d448-63ef-4117-8cb2-94f776a719f4",
      "code": "class Solution:\n  def numberOfSets(\n      self,\n      n: int,\n      maxDistance: int,\n      roads: list[list[int]],\n  ) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance\n               for mask in range(1 << n))\n\n  def _floydWarshall(\n      self,\n      n: int,\n      maxDistanceThreshold: int,\n      roads: list[list[int]],\n      mask: int,\n  ) -> list[list[int]]:\n    \"\"\"\n    Returns the maximum distance between any two branches, where the mask\n    represents the selected branches.\n    \"\"\"\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance",
      "title": "2959. Number of Possible Sets of Closing Branches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6b11d92-3ba5-48af-af68-f0ec6b5f2bc1",
      "code": "class Solution:\n  def countTestedDevices(self, batteryPercentages: list[int]) -> int:\n    ans = 0\n\n    for batteryPercentage in batteryPercentages:\n      if batteryPercentage - ans > 0:\n        ans += 1\n\n    return ans",
      "title": "2960. Count Tested Devices After Test Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39a0b689-8f54-4a64-9bfb-2d812c3ea6fa",
      "code": "class Solution:\n  def getGoodIndices(\n      self,\n      variables: list[list[int]],\n      target: int,\n  ) -> list[int]:\n    return [i for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target]",
      "title": "2961. Double Modular Exponentiation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62e812eb-9293-4d15-8db4-bc65e599138a",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    maxNum = max(nums)\n    ans = 0\n    count = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == maxNum:\n        count += 1\n      # Keep the window to include k - 1 times of the maxNummum number.\n      while count == k:\n        if nums[l] == maxNum:\n          count -= 1\n        l += 1\n      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any\n      # subarray nums[i:r+1], where i < l, it will have at least k times of the\n      # maxNummum number, since nums[l - 1] equals the maxNummum number.\n      ans += l\n\n    return ans",
      "title": "2962. Count Subarrays Where Max Element Appears at Least K Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ae4c858-a4d3-4f89-b417-87364d57f980",
      "code": "class Solution:\n  def numberOfGoodPartitions(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    # lastSeen[num] := the index of the last time `num` appeared\n    lastSeen = {}\n\n    for i, num in enumerate(nums):\n      lastSeen[num] = i\n\n    # Track the maximum right index of each running partition by ensuring that\n    # the first and last occurrences of a number fall within the same partition.\n    maxRight = 0\n    for i, num in enumerate(nums):\n      if i > maxRight:\n        # Start a new partition that starts from nums[i].\n        # Each partition doubles the total number of good partitions.\n        ans = ans * 2 % MOD\n      maxRight = max(maxRight, lastSeen[num])\n\n    return ans",
      "title": "2963. Count the Number of Good Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a3934f4-6e93-423d-91b2-56bc20b7fe43",
      "code": "class Solution:\n  # Similar to 1995. Count Special Quadruplets\n  def divisibleTripletCount(self, nums: list[int], d: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.\n      for i in range(j - 1, -1, -1):\n        ans += count[-(nums[i] + nums[j]) % d]\n      count[nums[j] % d] += 1  # j := k\n\n    return ans",
      "title": "2964. Number of Divisible Triplet Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "628551c2-c095-4fd1-8b4b-ff94afbab124",
      "code": "class Solution:\n  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:\n    count = [1] + [0] * len(grid)**2  # padding for 1-indexed\n\n    for row in grid:\n      for num in row:\n        count[num] += 1\n\n    return [count.index(2), count.index(0)]",
      "title": "2965. Find Missing and Repeated Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ace17fe0-acbf-4330-a04d-53dfd010c920",
      "code": "class Solution:\n  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:\n    ans = []\n\n    nums.sort()\n\n    for i in range(2, len(nums), 3):\n      if nums[i] - nums[i - 2] > k:\n        return []\n      ans.append([nums[i - 2], nums[i - 1], nums[i]])\n\n    return ans",
      "title": "2966. Divide Array Into Arrays With Max Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89922194-5984-4812-9e38-f767c4342d73",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    nums.sort()\n    median = nums[len(nums) // 2]\n    nextPalindrome = self._getPalindrome(median, delta=1)\n    prevPalindrome = self._getPalindrome(median, delta=-1)\n    return min(self._cost(nums, nextPalindrome),\n               self._cost(nums, prevPalindrome))\n\n  def _cost(self, nums: list[int], palindrome: int) -> int:\n    \"\"\"Returns the cost to change all the numbers to `palindrome`.\"\"\"\n    return sum(abs(palindrome - num) for num in nums)\n\n  def _getPalindrome(self, num: int, delta: int) -> int:\n    \"\"\"Returns the palindrome `p`, where p = num + a * delta and a > 0.\"\"\"\n    while not self._isPalindrome(num):\n      num += delta\n    return num\n\n  def _isPalindrome(self, num: int) -> int:\n    original = str(num)\n    return original == original[::-1]",
      "title": "2967. Minimum Cost to Make Array Equalindromic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9ab5b8d-3e0e-4953-986e-9b986f0d9395",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = 0\n    cost = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      cost += num - nums[(l + r) // 2]\n      while cost > k:\n        cost -= nums[(l + r + 1) // 2] - nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2968. Apply Operations to Maximize Frequency Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ffba1bb-8e6a-4d9f-86ad-bd50188a9ca9",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2969. Minimum Number of Coins for Fruits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d2a05c4-45fb-48be-a4ff-f0b5d96a919e",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2969. Minimum Number of Coins for Fruits II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53222277-66c9-4183-b0af-6baa1be371c6",
      "code": "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2970. Count the Number of Incremovable Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "576ed139-019d-443e-80eb-b6829f65482d",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    prefix = sum(nums)\n\n    for num in sorted(nums, reverse=True):\n      prefix -= num\n      # Let `num` be the longest side. Check if the sum of all the edges with\n      # length no longer than `num` > `num``.\n      if prefix > num:\n        return prefix + num\n\n    return -1",
      "title": "2971. Find Polygon With the Largest Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b02c9925-2fdc-4746-b356-863a3ef1c6ef",
      "code": "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2972. Count the Number of Incremovable Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f670d941-742d-4f4d-aacc-8e2d1ad76767",
      "code": "class ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res,\n                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans",
      "title": "2973. Find Number of Coins to Place in Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5de9d91-b10c-41a8-913d-cda7755ad95c",
      "code": "class Solution:\n  def numberGame(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    return [nums[i + 1] if i % 2 == 0\n            else nums[i - 1]\n            for i in range(len(nums))]",
      "title": "2974. Minimum Number Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f521ce0-651d-4517-94b5-b4f759068dc4",
      "code": "class Solution:\n  def maximizeSquareArea(\n      self,\n      m: int,\n      n: int,\n      hFences: list[int],\n      vFences: list[int],\n  ) -> int:\n    hFences = sorted(hFences + [1, m])\n    vFences = sorted(vFences + [1, n])\n    hGaps = {hFences[i] - hFences[j]\n             for i in range(len(hFences))\n             for j in range(i)}\n    vGaps = {vFences[i] - vFences[j]\n             for i in range(len(vFences))\n             for j in range(i)}\n    maxGap = next((hGap\n                  for hGap in sorted(hGaps, reverse=True)\n                  if hGap in vGaps), -1)\n    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)",
      "title": "2975. Maximum Square Area by Removing Fences From a Field",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "067edf76-ddf9-49c5-9f41-ee46a0725356",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    ans = 0\n    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans",
      "title": "2976. Minimum Cost to Convert String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7e2394e-67c7-4d5a-8480-f4419f59dca4",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    # dist[u][v] := the minimum distance to change the substring with id u to\n    # the substring with id v\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    # dp[i] := the minimum cost to change the first i letters of `source` into\n    # `target`, leaving the suffix untouched\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    return -1 if dp[len(source)] == math.inf else dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId",
      "title": "2977. Minimum Cost to Convert String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a758a19a-cca6-4a33-bf63-f57b6007f238",
      "code": "class Solution:\n  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n    # https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo",
      "title": "2979. Most Expensive Item That Can Not Be Bought",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "434efce2-24fa-4266-8311-1ce24fb221fa",
      "code": "class Solution:\n  def hasTrailingZeros(self, nums: list[int]) -> bool:\n    return sum(num % 2 == 0 for num in nums) >= 2",
      "title": "2980. Check if Bitwise OR Has Trailing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd204e6-84bf-4303-812b-e95d5442b916",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2981. Find Longest Special Substring That Occurs Thrice I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d1fcb63-46b5-4e17-b031-c11b417f78a1",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2982. Find Longest Special Substring That Occurs Thrice II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01d2cda3-f226-435b-a984-cee7c9dbff84",
      "code": "class Solution:\n  def canMakePalindromeQueries(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    n = len(s)\n    # mirroredDiffs[i] := the number of different letters between the first i\n    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    mirroredDiffs = self._getMirroredDiffs(s)\n    # counts[i] := the count of s[0..i)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: list[int], b: list[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      # Use left-closed, right-open intervals to facilitate the calculation.\n      #   ...... [a, b) ...|... [rb, ra) ......\n      #   .... [rd, rc) .....|..... [c, d) ....\n      b += 1\n      d += 1\n      ra = n - a  # the reflected index of a in s[n / 2..n)\n      rb = n - b  # the reflected index of b in s[n / 2..n)\n      rc = n - c  # the reflected index of c in s[n / 2..n)\n      rd = n - d  # the reflected index of d in s[n / 2..n)\n      # No difference is allowed outside the query ranges.\n      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or\n         (n // 2 > max(b, rc) and\n          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or\n         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or\n         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):\n        ans.append(False)\n      else:\n        # The `count` map of the intersection of [a, b) and [rd, rc) in\n        # s[0..n / 2) must equate to the `count` map of the intersection of\n        # [c, d) and [rb, ra) in s[n / 2..n).\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> list[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> list[list[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts",
      "title": "2983. Palindrome Rearrangement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15274e85-8e36-44bc-a825-023d2518dbcf",
      "code": "class Solution:\n  def selfDivisiblePermutationCount(self, n: int) -> int:\n    def dfs(num: int, used: int) -> int:\n      if num > n:\n        return 1\n\n      count = 0\n      for i in range(1, n + 1):\n        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):\n          count += dfs(num + 1, used | 1 << i)\n\n      return count\n\n    return dfs(1, 0)",
      "title": "2992. Number of Self-Divisible Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d8b8405-c495-4776-8f6f-016dce65be69",
      "code": "class Solution:\n  def missingInteger(self, nums: list[int]) -> int:\n    numsSet = set(nums)\n    ans = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1] + 1:\n        break\n      ans += nums[i]\n\n    while ans in numsSet:\n      ans += 1\n\n    return ans",
      "title": "2996. Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e4d7f6d-04f3-4121-a2e4-39de8678e1fe",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return functools.reduce(operator.xor, nums, k).bit_count()",
      "title": "2997. Minimum Number of Operations to Make Array XOR Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b238ce48-9e45-44c4-9945-ede7b1fa4cd0",
      "code": "class Solution:\n  def minimumOperationsToMakeEqual(self, x, y):\n    if x <= y:\n      return y - x\n\n    queue = collections.deque([x])\n    seen = set()\n\n    ans = 0\n    while queue:\n      for _ in range(len(queue)):\n        num = queue.popleft()\n        if num == y:\n          return ans\n        if num in seen:\n          continue\n        seen.add(num)\n        if num % 11 == 0:\n          queue.append(num // 11)\n        if num % 5 == 0:\n          queue.append(num // 5)\n        queue.append(num - 1)\n        queue.append(num + 1)\n      ans += 1",
      "title": "2998. Minimum Number of Operations to Make X and Y Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02bcb3c1-6284-43f3-9029-0b9c82e357bb",
      "code": "class Solution:\n  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:\n    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))\n    return a * b",
      "title": "3000. Maximum Area of Longest Diagonal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "817103fb-8f07-4450-9576-a2d18e92e59b",
      "code": "class Solution:\n  def minMovesToCaptureTheQueen(\n      self, a: int, b: int, c: int, d: int, e: int, f: int,\n  ) -> int:\n    # The rook is in the same row as the queen.\n    if a == e:\n      # The bishop blocks the rook or not.\n      return 2 if c == a and (b < d < f or b > d > f) else 1\n    # The rook is in the same column as the queen.\n    if b == f:\n      # The bishop blocks the rook or not.\n      return 2 if d == f and (a < c < e or a > c > e) else 1\n    # The bishop is in the same up-diagonal as the queen.\n    if c + d == e + f:\n      # The rook blocks the bishop or not.\n      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1\n    # The bishop is in the same down-diagonal as the queen.\n    if c - d == e - f:\n      # The rook blocks the bishop or not.\n      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1\n    # The rook can always get the green in two steps.\n    return 2",
      "title": "3001. Minimum Moves to Capture The Queen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "859cfeff-dd65-45f4-9b0d-e8b5b7d4c0d3",
      "code": "class Solution:\n  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = set1.intersection(set2)\n\n    n = len(nums1)\n    n1 = len(set1)\n    n2 = len(set2)\n    nc = len(common)\n    maxUniqueNums1 = min(n1 - nc, n // 2)\n    maxUniqueNums2 = min(n2 - nc, n // 2)\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)",
      "title": "3002. Maximum Size of a Set After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebbf579e-d40c-4206-991a-4e3877fc6873",
      "code": "class Solution:\n  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, canChange: bool, mask: int) -> int:\n      \"\"\"\n      Returns the maximum number of partitions of s[i..n), where `canChange` is\n      True if we can still change a letter, and `mask` is the bitmask of the\n      letters we've seen.\n      \"\"\"\n      if i == len(s):\n        return 0\n\n      def getRes(newBit: int, nextCanChange: bool) -> int:\n        newMask = mask | newBit\n        if newMask.bit_count() > k:\n          return 1 + dp(i + 1, nextCanChange, newBit)\n        return dp(i + 1, nextCanChange, newMask)\n\n      # Initialize the result based on the current letter.\n      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)\n\n      # If allowed, explore the option to change the current letter.\n      if canChange:\n        for j in range(26):\n          res = max(res, getRes(1 << j, False))\n      return res\n\n    return dp(0, True, 0) + 1",
      "title": "3003. Maximize the Number of Partitions After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c882392f-e516-41b4-8f85-731f13ea72fa",
      "code": "class Solution:\n  def maximumSubtreeSize(\n      self,\n      edges: list[list[int]],\n      colors: list[int],\n  ) -> int:\n    ans = 1\n    tree = [[] for _ in range(len(colors))]\n\n    for u, v in edges:\n      tree[u].append(v)\n\n    def dfs(u: int) -> int:\n      \"\"\"\n      Returns the size of subtree of u if every node in the subtree has the same\n      color. Otherwise, returns -1.\n      \"\"\"\n      nonlocal ans\n      res = 1\n      for v in tree[u]:\n        if colors[v] != colors[u]:\n          res = -1\n        # If any node in the subtree of v has a different color, the result of\n        # the subtree of u will be -1 as well.\n        subtreeSize = dfs(v)\n        if subtreeSize == -1:\n          res = -1\n        elif res != -1:\n          res += subtreeSize\n      ans = max(ans, res)\n      return res\n\n    dfs(0)\n    return ans",
      "title": "3004. Maximum Subtree of the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a69a94bb-7ad4-4d3c-94c6-c5c2c4ac36eb",
      "code": "class Solution:\n  def maxFrequencyElements(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n    return sum(freq == maxFreq for freq in count.values()) * maxFreq",
      "title": "3005. Count Elements With Maximum Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b2b7e02-73a7-4272-a0d7-6604c9bb2bab",
      "code": "class Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3006. Find Beautiful Indices in the Given Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b8537df-724b-42e8-b23c-85c839d8f8b8",
      "code": "class Solution:\n  def findMaximumNumber(self, k: int, x: int) -> int:\n    def getSumPrices(num: int) -> int:\n      \"\"\"Returns the sum of prices of all numbers from 1 to `num`.\"\"\"\n      sumPrices = 0\n      # Increment `num` to account the 0-th row in the count of groups.\n      num += 1\n      for i in range(num.bit_length(), 0, -1):\n        if i % x == 0:\n          groupSize = 1 << i\n          halfGroupSize = 1 << i - 1\n          sumPrices += num // groupSize * halfGroupSize\n          sumPrices += max(0, (num % groupSize) - halfGroupSize)\n      return sumPrices\n\n    l = 1\n    r = 10**15\n    return bisect.bisect_right(range(l, r + 1), k, key=getSumPrices) - 1 + l",
      "title": "3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5648bf4d-2ee4-4d81-b832-100643a59961",
      "code": "class Solution:\n  # Same as 3006. Find Beautiful Indices in the Given Array I\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = []\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3008. Find Beautiful Indices in the Given Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c101bbf-5384-4ffd-a16a-8ad0b0d502c8",
      "code": "class Solution:\n  def maxIntersectionCount(self, y: list[int]) -> int:\n    ans = 0\n    intersectionCount = 0\n    line = collections.Counter()\n\n    for i, (a, b) in enumerate(itertools.pairwise(y)):\n      start = 2 * a\n      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)\n      line[min(start, end)] += 1\n      line[max(start, end) + 1] -= 1\n\n    for count in sorted(line):\n      intersectionCount += line[count]\n      ans = max(ans, intersectionCount)\n\n    return ans",
      "title": "3009. Maximum Number of Intersections on the Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a763d89-1377-4e7b-a8ae-85dc247f1a59",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    MAX = 50\n    min1 = MAX\n    min2 = MAX\n\n    for i in range(1, len(nums)):\n      if nums[i] < min1:\n        min2 = min1\n        min1 = nums[i]\n      elif nums[i] < min2:\n        min2 = nums[i]\n\n    return nums[0] + min1 + min2",
      "title": "3010. Divide an Array Into Subarrays With Minimum Cost I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4132dde-1342-4d41-933e-26a7524c3738",
      "code": "class Solution:\n  def canSortArray(self, nums: list[int]) -> int:\n    # Divide the array into distinct segments where each segment is comprised\n    # of consecutive elements sharing an equal number of set bits. Ensure that\n    # for each segment, when moving from left to right, the maximum of a\n    # preceding segment is less than the minimum of the following segment.\n    prevSetBits = 0\n    prevMax = -math.inf  # the maximum of the previous segment\n    currMax = -math.inf  # the maximum of the current segment\n    currMin = math.inf   # the minimum of the current segment\n\n    for num in nums:\n      setBits = num.bit_count()\n      if setBits != prevSetBits:  # Start a new segment.\n        if prevMax > currMin:\n          return False\n        prevSetBits = setBits\n        prevMax = currMax\n        currMax = num\n        currMin = num\n      else:  # Continue with the current segment.\n        currMax = max(currMax, num)\n        currMin = min(currMin, num)\n\n    return prevMax <= currMin",
      "title": "3011. Find if Array Can Be Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52c63c0c-6579-4fef-858c-30eb0583b158",
      "code": "class Solution:\n  def minimumArrayLength(self, nums: list[int]) -> int:\n    # Let the minimum number in the array `nums` be x.\n    # * If there exists any element nums[i] where nums[i] % x > 0, a new\n    #   minimum can be generated and all other numbers can be removed.\n    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    #   generated which cannot be removed. Therefore, the result will be\n    #   (frequency of x + 1) / 2.\n    minNum = min(nums)\n    if any(num % minNum > 0 for num in nums):\n      return 1\n    return (nums.count(minNum) + 1) // 2",
      "title": "3012. Minimize Length of Array Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7a233a4-edce-4478-a82e-d14c593bf5cb",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:\n    # Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    windowSum = sum(nums[i] for i in range(1, dist + 2))\n    selected = SortedList(nums[i] for i in range(1, dist + 2))\n    candidates = SortedList()\n\n    def balance() -> int:\n      \"\"\"\n      Returns the updated `windowSum` by balancing the multiset `selected` to\n      keep the top k - 1 numbers.\n      \"\"\"\n      nonlocal windowSum\n      while len(selected) < k - 1:\n        minCandidate = candidates[0]\n        windowSum += minCandidate\n        selected.add(minCandidate)\n        candidates.remove(minCandidate)\n      while len(selected) > k - 1:\n        maxSelected = selected[-1]\n        windowSum -= maxSelected\n        selected.remove(maxSelected)\n        candidates.add(maxSelected)\n      return windowSum\n\n    windowSum = balance()\n    minWindowSum = windowSum\n\n    for i in range(dist + 2, len(nums)):\n      outOfScope = nums[i - dist - 1]\n      if outOfScope in selected:\n        windowSum -= outOfScope\n        selected.remove(outOfScope)\n      else:\n        candidates.remove(outOfScope)\n      if nums[i] < selected[-1]:  # nums[i] is a better number.\n        windowSum += nums[i]\n        selected.add(nums[i])\n      else:\n        candidates.add(nums[i])\n      windowSum = balance()\n      minWindowSum = min(minWindowSum, windowSum)\n\n    return nums[0] + minWindowSum",
      "title": "3013. Divide an Array Into Subarrays With Minimum Cost II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e6adda-51f1-4fbe-ab5f-60499926b0fe",
      "code": "class Solution:\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3014. Minimum Number of Pushes to Type Word I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cd17a1d-536f-47ad-a304-63e7742729c7",
      "code": "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3015. Count the Number of Houses at a Certain Distance I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f3040e8-b298-4689-bfc8-59e8702552d9",
      "code": "class Solution:\n  # Same as 3014. Minimum Number of Pushes to Type Word I\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3016. Minimum Number of Pushes to Type Word II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bfd835b-af9a-442d-8886-7a917474d7ed",
      "code": "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3017. Count the Number of Houses at a Certain Distance II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ea441af-5e47-412c-b063-1cb6d65a64e8",
      "code": "class Solution:\n  def maximumProcessableQueries(\n      self,\n      nums: list[int],\n      queries: list[int],\n  ) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    # removed after processing dp[i][j] queries\n    dp = [[0] * n for _ in range(n)]\n\n    for d in range(n - 1, -1, -1):\n      for i in range(n):\n        j = i + d\n        if j >= n:\n          continue\n        if i > 0:\n          # Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] +\n                         (nums[i - 1] >= queries[dp[i - 1][j]]))\n        if j + 1 < n:\n          # Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] +\n                         (nums[j + 1] >= queries[dp[i][j + 1]]))\n        if dp[i][j] == len(queries):\n          return len(queries)\n\n    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])\n               for i in range(n))",
      "title": "3018. Maximum Number of Removal Queries That Can Be Processed I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57c1ccb0-43a6-4524-83ab-5e41576c318e",
      "code": "class Solution:\n  def countKeyChanges(self, s: str) -> int:\n    return sum(a.lower() != b.lower()\n               for a, b in itertools.pairwise(s))",
      "title": "3019. Number of Changing Keys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "074ce26b-37dd-4851-b00c-1e060735dba6",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    count = collections.Counter(nums)\n    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1\n\n    for num in nums:\n      if num == 1:\n        continue\n      length = 0\n      x = num\n      while x <= maxNum and x in count and count[x] >= 2:\n        length += 2\n        x *= x\n      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      # The goal is to determine if we can insert x^k in the middle of the\n      # pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      # and decrease the length by 1.\n      ans = max(ans, length + (1 if x in count else -1))\n\n    return ans",
      "title": "3020. Find the Maximum Number of Elements in Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7050ecc4-03d5-494c-ab5c-8d187aebd740",
      "code": "class Solution:\n  def flowerGame(self, n: int, m: int) -> int:\n    # Alice wins if x + y is odd, occurring when:\n    #   1. x is even and y is odd, or\n    #   2. y is even and x is odd.\n    xEven = n // 2\n    yEven = m // 2\n    xOdd = (n + 1) // 2\n    yOdd = (m + 1) // 2\n    return xEven * yOdd + yEven * xOdd",
      "title": "3021. Alice and Bob Playing Flower Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "269780a4-139f-4127-9c2c-81a11215f07e",
      "code": "class Solution:\n  def minOrAfterOperations(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111\n\n    for i in range(MAX_BIT, -1, -1):\n      # Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      # currently added bit within k operations. If it's impossible, then we\n      # add the i-th bit to the answer.\n      prefixMask |= 1 << i\n      if self._getMergeOps(nums, prefixMask, ans) > k:\n        ans |= 1 << i\n\n    return ans\n\n  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:\n    \"\"\"\n    Returns the number of merge operations to turn `prefixMask` to the target\n    by ANDing `nums`.\n    \"\"\"\n    mergeOps = 0\n    ands = prefixMask\n    for num in nums:\n      ands &= num\n      if (ands | target) == target:\n        ands = prefixMask\n      else:\n        mergeOps += 1  # Keep merging the next num\n    return mergeOps",
      "title": "3022. Minimize OR of Remaining Elements Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cad04823-a948-4ad0-a127-58ed96811689",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int],\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3023. Find Pattern in Infinite Stream I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c49aef6a-070e-42c3-999f-a04fc39408de",
      "code": "class Solution:\n  def triangleType(self, nums: list[int]) -> str:\n    nums.sort()\n    if nums[0] + nums[1] <= nums[2]:\n      return 'none'\n    if nums[0] == nums[1] and nums[1] == nums[2]:\n      return 'equilateral'\n    if nums[0] == nums[1] or nums[1] == nums[2]:\n      return 'isosceles'\n    return 'scalene'",
      "title": "3024. Type of Triangle II Easy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f00d867-e325-4864-ad59-7a8328d71af1",
      "code": "class Solution:\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3025. Find the Number of Ways to Place People I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94e361ba-b25f-4537-a72c-48c214c5e45b",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    numToMinPrefix = {}\n\n    for num in nums:\n      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:\n        numToMinPrefix[num] = prefix\n      prefix += num\n      if num + k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num + k])\n      if num - k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num - k])\n\n    return 0 if ans == -math.inf else ans",
      "title": "3026. Maximum Good Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad7f0f50-5dd0-497e-93f6-ae6ab631f8bd",
      "code": "class Solution:\n  # Same as 3025. Find the Number of Ways to Place People I\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3027. Find the Number of Ways to Place People II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d8d0886-bf3b-464e-b9a4-fddeecf284e1",
      "code": "class Solution:\n  def returnToBoundaryCount(self, nums: list[int]) -> int:\n    return sum(prefix == 0 for prefix in itertools.accumulate(nums))",
      "title": "3028. Ant on the Boundary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf30af78-b825-48ae-b749-159980f075a8",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3029. Minimum Time to Revert Word to Initial State I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b028099-6751-4e91-9c1b-ec09bcbd83fd",
      "code": "class Solution:\n  def resultGrid(\n      self,\n      image: list[list[int]],\n      threshold: int,\n  ) -> list[list[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y]\n                           for x in range(i, i + 3)\n                           for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(\n      self,\n      image: list[list[int]],\n      i: int,\n      j: int,\n      threshold: int,\n  ) -> bool:\n    \"\"\"Returns True if image[i..i + 2][j..j + 2] is a region.\"\"\"\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True",
      "title": "3030. Find the Grid of Region Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdc16c5a-1f5c-4d72-ae4b-d0caa05b3eda",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3031. Minimum Time to Revert Word to Initial State II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b92d476-d8e3-457c-9594-dbd3d95e979c",
      "code": "class Solution:\n  def numberCount(self, a: int, b: int) -> int:\n    return sum(len(set(str(num))) == len(str(num))\n               for num in range(a, b + 1))",
      "title": "3032. Count Numbers With Unique Digits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74dfe98a-ff70-4016-b171-bd989ac9bf6b",
      "code": "class Solution:\n  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = matrix.copy()\n\n    for j in range(n):\n      mx = max(matrix[i][j] for i in range(m))\n      for i in range(m):\n        if matrix[i][j] == -1:\n          ans[i][j] = mx\n\n    return ans",
      "title": "3033. Modify the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0461db85-7e08-499b-a16c-42b81274961b",
      "code": "class Solution:\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3034. Number of Subarrays That Match a Pattern I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b24d28c-d0d3-4e5c-8a4d-d3b7a72bfb23",
      "code": "class Solution:\n  def maxPalindromesAfterOperations(self, words: list[str]) -> int:\n    ans = 0\n    count = collections.Counter(''.join(words))\n    pairs = sum(value // 2 for value in count.values())\n\n    for length in sorted(len(word) for word in words):\n      needPairs = length // 2\n      if pairs < needPairs:\n        return ans\n      ans += 1\n      pairs -= needPairs\n\n    return ans",
      "title": "3035. Maximum Palindromes After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a29583c-09ea-4072-8924-40fc6824beeb",
      "code": "class Solution:\n  # Same as 3034. Number of Subarrays That Match a Pattern I\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3036. Number of Subarrays That Match a Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54c5db85-7443-497f-a93d-41af15ee0fc7",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  # Same as 3023. Find Pattern in Infinite Stream I\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int]\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3037. Find Pattern in Infinite Stream II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe49e0d0-5abc-4c98-ae42-25fd2cc6c6a5",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    ans = 1\n    summ = nums[0] + nums[1]\n\n    for i in range(2, len(nums) - 1, 2):\n      if nums[i] + nums[i + 1] == summ:\n        ans += 1\n      else:\n        break\n\n    return ans",
      "title": "3038. Maximum Number of Operations With the Same Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b88a343e-7989-44f7-aaff-1a41def74d77",
      "code": "class Solution:\n  def lastNonEmptyString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    maxFreq = max(count.values())\n\n    for c in reversed(s):\n      if count[c] == maxFreq:\n        ans.append(c)\n        count[c] -= 1\n\n    return ''.join(reversed(ans))",
      "title": "3039. Apply Operations to Make String Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73bed1bf-95cc-4e11-ab41-8e850a99e492",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, score: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      nums[i..j], s.t. all operations have the same `score`.\n      \"\"\"\n      if i >= j:\n        return 0\n      deleteFirstTwo = (1 + dp(i + 2, j, score)\n                        if nums[i] + nums[i + 1] == score else 0)\n      deleteLastTwo = (1 + dp(i, j - 2, score)\n                       if nums[j] + nums[j - 1] == score else 0)\n      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)\n                            if nums[i] + nums[j] == score else 0)\n      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)\n\n    n = len(nums)\n    return max(dp(0, n - 1, nums[0] + nums[1]),\n               dp(0, n - 1, nums[-1] + nums[-2]),\n               dp(0, n - 1, nums[0] + nums[-1]))",
      "title": "3040. Maximum Number of Operations With the Same Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baea1b05-2a22-4e44-8b02-4f3e6a08f570",
      "code": "class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 1\n    prev = -math.inf\n    # the length of the longest consecutive elements (seq0) ending in the\n    # previous number\n    dp0 = 1\n    # the length of the longest consecutive elements (seq1) ending in the\n    # previous number + 1\n    dp1 = 1\n\n    for num in sorted(nums):\n      if num == prev:\n        dp1 = dp0 + 1  # Append `num + 1` to seq0.\n      elif num == prev + 1:\n        dp0 += 1  # Append `num` to seq0.\n        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.\n      elif num == prev + 2:\n        dp0 = dp1 + 1  # Append `num` to seq1.\n        dp1 = 1        # Start a new sequence [`num + 1`].\n      else:\n        dp0 = 1  # Start a new sequence [`num`].\n        dp1 = 1  # Start a new sequence [`num + 1`].\n      ans = max(ans, dp0, dp1)\n      prev = num\n\n    return ans",
      "title": "3041. Maximize Consecutive Elements in an Array After Modification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7f8bdf0-eb63-463c-bd7e-2c857b4143df",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3042. Count Prefix and Suffix Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0940166b-fcad-4844-931a-c124412aa673",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)",
      "title": "3043. Find the Length of the Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15796f68-9c35-40ce-9e5a-c75840abd43d",
      "code": "class Solution:\n  def mostFrequentPrime(self, mat: list[list[int]]) -> int:\n    DIRS = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in DIRS:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]",
      "title": "3044. Most Frequent Prime",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b79107fe-0387-4cdf-9252-66e668144157",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  # Same as 3045. Count Prefix and Suffix Pairs II\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3045. Count Prefix and Suffix Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd4a5bbb-2916-4d17-b3b9-545d24bba716",
      "code": "class Solution:\n  def isPossibleToSplit(self, nums: list[int]) -> bool:\n    return all(freq <= 2 for freq in collections.Counter(nums).values())",
      "title": "3046. Split the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e6207d2-083b-4591-ba73-c08b28d2ca35",
      "code": "class Solution:\n  def largestSquareArea(\n      self,\n      bottomLeft: list[list[int]],\n      topRight: list[list[int]],\n  ) -> int:\n    minSide = 0\n\n    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (\n            itertools.combinations(zip(bottomLeft, topRight), 2)):\n      overlapX = min(ax2, bx2) - max(ax1, bx1)\n      overlapY = min(ay2, by2) - max(ay1, by1)\n      minSide = max(minSide, min(overlapX, overlapY))\n\n    return minSide**2",
      "title": "3047. Find the Largest Area of Square Inside Two Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90094670-c973-4ffc-9cf3-3aa360fb74c9",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    def canMark(second: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `second`.\n      \"\"\"\n      numMarked = 0\n      decrement = 0\n      indexToLastSecond = {}\n\n      for i in range(second):\n        indexToLastSecond[changeIndices[i] - 1] = i\n\n      for i in range(second):\n        index = changeIndices[i] - 1  # Convert to 0-indexed\n        if i == indexToLastSecond[index]:\n          # Reach the last occurrence of the number.\n          # So, the current second will be used to mark the index.\n          if nums[index] > decrement:\n            # The decrement is less than the number to be marked.\n            return False\n          decrement -= nums[index]\n          numMarked += 1\n        else:\n          decrement += 1\n\n      return numMarked == len(nums)\n\n    l = 1\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1",
      "title": "3048. Earliest Second to Mark Indices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ab51894-069c-4d19-bad0-8e7e0625beed",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    # {the second: the index of nums can be zeroed at the current second}\n    secondToIndex = self._getSecondToIndex(nums, changeIndices)\n    numsSum = sum(nums)\n\n    def canMark(maxSecond: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `maxSecond`.\n      \"\"\"\n      # Use a min-heap to greedily pop out the minimum number, which yields the\n      # least saving.\n      minHeap = []\n      marks = 0\n\n      for second in range(maxSecond - 1, -1, -1):\n        if second in secondToIndex:\n          # The number mapped by the index is a candidate to be zeroed out.\n          index = secondToIndex[second]\n          heapq.heappush(minHeap, nums[index])\n          if marks == 0:\n            # Running out of marks, so need to pop out the minimum number.\n            # So, the current second will be used to mark an index.\n            heapq.heappop(minHeap)\n            marks += 1\n          else:\n            # There're enough marks.\n            # So, the current second will be used to zero out a number.\n            marks -= 1\n        else:\n          # There's no candidate to be zeroed out.\n          # So, the current second will be used to mark an index.\n          marks += 1\n\n      decrementAndMarkCost = ((numsSum - sum(minHeap)) +\n                              (len(nums) - len(minHeap)))\n      zeroAndMarkCost = len(minHeap) + len(minHeap)\n      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond\n\n    l = 0\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n\n  def _getSecondToIndex(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> dict[int, int]:\n    # {the `index` of nums: the earliest second to zero out nums[index]}\n    indexToFirstSecond = {}\n    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):\n      index = oneIndexedIndex - 1  # Convert to 0-indexed.\n      if nums[index] > 0 and index not in indexToFirstSecond:\n        indexToFirstSecond[index] = zeroIndexedSecond\n    return {second: index for index, second in indexToFirstSecond.items()}",
      "title": "3049. Earliest Second to Mark Indices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31a5589b-8676-4ac1-9ee7-694b3d6cf9de",
      "code": "class Solution:\n  def gameResult(self, head: ListNode | None) -> str:\n    even = 0\n    odd = 0\n\n    while head:\n      if head.val > head.next.val:\n        even += 1\n      elif head.val < head.next.val:\n        odd += 1\n      head = head.next.next\n\n    if even > odd:\n      return 'Even'\n    if even < odd:\n      return 'Odd'\n    return 'Tie'",
      "title": "3062. Winner of the Linked List Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ed837cf-7083-457e-be2b-7761aef0fbd3",
      "code": "class Solution:\n  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:\n    count = collections.Counter()\n    curr = head\n\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    for freq in count.values():\n      tail.next = ListNode(freq)\n      tail = tail.next\n\n    return dummy.next",
      "title": "3063. Linked List Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef5be656-b185-4e53-891f-76009386c032",
      "code": "# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return sum(1 << i for i in range(31)\n               if commonSetBits(1 << i) == 1)",
      "title": "3064. Guess the Number Using Bitwise Questions I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8ef67dd-ba63-456f-be74-8890848b3661",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(num < k for num in nums)",
      "title": "3065. Minimum Operations to Exceed Threshold Value I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "225b314f-04d6-4553-87c7-0ac230281d13",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    ans = 0\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    while len(minHeap) > 1 and minHeap[0] < k:\n      x = heapq.heappop(minHeap)\n      y = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))\n      ans += 1\n\n    return ans",
      "title": "3066. Minimum Operations to Exceed Threshold Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a5b047-2398-4ba3-9799-761d0f08a479",
      "code": "class Solution:\n  def countPairsOfConnectableServers(\n      self,\n      edges: list[list[int]],\n      signalSpeed: int,\n  ) -> list[int]:\n    n = len(edges) + 1\n    tree = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      tree[u].append((v, w))\n      tree[v].append((u, w))\n\n    def connectablePairsRootedAt(u: int) -> int:\n      pairs = 0\n      count = 0\n      for v, w in tree[u]:\n        childCount = dfs(v, u, w)\n        pairs += count * childCount\n        count += childCount\n      return pairs\n\n    def dfs(u: int, prev: int, dist: int) -> int:\n      return (int(dist % signalSpeed == 0) +\n              sum(dfs(v, u, dist + w)\n              for v, w in tree[u]\n              if v != prev))\n\n    return [connectablePairsRootedAt(i) for i in range(n)]",
      "title": "3067. Count Pairs of Connectable Servers in a Weighted Tree Network",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1d04cca-72f9-47a6-aa6e-c958c1cd4668",
      "code": "class Solution:\n  def maximumValueSum(\n      self,\n      nums: list[int],\n      k: int,\n      edges: list[list[int]],\n  ) -> int:\n    maxSum = sum(max(num, num ^ k) for num in nums)\n    changedCount = sum((num ^ k) > num for num in nums)\n    if changedCount % 2 == 0:\n      return maxSum\n    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)\n    return maxSum - minChangeDiff",
      "title": "3068. Find the Maximum Sum of Node Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21ae8240-7024-412c-98d8-5161a3ee3e22",
      "code": "class Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = [nums[0]]\n    arr2 = [nums[1]]\n\n    for i in range(2, len(nums)):\n      if arr1[-1] > arr2[-1]:\n        arr1.append(nums[i])\n      else:\n        arr2.append(nums[i])\n\n    return arr1 + arr2",
      "title": "3069. Distribute Elements Into Two Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b4793fd-55d2-4863-868c-b6234081c441",
      "code": "class Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n        if prefix[i + 1][j + 1] <= k:\n          ans += 1\n\n    return ans",
      "title": "3070. Count Submatrices with Top-Left Element and Sum Less Than k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f07ad1ae-2b82-4081-81ea-9b7e75fce1ca",
      "code": "class Solution:\n  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    mid = n // 2\n\n    def getOperations(a: int, b: int) -> int:\n      \"\"\"Returns the number of operations to turn Y into a and non-Y into b.\"\"\"\n      operations = 0\n      for i, row in enumerate(grid):\n        for j, num in enumerate(row):\n          # For the 'Y' pattern, before the midpoint, check the diagonal and\n          # anti-diagonal. After the midpoint, check the middle column.\n          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:\n            if num != a:\n              operations += 1\n          elif num != b:\n            operations += 1\n      return operations\n\n    return min(getOperations(0, 1), getOperations(0, 2),\n               getOperations(1, 0), getOperations(1, 2),\n               getOperations(2, 0), getOperations(2, 1))",
      "title": "3071. Minimum Operations to Write the Letter Y on a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1a110f8-e154-40f8-9bc3-7d23f7905471",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: list[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.add(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks",
      "title": "3072. Distribute Elements Into Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3cb8c61-58bd-493b-95c5-030c68b30322",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))\n    leftSortedSet = SortedSet([nums[0]])\n\n    for i in range(len(nums) - 2, -1, -1):\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1])\n\n    for j in range(1, len(nums) - 1):\n      i = bisect.bisect_left(leftSortedSet, nums[j])\n      if i > 0 and rightMax[j] > nums[j]:\n        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])\n      leftSortedSet.add(nums[j])\n\n    return ans",
      "title": "3073. Maximum Increasing Triplet Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "946fa5db-8ba3-470e-a257-6f3c6e2216be",
      "code": "class Solution:\n  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:\n    appleSum = sum(apple)\n    capacitySum = 0\n\n    for i, c in enumerate(sorted(capacity, reverse=True)):\n      capacitySum += c\n      if capacitySum >= appleSum:\n        return i + 1\n\n    return len(capacity)",
      "title": "3074. Apple Redistribution into Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0763676-2642-4bbf-b34d-d8ccc4c1c7bf",
      "code": "class Solution:\n  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:\n    ans = 0\n    decremented = 0\n\n    happiness.sort(reverse=True)\n\n    for i in range(k):\n      ans += max(0, happiness[i] - decremented)\n      decremented += 1\n\n    return ans",
      "title": "3075. Maximize Happiness of Selected Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d795ad5-512b-4adf-a061-eb55804cfdb6",
      "code": "class Solution:\n  def shortestSubstrings(self, arr: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    def getSubstrings(s: str) -> Iterator[str]:\n      for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n          yield s[i:j]\n\n    def add(s: str) -> None:\n      \"\"\"Adds all substrings of s to `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] += 1\n\n    def remove(s: str) -> None:\n      \"\"\"Removes all substrings of s from `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] -= 1\n\n    def getMinSub(s: str) -> str:\n      minSub = ''\n      for sub in getSubstrings(s):\n        if count[sub] > 0:\n          continue\n        if minSub == ('' or\n                      len(sub) < len(minSub) or\n                      len(sub) == len(minSub) and sub < minSub):\n          minSub = sub\n      return minSub\n\n    for s in arr:\n      add(s)\n\n    for s in arr:\n      remove(s)\n      ans.append(getMinSub(s))\n      add(s)\n\n    return ans",
      "title": "3076. Shortest Uncommon Substring in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02acfffc-fae7-49c8-b415-ec1bc2b16e8d",
      "code": "class Solution:\n  def maximumStrength(self, nums: list[int], k: int) -> int:\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, fresh: bool) -> int:\n      \"\"\"\n      Returns the maximum strength of nums[i..n) with k operations left, where\n      `fresh` means we're starting a new subarray.\n      \"\"\"\n      if len(nums) - i < k:\n        return -math.inf\n      if k == 0:\n        return 0\n      if i == len(nums):\n        return 0 if k == 0 else -math.inf\n      # If it's not fresh, we can't skip the current number and consider it as a\n      # fresh start, since the case where it's fresh is already covered by\n      # `includeAndFreshStart`.\n      skip = dp(i + 1, k, True) if fresh else -math.inf\n      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k\n      includeAndContinue = dp(i + 1, k, False) + gain\n      includeAndFreshStart = dp(i + 1, k - 1, True) + gain\n      return max(skip, includeAndContinue, includeAndFreshStart)\n\n    return dp(0, k, True)",
      "title": "3077. Maximum Strength of K Disjoint Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f4e5d57-99c1-45a1-889f-2c5d6fb289f2",
      "code": "class Solution:\n  def findPattern(\n      self,\n      board: list[list[int]],\n      pattern: list[str],\n  ) -> list[int]:\n    def isMatch(x: int, y: int) -> bool:\n      digitToLetter = {}\n      letterToDigit = {}\n      for i, row in enumerate(pattern):\n        for j, c in enumerate(row):\n          digit = board[i + x][j + y]\n          if c.isdigit():\n            if int(c) != digit:\n              return False\n          else:\n            if digitToLetter.get(digit, c) != c:\n              return False\n            if letterToDigit.get(c, digit) != digit:\n              return False\n            digitToLetter[digit] = c\n            letterToDigit[c] = digit\n      return True\n\n    for x in range(len(board) - len(pattern) + 1):\n      for y in range(len(board[0]) - len(pattern[0]) + 1):\n        if isMatch(x, y):\n          return [x, y]\n\n    return [-1, -1]",
      "title": "3078. Match Alphanumerical Pattern in Matrix I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb9c3dd9-3244-48b2-adbc-8b61c3205329",
      "code": "class Solution:\n  def sumOfEncryptedInt(self, nums: list[int]) -> int:\n    def getEncrypted(num: int) -> int:\n      maxDigit = 0\n      base = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        base = base * 10 + 1\n        num //= 10\n      return base * maxDigit\n\n    return sum(getEncrypted(num) for num in nums)",
      "title": "3079. Find the Sum of Encrypted Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c16dbc30-85c1-4862-b394-f128712c575d",
      "code": "class Solution:\n  def unmarkedSumArray(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    marked = set()\n    summ = sum(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for index, k in queries:\n      if index not in marked:\n        marked.add(index)\n        summ -= nums[index]\n      popped = 0\n      while popped < k and minHeap:\n        num, i = heapq.heappop(minHeap)\n        if i not in marked:\n          marked.add(i)\n          summ -= num\n          popped += 1\n      ans.append(summ)\n\n    return ans",
      "title": "3080. Mark Elements on Array by Performing Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62af718f-fcab-4b28-824c-1112183770fa",
      "code": "class Solution:\n  def minimizeStringValue(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    letters = []\n\n    del count['?']\n\n    def getMinFreqLetter(count: dict[str, int]) -> str:\n      minFreqLetter = 'a'\n      for c in string.ascii_lowercase:\n        if count[c] < count[minFreqLetter]:\n          minFreqLetter = c\n      return minFreqLetter\n\n    for c in s:\n      if c == '?':\n        minFreqLetter = getMinFreqLetter(count)\n        letters.append(minFreqLetter)\n        count[minFreqLetter] += 1\n\n    letters.sort()\n    i = 0  # letters' index\n\n    for c in s:\n      if c == '?':\n        ans.append(letters[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3081. Replace Question Marks in String to Minimize Its Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea5dffba-c0fd-4b37-816d-12d4dda90f09",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(k + 1):\n        if j < num:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2) % MOD\n        else:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          # 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % MOD\n\n    return dp[n][k]",
      "title": "3082. Find the Sum of the Power of All Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c9e5e02-89da-446a-8459-79a5999708da",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of subsequences in nums[i..n) that sums to j.\"\"\"\n      if j == 0:\n        # For each of the remaining number, we can either pick it or skip it.\n        return pow(2, len(nums) - i, MOD)\n      if i == len(nums) or j < 0:\n        return 0\n        # 1. Include nums[i] in the subsequence and pick it.\n        # 2. Include nums[i] in the subsequence and skip it.\n        # 3. Exclude nums[i] in the subsequence.\n      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % MOD\n\n    return dp(0, k)",
      "title": "3082. Find the Sum of the Power of All Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c725030-2f4a-44c1-a115-656db3818e0d",
      "code": "class Solution:\n  def isSubstringPresent(self, s: str) -> bool:\n    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))",
      "title": "3083. Existence of a Substring in a String and Its Reverse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97b229de-6740-44b4-ad4b-9db1d6734033",
      "code": "class Solution:\n  def countSubstrings(self, s: str, c: str) -> int:\n    freq = s.count(c)\n    return freq * (freq + 1) // 2",
      "title": "3084. Count Substrings Starting and Ending with Given Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48cc9e23-fa43-435c-a356-55ab3c6dabef",
      "code": "class Solution:\n  def minimumDeletions(self, word: str, k: int) -> int:\n    ans = math.inf\n    count = collections.Counter(word)\n\n    for minFreq in count.values():\n      deletions = 0\n      for freq in count.values():\n        if freq < minFreq:\n          deletions += freq\n        else:\n          deletions += max(0, freq - (minFreq + k))\n      ans = min(ans, deletions)\n\n    return ans",
      "title": "3085. Minimum Deletions to Make String K-Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdec1f54-a3cc-4093-b106-d6ab32ba332c",
      "code": "class Solution:\n  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:\n    # Dylan has two actions for collecting '1's in a sequence:\n    # Action 1: Put a '1' next to him and pick it up.\n    #           The cost is 2.\n    # Action 2: Swap a '1' towards him and collect it.\n    #           The cost equals the distance to the '1'.\n    #\n    # To minimize the swapping cost, Dylan can use a sliding window strategy,\n    # selecting the optimal position (middle '1' in the window) for efficient\n    # collection. The window's size is crucial:\n\n    # The minimum window size: min(0, k - maxChanges), ensuring the window\n    # isn't too small.\n    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    # preventing overly ambitious swaps.\n    #\n    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    # cheaper to use Action 1.\n\n    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    # a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    # should be replaced with Action 1.\n    NUM_OF_INDICES_WITHIN_ONE_DISTANCE = 3\n    ans = math.inf\n    oneIndices = [i for i, num in enumerate(nums) if num == 1]\n    prefix = list(itertools.accumulate(oneIndices, initial=0))\n\n    minOnesByTwo = max(0, k - maxChanges)\n    maxOnesByTwo = min(\n        k, minOnesByTwo + NUM_OF_INDICES_WITHIN_ONE_DISTANCE, len(oneIndices))\n\n    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):\n      for l in range(len(prefix) - onesByTwo):\n        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].\n        cost1 = (k - onesByTwo) * 2\n        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -\n                 (prefix[(l + r + 1) // 2] - prefix[l]))\n        ans = min(ans, cost1 + cost2)\n\n    return ans",
      "title": "3086. Minimum Moves to Pick K Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85f7520e-95d7-47c6-8b4a-15409b9b2ddc",
      "code": "class Solution:\n  def makeAntiPalindrome(self, s: str) -> str:\n    n = len(s)\n    i = n // 2\n    chars = sorted(list(s))\n    if chars[i] != chars[n - 1 - i]:\n      return ''.join(chars)\n\n    j = self._getFirstDiffIndexInSecondHalf(chars)\n    while chars[i] == chars[n - 1 - i]:\n      if j == n:\n        return '-1'\n      chars[i], chars[j] = chars[j], chars[i]\n      i += 1\n      j += 1\n\n    return ''.join(chars)\n\n  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:\n    \"\"\"\n    Returns the first index in chars[n / 2..n) that is different from the first\n    letter of the second half, chars[n / 2].\n    \"\"\"\n    n = len(chars)\n    firstLetter = chars[n // 2]\n    firstDiffIndex = n // 2\n    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:\n      firstDiffIndex += 1\n    return firstDiffIndex",
      "title": "3088. Make String Anti-palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96f07ffe-48d4-4f0e-abaf-6253136222f5",
      "code": "class Solution:\n  def maximumLengthSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 2:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "3090. Maximum Length Substring With Two Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6d2da72-84d9-4c08-a5b3-92adf11aa107",
      "code": "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.ceil(math.sqrt(k))\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y",
      "title": "3091. Apply Operations to Make Sum of Array Greater Than or Equal to k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0569ba7-45b0-4149-9000-a5cd6d37b094",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:\n    ans = []\n    numCount = collections.Counter()  # {num: freq}\n    freqCount = SortedDict()  # {num's freq: freq}\n\n    for num, f in zip(nums, freq):\n      if numCount[num] > 0:\n        numFreq = numCount[num]\n        freqCount[numFreq] -= 1\n        if freqCount[numFreq] == 0:\n          del freqCount[numFreq]\n      newFreq = numCount[num] + f\n      if newFreq == 0:\n        del numCount[num]\n      else:\n        numCount[num] = newFreq\n        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1\n      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)\n\n    return ans",
      "title": "3092. Most Frequent IDs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ef53e2e-452f-4d57-a488-60591671e58d",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n    self.length = math.inf\n    self.index = -1\n\n\nclass Solution:\n  def stringIndices(\n      self,\n      wordsContainer: list[str],\n      wordsQuery: list[str],\n  ) -> list[int]:\n    ans = []\n    root = TrieNode()\n    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]\n\n    def insert(word: str, index: int) -> None:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n        if node.length > len(word):\n          node.length = len(word)\n          node.index = index\n\n    def search(word: str) -> int:\n      node = root\n      for c in reversed(word):\n        if c not in node.children:\n          return node.index\n        node = node.children[c]\n      return node.index\n\n    for i, word in enumerate(wordsContainer):\n      insert(word, i)\n\n    for query in wordsQuery:\n      index = search(query)\n      ans.append(minIndex if index == -1 else index)\n\n    return ans",
      "title": "3093. Longest Common Suffix Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c53d811-d276-42ce-acc1-6389f3b49187",
      "code": "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    ans = 0\n    sameCount = commonBits(0)\n\n    for i in range(31):\n      if commonBits(1 << i) > sameCount:\n        ans |= 1 << i\n      commonBits(1 << i)  # Revert the XOR.\n\n    return ans",
      "title": "3094. Guess the Number Using Bitwise Questions II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90e0f5e3-986b-42b2-84df-72631d6325e6",
      "code": "class Solution:\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3095. Shortest Subarray With OR at Least K I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82eb5941-c009-40b1-91e1-f6f42369009e",
      "code": "class Solution:\n  def minimumLevels(self, possible: list[int]) -> int:\n    n = len(possible)\n    nums = [num if num == 1 else -1 for num in possible]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n):\n      if prefix[i] > prefix[n] - prefix[i]:\n        return i\n\n    return -1",
      "title": "3096. Minimum Levels to Gain More Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5815c11-9bf9-424b-99ab-ed8ece7efe4d",
      "code": "class Solution:\n  # Same as 3095. Shortest Subarray With OR at Least K I\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3097. Shortest Subarray With OR at Least K II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d157d03a-eee2-4f12-b722-5952ee6766cf",
      "code": "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        k: int,\n        lastPickedIndex: int,\n        firstIndex: int,\n        secondIndex: int\n    ) -> int:\n      if k == 0:\n        return nums[secondIndex] - nums[firstIndex]\n      if i == len(nums):\n        return 0\n      newFirstIndex = firstIndex\n      newSecondIndex = secondIndex\n      if firstIndex == -1:\n        newFirstIndex = i\n      elif secondIndex == -1:\n        newSecondIndex = i\n      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:\n        newFirstIndex = lastPickedIndex\n        newSecondIndex = i\n      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)\n      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, -1, -1)",
      "title": "3098. Find the Sum of Subsequence Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc665c07-4342-46e6-b03e-656bca7075b9",
      "code": "class Solution:\n  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n    digitSum = self._getDigitSum(x)\n    return digitSum if x % digitSum == 0 else -1\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3099. Harshad Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0c1b380-0f13-47e8-9b39-51f391743c3d",
      "code": "class Solution:\n  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n    ans = numBottles\n\n    while numBottles >= numExchange:\n      numBottles = numBottles - numExchange + 1\n      numExchange += 1\n      ans += 1\n\n    return ans",
      "title": "3100. Water Bottles II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9aad98c0-b92b-4190-a77d-8889dfa39b52",
      "code": "class Solution:\n  def countAlternatingSubarrays(self, nums: list[int]) -> int:\n    # dp[i] := the number of alternating subarrays ending in index i\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1]:\n        dp[i] += dp[i - 1]\n\n    return sum(dp)",
      "title": "3101. Count Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0784398-2d41-46a0-93af-df84677315c3",
      "code": "class Solution:\n  def minimumDistance(self, points: list[list[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi),\n               self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(\n      self,\n      points: list[list[int]],\n      excludedIndex: int,\n  ) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff\n            else [minDiffIndex, maxDiffIndex])\n\n  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])",
      "title": "3102. Minimize Manhattan Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9b65eab-61fa-42d8-af51-d941633f9f8e",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str) -> int:\n    allCount = collections.Counter(s)\n\n    # Similar to 395. Longest Substring with At Least K Repeating Characters\n    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:\n      res = -1\n      # the number of unique letters\n      uniqueLetters = 0\n      # the number of letters that have all their frequency in the substring\n      lettersHavingAllFreq = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == allCount[c]:\n          lettersHavingAllFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == allCount[s[l]]:\n            lettersHavingAllFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having all their frequency are equal to n, this is a valid window.\n        # Implcit: uniqueLetters == n\n        if lettersHavingAllFreq == n and r - l + 1 < len(s):\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(maxSubstringLengthWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "3104. Find Longest Self-Contained Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77eaa1c8-7deb-4d82-b0e2-598a1db58ad9",
      "code": "class Solution:\n  # Similar to 978. Longest Turbulent Subarray\n  def longestMonotonicSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        increasing += 1\n        decreasing = 1\n      elif nums[i] < nums[i - 1]:\n        decreasing += 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, increasing, decreasing)\n\n    return ans",
      "title": "3105. Longest Strictly Increasing or Strictly Decreasing Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1030e8be-0449-4144-b0d7-23ee5fcfcad3",
      "code": "class Solution:\n  def getSmallestString(self, s: str, k: int) -> str:\n    ans = list(s)\n\n    for i, c in enumerate(s):\n      if k == 0:\n        break\n      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n      if k >= distToA:\n        k -= distToA\n        ans[i] = 'a'\n      else:\n        # k is not enough to change the current letter to 'a', so move as closer\n        # to 'a' as possible.\n        ans[i] = chr(ord(c) - k)\n        k = 0\n\n    return ''.join(ans)",
      "title": "3106. Lexicographically Smallest String After Operations With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c396fe50-3c2f-4857-8e87-fc68ab047c5c",
      "code": "class Solution:\n  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    for i in range(n // 2 + 1):\n      ans += max(0, nums[i] - k)\n\n    for i in range(n // 2, n):\n      ans += max(0, k - nums[i])\n\n    return ans",
      "title": "3107. Minimum Operations to Make Median of Array Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "789367c7-3ba5-42db-96b7-a1d8dca6e461",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    return self.weight[i] if i == j else -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]",
      "title": "3108. Minimum Cost Walk in Weighted Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb155a05-867b-47a5-84ae-a68e3c339dc7",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getPermutationIndex(self, perm: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(perm)\n    ans = 0\n    tree = FenwickTree(n)\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = (fact[i - 1] * i) % MOD\n\n    for i, num in enumerate(perm):\n      # the number of unused numbers less than `num`\n      unusedNums = num - 1 - tree.get(num - 1)\n      suffixLength = fact[n - 1 - i]\n      ans += unusedNums * suffixLength\n      ans %= MOD\n      tree.add(num, 1)\n\n    return ans",
      "title": "3109. Find the Index of Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60416d42-dbaa-4a37-9f84-d78dcd8f14b2",
      "code": "class Solution:\n  def scoreOfString(self, s: str) -> int:\n    return sum(abs(ord(a) - ord(b))\n               for a, b in itertools.pairwise(s))",
      "title": "3110. Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d6c2ca9-c5d4-40b0-903e-79b470b0fdd5",
      "code": "class Solution:\n  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:\n    ans = 0\n    prevX = -w - 1\n    xs = sorted([x for x, _ in points])\n\n    for x in xs:\n      if x > prevX + w:\n        ans += 1\n        prevX = x\n\n    return ans",
      "title": "3111. Minimum Rectangles to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a34b6cd-b849-4779-8bd8-f5364b579957",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      edges: list[list[int]],\n      disappear: list[int],\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      disappear: list[int],\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return [d if d != math.inf else -1\n            for d in dist]",
      "title": "3112. Minimum Time to Visit Disappearing Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a3eb480-3e68-4449-b5ce-6cf93a3ae1b4",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1][0] < num:\n        stack.pop()\n      if not stack or stack[-1][0] != num:\n        stack.append([num, 0])\n      stack[-1][1] += 1\n      ans += stack[-1][1]\n\n    return ans",
      "title": "3113. Find the Number of Subarrays Where Boundary Elements Are Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f534fc4-db69-42cb-b2a1-986f978b8b90",
      "code": "class Solution:\n  # Similar to 1736. Latest Time by Replacing Hidden Digits\n  def findLatestTime(self, s: str) -> str:\n    ans = list(s)\n    if s[0] == '?':\n      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'\n    if s[1] == '?':\n      ans[1] = '1' if ans[0] == '1' else '9'\n    if s[3] == '?':\n      ans[3] = '5'\n    if s[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "3114. Latest Time You Can Obtain After Replacing Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0170a6d3-28eb-494d-98a1-059a6cf4fde1",
      "code": "class Solution:\n  def maximumPrimeDifference(self, nums: list[int]) -> int:\n    MAX = 100\n    isPrime = self._sieveEratosthenes(MAX + 1)\n    minPrimeIndex = -1\n    maxPrimeIndex = -1\n\n    for i, num in enumerate(nums):\n      if isPrime[num]:\n        if minPrimeIndex == -1:\n          minPrimeIndex = i\n        maxPrimeIndex = i\n\n    return maxPrimeIndex - minPrimeIndex\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3115. Maximum Prime Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b2af8d3-b044-42e7-b3fd-0e99aeceda00",
      "code": "class Solution:\n  def findKthSmallest(self, coins: list[int], k: int) -> int:\n    sizeToLcms = self._getSizeToLcms(coins)\n\n    def count(m: int) -> int:\n      \"\"\"Returns the number of denominations <= m.\"\"\"\n      res = 0\n      for sz, lcms in enumerate(sizeToLcms):\n        for lcm in lcms:\n          # Principle of Inclusion-Exclusion (PIE)\n          res += m // lcm * pow(-1, sz + 1)\n      return res\n\n    return bisect.bisect_left(range(k * min(coins)), k, key=count)\n\n  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:\n    # Returns the LCMs for each number of combination of coins.\n    sizeToLcms = [[] for _ in range(len(coins) + 1)]\n    for sz in range(1, len(coins) + 1):\n      for combination in itertools.combinations(coins, sz):\n        sizeToLcms[sz].append(math.lcm(*combination))\n    return sizeToLcms",
      "title": "3116. Kth Smallest Amount With Single Denomination Combination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd9dfbf5-d75d-4d40-8956-bb16821cd8fe",
      "code": "class Solution:\n  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:\n    n = len(nums)\n    m = len(andValues)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n      `mask` is the running value of the current subarray.\n      \"\"\"\n      if i == n and j == m:\n        return 0\n      if i == n or j == m:\n        return math.inf\n      mask &= nums[i]\n      if mask < andValues[j]:\n        return math.inf\n      if mask == andValues[j]:\n        # 1. Keep going.\n        # 2. End the subarray here and pick nums[i], then fresh start.\n        return min(dp(i + 1, j, mask),\n                   nums[i] + dp(i + 1, j + 1, -1))\n      return dp(i + 1, j, mask)  # Keep going.\n\n    ans = dp(0, 0, -1)\n    return ans if ans < math.inf else -1",
      "title": "3117. Minimum Sum of Values by Dividing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "097d920c-2443-486d-b488-0b2cf098a0c9",
      "code": "class Solution:\n  def maxPotholes(self, road: str, budget: int) -> int:\n    ans = 0\n\n    for length in sorted(map(len, road.split('.')), reverse=True):\n      canRepair = max(0, budget - 1)\n      if length > canRepair:\n        return ans + canRepair\n      ans += length\n      budget -= length + 1\n\n    return ans",
      "title": "3119. Maximum Number of Potholes That Can Be Fixed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37429895-c86d-4849-8bda-d8a145457f5c",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = True\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3120. Count the Number of Special Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "230b16fa-b6ce-4d01-b47b-9370f7a7ee6a",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = not upper[c.upper()]\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3121. Count the Number of Special Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec95a1f7-eb02-4b61-b63b-6d077f29a6d5",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    count = [[0] * 10 for _ in range(n)]\n\n    for row in grid:\n      for j, num in enumerate(row):\n        count[j][num] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of minimum operations needed to make grid[:][j..n)\n      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n      \"\"\"\n      if i == n:\n        return 0\n\n      res = math.inf\n\n      for num in range(10):\n        if i == 0 or num != prev:\n          res = min(res, m - count[i][num] + dp(i + 1, num))\n\n      return res\n\n    return dp(0, 0)",
      "title": "3122. Minimum Number of Operations to Satisfy Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc423af8-229d-4ec3-bd5f-53fbc9764742",
      "code": "class Solution:\n  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or\n            from0[v] + w + from1[u] == from0[-1]\n            for u, v, w in edges]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "3123. Find Edges in Shortest Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c0630f1-9c57-4984-bc14-4ecc2701c0db",
      "code": "class Solution:\n  def maxNumber(self, n: int) -> int:\n    # assume n = 0b00...11???\n    #        x = 0b00...01111\n    #  since y = 0b00...10000 is in [x, n]\n    #    and x & y = 0\n    return (1 << n.bit_length() - 1) - 1",
      "title": "3125. Maximum Number That Makes Result of Bitwise AND Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba32725b-889f-4235-bb72-5cf59b873204",
      "code": "class Solution:\n  def canMakeSquare(self, grid: list[list[str]]) -> bool:\n    for i in range(2):\n      for j in range(2):\n        black = 0\n        white = 0\n        for x in range(2):\n          for y in range(2):\n            if grid[i + x][j + y] == 'B':\n              black += 1\n            else:\n              white += 1\n        if black >= 3 or white >= 3:\n          return True\n    return False",
      "title": "3127. Make a Square with the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1e59a9f-b2ad-4c3f-b03a-f92f3a2b7ed4",
      "code": "class Solution:\n  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    return sum((rows[i] - 1) * (cols[j] - 1)\n               for i, row in enumerate(grid)\n               for j, num in enumerate(row)\n               if num == 1)",
      "title": "3128. Right Triangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f27b904-2056-490b-a5fd-2023a8c0b121",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n           for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3129. Find All Possible Stable Binary Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2465854-fb3a-46f9-8086-7fd82434dad9",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n          for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3130. Find All Possible Stable Binary Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b16105bb-e9b3-4c5e-9a8b-bd4000ddf07a",
      "code": "class Solution:\n  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(nums2) - min(nums1)",
      "title": "3131. Find the Integer Added to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94615bee-31e0-4d7e-8685-b0acdacaad69",
      "code": "class Solution:\n  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    # After removing two elements from nums1, either nums1[0], nums1[1], or\n    # nums1[2] will persist. Therefore, the difference between nums1 (with two\n    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    # 0 <= i <= 2.\n    ans = math.inf\n\n    nums1.sort()\n    nums2.sort()\n\n    for i in range(3):\n      inc = nums2[0] - nums1[i]\n      if self._isValidDiff(nums1, nums2, inc):\n        ans = min(ans, inc)\n\n    return ans\n\n  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:\n    \"\"\"\n    Returns True if it's possible to increase nums1 (with two elements removed)\n    by `inc` to nums2.\n    \"\"\"\n    removed = 0\n    i = 0  # nums2's index\n\n    for num in nums1:\n      if num + inc == nums2[i]:\n        i += 1\n        if i == len(nums2):\n          break\n      else:\n        removed += 1\n\n    return removed <= 2",
      "title": "3132. Find the Integer Added to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5989a772-a351-4f7b-9466-11f9d64ae4c0",
      "code": "class Solution:\n  def minEnd(self, n: int, x: int) -> int:\n    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    # operation increase x for (n - 1) iterations while preserving x's 1s.\n    MAX_BIT = n.bit_length() + x.bit_length()\n    k = n - 1\n    BINARY_INDEX = 0\n\n    for i in range(MAX_BIT):\n      if x >> i & 1 == 0:\n        # Set x's 0 with k's bit if the running bit of k is 1.\n        if k >> BINARY_INDEX & 1:\n          x |= 1 << i\n        BINARY_INDEX += 1\n\n    return x",
      "title": "3133. Minimum Array End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46198fc2-1f16-43a2-86d5-77c38e53ec17",
      "code": "class Solution:\n  def medianOfUniquenessArray(self, nums: list[int]):\n    n = len(nums)\n    subarrayCount = n * (n + 1) // 2\n    medianCount = (subarrayCount + 1) // 2\n\n    # Similar to 992. Subarrays with K Different Integers\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    l = 1\n    r = n\n    return bisect.bisect_left(range(l, r), medianCount,\n                              key=subarraysWithAtMostKDistinct) + l",
      "title": "3134. Find the Median of the Uniqueness Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "193d9243-b2a6-4a42-ab58-82f237548794",
      "code": "class Solution:\n  def minOperations(self, initial: str, target: str) -> int:\n    m = len(initial)\n    n = len(target)\n    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if initial[i - 1] == target[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n\n    return m + n - 2 * max(map(max, dp))",
      "title": "3135. Equalize Strings by Adding or Removing Characters at Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a86da666-2dd8-4ddb-8b8a-5c76a57e5913",
      "code": "class Solution:\n  def isValid(self, word: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n\n    def isConsonant(c: str) -> bool:\n      return c.isalpha() and c not in VOWELS\n\n    return (len(word) >= 3 and\n            all(c.isalnum() for c in word) and\n            any(c in VOWELS for c in word) and\n            any(isConsonant(c) for c in word))",
      "title": "3136. Valid Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f070e715-b290-4b55-8a91-283427bd84d6",
      "code": "class Solution:\n  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))\n    return len(word) // k - max(count.values())",
      "title": "3137. Minimum Number of Operations to Make Word K-Periodic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa98bca9-2b19-459a-bba3-26de9a23749f",
      "code": "class Solution:\n  def minAnagramLength(self, s: str) -> int:\n    n = len(s)\n    for k in range(1, n + 1):\n      if n % k == 0 and self._canFormAnagram(s, k):\n        return k\n    return n\n\n  def _canFormAnagram(self, s: str, k: int) -> bool:\n    \"\"\"Returns True if we can concatenate an anagram of length k to s.\"\"\"\n    anagramCount = collections.Counter(s[:k])\n    return all(collections.Counter(s[i:i + k]) == anagramCount\n               for i in range(k, len(s), k))",
      "title": "3138. Minimum Length of Anagram Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6116664-f63f-4fb7-85d7-943ff124db52",
      "code": "class Solution:\n  def minCostToEqualizeArray(\n      self,\n      nums: list[int],\n      cost1: int,\n      cost2: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    minNum = min(nums)\n    maxNum = max(nums)\n    summ = sum(nums)\n\n    if cost1 * 2 <= cost2 or n < 3:\n      totalGap = maxNum * n - summ\n      return (cost1 * totalGap) % MOD\n\n    def getMinCost(target: int) -> int:\n      \"\"\"Returns the minimum cost to make all numbers equal to `target`.\"\"\"\n      maxGap = target - minNum\n      totalGap = target * n - summ\n      # Pair one shallowest number with one non-shallowest number, so the worst\n      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.\n      pairs = min(totalGap // 2, totalGap - maxGap)\n      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs\n\n    return min(getMinCost(target)\n               for target in range(maxNum, 2 * maxNum)) % MOD",
      "title": "3139. Minimum Cost to Equalize Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edc3ce3d-60dc-4940-9710-6fed5ed0b141",
      "code": "class Solution:\n  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:\n    MAX_MASK = 1 << m\n    # dp[i] := the maximum hamming distance from i to any number in `nums`\n    dp = [-math.inf] * MAX_MASK\n\n    for num in nums:\n      dp[num] = 0\n\n    for bit in range(m):\n      newDp = [0] * MAX_MASK\n      for mask in range(MAX_MASK):\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)\n      dp = newDp\n\n    return [dp[num] for num in nums]",
      "title": "3141. Maximum Hamming Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d33472b-a78d-49e5-a201-31ef8094c13d",
      "code": "class Solution:\n  def satisfiesConditions(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    return (all(grid[i][j] == grid[i + 1][j]\n                for i in range(m - 1)\n                for j in range(n)) and\n            all(grid[i][j] != grid[i][j + 1]\n                for i in range(m)\n                for j in range(n - 1)))",
      "title": "3142. Check if Grid Satisfies Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69e3a7d1-cc8e-45c3-8573-4d33905f17a7",
      "code": "class Solution:\n  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:\n    secondMinSize = math.inf\n    minSizes = {}\n\n    for (x, y), c in zip(points, s):\n      sz = max(abs(x), abs(y))\n      if c not in minSizes:\n        minSizes[c] = sz\n      elif sz < minSizes[c]:\n        # This is because minSizes[j] is about to be replaced by a smaller\n        # value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[c])\n        minSizes[c] = sz\n      else:\n        # `sz` is not smaller than the current minimum size, but it could be\n        # smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz)\n\n    return sum(sz < secondMinSize for sz in minSizes.values())",
      "title": "3143. Maximum Points Inside the Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f61f0cd-60df-408c-8ab4-05dfeddfeea8",
      "code": "class Solution:\n  def minimumSubstringsInPartition(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of substrings in s[0..i]\n    dp = [n] * n\n\n    for i in range(n):\n      count = collections.Counter()\n      for j in range(i, -1, -1):\n        count[s[j]] += 1\n        # word[j..i] is balanced.\n        if min(count.values()) == max(count.values()):\n          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)\n\n    return dp[-1]",
      "title": "3144. Minimum Substring Partition of Equal Character Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "896b072a-d3bc-45fc-9fa7-002c93537a78",
      "code": "class Solution:\n  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:\n    def sumBitsTill(x: int) -> int:\n      \"\"\"Returns sum(i.bit_count()), where 1 <= i <= x.\"\"\"\n      sumBits = 0\n      powerOfTwo = 1\n      while powerOfTwo <= x:\n        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo\n        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)\n        powerOfTwo *= 2\n      return sumBits\n\n    def sumPowersTill(x: int) -> int:\n      \"\"\"Returns sum(all powers of i), where 1 <= i <= x.\"\"\"\n      sumPowers = 0\n      powerOfTwo = 1\n      for power in range(x.bit_length()):\n        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power\n        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power\n        powerOfTwo *= 2\n      return sumPowers\n\n    def sumPowersFirstKBigNums(k: int) -> int:\n      \"\"\"Returns the sum of powers of the first k numbers in `big_nums`.\"\"\"\n      # Find the first number in [1, k] that has sumBitsTill(num) >= k.\n      num = bisect.bisect_left(range(k), k, key=sumBitsTill)\n      sumPowers = sumPowersTill(num - 1)\n      remainingCount = k - sumBitsTill(num - 1)\n      for power in range(num.bit_length()):\n        if num >> power & 1:\n          sumPowers += power\n          remainingCount -= 1\n          if remainingCount == 0:\n            break\n      return sumPowers\n\n    return [pow(2,\n                sumPowersFirstKBigNums(b + 1) -\n                sumPowersFirstKBigNums(a), mod)\n            for a, b, mod in queries]",
      "title": "3145. Find Products of Elements of Big Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b9e77b8-a313-44d1-8a49-2fb13f0e744f",
      "code": "class Solution:\n  def findPermutationDifference(self, s: str, t: str) -> int:\n    indices = {c: i for i, c in enumerate(s)}\n    return sum([abs(indices[c] - i) for i, c in enumerate(t)])",
      "title": "3146. Permutation Difference between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f60161a3-064c-4a25-b2ff-8e998077e8dd",
      "code": "class Solution:\n  def maximumEnergy(self, energy: list[int], k: int) -> int:\n    # dp[i] := the sum of energy starting at i\n    dp = energy.copy()\n    for i in range(len(energy) - 1 - k, -1, -1):\n      dp[i] += dp[i + k]\n    return max(dp)",
      "title": "3147. Taking Maximum Energy From the Mystic Dungeon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "082f3bfd-5279-482b-9a64-3185bf1ec2e0",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    MAX = 200000\n    ans = -MAX\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        prevMin = min(grid[i - 1][j] if i > 0 else MAX,\n                      grid[i][j - 1] if j > 0 else MAX)\n        ans = max(ans, num - prevMin)\n        grid[i][j] = min(num, prevMin)\n\n    return ans",
      "title": "3148. Maximum Difference Score in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b95944d5-1198-44bb-a135-9b0976f0b154",
      "code": "class Solution:\n  def findPermutation(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    bestPick = [[0] * (1 << n) for _ in range(n)]\n\n    @functools.lru_cache(None)\n    def getScore(last: int, mask: int) -> int:\n      if mask.bit_count() == len(nums):\n        return abs(last - nums[0])\n\n      minScore = math.inf\n      for i in range(1, len(nums)):\n        if mask >> i & 1:\n          continue\n        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))\n        if nextMinScore < minScore:\n          minScore = nextMinScore\n          bestPick[last][mask] = i\n\n      return minScore\n\n    getScore(0, 1)\n    return self._construct(bestPick)\n\n  def _construct(self, bestPick: list[list[int]]) -> list[int]:\n    ans = []\n    last = 0\n    mask = 1\n    for _ in range(len(bestPick)):\n      ans.append(last)\n      last = bestPick[last][mask]\n      mask |= 1 << last\n    return ans",
      "title": "3149. Find the Minimum Cost Array Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d152741a-13c4-444a-ad4e-8135ae4d919b",
      "code": "class Solution:\n  def isArraySpecial(self, nums: list[int]) -> bool:\n    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))",
      "title": "3151. Special Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40c584df-25c8-4a7d-a027-345c2ca886de",
      "code": "class Solution:\n  def isArraySpecial(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    id = 0\n    # parityIds[i] := the id of the parity group that nums[i] belongs to\n    parityIds = [id]\n\n    for a, b in itertools.pairwise(nums):\n      if a % 2 == b % 2:\n        id += 1\n      parityIds.append(id)\n\n    for _from, to in queries:\n      ans.append(parityIds[_from] == parityIds[to])\n\n    return ans",
      "title": "3152. Special Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "945ce522-1dcd-43e9-9a96-cb36df0865f3",
      "code": "class Solution:\n  def sumDigitDifferences(self, nums: list[int]) -> int:\n    n = len(nums)\n    digitSize = len(str(nums[0]))\n    ans = 0\n\n    denominator = 1\n    for _ in range(digitSize):\n      count = [0] * 10\n      for num in nums:\n        count[num // denominator % 10] += 1\n      ans += sum(freq * (n - freq) for freq in count)\n      denominator *= 10\n\n    return ans // 2",
      "title": "3153. Sum of Digit Differences of All Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69041ef7-5258-4b47-a9be-437359342707",
      "code": "class Solution:\n  def waysToReachStair(self, k: int) -> int:\n    # Let's say we have `down` operation 1 and `jump` operation 2.\n    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    # => 1 + (2^jump - 1) - down = k.\n    # => down = 2^jump - k.\n    # Since `down` operations cannot be used consecutively, there're jump + 1\n    # positions (before and after each `jump`) for  `down`. The maximum jump is\n    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    # being the maximum value of 10^9.\n    MAX_JUMP = 29\n    ans = 0\n\n    for jump in range(MAX_JUMP + 1):\n      down = (1 << jump) - k\n      if down < 0 or down > jump + 1:\n        continue\n      ans += math.comb(jump + 1, down)\n\n    return ans",
      "title": "3154. Find Number of Ways to Reach the K-th Stair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a3e7372-8322-412b-bb78-a0c48654b2fd",
      "code": "class Solution:\n  def maxUpgrades(\n      self,\n      count: list[int],\n      upgrade: list[int],\n      sell: list[int],\n      money: list[int],\n  ) -> list[int]:\n    # If there's enough money, upgrade all servers; otherwise, optimize by\n    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    # Therefore, x = (money + count * sell) / (sell + upgrade).\n    return [min(c, (m + c * s) // (s + u))\n            for c, u, s, m in zip(count, upgrade, sell, money)]",
      "title": "3155. Maximum Number of Upgradable Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b039320c-1b55-4707-b9f4-95bdf433178a",
      "code": "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    ans = 0\n    minLevelSum = math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum < minLevelSum:\n        minLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "3157. Find the Level of Tree with Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afb4cd37-ce43-4b4e-9410-8571f9f8551e",
      "code": "class Solution:\n  def duplicateNumbersXOR(self, nums):\n    count = collections.Counter(nums)\n    return functools.reduce(\n        operator.xor, [num for num, freq in count.items() if freq == 2],\n        0)",
      "title": "3158. Find the XOR of Numbers Which Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b05ada3a-57ee-43d1-bae9-7c032e3db1ba",
      "code": "class Solution:\n  def occurrencesOfElement(\n      self,\n      nums: list[int],\n      queries: list[int],\n      x: int,\n  ) -> list[int]:\n    indices = [i for i, num in enumerate(nums) if num == x]\n    return [indices[query - 1] if query <= len(indices) else -1\n            for query in queries]",
      "title": "3159. Find Occurrences of an Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd35c0b7-a185-4e1a-a1b2-de48efea6f0e",
      "code": "class Solution:\n  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    ballToColor = {}\n    colorCount = collections.Counter()\n\n    for ball, color in queries:\n      if ball in ballToColor:\n        prevColor = ballToColor[ball]\n        colorCount[prevColor] -= 1\n        if colorCount[prevColor] == 0:\n          del colorCount[prevColor]\n      ballToColor[ball] = color\n      colorCount[color] += 1\n      ans.append(len(colorCount))\n\n    return ans",
      "title": "3160. Find the Number of Distinct Colors Among the Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfa40ca1-9704-4380-b418-2fba5feb6da0",
      "code": "from sortedcontainers import SortedList\n\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowtree(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowtree(i)\n    return res\n\n  @staticmethod\n  def lowtree(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getResults(self, queries: list[list[int]]) -> list[bool]:\n    n = min(50000, len(queries) * 3)\n    ans = []\n    tree = FenwickTree(n + 1)\n    obstacles = SortedList([0, n])  # sentinel values\n\n    for query in queries:\n      type = query[0]\n      if type == 1:\n        x = query[1]\n        obstacles.add(x)\n\n    for x1, x2 in itertools.pairwise(obstacles):\n      tree.maximize(x2, x2 - x1)\n\n    for query in reversed(queries):\n      type = query[0]\n      x = query[1]\n      if type == 1:\n        i = obstacles.index(x)\n        next = obstacles[i + 1]\n        prev = obstacles[i - 1]\n        obstacles.remove(x)\n        tree.maximize(next, next - prev)\n      else:\n        sz = query[2]\n        i = obstacles.bisect_right(x)\n        prev = obstacles[i - 1]\n        ans.append(tree.get(prev) >= sz or x - prev >= sz)\n\n    return ans[::-1]",
      "title": "3161. Block Placement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea080363-eb17-46db-977a-7d9e69a20644",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    return sum(num1 % (num2 * k) == 0\n               for num1 in nums1\n               for num2 in nums2)",
      "title": "3162. Find the Number of Good Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1eb51301-44c2-4952-bb79-2721f5ef9eff",
      "code": "class Solution:\n  def compressedString(self, word: str) -> str:\n    n = len(word)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      count = 0\n      while j < n and word[j] == word[i] and count < 9:\n        j += 1\n        count += 1\n      ans.append(str(count) + word[i])\n      i = j\n\n    return ''.join(ans)",
      "title": "3163. String Compression III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26afc4bf-2e24-4dc9-ad35-1f3b86ab8309",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    count = collections.Counter(num * k for num in nums2)\n    ans = 0\n\n    for num in nums1:\n      for divisor in range(1, int(num ** 0.5) + 1):\n        if num % divisor == 0:\n          ans += count[divisor]\n          if num // divisor != divisor:\n            ans += count[num // divisor]\n\n    return ans",
      "title": "3164. Find the Number of Good Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9e2869d-23c2-46e8-b99b-505afce35bcf",
      "code": "class Solution:\n  def betterCompression(self, compressed: str) -> str:\n    count = collections.Counter()\n    i = 0\n\n    while i < len(compressed):\n      c = compressed[i]\n      i += 1\n      freq = 0\n      while i < len(compressed) and compressed[i].isdigit():\n        freq = freq * 10 + int(compressed[i])\n        i += 1\n      count[c] += freq\n\n    return ''.join([c + str(count[c])\n                    for c in sorted(count.keys())])",
      "title": "3167. Better Compression of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0069ef6-4e9b-43d6-b82c-b8a437aadda5",
      "code": "class Solution:\n  def minimumChairs(self, s: str) -> int:\n    ans = 0\n    chairs = 0\n\n    for c in s:\n      chairs += 1 if c == 'E' else -1\n      ans = max(ans, chairs)\n\n    return ans",
      "title": "3168. Minimum Number of Chairs in a Waiting Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24daac48-0287-4f8b-9fce-6f5fdaf00f09",
      "code": "class Solution:\n  def countDays(self, days: int, meetings: list[list[int]]) -> int:\n    freeDays = 0\n    prevEnd = 0\n\n    for start, end in sorted(meetings):\n      if start > prevEnd:\n        freeDays += start - prevEnd - 1\n      prevEnd = max(prevEnd, end)\n\n    return freeDays + max(0, days - prevEnd)",
      "title": "3169. Count Days Without Meetings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fc3d00f-9197-4058-b853-3e2f53c7334b",
      "code": "class Solution:\n  def clearStars(self, s: str) -> str:\n    ans = list(s)\n    buckets = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      if c == '*':\n        ans[i] = ''\n        j = next(j for j, bucket in enumerate(buckets) if bucket)\n        ans[buckets[j].pop()] = ''\n      else:\n        buckets[ord(c) - ord('a')].append(i)\n\n    return ''.join(ans)",
      "title": "3170. Lexicographically Minimum String After Removing Stars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8d5017b-10a0-4a17-a6fa-8aaa6928494e",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in nums:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the OR operation, the size of `next_set` will be at most\n      # bin(num).count('1') + 1.\n      dp = {num} | {val | num for val in dp}\n      ans = min(ans, min(abs(k - val) for val in dp))\n\n    return ans",
      "title": "3171. Find Subarray With Bitwise AND Closest to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94fd900a-fb58-4d4d-92d0-c62405b5f3c0",
      "code": "class Solution:\n  def orArray(self, nums: list[int]) -> list[int]:\n    return [a | b for a, b in itertools.pairwise(nums)]",
      "title": "3173. Bitwise OR of Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe50bc98-54f4-4932-8617-0ad17421f2f4",
      "code": "class Solution:\n  def clearDigits(self, s: str) -> str:\n    ans = []\n\n    for c in s:\n      if c.isdigit():\n        # Since `ans` only contains non-digit characters, removing the last\n        # character is equivalent to deleting the closest non-digit character.\n        ans.pop()\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3174. Clear Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bd0adf5-03d0-42cc-8a3c-197c1df46f07",
      "code": "class Solution:\n  # Similar to 1535. Find the Winner of an Array Game\n  def findWinningPlayer(self, skills: list[int], k: int) -> int:\n    ans = 0\n    wins = 0\n\n    i = 1\n    while i < len(skills) and wins < k:\n      if skills[i] > skills[ans]:\n        ans = i\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "3175. Find The First Player to win K Games in a Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98bb31ef-b0a2-4f9d-a58a-0286a1e32b4e",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3176. Find the Maximum Length of a Good Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39bdda2e-d29b-47e4-bf50-c23c722acc9e",
      "code": "class Solution:\n  # Same as 3176. Find the Maximum Length of a Good Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3177. Find the Maximum Length of a Good Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32f90167-90d6-4fb9-a9a9-2e78fcae8b09",
      "code": "class Solution:\n  def numberOfChild(self, n: int, k: int) -> int:\n    # the time for the ball to return to 0\n    roundTime = 2 * (n - 1)\n    pos = k % roundTime\n    return pos if pos < n else roundTime - pos",
      "title": "3178. Find the Child Who Has the Ball After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cc8c06a-4679-4ed6-9c8e-f61794264ecc",
      "code": "class Solution:\n  def valueAfterKSeconds(self, n: int, k: int) -> int:\n    return math.comb(n + k - 1, n - 1) % 1_000_000_007",
      "title": "3179. Find the N-th Value After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9abf6f0f-7d48-46bd-b155-e8c0f06de5b9",
      "code": "# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n# `rewardValue` is achievable in O(1).\n#\n# Let's use `rewardValues = [1, 3, 4]` as an example.\n#\n# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n# Therefore, we can set the size of the bitset to 8 to represent possible\n# total rewards from 0 to 7.\n#\n# Let's define a bitset `dp` to record whether each total reward is\n# achievable. dp[num] = true if reward `num` is achievable.\n#\n# Initially, dp = 0b00000001 := reward 0 is achievable.\n#\n# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n#   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n#\n# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n#\n# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n#\n# Therefore, the maximum total reward is 7.\n\nclass Solution:\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3180. Maximum Total Reward Using Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "475da838-1283-4465-b639-ad20cb9654c5",
      "code": "class Solution:\n  # Same as 3180. Maximum Total Reward Using Operations I\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3181. Maximum Total Reward Using Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e689de9c-fd48-4ef5-a706-f4f60759df17",
      "code": "class Solution:\n  def numberOfWays(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    dp = [1] + [0] * n\n\n    for coin in (1, 2, 6):\n      for i in range(coin, n + 1):\n        dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    ans = dp[n]\n    if n - 4 >= 0:\n      ans = (ans + dp[n - 4]) % MOD\n    if n - 8 >= 0:\n      ans = (ans + dp[n - 8]) % MOD\n    return ans",
      "title": "3183. The Number of Ways to Make the Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94e0ab23-77a6-47a7-9aee-c054e3b395c4",
      "code": "class Solution:\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3184. Count Pairs That Form a Complete Day I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d02146ec-0e89-4cda-9abe-11c06228cbc3",
      "code": "class Solution:\n  # Same as 3184. Count Pairs That Form a Complete Day I\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3185. Count Pairs That Form a Complete Day II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a681f46-8909-4092-b3e0-c22fd041b4fa",
      "code": "class Solution:\n  def maximumTotalDamage(self, power: list[int]) -> int:\n    count = collections.Counter(power)\n    uniqueDamages = sorted(count.keys())\n    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    # indicates if the i-th damage is used\n    dp = [[0] * 2 for _ in range(len(uniqueDamages))]\n\n    for i, damage in enumerate(uniqueDamages):\n      if i == 0:\n        dp[0] = [0, damage * count[damage]]\n        continue\n      dp[i][0] = max(dp[i - 1])\n      dp[i][1] = damage * count[damage]\n      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):\n        dp[i][1] += max(dp[i - 1])\n      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:\n        dp[i][1] += max(dp[i - 2])\n      elif i >= 3:\n        dp[i][1] += max(dp[i - 3])\n\n    return max(dp[-1])",
      "title": "3186. Maximum Total Damage With Spell Casting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e8b2645-3139-4b4b-b9d6-b6593ad6c3f7",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countOfPeaks(\n      self,\n      nums: list[int],\n      queries:\n      list[list[int]],\n  ) -> list[int]:\n    ans = []\n    peak = [0] + [int(a < b > c)\n                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]\n    tree = FenwickTree(len(peak))\n\n    for i, p in enumerate(peak):\n      tree.add(i + 1, p)\n\n    def update(i: int) -> None:\n      \"\"\"\n      Update the peak array and Fenwick tree if the peak status of nums[i]\n      changes.\n      \"\"\"\n      newPeak = self._isPeak(nums, i)\n      if newPeak != peak[i]:\n        tree.add(i + 1, newPeak - peak[i])\n        peak[i] = newPeak\n\n    for query in queries:\n      if query[0] == 1:\n        l = query[1]\n        r = query[2]\n        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))\n      elif query[0] == 2:\n        index = query[1]\n        val = query[2]\n        nums[index] = val\n        update(index)\n        if index > 0:\n          update(index - 1)\n        if index + 1 < len(nums):\n          update(index + 1)\n\n    return ans\n\n  def _isPeak(self, nums: list[int], i: int) -> bool:\n    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]",
      "title": "3187. Peaks in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba48dd0d-9844-47b7-91df-e42b3d907f47",
      "code": "class Solution:\n  def minMoves(self, rooks: list[list[int]]) -> int:\n    n = len(rooks)\n    sortedByRow = sorted(rooks, key=lambda x: x[0])\n    sortedByCol = sorted(rooks, key=lambda x: x[1])\n    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +\n            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))",
      "title": "3189. Minimum Moves to Get a Peaceful Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f25d0078-64e5-4859-8dd0-9ff62527c5f5",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return sum(num % 3 != 0 for num in nums)",
      "title": "3190. Find Minimum Operations to Make All Elements Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1018b4b-f75a-49cc-84d6-0de0736670ba",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2):\n      if nums[i] == 0:\n        nums[i + 1] ^= 1\n        nums[i + 2] ^= 1\n        ans += 1\n\n    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans",
      "title": "3191. Minimum Operations to Make Binary Array Elements Equal to One I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d43d3fd3-a70e-4016-8853-b2f72d5b9c7b",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    target = 1\n\n    for num in nums:\n      if num != target:\n        ans += 1\n        target ^= 1\n\n    return ans",
      "title": "3192. Minimum Operations to Make Binary Array Elements Equal to One II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598b4c3b-88dc-4ed9-a766-908fdb3bfaea",
      "code": "class Solution:\n  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    # dp[i][j] := the number of ways to arrange the first i numbers of the\n    # permutation s.t. there are j inversions\n    dp = [[0] * (MAX_INVERSIONS + 1) for _ in range(n + 1)]\n    endToCnt = {end + 1: cnt for end, cnt in requirements}\n\n    # There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1\n\n    for i in range(2, n + 1):\n      for newInversions in range(i):\n        for j in range(MAX_INVERSIONS - newInversions + 1):\n          inversionsAfterInsertion = j + newInversions\n          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:\n            continue\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j]\n          dp[i][inversionsAfterInsertion] %= MOD\n\n    return dp[n][endToCnt[n]]",
      "title": "3193. Count the Number of Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a010b3a-3972-42f3-a399-68ceef355fe2",
      "code": "class Solution:\n  def minimumAverage(self, nums: list[int]) -> float:\n    nums.sort()\n    return min((nums[i] + nums[~i]) / 2\n               for i in range(len(nums) // 2 + 1))",
      "title": "3194. Minimum Average of Smallest and Largest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52e3d2c5-ec2a-45e8-bbb5-4caf1d082a96",
      "code": "class Solution:\n  def minimumArea(self, grid: list[list[int]]) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3195. Find the Minimum Area to Cover All Ones I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fc3e9de-643a-4430-b8ac-6d15e6c71599",
      "code": "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    # A small trick so that we don't need to handle the edge case and can use\n    # ranged-based for loop.\n    keep = -math.inf  # the maximum cost if the last number is kept\n    flip = 0  # the maximum cost if the last number is flipped\n\n    for num in nums:\n      keep, flip = max(keep, flip) + num, keep - num\n\n    return max(keep, flip)",
      "title": "3196. Maximize Total Cost of Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76a61d14-3e8c-40ed-a232-d1e2f7e896b0",
      "code": "class Solution:\n  def minimumSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m * n\n\n    for i in range(m):\n      top = self._minimumArea(grid, 0, i, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, top +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for i in range(m):\n      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, bottom +\n                  self._minimumArea(grid, 0, i - 1, 0, j) +\n                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))\n\n    for j in range(n):\n      left = self._minimumArea(grid, 0, m - 1, 0, j)\n      for i in range(m):\n        ans = min(ans, left +\n                  self._minimumArea(grid, 0, i, j + 1, n - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for j in range(n):\n      right = self._minimumArea(grid, 0, m - 1, j, n - 1)\n      for i in range(m):\n        ans = min(ans, right +\n                  self._minimumArea(grid, 0, i, 0, j - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))\n\n    for i1 in range(m):\n      for i2 in range(i1 + 1, m):\n        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +\n                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))\n\n    for j1 in range(n):\n      for j2 in range(j1 + 1, n):\n        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +\n                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))\n\n    return ans\n\n  def _minimumArea(\n      self,\n      grid: list[list[int]],\n      si: int,\n      ei: int,\n      sj: int,\n      ej: int,\n  ) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n    for i in range(si, ei + 1):\n      for j in range(sj, ej + 1):\n        if grid[i][j] == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3197. Find the Minimum Area to Cover All Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2714a6cd-2601-4343-92a9-d981d4f404a7",
      "code": "class Solution:\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3199. Count Triplets with Even XOR Set Bits I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1909c459-c252-4c6d-86b7-32b2deda04bd",
      "code": "class Solution:\n  def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n    return max(self._maxHeight(red, blue),\n               self._maxHeight(blue, red))\n\n  def _maxHeight(self, n1: int, n2: int) -> int:\n    \"\"\"\n    Returns the maximum height of a triangle with the odd levels having `n1`\n    balls and the even levels having `n2` balls.\n    \"\"\"\n    #             1 + 3 + ... + h <= n1\n    # ((1 + h) * (n + 1) / 2) / 2 <= n1\n    #                           h <= sqrt(4 * n1) - 1\n    oddHeight = math.isqrt(4 * n1) - 1\n    #       2 + 4 + ... + h <= n2\n    # ((2 + h) * h / 2) / 2 <= n2\n    #                     h <= sqrt(4 * n2 + 1) - 1\n    evenHeight = math.isqrt(4 * n2 + 1) - 1\n    # If the difference between the odd and even heights is >= 1, we can add an\n    # extra level to the minimum height.\n    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1\n                                         else 0)",
      "title": "3200. Maximum Height of a Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5ef95a0-e26a-45cc-a76d-c479894476e6",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * 2 for _ in range(2)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(2):\n        dp[x % 2][y] = dp[y][x % 2] + 1\n\n    return max(map(max, dp))",
      "title": "3201. Find the Maximum Length of Valid Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b5e54eb-7dcc-41fa-9ae8-5c225d3da411",
      "code": "class Solution:\n  # Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * k for _ in range(k)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(k):\n        dp[x % k][y] = dp[y][x % k] + 1\n\n    return max(map(max, dp))",
      "title": "3202. Find the Maximum Length of Valid Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27eae645-64fe-4fc3-82ce-6e377f3cdd83",
      "code": "class Solution:\n  def minimumDiameterAfterMerge(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n  ) -> int:\n    diameter1 = self._getDiameter(edges1)\n    diameter2 = self._getDiameter(edges2)\n    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1\n    return max(diameter1, diameter2, combinedDiameter)\n\n  def _getDiameter(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    maxDiameter = [0]\n    self._maxDepth(graph, 0, -1, maxDiameter)\n    return maxDiameter[0]\n\n  # Similar to 1522. Diameter of N-Ary Tree\n  def _maxDepth(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      maxDiameter: list[int],\n  ) -> int:\n    \"\"\"Returns the maximum depth of the subtree rooted at u.\"\"\"\n    maxSubDepth1 = 0\n    maxSubDepth2 = 0\n    for v in graph[u]:\n      if v == prev:\n        continue\n      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)\n      if maxSubDepth > maxSubDepth1:\n        maxSubDepth2 = maxSubDepth1\n        maxSubDepth1 = maxSubDepth\n      elif maxSubDepth > maxSubDepth2:\n        maxSubDepth2 = maxSubDepth\n    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)\n    return 1 + maxSubDepth1",
      "title": "3203. Find Minimum Diameter After Merging Two Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e09b8512-7086-49f3-bea7-fabdac2223c7",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i] := the maximum score to jump from index i to n - 1\n    dp = [0] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        # Jump from i to j, and then jump from j to n - 1.\n        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])\n\n    return dp[0]",
      "title": "3205. Maximum Array Hopping Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f474949b-58a0-4ab2-ae4d-a36c6b5b603a",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int]) -> int:\n    n = len(colors)\n    return sum(colors[i] != colors[i - 1] and\n               colors[i] != colors[(i + 1) % n]\n               for i in range(n))",
      "title": "3206. Alternating Groups I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6921787-eb73-437a-b99d-ead675080acb",
      "code": "class Solution:\n  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:\n    minEnergy = min(enemyEnergies)\n    return (0 if currentEnergy < minEnergy\n            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)",
      "title": "3207. Maximum Points After Enemy Battles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c422bccf-7d7a-45af-beae-186b1e0c4d9a",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:\n    n = len(colors)\n    ans = 0\n    alternating = 1\n\n    for i in range(n + k - 2):\n      alternating = (1 if colors[i % n] == colors[(i - 1) % n]\n                     else alternating + 1)\n      if alternating >= k:\n        ans += 1\n\n    return ans",
      "title": "3208. Alternating Groups II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5e4ee4-107c-429c-8575-00a0aa76d170",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # the counter of all the values of subarrays that end in the previous\n    # number\n    prev = collections.Counter()\n\n    for num in nums:\n      # Extend each subarray that ends in the previous number. Due to\n      # monotonicity of the AND operation, the size of `curr` will be at most\n      # num.bit_count() + 1.\n      curr = collections.Counter({num: 1})\n      for val, freq in prev.items():\n        curr[val & num] += freq\n      ans += curr[k]\n      prev = curr\n\n    return ans",
      "title": "3209. Number of Subarrays With AND Value of K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9947436b-88b1-4fed-9f6f-b060a02f73db",
      "code": "class Solution:\n  def getEncryptedString(self, s: str, k: int) -> str:\n    k %= len(s)\n    return s[k:] + s[0:k]",
      "title": "3210. Find the Encrypted String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04646afa-31fb-4bea-9c95-b10a804026c9",
      "code": "class Solution:\n  def validStrings(self, n: int) -> list[str]:\n    ans = []\n\n    def dfs(n: int, s: list[str]) -> None:\n      if n == 0:\n        ans.append(''.join(s))\n        return\n      if not s or s[-1] == '1':\n        s.append('0')\n        dfs(n - 1, s)\n        s.pop()\n      s.append('1')\n      dfs(n - 1, s)\n      s.pop()\n\n    dfs(n, [])\n    return ans",
      "title": "3211. Generate Binary Strings Without Adjacent Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ccd31b9-cd55-4093-9155-e7f94fbfc5bc",
      "code": "class Solution:\n  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    x = [[0] * (n + 1) for _ in range(m + 1)]\n    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    y = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]\n        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]\n        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:\n          ans += 1\n\n    return ans",
      "title": "3212. Count Submatrices With Equal Frequency of X and Y",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fe9d3e5-eadf-4cac-8ac1-3507dcb02ca6",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0..i)\n    dp = [0] + [math.inf] * n\n    # minCost[c][word] := the minimum cost to construct word starting with `c`\n    minCost: dict[str, dict[str, int]] = collections.defaultdict(dict)\n\n    for word, cost in zip(words, costs):\n      c = word[0]\n      minCost[c][word] = min(minCost[c].get(word, math.inf), cost)\n\n    for i, c in enumerate(target):\n      for word, cost in minCost[c].items():\n        j = i + len(word)\n        if j <= n and cost + dp[i] < dp[j] and target[i:j] == word:\n          dp[j] = cost + dp[i]\n\n    return -1 if dp[n] == math.inf else dp[n]",
      "title": "3213. Construct String with Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b284e6bf-066a-4663-93ec-1bf973032cfc",
      "code": "class Solution:\n  # Same as 3199. Count Triplets with Even XOR Set Bits I\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3215. Count Triplets with Even XOR Set Bits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47e99645-35b0-456a-99ba-3587f043f6bd",
      "code": "class Solution:\n  def getSmallestString(self, s: str) -> str:\n    chars = list(s)\n    for i, (a, b) in enumerate(itertools.pairwise(chars)):\n      if ord(a) % 2 == ord(b) % 2 and a > b:\n        chars[i], chars[i + 1] = chars[i + 1], chars[i]\n        return ''.join(chars)\n    return s",
      "title": "3216. Lexicographically Smallest String After a Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cfd1309-b778-4855-b8ae-6386d78b5cdf",
      "code": "class Solution:\n  def modifiedList(\n      self,\n      nums: list[int],\n      head: ListNode | None,\n  ) -> ListNode | None:\n    dummy = ListNode(0, head)\n    numsSet = set(nums)\n\n    curr = dummy\n    while curr.next:\n      if curr.next.val in numsSet:\n        curr.next = curr.next.next\n      else:\n        curr = curr.next\n\n    return dummy.next",
      "title": "3217. Delete Nodes From Linked List Present in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54755c25-febc-4b56-a0e4-68b8f44d0ec7",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3218. Minimum Cost for Cutting Cake I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bddebf14-32ed-43eb-87fa-afa64c07194b",
      "code": "class Solution:\n  # Same as 3218. Minimum Cost for Cutting Cake I\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3219. Minimum Cost for Cutting Cake II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac59998b-b72f-4153-a55c-92a67c9800a2",
      "code": "class Solution:\n  # Same as 3205. Maximum Array Hopping Score I\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))",
      "title": "3221. Maximum Array Hopping Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ffdc13-aa35-4204-8176-fcda8a928a4d",
      "code": "class Solution:\n  def losingPlayer(self, x: int, y: int) -> str:\n    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'",
      "title": "3222. Find the Winning Player in Coin Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c261ec70-1172-4908-b9b9-d3f65ed32783",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    count = collections.Counter(s)\n    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())",
      "title": "3223. Minimum Length of String After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "189beb08-ad36-426f-a8c7-ae2763b67cca",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    pairSize = len(nums) // 2\n    diffCount = collections.Counter()  # {nums[-1 - i] - nums[i]: freq}\n    # oneChangeCount[i] := the number of pairs that need only one change to\n    # to achieve a difference of `i`\n    oneChangeCount = [0] * (k + 1)\n\n    for i in range(pairSize):\n      a = nums[i]\n      b = nums[-1 - i]\n      diffCount[abs(a - b)] += 1\n      oneChangeCount[max(a, b, k - a, k - b)] += 1\n\n    # prefixOneChangeCount[i] := the number of pairs that need only one change\n    # to achieve a difference >= `i`\n    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    prefixOneChangeCount = list(\n        itertools.accumulate(reversed(oneChangeCount)))[::-1]\n\n    return min(prefixOneChangeCount[diff] - freq +  # one change\n               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes\n               for diff, freq in diffCount.items())",
      "title": "3224. Minimum Array Changes to Make Differences Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "394735f6-7c4f-4959-be65-d26d0ad19220",
      "code": "class Solution:\n  def maximumScore(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    # prefix[j][i] := the sum of the first i elements in the j-th column\n    prefix = [[0] * (n + 1) for _ in range(n)]\n    # prevPick[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the previous column is in row (i - 1)\n    prevPick = [0] * (n + 1)\n    # prevSkip[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the column before the previous one is in\n    # row (i - 1)\n    prevSkip = [0] * (n + 1)\n\n    for j in range(n):\n      for i in range(n):\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j]\n\n    for j in range(1, n):\n      currPick = [0] * (n + 1)\n      currSkip = [0] * (n + 1)\n      # Consider all possible combinations of the number of current and\n      # previous selected elements.\n      for curr in range(n + 1):  # the number of current selected elements\n        for prev in range(n + 1):  # the number of previous selected elements\n          if curr > prev:\n            # 1. The current bottom is deeper than the previous bottom.\n            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.\n            score = prefix[j - 1][curr] - prefix[j - 1][prev]\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)\n          else:\n            # 2. The previous bottom is deeper than the current bottom.\n            # Get the score of grid[curr..prev)[j] for pick only.\n            score = prefix[j][prev] - prefix[j][curr]\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevPick[prev])\n      prevPick = currPick\n      prevSkip = currSkip\n\n    return max(prevPick)",
      "title": "3225. Maximum Score From Grid Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}