{
  "snippets": [
    {
      "id": "e17283df-c9c3-44b8-8f1f-d6f0c989d9d0",
      "code": "class Solution:\n  def twoSum(self, nums: list[int], target: int) -> list[int]:\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      if target - num in numToIndex:\n        return numToIndex[target - num], i\n      numToIndex[num] = i",
      "title": "1. Two Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03cd60fb-cca0-44d8-bec9-0675c865c72d",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    carry = 0\n\n    while carry or l1 or l2:\n      if l1:\n        carry += l1.val\n        l1 = l1.next\n      if l2:\n        carry += l2.val\n        l2 = l2.next\n      curr.next = ListNode(carry % 10)\n      carry //= 10\n      curr = curr.next\n\n    return dummy.next",
      "title": "2. Add Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f190505d-0bb7-40e0-8ad2-9efdc3947c68",
      "code": "class Solution:\n  def lengthOfLongestSubstring(self, s: str) -> int:\n    ans = 0\n    # The substring s[j + 1..i] has no repeating characters.\n    j = -1\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      # Update j to lastSeen[c], so the window must start from j + 1.\n      j = max(j, lastSeen.get(c, -1))\n      ans = max(ans, i - j)\n      lastSeen[c] = i\n\n    return ans",
      "title": "3. Longest Substring Without Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09a0d72c-76d5-4812-ae3c-6d0aff7cfdad",
      "code": "class Solution:\n  def findMedianSortedArrays(self, nums1: list[int], nums2: list[int]) -> float:\n    n1 = len(nums1)\n    n2 = len(nums2)\n    if n1 > n2:\n      return self.findMedianSortedArrays(nums2, nums1)\n\n    l = 0\n    r = n1\n\n    while l <= r:\n      partition1 = (l + r) // 2\n      partition2 = (n1 + n2 + 1) // 2 - partition1\n      maxLeft1 = -2**31 if partition1 == 0 else nums1[partition1 - 1]\n      maxLeft2 = -2**31 if partition2 == 0 else nums2[partition2 - 1]\n      minRight1 = 2**31 - 1 if partition1 == n1 else nums1[partition1]\n      minRight2 = 2**31 - 1 if partition2 == n2 else nums2[partition2]\n      if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:\n        return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5 if (n1 + n2) % 2 == 0 else max(maxLeft1, maxLeft2)\n      elif maxLeft1 > minRight2:\n        r = partition1 - 1\n      else:\n        l = partition1 + 1",
      "title": "4. Median of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b97908ac-683c-48bc-9cf9-5a133bc5a95a",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> str:\n    t = '#'.join('@' + s + '$')\n    p = self._manacher(t)\n    maxPalindromeLength, bestCenter = max((extend, i)\n                                          for i, extend in enumerate(p))\n    l = (bestCenter - maxPalindromeLength) // 2\n    r = (bestCenter + maxPalindromeLength) // 2\n    return s[l:r]\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p",
      "title": "5. Longest Palindromic Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d99bbd91-7b47-4dd3-93c4-c972401e9a2a",
      "code": "class Solution:\n  def convert(self, s: str, numRows: int) -> str:\n    rows = [''] * numRows\n    k = 0\n    direction = (numRows == 1) - 1\n\n    for c in s:\n      rows[k] += c\n      if k == 0 or k == numRows - 1:\n        direction *= -1\n      k += direction\n\n    return ''.join(rows)",
      "title": "6. ZigZag Conversion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90676208-d1e7-46da-a291-5c7ff3b9a3f0",
      "code": "class Solution:\n  def reverse(self, x: int) -> int:\n    ans = 0\n    sign = -1 if x < 0 else 1\n    x *= sign\n\n    while x:\n      ans = ans * 10 + x % 10\n      x //= 10\n\n    return 0 if ans < -2**31 or ans > 2**31 - 1 else sign * ans",
      "title": "7. Reverse Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2abb313-391f-457e-88f3-292ef75fbc12",
      "code": "class Solution:\n  def myAtoi(self, s: str) -> int:\n    s = s.strip()\n    if not s:\n      return 0\n\n    sign = -1 if s[0] == '-' else 1\n    if s[0] in {'-', '+'}:\n      s = s[1:]\n\n    num = 0\n\n    for c in s:\n      if not c.isdigit():\n        break\n      num = num * 10 + int(c)\n      if sign * num <= -2**31:\n        return -2**31\n      if sign * num >= 2**31 - 1:\n        return 2**31 - 1\n\n    return sign * num",
      "title": "8. String to Integer (atoi)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0c57c76-e5e9-45b8-a385-49e9ccb1b55b",
      "code": "class Solution:\n  def isPalindrome(self, x: int) -> bool:\n    if x < 0:\n      return False\n\n    rev = 0\n    y = x\n\n    while y:\n      rev = rev * 10 + y % 10\n      y //= 10\n\n    return rev == x",
      "title": "9. Palindrome Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0aea773c-4774-452b-8dca-31c6bbf64ca5",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return j >= 0 and p[j] == '.' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*' and dp[0][j - 1]:\n        dp[0][j + 1] = True\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          # The minimum index of '*' is 1.\n          noRepeat = dp[i + 1][j - 1]\n          doRepeat = isMatch(i, j - 1) and dp[i][j + 1]\n          dp[i + 1][j + 1] = noRepeat or doRepeat\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "10. Regular Expression Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57f57593-ca3e-4417-be42-1164fdc86e2d",
      "code": "class Solution:\n  def maxArea(self, height: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(height) - 1\n\n    while l < r:\n      minHeight = min(height[l], height[r])\n      ans = max(ans, minHeight * (r - l))\n      if height[l] < height[r]:\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "11. Container With Most Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17af5653-2689-4ec3-8538-cb809340deac",
      "code": "class Solution:\n  def intToRoman(self, num: int) -> str:\n    valueSymbols = [(1000, 'M'), (900, 'CM'),\n                    (500, 'D'), (400, 'CD'),\n                    (100, 'C'), (90, 'XC'),\n                    (50, 'L'), (40, 'XL'),\n                    (10, 'X'), (9, 'IX'),\n                    (5, 'V'), (4, 'IV'),\n                    (1, 'I')]\n    ans = []\n\n    for value, symbol in valueSymbols:\n      if num == 0:\n        break\n      count, num = divmod(num, value)\n      ans.append(symbol * count)\n\n    return ''.join(ans)",
      "title": "12. Integer to Roman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f33a697-d8e7-4f58-8838-35ff8c928247",
      "code": "class Solution:\n  def romanToInt(self, s: str) -> int:\n    ans = 0\n    roman = {'I': 1, 'V': 5, 'X': 10, 'L': 50,\n             'C': 100, 'D': 500, 'M': 1000}\n\n    for a, b in zip(s, s[1:]):\n      if roman[a] < roman[b]:\n        ans -= roman[a]\n      else:\n        ans += roman[a]\n\n    return ans + roman[s[-1]]",
      "title": "13. Roman to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83d369d3-f5c7-43d1-9e2b-08ef9060eb12",
      "code": "class Solution:\n  def longestCommonPrefix(self, strs: list[str]) -> str:\n    if not strs:\n      return ''\n\n    for i in range(len(strs[0])):\n      for j in range(1, len(strs)):\n        if i == len(strs[j]) or strs[j][i] != strs[0][i]:\n          return strs[0][:i]\n\n    return strs[0]",
      "title": "14. Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "878f56c1-fb28-4441-94a1-525ceb1d8032",
      "code": "class Solution:\n  def threeSum(self, nums: list[int]) -> list[list[int]]:\n    if len(nums) < 3:\n      return []\n\n    ans = []\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == 0:\n          ans.append((nums[i], nums[l], nums[r]))\n          l += 1\n          r -= 1\n          while nums[l] == nums[l - 1] and l < r:\n            l += 1\n          while nums[r] == nums[r + 1] and l < r:\n            r -= 1\n        elif summ < 0:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "15. 3Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0444f950-e28a-433e-8ceb-965581aaf09a",
      "code": "class Solution:\n  def threeSumClosest(self, nums: list[int], target: int) -> int:\n    ans = nums[0] + nums[1] + nums[2]\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      if i > 0 and nums[i] == nums[i - 1]:\n        continue\n      # Choose nums[i] as the first number in the triplet, then search the\n      # remaining numbers in [i + 1, n - 1].\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        summ = nums[i] + nums[l] + nums[r]\n        if summ == target:\n          return summ\n        if abs(summ - target) < abs(ans - target):\n          ans = summ\n        if summ < target:\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "16. 3Sum Closest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d0457d1-93be-41ac-bc0d-431302bc0b07",
      "code": "class Solution:\n  def letterCombinations(self, digits: str) -> list[str]:\n    if not digits:\n      return []\n\n    digitToLetters = ['', '', 'abc', 'def', 'ghi',\n                      'jkl', 'mno', 'pqrs', 'tuv', 'wxyz']\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(digits):\n        ans.append(''.join(path))\n        return\n\n      for letter in digitToLetters[int(digits[i])]:\n        path.append(letter)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return ans",
      "title": "17. Letter Combinations of a Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cb637be-15da-4d3f-8d76-e6cda1d934b7",
      "code": "class Solution:\n  def fourSum(self, nums: list[int], target: int):\n    ans = []\n\n    def nSum(\n            l: int, r: int, target: int, n: int, path: list[int],\n            ans: list[list[int]]) -> None:\n      \"\"\"Finds n numbers that add up to the target in [l, r].\"\"\"\n      if r - l + 1 < n or n < 2 or target < nums[l] * n or target > nums[r] * n:\n        return\n      if n == 2:\n        while l < r:\n          summ = nums[l] + nums[r]\n          if summ == target:\n            ans.append(path + [nums[l], nums[r]])\n            l += 1\n            while nums[l] == nums[l - 1] and l < r:\n              l += 1\n          elif summ < target:\n            l += 1\n          else:\n            r -= 1\n        return\n\n      for i in range(l, r + 1):\n        if i > l and nums[i] == nums[i - 1]:\n          continue\n\n        nSum(i + 1, r, target - nums[i], n - 1, path + [nums[i]], ans)\n\n    nums.sort()\n    nSum(0, len(nums) - 1, target, 4, [], ans)\n    return ans",
      "title": "18. 4Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13b1dcfa-9c5d-46af-b6a5-07bdf7422740",
      "code": "class Solution:\n  def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:\n    slow = head\n    fast = head\n\n    for _ in range(n):\n      fast = fast.next\n    if not fast:\n      return head.next\n\n    while fast.next:\n      slow = slow.next\n      fast = fast.next\n    slow.next = slow.next.next\n\n    return head",
      "title": "19. Remove Nth Node From End of List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe04d4ba-a4d2-4fe3-b9ef-cd792e162f97",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == '(':\n        stack.append(')')\n      elif c == '{':\n        stack.append('}')\n      elif c == '[':\n        stack.append(']')\n      elif not stack or stack.pop() != c:\n        return False\n\n    return not stack",
      "title": "20. Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "777fa003-0639-4bf7-8331-0fbfc9334775",
      "code": "class Solution:\n  def mergeTwoLists(\n      self,\n      list1: ListNode | None,\n      list2: ListNode | None,\n  ) -> ListNode | None:\n    if not list1 or not list2:\n      return list1 if list1 else list2\n    if list1.val > list2.val:\n      list1, list2 = list2, list1\n    list1.next = self.mergeTwoLists(list1.next, list2)\n    return list1",
      "title": "21. Merge Two Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fc18707-2292-4137-b10e-b157c716892c",
      "code": "class Solution:\n  def generateParenthesis(self, n):\n    ans = []\n\n    def dfs(l: int, r: int, s: list[str]) -> None:\n      if l == 0 and r == 0:\n        ans.append(''.join(s))\n      if l > 0:\n        s.append('(')\n        dfs(l - 1, r, s)\n        s.pop()\n      if l < r:\n        s.append(')')\n        dfs(l, r - 1, s)\n        s.pop()\n\n    dfs(n, n, [])\n    return ans",
      "title": "22. Generate Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35078b68-7b31-4149-8af0-e498ee317216",
      "code": "from queue import PriorityQueue\n\n\nclass Solution:\n  def mergeKLists(self, lists: list[ListNode]) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    pq = PriorityQueue()\n\n    for i, lst in enumerate(lists):\n      if lst:\n        pq.put((lst.val, i, lst))\n\n    while not pq.empty():\n      _, i, minNode = pq.get()\n      if minNode.next:\n        pq.put((minNode.next.val, i, minNode.next))\n      curr.next = minNode\n      curr = curr.next\n\n    return dummy.next",
      "title": "23. Merge k Sorted Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2730c869-f1bf-46db-9806-7dbed4cbfa82",
      "code": "class Solution:\n  def swapPairs(self, head: ListNode) -> ListNode:\n    def getLength(head: ListNode) -> int:\n      length = 0\n      while head:\n        length += 1\n        head = head.next\n      return length\n\n    length = getLength(head)\n    dummy = ListNode(0, head)\n    prev = dummy\n    curr = head\n\n    for _ in range(length // 2):\n      next = curr.next\n      curr.next = next.next\n      next.next = prev.next\n      prev.next = next\n      prev = curr\n      curr = curr.next\n\n    return dummy.next",
      "title": "24. Swap Nodes in Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "384653c6-c9ec-4218-bb8e-67d65555dff8",
      "code": "class Solution:\n  def reverseKGroup(self, head: ListNode | None, k: int) -> ListNode | None:\n    if not head:\n      return None\n\n    tail = head\n\n    for _ in range(k):\n      # There are less than k nodes in the list, do nothing.\n      if not tail:\n        return head\n      tail = tail.next\n\n    newHead = self._reverse(head, tail)\n    head.next = self.reverseKGroup(tail, k)\n    return newHead\n\n  def _reverse(\n      self,\n      head: ListNode | None,\n      tail: ListNode | None,\n  ) -> ListNode | None:\n    \"\"\"Reverses [head, tail).\"\"\"\n    prev = None\n    curr = head\n    while curr != tail:\n      next = curr.next\n      curr.next = prev\n      prev = curr\n      curr = next\n    return prev",
      "title": "25. Reverse Nodes in k-Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc954d2a-0151-4b1f-b7d2-f9223052eca2",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 1 or num > nums[i - 1]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "26. Remove Duplicates from Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e21b59fd-87de-4f21-86f6-ae6a8fd2842b",
      "code": "class Solution:\n  def removeElement(self, nums: list[int], val: int) -> int:\n    i = 0\n\n    for num in nums:\n      if num != val:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "27. Remove Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c3a552c-982b-4ac4-a1db-3abf74a2d2ed",
      "code": "class Solution:\n  def strStr(self, haystack: str, needle: str) -> int:\n    m = len(haystack)\n    n = len(needle)\n\n    for i in range(m - n + 1):\n      if haystack[i:i + n] == needle:\n        return i\n\n    return -1",
      "title": "28. Implement strStr()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a356c56c-11f2-463c-919a-89bbe382c91c",
      "code": "class Solution:\n  def divide(self, dividend: int, divisor: int) -> int:\n    # -2^{31} / -1 = 2^31 will overflow, so return 2^31 - 1.\n    if dividend == -2**31 and divisor == -1:\n      return 2**31 - 1\n\n    sign = -1 if (dividend > 0) ^ (divisor > 0) else 1\n    ans = 0\n    dvd = abs(dividend)\n    dvs = abs(divisor)\n\n    while dvd >= dvs:\n      k = 1\n      while k * 2 * dvs <= dvd:\n        k <<= 1\n      dvd -= k * dvs\n      ans += k\n\n    return sign * ans",
      "title": "29. Divide Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff33a102-8f7a-4e7c-84b8-9d3d74b3c262",
      "code": "class Solution:\n  def findSubstring(self, s: str, words: list[str]) -> list[int]:\n    if len(s) == 0 or words == []:\n      return []\n\n    k = len(words)\n    n = len(words[0])\n    ans = []\n    count = collections.Counter(words)\n\n    for i in range(len(s) - k * n + 1):\n      seen = collections.defaultdict(int)\n      j = 0\n      while j < k:\n        word = s[i + j * n: i + j * n + n]\n        seen[word] += 1\n        if seen[word] > count[word]:\n          break\n        j += 1\n      if j == k:\n        ans.append(i)\n\n    return ans",
      "title": "30. Substring with Concatenation of All Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bba844f-9809-41de-bcc6-8cd46603855b",
      "code": "class Solution:\n  def nextPermutation(self, nums: list[int]) -> None:\n    n = len(nums)\n\n    # From back to front, find the first number < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From back to front, find the first number > nums[i], swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums: list[int], l: int, r: int) -> None:\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)",
      "title": "31. Next Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07f0a226-b502-4665-a6d9-ced2b6905b83",
      "code": "class Solution:\n  def longestValidParentheses(self, s: str) -> int:\n    s2 = ')' + s\n    # dp[i] := the length of the longest valid parentheses in the substring\n    # s2[1..i]\n    dp = [0] * len(s2)\n\n    for i in range(1, len(s2)):\n      if s2[i] == ')' and s2[i - dp[i - 1] - 1] == '(':\n        dp[i] = dp[i - 1] + dp[i - dp[i - 1] - 2] + 2\n\n    return max(dp)",
      "title": "32. Longest Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "918c0e00-4091-459d-b265-bc2397354af4",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[l] <= nums[m]:  # nums[l..m] are sorted.\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted.\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return -1",
      "title": "33. Search in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f942efed-7221-4f6a-adb0-7d3cadf2bc1d",
      "code": "class Solution:\n  def searchRange(self, nums: list[int], target: int) -> list[int]:\n    l = bisect_left(nums, target)\n    if l == len(nums) or nums[l] != target:\n      return -1, -1\n    r = bisect_right(nums, target) - 1\n    return l, r",
      "title": "34. Find First and Last Position of Element in Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d09c3e-1fce-488b-bcc2-6d1c0145c7d6",
      "code": "class Solution:\n  def searchInsert(self, nums: list[int], target: int) -> int:\n    l = 0\n    r = len(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return m\n      if nums[m] < target:\n        l = m + 1\n      else:\n        r = m\n\n    return l",
      "title": "35. Search Insert Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee28c600-bd5f-44c1-aa69-fed5054255c2",
      "code": "class Solution:\n  def isValidSudoku(self, board: list[list[str]]) -> bool:\n    seen = set()\n\n    for i in range(9):\n      for j in range(9):\n        c = board[i][j]\n        if c == '.':\n          continue\n        if (c + '@row ' + str(i) in seen or\n            c + '@col ' + str(j) in seen or\n                c + '@box ' + str(i // 3) + str(j // 3) in seen):\n          return False\n        seen.add(c + '@row ' + str(i))\n        seen.add(c + '@col ' + str(j))\n        seen.add(c + '@box ' + str(i // 3) + str(j // 3))\n\n    return True",
      "title": "36. Valid Sudoku",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65e78df6-a9d5-4eab-b4b6-90d9a42f5277",
      "code": "class Solution:\n  def solveSudoku(self, board: list[list[str]]) -> None:\n    def isValid(row: int, col: int, c: str) -> bool:\n      for i in range(9):\n        if (board[i][col] == c or\n            board[row][i] == c or\n                board[3 * (row // 3) + i // 3][3 * (col // 3) + i % 3] == c):\n          return False\n      return True\n\n    def solve(s: int) -> bool:\n      if s == 81:\n        return True\n\n      i = s // 9\n      j = s % 9\n\n      if board[i][j] != '.':\n        return solve(s + 1)\n\n      for c in string.digits[1:]:\n        if isValid(i, j, c):\n          board[i][j] = c\n          if solve(s + 1):\n            return True\n          board[i][j] = '.'\n\n      return False\n\n    solve(0)",
      "title": "37. Sudoku Solver",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4392a3f-ced8-4f25-ac72-fcccebfe7ade",
      "code": "class Solution:\n  def countAndSay(self, n: int) -> str:\n    ans = '1'\n\n    for _ in range(n - 1):\n      nxt = ''\n      i = 0\n      while i < len(ans):\n        count = 1\n        while i + 1 < len(ans) and ans[i] == ans[i + 1]:\n          count += 1\n          i += 1\n        nxt += str(count) + ans[i]\n        i += 1\n      ans = nxt\n\n    return ans",
      "title": "38. Count and Say",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "970a8546-d26b-48c7-b892-1a1620d2e8b1",
      "code": "class Solution:\n  def combinationSum(self, candidates: list[int],\n                     target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.clone())\n        return\n\n      for i in range(s, len(candidates)):\n        path.append(candidates[i])\n        dfs(i, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "39. Combination Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "818f6037-ee06-48e8-9d63-e4480d64d8d3",
      "code": "class Solution:\n  def combinationSum2(self, candidates: list[int],\n                      target: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, target: int, path: list[int]) -> None:\n      if target < 0:\n        return\n      if target == 0:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, len(candidates)):\n        if i > s and candidates[i] == candidates[i - 1]:\n          continue\n        path.append(candidates[i])\n        dfs(i + 1, target - candidates[i], path)\n        path.pop()\n\n    candidates.sort()\n    dfs(0, target, [])\n    return ans",
      "title": "40. Combination Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d0a770b-71a5-43c2-a3b6-399173eeac22",
      "code": "class Solution:\n  def firstMissingPositive(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    # Correct slot:\n    # nums[i] = i + 1\n    # nums[i] - 1 = i\n    # nums[nums[i] - 1] = nums[i]\n    for i in range(n):\n      while nums[i] > 0 and nums[i] <= n and nums[nums[i] - 1] != nums[i]:\n        nums[nums[i] - 1], nums[i] = nums[i], nums[nums[i] - 1]\n\n    for i, num in enumerate(nums):\n      if num != i + 1:\n        return i + 1\n\n    return n + 1",
      "title": "41. First Missing Positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52ca1df9-d676-464d-8724-6e6e62bc3a26",
      "code": "class Solution:\n  def trap(self, height: list[int]) -> int:\n    n = len(height)\n    l = [0] * n  # l[i] := max(height[0..i])\n    r = [0] * n  # r[i] := max(height[i..n))\n\n    for i, h in enumerate(height):\n      l[i] = h if i == 0 else max(h, l[i - 1])\n\n    for i, h in reversed(list(enumerate(height))):\n      r[i] = h if i == n - 1 else max(h, r[i + 1])\n\n    return sum(min(l[i], r[i]) - h\n               for i, h in enumerate(height))",
      "title": "42. Trapping Rain Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6aa48f94-c8c4-40de-b1ba-8dd4fbc58287",
      "code": "class Solution:\n  def multiply(self, num1: str, num2: str) -> str:\n    s = [0] * (len(num1) + len(num2))\n\n    for i in reversed(range(len(num1))):\n      for j in reversed(range(len(num2))):\n        mult = int(num1[i]) * int(num2[j])\n        summ = mult + s[i + j + 1]\n        s[i + j] += summ // 10\n        s[i + j + 1] = summ % 10\n\n    for i, c in enumerate(s):\n      if c != 0:\n        break\n\n    return ''.join(map(str, s[i:]))",
      "title": "43. Multiply Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0685ef6e-c569-47a3-a485-0ad848eb75d5",
      "code": "class Solution:\n  def isMatch(self, s: str, p: str) -> bool:\n    m = len(s)\n    n = len(p)\n    # dp[i][j] := True if s[0..i) matches p[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    def isMatch(i: int, j: int) -> bool:\n      return i >= 0 and p[j] == '?' or s[i] == p[j]\n\n    for j, c in enumerate(p):\n      if c == '*':\n        dp[0][j + 1] = dp[0][j]\n\n    for i in range(m):\n      for j in range(n):\n        if p[j] == '*':\n          matchEmpty = dp[i + 1][j]\n          matchSome = dp[i][j + 1]\n          dp[i + 1][j + 1] = matchEmpty or matchSome\n        elif isMatch(i, j):\n          dp[i + 1][j + 1] = dp[i][j]\n\n    return dp[m][n]",
      "title": "44. Wildcard Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "920a8e83-0ff0-424f-acdd-395b599d627f",
      "code": "class Solution:\n  def jump(self, nums: list[int]) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    # Start an implicit BFS.\n    for i in range(len(nums) - 1):\n      farthest = max(farthest, i + nums[i])\n      if farthest >= len(nums) - 1:\n        ans += 1\n        break\n      if i == end:      # Visited all the items on the current level.\n        ans += 1        # Increment the level.\n        end = farthest  # Make the queue size for the next level.\n\n    return ans",
      "title": "45. Jump Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21daa33f-7bca-4e2b-abd2-58eae7389cde",
      "code": "class Solution:\n  def permute(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    dfs([])\n    return ans",
      "title": "46. Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d067a6a1-8130-4236-ad9d-94ea3ec6f083",
      "code": "class Solution:\n  def permuteUnique(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n    used = [False] * len(nums)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == len(nums):\n        ans.append(path.copy())\n        return\n\n      for i, num in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "47. Permutations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08153c0b-a28b-4b45-9705-67e11641bf86",
      "code": "class Solution:\n  def rotate(self, matrix: list[list[int]]) -> None:\n    for mn in range(len(matrix) // 2):\n      mx = len(matrix) - mn - 1\n      for i in range(mn, mx):\n        offset = i - mn\n        top = matrix[mn][i]\n        matrix[mn][i] = matrix[mx - offset][mn]\n        matrix[mx - offset][mn] = matrix[mx][mx - offset]\n        matrix[mx][mx - offset] = matrix[i][mx]\n        matrix[i][mx] = top",
      "title": "48. Rotate Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c775ca13-d9eb-4220-8788-e20e315435be",
      "code": "class Solution:\n  def groupAnagrams(self, strs: list[str]) -> list[list[str]]:\n    dict = collections.defaultdict(list)\n\n    for str in strs:\n      key = ''.join(sorted(str))\n      dict[key].append(str)\n\n    return dict.values()",
      "title": "49. Group Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ad4a20f-b1c5-4a5f-9d33-fdfb8e8adc91",
      "code": "class Solution:\n  def myPow(self, x: float, n: int) -> float:\n    if n == 0:\n      return 1\n    if n < 0:\n      return 1 / self.myPow(x, -n)\n    if n % 2 == 1:\n      return x * self.myPow(x, n - 1)\n    return self.myPow(x * x, n // 2)",
      "title": "50. Pow(x, n)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d782eea-5195-41bf-a1d8-df6079695415",
      "code": "class Solution:\n  def solveNQueens(self, n: int) -> list[list[str]]:\n    ans = []\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int, board: list[int]) -> None:\n      if i == n:\n        ans.append(board)\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1, board + ['.' * j + 'Q' + '.' * (n - j - 1)])\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0, [])\n    return ans",
      "title": "51. N-Queens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8468c30f-6271-438c-bd1f-ca8f62a4a239",
      "code": "class Solution:\n  def totalNQueens(self, n: int) -> int:\n    ans = 0\n    cols = [False] * n\n    diag1 = [False] * (2 * n - 1)\n    diag2 = [False] * (2 * n - 1)\n\n    def dfs(i: int) -> None:\n      nonlocal ans\n      if i == n:\n        ans += 1\n        return\n\n      for j in range(n):\n        if cols[j] or diag1[i + j] or diag2[j - i + n - 1]:\n          continue\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = True\n        dfs(i + 1)\n        cols[j] = diag1[i + j] = diag2[j - i + n - 1] = False\n\n    dfs(0)\n    return ans",
      "title": "52. N-Queens II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09a2908a-2b29-44e0-92a9-9a2a1a527246",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  # the sum of the subarray starting from the first number\n  maxSubarraySumLeft: int\n  # the sum of the subarray ending in the last number\n  maxSubarraySumRight: int\n  maxSubarraySum: int\n\n\nclass Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    def divideAndConquer(l: int, r: int) -> T:\n      if l == r:\n        return T(nums[l], nums[l], nums[l], nums[l])\n      m = (l + r) // 2\n      left = divideAndConquer(l, m)\n      right = divideAndConquer(m + 1, r)\n      maxSubarraySumLeft = max(left.maxSubarraySumLeft,\n                               left.summ + right.maxSubarraySumLeft)\n      maxSubarraySumRight = max(\n          left.maxSubarraySumRight + right.summ, right.maxSubarraySumRight)\n      maxSubarraySum = max(left.maxSubarraySumRight + right.maxSubarraySumLeft,\n                           left.maxSubarraySum, right.maxSubarraySum)\n      summ = left.summ + right.summ\n      return T(summ, maxSubarraySumLeft, maxSubarraySumRight, maxSubarraySum)\n\n    return divideAndConquer(0, len(nums) - 1).maxSubarraySum",
      "title": "53. Maximum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3353ad9d-1618-45ee-908a-00342d700740",
      "code": "class Solution:\n  def maxSubArray(self, nums: list[int]) -> int:\n    # dp[i] := the maximum sum subarray ending in i\n    dp = [0] * len(nums)\n\n    dp[0] = nums[0]\n    for i in range(1, len(nums)):\n      dp[i] = max(nums[i], dp[i - 1] + nums[i])\n\n    return max(dp)",
      "title": "53. Maximum Subarray_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6fbdb53-6a31-4def-996a-58d600346237",
      "code": "class Solution:\n  def spiralOrder(self, matrix: list[list[int]]) -> list[int]:\n    if not matrix:\n      return []\n\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = []\n    r1 = 0\n    c1 = 0\n    r2 = m - 1\n    c2 = n - 1\n\n    # Repeatedly add matrix[r1..r2][c1..c2] to `ans`.\n    while len(ans) < m * n:\n      j = c1\n      while j <= c2 and len(ans) < m * n:\n        ans.append(matrix[r1][j])\n        j += 1\n      i = r1 + 1\n      while i <= r2 - 1 and len(ans) < m * n:\n        ans.append(matrix[i][c2])\n        i += 1\n      j = c2\n      while j >= c1 and len(ans) < m * n:\n        ans.append(matrix[r2][j])\n        j -= 1\n      i = r2 - 1\n      while i >= r1 + 1 and len(ans) < m * n:\n        ans.append(matrix[i][c1])\n        i -= 1\n      r1 += 1\n      c1 += 1\n      r2 -= 1\n      c2 -= 1\n\n    return ans",
      "title": "54. Spiral Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d50dbd8a-f686-4b31-9d26-0f4d6918d36b",
      "code": "class Solution:\n  def canJump(self, nums: list[int]) -> bool:\n    i = 0\n    reach = 0\n\n    while i < len(nums) and i <= reach:\n      reach = max(reach, i + nums[i])\n      i += 1\n\n    return i == len(nums)",
      "title": "55. Jump Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2180b70-e535-4451-9144-b01ceeba723e",
      "code": "class Solution:\n  def merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    for interval in sorted(intervals):\n      if not ans or ans[-1][1] < interval[0]:\n        ans.append(interval)\n      else:\n        ans[-1][1] = max(ans[-1][1], interval[1])\n\n    return ans",
      "title": "56. Merge Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3186e4b3-2b48-477d-9faf-5bfdbd99c25b",
      "code": "class Solution:\n  def insert(self, intervals: list[list[int]],\n             newInterval: list[int]) -> list[list[int]]:\n    n = len(intervals)\n    ans = []\n    i = 0\n\n    while i < n and intervals[i][1] < newInterval[0]:\n      ans.append(intervals[i])\n      i += 1\n\n    # Merge overlapping intervals.\n    while i < n and intervals[i][0] <= newInterval[1]:\n      newInterval[0] = min(newInterval[0], intervals[i][0])\n      newInterval[1] = max(newInterval[1], intervals[i][1])\n      i += 1\n\n    ans.append(newInterval)\n\n    while i < n:\n      ans.append(intervals[i])\n      i += 1\n\n    return ans",
      "title": "57. Insert Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72474fa4-ad0f-4d9e-8d79-1811005c3010",
      "code": "class Solution:\n  def lengthOfLastWord(self, s: str) -> int:\n    i = len(s) - 1\n\n    while i >= 0 and s[i] == ' ':\n      i -= 1\n    lastIndex = i\n    while i >= 0 and s[i] != ' ':\n      i -= 1\n\n    return lastIndex - i",
      "title": "58. Length of Last Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5576ffe7-e67e-4557-9ce2-b5a78ab68bb1",
      "code": "class Solution:\n  def generateMatrix(self, n: int) -> list[list[int]]:\n    ans = [[0] * n for _ in range(n)]\n    count = 1\n\n    for mn in range(n // 2):\n      mx = n - mn - 1\n      for i in range(mn, mx):\n        ans[mn][i] = count\n        count += 1\n      for i in range(mn, mx):\n        ans[i][mx] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[mx][i] = count\n        count += 1\n      for i in range(mx, mn, -1):\n        ans[i][mn] = count\n        count += 1\n\n    if n % 2 == 1:\n      ans[n // 2][n // 2] = count\n\n    return ans",
      "title": "59. Spiral Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea61ca29-3c26-4160-b2c2-8b1a7c78884e",
      "code": "class Solution:\n  def getPermutation(self, n: int, k: int) -> str:\n    ans = ''\n    nums = [i + 1 for i in range(n)]\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = fact[i - 1] * i\n\n    k -= 1  # 0-indexed\n\n    for i in reversed(range(n)):\n      j = k // fact[i]\n      k %= fact[i]\n      ans += str(nums[j])\n      nums.pop(j)\n\n    return ans",
      "title": "60. Permutation Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "701ac24b-97d3-4f61-bfd6-07436b156cd7",
      "code": "class Solution:\n  def rotateRight(self, head: ListNode, k: int) -> ListNode:\n    if not head or not head.next or k == 0:\n      return head\n\n    tail = head\n    length = 1\n    while tail.next:\n      tail = tail.next\n      length += 1\n    tail.next = head  # Circle the list.\n\n    t = length - k % length\n    for _ in range(t):\n      tail = tail.next\n    newHead = tail.next\n    tail.next = None\n\n    return newHead",
      "title": "61. Rotate List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9a80b0c-c305-4195-a4a3-1249c9a9ffed",
      "code": "class Solution:\n  def uniquePaths(self, m: int, n: int) -> int:\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[1] * n for _ in range(m)]\n\n    for i in range(1, m):\n      for j in range(1, n):\n        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[-1][-1]",
      "title": "62. Unique Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86e567be-e4de-4c5d-9aa4-a40648112db5",
      "code": "class Solution:\n  def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:\n    m = len(obstacleGrid)\n    n = len(obstacleGrid[0])\n    # dp[i][j] := the number of unique paths from (0, 0) to (i, j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n    dp[0][1] = 1  # Can also set dp[1][0] = 1.\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if obstacleGrid[i - 1][j - 1] == 0:\n          dp[i][j] = dp[i - 1][j] + dp[i][j - 1]\n\n    return dp[m][n]",
      "title": "63. Unique Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f58a747-552c-45fe-b92e-e673440fd533",
      "code": "class Solution:\n  def minPathSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if i > 0 and j > 0:\n          grid[i][j] += min(grid[i - 1][j], grid[i][j - 1])\n        elif i > 0:\n          grid[i][0] += grid[i - 1][0]\n        elif j > 0:\n          grid[0][j] += grid[0][j - 1]\n\n    return grid[m - 1][n - 1]",
      "title": "64. Minimum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37dfe459-9ede-475a-ada5-e66c8f77846f",
      "code": "class Solution:\n  def isNumber(self, s: str) -> bool:\n    s = s.strip()\n    if not s:\n      return False\n\n    seenNum = False\n    seenDot = False\n    seenE = False\n\n    for i, c in enumerate(s):\n      if c == '.':\n        if seenDot or seenE:\n          return False\n        seenDot = True\n      elif c == 'e' or c == 'E':\n        if seenE or not seenNum:\n          return False\n        seenE = True\n        seenNum = False\n      elif c in '+-':\n        if i > 0 and s[i - 1] not in 'eE':\n          return False\n        seenNum = False\n      else:\n        if not c.isdigit():\n          return False\n        seenNum = True\n\n    return seenNum",
      "title": "65. Valid Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe61dc88-00f8-4d17-adcf-987a0be7c851",
      "code": "class Solution:\n  def plusOne(self, digits: list[int]) -> list[int]:\n    for i, d in reversed(list(enumerate(digits))):\n      if d < 9:\n        digits[i] += 1\n        return digits\n      digits[i] = 0\n\n    return [1] + digits",
      "title": "66. Plus One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61a391ba-03e2-48bb-b953-6a296ee2bec9",
      "code": "class Solution:\n  def addBinary(self, a: str, b: str) -> str:\n    ans = []\n    carry = 0\n    i = len(a) - 1\n    j = len(b) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(a[i])\n        i -= 1\n      if j >= 0:\n        carry += int(b[j])\n        j -= 1\n      ans.append(str(carry % 2))\n      carry //= 2\n\n    return ''.join(reversed(ans))",
      "title": "67. Add Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02d1cbce-9556-49ff-a264-5b52eef4ef9d",
      "code": "class Solution:\n  def fullJustify(self, words: list[str], maxWidth: int) -> list[str]:\n    ans = []\n    row = []\n    rowLetters = 0\n\n    for word in words:\n      # If we place the word in this row, it will exceed the maximum width.\n      # Therefore, we cannot put the word in this row and have to pad spaces\n      # for each word in this row.\n      if rowLetters + len(word) + len(row) > maxWidth:\n        for i in range(maxWidth - rowLetters):\n          row[i % (len(row) - 1 or 1)] += ' '\n        ans.append(''.join(row))\n        row = []\n        rowLetters = 0\n      row.append(word)\n      rowLetters += len(word)\n\n    return ans + [' '.join(row).ljust(maxWidth)]",
      "title": "68. Text Justification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35493544-e146-40d5-8795-e061ebfc404d",
      "code": "class Solution:\n  def mySqrt(self, x: int) -> int:\n    return bisect.bisect_right(range(x + 1), x,\n                               key=lambda m: m * m) - 1",
      "title": "69. Sqrt(x)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b66b4d04-641f-407a-85e2-1d68c3eb0d1d",
      "code": "class Solution:\n  def climbStairs(self, n: int) -> int:\n    # dp[i] := the number of ways to climb to the i-th stair\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      dp[i] = dp[i - 1] + dp[i - 2]\n\n    return dp[n]",
      "title": "70. Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32649e5d-bba1-47de-8530-dc31974f4ccb",
      "code": "class Solution:\n  def simplifyPath(self, path: str) -> str:\n    stack = []\n\n    for str in path.split('/'):\n      if str in ('', '.'):\n        continue\n      if str == '..':\n        if stack:\n          stack.pop()\n      else:\n        stack.append(str)\n\n    return '/' + '/'.join(stack)",
      "title": "71. Simplify Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "727a7c25-66a7-46f7-90fa-2159d8d5d159",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    m = len(word1)\n    n = len(word2)\n    # dp[i][j] := the minimum number of operations to convert word1[0..i) to\n    # word2[0..j)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      dp[i][0] = i\n\n    for j in range(1, n + 1):\n      dp[0][j] = j\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if word1[i - 1] == word2[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1]\n        else:\n          dp[i][j] = min(dp[i - 1][j - 1], dp[i - 1][j], dp[i][j - 1]) + 1\n\n    return dp[m][n]",
      "title": "72. Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36447001-44dc-41be-8922-290ff361e42b",
      "code": "class Solution:\n  def setZeroes(self, matrix: list[list[int]]) -> None:\n    m = len(matrix)\n    n = len(matrix[0])\n    shouldFillFirstRow = 0 in matrix[0]\n    shouldFillFirstCol = 0 in list(zip(*matrix))[0]\n\n    # Store the information in the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][j] == 0:\n          matrix[i][0] = 0\n          matrix[0][j] = 0\n\n    # Fill 0s for the matrix except the first row and the first column.\n    for i in range(1, m):\n      for j in range(1, n):\n        if matrix[i][0] == 0 or matrix[0][j] == 0:\n          matrix[i][j] = 0\n\n    # Fill 0s for the first row if needed.\n    if shouldFillFirstRow:\n      matrix[0] = [0] * n\n\n    # Fill 0s for the first column if needed.\n    if shouldFillFirstCol:\n      for row in matrix:\n        row[0] = 0",
      "title": "73. Set Matrix Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3003570-fb66-4916-ba61-6d7453e9bb8e",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    if not matrix:\n      return False\n\n    m = len(matrix)\n    n = len(matrix[0])\n    l = 0\n    r = m * n\n\n    while l < r:\n      mid = (l + r) // 2\n      i = mid // n\n      j = mid % n\n      if matrix[i][j] == target:\n        return True\n      if matrix[i][j] < target:\n        l = mid + 1\n      else:\n        r = mid\n\n    return False",
      "title": "74. Search a 2D Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27e1a2dd-a90a-42a0-a152-cf839aa099de",
      "code": "class Solution:\n  def sortColors(self, nums: list[int]) -> None:\n    l = 0  # The next 0 should be placed in l.\n    r = len(nums) - 1  # THe next 2 should be placed in r.\n\n    i = 0\n    while i <= r:\n      if nums[i] == 0:\n        nums[i], nums[l] = nums[l], nums[i]\n        i += 1\n        l += 1\n      elif nums[i] == 1:\n        i += 1\n      else:\n        # We may swap a 0 to index i, but we're still not sure whether this 0\n        # is placed in the correct index, so we can't move pointer i.\n        nums[i], nums[r] = nums[r], nums[i]\n        r -= 1",
      "title": "75. Sort Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f482825-0e9b-4b4a-84c9-406713dc7315",
      "code": "class Solution:\n  def minWindow(self, s: str, t: str) -> str:\n    count = collections.Counter(t)\n    required = len(t)\n    bestLeft = -1\n    minLength = len(s) + 1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        count[s[l]] += 1\n        if count[s[l]] > 0:\n          required += 1\n        l += 1\n\n    return '' if bestLeft == -1 else s[bestLeft: bestLeft + minLength]",
      "title": "76. Minimum Window Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b25a6a67-1438-4fe4-ba9c-d10a84c19bdb",
      "code": "class Solution:\n  def combine(self, n: int, k: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) == k:\n        ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        path.append(i)\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(1, [])\n    return ans",
      "title": "77. Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b9f5983-b24e-4a0b-a4ec-f5089a173e16",
      "code": "class Solution:\n  def subsets(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n\n      for i in range(s, len(nums)):\n        dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "78. Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0a99c40-22e6-4949-868b-be6fde0b6b91",
      "code": "class Solution:\n  def exist(self, board: list[list[str]], word: str) -> bool:\n    m = len(board)\n    n = len(board[0])\n\n    def dfs(i: int, j: int, s: int) -> bool:\n      if i < 0 or i == m or j < 0 or j == n:\n        return False\n      if board[i][j] != word[s] or board[i][j] == '*':\n        return False\n      if s == len(word) - 1:\n        return True\n\n      cache = board[i][j]\n      board[i][j] = '*'\n      isExist = (dfs(i + 1, j, s + 1) or\n                 dfs(i - 1, j, s + 1) or\n                 dfs(i, j + 1, s + 1) or\n                 dfs(i, j - 1, s + 1))\n      board[i][j] = cache\n\n      return isExist\n\n    return any(dfs(i, j, 0)\n               for i in range(m)\n               for j in range(n))",
      "title": "79. Word Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60cdeb5a-b3e7-4596-b021-929edfdc26d6",
      "code": "class Solution:\n  def removeDuplicates(self, nums: list[int]) -> int:\n    i = 0\n\n    for num in nums:\n      if i < 2 or num != nums[i - 2]:\n        nums[i] = num\n        i += 1\n\n    return i",
      "title": "80. Remove Duplicates from Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8866201b-107d-45fd-8bb8-0e5717d657a9",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> bool:\n    l = 0\n    r = len(nums) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if nums[m] == target:\n        return True\n      if nums[l] == nums[m] == nums[r]:\n        l += 1\n        r -= 1\n      elif nums[l] <= nums[m]:  # nums[l..m] are sorted\n        if nums[l] <= target < nums[m]:\n          r = m - 1\n        else:\n          l = m + 1\n      else:  # nums[m..n - 1] are sorted\n        if nums[m] < target <= nums[r]:\n          l = m + 1\n        else:\n          r = m - 1\n\n    return False",
      "title": "81. Search in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8f9b3f1-00ff-498e-86c1-e47b0ccc4cf3",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      while head.next and head.val == head.next.val:\n        head = head.next\n      if prev.next == head:\n        prev = prev.next\n      else:\n        prev.next = head.next\n      head = head.next\n\n    return dummy.next",
      "title": "82. Remove Duplicates from Sorted List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e89d2889-7fab-4fa1-aac5-c35e4fe2e7d7",
      "code": "class Solution:\n  def deleteDuplicates(self, head: ListNode) -> ListNode:\n    curr = head\n\n    while curr:\n      while curr.next and curr.val == curr.next.val:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return head",
      "title": "83. Remove Duplicates from Sorted List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10ec7700-ce51-4723-af5b-05b8e16fc669",
      "code": "class Solution:\n  def largestRectangleArea(self, heights: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(heights) + 1):\n      while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n        h = heights[stack.pop()]\n        w = i - stack[-1] - 1 if stack else i\n        ans = max(ans, h * w)\n      stack.append(i)\n\n    return ans",
      "title": "84. Largest Rectangle in Histogram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb7e4f82-e969-4876-bae1-9bffb76b102f",
      "code": "class Solution:\n  def maximalRectangle(self, matrix: list[list[str]]) -> int:\n    if not matrix:\n      return 0\n\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    def largestRectangleArea(heights: list[int]) -> int:\n      ans = 0\n      stack = []\n\n      for i in range(len(heights) + 1):\n        while stack and (i == len(heights) or heights[stack[-1]] > heights[i]):\n          h = heights[stack.pop()]\n          w = i - stack[-1] - 1 if stack else i\n          ans = max(ans, h * w)\n        stack.append(i)\n\n      return ans\n\n    for row in matrix:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == '0' else hist[i] + 1\n      ans = max(ans, largestRectangleArea(hist))\n\n    return ans",
      "title": "85. Maximal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e88fc85e-4f3d-4704-82a3-cab65e5e1a40",
      "code": "class Solution:\n  def partition(self, head: ListNode, x: int) -> ListNode:\n    beforeHead = ListNode(0)\n    afterHead = ListNode(0)\n    before = beforeHead\n    after = afterHead\n\n    while head:\n      if head.val < x:\n        before.next = head\n        before = head\n      else:\n        after.next = head\n        after = head\n      head = head.next\n\n    after.next = None\n    before.next = afterHead.next\n\n    return beforeHead.next",
      "title": "86. Partition List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85317160-c916-445d-bfc4-7728493a207a",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def isScramble(self, s1: str, s2: str) -> bool:\n    if s1 == s2:\n      return True\n    if collections.Counter(s1) != collections.Counter(s2):\n      return False\n\n    for i in range(1, len(s1)):\n      if self.isScramble(s1[:i], s2[:i]) and self.isScramble(s1[i:], s2[i:]):\n        return True\n      if (self.isScramble(s1[:i], s2[len(s2) - i:]) and\n              self.isScramble(s1[i:], s2[: len(s2) - i])):\n        return True\n\n    return False",
      "title": "87. Scramble String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b80bdaec-dfff-475a-8995-2208ad1f330d",
      "code": "class Solution:\n  def merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -> None:\n    i = m - 1  # nums1's index (the actual nums)\n    j = n - 1  # nums2's index\n    k = m + n - 1  # nums1's index (the next filled position)\n\n    while j >= 0:\n      if i >= 0 and nums1[i] > nums2[j]:\n        nums1[k] = nums1[i]\n        k -= 1\n        i -= 1\n      else:\n        nums1[k] = nums2[j]\n        k -= 1\n        j -= 1",
      "title": "88. Merge Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9653dbad-0dee-4d3d-bcaf-66a5824e7059",
      "code": "class Solution:\n  def grayCode(self, n: int) -> list[int]:\n    ans = [0]\n\n    for i in range(n):\n      for j in reversed(range(len(ans))):\n        ans.append(ans[j] | 1 << i)\n\n    return ans",
      "title": "89. Gray Code",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "275890e6-df9a-42bd-b580-d431d332012a",
      "code": "class Solution:\n  def subsetsWithDup(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      ans.append(path)\n      if s == len(nums):\n        return\n\n      for i in range(s, len(nums)):\n        if i > s and nums[i] == nums[i - 1]:\n          continue\n        dfs(i + 1, path + [nums[i]])\n\n    nums.sort()\n    dfs(0, [])\n    return ans",
      "title": "90. Subsets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d0f8f45-cd55-43cd-8f5c-32e28444e5dc",
      "code": "class Solution:\n  def numDecodings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the number of ways to decode s[i..n)\n    dp = [0] * n + [1]\n\n    def isValid(a: str, b=None) -> bool:\n      if b:\n        return a == '1' or a == '2' and b < '7'\n      return a != '0'\n\n    if isValid(s[-1]):\n      dp[n - 1] = 1\n\n    for i in reversed(range(n - 1)):\n      if isValid(s[i]):\n        dp[i] += dp[i + 1]\n      if isValid(s[i], s[i + 1]):\n        dp[i] += dp[i + 2]\n\n    return dp[0]",
      "title": "91. Decode Ways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8ecd329-bb74-49eb-96d4-fff25408ae00",
      "code": "class Solution:\n  def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:\n    if not head and m == n:\n      return head\n\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    for _ in range(m - 1):\n      prev = prev.next  # Point to the node before the sublist [m, n].\n\n    tail = prev.next  # Be the tail of the sublist [m, n].\n\n    # Reverse the sublist [m, n] one by one.\n    for _ in range(n - m):\n      cache = tail.next\n      tail.next = cache.next\n      cache.next = prev.next\n      prev.next = cache\n\n    return dummy.next",
      "title": "92. Reverse Linked List II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bae6962-407c-4cc1-8df3-502cd99744b9",
      "code": "class Solution:\n  def restoreIpAddresses(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(start: int, path: list[int]) -> None:\n      if len(path) == 4 and start == len(s):\n        ans.append(path[0] + '.' + path[1] + '.' + path[2] + '.' + path[3])\n        return\n      if len(path) == 4 or start == len(s):\n        return\n\n      for length in range(1, 4):\n        if start + length > len(s):\n          return  # out-of-bounds\n        if length > 1 and s[start] == '0':\n          return  # leading '0'\n        num = s[start: start + length]\n        if int(num) > 255:\n          return\n        dfs(start + length, path + [num])\n\n    dfs(0, [])\n    return ans",
      "title": "93. Restore IP Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfbb1162-d961-432d-864a-4c8f11d779c7",
      "code": "class Solution:\n  def inorderTraversal(self, root: TreeNode | None) -> list[int]:\n    ans = []\n    stack = []\n\n    while root or stack:\n      while root:\n        stack.append(root)\n        root = root.left\n      root = stack.pop()\n      ans.append(root.val)\n      root = root.right\n\n    return ans",
      "title": "94. Binary Tree Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d133e185-3ab7-4162-abc3-2fc2831c500f",
      "code": "class Solution:\n  def generateTrees(self, n: int) -> list[TreeNode]:\n    if n == 0:\n      return []\n\n    def generateTrees(mn: int, mx: int) -> list[int | None]:\n      if mn > mx:\n        return [None]\n\n      ans = []\n\n      for i in range(mn, mx + 1):\n        for left in generateTrees(mn, i - 1):\n          for right in generateTrees(i + 1, mx):\n            ans.append(TreeNode(i))\n            ans[-1].left = left\n            ans[-1].right = right\n\n      return ans\n\n    return generateTrees(1, n)",
      "title": "95. Unique Binary Search Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb816425-cee2-44c0-9884-fae1eca06cbc",
      "code": "class Solution:\n  def numTrees(self, n: int) -> int:\n    # dp[i] := the number of unique BST's that store values 1..i\n    dp = [1, 1] + [0] * (n - 1)\n\n    for i in range(2, n + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - j - 1]\n\n    return dp[n]",
      "title": "96. Unique Binary Search Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2969b2e1-5592-439e-a731-c63c784a0e65",
      "code": "class Solution:\n  def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n    m = len(s1)\n    n = len(s2)\n    if m + n != len(s3):\n      return False\n\n    # dp[i][j] := true if s3[0..i + j) is formed by the interleaving of\n    # s1[0..i) and s2[0..j)\n    dp = [[False] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = True\n\n    for i in range(1, m + 1):\n      dp[i][0] = dp[i - 1][0] and s1[i - 1] == s3[i - 1]\n\n    for j in range(1, n + 1):\n      dp[0][j] = dp[0][j - 1] and s2[j - 1] == s3[j - 1]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j] and s1[i - 1] == s3[i + j - 1] or\n                    dp[i][j - 1] and s2[j - 1] == s3[i + j - 1])\n\n    return dp[m][n]",
      "title": "97. Interleaving String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75ea448b-383c-4dc8-b8ea-5f3304927ea0",
      "code": "class Solution:\n  def isValidBST(self, root: TreeNode | None) -> bool:\n    def isValidBST(root: TreeNode | None,\n                   minNode: TreeNode | None, maxNode: TreeNode | None) -> bool:\n      if not root:\n        return True\n      if minNode and root.val <= minNode.val:\n        return False\n      if maxNode and root.val >= maxNode.val:\n        return False\n\n      return (isValidBST(root.left, minNode, root) and\n              isValidBST(root.right, root, maxNode))\n\n    return isValidBST(root, None, None)",
      "title": "98. Validate Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ae32625-429c-403d-96c6-9f992a99e54e",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    pred = None\n    x = None  # the first wrong node\n    y = None  # the second wrong node\n\n    def findPredecessor(root: TreeNode | None) -> TreeNode | None:\n      pred = root.left\n      while pred.right and pred.right != root:\n        pred = pred.right\n      return pred\n\n    while root:\n      if root.left:\n        morrisPred = findPredecessor(root)\n        if morrisPred.right:\n          # The node has already been connected before.\n          # Start the main logic.\n          if pred and root.val < pred.val:\n            y = root\n            if not x:\n              x = pred\n          pred = root\n          # End of the main logic\n          morrisPred.right = None  # Break the connection.\n          root = root.right\n        else:\n          morrisPred.right = root  # Connect it.\n          root = root.left\n      else:\n        # Start the main logic.\n        if pred and root.val < pred.val:\n          y = root\n          if not x:\n            x = pred\n        pred = root\n        # End of the main logic.\n        root = root.right\n\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    swap(x, y)",
      "title": "99. Recover Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a0efe67-1091-4e2e-97cd-5cc748edf2eb",
      "code": "class Solution:\n  def recoverTree(self, root: TreeNode | None) -> None:\n    def swap(x: TreeNode | None, y: TreeNode | None) -> None:\n      temp = x.val\n      x.val = y.val\n      y.val = temp\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n\n      if self.pred and root.val < self.pred.val:\n        self.y = root\n        if not self.x:\n          self.x = self.pred\n        else:\n          return\n      self.pred = root\n\n      inorder(root.right)\n\n    inorder(root)\n    swap(self.x, self.y)\n\n  pred = None\n  x = None  # the first wrong node\n  y = None  # the second wrong node",
      "title": "99. Recover Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2a2107c-3913-4b26-a808-6a529860be10",
      "code": "class Solution:\n  def isSameTree(self, p: TreeNode | None, q: TreeNode | None) -> bool:\n    if not p or not q:\n      return p == q\n    return (p.val == q.val and\n            self.isSameTree(p.left, q.left) and\n            self.isSameTree(p.right, q.right))",
      "title": "100. Same Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94f43160-208b-440f-b7cb-701d65857703",
      "code": "class Solution:\n  def isSymmetric(self, root: TreeNode | None) -> bool:\n    def isSymmetric(p: TreeNode | None, q: TreeNode | None) -> bool:\n      if not p or not q:\n        return p == q\n      return (p.val == q.val and\n              isSymmetric(p.left, q.right) and\n              isSymmetric(p.right, q.left))\n\n    return isSymmetric(root, root)",
      "title": "101. Symmetric Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b29fabda-9652-4db0-8a5b-0aafdee314d0",
      "code": "class Solution:\n  def levelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans",
      "title": "102. Binary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0b12cc6-da28-4140-b222-71f4e67ac950",
      "code": "class Solution:\n  def zigzagLevelOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    dq = collections.deque([root])\n    isLeftToRight = True\n\n    while dq:\n      currLevel = []\n      for _ in range(len(dq)):\n        if isLeftToRight:\n          node = dq.popleft()\n          currLevel.append(node.val)\n          if node.left:\n            dq.append(node.left)\n          if node.right:\n            dq.append(node.right)\n        else:\n          node = dq.pop()\n          currLevel.append(node.val)\n          if node.right:\n            dq.appendleft(node.right)\n          if node.left:\n            dq.appendleft(node.left)\n      ans.append(currLevel)\n      isLeftToRight = not isLeftToRight\n\n    return ans",
      "title": "103. Binary Tree Zigzag Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e27f9621-2a3a-4371-bd04-b06fd280ea77",
      "code": "class Solution:\n  def maxDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    return 1 + max(self.maxDepth(root.left), self.maxDepth(root.right))",
      "title": "104. Maximum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c2f9635-1e0d-4a89-878a-560cd956ce58",
      "code": "class Solution:\n  def buildTree(\n      self,\n      preorder: list[int],\n      inorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        preStart: int,\n        preEnd: int,\n        inStart: int,\n        inEnd: int,\n    ) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n\n      rootVal = preorder[preStart]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        inStart, rootInIndex - 1)\n      root.right = build(preStart + leftSize + 1,\n                         preEnd, rootInIndex + 1, inEnd)\n      return root\n\n    return build(0, len(preorder) - 1, 0, len(inorder) - 1)",
      "title": "105. Construct Binary Tree from Preorder and Inorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f1a9919-8533-40bb-832f-9b334e330a75",
      "code": "class Solution:\n  def buildTree(\n      self,\n      inorder: list[int],\n      postorder: list[int],\n  ) -> TreeNode | None:\n    inToIndex = {num: i for i, num in enumerate(inorder)}\n\n    def build(\n        inStart: int,\n        inEnd: int,\n        postStart: int,\n        postEnd: int,\n    ) -> TreeNode | None:\n      if inStart > inEnd:\n        return None\n\n      rootVal = postorder[postEnd]\n      rootInIndex = inToIndex[rootVal]\n      leftSize = rootInIndex - inStart\n\n      root = TreeNode(rootVal)\n      root.left = build(inStart, rootInIndex - 1,  postStart,\n                        postStart + leftSize - 1)\n      root.right = build(rootInIndex + 1, inEnd,  postStart + leftSize,\n                         postEnd - 1)\n      return root\n\n    return build(0, len(inorder) - 1, 0, len(postorder) - 1)",
      "title": "106. Construct Binary Tree from Inorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f15e5125-11bf-47fd-bc84-935a9595fe35",
      "code": "class Solution:\n  def levelOrderBottom(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      ans.append(currLevel)\n\n    return ans[::-1]",
      "title": "107. Binary Tree Level Order Traversal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcad6471-e5de-46ad-ab7e-d9e841f06b61",
      "code": "class Solution:\n  def sortedArrayToBST(self, nums: list[int]) -> TreeNode | None:\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "108. Convert Sorted Array to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75db18ad-f403-42e1-8af2-1f6b2be41f75",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode | None) -> TreeNode | None:\n    def helper(l: int, r: int) -> TreeNode | None:\n      nonlocal head\n      if l > r:\n        return None\n\n      m = (l + r) // 2\n\n      # Simulate inorder traversal: recursively form the left half.\n      left = helper(l, m - 1)\n\n      # Once the left half is traversed, process the current node.\n      root = TreeNode(head.val)\n      root.left = left\n\n      # Maintain the invariance.\n      head = head.next\n\n      # Simulate inorder traversal: recursively form the right half.\n      root.right = helper(m + 1, r)\n      return root\n\n    return helper(0, self._getLength(head) - 1)\n\n  def _getLength(self, head: ListNode | None) -> int:\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n    return length",
      "title": "109. Convert Sorted List to Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "053843a9-6ab4-481d-9d06-1ea637c291fb",
      "code": "class Solution:\n  def sortedListToBST(self, head: ListNode) -> TreeNode:\n    def findMid(head: ListNode) -> ListNode:\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    if not head:\n      return None\n    if not head.next:\n      return TreeNode(head.val)\n\n    mid = findMid(head)\n    root = TreeNode(mid.val)\n    root.left = self.sortedListToBST(head)\n    root.right = self.sortedListToBST(mid.next)\n    return root",
      "title": "109. Convert Sorted List to Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0139523e-2cac-400b-b7c3-ad0fe6bd5dcb",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    def maxDepth(root: TreeNode | None) -> int:\n      \"\"\"Returns the height of root if root is balanced; otherwise, returns -1.\"\"\"\n      if not root:\n        return 0\n\n      left = maxDepth(root.left)\n      if left == -1:\n        return -1\n      right = maxDepth(root.right)\n      if right == -1:\n        return -1\n      if abs(left - right) > 1:\n        return -1\n\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return maxDepth(root) != -1",
      "title": "110. Balanced Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efc7577c-f1f9-46c9-96d7-2f7aaaebbdbf",
      "code": "class Solution:\n  def isBalanced(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n\n    def maxDepth(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxDepth(root.left), maxDepth(root.right))\n\n    return (abs(maxDepth(root.left) - maxDepth(root.right)) <= 1 and\n            self.isBalanced(root.left) and\n            self.isBalanced(root.right))",
      "title": "110. Balanced Binary Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dcbe684-6dd1-47ce-aad5-3308577e90e2",
      "code": "class Solution:\n  def minDepth(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    q = collections.deque([root])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        node = q.popleft()\n        if not node.left and not node.right:\n          return step\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      step += 1",
      "title": "111. Minimum Depth of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3db47950-72d0-4dbf-8dee-5c6ae55bdc0e",
      "code": "class Solution:\n  def hasPathSum(self, root: TreeNode, summ: int) -> bool:\n    if not root:\n      return False\n    if root.val == summ and not root.left and not root.right:\n      return True\n    return (self.hasPathSum(root.left, summ - root.val) or\n            self.hasPathSum(root.right, summ - root.val))",
      "title": "112. Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a744600-bdef-478a-9c6b-8cc0639e4e59",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode, summ: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(root: TreeNode, summ: int, path: list[int]) -> None:\n      if not root:\n        return\n      if root.val == summ and not root.left and not root.right:\n        ans.append(path + [root.val])\n        return\n\n      dfs(root.left, summ - root.val, path + [root.val])\n      dfs(root.right, summ - root.val, path + [root.val])\n\n    dfs(root, summ, [])\n    return ans",
      "title": "113. Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09fc8fed-24c4-4633-b528-0c26e89d37e2",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88fb2af5-3ed2-496f-99af-67eb3cc9debe",
      "code": "class Solution:\n  def flatten(self, root: TreeNode | None) -> None:\n    if not root:\n      return\n\n    self.flatten(root.left)\n    self.flatten(root.right)\n\n    left = root.left  # flattened left\n    right = root.right  # flattened right\n\n    root.left = None\n    root.right = left\n\n    # Connect the original right subtree to the end of the new right subtree.\n    rightmost = root\n    while rightmost.right:\n      rightmost = rightmost.right\n    rightmost.right = right",
      "title": "114. Flatten Binary Tree to Linked List_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d31b7bd-f887-42ca-9aa0-489d29a85ad4",
      "code": "class Solution:\n  def numDistinct(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1):\n      dp[i][0] = 1\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if s[i - 1] == t[j - 1]:\n          dp[i][j] = dp[i - 1][j - 1] + dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j]\n\n    return dp[m][n]",
      "title": "115. Distinct Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a9e06a7-ff4e-4075-b578-0cf476391fda",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node and node.left:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        needle.next = node.left\n        needle = needle.next\n        needle.next = node.right\n        needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "116. Populating Next Right Pointers in Each Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ebecc22-f7c3-4f90-8613-f3fb9fdf8649",
      "code": "class Solution:\n  def connect(self, root: 'Node') -> 'Node':\n    node = root  # the node that is above the current needling\n\n    while node:\n      dummy = Node(0)  # a dummy node before needling\n      # Needle the children of the node.\n      needle = dummy\n      while node:\n        if node.left:  # Needle the left child.\n          needle.next = node.left\n          needle = needle.next\n        if node.right:  # Needle the right child.\n          needle.next = node.right\n          needle = needle.next\n        node = node.next\n      node = dummy.next  # Move the node to the next level.\n\n    return root",
      "title": "117. Populating Next Right Pointers in Each Node II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2da3b2fb-169d-47d8-8a62-d5a3e57e99e1",
      "code": "class Solution:\n  def generate(self, numRows: int) -> list[list[int]]:\n    ans = []\n\n    for i in range(numRows):\n      ans.append([1] * (i + 1))\n\n    for i in range(2, numRows):\n      for j in range(1, len(ans[i]) - 1):\n        ans[i][j] = ans[i - 1][j - 1] + ans[i - 1][j]\n\n    return ans",
      "title": "118. Pascal's Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b5e856b-de8e-411d-8d6c-950322d2f488",
      "code": "class Solution:\n  def getRow(self, rowIndex: int) -> list[int]:\n    ans = [1] * (rowIndex + 1)\n\n    for i in range(2, rowIndex + 1):\n      for j in range(1, i):\n        ans[i - j] += ans[i - j - 1]\n\n    return ans",
      "title": "119. Pascal's Triangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a93614cb-f147-466b-9ba3-10eb3f164a0f",
      "code": "class Solution:\n  def minimumTotal(self, triangle: list[list[int]]) -> int:\n    for i in range(len(triangle) - 2, -1, -1):\n      for j in range(i + 1):\n        triangle[i][j] += min(triangle[i + 1][j],\n                              triangle[i + 1][j + 1])\n\n    return triangle[0][0]",
      "title": "120. Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afdc6c02-4b23-4990-b1ac-e3b01e75cf67",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellOne",
      "title": "121. Best Time to Buy and Sell Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "288c5f15-1e20-4fc6-a1cd-cc141b091042",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price)\n\n    return sell",
      "title": "122. Best Time to Buy and Sell Stock II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "105a302a-b255-4f28-b375-084d3c2c20e0",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sellTwo = 0\n    holdTwo = -math.inf\n    sellOne = 0\n    holdOne = -math.inf\n\n    for price in prices:\n      sellTwo = max(sellTwo, holdTwo + price)\n      holdTwo = max(holdTwo, sellOne - price)\n      sellOne = max(sellOne, holdOne + price)\n      holdOne = max(holdOne, -price)\n\n    return sellTwo",
      "title": "123. Best Time to Buy and Sell Stock III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e724e7c8-e90f-426b-890f-20549fb2d1c2",
      "code": "class Solution:\n  def maxPathSum(self, root: TreeNode | None) -> int:\n    ans = -math.inf\n\n    def maxPathSumDownFrom(root: TreeNode | None) -> int:\n      \"\"\"\n      Returns the maximum path sum starting from the current root, where\n      root.val is always included.\n      \"\"\"\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = max(0, maxPathSumDownFrom(root.left))\n      r = max(0, maxPathSumDownFrom(root.right))\n      ans = max(ans, root.val + l + r)\n      return root.val + max(l, r)\n\n    maxPathSumDownFrom(root)\n    return ans",
      "title": "124. Binary Tree Maximum Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "24bb70f0-da3d-491e-8f98-57060d4f2175",
      "code": "class Solution:\n  def isPalindrome(self, s: str) -> bool:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and not s[l].isalnum():\n        l += 1\n      while l < r and not s[r].isalnum():\n        r -= 1\n      if s[l].lower() != s[r].lower():\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "125. Valid Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c65623a-c7d9-425e-b575-6766d6d9e373",
      "code": "class Solution:\n  def findLadders(self, beginWord: str, endWord: str, wordList: list[str]) -> list[list[str]]:\n    wordSet = set(wordList)\n    if endWord not in wordList:\n      return []\n\n    # {\"hit\": [\"hot\"], \"hot\": [\"dot\", \"lot\"], ...}\n    graph: dict[str, list[str]] = collections.defaultdict(list)\n\n    # Build the graph from the beginWord to the endWord.\n    if not self._bfs(beginWord, endWord, wordSet, graph):\n      return []\n\n    ans = []\n\n    self._dfs(graph, beginWord, endWord, [beginWord], ans)\n    return ans\n\n  def _bfs(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordSet: set[str],\n      graph: dict[str, list[str]],\n  ) -> bool:\n    q1 = {beginWord}\n    q2 = {endWord}\n    backward = False\n\n    while q1 and q2:\n      for word in q1:\n        wordSet.discard(word)\n      for word in q2:\n        wordSet.discard(word)\n      # Always expand the smaller queue.\n      if len(q1) > len(q2):\n        q1, q2 = q2, q1\n        backward = not backward\n      q = set()\n      reachEndWord = False\n      for parent in q1:\n        for child in self._getChildren(parent, wordSet, q2):\n          if child in wordSet or child in q2:\n            q.add(child)\n            if backward:\n              graph[child].append(parent)\n            else:\n              graph[parent].append(child)\n          if child in q2:\n            reachEndWord = True\n      if reachEndWord:\n        return True\n      q1 = q\n\n    return False\n\n  def _getChildren(self, parent: str, wordSet: set[str], q2) -> list[str]:\n    children = []\n    s = list(parent)\n\n    for i, cache in enumerate(s):\n      for c in string.ascii_lowercase:\n        if c == cache:\n          continue\n        s[i] = c\n        child = ''.join(s)\n        if child in wordSet or child in q2:\n          children.append(child)\n      s[i] = cache\n\n    return children\n\n  def _dfs(\n      self,\n      graph: dict[str, list[str]],\n      word: str,\n      endWord: str,\n      path: list[str],\n      ans: list[list[str]],\n  ) -> None:\n    if word == endWord:\n      ans.append(path.copy())\n      return\n\n    for child in graph.get(word, []):\n      path.append(child)\n      self._dfs(graph, child, endWord, path, ans)\n      path.pop()",
      "title": "126. Word Ladder II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28547a6e-fbbf-4517-a8ff-7c42a6295fbf",
      "code": "class Solution:\n  def ladderLength(\n      self,\n      beginWord: str,\n      endWord: str,\n      wordList: list[str],\n  ) -> int:\n    wordSet = set(wordList)\n    if endWord not in wordSet:\n      return 0\n\n    q = collections.deque([beginWord])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for i, cache in enumerate(wordList):\n          for c in string.ascii_lowercase:\n            wordList[i] = c\n            word = ''.join(wordList)\n            if word == endWord:\n              return step + 1\n            if word in wordSet:\n              q.append(word)\n              wordSet.remove(word)\n          wordList[i] = cache\n      step += 1\n\n    return 0",
      "title": "127. Word Ladder",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28df08e4-3a17-49a7-bd6d-8f472cdde468",
      "code": "class Solution:\n  def longestConsecutive(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set(nums)\n\n    for num in seen:\n      # `num` is the start of a sequence.\n      if num - 1 in seen:\n        continue\n      length = 0\n      while num in seen:\n        num += 1\n        length += 1\n      ans = max(ans, length)\n\n    return ans",
      "title": "128. Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5927f60-4e99-4444-a867-b4da4806461e",
      "code": "class Solution:\n  def sumNumbers(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans += path * 10 + root.val\n        return\n\n      dfs(root.left, path * 10 + root.val)\n      dfs(root.right, path * 10 + root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "129. Sum Root to Leaf Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20e84ceb-95b0-444d-bb05-ad317df50dcb",
      "code": "class Solution:\n  def solve(self, board: list[list[str]]) -> None:\n    if not board:\n      return\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(board)\n    n = len(board[0])\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if board[i][j] == 'O':\n            q.append((i, j))\n            board[i][j] = '*'\n\n    # Mark the grids that stretch from the four sides with '*'.\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if board[x][y] != 'O':\n          continue\n        q.append((x, y))\n        board[x][y] = '*'\n\n    for row in board:\n      for i, c in enumerate(row):\n        row[i] = 'O' if c == '*' else 'X'",
      "title": "130. Surrounded Regions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59e7dc10-c456-4753-bf83-7c4304b2f24f",
      "code": "class Solution:\n  def partition(self, s: str) -> list[list[str]]:\n    ans = []\n\n    def isPalindrome(s: str) -> bool:\n      return s == s[::-1]\n\n    def dfs(s: str, j: int, path: list[str], ans: list[list[str]]) -> None:\n      if j == len(s):\n        ans.append(path)\n        return\n\n      for i in range(j, len(s)):\n        if isPalindrome(s[j: i + 1]):\n          dfs(s, i + 1, path + [s[j: i + 1]], ans)\n\n    dfs(s, 0, [], ans)\n    return ans",
      "title": "131. Palindrome Partitioning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0b06667-46cd-4c96-82d8-27bc950c989c",
      "code": "class Solution:\n  def minCut(self, s: str) -> int:\n    n = len(s)\n    # isPalindrome[i][j] := True if s[i..j] is a palindrome\n    isPalindrome = [[True] * n for _ in range(n)]\n    # dp[i] := the minimum cuts needed for a palindrome partitioning of s[0..i]\n    dp = [n] * n\n\n    for l in range(2, n + 1):\n      i = 0\n      for j in range(l - 1, n):\n        isPalindrome[i][j] = s[i] == s[j] and isPalindrome[i + 1][j - 1]\n        i += 1\n\n    for i in range(n):\n      if isPalindrome[0][i]:\n        dp[i] = 0\n        continue\n\n      # Try all the possible partitions.\n      for j in range(i):\n        if isPalindrome[j + 1][i]:\n          dp[i] = min(dp[i], dp[j] + 1)\n\n    return dp[-1]",
      "title": "132. Palindrome Partitioning II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88001456-f47a-4fb4-9811-2121aa70fc46",
      "code": "class Solution:\n  def cloneGraph(self, node: 'Node') -> 'Node':\n    if not node:\n      return None\n\n    q = collections.deque([node])\n    map = {node: Node(node.val)}\n\n    while q:\n      u = q.popleft()\n      for v in u.neighbors:\n        if v not in map:\n          map[v] = Node(v.val)\n          q.append(v)\n        map[u].neighbors.append(map[v])\n\n    return map[node]",
      "title": "133. Clone Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a654dec-44d2-48b3-b4c7-cd0faee2fc2b",
      "code": "class Solution:\n  def canCompleteCircuit(self, gas: list[int], cost: list[int]) -> int:\n    ans = 0\n    net = 0\n    summ = 0\n\n    # Try to start from each index.\n    for i in range(len(gas)):\n      net += gas[i] - cost[i]\n      summ += gas[i] - cost[i]\n      if summ < 0:\n        summ = 0\n        ans = i + 1  # Start from the next index.\n\n    return -1 if net < 0 else ans",
      "title": "134. Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56c9187c-7d01-47f0-9c83-320374c19601",
      "code": "class Solution:\n  def candy(self, ratings: list[int]) -> int:\n    n = len(ratings)\n\n    ans = 0\n    l = [1] * n\n    r = [1] * n\n\n    for i in range(1, n):\n      if ratings[i] > ratings[i - 1]:\n        l[i] = l[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if ratings[i] > ratings[i + 1]:\n        r[i] = r[i + 1] + 1\n\n    for a, b in zip(l, r):\n      ans += max(a, b)\n\n    return ans",
      "title": "135. Candy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a5d3151-b196-41ab-ad4d-5660c3b1a3d5",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums, 0)",
      "title": "136. Single Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89ac4c19-51a7-41a6-a632-bcdb39106784",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> int:\n    ones = 0\n    twos = 0\n\n    for num in nums:\n      ones ^= (num & ~twos)\n      twos ^= (num & ~ones)\n\n    return ones",
      "title": "137. Single Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8396a877-68c9-4999-bd6e-308bc381d314",
      "code": "class Solution:\n  def copyRandomList(self, head: 'Node') -> 'Node':\n    if not head:\n      return None\n    if head in self.map:\n      return self.map[head]\n\n    newNode = Node(head.val)\n    self.map[head] = newNode\n    newNode.next = self.copyRandomList(head.next)\n    newNode.random = self.copyRandomList(head.random)\n    return newNode\n\n  map = {}",
      "title": "138. Copy List with Random Pointer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c10fbfcb-4ab8-441e-b11d-ab4ec48f4b09",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe7ffdd0-d3c6-41c1-9904-25dceb44947f",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    n = len(s)\n    maxLength = len(max(wordDict, key=len))\n    wordSet = set(wordDict)\n    # dp[i] := True if s[0..i) can be segmented\n    dp = [True] + [False] * n\n\n    for i in range(1, n + 1):\n      for j in range(i - 1, -1, -1):\n        if i - j > maxLength:\n          break\n        # s[0..j) can be segmented and s[j..i) is in the wordSet, so s[0..i)\n        # can be segmented.\n        if dp[j] and s[j:i] in wordSet:\n          dp[i] = True\n          break\n\n    return dp[n]",
      "title": "139. Word Break_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "420168e0-5a96-4666-aa8e-800afbd06438",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> bool:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> bool:\n      \"\"\"Returns True if s can be segmented.\"\"\"\n      if s in wordSet:\n        return True\n      return any(s[:i] in wordSet and wordBreak(s[i:]) for i in range(len(s)))\n\n    return wordBreak(s)",
      "title": "139. Word Break_3",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb937c64-e5bc-4738-9f89-348e53edd27f",
      "code": "class Solution:\n  def wordBreak(self, s: str, wordDict: list[str]) -> list[str]:\n    wordSet = set(wordDict)\n\n    @functools.lru_cache(None)\n    def wordBreak(s: str) -> list[str]:\n      ans = []\n\n      # 1 <= len(prefix) < len(s)\n      for i in range(1, len(s)):\n        prefix = s[:i]\n        suffix = s[i:]\n        if prefix in wordSet:\n          for word in wordBreak(suffix):\n            ans.append(prefix + ' ' + word)\n\n      # `wordSet` contains the whole string s, so don't add any space.\n      if s in wordSet:\n        ans.append(s)\n\n      return ans\n\n    return wordBreak(s)",
      "title": "140. Word Break II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "594edc7a-22c1-4a8f-a98f-46f82dcc7f06",
      "code": "class Solution:\n  def hasCycle(self, head: ListNode) -> bool:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        return True\n\n    return False",
      "title": "141. Linked List Cycle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c34dfa84-2137-4a7c-916a-abe183d0b795",
      "code": "class Solution:\n  def detectCycle(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n      if slow == fast:\n        slow = head\n        while slow != fast:\n          slow = slow.next\n          fast = fast.next\n        return slow\n\n    return None",
      "title": "142. Linked List Cycle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79f74b12-d87b-4ce4-b469-bc60af619094",
      "code": "class Solution:\n  def reorderList(self, head: ListNode) -> None:\n    def findMid(head: ListNode):\n      prev = None\n      slow = head\n      fast = head\n\n      while fast and fast.next:\n        prev = slow\n        slow = slow.next\n        fast = fast.next.next\n      prev.next = None\n\n      return slow\n\n    def reverse(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n\n      return prev\n\n    def merge(l1: ListNode, l2: ListNode) -> None:\n      while l2:\n        next = l1.next\n        l1.next = l2\n        l1 = l2\n        l2 = next\n\n    if not head or not head.next:\n      return\n\n    mid = findMid(head)\n    reversed = reverse(mid)\n    merge(head, reversed)",
      "title": "143. Reorder List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1e8ad0d-2251-4f7f-adcf-9115251e0818",
      "code": "class Solution:\n  def preorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.right:\n        stack.append(node.right)\n      if node.left:\n        stack.append(node.left)\n\n    return ans",
      "title": "144. Binary Tree Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0857a5a7-0527-4303-ae9d-0e213575a1c0",
      "code": "class Solution:\n  def postorderTraversal(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    stack = [root]\n\n    while stack:\n      node = stack.pop()\n      ans.append(node.val)\n      if node.left:\n        stack.append(node.left)\n      if node.right:\n        stack.append(node.right)\n\n    return ans[::-1]",
      "title": "145. Binary Tree Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e3421fa-210e-4b83-84bb-4fb621920c40",
      "code": "class Solution:\n  def insertionSortList(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0)\n    prev = dummy  # the last and thus largest of the sorted list\n\n    while head:  # the current inserting node\n      next = head.next  # Cache the next inserting node.\n      if prev.val >= head.val:\n        prev = dummy  # Move `prev` to the front.\n      while prev.next and prev.next.val < head.val:\n        prev = prev.next\n      head.next = prev.next\n      prev.next = head\n      head = next  # Update the current inserting node.\n\n    return dummy.next",
      "title": "147. Insertion Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da99e6e0-8487-48c6-9c87-593240b338c3",
      "code": "class Solution:\n  def sortList(self, head: ListNode) -> ListNode:\n    def split(head: ListNode, k: int) -> ListNode:\n      while k > 1 and head:\n        head = head.next\n        k -= 1\n      rest = head.next if head else None\n      if head:\n        head.next = None\n      return rest\n\n    def merge(l1: ListNode, l2: ListNode) -> tuple:\n      dummy = ListNode(0)\n      tail = dummy\n\n      while l1 and l2:\n        if l1.val > l2.val:\n          l1, l2 = l2, l1\n        tail.next = l1\n        l1 = l1.next\n        tail = tail.next\n      tail.next = l1 if l1 else l2\n      while tail.next:\n        tail = tail.next\n\n      return dummy.next, tail\n\n    length = 0\n    curr = head\n    while curr:\n      length += 1\n      curr = curr.next\n\n    dummy = ListNode(0, head)\n\n    k = 1\n    while k < length:\n      curr = dummy.next\n      tail = dummy\n      while curr:\n        l = curr\n        r = split(l, k)\n        curr = split(r, k)\n        mergedHead, mergedTail = merge(l, r)\n        tail.next = mergedHead\n        tail = mergedTail\n      k *= 2\n\n    return dummy.next",
      "title": "148. Sort List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7cb556c-6f1b-4e58-ae83-d50e82030b74",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i, p in enumerate(points):\n      slopeCount = collections.defaultdict(int)\n      samePoints = 1\n      maxPoints = 0  # the maximum number of points with the same slope\n      for j in range(i + 1, len(points)):\n        q = points[j]\n        if p == q:\n          samePoints += 1\n        else:\n          slope = getSlope(p, q)\n          slopeCount[slope] += 1\n          maxPoints = max(maxPoints, slopeCount[slope])\n      ans = max(ans, samePoints + maxPoints)\n\n    return ans",
      "title": "149. Max Points on a Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9edd1b9-fbaf-449a-8046-4b6fa50d6928",
      "code": "class Solution:\n  def evalRPN(self, tokens: list[str]) -> int:\n    stack = []\n    op = {\n        '+': lambda a, b: a + b,\n        '-': lambda a, b: a - b,\n        '*': lambda a, b: a * b,\n        '/': lambda a, b: int(a / b),\n    }\n\n    for token in tokens:\n      if token in op:\n        b = stack.pop()\n        a = stack.pop()\n        stack.append(op[token](a, b))\n      else:\n        stack.append(int(token))\n\n    return stack.pop()",
      "title": "150. Evaluate Reverse Polish Notation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d7d2405-ddd2-470a-a6b5-09aa65715859",
      "code": "class Solution:\n  def reverseWords(self, s: str) -> str:\n    return ' '.join(reversed(s.split()))",
      "title": "151. Reverse Words in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a01cc00e-44d5-453d-babc-acff9cb1ad4c",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    ans = nums[0]\n    dpMin = nums[0]  # the minimum so far\n    dpMax = nums[0]  # the maximum so far\n\n    for i in range(1, len(nums)):\n      num = nums[i]\n      prevMin = dpMin  # dpMin[i - 1]\n      prevMax = dpMax  # dpMax[i - 1]\n      if num < 0:\n        dpMin = min(prevMax * num, num)\n        dpMax = max(prevMin * num, num)\n      else:\n        dpMin = min(prevMin * num, num)\n        dpMax = max(prevMax * num, num)\n\n      ans = max(ans, dpMax)\n\n    return ans",
      "title": "152. Maximum Product Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5db3274b-273b-4bde-b771-226e4c83e21a",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "153. Find Minimum in Rotated Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de9e33e6-2984-4621-9d3b-9e9ae2060cae",
      "code": "class Solution:\n  def findMin(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] == nums[r]:\n        r -= 1\n      elif nums[m] < nums[r]:\n        r = m\n      else:\n        l = m + 1\n\n    return nums[l]",
      "title": "154. Find Minimum in Rotated Sorted Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "243bf9a9-c0d6-49e7-953d-ebd5ef349d2a",
      "code": "class Solution:\n  def upsideDownBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    prevRoot = None\n    prevRightChild = None\n\n    while root:\n      nextRoot = root.left  # Cache the next root.\n      root.left = prevRightChild\n      prevRightChild = root.right\n      root.right = prevRoot\n      prevRoot = root  # Record the previous root.\n      root = nextRoot  # Update the root.\n\n    return prevRoot",
      "title": "156. Binary Tree Upside Down",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70aaf49e-0481-433c-bd4c-7a25cd942df3",
      "code": "\"\"\"\nThe read4 API is already defined for you.\n  def read4(buf4: list[str]) -> int:\n\n# Below is an example of how the read4 API can be called.\nfile = File(\"abcdefghijk\") # File is \"abcdefghijk\", initially file pointer (fp) points to 'a'\nbuf4 = [' '] * 4 # Create buffer with enough space to store characters\nread4(buf4) # Read4 returns 4. Now buf = ['a','b','c','d'], fp points to 'e'\nread4(buf4) # Read4 returns 4. Now buf = ['e','f','g','h'], fp points to 'i'\nread4(buf4) # Read4 returns 3. Now buf = ['i','j','k',...], fp points to end of file\n\"\"\"\n\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    buf4 = [' '] * 4\n    i4 = 0  # buf4's index\n    n4 = 0  # buf4's size\n    i = 0  # buf's index\n\n    while i < n:\n      if i4 == n4:  # All the characters in the buf4 are consumed.\n        i4 = 0  # Reset the buf4's index.\n        n4 = read4(buf4)  # Read <= 4 characters from the file to the buf4.\n        if n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = buf4[i4]\n      i += 1\n      i4 += 1\n\n    return i",
      "title": "157. Read N Characters Given Read4",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b353785-ad43-4fcd-bf95-646475d06f57",
      "code": "# The read4 API is already defined for you.\n# Def read4(buf4: list[str]) -> int:\n\nclass Solution:\n  def read(self, buf: list[str], n: int) -> int:\n    i = 0  # buf's index\n\n    while i < n:\n      if self.i4 == self.n4:  # All the characters in the buf4 are consumed.\n        self.i4 = 0  # Reset the buf4's index.\n        # Read <= 4 characters from the file to the buf4.\n        self.n4 = read4(self.buf4)\n        if self.n4 == 0:  # Reach the EOF.\n          return i\n      buf[i] = self.buf4[self.i4]\n      i += 1\n      self.i4 += 1\n\n    return i\n\n  buf4 = [' '] * 4\n  i4 = 0  # buf4's index\n  n4 = 0  # buf4's size",
      "title": "158. Read N Characters Given Read4 II - Call multiple times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a1f298a-b057-482a-b1ae-4c12d58f7864",
      "code": "class Solution:\n  def lengthOfLongestSubstringTwoDistinct(self, s: str) -> int:\n    ans = 0\n    distinct = 0\n    count = [0] * 128\n\n    l = 0\n    for r, c in enumerate(s):\n      count[ord(c)] += 1\n      if count[ord(c)] == 1:\n        distinct += 1\n      while distinct == 3:\n        count[ord(s[l])] -= 1\n        if count[ord(s[l])] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "159. Longest Substring with At Most Two Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69612f34-e2a1-4b4c-b45f-8e2ecfa6e6ca",
      "code": "class Solution:\n  def getIntersectionNode(\n      self,\n      headA: ListNode,\n      headB: ListNode,\n  ) -> ListNode | None:\n    a = headA\n    b = headB\n\n    while a != b:\n      a = a.next if a else headB\n      b = b.next if b else headA\n\n    return a",
      "title": "160. Intersection of Two Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8e79174-3f9a-4370-99f8-7686f8440332",
      "code": "class Solution:\n  def isOneEditDistance(self, s: str, t: str) -> bool:\n    m = len(s)\n    n = len(t)\n    if m > n:  # Make sure that |s| <= |t|.\n      return self.isOneEditDistance(t, s)\n\n    for i in range(m):\n      if s[i] != t[i]:\n        if m == n:\n          return s[i + 1:] == t[i + 1:]  # Replace s[i] with t[i].\n        return s[i:] == t[i + 1:]  # Delete t[i].\n\n    return m + 1 == n  # Delete t[-1].",
      "title": "161. One Edit Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de3917b5-642d-44b4-b0e3-e2644494b71b",
      "code": "class Solution:\n  def findPeakElement(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if nums[m] >= nums[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "162. Find Peak Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fe2f861-713a-4f8e-8a74-a31e2e6c7bee",
      "code": "class Solution:\n  def findMissingRanges(\n      self,\n      nums: list[int],\n      lower: int,\n      upper: int,\n  ) -> list[list[int]]:\n    def getRange(lo: int, hi: int) -> list[int]:\n      if lo == hi:\n        return [lo, lo]\n      return [lo, hi]\n\n    if not nums:\n      return [getRange(lower, upper)]\n\n    ans = []\n\n    if nums[0] > lower:\n      ans.append(getRange(lower, nums[0] - 1))\n\n    for prev, curr in zip(nums, nums[1:]):\n      if curr > prev + 1:\n        ans.append(getRange(prev + 1, curr - 1))\n\n    if nums[-1] < upper:\n      ans.append(getRange(nums[-1] + 1, upper))\n\n    return ans",
      "title": "163. Missing Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be282a34-a1c8-4d97-9d0f-6aa18977ec9c",
      "code": "class Bucket:\n  def __init__(self, mn: int, mx: int):\n    self.mn = mn\n    self.mx = mx\n\n\nclass Solution:\n  def maximumGap(self, nums: list[int]) -> int:\n    if len(nums) < 2:\n      return 0\n\n    mn = min(nums)\n    mx = max(nums)\n    if mn == mx:\n      return 0\n\n    gap = math.ceil((mx - mn) / (len(nums) - 1))\n    bucketSize = (mx - mn) // gap + 1\n    buckets = [Bucket(math.inf, -math.inf) for _ in range(bucketSize)]\n\n    for num in nums:\n      i = (num - mn) // gap\n      buckets[i].mn = min(buckets[i].mn, num)\n      buckets[i].mx = max(buckets[i].mx, num)\n\n    ans = 0\n    prevMax = mn\n\n    for bucket in buckets:\n      if bucket.mn == math.inf:\n        continue  # empty bucket\n      ans = max(ans, bucket.mn - prevMax)\n      prevMax = bucket.mx\n\n    return ans",
      "title": "164. Maximum Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db87633a-15be-4195-9a45-75a31ec26ee8",
      "code": "class Solution:\n  def compareVersion(self, version1: str, version2: str) -> int:\n    levels1 = version1.split('.')\n    levels2 = version2.split('.')\n    length = max(len(levels1), len(levels2))\n\n    for i in range(length):\n      v1 = int(levels1[i]) if i < len(levels1) else 0\n      v2 = int(levels2[i]) if i < len(levels2) else 0\n      if v1 < v2:\n        return -1\n      if v1 > v2:\n        return 1\n\n    return 0",
      "title": "165. Compare Version Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4032389-9713-4ce4-909a-c53c201a4b1f",
      "code": "class Solution:\n  def fractionToDecimal(self, numerator: int, denominator: int) -> str:\n    if numerator == 0:\n      return '0'\n\n    ans = ''\n\n    if (numerator < 0) ^ (denominator < 0):\n      ans += '-'\n\n    numerator = abs(numerator)\n    denominator = abs(denominator)\n    ans += str(numerator // denominator)\n\n    if numerator % denominator == 0:\n      return ans\n\n    ans += '.'\n    dict = {}\n\n    remainder = numerator % denominator\n    while remainder:\n      if remainder in dict:\n        ans = ans[:dict[remainder]] + '(' + ans[dict[remainder]:] + ')'\n        break\n      dict[remainder] = len(ans)\n      remainder *= 10\n      ans += str(remainder // denominator)\n      remainder %= denominator\n\n    return ans",
      "title": "166. Fraction to Recurring Decimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e6de1ae-6a05-480a-8a5f-922810ef9534",
      "code": "class Solution:\n  def twoSum(self, numbers: list[int], target: int) -> list[int]:\n    l = 0\n    r = len(numbers) - 1\n\n    while l < r:\n      summ = numbers[l] + numbers[r]\n      if summ == target:\n        return [l + 1, r + 1]\n      if summ < target:\n        l += 1\n      else:\n        r -= 1",
      "title": "167. Two Sum II - Input array is sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3867d4d5-0a72-41b9-8121-e96d6bb27f32",
      "code": "class Solution:\n  def convertToTitle(self, n: int) -> str:\n    return (self.convertToTitle((n - 1) // 26) + chr(ord('A') + (n - 1) % 26)\n            if n\n            else '')",
      "title": "168. Excel Sheet Column Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78ec6ce7-1980-428c-9062-f5718485df02",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> int:\n    ans = None\n    count = 0\n\n    for num in nums:\n      if count == 0:\n        ans = num\n      count += (1 if num == ans else -1)\n\n    return ans",
      "title": "169. Majority Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d87f7186-e59b-4156-a3df-c97913d75197",
      "code": "class Solution:\n  def titleToNumber(self, columnTitle: str) -> int:\n    return functools.reduce(lambda subtotal, c:\n                            subtotal * 26 + ord(c) - ord('@'), columnTitle, 0)",
      "title": "171. Excel Sheet Column Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05b503f5-ee44-4a48-8ef1-c0ca4591ebf6",
      "code": "class Solution:\n  def trailingZeroes(self, n: int) -> int:\n    return 0 if n == 0 else n // 5 + self.trailingZeroes(n // 5)",
      "title": "172. Factorial Trailing Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "420ee47b-f3c2-4612-9bdd-549503493bcc",
      "code": "class Solution:\n  def calculateMinimumHP(self, dungeon: list[list[int]]) -> int:\n    m = len(dungeon)\n    n = len(dungeon[0])\n    dp = [math.inf] * (n + 1)\n    dp[n - 1] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        dp[j] = min(dp[j], dp[j + 1]) - dungeon[i][j]\n        dp[j] = max(dp[j], 1)\n\n    return dp[0]",
      "title": "174. Dungeon Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35163373-2021-425f-a3a6-fda039af9d42",
      "code": "class LargerStrKey(str):\n  def __lt__(x: str, y: str) -> bool:\n    return x + y > y + x\n\n\nclass Solution:\n  def largestNumber(self, nums: list[int]) -> str:\n    return ''.join(sorted(map(str, nums), key=LargerStrKey)).lstrip('0') or '0'",
      "title": "179. Largest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0c26755-d564-4eb3-9469-3c2a5b51d818",
      "code": "class Solution:\n  def reverseWords(self, s: list[str]) -> None:\n    def reverse(l: int, r: int) -> None:\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    def reverseWords(n: int) -> None:\n      i = 0\n      j = 0\n\n      while i < n:\n        while i < j or (i < n and s[i] == ' '):  # Skip the spaces.\n          i += 1\n        while j < i or (j < n and s[j] != ' '):  # Skip the spaces.\n          j += 1\n        reverse(i, j - 1)  # Reverse the word.\n\n    reverse(0, len(s) - 1)  # Reverse the whole string.\n    reverseWords(len(s))  # Reverse each word.",
      "title": "186. Reverse Words in a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bccc005d-d261-40cc-9f43-8c43ff9de4c3",
      "code": "class Solution:\n  def findRepeatedDnaSequences(self, s: str) -> list[str]:\n    ans = set()\n    seen = set()\n\n    for i in range(len(s) - 9):\n      seq = s[i:i + 10]\n      if seq in seen:\n        ans.add(seq)\n      seen.add(seq)\n\n    return list(ans)",
      "title": "187. Repeated DNA Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5ab0cf6-a2da-4694-84b9-93c630a6dfea",
      "code": "class Solution:\n  def maxProfit(self, k: int, prices: list[int]) -> int:\n    if k >= len(prices) // 2:\n      sell = 0\n      hold = -math.inf\n\n      for price in prices:\n        sell = max(sell, hold + price)\n        hold = max(hold, sell - price)\n\n      return sell\n\n    sell = [0] * (k + 1)\n    hold = [-math.inf] * (k + 1)\n\n    for price in prices:\n      for i in range(k, 0, -1):\n        sell[i] = max(sell[i], hold[i] + price)\n        hold[i] = max(hold[i], sell[i - 1] - price)\n\n    return sell[k]",
      "title": "188. Best Time to Buy and Sell Stock IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00fa7729-6ae6-48c6-a0a2-7682648e3255",
      "code": "class Solution:\n  def rotate(self, nums: list[int], k: int) -> None:\n    k %= len(nums)\n    self.reverse(nums, 0, len(nums) - 1)\n    self.reverse(nums, 0, k - 1)\n    self.reverse(nums, k, len(nums) - 1)\n\n  def reverse(self, nums: list[int], l: int, r: int) -> None:\n    while l < r:\n      nums[l], nums[r] = nums[r], nums[l]\n      l += 1\n      r -= 1",
      "title": "189. Rotate Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb5e9e10-0b23-4283-8aea-f055be75ff02",
      "code": "class Solution:\n  def reverseBits(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if n >> i & 1:\n        ans |= 1 << 31 - i\n\n    return ans",
      "title": "190. Reverse Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76a816b5-117d-4639-b414-24ad24cc58bd",
      "code": "class Solution:\n  def hammingWeight(self, n: int) -> int:\n    ans = 0\n\n    for i in range(32):\n      if (n >> i) & 1:\n        ans += 1\n\n    return ans",
      "title": "191. Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4ef407b-ade7-4cdd-8265-babb527a1a26",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) == 1:\n      return nums[0]\n\n    # dp[i]:= max money of robbing nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n    dp[1] = max(nums[0], nums[1])\n\n    for i in range(2, len(nums)):\n      dp[i] = max(dp[i - 1], dp[i - 2] + nums[i])\n\n    return dp[-1]",
      "title": "198. House Robber",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "224dad1b-bbb0-459b-94b6-5ec37a76ef10",
      "code": "class Solution:\n  def rightSideView(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      size = len(q)\n      for i in range(size):\n        root = q.popleft()\n        if i == size - 1:\n          ans.append(root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n\n    return ans",
      "title": "199. Binary Tree Right Side View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29b7a11d-8db3-4a64-b1e1-bbcd1fdf53a4",
      "code": "class Solution:\n  def numIslands(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def bfs(r, c):\n      q = collections.deque([(r, c)])\n      grid[r][c] = '2'  # Mark '2' as visited.\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] != '1':\n            continue\n          q.append((x, y))\n          grid[x][y] = '2'  # Mark '2' as visited.\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == '1':\n          bfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "200. Number of Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8b8155f-193b-4039-a477-1466b6cac88a",
      "code": "class Solution:\n  def rangeBitwiseAnd(self, m: int, n: int) -> int:\n    return self.rangeBitwiseAnd(m >> 1, n >> 1) << 1 if m < n else m",
      "title": "201. Bitwise AND of Numbers Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "356e7caf-eb75-4ff8-8014-7331b4b55d19",
      "code": "class Solution:\n  def isHappy(self, n: int) -> bool:\n    def squaredSum(n: int) -> bool:\n      summ = 0\n      while n > 0:\n        summ += pow(n % 10, 2)\n        n //= 10\n      return summ\n\n    slow = squaredSum(n)\n    fast = squaredSum(squaredSum(n))\n\n    while slow != fast:\n      slow = squaredSum(slow)\n      fast = squaredSum(squaredSum(fast))\n\n    return slow == 1",
      "title": "202. Happy Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "594d3c80-1841-4e20-9698-feaae9600dfb",
      "code": "class Solution:\n  def removeElements(self, head: ListNode, val: int) -> ListNode:\n    dummy = ListNode(0, head)\n    prev = dummy\n\n    while head:\n      if head.val != val:\n        prev.next = head\n        prev = prev.next\n      head = head.next\n    prev.next = None\n\n    return dummy.next",
      "title": "203. Remove Linked List Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18fc8f61-c8f5-440f-b9ec-d08aa6bf40ce",
      "code": "class Solution:\n  def countPrimes(self, n: int) -> int:\n    if n <= 2:\n      return 0\n    return sum(self._sieveEratosthenes(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "204. Count Primes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6378471-c480-4bed-9284-e9fa0a17fbe7",
      "code": "class Solution:\n  def isIsomorphic(self, s: str, t: str) -> bool:\n    return [*map(s.index, s)] == [*map(t.index, t)]",
      "title": "205. Isomorphic Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88f7498d-73c5-4060-a0b1-11a47953455d",
      "code": "class Solution:\n  def reverseList(self, head: ListNode | None) -> ListNode | None:\n    if not head or not head.next:\n      return head\n\n    newHead = self.reverseList(head.next)\n    head.next.next = head\n    head.next = None\n    return newHead",
      "title": "206. Reverse Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8688f7a-4777-4861-8ade-393af8e094bc",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def canFinish(self, numCourses: int, prerequisites: list[list[int]]) -> bool:\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not any(hasCycle(i) for i in range(numCourses))",
      "title": "207. Course Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1c3d7fb-0d32-4e8f-8d47-77465ed6b7eb",
      "code": "class Solution:\n  def minSubArrayLen(self, target: int, nums: list[int]) -> int:\n    ans = math.inf\n    summ = 0\n    j = 0\n\n    for i, num in enumerate(nums):\n      summ += num\n      while summ >= target:\n        ans = min(ans, i - j + 1)\n        summ -= nums[j]\n        j += 1\n\n    return 0 if ans == math.inf else ans",
      "title": "209. Minimum Size Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "916a5798-ffc1-4543-b43b-b09215b71baa",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def findOrder(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(numCourses)]\n    states = [State.INIT] * numCourses\n\n    for v, u in prerequisites:\n      graph[u].append(v)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      ans.append(u)\n      return False\n\n    if any(hasCycle(i) for i in range(numCourses)):\n      return []\n\n    return ans[::-1]",
      "title": "210. Course Schedule II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9d7c1d1-1b4f-4194-b53c-fe615a98590a",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def findWords(self, board: list[list[str]], words: list[str]) -> list[str]:\n    m = len(board)\n    n = len(board[0])\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    for word in words:\n      insert(word)\n\n    def dfs(i: int, j: int, node: TrieNode) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if board[i][j] == '*':\n        return\n\n      c = board[i][j]\n      if c not in node.children:\n        return\n\n      child = node.children[c]\n      if child.word:\n        ans.append(child.word)\n        child.word = None\n\n      board[i][j] = '*'\n      dfs(i + 1, j, child)\n      dfs(i - 1, j, child)\n      dfs(i, j + 1, child)\n      dfs(i, j - 1, child)\n      board[i][j] = c\n\n    for i in range(m):\n      for j in range(n):\n        dfs(i, j, root)\n\n    return ans",
      "title": "212. Word Search II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "542bb454-0b80-40ce-aecb-7a6772df7229",
      "code": "class Solution:\n  def rob(self, nums: list[int]) -> int:\n    if not nums:\n      return 0\n    if len(nums) < 2:\n      return nums[0]\n\n    def rob(l: int, r: int) -> int:\n      dp1 = 0\n      dp2 = 0\n\n      for i in range(l, r + 1):\n        temp = dp1\n        dp1 = max(dp1, dp2 + nums[i])\n        dp2 = temp\n\n      return dp1\n\n    return max(rob(0, len(nums) - 2),\n               rob(1, len(nums) - 1))",
      "title": "213. House Robber II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d80a669-5bec-48bb-952a-1e75e98408b8",
      "code": "class Solution:\n  def shortestPalindrome(self, s: str) -> str:\n    t = s[::-1]\n\n    for i in range(len(t)):\n      if s.startswith(t[i:]):\n        return t[:i] + s\n\n    return t + s",
      "title": "214. Shortest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0a6e969-81f5-46c5-a74f-6f7983dc4dcb",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "215. Kth Largest Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4b04a0c-8ca8-4fee-89e7-838fe9df1696",
      "code": "class Solution:\n  def findKthLargest(self, nums: list[int], k: int) -> int:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, num)\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return minHeap[0]",
      "title": "215. Kth Largest Element in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2413ed4d-e664-42ba-956e-a5c565d37111",
      "code": "class Solution:\n  def combinationSum3(self, k: int, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(k: int, n: int, s: int, path: list[int]) -> None:\n      if k == 0 and n == 0:\n        ans.append(path)\n        return\n      if k == 0 or n < 0:\n        return\n\n      for i in range(s, 10):\n        dfs(k - 1, n - i, i + 1, path + [i])\n\n    dfs(k, n, 1, [])\n    return ans",
      "title": "216. Combination Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48e210fc-91a5-4d20-92c8-543a068cf4d4",
      "code": "class Solution:\n  def containsDuplicate(self, nums: list[int]) -> bool:\n    return len(nums) != len(set(nums))",
      "title": "217. Contains Duplicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e307552b-80de-4c89-816c-d6ffa02ed5e2",
      "code": "class Solution:\n  def getSkyline(self, buildings: list[list[int]]) -> list[list[int]]:\n    n = len(buildings)\n    if n == 0:\n      return []\n    if n == 1:\n      left, right, height = buildings[0]\n      return [[left, height], [right, 0]]\n\n    left = self.getSkyline(buildings[:n // 2])\n    right = self.getSkyline(buildings[n // 2:])\n    return self._merge(left, right)\n\n  def _merge(self, left: list[list[int]],\n             right: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # left's index\n    j = 0  # right's index\n    leftY = 0\n    rightY = 0\n\n    while i < len(left) and j < len(right):\n      # Choose the powith smaller x\n      if left[i][0] < right[j][0]:\n        leftY = left[i][1]  # Update the ongoing `leftY`.\n        self._addPoint(ans, left[i][0], max(left[i][1], rightY))\n        i += 1\n      else:\n        rightY = right[j][1]  # Update the ongoing `rightY`.\n        self._addPoint(ans, right[j][0], max(right[j][1], leftY))\n        j += 1\n\n    while i < len(left):\n      self._addPoint(ans, left[i][0], left[i][1])\n      i += 1\n\n    while j < len(right):\n      self._addPoint(ans, right[j][0], right[j][1])\n      j += 1\n\n    return ans\n\n  def _addPoint(self, ans: list[list[int]], x: int, y: int) -> None:\n    if ans and ans[-1][0] == x:\n      ans[-1][1] = y\n      return\n    if ans and ans[-1][1] == y:\n      return\n    ans.append([x, y])",
      "title": "218. The Skyline Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e647e236-adae-4402-a3cb-84596fcd839d",
      "code": "class Solution:\n  def containsNearbyDuplicate(self, nums: list[int], k: int) -> bool:\n    seen = set()\n\n    for i, num in enumerate(nums):\n      if i > k:\n        seen.remove(nums[i - k - 1])\n      if num in seen:\n        return True\n      seen.add(num)\n\n    return False",
      "title": "219. Contains Duplicate II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86c35719-abc3-4ac6-98c4-95351da9897e",
      "code": "class Solution:\n  def containsNearbyAlmostDuplicate(\n      self,\n      nums: list[int],\n      indexDiff: int,\n      valueDiff: int,\n  ) -> bool:\n    if not nums or indexDiff <= 0 or valueDiff < 0:\n      return False\n\n    mn = min(nums)\n    diff = valueDiff + 1  # In case that `valueDiff` equals 0.\n    bucket = {}\n\n    def getKey(num: int) -> int:\n      return (num - mn) // diff\n\n    for i, num in enumerate(nums):\n      key = getKey(num)\n      if key in bucket:  # the current bucket\n        return True\n      # the left adjacent bucket\n      if key - 1 in bucket and num - bucket[key - 1] < diff:\n        return True\n      # the right adjacent bucket\n      if key + 1 in bucket and bucket[key + 1] - num < diff:\n        return True\n      bucket[key] = num\n      if i >= indexDiff:\n        del bucket[getKey(nums[i - indexDiff])]\n\n    return False",
      "title": "220. Contains Duplicate III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "013e42a6-c738-4dc0-8d63-12dff5f7ace4",
      "code": "class Solution:\n  def maximalSquare(self, matrix: list[list[str]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    dp = [0] * n\n    maxLength = 0\n    prev = 0  # dp[i - 1][j - 1]\n\n    for i in range(m):\n      for j in range(n):\n        cache = dp[j]\n        if i == 0 or j == 0 or matrix[i][j] == '0':\n          dp[j] = 1 if matrix[i][j] == '1' else 0\n        else:\n          dp[j] = min([prev, dp[j], dp[j - 1]]) + 1\n        maxLength = max(maxLength, dp[j])\n        prev = cache\n\n    return maxLength * maxLength",
      "title": "221. Maximal Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f90a516d-78d8-42f5-a1b6-e97adc367933",
      "code": "class Solution:\n  def countNodes(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    left = root\n    right = root\n    heightL = 0\n    heightR = 0\n\n    while left:\n      heightL += 1\n      left = left.left\n\n    while right:\n      heightR += 1\n      right = right.right\n\n    if heightL == heightR:  # `root` is a complete tree.\n      return pow(2, heightL) - 1\n    return 1 + self.countNodes(root.left) + self.countNodes(root.right)",
      "title": "222. Count Complete Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "603cc23c-c2f3-4431-aa7d-76d27f60d82f",
      "code": "class Solution:\n  def computeArea(self,\n                  A: int, B: int, C: int, D: int,\n                  E: int, F: int, G: int, H: int) -> int:\n    x = min(C, G) - max(A, E) if max(A, E) < min(C, G) else 0\n    y = min(D, H) - max(B, F) if max(B, F) < min(D, H) else 0\n    return (C - A) * (D - B) + (G - E) * (H - F) - x * y",
      "title": "223. Rectangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "446d2613-5733-41a3-983a-59596922f28d",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    num = 0\n    sign = 1\n    stack = [sign]  # stack[-1]: the current environment's sign\n\n    for c in s:\n      if c.isdigit():\n        num = num * 10 + int(c)\n      elif c == '(':\n        stack.append(sign)\n      elif c == ')':\n        stack.pop()\n      elif c == '+' or c == '-':\n        ans += sign * num\n        sign = (1 if c == '+' else -1) * stack[-1]\n        num = 0\n\n    return ans + sign * num",
      "title": "224. Basic Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b42438df-6a08-4434-bbfb-b3c343bb2791",
      "code": "class Solution:\n  def invertTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n\n    left = root.left\n    right = root.right\n    root.left = self.invertTree(right)\n    root.right = self.invertTree(left)\n    return root",
      "title": "226. Invert Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb2b0f5f-fe37-4685-961d-d813bb2fdf26",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    ans = 0\n    prevNum = 0\n    currNum = 0\n    op = '+'\n\n    for i, c in enumerate(s):\n      if c.isdigit():\n        currNum = currNum * 10 + int(c)\n      if not c.isdigit() and c != ' ' or i == len(s) - 1:\n        if op == '+' or op == '-':\n          ans += prevNum\n          prevNum = currNum if op == '+' else -currNum\n        elif op == '*':\n          prevNum = prevNum * currNum\n        elif op == '/':\n          if prevNum < 0:\n            prevNum = math.ceil(prevNum / currNum)\n          else:\n            prevNum = prevNum // currNum\n        op = c\n        currNum = 0\n\n    return ans + prevNum",
      "title": "227. Basic Calculator II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc79ef87-3b46-42aa-b33b-0a406225e7fb",
      "code": "class Solution:\n  def summaryRanges(self, nums: list[int]) -> list[str]:\n    ans = []\n\n    i = 0\n    while i < len(nums):\n      begin = nums[i]\n      while i < len(nums) - 1 and nums[i] == nums[i + 1] - 1:\n        i += 1\n      end = nums[i]\n      if begin == end:\n        ans.append(str(begin))\n      else:\n        ans.append(str(begin) + \"->\" + str(end))\n      i += 1\n\n    return ans",
      "title": "228. Summary Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c5271d3-813d-481e-850b-b0f1dcec0c6c",
      "code": "class Solution:\n  def majorityElement(self, nums: list[int]) -> list[int]:\n    ans1 = 0\n    ans2 = 1\n    count1 = 0\n    count2 = 0\n\n    for num in nums:\n      if num == ans1:\n        count1 += 1\n      elif num == ans2:\n        count2 += 1\n      elif count1 == 0:\n        ans1 = num\n        count1 = 1\n      elif count2 == 0:\n        ans2 = num\n        count2 = 1\n      else:\n        count1 -= 1\n        count2 -= 1\n\n    return [ans for ans in (ans1, ans2) if nums.count(ans) > len(nums) // 3]",
      "title": "229. Majority Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd1663a4-803b-43d3-9d19-3d3e7012a734",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45acc43e-7169-4aa4-804f-ee0f9a55a5ac",
      "code": "class Solution:\n  def kthSmallest(self, root: TreeNode | None, k: int) -> int:\n    def countNodes(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + countNodes(root.left) + countNodes(root.right)\n\n    leftCount = countNodes(root.left)\n\n    if leftCount == k - 1:\n      return root.val\n    if leftCount >= k:\n      return self.kthSmallest(root.left, k)\n    return self.kthSmallest(root.right, k - 1 - leftCount)  # leftCount < k",
      "title": "230. Kth Smallest Element in a BST_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "920587c2-b42f-4e53-a726-fdb06c884d15",
      "code": "class Solution:\n  def isPowerOfTwo(self, n: int) -> bool:\n    return n >= 0 and n.bit_count() == 1",
      "title": "231. Power of Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "787fe686-4af2-4d2f-bf9c-8525d6cfd4e5",
      "code": "class Solution:\n  def countDigitOne(self, n: int) -> int:\n    ans = 0\n\n    pow10 = 1\n    while pow10 <= n:\n      divisor = pow10 * 10\n      quotient = n // divisor\n      remainder = n % divisor\n      if quotient > 0:\n        ans += quotient * pow10\n      if remainder >= pow10:\n        ans += min(remainder - pow10 + 1, pow10)\n      pow10 *= 10\n\n    return ans",
      "title": "233. Number of Digit One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cba93d9-d830-4c06-8cff-d06e7dc791d1",
      "code": "class Solution:\n  def isPalindrome(self, head: ListNode) -> bool:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      curr = head\n      while curr:\n        next = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next\n      return prev\n\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    if fast:\n      slow = slow.next\n    slow = reverseList(slow)\n\n    while slow:\n      if slow.val != head.val:\n        return False\n      slow = slow.next\n      head = head.next\n\n    return True",
      "title": "234. Palindrome Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2410826f-c86f-4116-846b-d859fa531981",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    if root.val > max(p.val, q.val):\n      return self.lowestCommonAncestor(root.left, p, q)\n    if root.val < min(p.val, q.val):\n      return self.lowestCommonAncestor(root.right, p, q)\n    return root",
      "title": "235. Lowest Common Ancestor of a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82184daf-3d84-4b38-a406-a4e675c4a984",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n      q: TreeNode | None,\n  ) -> TreeNode | None:\n    q_ = collections.deque([root])\n    parent = {root: None}\n    ancestors = set()  # p's ancestors\n\n    # Iterate until we find both p and q.\n    while p not in parent or q not in parent:\n      root = q_.popleft()\n      if root.left:\n        parent[root.left] = root\n        q_.append(root.left)\n      if root.right:\n        parent[root.right] = root\n        q_.append(root.right)\n\n    # Insert all the p's ancestors.\n    while p:\n      ancestors.add(p)\n      p = parent[p]  # `p` becomes None in the end.\n\n    # Go up from q until we meet any of p's ancestors.\n    while q not in ancestors:\n      q = parent[q]\n\n    return q",
      "title": "236. Lowest Common Ancestor of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf4626a5-6841-419c-a795-474f4a974278",
      "code": "class Solution:\n  def deleteNode(self, node):\n    node.val = node.next.val\n    node.next = node.next.next",
      "title": "237. Delete Node in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ea1cc1e-8410-42a1-80d1-453b21eeff75",
      "code": "class Solution:\n  def productExceptSelf(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    prefix = [1] * n  # prefix product\n    suffix = [1] * n  # suffix product\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] * nums[i - 1]\n\n    for i in reversed(range(n - 1)):\n      suffix[i] = suffix[i + 1] * nums[i + 1]\n\n    return [prefix[i] * suffix[i] for i in range(n)]",
      "title": "238. Product of Array Except Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2feee75c-f23e-4d58-8f7c-c0825cb2f2c2",
      "code": "class Solution:\n  def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    maxQ = collections.deque()\n\n    for i, num in enumerate(nums):\n      while maxQ and maxQ[-1] < num:\n        maxQ.pop()\n      maxQ.append(num)\n      if i >= k and nums[i - k] == maxQ[0]:  # out-of-bounds\n        maxQ.popleft()\n      if i >= k - 1:\n        ans.append(maxQ[0])\n\n    return ans",
      "title": "239. Sliding Window Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae0311b3-0491-449f-916c-08dbc11068ca",
      "code": "class Solution:\n  def searchMatrix(self, matrix: list[list[int]], target: int) -> bool:\n    r = 0\n    c = len(matrix[0]) - 1\n\n    while r < len(matrix) and c >= 0:\n      if matrix[r][c] == target:\n        return True\n      if target < matrix[r][c]:\n        c -= 1\n      else:\n        r += 1\n\n    return False",
      "title": "240. Search a 2D Matrix II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c14828a3-1ff7-44d0-afce-597178ecba3d",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def diffWaysToCompute(self, expression: str) -> list[int]:\n    ans = []\n\n    for i, c in enumerate(expression):\n      if c in '+-*':\n        for a in self.diffWaysToCompute(expression[:i]):\n          for b in self.diffWaysToCompute(expression[i + 1:]):\n            ans.append(eval(str(a) + c + str(b)))\n\n    return ans or [int(expression)]",
      "title": "241. Different Ways to Add Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbaac166-2809-4555-b7de-924d4e0d02ac",
      "code": "class Solution:\n  def isAnagram(self, s: str, t: str) -> bool:\n    if len(s) != len(t):\n      return False\n\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return all(freq == 0 for freq in count.values())",
      "title": "242. Valid Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2a29563-3212-4d65-b061-8958811e6acd",
      "code": "class Solution:\n  def shortestDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    ans = len(wordsDict)\n    index1 = -1  # wordsdict[index1] == word1\n    index2 = -1  # wordsdict[index2] == word2\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        index1 = i\n        if index2 != -1:\n          ans = min(ans, index1 - index2)\n      if word == word2:\n        index2 = i\n        if index1 != -1:\n          ans = min(ans, index2 - index1)\n\n    return ans",
      "title": "243. Shortest Word Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67d84bbf-3b68-4405-84d0-2a6e347eeb3e",
      "code": "class Solution:\n  def shortestWordDistance(\n      self,\n      wordsDict: list[str],\n      word1: str,\n      word2: str,\n  ) -> int:\n    isSame = word1 == word2\n    ans = math.inf\n    # If word1 == word2, index1 is the newest index.\n    index1 = len(wordsDict)\n    # If word1 == word2, index2 is the previous index.\n    index2 = -len(wordsDict)\n\n    for i, word in enumerate(wordsDict):\n      if word == word1:\n        if isSame:\n          index2 = index1\n        index1 = i\n      elif word == word2:\n        index2 = i\n      ans = min(ans, abs(index1 - index2))\n\n    return ans",
      "title": "245. Shortest Word Distance III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8727581-ea82-4803-a137-a25527971035",
      "code": "class Solution:\n  def isStrobogrammatic(self, num: str) -> bool:\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    l = 0\n    r = len(num) - 1\n\n    while l <= r:\n      if num[r] not in rotated:\n        return False\n      if num[l] != rotated[num[r]]:\n        return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "246. Strobogrammatic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "becd3d37-a02e-468a-9cef-14a2c9d8b090",
      "code": "class Solution:\n  def findStrobogrammatic(self, n: int) -> list[str]:\n    def helper(n: int, k: int) -> list[str]:\n      if n == 0:\n        return ['']\n      if n == 1:\n        return ['0', '1', '8']\n\n      ans = []\n\n      for inner in helper(n - 2, k):\n        if n < k:\n          ans.append('0' + inner + '0')\n        ans.append('1' + inner + '1')\n        ans.append('6' + inner + '9')\n        ans.append('8' + inner + '8')\n        ans.append('9' + inner + '6')\n\n      return ans\n\n    return helper(n, n)",
      "title": "247. Strobogrammatic Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae7828a4-0499-47ad-b216-610c38c54349",
      "code": "class Solution:\n  def strobogrammaticInRange(self, low: str, high: str) -> int:\n    pairs = [['0', '0'], ['1', '1'], ['6', '9'], ['8', '8'], ['9', '6']]\n    ans = 0\n\n    def dfs(s: list[str], l: int, r: int) -> None:\n      nonlocal ans\n      if l > r:\n        if len(s) == len(low) and ''.join(s) < low:\n          return\n        if len(s) == len(high) and ''.join(s) > high:\n          return\n        ans += 1\n        return\n\n      for leftDigit, rightDigit in pairs:\n        if l == r and leftDigit != rightDigit:\n          continue\n        s[l] = leftDigit\n        s[r] = rightDigit\n        if len(s) > 1 and s[0] == '0':\n          continue\n        dfs(s, l + 1, r - 1)\n\n    for n in range(len(low), len(high) + 1):\n      dfs([' '] * n, 0, n - 1)\n\n    return ans",
      "title": "248. Strobogrammatic Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1be8fa4d-7fc6-4225-b83e-324f736a5628",
      "code": "class Solution:\n  def groupStrings(self, strings: list[str]) -> list[list[str]]:\n    keyToStrings = collections.defaultdict(list)\n\n    def getKey(s: str) -> str:\n      \"\"\"\n      Returns the key of 's' by pairwise calculation of differences.\n      e.g. getKey(\"abc\") -> \"1,1\" because diff(a, b) = 1 and diff(b, c) = 1.\n      \"\"\"\n      diffs = []\n\n      for i in range(1, len(s)):\n        diff = (ord(s[i]) - ord(s[i - 1]) + 26) % 26\n        diffs.append(str(diff))\n\n      return ','.join(diffs)\n\n    for s in strings:\n      keyToStrings[getKey(s)].append(s)\n\n    return keyToStrings.values()",
      "title": "249. Group Shifted Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45fa4110-cefd-479b-b065-4319c00a8c8b",
      "code": "class Solution:\n  def countUnivalSubtrees(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def isUnival(root: TreeNode | None, val: int) -> bool:\n      nonlocal ans\n      if not root:\n        return True\n\n      if isUnival(root.left, root.val) & isUnival(root.right, root.val):\n        ans += 1\n        return root.val == val\n\n      return False\n\n    isUnival(root, math.inf)\n    return ans",
      "title": "250. Count Univalue Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb05050b-5fd2-411c-8829-f64aa40f8595",
      "code": "class Solution:\n  def canAttendMeetings(self, intervals: list[list[int]]) -> bool:\n    intervals.sort()\n\n    for i in range(1, len(intervals)):\n      if intervals[i - 1][1] > intervals[i][0]:\n        return False\n\n    return True",
      "title": "252. Meeting Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fba86ed-2804-43d8-84a5-8c96627d17ed",
      "code": "class Solution:\n  def minMeetingRooms(self, intervals: list[list[int]]) -> int:\n    n = len(intervals)\n    ans = 0\n    starts = []\n    ends = []\n\n    for start, end in intervals:\n      starts.append(start)\n      ends.append(end)\n\n    starts.sort()\n    ends.sort()\n\n    j = 0\n    for i in range(n):\n      if starts[i] < ends[j]:\n        ans += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "253. Meeting Rooms II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bbb8dfd-0744-4d35-8542-4c638993b477",
      "code": "class Solution:\n  def getFactors(self, n: int) -> list[list[int]]:\n    ans = []\n\n    def dfs(n: int, s: int, path: list[int]) -> None:\n      if n <= 1:\n        if len(path) > 1:\n          ans.append(path.copy())\n        return\n\n      for i in range(s, n + 1):\n        if n % i == 0:\n          path.append(i)\n          dfs(n // i, i, path)\n          path.pop()\n\n    dfs(n, 2, [])  # The minimum factor is 2.\n    return ans",
      "title": "254. Factor Combinations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2981f8a-5581-46cc-b9f2-fdfaf4d5c4ab",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "747afe44-6cb5-49cd-a681-3b04e03b2acb",
      "code": "class Solution:\n  def verifyPreorder(self, preorder: list[int]) -> bool:\n    i = 0\n\n    def dfs(min: int, max: int) -> None:\n      nonlocal i\n      if i == len(preorder):\n        return\n      if preorder[i] < min or preorder[i] > max:\n        return\n\n      val = preorder[i]\n      i += 1\n      dfs(min, val)\n      dfs(val, max)\n\n    dfs(-math.inf, math.inf)\n    return i == len(preorder)",
      "title": "255. Verify Preorder Sequence in Binary Search Tree_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c532931-fe80-491b-a396-c514e39ebe82",
      "code": "class Solution:\n  def minCost(self, costs: list[list[int]]) -> list[list[int]]:\n    for i in range(1, len(costs)):\n      costs[i][0] += min(costs[i - 1][1], costs[i - 1][2])\n      costs[i][1] += min(costs[i - 1][0], costs[i - 1][2])\n      costs[i][2] += min(costs[i - 1][0], costs[i - 1][1])\n\n    return min(costs[-1])",
      "title": "256. Paint House",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa148d3c-a5f1-40ec-af6c-d34714583ce0",
      "code": "class Solution:\n  def binaryTreePaths(self, root: TreeNode | None) -> list[str]:\n    ans = []\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        ans.append(''.join(path) + str(root.val))\n        return\n\n      path.append(str(root.val) + '->')\n      dfs(root.left, path)\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(root, [])\n    return ans",
      "title": "257. Binary Tree Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7757599-c43c-441c-ab7d-5be1dcccc46d",
      "code": "class Solution:\n  def addDigits(self, num: int) -> int:\n    return 0 if num == 0 else 1 + (num - 1) % 9",
      "title": "258. Add Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8700f85e-1f6b-48a9-86ee-3436cd0293a7",
      "code": "class Solution:\n  def threeSumSmaller(self, nums: list[int], target: int) -> int:\n    if len(nums) < 3:\n      return 0\n\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 2):\n      l = i + 1\n      r = len(nums) - 1\n      while l < r:\n        if nums[i] + nums[l] + nums[r] < target:\n          # (nums[i], nums[l], nums[r])\n          # (nums[i], nums[l], nums[r - 1])\n          # ...,\n          # (nums[i], nums[l], nums[l + 1])\n          ans += r - l\n          l += 1\n        else:\n          r -= 1\n\n    return ans",
      "title": "259. 3Sum Smaller",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afa959d3-0c40-4716-a98f-69f54ec45b61",
      "code": "class Solution:\n  def singleNumber(self, nums: list[int]) -> list[int]:\n    xors = functools.reduce(operator.xor, nums)\n    lowbit = xors & -xors\n    ans = [0, 0]\n\n    # Seperate `nums` into two groups by `lowbit`.\n    for num in nums:\n      if num & lowbit:\n        ans[0] ^= num\n      else:\n        ans[1] ^= num\n\n    return ans",
      "title": "260. Single Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a073e8d5-1996-4af8-a892-fe1cb4005074",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validTree(self, n: int, edges: list[list[int]]) -> bool:\n    if n == 0 or len(edges) != n - 1:\n      return False\n\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count == 1",
      "title": "261. Graph Valid Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a768d27-b8d4-4f31-998a-ddb9714ad7e9",
      "code": "class Solution:\n  def isUgly(self, n: int) -> bool:\n    if n == 0:\n      return False\n\n    for prime in 2, 3, 5:\n      while n % prime == 0:\n        n //= prime\n\n    return n == 1",
      "title": "263. Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "becce4a4-2b65-4f3c-91bd-9fc4a8bf2e19",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int) -> int:\n    nums = [1]\n    i2 = 0\n    i3 = 0\n    i5 = 0\n\n    while len(nums) < n:\n      next2 = nums[i2] * 2\n      next3 = nums[i3] * 3\n      next5 = nums[i5] * 5\n      next = min(next2, next3, next5)\n      if next == next2:\n        i2 += 1\n      if next == next3:\n        i3 += 1\n      if next == next5:\n        i5 += 1\n      nums.append(next)\n\n    return nums[-1]",
      "title": "264. Ugly Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c62bbd0d-15da-4e76-a707-ec25faf0fa91",
      "code": "class Solution:\n  def minCostII(self, costs: list[list[int]]) -> int:\n    prevIndex = -1  # the previous minimum index\n    prevMin1 = 0  # the minimum cost so far\n    prevMin2 = 0  # the second minimum cost so far\n\n    for cost in costs:  # O(n)\n      # the painted index that will achieve the minimum cost after painting the\n      # current house\n      index = -1\n      # the minimum cost after painting the current house\n      min1 = math.inf\n      # the second minimum cost after painting the current house\n      min2 = math.inf\n      for i, cst in enumerate(cost):   # O(k)\n        theCost = cst + (prevMin2 if i == prevIndex else prevMin1)\n        if theCost < min1:\n          index = i\n          min2 = min1\n          min1 = theCost\n        elif theCost < min2:  # min1 <= theCost < min2\n          min2 = theCost\n\n      prevIndex = index\n      prevMin1 = min1\n      prevMin2 = min2\n\n    return prevMin1",
      "title": "265. Paint House II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a3ee41e-34c1-441c-919a-d0a5d6ffae3c",
      "code": "class Solution:\n  def canPermutePalindrome(self, s: str) -> bool:\n    seen = set()\n\n    for c in s:\n      if c in seen:\n        seen.remove(c)\n      else:\n        seen.add(c)\n\n    return len(seen) <= 1",
      "title": "266. Palindrome Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be548f28-a12d-491d-92e8-258488b755c6",
      "code": "class Solution:\n  def generatePalindromes(self, s: str) -> list[str]:\n    count = collections.Counter(s)\n\n    # Count odd ones.\n    odd = sum(value & 1 for value in count.values())\n\n    # Can't form any palindrome.\n    if odd > 1:\n      return []\n\n    ans = []\n    candidates = []\n    mid = ''\n\n    # Get the mid and the candidates characters.\n    for key, value in count.items():\n      if value % 2 == 1:\n        mid += key\n      for _ in range(value // 2):\n        candidates.append(key)\n\n    def dfs(used: list[bool], path: list[str]) -> None:\n      \"\"\"Generates all the unique palindromes from the candidates.\"\"\"\n      if len(path) == len(candidates):\n        ans.append(''.join(path) + mid + ''.join(reversed(path)))\n        return\n\n      for i, candidate in enumerate(candidates):\n        if used[i]:\n          continue\n        if i > 0 and candidate == candidates[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        path.append(candidate)\n        dfs(used, path)\n        path.pop()\n        used[i] = False\n\n    # Backtrack to generate the ans strings.\n    dfs([False] * len(candidates), [])\n    return ans",
      "title": "267. Palindrome Permutation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caa6467a-8716-4515-99cd-70866f2c8ac1",
      "code": "class Solution:\n  def missingNumber(self, nums: list[int]) -> int:\n    ans = len(nums)\n\n    for i, num in enumerate(nums):\n      ans ^= i ^ num\n\n    return ans",
      "title": "268. Missing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9da4b938-47bf-4346-9789-d201d1ee2064",
      "code": "class Solution:\n  def alienOrder(self, words: list[str]) -> str:\n    graph = {}\n    inDegrees = [0] * 26\n\n    self._buildGraph(graph, words, inDegrees)\n    return self._topology(graph, inDegrees)\n\n  def _buildGraph(\n      self,\n      graph: dict[str, set[str]],\n      words: list[str],\n      inDegrees: list[int],\n  ) -> None:\n    # Create a node for each character in each word.\n    for word in words:\n      for c in word:\n        if c not in graph:\n          graph[c] = set()\n\n    for first, second in zip(words, words[1:]):\n      length = min(len(first), len(second))\n      for j in range(length):\n        u = first[j]\n        v = second[j]\n        if u != v:\n          if v not in graph[u]:\n            graph[u].add(v)\n            inDegrees[ord(v) - ord('a')] += 1\n          break  # The order of characters after this are meaningless.\n        # First = 'ab', second = 'a' . invalid\n        if j == length - 1 and len(first) > len(second):\n          graph.clear()\n          return\n\n  def _topology(self, graph: dict[str, set[str]], inDegrees: list[int]) -> str:\n    s = ''\n    q = collections.deque()\n\n    for c in graph:\n      if inDegrees[ord(c) - ord('a')] == 0:\n        q.append(c)\n\n    while q:\n      u = q.pop()\n      s += u\n      for v in graph[u]:\n        inDegrees[ord(v) - ord('a')] -= 1\n        if inDegrees[ord(v) - ord('a')] == 0:\n          q.append(v)\n\n    # Words = ['z', 'x', 'y', 'x']\n    return s if len(s) == len(graph) else ''",
      "title": "269. Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ee18254-f39e-4c0f-b6ff-6c76155c0352",
      "code": "class Solution:\n  def closestValue(self, root: TreeNode | None, target: float) -> int:\n    # If target < root.val, search the left subtree.\n    if target < root.val and root.left:\n      left = self.closestValue(root.left, target)\n      if abs(left - target) <= abs(root.val - target):\n        return left\n\n    # If target > root.val, search the right subtree.\n    if target > root.val and root.right:\n      right = self.closestValue(root.right, target)\n      if abs(right - target) < abs(root.val - target):\n        return right\n\n    return root.val",
      "title": "270. Closest Binary Search Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f0c8f8e-aa82-46e7-b6e2-da23f231c41d",
      "code": "class Solution:\n  def closestKValues(\n      self,\n      root: TreeNode | None,\n      target: float,\n      k: int,\n  ) -> list[int]:\n    dq = collections.deque()\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      dq.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    while len(dq) > k:\n      if abs(dq[0] - target) > abs(dq[-1] - target):\n        dq.popleft()\n      else:\n        dq.pop()\n\n    return list(dq)",
      "title": "272. Closest Binary Search Tree Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd7d941-3171-461b-914c-7774ef2a2f7f",
      "code": "class Solution:\n  def numberToWords(self, num: int) -> str:\n    if num == 0:\n      return 'Zero'\n\n    belowTwenty = ['',        'One',       'Two',      'Three',\n                   'Four',    'Five',      'Six',      'Seven',\n                   'Eight',   'Nine',      'Ten',      'Eleven',\n                   'Twelve',  'Thirteen',  'Fourteen', 'Fifteen',\n                   'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen']\n    tens = ['',      'Ten',   'Twenty',  'Thirty', 'Forty',\n            'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety']\n\n    def helper(num: int) -> str:\n      if num < 20:\n        s = belowTwenty[num]\n      elif num < 100:\n        s = tens[num // 10] + ' ' + belowTwenty[num % 10]\n      elif num < 1000:\n        s = helper(num // 100) + ' Hundred ' + helper(num % 100)\n      elif num < 1000000:\n        s = helper(num // 1000) + ' Thousand ' + helper(num % 1000)\n      elif num < 1000000000:\n        s = helper(num // 1000000) + ' Million ' + helper(num % 1000000)\n      else:\n        s = helper(num // 1000000000) + ' Billion ' + helper(num % 1000000000)\n      return s.strip()\n\n    return helper(num)",
      "title": "273. Integer to English Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9d72465-3016-4be6-82e0-3adad31089f2",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    accumulate = 0\n    count = [0] * (n + 1)\n\n    for citation in citations:\n      count[min(citation, n)] += 1\n\n    # To find the maximum h-index, loop from the back to the front.\n    # i := the candidate's h-index\n    for i, c in reversed(list(enumerate(count))):\n      accumulate += c\n      if accumulate >= i:\n        return i",
      "title": "274. H-Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ede80623-eee5-4295-846d-c290ca530383",
      "code": "class Solution:\n  def hIndex(self, citations: list[int]) -> int:\n    n = len(citations)\n    return n - bisect.bisect_left(range(n), n,\n                                  key=lambda m: citations[m] + m)",
      "title": "275. H-Index II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68f2a673-e3d3-40bc-86e2-96a2f88c1892",
      "code": "class Solution:\n  def numWays(self, n: int, k: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return k\n    if n == 2:\n      return k * k\n\n    # dp[i] := the number of ways to pan posts with k colors\n    dp = [0] * (n + 1)\n    dp[0] = 0\n    dp[1] = k\n    dp[2] = k * k\n\n    for i in range(3, n + 1):\n      dp[i] = (dp[i - 1] + dp[i - 2]) * (k - 1)\n\n    return dp[n]",
      "title": "276. Paint Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa2b876e-21c8-47c9-92c1-806563f37230",
      "code": "# The knows API is already defined for you.\n# Returns a bool, whether a knows b\n# Def knows(a: int, b: int) -> bool:\n\n\nclass Solution:\n  def findCelebrity(self, n: int) -> int:\n    candidate = 0\n\n    # Everyone knows the celebrity.\n    for i in range(1, n):\n      if knows(candidate, i):\n        candidate = i\n\n    # The candidate knows nobody and everyone knows the celebrity.\n    for i in range(n):\n      if i < candidate and knows(candidate, i) or not knows(i, candidate):\n        return -1\n      if i > candidate and not knows(i, candidate):\n        return -1\n\n    return candidate",
      "title": "277. Find the Celebrity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5cb8aa7-e50e-4d0a-be81-dd211434157d",
      "code": "class Solution:\n  def firstBadVersion(self, n: int) -> int:\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r) >> 1\n      if isBadVersion(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "278. First Bad Version",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dd2a54a-3a41-4c24-aac4-329b0a199c7d",
      "code": "class Solution:\n  def numSquares(self, n: int) -> int:\n    dp = [n] * (n + 1)  # 1^2 x n\n    dp[0] = 0  # no way\n    dp[1] = 1  # 1^2\n\n    for i in range(2, n + 1):\n      j = 1\n      while j * j <= i:\n        dp[i] = min(dp[i], dp[i - j * j] + 1)\n        j += 1\n\n    return dp[n]",
      "title": "279. Perfect Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fefdfab4-2c37-45ca-9373-a2513b629e4f",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    # 1. If i is even, then nums[i] <= nums[i - 1].\n    # 2. If i is odd, then nums[i] >= nums[i - 1].\n    for i in range(1, len(nums)):\n      if (i % 2 == 0 and nums[i] > nums[i - 1] or\n              i % 2 == 1 and nums[i] < nums[i - 1]):\n        nums[i], nums[i - 1] = nums[i - 1], nums[i]",
      "title": "280. Wiggle Sort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb636f2d-6ee1-45f2-8da2-36a7cfa19431",
      "code": "class Solution:\n  def addOperators(self, num: str, target: int) -> list[str]:\n    ans = []\n\n    def dfs(start: int, prev: int, eval: int, path: list[str]) -> None:\n      if start == len(num):\n        if eval == target:\n          ans.append(''.join(path))\n        return\n\n      for i in range(start, len(num)):\n        if i > start and num[start] == '0':\n          return\n        s = num[start:i + 1]\n        curr = int(s)\n        if start == 0:\n          path.append(s)\n          dfs(i + 1, curr, curr, path)\n          path.pop()\n        else:\n          for op in ['+', '-', '*']:\n            path.append(op + s)\n            if op == '+':\n              dfs(i + 1, curr, eval + curr, path)\n            elif op == '-':\n              dfs(i + 1, -curr, eval - curr, path)\n            else:\n              dfs(i + 1, prev * curr, eval - prev + prev * curr, path)\n            path.pop()\n\n    dfs(0, 0, 0, [])\n    return ans",
      "title": "282. Expression Add Operators",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ee36637-bfc1-4a60-aca1-e2feda8870e5",
      "code": "class Solution:\n  def moveZeroes(self, nums: list[int]) -> None:\n    j = 0\n    for num in nums:\n      if num != 0:\n        nums[j] = num\n        j += 1\n\n    for i in range(j, len(nums)):\n      nums[i] = 0",
      "title": "283. Move Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f60bb64-abe1-475b-b7c7-e58162fbc677",
      "code": "class Solution:\n  def inorderSuccessor(\n      self,\n      root: TreeNode | None,\n      p: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val <= p.val:\n      return self.inorderSuccessor(root.right, p)\n    return self.inorderSuccessor(root.left, p) or root",
      "title": "285. Inorder Successor in BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71117911-c1f9-4f33-8f37-6e2f6cfb7902",
      "code": "class Solution:\n  def wallsAndGates(self, rooms: list[list[int]]) -> None:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    INF = 2**31 - 1\n    m = len(rooms)\n    n = len(rooms[0])\n    q = collections.deque((i, j)\n                          for i in range(m)\n                          for j in range(n)\n                          if rooms[i][j] == 0)\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if rooms[x][y] != INF:\n          continue\n        rooms[x][y] = rooms[i][j] + 1\n        q.append((x, y))",
      "title": "286. Walls and Gates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9abd6579-53a4-4d7f-a927-f67217ae1f00",
      "code": "class Solution:\n  def findDuplicate(self, nums: list[int]) -> int:\n    slow = nums[nums[0]]\n    fast = nums[nums[nums[0]]]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[nums[fast]]\n\n    slow = nums[0]\n\n    while slow != fast:\n      slow = nums[slow]\n      fast = nums[fast]\n\n    return slow",
      "title": "287. Find the Duplicate Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f34548c-3b83-4721-9b3b-a30bb3178f82",
      "code": "class Solution:\n  def gameOfLife(self, board: list[list[int]]) -> None:\n    m = len(board)\n    n = len(board[0])\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        for x in range(max(0, i - 1), min(m, i + 2)):\n          for y in range(max(0, j - 1), min(n, j + 2)):\n            ones += board[x][y] & 1\n        # Any live cell with two or three live neighbors lives on to the next\n        # generation.\n        if board[i][j] == 1 and (ones == 3 or ones == 4):\n          board[i][j] |= 0b10\n        # Any dead cell with exactly three live neighbors becomes a live cell,\n        # as if by reproduction.\n        if board[i][j] == 0 and ones == 3:\n          board[i][j] |= 0b10\n\n    for i in range(m):\n      for j in range(n):\n        board[i][j] >>= 1",
      "title": "289. Game of Life",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44cc6f5a-ab68-4fe1-b05c-ca1f2ba49a6d",
      "code": "class Solution:\n  def wordPattern(self, pattern: str, str: str) -> bool:\n    t = str.split()\n    return [*map(pattern.index, pattern)] == [*map(t.index, t)]",
      "title": "290. Word Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba3a8e55-5890-4d9e-9038-6bbde02eacd5",
      "code": "class Solution:\n  def wordPatternMatch(self, pattern: str, s: str) -> bool:\n    def isMatch(\n            i: int, j: int, charToString: dict[str, str],\n            seen: set[str]) -> bool:\n      if i == len(pattern) and j == len(s):\n        return True\n      if i == len(pattern) or j == len(s):\n        return False\n\n      c = pattern[i]\n\n      if c in charToString:\n        t = charToString[c]\n        # See if we can match t with s[j..n).\n        if t not in s[j:]:\n          return False\n\n        # If there's a match, continue to match the rest.\n        return isMatch(i + 1, j + len(t), charToString, seen)\n\n      for k in range(j, len(s)):\n        t = s[j:k + 1]\n\n        # This string is mapped by another character.\n        if t in seen:\n          continue\n\n        charToString[c] = t\n        seen.add(t)\n\n        if isMatch(i + 1, k + 1, charToString, seen):\n          return True\n\n        # Backtrack.\n        del charToString[c]\n        seen.remove(t)\n\n      return False\n\n    return isMatch(0, 0, {}, set())",
      "title": "291. Word Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96d72b8a-31ae-4312-a44e-034a94a5a390",
      "code": "class Solution:\n  def canWinNim(self, n: int) -> bool:\n    return n % 4 != 0",
      "title": "292. Nim Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3aa7e04-8c1c-4a5e-8708-c46cbec34314",
      "code": "class Solution:\n  def generatePossibleNextMoves(self, currentState: str) -> list[str]:\n    return [currentState[:i] + '--' + currentState[i + 2:]\n            for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n            if a == '+' and b == '+']",
      "title": "293. Flip Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6807a5c9-89b2-45f0-9617-9ba51eaa5e4c",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def canWin(self, currentState: str) -> bool:\n    # If any of currentState[i:i + 2] == \"++\" and your friend can't win after\n    # changing currentState[i:i + 2] to \"--\" (or \"-\"), then you can win.\n    return any(True\n               for i, (a, b) in enumerate(zip(currentState, currentState[1:]))\n               if a == '+' and b == '+' and\n               not self.canWin(currentState[:i] + '-' + currentState[i + 2:]))",
      "title": "294. Flip Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b321d69-4615-4a1a-9366-4fac32dcc023",
      "code": "class Solution:\n  def minTotalDistance(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # i indices s.t. grid[i][j] == 1\n    I = [i for i in range(m) for j in range(n) if grid[i][j]]\n    # j indices s.t. grid[i][j] == 1\n    J = [j for j in range(n) for i in range(m) if grid[i][j]]\n\n    def minTotalDistance(grid: list[int]) -> int:\n      summ = 0\n      i = 0\n      j = len(grid) - 1\n      while i < j:\n        summ += grid[j] - grid[i]\n        i += 1\n        j -= 1\n      return summ\n\n    # sum(i - median(I)) + sum(j - median(J))\n    return minTotalDistance(I) + minTotalDistance(J)",
      "title": "296. Best Meeting Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78c0c0ce-2f95-4dbc-a5f8-2de44c1171b7",
      "code": "class Solution:\n  def longestConsecutive(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode | None, target: int, length: int, maxLength: int) -> int:\n      if not root:\n        return maxLength\n      if root.val == target:\n        length += 1\n        maxLength = max(maxLength, length)\n      else:\n        length = 1\n      return max(dfs(root.left, root.val + 1, length, maxLength),\n                 dfs(root.right, root.val + 1, length, maxLength))\n\n    return dfs(root, root.val, 0, 0)",
      "title": "298. Binary Tree Longest Consecutive Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61d323e3-7a53-4f7f-a813-d9f6730df148",
      "code": "class Solution:\n  def getHint(self, secret: str, guess: str) -> str:\n    bulls = sum(map(operator.eq, secret, guess))\n    bovine = sum(min(secret.count(x), guess.count(x)) for x in set(guess))\n    return '%dA%dB' % (bulls, bovine - bulls)",
      "title": "299. Bulls and Cows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d25027cd-4e56-4a7a-8b46-356f89b6d1fa",
      "code": "class Solution:\n  def lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n\n    return len(tails)",
      "title": "300. Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "175660fb-0ab1-4066-a7b5-a863b7801a1b",
      "code": "class Solution:\n  def removeInvalidParentheses(self, s: str) -> list[str]:\n    # Similar to 921. Minimum Add to Make Parentheses Valid\n    def getLeftAndRightCounts(s: str) -> tuple[int, int]:\n      \"\"\"Returns how many '(' and ')' need to be deleted.\"\"\"\n      l = 0\n      r = 0\n\n      for c in s:\n        if c == '(':\n          l += 1\n        elif c == ')':\n          if l == 0:\n            r += 1\n          else:\n            l -= 1\n\n      return l, r\n\n    def isValid(s: str):\n      opened = 0  # the number of '(' - # of ')'\n      for c in s:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened < 0:\n          return False\n      return True  # opened == 0\n\n    ans = []\n\n    def dfs(s: str, start: int, l: int, r: int) -> None:\n      if l == 0 and r == 0 and isValid(s):\n        ans.append(s)\n        return\n\n      for i in range(start, len(s)):\n        if i > start and s[i] == s[i - 1]:\n          continue\n        if r > 0 and s[i] == ')':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l, r - 1)\n        elif l > 0 and s[i] == '(':  # Delete s[i]\n          dfs(s[:i] + s[i + 1:], i, l - 1, r)\n\n    l, r = getLeftAndRightCounts(s)\n    dfs(s, 0, l, r)\n    return ans",
      "title": "301. Remove Invalid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d786de9c-8f25-4f26-af23-1f8f83f8c99a",
      "code": "class Solution:\n  def minArea(self, image: list[list[str]], x: int, y: int) -> int:\n    def firstAnyOne(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          l = m + 1\n        else:\n          r = m\n      return l\n\n    def firstAllZeros(l: int, r: int, allZeros: Callable[[int], bool]) -> int:\n      while l < r:\n        m = (l + r) // 2\n        if allZeros(m):\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def colAllZeros(colIndex: int) -> bool:\n      return all(pixel == '0' for pixel in list(zip(*image))[colIndex])\n\n    def rowAllZeros(rowIndex: int) -> bool:\n      return all(pixel == '0' for pixel in image[rowIndex])\n\n    x1 = firstAnyOne(0, x, rowAllZeros)\n    x2 = firstAllZeros(x + 1, len(image), rowAllZeros)\n    y1 = firstAnyOne(0, y, colAllZeros)\n    y2 = firstAllZeros(y + 1, len(image[0]), colAllZeros)\n    return (x2 - x1) * (y2 - y1)",
      "title": "302. Smallest Rectangle Enclosing Black Pixels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5efde8b7-fe04-46e5-a4f2-d46226d978a4",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = [-1] * n\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numIslands2(\n      self,\n      m: int,\n      n: int,\n      positions: list[list[int]],\n  ) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    seen = [[False] * n for _ in range(m)]\n    uf = UnionFind(m * n)\n    count = 0\n\n    def getId(i: int, j: int, n: int) -> int:\n      return i * n + j\n\n    for i, j in positions:\n      if seen[i][j]:\n        ans.append(count)\n        continue\n      seen[i][j] = True\n      id = getId(i, j, n)\n      uf.id[id] = id\n      count += 1\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        neighborId = getId(x, y, n)\n        if uf.id[neighborId] == -1:  # water\n          continue\n        currentParent = uf.find(id)\n        neighborParent = uf.find(neighborId)\n        if currentParent != neighborParent:\n          uf.unionByRank(currentParent, neighborParent)\n          count -= 1\n      ans.append(count)\n\n    return ans",
      "title": "305. Number of Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89a9f767-df45-4813-b313-15d8053a892d",
      "code": "class Solution:\n  def isAdditiveNumber(self, num: str) -> bool:\n    n = len(num)\n\n    def dfs(firstNum: int, secondNum: int, s: int) -> bool:\n      if s == len(num):\n        return True\n\n      thirdNum = firstNum + secondNum\n      thirdNumStr = str(thirdNum)\n\n      return (num.find(thirdNumStr, s) == s and\n              dfs(secondNum, thirdNum, s + len(thirdNumStr)))\n\n    # num[0..i] = firstNum\n    for i in range(n // 2):\n      if i > 0 and num[0] == '0':\n        return False\n      firstNum = int(num[:i + 1])\n      # num[i + 1..j] = secondNum\n      # |thirdNum| >= max(|firstNum|, |secondNum|)\n      j = i + 1\n      while max(i, j - i) < n - j:\n        if j > i + 1 and num[i + 1] == '0':\n          break\n        secondNum = int(num[i + 1:j + 1])\n        if dfs(firstNum, secondNum, j + 1):\n          return True\n        j += 1\n\n    return False",
      "title": "306. Additive Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca6aad03-5aaa-4945-b296-8ec71525b741",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int]) -> int:\n    sell = 0\n    hold = -math.inf\n    prev = 0\n\n    for price in prices:\n      cache = sell\n      sell = max(sell, hold + price)\n      hold = max(hold, prev - price)\n      prev = cache\n\n    return sell",
      "title": "309. Best Time to Buy and Sell Stock with Cooldown",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51e1bd0b-b885-42c0-b5a4-d77a0b9972b6",
      "code": "class Solution:\n  def findMinHeightTrees(self, n: int, edges: list[list[int]]) -> list[int]:\n    if n == 1 or not edges:\n      return [0]\n\n    ans = []\n    graph = collections.defaultdict(set)\n\n    for u, v in edges:\n      graph[u].add(v)\n      graph[v].add(u)\n\n    for label, children in graph.items():\n      if len(children) == 1:\n        ans.append(label)\n\n    while n > 2:\n      n -= len(ans)\n      nextLeaves = []\n      for leaf in ans:\n        u = next(iter(graph[leaf]))\n        graph[u].remove(leaf)\n        if len(graph[u]) == 1:\n          nextLeaves.append(u)\n      ans = nextLeaves\n\n    return ans",
      "title": "310. Minimum Height Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b354597f-ba16-41ba-b608-a193281af03f",
      "code": "class Solution:\n  def multiply(self, mat1: list[list[int]],\n               mat2: list[list[int]]) -> list[list[int]]:\n    m = len(mat1)\n    n = len(mat2)\n    l = len(mat2[0])\n    ans = [[0] * l for _ in range(m)]\n    nonZeroColIndicesInMat2 = [\n        [j for j, a in enumerate(row) if a]\n        for row in mat2\n    ]\n\n    for i in range(m):\n      for j, a in enumerate(mat1[i]):\n        if a == 0:\n          continue\n        # mat1s j-th column matches mat2's j-th row\n        for colIndex in nonZeroColIndicesInMat2[j]:\n          ans[i][colIndex] += a * mat2[j][colIndex]\n\n    return ans",
      "title": "311. Sparse Matrix Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaa2980c-b316-4efa-9f82-034e8ebacc69",
      "code": "class Solution:\n  def maxCoins(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i][j] := maxCoins(nums[i..j])\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    nums = [1] + nums + [1]\n\n    for d in range(n):\n      for i in range(1, n - d + 1):\n        j = i + d\n        for k in range(i, j + 1):\n          dp[i][j] = max(\n              dp[i][j],\n              dp[i][k - 1] +\n              dp[k + 1][j] +\n              nums[i - 1] * nums[k] * nums[j + 1])\n\n    return dp[1][n]",
      "title": "312. Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b8d8528-cde6-4aa1-87b2-5549fd31c601",
      "code": "class UglyNum:\n  def __init__(self, prime: int, index: int, value: int):\n    self.prime = prime\n    self.index = index  # Point the next index of uglyNums.\n    self.value = value  # prime * uglyNums[index]\n\n\nclass Solution:\n  def nthSuperUglyNumber(self, n: int, primes: list[int]) -> int:\n    minHeap = []  # (value, prime, index)\n    uglyNums = [1]\n\n    for prime in primes:\n      heapq.heappush(minHeap, (prime * uglyNums[0], prime, 1))\n\n    while len(uglyNums) < n:\n      uglyNums.append(minHeap[0][0])\n      while minHeap[0][0] == uglyNums[-1]:\n        _, prime, index = heapq.heappop(minHeap)\n        heapq.heappush(minHeap, (prime * uglyNums[index], prime, index + 1))\n\n    return uglyNums[-1]",
      "title": "313. Super Ugly Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cae342fd-09ac-4d36-a2aa-5d6cf836084d",
      "code": "class Solution:\n  def verticalOrder(self, root: TreeNode | None) -> list[list[int]]:\n    if not root:\n      return []\n\n    range_ = [0] * 2\n\n    def getRange(root: TreeNode | None, x: int) -> None:\n      if not root:\n        return\n\n      range_[0] = min(range_[0], x)\n      range_[1] = max(range_[1], x)\n\n      getRange(root.left, x - 1)\n      getRange(root.right, x + 1)\n\n    getRange(root, 0)  # Get the leftmost and the rightmost x index.\n\n    ans = [[] for _ in range(range_[1] - range_[0] + 1)]\n    q = collections.deque([(root, -range_[0])])  # (TreeNode, x)\n\n    while q:\n      node, x = q.popleft()\n      ans[x].append(node.val)\n      if node.left:\n        q.append((node.left, x - 1))\n      if node.right:\n        q.append((node.right, x + 1))\n\n    return ans",
      "title": "314. Binary Tree Vertical Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fae1a5b3-b31c-4b12-bbcd-d98a2a468565",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Item:\n  num: int = 0\n  index: int = 0\n\n\nclass Solution:\n  def countSmaller(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    items = [Item(num, i) for i, num in enumerate(nums)]\n\n    self._mergeSort(items, 0, n - 1, ans)\n    return ans\n\n  def _mergeSort(\n      self,\n      items: list[Item],\n      l: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(items, l, m, ans)\n    self._mergeSort(items, m + 1, r, ans)\n    self._merge(items, l, m, r, ans)\n\n  def _merge(\n      self,\n      items: list[Item],\n      l: int,\n      m: int,\n      r: int,\n      ans: list[int],\n  ) -> None:\n    sorted = [Item()] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n    rightCount = 0  # the number of numbers < items[i].num\n\n    while i <= m and j <= r:\n      if items[i].num > items[j].num:\n        rightCount += 1\n        sorted[k] = items[j]\n        k += 1\n        j += 1\n      else:\n        ans[items[i].index] += rightCount\n        sorted[k] = items[i]\n        k += 1\n        i += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      ans[items[i].index] += rightCount\n      sorted[k] = items[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = items[j]\n      k += 1\n      j += 1\n\n    items[l:l + len(sorted)] = sorted",
      "title": "315. Count of Smaller Numbers After Self",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffaff877-d3b8-45a8-b2c2-3e8e650a39b5",
      "code": "class Solution:\n  def removeDuplicateLetters(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    used = [False] * 26\n\n    for c in s:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "316. Remove Duplicate Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "210253b0-4f9c-4971-85f1-627339118051",
      "code": "class Solution:\n  def shortestDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nBuildings = sum(a == 1 for row in grid for a in row)\n    ans = math.inf\n    # dist[i][j] := the total distance of grid[i][j] (0) to reach all the\n    # buildings (1)\n    dist = [[0] * n for _ in range(m)]\n    # reachCount[i][j] := the number of buildings (1) grid[i][j] (0) can reach\n    reachCount = [[0] * n for _ in range(m)]\n\n    def bfs(row: int, col: int) -> bool:\n      q = collections.deque([(row, col)])\n      seen = {(row, col)}\n      seenBuildings = 1\n\n      step = 1\n      while q:\n        for _ in range(len(q)):\n          i, j = q.popleft()\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x == m or y < 0 or y == n:\n              continue\n            if (x, y) in seen:\n              continue\n            seen.add((x, y))\n            if not grid[x][y]:\n              dist[x][y] += step\n              reachCount[x][y] += 1\n              q.append((x, y))\n            elif grid[x][y] == 1:\n              seenBuildings += 1\n        step += 1\n\n      # True if all the buildings (1) are connected\n      return seenBuildings == nBuildings\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:  # BFS from this building.\n          if not bfs(i, j):\n            return -1\n\n    for i in range(m):\n      for j in range(n):\n        if reachCount[i][j] == nBuildings:\n          ans = min(ans, dist[i][j])\n\n    return -1 if ans == math.inf else ans",
      "title": "317. Shortest Distance from All Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db861c8a-be73-49cb-bf07-2db5b9356ef0",
      "code": "class Solution:\n  def maxProduct(self, words: list[str]) -> int:\n    ans = 0\n\n    def getMask(word: str) -> int:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    masks = [getMask(word) for word in words]\n\n    for i in range(len(words)):\n      for j in range(i):\n        if not (masks[i] & masks[j]):\n          ans = max(ans, len(words[i]) * len(words[j]))\n\n    return ans",
      "title": "318. Maximum Product of Word Lengths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2661f7b-54ef-415b-ae8d-1b073ee03101",
      "code": "class Solution:\n  def bulbSwitch(self, n: int) -> int:\n    # The k-th bulb can only be switched when k % i == 0.\n    # So, we can rephrase the problem:\n    # To find number of numbers <= n that have odd factors.\n    # Obviously, only square numbers have odd factor(s).\n    # e.g. n = 10, only 1, 4, and 9 are square numbers that <= 10\n    return math.isqrt(n)",
      "title": "319. Bulb Switcher",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37dd5750-7cf2-40da-9dfa-7b888750494d",
      "code": "class Solution:\n  def generateAbbreviations(self, word: str) -> list[str]:\n    ans = []\n\n    def getCountString(count: int) -> str:\n      return str(count) if count > 0 else ''\n\n    def dfs(i: int, count: int, path: list[str]) -> None:\n      if i == len(word):\n        ans.append(''.join(path) + getCountString(count))\n        return\n\n      # Abbreviate the word[i].\n      dfs(i + 1, count + 1, path)\n      # Keep the word[i], so consume the count as a string.\n      path.append(getCountString(count) + word[i])\n      # Reset the count to 0.\n      dfs(i + 1, 0, path)\n      path.pop()\n\n    dfs(0, 0, [])\n    return ans",
      "title": "320. Generalized Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee5a0af1-5c39-4aea-bd02-bfc7ae50eccd",
      "code": "class Solution:\n  def maxNumber(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    def maxArray(nums: list[int], k: int) -> list[int]:\n      res = []\n      toTop = len(nums) - k\n      for num in nums:\n        while res and res[-1] < num and toTop > 0:\n          res.pop()\n          toTop -= 1\n        res.append(num)\n      return res[:k]\n\n    def merge(nums1: list[int], nums2: list[int]) -> list[int]:\n      return [max(nums1, nums2).pop(0) for _ in nums1 + nums2]\n\n    return max(merge(maxArray(nums1, i), maxArray(nums2, k - i))\n               for i in range(k + 1)\n               if i <= len(nums1) and k - i <= len(nums2))",
      "title": "321. Create Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c20b72e-4ffa-4d9a-b6d6-e0c5418b3e06",
      "code": "class Solution:\n  def coinChange(self, coins: list[int], amount: int) -> int:\n    # dp[i] := the minimum number Of coins to make up i\n    dp = [0] + [amount + 1] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] = min(dp[i], dp[i - coin] + 1)\n\n    return -1 if dp[amount] == amount + 1 else dp[amount]",
      "title": "322. Coin Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aeb94a62-9a9c-4abb-8e29-bc76e38079f2",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.count",
      "title": "323. Number of Connected Components in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43f04e49-b813-4142-b3c9-d3f5e7c06a6e",
      "code": "class Solution:\n  def countComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(node: int, seen: set[int]) -> None:\n      q = collections.deque([node])\n      seen.add(node)\n\n      while q:\n        u = q.pop()\n        for v in graph[u]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for i in range(n):\n      if i not in seen:\n        bfs(i, seen)\n        ans += 1\n\n    return ans",
      "title": "323. Number of Connected Components in an Undirected Graph_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "788ab66e-c12b-4fbe-9ea8-f0bddd684e7f",
      "code": "class Solution:\n  def wiggleSort(self, nums: list[int]) -> None:\n    n = len(nums)\n    median = self._findKthLargest(nums, (n + 1) // 2)\n\n    def A(i: int):\n      return (1 + 2 * i) % (n | 1)\n\n    i = 0\n    j = 0\n    k = n - 1\n\n    while i <= k:\n      if nums[A(i)] > median:\n        nums[A(i)], nums[A(j)] = nums[A(j)], nums[A(i)]\n        i, j = i + 1, j + 1\n      elif nums[A(i)] < median:\n        nums[A(i)], nums[A(k)] = nums[A(k)], nums[A(i)]\n        k -= 1\n      else:\n        i += 1\n\n  # Same as 215. Kth Largest Element in an Array\n  def _findKthLargest(self, nums: list[int], k: int) -> int:\n    def quickSelect(l: int, r: int, k: int) -> int:\n      randIndex = random.randint(0, r - l) + l\n      nums[randIndex], nums[r] = nums[r], nums[randIndex]\n      pivot = nums[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if nums[i] >= pivot:\n          nums[nextSwapped], nums[i] = nums[i], nums[nextSwapped]\n          nextSwapped += 1\n      nums[nextSwapped], nums[r] = nums[r], nums[nextSwapped]\n\n      count = nextSwapped - l + 1  # Number of nums >= pivot\n      if count == k:\n        return nums[nextSwapped]\n      if count > k:\n        return quickSelect(l, nextSwapped - 1, k)\n      return quickSelect(nextSwapped + 1, r, k - count)\n\n    return quickSelect(0, len(nums) - 1, k)",
      "title": "324. Wiggle Sort II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4d54888-15c8-4bc9-95c1-d0e95bd627f6",
      "code": "class Solution:\n  def maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        ans = max(ans, i - prefixToIndex[target])\n      if prefix not in prefixToIndex:\n        prefixToIndex[prefix] = i\n\n    return ans",
      "title": "325. Maximum Size Subarray Sum Equals k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c662780c-5575-49c6-a767-eb716644b128",
      "code": "class Solution:\n  def isPowerOfThree(self, n: int) -> bool:\n    return n > 0 and 3**19 % n == 0",
      "title": "326. Power of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6376a1aa-7eb4-45a3-95d7-d6b5633bd9c4",
      "code": "class Solution:\n  def countRangeSum(self, nums: list[int], lower: int, upper: int) -> int:\n    n = len(nums)\n    self.ans = 0\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    self._mergeSort(prefix, 0, n, lower, upper)\n    return self.ans\n\n  def _mergeSort(\n      self,\n      prefix: list[int],\n      l: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    if l >= r:\n      return\n\n    m = (l + r) // 2\n    self._mergeSort(prefix, l, m, lower, upper)\n    self._mergeSort(prefix, m + 1, r, lower, upper)\n    self._merge(prefix, l, m, r, lower, upper)\n\n  def _merge(\n      self,\n      prefix: list[int],\n      l: int,\n      m: int,\n      r: int,\n      lower: int,\n      upper: int,\n  ) -> None:\n    lo = m + 1  # the first index s.t. prefix[lo] - prefix[i] >= lower\n    hi = m + 1  # the first index s.t. prefix[hi] - prefix[i] > upper\n\n    # For each index i in range [l, m], add hi - lo to `ans`.\n    for i in range(l, m + 1):\n      while lo <= r and prefix[lo] - prefix[i] < lower:\n        lo += 1\n      while hi <= r and prefix[hi] - prefix[i] <= upper:\n        hi += 1\n      self.ans += hi - lo\n\n    sorted = [0] * (r - l + 1)\n    k = 0  # sorted's index\n    i = l  # left's index\n    j = m + 1  # right's index\n\n    while i <= m and j <= r:\n      if prefix[i] < prefix[j]:\n        sorted[k] = prefix[i]\n        k += 1\n        i += 1\n      else:\n        sorted[k] = prefix[j]\n        k += 1\n        j += 1\n\n    # Put the possible remaining left part into the sorted array.\n    while i <= m:\n      sorted[k] = prefix[i]\n      k += 1\n      i += 1\n\n    # Put the possible remaining right part into the sorted array.\n    while j <= r:\n      sorted[k] = prefix[j]\n      k += 1\n      j += 1\n\n    prefix[l:l + len(sorted)] = sorted",
      "title": "327. Count of Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4061ff30-dbdb-4ef7-82f7-1ffaf6e3d498",
      "code": "class Solution:\n  def oddEvenList(self, head: ListNode) -> ListNode:\n    oddHead = ListNode(0)\n    evenHead = ListNode(0)\n    odd = oddHead\n    even = evenHead\n    isOdd = True\n\n    while head:\n      if isOdd:\n        odd.next = head\n        odd = head\n      else:\n        even.next = head\n        even = head\n      head = head.next\n      isOdd = not isOdd\n\n    even.next = None\n    odd.next = evenHead.next\n    return oddHead.next",
      "title": "328. Odd Even Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b40e5a6-b4f4-4a70-b4ca-8c635f1d3023",
      "code": "class Solution:\n  def longestIncreasingPath(self, matrix: list[list[int]]) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, prev: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 0\n      if matrix[i][j] <= prev:\n        return 0\n\n      curr = matrix[i][j]\n      return 1 + max(dfs(i + 1, j, curr),\n                     dfs(i - 1, j, curr),\n                     dfs(i, j + 1, curr),\n                     dfs(i, j - 1, curr))\n\n    return max(dfs(i, j, -math.inf) for i in range(m) for j in range(n))",
      "title": "329. Longest Increasing Path in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b81b3c0-33ec-400c-829a-0feaacb96930",
      "code": "class Solution:\n  def minPatches(self, nums: list[int], n: int) -> int:\n    ans = 0\n    i = 0  # nums' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    while miss <= n:\n      if i < len(nums) and nums[i] <= miss:\n        miss += nums[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "330. Patching Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5950589-9215-47da-bdcd-ffedc6681e31",
      "code": "class Solution:\n  def isValidSerialization(self, preorder: str) -> bool:\n    degree = 1  # out-degree (children) - in-degree (parent)\n\n    for node in preorder.split(','):\n      degree -= 1\n      if degree < 0:\n        return False\n      if node != '#':\n        degree += 2\n\n    return degree == 0",
      "title": "331. Verify Preorder Serialization of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "562f96d7-2b32-4f0a-a3f1-824fee6f06ce",
      "code": "class Solution:\n  def findItinerary(self, tickets: list[list[str]]) -> list[str]:\n    ans = []\n    graph = collections.defaultdict(list)\n\n    for a, b in reversed(sorted(tickets)):\n      graph[a].append(b)\n\n    def dfs(u: str) -> None:\n      while u in graph and graph[u]:\n        dfs(graph[u].pop())\n      ans.append(u)\n\n    dfs('JFK')\n    return ans[::-1]",
      "title": "332. Reconstruct Itinerary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d4fda34-6c9c-4f02-8fac-b109a28bb657",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  mn: int  # the minimum value in the subtree\n  mx: int  # the maximum value in the subtree\n  size: int  # the size of the subtree\n\n\nclass Solution:\n  def largestBSTSubtree(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(math.inf, -math.inf, 0)\n\n      l = dfs(root.left)\n      r = dfs(root.right)\n\n      if l.mx < root.val < r.mn:\n        return T(min(l.mn, root.val), max(r.mx, root.val), 1 + l.size + r.size)\n\n      # Mark one as invalid, but still record the size of children.\n      # Return (-inf, inf) because no node will be > inf or < -inf.\n      return T(-math.inf, math.inf, max(l.size, r.size))\n\n    return dfs(root).size",
      "title": "333. Largest BST Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d377842-2c2e-4565-97c1-80eac54e4fee",
      "code": "class Solution:\n  def increasingTriplet(self, nums: list[int]) -> bool:\n    first = math.inf\n    second = math.inf\n\n    for num in nums:\n      if num <= first:\n        first = num\n      elif num <= second:  # first < num <= second\n        second = num\n      else:\n        return True  # first < second < num (third)\n\n    return False",
      "title": "334. Increasing Triplet Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71b921bb-0897-4a9a-8b71-b8029bb4d45f",
      "code": "class Solution:\n  def isSelfCrossing(self, x: list[int]) -> bool:\n    if len(x) <= 3:\n      return False\n\n    for i in range(3, len(x)):\n      if x[i - 2] <= x[i] and x[i - 1] <= x[i - 3]:\n        return True\n      if i >= 4 and x[i - 1] == x[i - 3] and x[i - 2] <= x[i] + x[i - 4]:\n        return True\n      if i >= 5 and x[i - 4] <= x[i - 2] and x[i - 2] <= x[i] + x[i - 4] and x[i - 1] <= x[i - 3] and x[i - 3] <= x[i - 1] + x[i - 5]:\n        return True\n\n    return False",
      "title": "335. Self Crossing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c71c850-2308-4543-b71c-073c1c179b1a",
      "code": "class Solution:\n  def palindromePairs(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    dict = {word[::-1]: i for i, word in enumerate(words)}\n\n    for i, word in enumerate(words):\n      if \"\" in dict and dict[\"\"] != i and word == word[::-1]:\n        ans.append([i, dict[\"\"]])\n\n      for j in range(1, len(word) + 1):\n        l = word[:j]\n        r = word[j:]\n        if l in dict and dict[l] != i and r == r[::-1]:\n          ans.append([i, dict[l]])\n        if r in dict and dict[r] != i and l == l[::-1]:\n          ans.append([dict[r], i])\n\n    return ans",
      "title": "336. Palindrome Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93c831df-d6c6-4b8d-9617-f9ce9665f316",
      "code": "class Solution:\n  def rob(self, root: TreeNode | None) -> int:\n    def robOrNot(root: TreeNode | None) -> tuple:\n      if not root:\n        return (0, 0)\n\n      robLeft, notRobLeft = robOrNot(root.left)\n      robRight, notRobRight = robOrNot(root.right)\n\n      return (root.val + notRobLeft + notRobRight,\n              max(robLeft, notRobLeft) + max(robRight, notRobRight))\n\n    return max(robOrNot(root))",
      "title": "337. House Robber III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2e2b50a-d713-4984-8e89-b06622f2d0dc",
      "code": "class Solution:\n  def countBits(self, n: int) -> list[int]:\n    # f(i) := i's number of 1s in bitmask\n    # f(i) = f(i / 2) + i % 2\n    ans = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      ans[i] = ans[i // 2] + (i & 1)\n\n    return ans",
      "title": "338. Counting Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e69ce4d0-fff0-49d6-9e67-3e57e7ccedd6",
      "code": "class Solution:\n  def depthSum(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    depth = 0\n    q = collections.deque()\n\n    def addIntegers(nestedList: list[NestedInteger]) -> None:\n      for ni in nestedList:\n        q.append(ni)\n\n    addIntegers(nestedList)\n\n    while q:\n      depth += 1\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          ans += ni.getInteger() * depth\n        else:\n          addIntegers(ni.getList())\n\n    return ans",
      "title": "339. Nested List Weight Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cba7b021-1b4c-47b8-b644-c35d4dbe8e6d",
      "code": "class Solution:\n  def lengthOfLongestSubstringKDistinct(self, s: str, k: int) -> int:\n    ans = 0\n    distinct = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        distinct += 1\n      while distinct == k + 1:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          distinct -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "340. Longest Substring with At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cc645a6-a114-4ce8-a66b-471d6645763b",
      "code": "class Solution:\n  def isPowerOfFour(self, n: int) -> bool:\n    # Why (4^n - 1) % 3 == 0?\n    # (4^n - 1) = (2^n - 1)(2^n + 1) and 2^n - 1, 2^n, 2^n + 1 are\n    # three consecutive numbers; among one of them, there must be a multiple\n    # of 3, and that can't be 2^n, so it must be either 2^n - 1 or 2^n + 1.\n    # Therefore, 4^n - 1 is a multiple of 3.\n    return n > 0 and n.bit_count() == 1 and (n - 1) % 3 == 0",
      "title": "342. Power of Four",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "489c4657-3430-4c5c-91e7-8d7d5b347032",
      "code": "class Solution:\n  def integerBreak(self, n: int) -> int:\n    # If an optimal product contains a factor f >= 4, then we can replace it\n    # with 2 and f - 2 without losing optimality. As 2(f - 2) = 2f - 4 >= f,\n    # we never need a factor >= 4, meaning we only need factors 1, 2, and 3\n    # (and 1 is wasteful).\n    # Also, 3 * 3 is better than 2 * 2 * 2, so we never use 2 more than twice.\n    if n == 2:  # 1 * 1\n      return 1\n    if n == 3:  # 1 * 2\n      return 2\n\n    ans = 1\n\n    while n > 4:\n      n -= 3\n      ans *= 3\n    ans *= n\n\n    return ans",
      "title": "343. Integer Break",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2ec2725-40b5-4039-a76a-83a269ba609e",
      "code": "class Solution:\n  def reverseString(self, s: list[str]) -> None:\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      s[l], s[r] = s[r], s[l]\n      l += 1\n      r -= 1",
      "title": "344. Reverse String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96c18811-591a-4b3a-b715-4d76ed72f300",
      "code": "class Solution:\n  def reverseVowels(self, s: str) -> str:\n    chars = list(s)\n    VOWELS = 'aeiouAEIOU'\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      while l < r and chars[l] not in VOWELS:\n        l += 1\n      while l < r and chars[r] not in VOWELS:\n        r -= 1\n      chars[l], chars[r] = chars[r], chars[l]\n      l += 1\n      r -= 1\n\n    return ''.join(chars)",
      "title": "345. Reverse Vowels of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "820e2ca7-6d44-4c8f-8c94-c8e1c68bd6df",
      "code": "class Solution:\n  def topKFrequent(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    bucket = [[] for _ in range(len(nums) + 1)]\n\n    for num, freq in collections.Counter(nums).items():\n      bucket[freq].append(num)\n\n    for b in reversed(bucket):\n      ans += b\n      if len(ans) == k:\n        return ans",
      "title": "347. Top K Frequent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b97d8eb-ca9d-4e94-9bfd-ab626a60e316",
      "code": "class Solution:\n  def intersection(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    ans = []\n    nums1 = set(nums1)\n\n    for num in nums2:\n      if num in nums1:\n        ans.append(num)\n        nums1.remove(num)\n\n    return ans",
      "title": "349. Intersection of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffbe5d21-9dfc-4696-948b-8b79b53ee21a",
      "code": "class Solution:\n  def intersect(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    if len(nums1) > len(nums2):\n      return self.intersect(nums2, nums1)\n\n    ans = []\n    count = collections.Counter(nums1)\n\n    for num in nums2:\n      if count[num] > 0:\n        ans.append(num)\n        count[num] -= 1\n\n    return ans",
      "title": "350. Intersection of Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "338b6fd8-0d58-4d28-b635-e1779c032cd9",
      "code": "class Solution:\n  def numberOfPatterns(self, m: int, n: int) -> int:\n    seen = set()\n    accross = [[0] * 10 for _ in range(10)]\n\n    accross[1][3] = accross[3][1] = 2\n    accross[1][7] = accross[7][1] = 4\n    accross[3][9] = accross[9][3] = 6\n    accross[7][9] = accross[9][7] = 8\n    accross[1][9] = accross[9][1] = accross[2][8] = accross[8][2] = \\\n        accross[3][7] = accross[7][3] = accross[4][6] = accross[6][4] = 5\n\n    def dfs(u: int, depth: int) -> int:\n      if depth > n:\n        return 0\n\n      seen.add(u)\n      ans = 1 if depth >= m else 0\n\n      for v in range(1, 10):\n        if v == u or v in seen:\n          continue\n        accrossed = accross[u][v]\n        if not accrossed or accrossed in seen:\n          ans += dfs(v, depth + 1)\n\n      seen.remove(u)\n      return ans\n\n    # 1, 3, 7, 9 are symmetric\n    # 2, 4, 6, 8 are symmetric\n    return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1)",
      "title": "351. Android Unlock Patterns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5d3d296-b44c-4900-85c9-ccfdeb4505b3",
      "code": "class Solution:\n  def maxEnvelopes(self, envelopes: list[list[int]]) -> int:\n    envelopes.sort(key=lambda x: (x[0], -x[1]))\n    return self._lengthOfLIS(envelopes)\n\n  def _lengthOfLIS(self, envelopes: list[list[int]]) -> int:\n    # tails[i] := the minimum tails of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for _, h in envelopes:\n      if not tails or h > tails[-1]:\n        tails.append(h)\n      else:\n        tails[bisect.bisect_left(tails, h)] = h\n\n    return len(tails)",
      "title": "354. Russian Doll Envelopes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91b7e9c5-55fb-4b3a-a650-38050fe44901",
      "code": "class Solution:\n  def isReflected(self, points: list[list[int]]) -> bool:\n    minX = math.inf\n    maxX = -math.inf\n    seen = set()\n\n    for x, y in points:\n      minX = min(minX, x)\n      maxX = max(maxX, x)\n      seen.add((x, y))\n\n    summ = minX + maxX\n    # (leftX + rightX) / 2 = (minX + maxX) / 2\n    #  leftX = minX + maxX - rightX\n    # rightX = minX + maxX - leftX\n\n    return all((summ - x, y) in seen for x, y in points)",
      "title": "356. Line Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c73ea81-857a-46e5-a51f-7c56892f19eb",
      "code": "class Solution:\n  def countNumbersWithUniqueDigits(self, n: int) -> int:\n    if n == 0:\n      return 1\n\n    ans = 10\n    uniqueDigits = 9\n    availableNum = 9\n\n    while n > 1 and availableNum > 0:\n      uniqueDigits *= availableNum\n      ans += uniqueDigits\n      n -= 1\n      availableNum -= 1\n\n    return ans",
      "title": "357. Count Numbers with Unique Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79cf4d16-60df-4e7d-a5e0-7117bc49e406",
      "code": "class Solution:\n  def rearrangeString(self, s: str, k: int) -> str:\n    n = len(s)\n    ans = []\n    count = collections.Counter(s)\n    # valid[i] := the leftmost index i can appear\n    valid = collections.Counter()\n\n    def getBestLetter(index: int) -> str:\n      \"\"\"Returns the valid letter that has the most count.\"\"\"\n      maxCount = -1\n      bestLetter = '*'\n\n      for c in string.ascii_lowercase:\n        if count[c] > 0 and count[c] > maxCount and index >= valid[c]:\n          bestLetter = c\n          maxCount = count[c]\n\n      return bestLetter\n\n    for i in range(n):\n      c = getBestLetter(i)\n      if c == '*':\n        return ''\n      ans.append(c)\n      count[c] -= 1\n      valid[c] = i + k\n\n    return ''.join(ans)",
      "title": "358. Rearrange String k Distance Apart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a5f19b7-9f5b-4f55-8d01-42f568b91a32",
      "code": "class Solution:\n  def sortTransformedArray(\n      self,\n      nums: list[int],\n      a: int,\n      b: int,\n      c: int,\n  ) -> list[int]:\n    n = len(nums)\n    upward = a > 0\n    ans = [0] * n\n\n    # The concavity of f only depends on a's sign.\n    def f(x: int, a: int, b: int, c: int) -> int:\n      return (a * x + b) * x + c\n\n    quad = [f(num, a, b, c) for num in nums]\n\n    i = n - 1 if upward else 0\n    l = 0\n    r = n - 1\n    while l <= r:\n      if upward:  # is the maximum in the both ends\n        if quad[l] > quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i -= 1\n      else:  # is the minimum in the both ends\n        if quad[l] < quad[r]:\n          ans[i] = quad[l]\n          l += 1\n        else:\n          ans[i] = quad[r]\n          r -= 1\n        i += 1\n\n    return ans",
      "title": "360. Sort Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5df658b4-b61f-446a-89dd-6f16f82b43bd",
      "code": "class Solution:\n  def maxKilledEnemies(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    enemyCount = 0\n    # dp[i][j] := the maximum enemies grid[i][j] can kill\n    dp = [[0] * n for _ in range(m)]\n\n    def update(i: int, j: int) -> None:\n      nonlocal enemyCount\n      if grid[i][j] == '0':\n        dp[i][j] += enemyCount\n      elif grid[i][j] == 'E':\n        enemyCount += 1\n      else:  # grid[i][j] == 'W'\n        enemyCount = 0\n\n    # Extend the four directions, if meet 'W', need to start over from 0.\n    for i in range(m):\n      enemyCount = 0\n      for j in range(n):\n        update(i, j)\n      enemyCount = 0\n      for j in reversed(range(n)):\n        update(i, j)\n\n    for j in range(n):\n      enemyCount = 0\n      for i in range(m):\n        update(i, j)\n      enemyCount = 0\n      for i in reversed(range(m)):\n        update(i, j)\n\n    # Returns sum(map(sum, dp))\n    return max(map(max, dp))",
      "title": "361. Bomb Enemy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aabb0cf9-a6a0-47f7-b4ef-4445e160e8e7",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxSumSubmatrix(self, matrix: list[list[int]], k: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = -math.inf\n\n    for baseCol in range(n):\n      # sums[i] := sum(matrix[i][baseCol..j])\n      sums = [0] * m\n      for j in range(baseCol, n):\n        for i in range(m):\n          sums[i] += matrix[i][j]\n        # Find the maximum sum <= k of all the subarrays.\n        accumulate = SortedList([0])\n        prefix = 0\n        for summ in sums:\n          prefix += summ\n          it = accumulate.bisect_left(prefix - k)\n          if it != len(accumulate):\n            ans = max(ans, prefix - accumulate[it])\n          accumulate.add(prefix)\n\n    return ans",
      "title": "363. Max Sum of Rectangle No Larger Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa26a9b4-23b5-4c1e-bcdf-27274dc19f54",
      "code": "class Solution:\n  def depthSumInverse(self, nestedList: list[NestedInteger]) -> int:\n    ans = 0\n    prevSum = 0\n    q = collections.deque(nestedList)\n\n    while q:\n      for _ in range(len(q)):\n        ni = q.popleft()\n        if ni.isInteger():\n          prevSum += ni.getInteger()\n        else:\n          for nextNi in ni.getList():\n            q.append(nextNi)\n      ans += prevSum\n\n    return ans",
      "title": "364. Nested List Weight Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f7145a0-56b9-4b11-8470-7dabe9bbe1c2",
      "code": "class Solution:\n  def canMeasureWater(\n      self,\n      jug1Capacity: int,\n      jug2Capacity: int,\n      targetCapacity: int,\n  ) -> bool:\n    return (targetCapacity == 0 or\n            jug1Capacity + jug2Capacity >= targetCapacity and\n            targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0)",
      "title": "365. Water and Jug Problem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88992ae2-dc0c-4058-8b51-c79c388f01e9",
      "code": "class Solution:\n  def findLeaves(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n\n    def depth(root: TreeNode | None) -> int:\n      \"\"\"Returns the depth of the root (0-indexed).\"\"\"\n      if not root:\n        return -1\n\n      l = depth(root.left)\n      r = depth(root.right)\n      h = 1 + max(l, r)\n\n      if len(ans) == h:  # Meet a leaf\n        ans.append([])\n\n      ans[h].append(root.val)\n      return h\n\n    depth(root)\n    return ans",
      "title": "366. Find Leaves of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6613ae0c-3095-41d7-8f6e-62a00f324567",
      "code": "class Solution:\n  def isPerfectSquare(self, num: int) -> bool:\n    l = bisect.bisect_left(range(num), num, key=lambda m: m * m)\n    return l**2 == num",
      "title": "367. Valid Perfect Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3dc46f8-8221-43fc-8b43-e4bd67a26fc1",
      "code": "class Solution:\n  def largestDivisibleSubset(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = []\n    count = [1] * n\n    prevIndex = [-1] * n\n    maxCount = 0\n    index = -1\n\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      for j in reversed(range(i)):\n        if num % nums[j] == 0 and count[i] < count[j] + 1:\n          count[i] = count[j] + 1\n          prevIndex[i] = j\n      if count[i] > maxCount:\n        maxCount = count[i]\n        index = i\n\n    while index != -1:\n      ans.append(nums[index])\n      index = prevIndex[index]\n\n    return ans",
      "title": "368. Largest Divisible Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "046d928a-a67d-433b-ad07-897f2f508fa0",
      "code": "class Solution:\n  def plusOne(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0)\n    curr = dummy\n    dummy.next = head\n\n    while head:\n      if head.val != 9:\n        curr = head\n      head = head.next\n    # `curr` now points to the rightmost non-9 node.\n\n    curr.val += 1\n    while curr.next:\n      curr.next.val = 0\n      curr = curr.next\n\n    return dummy.next if dummy.val == 0 else dummy",
      "title": "369. Plus One Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2531ef2-c459-4e3b-b5aa-a7dbdb1243b2",
      "code": "class Solution:\n  def getModifiedArray(\n      self,\n      length: int,\n      updates: list[list[int]],\n  ) -> list[int]:\n    line = [0] * length\n\n    for start, end, inc in updates:\n      line[start] += inc\n      if end + 1 < length:\n        line[end + 1] -= inc\n\n    return itertools.accumulate(line)",
      "title": "370. Range Addition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30bf6792-c60e-4c6c-b60c-9a2424e3f5bb",
      "code": "class Solution:\n  def getSum(self, a: int, b: int) -> int:\n    mask = 0xFFFFFFFF\n    MAX = 2000\n\n    while b != 0:\n      a, b = (a ^ b) & mask, ((a & b) << 1) & mask\n\n    return a if a < MAX else ~(a ^ mask)",
      "title": "371. Sum of Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c98079a-1205-41be-904e-af656eaedbf6",
      "code": "class Solution:\n  def superPow(self, a: int, b: list[int]) -> int:\n    MOD = 1337\n    ans = 1\n\n    for i in b:\n      ans = pow(ans, 10, MOD) * pow(a, i, MOD)\n\n    return ans % MOD",
      "title": "372. Super Pow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a55f5c2-1b47-4b2e-aad1-61a22d2550bd",
      "code": "class Solution:\n  def kSmallestPairs(self, nums1: list[int],\n                     nums2: list[int],\n                     k: int) -> list[list[int]]:\n    minHeap = []\n\n    for i in range(min(k, len(nums1))):\n      heapq.heappush(minHeap, (nums1[i] + nums2[0], i, 0))\n\n    ans = []\n    while minHeap and len(ans) < k:\n      _, i, j = heapq.heappop(minHeap)\n      ans.append([nums1[i], nums2[j]])\n      if j + 1 < len(nums2):\n        heapq.heappush(minHeap, (nums1[i] + nums2[j + 1], i, j + 1))\n\n    return ans",
      "title": "373. Find K Pairs with Smallest Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00a31bac-0713-4acd-a07e-1a4027d88072",
      "code": "# The guess API is already defined for you.\n# @param num, your guess\n# @return -1 if num is higher than the picked number\n#          1 if num is lower than the picked number\n#          otherwise return 0\n# def guess(num: int) -> int:\n\nclass Solution:\n  def guessNumber(self, n: int) -> int:\n    l = 1\n    r = n\n\n    # Find the first guess number that >= the target number\n    while l < r:\n      m = (l + r) // 2\n      if guess(m) <= 0:  # -1, 0\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "374. Guess Number Higher or Lower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b175bac9-df16-4e19-85ab-66e95aa951f7",
      "code": "class Solution:\n  def getMoneyAmount(self, n: int) -> int:\n    # dp[i][j] := the minimum money you need to guarantee a win of picking i..j\n    dp = [[0] * (n + 2) for _ in range(n + 2)]\n\n    for d in range(1, n + 1):\n      for i in range(1, n - d + 1):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j + 1):\n          dp[i][j] = min(dp[i][j], max(dp[i][k - 1], dp[k + 1][j]) + k)\n\n    return dp[1][n]",
      "title": "375. Guess Number Higher or Lower II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3aec9a19-53b9-484f-b317-c0b900330c98",
      "code": "class Solution:\n  def wiggleMaxLength(self, nums: list[int]) -> int:\n    increasing = 1\n    decreasing = 1\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing = decreasing + 1\n      elif b < a:\n        decreasing = increasing + 1\n\n    return max(increasing, decreasing)",
      "title": "376. Wiggle Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef9aa8cd-8cb1-498b-9095-5a21d8492331",
      "code": "class Solution:\n  def combinationSum4(self, nums: list[int], target: int) -> int:\n    dp = [1] + [-1] * target\n\n    def dfs(target: int) -> int:\n      if target < 0:\n        return 0\n      if dp[target] != -1:\n        return dp[target]\n\n      dp[target] = sum(dfs(target - num) for num in nums)\n      return dp[target]\n\n    return dfs(target)",
      "title": "377. Combination Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8deed7e4-8b12-4c3a-83f1-346095f3fb1c",
      "code": "class Solution:\n  def kthSmallest(self, matrix: list[list[int]], k: int) -> int:\n    def numsNoGreaterThan(m: int) -> int:\n      count = 0\n      j = len(matrix[0]) - 1\n      # For each row, find the first index j s.t. row[j] <= m s.t. the number of\n      # numbers <= m for this row will be j + 1.\n      for row in matrix:\n        while j >= 0 and row[j] > m:\n          j -= 1\n        count += j + 1\n      return count\n\n    l = matrix[0][0]\n    r = matrix[-1][-1]\n    return bisect.bisect_left(range(l, r), k, key=numsNoGreaterThan) + l",
      "title": "378. Kth Smallest Element in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49da39a1-52c7-4c97-8e7d-9b12728f5388",
      "code": "# Definition for singly-linked list.\n# class ListNode:\n#   def __init__(self, val=0, next=None):\n#     self.val = val\n#     self.next = next\n\nclass Solution:\n  def __init__(self, head: ListNode | None):\n    self.head = head\n\n  def getRandom(self) -> int:\n    res = -1\n    i = 1\n    curr = self.head\n\n    while curr:\n      if random.randint(0, i - 1) == 0:\n        res = curr.val\n      curr = curr.next\n      i += 1\n\n    return res",
      "title": "382. Linked List Random Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e099a77-8d9d-4fc8-ae48-81e18c2fe209",
      "code": "class Solution:\n  def canConstruct(self, ransomNote: str, magazine: str) -> bool:\n    count1 = collections.Counter(ransomNote)\n    count2 = collections.Counter(magazine)\n    return all(count1[c] <= count2[c] for c in string.ascii_lowercase)",
      "title": "383. Ransom Note",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3578ef43-70ed-48dd-8419-c4088ab0640e",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def reset(self) -> list[int]:\n    return self.nums\n\n  def shuffle(self) -> list[int]:\n    arr = self.nums.copy()\n    for i in range(len(arr) - 1, 0, -1):\n      j = random.randint(0, i)\n      arr[i], arr[j] = arr[j], arr[i]\n    return arr",
      "title": "384. Shuffle an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26a9165c-04f8-45bd-a674-f8cf0b50e78b",
      "code": "class Solution:\n  def deserialize(self, s: str) -> NestedInteger:\n    if s[0] != '[':\n      return NestedInteger(int(s))\n\n    stack = []\n\n    for i, c in enumerate(s):\n      if c == '[':\n        stack.append(NestedInteger())\n        start = i + 1\n      elif c == ',':\n        if i > start:\n          num = int(s[start:i])\n          stack[-1].add(NestedInteger(num))\n        start = i + 1\n      elif c == ']':\n        popped = stack.pop()\n        if i > start:\n          num = int(s[start:i])\n          popped.add(NestedInteger(num))\n        if stack:\n          stack[-1].add(popped)\n        else:\n          return popped\n        start = i + 1",
      "title": "385. Mini Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f1f68a3-0c0e-48cc-b1b4-e9f2b6d79562",
      "code": "class Solution:\n  def lexicalOrder(self, n: int) -> list[int]:\n    ans = []\n    curr = 1\n\n    while len(ans) < n:\n      ans.append(curr)\n      if curr * 10 <= n:\n        curr *= 10\n      else:\n        while curr % 10 == 9 or curr == n:\n          curr //= 10\n        curr += 1\n\n    return ans",
      "title": "386. Lexicographical Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d96d4a47-1265-4e80-b49a-615df73c7421",
      "code": "class Solution:\n  def firstUniqChar(self, s: str) -> int:\n    count = collections.Counter(s)\n\n    for i, c in enumerate(s):\n      if count[c] == 1:\n        return i\n\n    return -1",
      "title": "387. First Unique Character in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e67759e8-6bdc-4fc9-a382-9c42f9c491b7",
      "code": "class Solution:\n  def lengthLongestPath(self, input: str) -> int:\n    ans = 0\n    stack = [(-1, 0)]  # placeholder\n\n    for token in input.split('\\n'):\n      depth = token.count('\\t')\n      token = token.replace('\\t', '')\n      while depth <= stack[-1][0]:\n        stack.pop()\n      if '.' in token:  # `token` is file.\n        ans = max(ans, stack[-1][1] + len(token))\n      else:  # directory + '/'\n        stack.append((depth, stack[-1][1] + len(token) + 1))\n\n    return ans",
      "title": "388. Longest Absolute File Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edd77e93-f603-4732-812a-5292a7e765d4",
      "code": "class Solution:\n  def findTheDifference(self, s: str, t: str) -> str:\n    sXors = chr(functools.reduce(operator.xor, map(ord, s), 0))\n    tXors = chr(functools.reduce(operator.xor, map(ord, t), 0))\n    return chr(ord(sXors) ^ ord(tXors))",
      "title": "389. Find the Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6e3c442-47e6-47b2-8efd-1f7699cb92e6",
      "code": "class Solution:\n  def lastRemaining(self, n: int) -> int:\n    return 1 if n == 1 else 2 * (1 + n // 2 - self.lastRemaining(n // 2))",
      "title": "390. Elimination Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ceab2674-b2f3-402b-99b1-7a376f3e2348",
      "code": "class Solution:\n  def isRectangleCover(self, rectangles: list[list[int]]) -> bool:\n    area = 0\n    x1 = math.inf\n    y1 = math.inf\n    x2 = -math.inf\n    y2 = -math.inf\n    corners: set[tuple[int, int]] = set()\n\n    for x, y, a, b in rectangles:\n      area += (a - x) * (b - y)\n      x1 = min(x1, x)\n      y1 = min(y1, y)\n      x2 = max(x2, a)\n      y2 = max(y2, b)\n\n      # the four points of the current rectangle\n      for point in [(x, y), (x, b), (a, y), (a, b)]:\n        if point in corners:\n          corners.remove(point)\n        else:\n          corners.add(point)\n\n    if len(corners) != 4:\n      return False\n    if ((x1, y1) not in corners or\n        (x1, y2) not in corners or\n        (x2, y1) not in corners or\n            (x2, y2) not in corners):\n      return False\n    return area == (x2 - x1) * (y2 - y1)",
      "title": "391. Perfect Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "086d1b0d-c22b-4d04-8bd6-9771bcc6487c",
      "code": "class Solution:\n  def isSubsequence(self, s: str, t: str) -> bool:\n    if not s:\n      return True\n\n    i = 0\n    for c in t:\n      if s[i] == c:\n        i += 1\n        if i == len(s):\n          return True\n\n    return False",
      "title": "392. Is Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "288896ae-ae85-4cfb-961b-00ec92daefcc",
      "code": "class Solution:\n  def validUtf8(self, data: list[int]) -> bool:\n    followedBytes = 0\n\n    for d in data:\n      if followedBytes == 0:\n        if (d >> 3) == 0b11110:\n          followedBytes = 3\n        elif (d >> 4) == 0b1110:\n          followedBytes = 2\n        elif (d >> 5) == 0b110:\n          followedBytes = 1\n        elif (d >> 7) == 0b0:\n          followedBytes = 0\n        else:\n          return False\n      else:\n        if (d >> 6) != 0b10:\n          return False\n        followedBytes -= 1\n\n    return followedBytes == 0",
      "title": "393. UTF-8 Validation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "feac4209-c03a-42d0-868b-5fcc3cbb1f5c",
      "code": "class Solution:\n  def decodeString(self, s: str) -> str:\n    ans = ''\n\n    while self.i < len(s) and s[self.i] != ']':\n      if s[self.i].isdigit():\n        k = 0\n        while self.i < len(s) and s[self.i].isdigit():\n          k = k * 10 + int(s[self.i])\n          self.i += 1\n        self.i += 1  # '['\n        decodedString = self.decodeString(s)\n        self.i += 1  # ']'\n        ans += k * decodedString\n      else:\n        ans += s[self.i]\n        self.i += 1\n\n    return ans\n\n  i = 0",
      "title": "394. Decode String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cd3632e-9208-4b88-906e-e471605b2548",
      "code": "class Solution:\n  def longestSubstring(self, s: str, k: int) -> int:\n    def longestSubstringWithNUniqueLetters(n: int) -> int:\n      res = 0\n      uniqueLetters = 0  # the number of unique letters\n      lettersHavingKFreq = 0  # the number of letters having frequency >= k\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == k:\n          lettersHavingKFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == k:\n            lettersHavingKFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having frequency >= k are equal to n, this is a valid window.\n        if lettersHavingKFreq == n:  # Implicit: uniqueLetters == n\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(longestSubstringWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "395. Longest Substring with At Least K Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d967da16-3ea8-4d38-bcb5-ece58939fbd2",
      "code": "class Solution:\n  def maxRotateFunction(self, nums: list[int]) -> int:\n    f = sum(i * num for i, num in enumerate(nums))\n    ans = f\n    summ = sum(nums)\n\n    for a in reversed(nums):\n      f += summ - len(nums) * a\n      ans = max(ans, f)\n\n    return ans",
      "title": "396. Rotate Function",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1fe215d-db2a-43a1-b10a-6de4b711c5cc",
      "code": "class Solution:\n  def integerReplacement(self, n: int) -> int:\n    ans = 0\n\n    while n > 1:\n      if n % 2 == 0:  # `n` ends in 0.\n        n >>= 1\n      elif n == 3 or (n >> 1 & 1) == 0:  # `n` = 3 or ends in 0b01.\n        n -= 1\n      else:  # `n` ends in 0b11.\n        n += 1\n      ans += 1\n\n    return ans",
      "title": "397. Integer Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2edd60f0-b09a-4ad4-bdce-09ecd841ec01",
      "code": "class Solution:\n  def __init__(self, nums: list[int]):\n    self.nums = nums\n\n  def pick(self, target: int) -> int:\n    ans = -1\n    rng = 0\n    for i, num in enumerate(self.nums):\n      if num == target:\n        rng += 1\n        if random.randint(0, rng - 1) == 0:\n          ans = i\n    return ans",
      "title": "398. Random Pick Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "594b1bc2-0ea1-4464-bc13-e616edab9f77",
      "code": "class Solution:\n  def calcEquation(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n      queries: list[list[str]],\n  ) -> list[float]:\n    ans = []\n    # graph[A][B] := A / B\n    graph = collections.defaultdict(dict)\n\n    for (A, B), value in zip(equations, values):\n      graph[A][B] = value\n      graph[B][A] = 1 / value\n\n    def devide(A: str, C: str, seen: set[str]) -> float:\n      \"\"\"Returns A / C.\"\"\"\n      if A == C:\n        return 1.0\n\n      seen.add(A)\n\n      # value := A / B\n      for B, value in graph[A].items():\n        if B in seen:\n          continue\n        res = devide(B, C, seen)  # B / C\n        if res > 0:  # valid result\n          return value * res  # (A / B) * (B / C) = A / C\n\n      return -1.0  # invalid result\n\n    for A, C in queries:\n      if A not in graph or C not in graph:\n        ans.append(-1.0)\n      else:\n        ans.append(devide(A, C, set()))\n\n    return ans",
      "title": "399. Evaluate Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "374c5afb-b472-4797-b57b-c34e3f463ab4",
      "code": "class Solution:\n  def findNthDigit(self, n: int) -> int:\n    def getDigit(num: int, pos: int, digitSize: int):\n      if pos == 0:\n        return num % 10\n      for _ in range(digitSize - pos):\n        num //= 10\n      return num % 10\n\n    digitSize = 1\n    startNum = 1\n    count = 9\n\n    while digitSize * count < n:\n      n -= digitSize * count\n      digitSize += 1\n      startNum *= 10\n      count *= 10\n\n    targetNum = startNum + (n - 1) // digitSize\n    pos = n % digitSize\n\n    return getDigit(targetNum, pos, digitSize)",
      "title": "400. Nth Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "838bfb87-51bf-436d-8238-95bbf08d0d58",
      "code": "class Solution:\n  def readBinaryWatch(self, turnedOn: int) -> list[str]:\n    ans = []\n    hours = [1, 2, 4, 8]\n    minutes = [1, 2, 4, 8, 16, 32]\n\n    def dfs(turnedOn: int, s: int, h: int, m: int) -> None:\n      if turnedOn == 0:\n        time = str(h) + \":\" + (str(m).zfill(2))\n        ans.append(time)\n        return\n\n      for i in range(s, len(hours) + len(minutes)):\n        if i < 4 and h + hours[i] < 12:\n          dfs(turnedOn - 1, i + 1, h + hours[i], m)\n        elif i >= 4 and m + minutes[i - 4] < 60:\n          dfs(turnedOn - 1, i + 1, h, m + minutes[i - 4])\n\n    dfs(turnedOn, 0, 0, 0)\n    return ans",
      "title": "401. Binary Watch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3d92b58-b51a-4194-84a1-e6e44bd71d06",
      "code": "class Solution:\n  def removeKdigits(self, num: str, k: int) -> str:\n    if len(num) == k:\n      return '0'\n\n    ans = []\n    stack = []\n\n    for i, digit in enumerate(num):\n      while k > 0 and stack and stack[-1] > digit:\n        stack.pop()\n        k -= 1\n      stack.append(digit)\n\n    for _ in range(k):\n      stack.pop()\n\n    for c in stack:\n      if c == '0' and not ans:\n        continue\n      ans.append(c)\n\n    return ''.join(ans) if ans else '0'",
      "title": "402. Remove K Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b3e8022-7896-48fe-9d62-feb69f285a4c",
      "code": "class Solution:\n  def canCross(self, stones: list[int]) -> bool:\n    n = len(stones)\n    # dp[i][j] := True if a frog can make a size j jump to stones[i]\n    dp = [[False] * (n + 1) for _ in range(n)]\n    dp[0][0] = True\n\n    for i in range(1, n):\n      for j in range(i):\n        k = stones[i] - stones[j]\n        if k > n:\n          continue\n        for x in (k - 1, k, k + 1):\n          if 0 <= x <= n:\n            dp[i][k] |= dp[j][x]\n\n    return any(dp[-1])",
      "title": "403. Frog Jump",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2015f739-8f97-4db2-b726-caa1048b5903",
      "code": "class Solution:\n  def sumOfLeftLeaves(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n\n    ans = 0\n    stack = [root]\n\n    while stack:\n      root = stack.pop()\n      if root.left:\n        if not root.left.left and not root.left.right:\n          ans += root.left.val\n        else:\n          stack.append(root.left)\n      if root.right:\n        stack.append(root.right)\n\n    return ans",
      "title": "404. Sum of Left Leaves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a58b2b62-f102-43f0-9dae-21e40dcee497",
      "code": "class Solution:\n  def toHex(self, num: int) -> str:\n    if num == 0:\n      return '0'\n\n    hex = '0123456789abcdef'\n    ans = []\n\n    # Handling negative numbers by using 32-bit unsigned representation Python's\n    # bitwise operation works on signed numbers, so we convert to 32-bit\n    # unsigned for negative numbers.\n    if num < 0:\n      num += 2**32\n\n    while num > 0:\n      ans.append(hex[num & 0xF])\n      num >>= 4\n\n    return ''.join(reversed(ans))",
      "title": "405. Convert a Number to Hexadecimal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be880d32-6043-453a-9bbe-a8e4f1cf2711",
      "code": "class Solution:\n  def reconstructQueue(self, people: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    people.sort(key=lambda x: (-x[0], x[1]))\n\n    for person in people:\n      ans.insert(person[1], person)\n\n    return ans",
      "title": "406. Queue Reconstruction by Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b91fceaf-4a52-4275-b41e-2dec71024956",
      "code": "class Solution:\n  def trapRainWater(self, heightMap: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heightMap)\n    n = len(heightMap[0])\n    ans = 0\n    minHeap = []\n    seen = set()\n\n    for i in range(m):\n      heapq.heappush(minHeap, (heightMap[i][0], i, 0))\n      heapq.heappush(minHeap, (heightMap[i][n - 1], i, n - 1))\n      seen.add((i, 0))\n      seen.add((i, n - 1))\n\n    for j in range(1, n - 1):\n      heapq.heappush(minHeap, (heightMap[0][j], 0, j))\n      heapq.heappush(minHeap, (heightMap[m - 1][j], m - 1, j))\n      seen.add((0, j))\n      seen.add((m - 1, j))\n\n    while minHeap:\n      h, i, j = heapq.heappop(minHeap)\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        if heightMap[x][y] < h:\n          ans += h - heightMap[x][y]\n          # Fill water in grid[x][y].\n          heapq.heappush(minHeap, (h, x, y))\n        else:\n          heapq.heappush(minHeap, (heightMap[x][y], x, y))\n        seen.add((x, y))\n\n    return ans",
      "title": "407. Trapping Rain Water II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c90ef56c-299e-417f-8cf1-70837dea57ac",
      "code": "class Solution:\n  def validWordAbbreviation(self, word: str, abbr: str) -> bool:\n    i = 0  # word's index\n    j = 0  # abbr's index\n\n    while i < len(word) and j < len(abbr):\n      if word[i] == abbr[j]:\n        i += 1\n        j += 1\n        continue\n      if not abbr[j].isdigit() or abbr[j] == '0':\n        return False\n      num = 0\n      while j < len(abbr) and abbr[j].isdigit():\n        num = num * 10 + int(abbr[j])\n        j += 1\n      i += num\n\n    return i == len(word) and j == len(abbr)",
      "title": "408. Valid Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b73560c-2771-4013-905b-221e7094714a",
      "code": "class Solution:\n  def longestPalindrome(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n\n    for c in count.values():\n      ans += c if c % 2 == 0 else c - 1\n\n    hasOddCount = any(c % 2 == 1 for c in count.values())\n    return ans + hasOddCount",
      "title": "409. Longest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "452f059b-7978-4774-9206-950f4298a34b",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # dp[i][k] := the minimum of the maximum sum to split the first i numbers\n    # into k groups\n    dp = [[math.inf] * (k + 1) for _ in range(n + 1)]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n + 1):\n      dp[i][1] = prefix[i]\n\n    for l in range(2, k + 1):\n      for i in range(l, n + 1):\n        for j in range(l - 1, i):\n          dp[i][l] = min(dp[i][l], max(dp[j][l - 1], prefix[i] - prefix[j]))\n\n    return dp[n][k]",
      "title": "410. Split Array Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71005253-1553-400b-8e17-fb11fc08a715",
      "code": "class Solution:\n  def splitArray(self, nums: list[int], k: int) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum of the maximum sum to split the first i numbers into\n      k groups.\n      \"\"\"\n      if k == 1:\n        return prefix[i]\n      return min(max(dp(j, k - 1), prefix[i] - prefix[j])\n                 for j in range(k - 1, i))\n\n    return dp(len(nums), k)",
      "title": "410. Split Array Largest Sum_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85e1748e-54bf-4df5-ac23-b9dfabb1b449",
      "code": "class Solution:\n  def minAbbreviation(self, target: str, dictionary: list[str]) -> str:\n    m = len(target)\n\n    def getMask(word: str) -> int:\n      # mask[i] = 0 := target[i] == word[i]\n      # mask[i] = 1 := target[i] != word[i]\n      # e.g. target = \"apple\"\n      #        word = \"blade\"\n      #        mask =  11110\n      mask = 0\n      for i, c in enumerate(word):\n        if c != target[i]:\n          mask |= 1 << m - 1 - i\n      return mask\n\n    masks = [getMask(word) for word in dictionary if len(word) == m]\n    if not masks:\n      return str(m)\n\n    abbrs = []\n\n    def getAbbr(cand: int) -> str:\n      abbr = []\n      replacedCount = 0\n      for i, c in enumerate(target):\n        if cand >> m - 1 - i & 1:\n          # If cand[i] = 1, `abbr` should show the original character.\n          if replacedCount:\n            abbr += str(replacedCount)\n          abbr.append(c)\n          replacedCount = 0\n        else:\n          # If cand[i] = 0, `abbr` can be replaced.\n          replacedCount += 1\n      if replacedCount:\n        abbr.append(str(replacedCount))\n      return ''.join(abbr)\n\n    # all the candidate representation of the target\n    for cand in range(2**m):\n      # All the masks have at lease one bit different from the candidate.\n      if all(cand & mask for mask in masks):\n        abbr = getAbbr(cand)\n        abbrs.append(abbr)\n\n    def getAbbrLen(abbr: str) -> int:\n      abbrLen = 0\n      i = 0\n      j = 0\n      while i < len(abbr):\n        if abbr[j].isalpha():\n          j += 1\n        else:\n          while j < len(abbr) and abbr[j].isdigit():\n            j += 1\n        abbrLen += 1\n        i = j\n      return abbrLen\n\n    return min(abbrs, key=lambda x: getAbbrLen(x))",
      "title": "411. Minimum Unique Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3aa24f8-40ef-4ca9-af7c-55fcee300372",
      "code": "class Solution:\n  def fizzBuzz(self, n: int) -> list[str]:\n    d = {3: 'Fizz', 5: 'Buzz'}\n    return [''.join([d[k] for k in d if i % k == 0]) or str(i) for i in range(1, n + 1)]",
      "title": "412. Fizz Buzz",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d2f6f9f-5d0b-406a-8991-17b8de9e05a2",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return 0\n\n    dp = [0] * n  # dp[i] := the number of arithmetic slices ending in index i\n\n    for i in range(2, len(nums)):\n      if nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]:\n        dp[i] = dp[i - 1] + 1\n\n    return sum(dp)",
      "title": "413. Arithmetic Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34e4f9db-6ef2-4de0-bbe7-cf47e05f6a1b",
      "code": "class Solution:\n  def thirdMax(self, nums: list[int]) -> int:\n    max1 = -math.inf  # the maximum\n    max2 = -math.inf  # the second maximum\n    max3 = -math.inf  # the third maximum\n\n    for num in nums:\n      if num > max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif max1 > num and num > max2:\n        max3 = max2\n        max2 = num\n      elif max2 > num and num > max3:\n        max3 = num\n\n    return max1 if max3 == -math.inf else max3",
      "title": "414. Third Maximum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "622fc629-1f86-4648-96de-d3c94bdd2dd9",
      "code": "class Solution:\n  def addStrings(self, num1: str, num2: str) -> str:\n    ans = []\n    carry = 0\n    i = len(num1) - 1\n    j = len(num2) - 1\n\n    while i >= 0 or j >= 0 or carry:\n      if i >= 0:\n        carry += int(num1[i])\n      if j >= 0:\n        carry += int(num2[j])\n      ans.append(str(carry % 10))\n      carry //= 10\n      i -= 1\n      j -= 1\n\n    return ''.join(reversed(ans))",
      "title": "415. Add Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa6d8bc3-22fb-4177-ae9b-d61e60c033d6",
      "code": "class Solution:\n  def canPartition(self, nums: list[int]) -> bool:\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return False\n    return self.knapsack_(nums, summ // 2)\n\n  def knapsack_(self, nums: list[int], subsetSum: int) -> bool:\n    n = len(nums)\n    # dp[i][j] := True if j can be formed by nums[0..i)\n    dp = [[False] * (subsetSum + 1) for _ in range(n + 1)]\n    dp[0][0] = True\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(subsetSum + 1):\n        if j < num:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = dp[i - 1][j] or dp[i - 1][j - num]\n\n    return dp[n][subsetSum]",
      "title": "416. Partition Equal Subset Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e91c70fd-782d-4722-9295-bb437cde10a9",
      "code": "class Solution:\n  def pacificAtlantic(self, heights: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    qP = collections.deque()\n    qA = collections.deque()\n    seenP = [[False] * n for _ in range(m)]\n    seenA = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      qP.append((i, 0))\n      qA.append((i, n - 1))\n      seenP[i][0] = True\n      seenA[i][n - 1] = True\n\n    for j in range(n):\n      qP.append((0, j))\n      qA.append((m - 1, j))\n      seenP[0][j] = True\n      seenA[m - 1][j] = True\n\n    def bfs(q: deque, seen: list[list[bool]]):\n      while q:\n        i, j = q.popleft()\n        h = heights[i][j]\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if seen[x][y] or heights[x][y] < h:\n            continue\n          q.append((x, y))\n          seen[x][y] = True\n\n    bfs(qP, seenP)\n    bfs(qA, seenA)\n\n    return [[i, j] for i in range(m) for j in range(n) if seenP[i][j] and seenA[i][j]]",
      "title": "417. Pacific Atlantic Water Flow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5a76ce1-b048-4f00-a132-24f0025d36e2",
      "code": "class Solution:\n  def wordsTyping(self, sentence: list[str], rows: int, cols: int) -> int:\n    combined = ' '.join(sentence) + ' '\n    n = len(combined)\n    i = 0\n\n    for _ in range(rows):\n      i += cols\n      if combined[i % n] == ' ':\n        i += 1\n      else:\n        while i > 0 and combined[(i - 1) % n] != ' ':\n          i -= 1\n\n    return i // n",
      "title": "418. Sentence Screen Fitting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "459af549-a29d-4c24-9d22-da02e8d7c07b",
      "code": "class Solution:\n  def countBattleships(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i, row in enumerate(board):\n      for j, cell in enumerate(row):\n        if cell == '.':\n          continue\n        if i > 0 and board[i - 1][j] == 'X':\n          continue\n        if j > 0 and board[i][j - 1] == 'X':\n          continue\n        ans += 1\n\n    return ans",
      "title": "419. Battleships in a Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19b60506-4e2a-4383-b91d-307b4eb57630",
      "code": "class Solution:\n  def strongPasswordChecker(self, password: str) -> int:\n    n = len(password)\n    missing = self._getMissing(password)\n    # the number of replacements to deal with 3 repeating characters\n    replaces = 0\n    # the number of sequences that can be substituted with 1 deletions,\n    # (3k)-seqs\n    oneSeq = 0\n    # the number of sequences that can be substituted with 2 deletions,\n    # (3k + 1)-seqs\n    twoSeq = 0\n\n    i = 2\n    while i < n:\n      if password[i] == password[i - 1] and password[i - 1] == password[i - 2]:\n        length = 2  # the length of the repeating password\n        while i < n and password[i] == password[i - 1]:\n          length += 1\n          i += 1\n        replaces += length // 3  # 'aaaaaaa' -> 'aaxaaxa'\n        if length % 3 == 0:\n          oneSeq += 1\n        if length % 3 == 1:\n          twoSeq += 1\n      else:\n        i += 1\n\n    if n < 6:\n      return max(6 - n, missing)\n    if n <= 20:\n      return max(replaces, missing)\n\n    deletes = n - 20\n    # Each replacement in (3k)-seqs can be substituted with 1 deletions.\n    replaces -= min(oneSeq, deletes)\n    # Each replacement in (3k + 1)-seqs can be substituted with 2 deletions.\n    replaces -= min(max(deletes - oneSeq, 0), twoSeq * 2) // 2\n    # Each replacement in other seqs can be substituted with 3 deletions.\n    replaces -= max(deletes - oneSeq - twoSeq * 2, 0) // 3\n    return deletes + max(replaces, missing)\n\n  def _getMissing(self, password: str) -> int:\n    return (3\n            - any(c.isupper() for c in password)\n            - any(c.islower() for c in password)\n            - any(c.isdigit() for c in password))",
      "title": "420. Strong Password Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f459d55-3805-439e-ae53-69e9211b8cc3",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def findMaximumXOR(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    if maxNum == 0:\n      return 0\n    maxBit = int(math.log2(maxNum))\n    ans = 0\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      ans = max(ans, bitTrie.getMaxXor(num))\n      bitTrie.insert(num)\n\n    return ans",
      "title": "421. Maximum XOR of Two Numbers in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89d4bc1f-9351-4f30-a9b1-1a0f79d25431",
      "code": "class Solution:\n  def validWordSquare(self, words: list[str]) -> bool:\n    for i, word in enumerate(words):\n      for j, c in enumerate(word):\n        if len(words) <= j or len(words[j]) <= i:  # out-of-bounds\n          return False\n        if c != words[j][i]:\n          return False\n    return True",
      "title": "422. Valid Word Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0be5fdd6-5cd2-4c93-a6d8-ab2e147b7ee0",
      "code": "class Solution:\n  def originalDigits(self, s: str) -> str:\n    count = [0] * 10\n\n    for c in s:\n      if c == 'z':\n        count[0] += 1\n      if c == 'o':\n        count[1] += 1\n      if c == 'w':\n        count[2] += 1\n      if c == 'h':\n        count[3] += 1\n      if c == 'u':\n        count[4] += 1\n      if c == 'f':\n        count[5] += 1\n      if c == 'x':\n        count[6] += 1\n      if c == 's':\n        count[7] += 1\n      if c == 'g':\n        count[8] += 1\n      if c == 'i':\n        count[9] += 1\n\n    count[1] -= count[0] + count[2] + count[4]\n    count[3] -= count[8]\n    count[5] -= count[4]\n    count[7] -= count[6]\n    count[9] -= count[5] + count[6] + count[8]\n    return ''.join(chr(i + ord('0')) for i, c in enumerate(count)\n                   for _ in range(c))",
      "title": "423. Reconstruct Original Digits from English",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae5a3d5-7a84-4a7e-9b6f-799bd0875ec1",
      "code": "class Solution:\n  def characterReplacement(self, s: str, k: int) -> int:\n    maxCount = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      maxCount = max(maxCount, count[c])\n      while maxCount + k < r - l + 1:\n        count[s[l]] -= 1\n        l += 1\n\n    return r - l + 1",
      "title": "424. Longest Repeating Character Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d12ec09d-94ee-48d7-9b3a-6e5bff246fef",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.startsWith: list[str] = []\n\n\nclass Trie:\n  def __init__(self, words: list[str]):\n    self.root = TrieNode()\n    for word in words:\n      self._insert(word)\n\n  def findBy(self, prefix: str) -> list[str]:\n    node = self.root\n    for c in prefix:\n      if c not in node.children:\n        return []\n      node = node.children[c]\n    return node.startsWith\n\n  def _insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n      node.startsWith.append(word)\n\n\nclass Solution:\n  def wordSquares(self, words: list[str]) -> list[list[str]]:\n    if not words:\n      return []\n\n    n = len(words[0])\n    ans = []\n    path = []\n    trie = Trie(words)\n\n    for word in words:\n      path.append(word)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n    return ans\n\n  def _dfs(self, trie: Trie, n: int, path: list[str], ans: list[list[str]]):\n    if len(path) == n:\n      ans.append(path.copy())\n      return\n\n    prefix = self._getPrefix(path)\n\n    for s in trie.findBy(prefix):\n      path.append(s)\n      self._dfs(trie, n, path, ans)\n      path.pop()\n\n  def _getPrefix(self, path: list[str]) -> str:\n    \"\"\"\n    e.g. path = [\"wall\",\n                 \"area\"]\n       prefix =  \"le..\"\n    \"\"\"\n    prefix = []\n    index = len(path)\n    for s in path:\n      prefix.append(s[index])\n    return ''.join(prefix)",
      "title": "425. Word Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c83db9d6-5a45-4526-b32e-a9e234ace293",
      "code": "class Solution:\n  def treeToDoublyList(self, root: 'Node | None') -> 'Node | None':\n    if not root:\n      return None\n    leftHead = self.treeToDoublyList(root.left)\n    rightHead = self.treeToDoublyList(root.right)\n    root.left = root\n    root.right = root\n    return self._connect(self._connect(leftHead, root), rightHead)\n\n  def _connect(self, node1: 'Node | None', node2: 'Node | None') -> 'Node | None':\n    if not node1:\n      return node2\n    if not node2:\n      return node1\n\n    tail1 = node1.left\n    tail2 = node2.left\n\n    # Connect node1's tail with node2.\n    tail1.right = node2\n    node2.left = tail1\n\n    # Connect node2's tail with node1.\n    tail2.right = node1\n    node1.left = tail2\n    return node1",
      "title": "426. Convert Binary Search Tree to Sorted Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d41526ed-56c1-4502-8333-1901d0806083",
      "code": "class Solution:\n  def construct(self, grid: list[list[int]]) -> 'Node':\n    return self._helper(grid, 0, 0, len(grid))\n\n  def _helper(self, grid: list[list[int]], i: int, j: int, w: int) -> 'Node':\n    if self._allSame(grid, i, j, w):\n      return Node(grid[i][j] == 1, True)\n    half = w // 2\n    return Node(True, False,\n                self._helper(grid, i, j, half),\n                self._helper(grid, i, j + half, half),\n                self._helper(grid, i + half, j, half),\n                self._helper(grid, i + half, j + half, half))\n\n  def _allSame(self, grid: list[list[int]], i: int, j: int, w: int) -> bool:\n    return all(grid[x][y] == grid[i][j]\n               for x in range(i, i + w)\n               for y in range(j, j + w))",
      "title": "427. Construct Quad Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c42598e1-d6dc-4a42-ac22-ab794755519a",
      "code": "class Solution:\n  def levelOrder(self, root: 'Node') -> list[list[int]]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      currLevel = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        currLevel.append(node.val)\n        for child in node.children:\n          q.append(child)\n      ans.append(currLevel)\n\n    return ans",
      "title": "429. N-ary Tree Level Order Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b5b05b3-3ba8-4fcf-b62f-4047e0de14c6",
      "code": "class Solution:\n  def flatten(self, head: 'Node') -> 'Node':\n    curr = head\n\n    while curr:\n      if curr.child:\n        cachedNext = curr.next\n        curr.next = curr.child\n        curr.child.prev = curr\n        curr.child = None\n        tail = curr.next\n        while tail.next:\n          tail = tail.next\n        tail.next = cachedNext\n        if cachedNext:\n          cachedNext.prev = tail\n      curr = curr.next\n\n    return head",
      "title": "430. Flatten a Multilevel Doubly Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "489bf809-f499-49d8-a826-3ab0d50c6996",
      "code": "class Solution:\n  def minMutation(self, startGene: str, endGene: str, bank: list[str]) -> int:\n    bankSet = set(bank)\n    if endGene not in bankSet:\n      return -1\n\n    GENES = 'ACGT'\n    q = collections.deque([startGene])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        wordList = list(q.popleft())\n        for j, cache in enumerate(wordList):\n          for c in GENES:\n            wordList[j] = c\n            word = ''.join(wordList)\n            if word == endGene:\n              return step\n            if word in bankSet:\n              bankSet.remove(word)\n              q.append(word)\n          wordList[j] = cache\n      step += 1\n\n    return -1",
      "title": "433. Minimum Genetic Mutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baa9cb38-2868-4960-9b7a-617094227309",
      "code": "class Solution:\n  def countSegments(self, s: str) -> int:\n    return len(s.split())",
      "title": "434. Number of Segments in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "028bf220-3ffe-4b9a-8270-7b1341bf1eb1",
      "code": "class Solution:\n  def eraseOverlapIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    currentEnd = -math.inf\n\n    for interval in sorted(intervals, key=lambda x: x[1]):\n      if interval[0] >= currentEnd:\n        currentEnd = interval[1]\n      else:\n        ans += 1\n\n    return ans",
      "title": "435. Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49a94dac-100f-4a92-ac93-26ab903af3c4",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def findRightInterval(self, intervals: list[list[int]]) -> list[int]:\n    ans = []\n    startToIndex = SortedDict()\n\n    for i, (start, end) in enumerate(intervals):\n      startToIndex[start] = i\n\n    for start, end in intervals:\n      i = startToIndex.bisect_left(end)\n      ans.append(-1 if i == len(startToIndex) else startToIndex.peekitem(i)[1])\n\n    return ans",
      "title": "436. Find Right Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0625b827-0da7-4f9b-a68d-d5bb999c0fc0",
      "code": "class Solution:\n  def pathSum(self, root: TreeNode | None, summ: int) -> int:\n    if not root:\n      return 0\n\n    def dfs(root: TreeNode, summ: int) -> int:\n      if not root:\n        return 0\n      return (int(summ == root.val) +\n              dfs(root.left, summ - root.val) +\n              dfs(root.right, summ - root.val))\n\n    return (dfs(root, summ) +\n            self.pathSum(root.left, summ) +\n            self.pathSum(root.right, summ))",
      "title": "437. Path Sum III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b5d065b-af86-48b1-9148-f432553cbb3d",
      "code": "class Solution:\n  def findAnagrams(self, s: str, p: str) -> list[int]:\n    ans = []\n    count = collections.Counter(p)\n    required = len(p)\n\n    for r, c in enumerate(s):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(p):\n        count[s[r - len(p)]] += 1\n        if count[s[r - len(p)]] > 0:\n          required += 1\n      if required == 0:\n        ans.append(r - len(p) + 1)\n\n    return ans",
      "title": "438. Find All Anagrams in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de43dbe6-63d4-4f5d-ae01-161754086f90",
      "code": "class Solution:\n  def parseTernary(self, expression: str) -> str:\n    c = expression[self.i]\n\n    if self.i + 1 == len(expression) or expression[self.i + 1] == ':':\n      self.i += 2\n      return str(c)\n\n    self.i += 2\n    first = self.parseTernary(expression)\n    second = self.parseTernary(expression)\n\n    return first if c == 'T' else second\n\n  i = 0",
      "title": "439. Ternary Expression Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26ff2383-65bd-4801-ab73-2c730ff0e23f",
      "code": "class Solution:\n  def findKthNumber(self, n: int, k: int) -> int:\n    ans = 1\n\n    i = 1\n    while i < k:\n      gap = self._getGap(ans, ans + 1, n)\n      if i + gap <= k:\n        i += gap\n        ans += 1\n      else:\n        i += 1\n        ans *= 10\n\n    return ans\n\n  def _getGap(self, a: int, b: int, n: int) -> int:\n    gap = 0\n    while a <= n:\n      gap += min(n + 1, b) - a\n      a *= 10\n      b *= 10\n    return gap",
      "title": "440. K-th Smallest in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83f615c1-e26c-4873-83af-b363c66a9e47",
      "code": "class Solution:\n  def arrangeCoins(self, n: int) -> int:\n    return int((-1 + math.sqrt(8 * n + 1)) // 2)",
      "title": "441. Arranging Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ce9b60-8b8e-43ba-926c-4e8cb25b95b8",
      "code": "class Solution:\n  def findDuplicates(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      nums[abs(num) - 1] *= -1\n      if nums[abs(num) - 1] > 0:\n        ans.append(abs(num))\n\n    return ans",
      "title": "442. Find All Duplicates in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "099f3bde-c636-4357-8d8d-44ad9e252d66",
      "code": "class Solution:\n  def compress(self, chars: list[str]) -> int:\n    ans = 0\n    i = 0\n\n    while i < len(chars):\n      letter = chars[i]\n      count = 0\n      while i < len(chars) and chars[i] == letter:\n        count += 1\n        i += 1\n      chars[ans] = letter\n      ans += 1\n      if count > 1:\n        for c in str(count):\n          chars[ans] = c\n          ans += 1\n\n    return ans",
      "title": "443. String Compression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa32e1b8-c4fd-435b-8cfe-1b664a7fa51c",
      "code": "class Solution:\n  def sequenceReconstruction(\n      self,\n      org: list[int],\n      seqs: list[list[int]],\n  ) -> bool:\n    if not seqs:\n      return False\n\n    n = len(org)\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for seq in seqs:\n      if len(seq) == 1 and seq[0] < 1 or seq[0] > n:\n        return False\n      for u, v in zip(seq, seq[1:]):\n        if u < 1 or u > n or v < 1 or v > n:\n          return False\n        graph[u - 1].append(v - 1)\n        inDegrees[v - 1] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n    i = 0  # org's index\n\n    while q:\n      if len(q) > 1:\n        return False\n      u = q.popleft()\n      if u != org[i] - 1:\n        return False\n      i += 1\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return i == n",
      "title": "444. Sequence Reconstruction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "771fd56e-4d77-447a-8135-8b154cc0ae5b",
      "code": "class Solution:\n  def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:\n    stack1 = []\n    stack2 = []\n\n    while l1:\n      stack1.append(l1)\n      l1 = l1.next\n\n    while l2:\n      stack2.append(l2)\n      l2 = l2.next\n\n    head = None\n    carry = 0\n\n    while carry or stack1 or stack2:\n      if stack1:\n        carry += stack1.pop().val\n      if stack2:\n        carry += stack2.pop().val\n      node = ListNode(carry % 10)\n      node.next = head\n      head = node\n      carry //= 10\n\n    return head",
      "title": "445. Add Two Numbers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85e07fbd-4564-4d2a-8fb9-6ede01551f7d",
      "code": "class Solution:\n  def numberOfArithmeticSlices(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][j] := the number of subsequences end in nums[j] nums[i]\n    dp = [[0] * n for _ in range(n)]\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for i in range(n):\n      for j in range(i):\n        target = nums[j] * 2 - nums[i]\n        if target in numToIndices:\n          for k in numToIndices[target]:\n            if k < j:\n              dp[i][j] += dp[j][k] + 1\n        ans += dp[i][j]\n\n    return ans",
      "title": "446. Arithmetic Slices II - Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c73221ec-94ad-4bd7-940d-bb124064f8ba",
      "code": "class Solution:\n  def numberOfBoomerangs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for x1, y1 in points:\n      count = collections.Counter()\n      for x2, y2 in points:\n        ans += 2 * count[(x1 - x2)**2 + (y1 - y2)**2]\n        count[(x1 - x2)**2 + (y1 - y2)**2] += 1\n\n    return ans",
      "title": "447. Number of Boomerangs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d91c8f6-d2f8-40df-841e-cb68d3c0a048",
      "code": "class Solution:\n  def findDisappearedNumbers(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      index = abs(num) - 1\n      nums[index] = -abs(nums[index])\n\n    return [i + 1 for i, num in enumerate(nums) if num > 0]",
      "title": "448. Find All Numbers Disappeared in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95c5709e-5101-4974-8d6a-593e440429fe",
      "code": "class Solution:\n  def deleteNode(self, root: TreeNode | None, key: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == key:\n      if not root.left:\n        return root.right\n      if not root.right:\n        return root.left\n      minNode = self._getMin(root.right)\n      root.right = self.deleteNode(root.right, minNode.val)\n      minNode.left = root.left\n      minNode.right = root.right\n      root = minNode\n    elif root.val < key:\n      root.right = self.deleteNode(root.right, key)\n    else:  # root.val > key\n      root.left = self.deleteNode(root.left, key)\n    return root\n\n  def _getMin(self, node: TreeNode | None) -> TreeNode | None:\n    while node.left:\n      node = node.left\n    return node",
      "title": "450. Delete Node in a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46ba2d6c-77e7-4b19-a73c-2bf63b874b1c",
      "code": "class Solution:\n  def frequencySort(self, s: str) -> str:\n    ans = []\n    buckets = [[] for _ in range(len(s) + 1)]\n\n    for c, freq in collections.Counter(s).items():\n      buckets[freq].append(c)\n\n    for freq in reversed(range(len(buckets))):\n      for c in buckets[freq]:\n        ans.append(c * freq)\n\n    return ''.join(ans)",
      "title": "451. Sort Characters By Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65f87f36-cbe8-4a1e-8668-2584e7182ffb",
      "code": "class Solution:\n  def findMinArrowShots(self, points: list[list[int]]) -> int:\n    ans = 0\n    arrowX = -math.inf\n\n    for point in sorted(points, key=lambda x: x[1]):\n      if point[0] > arrowX:\n        ans += 1\n        arrowX = point[1]\n\n    return ans",
      "title": "452. Minimum Number of Arrows to Burst Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89fc8ea2-641f-4461-a07b-ab4f990bdbbe",
      "code": "class Solution:\n  def minMoves(self, nums: list[int]) -> int:\n    mn = min(nums)\n    return sum(num - mn for num in nums)",
      "title": "453. Minimum Moves to Equal Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fca722d-eac7-415a-8912-54efdead0766",
      "code": "class Solution:\n  def fourSumCount(self, nums1: list[int], nums2: list[int],\n                   nums3: list[int], nums4: list[int]) -> int:\n    count = collections.Counter(a + b for a in nums1 for b in nums2)\n    return sum(count[-c - d] for c in nums3 for d in nums4)",
      "title": "454. 4Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "892c3ef2-b00f-429c-85df-b536d67afaa0",
      "code": "class Solution:\n  def findContentChildren(self, g: list[int], s: list[int]) -> int:\n    g.sort()\n    s.sort()\n\n    i = 0\n    for cookie in s:\n      if i < len(g) and g[i] <= cookie:\n        i += 1\n\n    return i",
      "title": "455. Assign Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6b799cd-f994-4e86-9dcb-e9e452ee8022",
      "code": "class Solution:\n  def find132pattern(self, nums: list[int]) -> bool:\n    stack = []  # a decreasing stack\n    ak = -math.inf  # Find a seq, where ai < ak < aj.\n\n    for num in reversed(nums):\n      # If ai < ak, done because ai must < aj.\n      if num < ak:\n        return True\n      while stack and stack[-1] < num:\n        ak = stack[-1]\n        stack.pop()\n      stack.append(num)  # `nums[i]` is a candidate of aj.\n\n    return False",
      "title": "456. 132 Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b3fb5d4-edf8-4c48-a4fa-584337649608",
      "code": "class Solution:\n  def circularArrayLoop(self, nums: list[int]) -> bool:\n    def advance(i: int) -> int:\n      return (i + nums[i]) % len(nums)\n\n    if len(nums) < 2:\n      return False\n\n    for i, num in enumerate(nums):\n      if num == 0:\n        continue\n\n      slow = i\n      fast = advance(slow)\n      while num * nums[fast] > 0 and num * nums[advance(fast)] > 0:\n        if slow == fast:\n          if slow == advance(slow):\n            break\n          return True\n        slow = advance(slow)\n        fast = advance(advance(fast))\n\n      slow = i\n      sign = num\n      while sign * nums[slow] > 0:\n        next = advance(slow)\n        nums[slow] = 0\n        slow = next\n\n    return False",
      "title": "457. Circular Array Loop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a051a88-0660-4061-acb6-395803eb3c4a",
      "code": "class Solution:\n  def poorPigs(self, buckets: int, minutesToDie: int, minutesToTest: int) -> int:\n    base = minutesToTest // minutesToDie + 1\n    ans = 0\n    x = 1\n    while x < buckets:\n      ans += 1\n      x *= base\n    return ans",
      "title": "458. Poor Pigs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70f509cd-81b0-40ab-992c-6d78ebb77ea9",
      "code": "class Solution:\n  def repeatedSubstringPattern(self, s: str) -> bool:\n    return s in (s + s)[1:-1]",
      "title": "459. Repeated Substring Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44366e87-cb6e-4db8-8a0f-1d7e5164e14d",
      "code": "class Solution:\n  def hammingDistance(self, x: int, y: int) -> int:\n    ans = 0\n\n    while x > 0 or y > 0:\n      ans += (x & 1) ^ (y & 1)\n      x >>= 1\n      y >>= 1\n\n    return ans",
      "title": "461. Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10ce8703-09a6-432e-90f9-e9c07b560827",
      "code": "import statistics\n\n\nclass Solution:\n  def minMoves2(self, nums: list[int]) -> int:\n    median = int(statistics.median(nums))\n    return sum(abs(num - median) for num in nums)",
      "title": "462. Minimum Moves to Equal Array Elements II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e13d6c0e-a37d-48b4-aa23-91cb10709da0",
      "code": "class Solution:\n  def islandPerimeter(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    islands = 0\n    neighbors = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          islands += 1\n          if i + 1 < m and grid[i + 1][j] == 1:\n            neighbors += 1\n          if j + 1 < n and grid[i][j + 1] == 1:\n            neighbors += 1\n\n    return islands * 4 - neighbors * 2",
      "title": "463. Island Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac18dfae-4080-48c5-93b6-d870cc170bfb",
      "code": "class Solution:\n  def canIWin(self, maxChoosableInteger: int, desiredTotal: int) -> bool:\n    if desiredTotal <= 0:\n      return True\n\n    totalSum = maxChoosableInteger * (maxChoosableInteger + 1) // 2\n    if totalSum < desiredTotal:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(total: int, used: int) -> bool:\n      \"\"\"\n      Returns true if the first player can we, where `used` represents the use\n      numbers.\n      \"\"\"\n      if total <= 0:\n        return False\n      return any((used >> i & 1) == 0\n                 and not dp(total - i, used | 1 << i)\n                 for i in range(1, maxChoosableInteger + 1))\n\n    return dp(desiredTotal, 0)",
      "title": "464. Can I Win",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94cff099-e6f4-4036-9831-afce86c0c2a2",
      "code": "class Solution:\n  def minTransfers(self, transactions: list[list[int]]) -> int:\n    balance = [0] * 21\n\n    for u, v, amount in transactions:\n      balance[u] -= amount\n      balance[v] += amount\n\n    debts = [b for b in balance if b]\n\n    def dfs(s: int) -> int:\n      while s < len(debts) and not debts[s]:\n        s += 1\n      if s == len(debts):\n        return 0\n\n      ans = math.inf\n\n      for i in range(s + 1, len(debts)):\n        if debts[i] * debts[s] < 0:\n          debts[i] += debts[s]  # `debts[s]` is settled.\n          ans = min(ans, 1 + dfs(s + 1))\n          debts[i] -= debts[s]  # Backtrack.\n\n      return ans\n\n    return dfs(0)",
      "title": "465. Optimal Account Balancing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f84d19b-23bc-45c1-8923-9b235ebffeb7",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Record:\n  count: int\n  nextIndex: int\n\n\nclass Solution:\n  def getMaxRepetitions(self, s1: str, n1: int, s2: str, n2: int) -> int:\n    # records[i].count := the number of times that s2 starting from index i has\n    # been fully matched with s1\n    # records[i].nextIndex := the next index in s2 to be matched after\n    # completing a full match starting from index i\n    records = []\n\n    for nextIndex in range(len(s2)):\n      count = 0\n      for c in s1:\n        if s2[nextIndex] == c:\n          nextIndex += 1\n          if nextIndex == len(s2):  # There's a match.\n            count += 1\n            nextIndex = 0\n      records.append(Record(count, nextIndex))\n\n    matches = 0  # the number of matches between `s1` x n1 and `s2`\n    i = 0  # the index in `s2` to start matching\n\n    for _ in range(n1):\n      matches += records[i].count\n      i = records[i].nextIndex\n\n    return matches // n2",
      "title": "466. Count The Repetitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df250d6e-428f-4c15-82b9-d2dbfe7beb10",
      "code": "class Solution:\n  def findSubstringInWraproundString(self, s: str) -> int:\n    maxLength = 1\n    # count[i] := the number of substrings ending in ('a' + i)\n    count = [0] * 26\n\n    for i in range(len(s)):\n      if i > 0 and (ord(s[i]) - ord(s[i - 1]) == 1\n                    or ord(s[i - 1]) - ord(s[i]) == 25):\n        maxLength += 1\n      else:\n        maxLength = 1\n      index = ord(s[i]) - ord('a')\n      count[index] = max(count[index], maxLength)\n\n    return sum(count)",
      "title": "467. Unique Substrings in Wraparound String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa688513-b3b0-4953-8938-41c83faa116f",
      "code": "class Solution:\n  def validIPAddress(self, queryIP: str) -> str:\n    if queryIP.count('.') == 3:\n      parts = queryIP.split('.')\n      if len(parts) == 4 and all(self._isIPv4(part) for part in parts):\n        return 'IPv4'\n\n    if queryIP.count(':') == 7:\n      parts = queryIP.split(':')\n      if len(parts) == 8 and all(self._isIPv6(part) for part in parts):\n        return 'IPv6'\n\n    return 'Neither'\n\n  def _isIPv4(self, digit: str) -> bool:\n    if not digit or len(digit) > 3:\n      return False\n    if len(digit) > 1 and digit[0] == '0':\n      return False\n    if not all(c.isdigit() for c in digit):\n      return False\n    num = int(digit)\n    return 0 <= num <= 255\n\n  def _isIPv6(self, digit: str) -> bool:\n    if not digit or len(digit) > 4:\n      return False\n    validChars = set('0123456789abcdefABCDEF')\n    return all(c in validChars for c in digit)",
      "title": "468. Validate IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cf6d08f-fb1c-4c59-8c66-6beaf8437995",
      "code": "class Solution:\n  def isConvex(self, points: list[list[int]]) -> bool:\n    def getCross(p: list[int], q: list[int], r: list[int]):\n      \"\"\"Returns pq x qr.\"\"\"\n      return (q[0] - p[0]) * (r[1] - p[1]) - (q[1] - p[1]) * (r[0] - p[0])\n\n    sign = 0\n    for i in range(len(points)):\n      cross = getCross(points[i - 2], points[i - 1], points[i])\n      if cross == 0:  # p, q, r are collinear.\n        continue\n      if sign == 0:  # Find the first cross that's not 0.\n        sign = cross\n      elif cross * sign < 0:\n        return False\n\n    return True",
      "title": "469. Convex Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "790c263a-a9fa-4504-915a-61695f9202bf",
      "code": "# The rand7() API is already defined for you.\n# def rand7():\n# @return a random integer in the range 1 to 7\n\nclass Solution:\n  def rand10(self) -> int:\n    num = 40\n    while num >= 40:\n      num = (rand7() - 1) * 7 + (rand7() - 1)\n    return num % 10 + 1",
      "title": "470. Implement Rand10() Using Rand7()",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee1c301e-3109-470c-a511-b73b96b78ce6",
      "code": "class Solution:\n  def encode(self, s: str) -> str:\n    n = len(s)\n    # dp[i][j] := the shortest encoded string of s[i..j]\n    dp = [[''] * n for _ in range(n)]\n\n    for d in range(n):\n      for i in range(n - d):\n        j = i + d\n        curr = s[i:j + 1]\n        dp[i][j] = curr\n\n        if len(dp[i][j]) < 5:\n          continue\n\n        # Try all the possible partitions.\n        for k in range(i, j):\n          if len(dp[i][k]) + len(dp[k + 1][j]) < len(dp[i][j]):\n            dp[i][j] = dp[i][k] + dp[k + 1][j]\n\n        # Try to compress the string.\n        # e.g. s = aabaabaab -> 3[aab]\n        for k in range(i, j):\n          pattern = s[i:k + 1]\n          if len(curr) % len(pattern) == 0 and pattern * (len(curr) //\n                                                          len(pattern)) == curr:\n            candidate = f\"{len(curr) // len(pattern)}[{dp[i][k]}]\"\n            if len(candidate) < len(dp[i][j]):\n              dp[i][j] = candidate\n\n    return dp[0][n - 1]",
      "title": "471. Encode String with Shortest Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d195674-6830-4943-ba3c-9b8ad097a140",
      "code": "class Solution:\n  def findAllConcatenatedWordsInADict(self, words: list[str]) -> list[str]:\n    wordSet = set(words)\n\n    @functools.lru_cache(None)\n    def isConcat(word: str) -> bool:\n      for i in range(1, len(word)):\n        prefix = word[:i]\n        suffix = word[i:]\n        if prefix in wordSet and (suffix in wordSet or isConcat(suffix)):\n          return True\n\n      return False\n\n    return [word for word in words if isConcat(word)]",
      "title": "472. Concatenated Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17164e32-8907-42f1-85fc-2c228d7e1dfa",
      "code": "class Solution:\n  def makesquare(self, matchsticks: list[int]) -> bool:\n    if len(matchsticks) < 4:\n      return False\n\n    perimeter = sum(matchsticks)\n    if perimeter % 4 != 0:\n      return False\n\n    A = sorted(matchsticks)[::-1]\n\n    def dfs(selected: int, edges: list[int]) -> bool:\n      if selected == len(A):\n        return all(edge == edges[0] for edge in edges)\n\n      for i, edge in enumerate(edges):\n        if A[selected] > edge:\n          continue\n        edges[i] -= A[selected]\n        if dfs(selected + 1, edges):\n          return True\n        edges[i] += A[selected]\n\n      return False\n\n    return dfs(0, [perimeter // 4] * 4)",
      "title": "473. Matchsticks to Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bab0ba9-ce3a-44b7-bd83-f4cff0ce7902",
      "code": "class Solution:\n  def findMaxForm(self, strs: list[str], m: int, n: int) -> int:\n    # dp[i][j] := the maximum size of the subset given i 0s and j 1s are\n    # available\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for s in strs:\n      zeros = s.count('0')\n      ones = len(s) - zeros\n      for i in range(m, zeros - 1, -1):\n        for j in range(n, ones - 1, -1):\n          dp[i][j] = max(dp[i][j], dp[i - zeros][j - ones] + 1)\n\n    return dp[m][n]",
      "title": "474. Ones and Zeroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c364db3e-fadd-4e27-90d9-eb1426cd2ebb",
      "code": "class Solution:\n  def totalHammingDistance(self, nums: list[int]) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      ones = sum(num & (1 << i) > 0 for num in nums)\n      zeros = len(nums) - ones\n      ans += ones * zeros\n\n    return ans",
      "title": "477. Total Hamming Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd109d72-f8e1-48d4-8569-ec4bf6b65157",
      "code": "class Solution:\n  def __init__(self, radius: float, x_center: float, y_center: float):\n    self.radius = radius\n    self.x_center = x_center\n    self.y_center = y_center\n\n  def randPoint(self) -> list[float]:\n    length = math.sqrt(random.uniform(0, 1)) * self.radius\n    degree = random.uniform(0, 1) * 2 * math.pi\n    x = self.x_center + length * math.cos(degree)\n    y = self.y_center + length * math.sin(degree)\n    return [x, y]",
      "title": "478. Generate Random Point in a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0877410-7553-434c-b484-fff528b2ad99",
      "code": "class Solution:\n  def largestPalindrome(self, n: int) -> int:\n    if n == 1:\n      return 9\n\n    MOD = 1337\n    upper = pow(10, n) - 1\n    lower = pow(10, n - 1) - 1\n\n    for i in range(upper, lower, -1):\n      cand = int(str(i) + str(i)[::-1])\n      j = upper\n      while j * j >= cand:\n        if cand % j == 0:\n          return cand % MOD\n        j -= 1",
      "title": "479. Largest Palindrome Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5426488-47d2-4744-b3d1-223e24b10111",
      "code": "class Solution:\n  def magicalString(self, n: int) -> int:\n    s = [' ', '1', '2', '2']\n\n    for i in range(3, n + 1):\n      if i % 2 == 1:\n        s.extend(['1'] * (int(s[i])))\n      else:\n        s.extend(['2'] * (int(s[i])))\n\n    return sum(1 for c in s[:n + 1] if c == '1')",
      "title": "481. Magical String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f66f1c7-68f4-4081-82af-4b90986bfa80",
      "code": "class Solution:\n  def licenseKeyFormatting(self, s: str, k: int) -> str:\n    ans = []\n    length = 0\n\n    for i in reversed(range(len(s))):\n      if s[i] == '-':\n        continue\n      if length > 0 and length % k == 0:\n        ans += '-'\n      ans += s[i].upper()\n      length += 1\n\n    return ''.join(reversed(ans))",
      "title": "482. License Key Formatting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e0d3682d-19b0-4be6-8201-c9b6360b6e7b",
      "code": "class Solution:\n  def smallestGoodBase(self, n: str) -> str:\n    n = int(n)\n\n    for m in range(int(math.log(n, 2)), 1, -1):\n      k = int(n**m**-1)\n      if (k**(m + 1) - 1) // (k - 1) == n:\n        return str(k)\n\n    return str(n - 1)",
      "title": "483. Smallest Good Base",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa30ae12-3e87-4acd-a550-201c679ff567",
      "code": "class Solution:\n  def findPermutation(self, s: str) -> list[int]:\n    ans = [i for i in range(1, len(s) + 2)]\n\n    # For each D* group (s[i..j]), reverse ans[i..j + 1].\n    i = -1\n    j = -1\n\n    def getNextIndex(c: str, start: int) -> int:\n      for i in range(start, len(s)):\n        if s[i] == c:\n          return i\n      return len(s)\n\n    while True:\n      i = getNextIndex('D', j + 1)\n      if i == len(s):\n        break\n      j = getNextIndex('I', i + 1)\n      ans[i:j + 1] = ans[i:j + 1][::-1]\n\n    return ans",
      "title": "484. Find Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "807e64dd-c228-42d7-b432-2743ffbd780d",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    summ = 0\n\n    for num in nums:\n      if num == 0:\n        summ = 0\n      else:\n        summ += num\n        ans = max(ans, summ)\n\n    return ans",
      "title": "485. Max Consecutive Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96cdf9e4-697f-43cd-a2e1-4c140835c375",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    maxZeros = 1\n    ans = 0\n    q = collections.deque()  # Store indices of zero.\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        q.append(r)\n      if len(q) > maxZeros:\n        l = q.popleft() + 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb7597bb-64fb-47f9-9eb3-d189840458d9",
      "code": "class Solution:\n  def findMaxConsecutiveOnes(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "487. Max Consecutive Ones II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88871b93-b1df-4042-a146-439624a77435",
      "code": "class Solution:\n  def findMinStep(self, board: str, hand: str) -> int:\n    def deDup(board):\n      start = 0  # the start index of a color sequenece\n      for i, c in enumerate(board):\n        if c != board[start]:\n          if i - start >= 3:\n            return deDup(board[:start] + board[i:])\n          start = i  # Meet a new sequence.\n      return board\n\n    @functools.lru_cache(None)\n    def dfs(board: str, hand: str):\n      board = deDup(board)\n      if board == '#':\n        return 0\n\n      boardSet = set(board)\n      # hand that is in board\n      hand = ''.join(h for h in hand if h in boardSet)\n      if not hand:  # infeasible\n        return math.inf\n\n      ans = math.inf\n\n      for i in range(len(board)):\n        for j, h in enumerate(hand):\n          # Place hs[j] in board[i].\n          newHand = hand[:j] + hand[j + 1:]\n          newBoard = board[:i] + h + board[i:]\n          ans = min(ans, 1 + dfs(newBoard, newHand))\n\n      return ans\n\n    ans = dfs(board + '#', hand)\n    return -1 if ans == math.inf else ans",
      "title": "488. Zuma Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e8772b1-7e77-499d-a8e9-32575be465a4",
      "code": "class Solution:\n  def hasPath(\n      self,\n      maze: list[list[int]],\n      start: list[int],\n      destination: list[int],\n  ) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(start[0], start[1])])\n    seen = {(start[0], start[1])}\n\n    def isValid(x: int, y: int) -> bool:\n      return 0 <= x < m and 0 <= y < n and maze[x][y] == 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i\n        y = j\n        while isValid(x + dx, y + dy):\n          x += dx\n          y += dy\n        if [x, y] == destination:\n          return True\n        if (x, y) in seen:\n          continue\n        q.append((x, y))\n        seen.add((x, y))\n\n    return False",
      "title": "490. The Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f550309e-7d2e-4e3b-a391-73ba60d817d4",
      "code": "class Solution:\n  def findSubsequences(self, nums: list[int]) -> list[list[int]]:\n    ans = []\n\n    def dfs(s: int, path: list[int]) -> None:\n      if len(path) > 1:\n        ans.append(path)\n\n      used = set()\n\n      for i in range(s, len(nums)):\n        if nums[i] in used:\n          continue\n        if not path or nums[i] >= path[-1]:\n          used.add(nums[i])\n          dfs(i + 1, path + [nums[i]])\n\n    dfs(0, [])\n    return ans",
      "title": "491. Increasing Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "192371d0-d34b-4922-be23-b038f8436d9b",
      "code": "class Solution:\n  def findTargetSumWays(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    if summ < abs(target) or (summ + target) % 2 == 1:\n      return 0\n\n    def knapsack(nums: list[int], target: int) -> int:\n      # dp[i] := the number of ways to sum to i by nums so far\n      dp = [0] * (target + 1)\n      dp[0] = 1\n\n      for num in nums:\n        for i in range(target, num - 1, -1):\n          dp[i] += dp[i - num]\n\n      return dp[target]\n\n    return knapsack(nums, (summ + target) // 2)",
      "title": "494. Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27d20648-39bb-4cda-b3d8-7f76dd8a7d6b",
      "code": "class Solution:\n  def findPoisonedDuration(self, timeSeries: list[int], duration: int) -> int:\n    if duration == 0:\n      return 0\n\n    ans = 0\n\n    for i in range(0, len(timeSeries) - 1):\n      ans += min(timeSeries[i + 1] - timeSeries[i], duration)\n\n    return ans + duration",
      "title": "495. Teemo Attacking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75d0f57c-a1dc-48a8-9161-3746961bc84a",
      "code": "class Solution:\n  def nextGreaterElement(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToNextGreater = {}\n    stack = []  # a decreasing stack\n\n    for num in nums2:\n      while stack and stack[-1] < num:\n        numToNextGreater[stack.pop()] = num\n      stack.append(num)\n\n    return [numToNextGreater.get(num, -1) for num in nums1]",
      "title": "496. Next Greater Element I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "359b5323-c816-4a35-8b33-34f8e29027ef",
      "code": "class Solution:\n  def __init__(self, rects: list[list[int]]):\n    self.rects = rects\n    self.areas = list(itertools.accumulate(\n        [(x2 - x1 + 1) * (y2 - y1 + 1) for x1, y1, x2, y2 in rects]))\n\n  def pick(self) -> list[int]:\n    index = bisect_right(self.areas, random.randint(0, self.areas[-1] - 1))\n    x1, y1, x2, y2 = self.rects[index]\n    return [random.randint(x1, x2), random.randint(y1, y2)]",
      "title": "497. Random Point in Non-overlapping Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f6a0eca-1fc8-4dee-841f-e78c87bf2cf5",
      "code": "class Solution:\n  def findShortestWay(\n      self,\n      maze: list[list[int]],\n      ball: list[int],\n      hole: list[int],\n  ) -> str:\n    ans = 'impossible'\n    minSteps = math.inf\n\n    def dfs(i: int, j: int, dx: int, dy: int, steps: int, path: str):\n      nonlocal ans\n      nonlocal minSteps\n      if steps >= minSteps:\n        return\n\n      if dx != 0 or dy != 0:  # Both are zeros for the initial ball position.\n        while (0 <= i + dx < len(maze) and 0 <= j + dy < len(maze[0]) and\n               maze[i + dx][j + dy] != 1):\n          i += dx\n          j += dy\n          steps += 1\n          if i == hole[0] and j == hole[1] and steps < minSteps:\n            minSteps = steps\n            ans = path\n\n      if maze[i][j] == 0 or steps + 2 < maze[i][j]:\n        maze[i][j] = steps + 2  # +2 because maze[i][j] == 0 || 1.\n        if dx == 0:\n          dfs(i, j, 1, 0, steps, path + 'd')\n        if dy == 0:\n          dfs(i, j, 0, -1, steps, path + 'l')\n        if dy == 0:\n          dfs(i, j, 0, 1, steps, path + 'r')\n        if dx == 0:\n          dfs(i, j, -1, 0, steps, path + 'u')\n\n    dfs(ball[0], ball[1], 0, 0, 0, '')\n    return ans",
      "title": "499. The Maze III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1920960-3438-4735-b150-5068b50b41ca",
      "code": "class Solution:\n  def findWords(self, words: list[str]) -> list[str]:\n    ans = []\n    rows = [set('qwertyuiop'), set('asdfghjkl'), set('zxcvbnm')]\n\n    for word in words:\n      lowerWord = set(word.lower())\n      if any(lowerWord <= row for row in rows):\n        ans.append(word)\n\n    return ans",
      "title": "500. Keyboard Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "339ae9eb-1d6c-408c-a25e-893b72db4ea6",
      "code": "class Solution:\n  def findMode(self, root: TreeNode | None) -> list[int]:\n    self.ans = []\n    self.pred = None\n    self.count = 0\n    self.maxCount = 0\n\n    def updateCount(root: TreeNode | None) -> None:\n      if self.pred and self.pred.val == root.val:\n        self.count += 1\n      else:\n        self.count = 1\n\n      if self.count > self.maxCount:\n        self.maxCount = self.count\n        self.ans = [root.val]\n      elif self.count == self.maxCount:\n        self.ans.append(root.val)\n\n      self.pred = root\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n\n      inorder(root.left)\n      updateCount(root)\n      inorder(root.right)\n\n    inorder(root)\n    return self.ans",
      "title": "501. Find Mode in Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "568071b2-98c7-43c6-84cb-a5b2e7a7f326",
      "code": "class Solution:\n  def nextGreaterElements(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [-1] * n\n    stack = []  # a decreasing stack storing indices\n\n    for i in range(n * 2):\n      num = nums[i % n]\n      while stack and nums[stack[-1]] < num:\n        ans[stack.pop()] = num\n      if i < n:\n        stack.append(i)\n\n    return ans",
      "title": "503. Next Greater Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "285f4189-3823-4eac-addc-8ce7d6273325",
      "code": "class Solution:\n  def checkPerfectNumber(self, num: int) -> bool:\n    return num in {6, 28, 496, 8128, 33550336}",
      "title": "507. Perfect Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b058c5fe-c823-4061-aae7-a3bb4937315b",
      "code": "class Solution:\n  def findFrequentTreeSum(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    count = collections.Counter()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      count[summ] += 1\n      return summ\n\n    dfs(root)\n    maxFreq = max(count.values())\n    return [summ for summ in count if count[summ] == maxFreq]",
      "title": "508. Most Frequent Subtree Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "618a1395-2a49-4248-8d08-1d4f672f8868",
      "code": "class Solution:\n  def fib(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 0, 1]\n\n    for i in range(2, n + 1):\n      dp[0] = dp[1]\n      dp[1] = dp[2]\n      dp[2] = dp[0] + dp[1]\n\n    return dp[2]",
      "title": "509. Fibonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "318a3ce0-b923-4778-b4e7-7f4f8b7999f5",
      "code": "class Solution:\n  def findBottomLeftValue(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxDepth = 0\n\n    def dfs(root: TreeNode | None, depth: int) -> None:\n      nonlocal ans\n      nonlocal maxDepth\n      if not root:\n        return\n      if depth > maxDepth:\n        maxDepth = depth\n        ans = root.val\n\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 1)\n    return ans",
      "title": "513. Find Bottom Left Tree Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0deca272-8284-4381-82cb-cc621d2df541",
      "code": "class Solution:\n  def findRotateSteps(self, ring: str, key: str) -> int:\n    @functools.lru_cache(None)\n    def dfs(ring: str, index: int) -> int:\n      \"\"\"Returns the number of rotates of ring to match key[index..n).\"\"\"\n      if index == len(key):\n        return 0\n\n      ans = math.inf\n\n      # For each ring[i] == key[index], we rotate the ring to match the ring[i]\n      # with the key[index], then recursively match the newRing with the\n      # key[index + 1..n).\n      for i, r in enumerate(ring):\n        if r == key[index]:\n          minRotates = min(i, len(ring) - i)\n          newRing = ring[i:] + ring[:i]\n          remainingRotates = dfs(newRing, index + 1)\n          ans = min(ans, minRotates + remainingRotates)\n\n      return ans\n\n    return dfs(ring, 0) + len(key)",
      "title": "514. Freedom Trail",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fc3ba02-567e-4eba-b834-29b65458678e",
      "code": "class Solution:\n  def largestValues(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = []\n    q = collections.deque([root])\n\n    while q:\n      mx = -math.inf\n      for _ in range(len(q)):\n        root = q.popleft()\n        mx = max(mx, root.val)\n        if root.left:\n          q.append(root.left)\n        if root.right:\n          q.append(root.right)\n      ans.append(mx)\n\n    return ans",
      "title": "515. Find Largest Value in Each Tree Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6295352d-c3b3-4018-80cd-ca9216ed1daf",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "516. Longest Palindromic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf962c11-b952-4d8f-b0b6-62d115235e17",
      "code": "class Solution:\n  def findMinMoves(self, machines: list[int]) -> int:\n    dresses = sum(machines)\n\n    if dresses % len(machines) != 0:\n      return -1\n\n    ans = 0\n    average = dresses // len(machines)\n    inout = 0\n\n    for dress in machines:\n      inout += dress - average\n      ans = max(ans, abs(inout), dress - average)\n\n    return ans",
      "title": "517. Super Washing Machines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66c9314b-679e-4ce8-ae2f-b33bea86937b",
      "code": "class Solution:\n  def change(self, amount: int, coins: list[int]) -> int:\n    dp = [1] + [0] * amount\n\n    for coin in coins:\n      for i in range(coin, amount + 1):\n        dp[i] += dp[i - coin]\n\n    return dp[amount]",
      "title": "518. Coin Change 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b0db494-2be9-4105-b449-1c308fb05d06",
      "code": "class Solution:\n  def detectCapitalUse(self, word: str) -> bool:\n    return word.isupper() or word.islower() or word.istitle()",
      "title": "520. Detect Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f06f5b4-5a94-4e20-9198-e34450a084cd",
      "code": "class Solution:\n  def findLUSlength(self, a: str, b: str) -> int:\n    return -1 if a == b else max(len(a), len(b))",
      "title": "521. Longest Uncommon Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a26eef8-63a3-49b7-919d-ee86065de396",
      "code": "class Solution:\n  def findLUSlength(self, strs: list[str]) -> int:\n    def isSubsequence(a: str, b: str) -> bool:\n      i = 0\n      j = 0\n\n      while i < len(a) and j < len(b):\n        if a[i] == b[j]:\n          i += 1\n        j += 1\n\n      return i == len(a)\n\n    seen = set()\n    duplicates = set()\n\n    for s in strs:\n      if s in seen:\n        duplicates.add(s)\n      seen.add(s)\n\n    strs.sort(key=lambda x: -len(x))\n\n    for i in range(len(strs)):\n      if strs[i] in duplicates:\n        continue\n      isASubsequence = False\n      for j in range(i):\n        isASubsequence |= isSubsequence(strs[i], strs[j])\n      if not isASubsequence:\n        return len(strs[i])\n\n    return -1",
      "title": "522. Longest Uncommon Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3161a791-ab3e-4f13-b51f-b29a26268064",
      "code": "class Solution:\n  def checkSubarraySum(self, nums: list[int], k: int) -> bool:\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      if k != 0:\n        prefix %= k\n      if prefix in prefixToIndex:\n        if i - prefixToIndex[prefix] > 1:\n          return True\n      else:\n        # Set a new key if it's absent because the previous index is better.\n        prefixToIndex[prefix] = i\n\n    return False",
      "title": "523. Continuous Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbc620d5-ef87-4785-a7a2-1ed958abe18c",
      "code": "class Solution:\n  def findLongestWord(self, s: str, d: list[str]) -> str:\n    ans = ''\n\n    for word in d:\n      i = 0\n      for c in s:\n        if i < len(word) and c == word[i]:\n          i += 1\n      if i == len(word):\n        if len(word) > len(ans) or len(word) == len(ans) and word < ans:\n          ans = word\n\n    return ans",
      "title": "524. Longest Word in Dictionary through Deleting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d98c4ec4-a439-4ad7-aa32-6a9a2e29b23c",
      "code": "class Solution:\n  def findMaxLength(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += 1 if num else -1\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "525. Contiguous Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c21b613e-2cc2-4013-975a-077963e5845c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedWord:\n  word: str\n  index: int\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n    ans = [''] * n\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    abbrevToIndexedWords = collections.defaultdict(list)\n\n    for i, word in enumerate(words):\n      abbrev = getAbbrev(word, 0)\n      abbrevToIndexedWords[abbrev].append(IndexedWord(word, i))\n\n    def insertWord(root: TrieNode | None, word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    def firstUniqueIndex(root: TrieNode | None, word: str) -> None:\n      node = root\n      for i, c in enumerate(word):\n        node = node.children[c]\n        if node.count == 1:\n          return i\n      return len(word)\n\n    for indexedWords in abbrevToIndexedWords.values():\n      root = TrieNode()\n      for iw in indexedWords:\n        insertWord(root, iw.word)\n      for iw in indexedWords:\n        index = firstUniqueIndex(root, iw.word)\n        ans[iw.index] = getAbbrev(iw.word, index)\n\n    return ans",
      "title": "527. Word Abbreviation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d38be1b-b041-48ab-b476-1669475e78f7",
      "code": "class Solution:\n  def wordsAbbreviation(self, words: list[str]) -> list[str]:\n    n = len(words)\n\n    def getAbbrev(s: str, prefixIndex: int) -> str:\n      n = len(s)\n      num = n - (prefixIndex + 1) - 1\n      numLength = 1 if num < 10 else (2 if num < 100 else 3)\n      abbrevLength = (prefixIndex + 1) + numLength + 1\n      if abbrevLength >= n:\n        return s\n      return s[:prefixIndex + 1] + str(num) + s[-1]\n\n    ans = [getAbbrev(word, 0) for word in words]\n    # prefix[i] := ans[i] takes words[i][0..prefix[i]]\n    prefix = [0] * n\n\n    for i in range(n):\n      while True:\n        dupeIndices = []\n        for j in range(i + 1, n):\n          if ans[i] == ans[j]:\n            dupeIndices.append(j)\n        if not dupeIndices:\n          break\n        dupeIndices.append(i)\n        for index in dupeIndices:\n          prefix[index] += 1\n          ans[index] = getAbbrev(words[index], prefix[index])\n\n    return ans",
      "title": "527. Word Abbreviation_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "368f25bf-d548-4d8a-a6dd-1254c21d083e",
      "code": "class Solution:\n  def __init__(self, w: list[int]):\n    self.prefix = list(itertools.accumulate(w))\n\n  def pickIndex(self) -> int:\n    target = random.randint(0, self.prefix[-1] - 1)\n    return bisect.bisect_right(range(len(self.prefix)), target,\n                               key=lambda m: self.prefix[m])",
      "title": "528. Random Pick with Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17cecb2b-213b-4033-aef9-63c85008f764",
      "code": "class Solution:\n  def updateBoard(self, board: list[list[str]],\n                  click: list[int]) -> list[list[str]]:\n    i, j = click\n    if board[i][j] == 'M':\n      board[i][j] = 'X'\n      return board\n\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    def getMinesCount(i: int, j: int) -> int:\n      minesCount = 0\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == len(board) or y < 0 or y == len(board[0]):\n          continue\n        if board[x][y] == 'M':\n          minesCount += 1\n      return minesCount\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(board) or j < 0 or j == len(board[0]):\n        return\n      if board[i][j] != 'E':\n        return\n\n      minesCount = getMinesCount(i, j)\n      board[i][j] = 'B' if minesCount == 0 else str(minesCount)\n\n      if minesCount == 0:\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy)\n\n    dfs(i, j)\n    return board",
      "title": "529. Minesweeper",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82f03091-5527-4adf-85a4-e6aa9d8d39a8",
      "code": "class Solution:\n  def findLonelyPixel(self, picture: list[list[str]]) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [0] * m  # rows[i] := the number of B's in rows i\n    cols = [0] * n  # cols[i] := the number of B's in cols i\n\n    for i in range(m):\n      for j in range(n):\n        if picture[i][j] == 'B':\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      if rows[i] == 1:  # Only have to examine the rows if rows[i] == 1.\n        for j in range(n):\n          # After meeting a 'B' in this rows, break and search the next row.\n          if picture[i][j] == 'B':\n            if cols[j] == 1:\n              ans += 1\n            break\n\n    return ans",
      "title": "531. Lonely Pixel I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef512bd1-02c7-4b7e-9011-1baf4551f7ef",
      "code": "class Solution:\n  def findPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for i, num in enumerate(nums):\n      target = num + k\n      if target in numToIndex and numToIndex[target] != i:\n        ans += 1\n        del numToIndex[target]\n\n    return ans",
      "title": "532. K-diff Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1a6e209-88fb-4306-8b05-f5a704d3ef19",
      "code": "class Solution:\n  def findBlackPixel(self, picture: list[list[str]], target: int) -> int:\n    m = len(picture)\n    n = len(picture[0])\n    ans = 0\n    rows = [row.count('B') for row in picture]\n    cols = [col.count('B') for col in zip(*picture)]\n    rowStrings = [''.join(row) for row in picture]\n    countRowStrings = collections.Counter(rowStrings)\n\n    for i, (row, stringRow) in enumerate(zip(rows, rowStrings)):\n      if row == target and countRowStrings[stringRow] == target:\n        for j, col in enumerate(cols):\n          if picture[i][j] == 'B' and col == target:\n            ans += 1\n\n    return ans",
      "title": "533. Lonely Pixel II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c2d9827-5f4f-46c9-8671-57762400d3d7",
      "code": "class Solution:\n  def complexNumberMultiply(self, num1: str, num2: str) -> str:\n    a0, a1 = self._getReala0ndImag(num1)\n    b0, b1 = self._getReala0ndImag(num2)\n    return str(a0 * b0 - a1 * b1) + '+' + str(a0 * b1 + a1 * b0) + 'i'\n\n  def _getReala0ndImag(self, s: str) -> tuple:\n    return int(s[:s.index('+')]), int(s[s.index('+') + 1:-1])",
      "title": "537. Complex Number Multiplication",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcae0ff9-cfa2-4791-892c-2a9500f1c097",
      "code": "class Solution:\n  def convertBST(self, root: TreeNode | None) -> TreeNode | None:\n    prefix = 0\n\n    def reversedInorder(root: TreeNode | None) -> None:\n      nonlocal prefix\n      if not root:\n        return\n\n      reversedInorder(root.right)\n      prefix += root.val\n      root.val = prefix\n      reversedInorder(root.left)\n\n    reversedInorder(root)\n    return root",
      "title": "538. Convert BST to Greater Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f16da12-08bf-4669-a9f4-f085f23521c4",
      "code": "class Solution:\n  def findMinDifference(self, timePoints: list[str]) -> int:\n    ans = 24 * 60\n    nums = sorted([int(timePoint[:2]) * 60 + int(timePoint[3:])\n                   for timePoint in timePoints])\n\n    for a, b in zip(nums, nums[1:]):\n      ans = min(ans, b - a)\n\n    return min(ans, 24 * 60 - nums[-1] + nums[0])",
      "title": "539. Minimum Time Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43920afc-2f27-4dc9-8789-181cbe6d5840",
      "code": "class Solution:\n  def singleNonDuplicate(self, nums: list[int]) -> int:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if m % 2 == 1:\n        m -= 1\n      if nums[m] == nums[m + 1]:\n        l = m + 2\n      else:\n        r = m\n\n    return nums[l]",
      "title": "540. Single Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a571f019-e4fe-49e3-858d-fc5b4acc4d9b",
      "code": "class Solution:\n  def reverseStr(self, s: str, k: int) -> str:\n    return s[:k][::-1] + s[k:2 * k] + self.reverseStr(s[2 * k:], k) if s else \"\"",
      "title": "541. Reverse String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57244421-a29c-4e29-b24c-a75df370a00a",
      "code": "class Solution:\n  def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(mat)\n    n = len(mat[0])\n    q = collections.deque()\n    seen = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 0:\n          q.append((i, j))\n          seen[i][j] = True\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seen[x][y]:\n          continue\n        mat[x][y] = mat[i][j] + 1\n        q.append((x, y))\n        seen[x][y] = True\n\n    return mat",
      "title": "542. 01 Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd59b2b8-18b5-44c4-9508-9c2b05b5846c",
      "code": "class Solution:\n  def diameterOfBinaryTree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def maxDepth(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = maxDepth(root.left)\n      r = maxDepth(root.right)\n      ans = max(ans, l + r)\n      return 1 + max(l, r)\n\n    maxDepth(root)\n    return ans",
      "title": "543. Diameter of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81b9a8ae-66a2-4975-915a-4047fc7ca3eb",
      "code": "class Solution:\n  def findContestMatch(self, n: int) -> str:\n    def generateMatches(matches: list[str]) -> str:\n      if len(matches) == 1:\n        return matches[0]\n\n      nextMatches = []\n\n      for i in range(len(matches) // 2):\n        nextMatches.append(\n            '(' + matches[i] + ',' + matches[len(matches) - 1 - i] + ')')\n\n      return generateMatches(nextMatches)\n\n    return generateMatches([str(i + 1) for i in range(n)])",
      "title": "544. Output Contest Matches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14005b97-854f-4633-b267-16b02fae264d",
      "code": "class Solution:\n  def boundaryOfBinaryTree(self, root: TreeNode | None) -> list[int]:\n    if not root:\n      return []\n\n    ans = [root.val]\n\n    def dfs(root: TreeNode | None, lb: bool, rb: bool):\n      \"\"\"\n      1. root.left is left boundary if root is left boundary.\n         root.right if left boundary if root.left is None.\n      2. Same applys for right boundary.\n      3. If root is left boundary, add it before 2 children - preorder.\n         If root is right boundary, add it after 2 children - postorder.\n      4. A leaf that is neighter left/right boundary belongs to the bottom.\n      \"\"\"\n      if not root:\n        return\n      if lb:\n        ans.append(root.val)\n      if not lb and not rb and not root.left and not root.right:\n        ans.append(root.val)\n\n      dfs(root.left, lb, rb and not root.right)\n      dfs(root.right, lb and not root.left, rb)\n      if rb:\n        ans.append(root.val)\n\n    dfs(root.left, True, False)\n    dfs(root.right, False, True)\n    return ans",
      "title": "545. Boundary of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9afc8b8-1069-420c-86a4-cc630736c5d0",
      "code": "class Solution:\n  def removeBoxes(self, boxes: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum score of boxes[i..j] if k boxes equal to boxes[j].\n      \"\"\"\n      if i > j:\n        return 0\n\n      r = j\n      sameBoxes = k + 1\n      while r > 0 and boxes[r - 1] == boxes[r]:\n        r -= 1\n        sameBoxes += 1\n      res = dp(i, r - 1, 0) + sameBoxes * sameBoxes\n\n      for p in range(i, r):\n        if boxes[p] == boxes[r]:\n          res = max(res, dp(i, p, sameBoxes) + dp(p + 1, r - 1, 0))\n\n      return res\n\n    return dp(0, len(boxes) - 1, 0)",
      "title": "546. Remove Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "063047fa-7f94-473d-bdbb-b867167288c3",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCircleNum(self, isConnected: list[list[int]]) -> int:\n    n = len(isConnected)\n    uf = UnionFind(n)\n\n    for i in range(n):\n      for j in range(i, n):\n        if isConnected[i][j] == 1:\n          uf.unionByRank(i, j)\n\n    return uf.count",
      "title": "547. Friend Circles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c6656a-b496-4892-ab3c-c5ed121de2bd",
      "code": "class Solution:\n  def checkRecord(self, s: str) -> bool:\n    return s.count('A') <= 1 and 'LLL' not in s",
      "title": "551. Student Attendance Record I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32575cb1-c119-4b78-9468-9c6e3f7c7d6d",
      "code": "class Solution:\n  def checkRecord(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the length so far with i A's and the last letters are j L's\n    dp = [[0] * 3 for _ in range(2)]\n    dp[0][0] = 1\n\n    for _ in range(n):\n      prev = [A[:] for A in dp]\n\n      # Append a P.\n      dp[0][0] = (prev[0][0] + prev[0][1] + prev[0][2]) % MOD\n\n      # Append an L.\n      dp[0][1] = prev[0][0]\n\n      # Append an L.\n      dp[0][2] = prev[0][1]\n\n      # Append an A or append a P.\n      dp[1][0] = (prev[0][0] + prev[0][1] + prev[0][2] +\n                  prev[1][0] + prev[1][1] + prev[1][2]) % MOD\n\n      # Append an L.\n      dp[1][1] = prev[1][0]\n\n      # Append an L.\n      dp[1][2] = prev[1][1]\n\n    return (sum(dp[0]) + sum(dp[1])) % MOD",
      "title": "552. Student Attendance Record II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "413ec6b9-339d-4bdb-8d40-5774f82eb69c",
      "code": "class Solution:\n  def optimalDivision(self, nums: list[int]) -> str:\n    ans = str(nums[0])\n\n    if len(nums) == 1:\n      return ans\n    if len(nums) == 2:\n      return ans + '/' + str(nums[1])\n\n    ans += '/(' + str(nums[1])\n    for i in range(2, len(nums)):\n      ans += '/' + str(nums[i])\n    ans += ')'\n    return ans",
      "title": "553. Optimal Division",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91edf901-1a54-4f80-b939-61dcf72051a5",
      "code": "class Solution:\n  def leastBricks(self, wall: list[list[int]]) -> int:\n    maxFreq = 0\n    count = collections.defaultdict(int)\n\n    for row in wall:\n      prefix = 0\n      for i in range(len(row) - 1):\n        prefix += row[i]\n        count[prefix] += 1\n        maxFreq = max(maxFreq, count[prefix])\n\n    return len(wall) - maxFreq",
      "title": "554. Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87e90907-7395-4e2f-8546-48834d5db07e",
      "code": "class Solution:\n  def splitLoopedString(self, strs: list[str]) -> str:\n    ans = ''\n    sortedStrs = [max(s, s[::-1]) for s in strs]\n\n    for i, sortedStr in enumerate(sortedStrs):\n      for s in (sortedStr, sortedStr[::-1]):\n        for j in range(len(s) + 1):\n          ans = max(\n              ans, s[j:] + ''.join(sortedStrs[i + 1:] + sortedStrs[:i]) + s[:j])\n\n    return ans",
      "title": "555. Split Concatenated Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d16ce67-3597-4e88-a824-25e3c9c4b270",
      "code": "class Solution:\n  def nextGreaterElement(self, n: int) -> int:\n    def nextPermutation(s: list[str]) -> str:\n      i = len(s) - 2\n      while i >= 0:\n        if s[i] < s[i + 1]:\n          break\n        i -= 1\n\n      if i >= 0:\n        for j in range(len(s) - 1, i, -1):\n          if s[j] > s[i]:\n            break\n        s[i], s[j] = s[j], s[i]\n\n      reverse(s, i + 1, len(s) - 1)\n      return ''.join(s)\n\n    def reverse(s: list[str], l: int, r: int):\n      while l < r:\n        s[l], s[r] = s[r], s[l]\n        l += 1\n        r -= 1\n\n    s = nextPermutation(list(str(n)))\n    ans = int(s)\n    return -1 if ans > 2**31 - 1 or ans <= n else ans",
      "title": "556. Next Greater Element III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "186b0a83-06da-475e-b5e8-e0e47a373a9e",
      "code": "class Solution:\n  def maxDepth(self, root: 'Node') -> int:\n    if not root:\n      return 0\n    if not root.children:\n      return 1\n    return 1 + max(self.maxDepth(child) for child in root.children)",
      "title": "559. Maximum Depth of N-ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6958809-4988-4d50-9882-a83015fa59fa",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix += num\n      ans += count[prefix - k]\n      count[prefix] += 1\n\n    return ans",
      "title": "560. Subarray Sum Equals K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e95357a-4641-4157-ab5b-499d6111f57e",
      "code": "class Solution:\n  def arrayPairSum(self, nums: list[int]) -> int:\n    return sum(sorted(nums)[::2])",
      "title": "561. Array Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbf2320d-0694-4460-9298-dc7bcde4beee",
      "code": "class Solution:\n  def longestLine(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    # dp[i][j][0] := horizontal\n    # dp[i][j][1] := vertical\n    # dp[i][j][2] := diagonal\n    # dp[i][j][3] := anti-diagonal\n    dp = [[[0] * 4 for j in range(n)] for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          dp[i][j][0] = dp[i][j - 1][0] + 1 if j > 0 else 1\n          dp[i][j][1] = dp[i - 1][j][1] + 1 if i > 0 else 1\n          dp[i][j][2] = dp[i - 1][j - 1][2] + 1 if i > 0 and j > 0 else 1\n          dp[i][j][3] = dp[i - 1][j + 1][3] + 1 if i > 0 and j < n - 1 else 1\n          ans = max(ans, max(dp[i][j]))\n\n    return ans",
      "title": "562. Longest Line of Consecutive One in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82a9358e-33b2-4f82-9b53-8937cebc41d7",
      "code": "class Solution:\n  def findTilt(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def summ(root: TreeNode | None) -> None:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = summ(root.left)\n      r = summ(root.right)\n      ans += abs(l - r)\n      return root.val + l + r\n\n    summ(root)\n    return ans",
      "title": "563. Binary Tree Tilt",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cb65fc3-55ed-4a74-a808-8ca6e9133ba7",
      "code": "class Solution:\n  def nearestPalindromic(self, n: str) -> str:\n    prevPalindrome, nextPalindrome = self._getPalindromes(n)\n    return (str(prevPalindrome)\n            if abs(prevPalindrome - int(n)) <= abs(nextPalindrome - int(n))\n            else str(nextPalindrome))\n\n  def _getPalindromes(self, s: str) -> tuple[str, str]:\n    \"\"\"Returns the two closest palindromes to the given number.\"\"\"\n    num = int(s)\n    sz = len(s)\n    palindromes = []\n    half = s[0:(sz + 1) // 2]\n    reversedHalf = half[:sz // 2][::-1]\n    candidate = int(half + reversedHalf)\n\n    if candidate < num:\n      palindromes.append(candidate)\n    else:\n      prevHalf = str(int(half) - 1)\n      reversedPrevHalf = prevHalf[:sz // 2][::-1]\n      if sz % 2 == 0 and int(prevHalf) == 0:\n        palindromes.append(9)\n      elif sz % 2 == 0 and prevHalf == '9':\n        palindromes.append(int(prevHalf + '9' + reversedPrevHalf))\n      else:\n        palindromes.append(int(prevHalf + reversedPrevHalf))\n\n    if candidate > num:\n      palindromes.append(candidate)\n    else:\n      nextHalf = str(int(half) + 1)\n      reversedNextHalf = nextHalf[:sz // 2][::-1]\n      palindromes.append(int(nextHalf + reversedNextHalf))\n\n    return palindromes",
      "title": "564. Find the Closest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "474fb571-1c3e-4942-b870-480c2d7cebf3",
      "code": "class Solution:\n  def arrayNesting(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if num == -1:\n        continue\n      index = num\n      count = 0\n      while nums[index] != -1:\n        cache = index\n        index = nums[index]\n        nums[cache] = -1\n        count += 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "565. Array Nesting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03f0072e-ea2e-48fb-be2d-b2998bc483f8",
      "code": "class Solution:\n  def matrixReshape(self, nums: list[list[int]],\n                    r: int, c: int) -> list[list[int]]:\n    if nums == [] or r * c != len(nums) * len(nums[0]):\n      return nums\n\n    ans = [[0 for j in range(c)] for i in range(r)]\n    k = 0\n\n    for row in nums:\n      for num in row:\n        ans[k // c][k % c] = num\n        k += 1\n\n    return ans",
      "title": "566. Reshape the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d2faff4-b3e9-4c7d-a273-6ebb030be20f",
      "code": "class Solution:\n  def checkInclusion(self, s1: str, s2: str) -> bool:\n    count = collections.Counter(s1)\n    required = len(s1)\n\n    for r, c in enumerate(s2):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      if r >= len(s1):  # The window is oversized.\n        count[s2[r - len(s1)]] += 1\n        if count[s2[r - len(s1)]] > 0:\n          required += 1\n      if required == 0:\n        return True\n\n    return False",
      "title": "567. Permutation in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c48377e-89d3-4b78-98d2-6ed8c9208c74",
      "code": "class Solution:\n  def minDistance(\n      self,\n      height: int,\n      width: int,\n      tree: list[int],\n      squirrel: list[int],\n      nuts: list[list[int]],\n  ) -> int:\n    def dist(a: list[int], b: list[int]) -> int:\n      return abs(a[0] - b[0]) + abs(a[1] - b[1])\n\n    totDist = sum(dist(nut, tree) for nut in nuts) * 2\n    maxSave = max(dist(nut, tree) - dist(nut, squirrel) for nut in nuts)\n    return totDist - maxSave",
      "title": "573. Squirrel Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a43e916a-3fab-463d-82d0-05aa9781ab9e",
      "code": "class Solution:\n  def distributeCandies(self, candies: list[int]) -> int:\n    return min(len(candies) // 2, len(set(candies)))",
      "title": "575. Distribute Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a34d8a8b-bd70-4ac4-bcd2-57f3dd241c82",
      "code": "class Solution:\n  def findPaths(\n      self,\n      m: int,\n      n: int,\n      maxMove: int,\n      startRow: int,\n      startColumn: int,\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i][j] := the number of paths to move the ball (i, j) out-of-bounds\n    dp = [[0] * n for _ in range(m)]\n    dp[startRow][startColumn] = 1\n\n    for _ in range(maxMove):\n      newDp = [[0] * n for _ in range(m)]\n      for i in range(m):\n        for j in range(n):\n          if dp[i][j] > 0:\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                ans = (ans + dp[i][j]) % MOD\n              else:\n                newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return ans",
      "title": "576. Out of Boundary Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f38b1e87-f2ca-415b-a7a0-547b1167d439",
      "code": "class Solution:\n  def findUnsortedSubarray(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n    flag = False\n\n    for i in range(1, len(nums)):\n      if nums[i] < nums[i - 1]:\n        flag = True\n      if flag:\n        mn = min(mn, nums[i])\n\n    flag = False\n\n    for i in reversed(range(len(nums) - 1)):\n      if nums[i] > nums[i + 1]:\n        flag = True\n      if flag:\n        mx = max(mx, nums[i])\n\n    for l in range(len(nums)):\n      if nums[l] > mn:\n        break\n\n    for r, num in reversed(list(enumerate(nums))):\n      if num < mx:\n        break\n\n    return 0 if l >= r else r - l + 1",
      "title": "581. Shortest Unsorted Continuous Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4880d05c-a411-4a53-8e3e-31d5328a4142",
      "code": "class Solution:\n  def killProcess(\n      self,\n      pid: list[int],\n      ppid: list[int],\n      kill: int,\n  ) -> list[int]:\n    ans = []\n    tree = collections.defaultdict(list)\n\n    for v, u in zip(pid, ppid):\n      if u == 0:\n        continue\n      tree[u].append(v)\n\n    def dfs(u: int) -> None:\n      ans.append(u)\n      for v in tree.get(u, []):\n        dfs(v)\n\n    dfs(kill)\n    return ans",
      "title": "582. Kill Process",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef3a60ca-7475-41d9-99e3-a3ea2e076886",
      "code": "class Solution:\n  def minDistance(self, word1: str, word2: str) -> int:\n    k = self._lcs(word1, word2)\n    return (len(word1) - k) + (len(word2) - k)\n\n  def _lcs(self, a: str, b: str) -> int:\n    m = len(a)\n    n = len(b)\n    # dp[i][j] := the length of LCS(a[0..i), b[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if a[i - 1] == b[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])\n\n    return dp[m][n]",
      "title": "583. Delete Operation for Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55a492c3-8a2e-4760-be17-b6e3a4aecd2e",
      "code": "class Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[list[int]]:\n    hull = []\n\n    trees.sort(key=lambda x: (x[0], x[1]))\n\n    def cross(p: list[int], q: list[int], r: list[int]) -> int:\n      return (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1])\n\n    # Build the lower hull: left-to-right scan.\n    for tree in trees:\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n    hull.pop()\n\n    # Build the upper hull: right-to-left scan.\n    for tree in reversed(trees):\n      while len(hull) > 1 and cross(hull[-1], hull[-2], tree) > 0:\n        hull.pop()\n      hull.append(tuple(tree))\n\n    # Remove the redundant elements from the stack.\n    return list(set(hull))",
      "title": "587. Erect the Fence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53f67054-6b74-481a-8155-26e27ab982d4",
      "code": "class Solution:\n  def isValid(self, code: str) -> bool:\n    if code[0] != '<' or code[-1] != '>':\n      return False\n\n    containsTag = False\n    stack = []\n\n    def isValidCdata(s: str) -> bool:\n      return s.find('[CDATA[') == 0\n\n    def isValidTagName(tagName: str, isEndTag: bool) -> bool:\n      nonlocal containsTag\n      if not tagName or len(tagName) > 9:\n        return False\n      if any(not c.isupper() for c in tagName):\n        return False\n\n      if isEndTag:\n        return stack and stack.pop() == tagName\n\n      containsTag = True\n      stack.append(tagName)\n      return True\n\n    i = 0\n    while i < len(code):\n      if not stack and containsTag:\n        return False\n      if code[i] == '<':\n        # It's inside a tag, so check if it's a cdata.\n        if stack and code[i + 1] == '!':\n          closeIndex = code.find(']]>', i + 2)\n          if closeIndex == -1 or not isValidCdata(code[i + 2:closeIndex]):\n            return False\n        elif code[i + 1] == '/':  # the end tag\n          closeIndex = code.find('>', i + 2)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 2: closeIndex],\n                  True):\n            return False\n        else:  # the start tag\n          closeIndex = code.find('>', i + 1)\n          if closeIndex == -1 or not isValidTagName(\n                  code[i + 1: closeIndex],\n                  False):\n            return False\n        i = closeIndex\n      i += 1\n\n    return not stack and containsTag",
      "title": "591. Tag Validator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c0bfb91-f2f9-463f-ae0b-65f1d8d1d268",
      "code": "class Solution:\n  def fractionAddition(self, expression: str) -> str:\n    ints = list(map(int, re.findall('[+-]?[0-9]+', expression)))\n    A = 0\n    B = 1\n\n    for a, b in zip(ints[::2], ints[1::2]):\n      A = A * b + a * B\n      B *= b\n      g = math.gcd(A, B)\n      A //= g\n      B //= g\n\n    return str(A) + '/' + str(B)",
      "title": "592. Fraction Addition and Subtraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7c72542-605b-4043-816d-afee68274f1f",
      "code": "class Solution:\n  def validSquare(\n      self,\n      p1: list[int],\n      p2: list[int],\n      p3: list[int],\n      p4: list[int],\n  ) -> bool:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return (p1[0] - p2[0])**2 + (p1[1] - p2[1])**2\n\n    distSet = set([dist(*pair)\n                   for pair in list(\n                       itertools.combinations([p1, p2, p3, p4], 2))])\n    return 0 not in distSet and len(distSet) == 2",
      "title": "593. Valid Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50ed62a5-d443-41e8-9c59-34fa02e933ed",
      "code": "class Solution:\n  def findLHS(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num + 1 in count:\n        ans = max(ans, freq + count[num + 1])\n\n    return ans",
      "title": "594. Longest Harmonious Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28e7419d-3eda-4e12-8fe5-96146c0b22ad",
      "code": "class Solution:\n  def maxCount(self, m: int, n: int, ops: list[list[int]]) -> int:\n    minY = m\n    minX = n\n\n    for y, x in ops:\n      minY = min(minY, y)\n      minX = min(minX, x)\n\n    return minX * minY",
      "title": "598. Range Addition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30ed056a-2c1a-4fa6-bd1f-06ec93e88a89",
      "code": "class Solution:\n  def findRestaurant(self, list1: list[str], list2: list[str]) -> list[str]:\n    ans = []\n    restaurantToIndex = {restaurant: i for i,\n                         restaurant in enumerate(list1)}\n    minSum = math.inf\n\n    for i, restaurant in enumerate(list2):\n      if restaurant in restaurantToIndex:\n        summ = restaurantToIndex[restaurant] + i\n        if summ < minSum:\n          ans.clear()\n        if summ <= minSum:\n          ans.append(restaurant)\n          minSum = summ\n\n    return ans",
      "title": "599. Minimum Index Sum of Two Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "130b2b34-4fec-4232-83cc-2cfd78a66391",
      "code": "class Solution:\n  def canPlaceFlowers(self, flowerbed: list[int], n: int) -> bool:\n    for i, flower in enumerate(flowerbed):\n      if flower == 0 and (\n              i == 0 or flowerbed[i - 1] == 0) and (\n              i == len(flowerbed) - 1 or flowerbed[i + 1] == 0):\n        flowerbed[i] = 1\n        n -= 1\n      if n <= 0:\n        return True\n\n    return False",
      "title": "605. Can Place Flowers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d151603-daa0-4214-a1b7-140e7fdd7d72",
      "code": "class Solution:\n  def tree2str(self, t: TreeNode | None) -> str:\n    def dfs(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n      if root.right:\n        return str(root.val) + '(' + dfs(root.left) + ')(' + dfs(root.right) + ')'\n      if root.left:\n        return str(root.val) + '(' + dfs(root.left) + ')'\n      return str(root.val)\n    return dfs(t)",
      "title": "606. Construct String from Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6eeb0c7-a36b-4620-8684-18c86ccbf579",
      "code": "class Solution:\n  def findDuplicate(self, paths: list[str]) -> list[list[str]]:\n    contentToPathFiles = collections.defaultdict(list)\n\n    for path in paths:\n      words = path.split(' ')\n      rootPath = words[0]  # \"root/d1/d2/.../dm\"\n      for fileAndContent in words[1:]:  # \"fn.txt(fn_content)\"\n        l = fileAndContent.find('(')\n        r = fileAndContent.find(')')\n        # \"fn.txt\"\n        file = fileAndContent[:l]\n        # \"fn_content\"\n        content = fileAndContent[l + 1:r]\n        # \"root/d1/d2/.../dm/fn.txt\"\n        filePath = rootPath + '/' + file\n        contentToPathFiles[content].append(filePath)\n\n    return [filePath for filePath in contentToPathFiles.values() if len(filePath) > 1]",
      "title": "609. Find Duplicate File in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a0011b1-bc8c-40f1-9a46-5501a9e853ed",
      "code": "class Solution:\n  def triangleNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for k in range(len(nums) - 1, 1, -1):\n      i = 0\n      j = k - 1\n      while i < j:\n        if nums[i] + nums[j] > nums[k]:\n          ans += j - i\n          j -= 1\n        else:\n          i += 1\n\n    return ans",
      "title": "611. Valid Triangle Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52335e67-f72b-4086-a277-74238aa4e550",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def addBoldTag(self, s: str, words: list[str]) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        if s[j] not in node.children:\n          node.children[s[j]] = TrieNode()\n        node = node.children[s[j]]\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "616. Add Bold Tag in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b0ab78f-5d3a-467a-99d0-bd917f436495",
      "code": "class Solution:\n  def mergeTrees(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n  ) -> TreeNode | None:\n    if not root1 and not root2:\n      return None\n    val = (root1.val if root1 else 0) + (root2.val if root2 else 0)\n    root = TreeNode(val)\n    root.left = self.mergeTrees(root1.left if root1 else None,\n                                root2.left if root2 else None)\n    root.right = self.mergeTrees(root1.right if root1 else None,\n                                 root2.right if root2 else None)\n    return root",
      "title": "617. Merge Two Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db5676ed-8c8a-480c-b417-7aee5ed75f87",
      "code": "class Solution:\n  def leastInterval(self, tasks: list[str], n: int) -> int:\n    count = collections.Counter(tasks)\n    maxFreq = max(count.values())\n    # Put the most frequent task in the slot first.\n    maxFreqTaskOccupy = (maxFreq - 1) * (n + 1)\n    # Get the number of tasks with same frequency as maxFreq, we'll append them after the\n    # `maxFreqTaskOccupy`.\n    nMaxFreq = sum(value == maxFreq for value in count.values())\n    # max(\n    #   the most frequent task is frequent enough to force some idle slots,\n    #   the most frequent task is not frequent enough to force idle slots\n    # )\n    return max(maxFreqTaskOccupy + nMaxFreq, len(tasks))",
      "title": "621. Task Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c9edbbf-ceef-42af-97c8-4378b7ea10f1",
      "code": "class Solution:\n  def maxDistance(self, arrays: list[list[int]]) -> int:\n    min1, index_min1 = min((A[0], i) for i, A in enumerate(arrays))\n    max1, index_max1 = max((A[-1], i) for i, A in enumerate(arrays))\n    if index_min1 != index_max1:\n      return max1 - min1\n\n    min2, index_min2 = min((A[0], i)\n                           for i, A in enumerate(arrays) if i != index_min1)\n    max2, index_min2 = max((A[-1], i)\n                           for i, A in enumerate(arrays) if i != index_max1)\n    return max(max1 - min2, max2 - min1)",
      "title": "624. Maximum Distance in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "381839f9-64d6-4b2a-99b4-95c9878dcd41",
      "code": "class Solution:\n  def smallestFactorization(self, num: int) -> int:\n    if num == 1:\n      return 1\n\n    ans = 0\n    base = 1\n\n    for i in range(9, 1, -1):\n      while num % i == 0:\n        num //= i\n        ans = base * i + ans\n        base *= 10\n\n    return ans if num == 1 and ans < 2**31 - 1 else 0",
      "title": "625. Minimum Factorization",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31d81ce1-ccb9-4c91-9c6f-d13c07e71e63",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int]) -> int:\n    min1 = inf   # the minimum\n    min2 = inf   # the second minimum\n    max1 = -inf  # the maximum\n    max2 = -inf  # the second maximum\n    max3 = -inf  # the third maximum\n\n    for num in nums:\n      if num <= min1:\n        min2 = min1\n        min1 = num\n      elif num <= min2:\n        min2 = num\n\n      if num >= max1:\n        max3 = max2\n        max2 = max1\n        max1 = num\n      elif num >= max2:\n        max3 = max2\n        max2 = num\n      elif num >= max3:\n        max3 = num\n\n    return max(max1 * min1 * min2, max1 * max2 * max3)",
      "title": "628. Maximum Product of Three Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8bac931-defd-4378-bf61-24251ac3c320",
      "code": "class Solution:\n  def kInversePairs(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of permutations of numbers 1..i with j inverse pairs\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    # If there's no inverse pair, the permutation is unique '123..i'\n    for i in range(n + 1):\n      dp[i][0] = 1\n\n    for i in range(1, n + 1):\n      for j in range(1, k + 1):\n        dp[i][j] = (dp[i][j - 1] + dp[i - 1][j]) % MOD\n        if j - i >= 0:\n          dp[i][j] = (dp[i][j] - dp[i - 1][j - i] + MOD) % MOD\n\n    return dp[n][k]",
      "title": "629. K Inverse Pairs Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21bf13e8-51e7-45df-87d2-478cdfd2a9eb",
      "code": "class Solution:\n  def scheduleCourse(self, courses: list[list[int]]) -> int:\n    time = 0\n    maxHeap = []\n\n    for duration, lastDay in sorted(courses, key=lambda x: x[1]):\n      heapq.heappush(maxHeap, -duration)\n      time += duration\n      # If the current course cannot be taken, check if it can be swapped with\n      # a previously taken course that has a larger duration to increase the\n      # time available to take upcoming courses.\n      if time > lastDay:\n        time += heapq.heappop(maxHeap)\n\n    return len(maxHeap)",
      "title": "630. Course Schedule III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b979f444-155b-414b-9c3d-eccbe4b60ab2",
      "code": "class Solution:\n  def smallestRange(self, nums: list[list[int]]) -> list[int]:\n    minHeap = [(row[0], i, 0) for i, row in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    maxRange = max(row[0] for row in nums)\n    minRange = heapq.nsmallest(1, minHeap)[0][0]\n    ans = [minRange, maxRange]\n\n    while len(minHeap) == len(nums):\n      num, r, c = heapq.heappop(minHeap)\n      if c + 1 < len(nums[r]):\n        heapq.heappush(minHeap, (nums[r][c + 1], r, c + 1))\n        maxRange = max(maxRange, nums[r][c + 1])\n        minRange = heapq.nsmallest(1, minHeap)[0][0]\n        if maxRange - minRange < ans[1] - ans[0]:\n          ans[0], ans[1] = minRange, maxRange\n\n    return ans",
      "title": "632. Smallest Range Covering Elements from K Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2ad20fd-5341-4d36-90ba-1de2d92245fc",
      "code": "class Solution:\n  def judgeSquareSum(self, c: int) -> bool:\n    l = 0\n    r = math.isqrt(c)\n\n    while l <= r:\n      summ = l * l + r * r\n      if summ == c:\n        return True\n      if summ < c:\n        l += 1\n      else:\n        r -= 1\n\n    return False",
      "title": "633. Sum of Square Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b71f13a-9575-4b75-a894-30a6d29f7eaa",
      "code": "class Solution:\n  def findDerangement(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      if i == 0:\n        return 1\n      if i == 1:\n        return 0\n      return (i - 1) * (dp(i - 1) + dp(i - 2)) % MOD\n\n    return dp(n)",
      "title": "634. Find the Derangement of An Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6afa5594-02e4-452c-a378-a0243711c1fa",
      "code": "class Solution:\n  def shoppingOffers(\n      self,\n      price: list[int],\n      special: list[list[int]],\n      needs: list[int]\n  ) -> int:\n    def dfs(s: int) -> int:\n      ans = 0\n      for i, need in enumerate(needs):\n        ans += need * price[i]\n\n      for i in range(s, len(special)):\n        offer = special[i]\n        if all(offer[j] <= need for j, need in enumerate(needs)):\n          # Use the special[i].\n          for j in range(len(needs)):\n            needs[j] -= offer[j]\n          ans = min(ans, offer[-1] + dfs(i))\n          # Unuse the special[i] (backtracking).\n          for j in range(len(needs)):\n            needs[j] += offer[j]\n\n      return ans\n\n    return dfs(0)",
      "title": "638. Shopping Offers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8849e23d-2be4-4602-96b7-f0df8ec081cb",
      "code": "class Solution:\n  def solveEquation(self, equation: str) -> str:\n    def calculate(s: str) -> tuple:\n      coefficient = 0\n      constant = 0\n      num = 0\n      sign = 1\n\n      for i, c in enumerate(s):\n        if c.isdigit():\n          num = num * 10 + int(c)\n        elif c in '+-':\n          constant += sign * num\n          sign = 1 if c == '+' else -1\n          num = 0\n        else:\n          if i > 0 and num == 0 and s[i - 1] == '0':\n            continue\n          coefficient += sign if num == 0 else sign * num\n          num = 0\n\n      return coefficient, constant + sign * num\n\n    lhsEquation, rhsEquation = equation.split('=')\n    lhsCoefficient, lhsConstant = calculate(lhsEquation)\n    rhsCoefficient, rhsConstant = calculate(rhsEquation)\n    coefficient = lhsCoefficient - rhsCoefficient\n    constant = rhsConstant - lhsConstant\n\n    if coefficient == 0 and constant == 0:\n      return \"Infinite solutions\"\n    if coefficient == 0 and constant != 0:\n      return \"No solution\"\n    return \"x=\" + str(constant // coefficient)",
      "title": "640. Solve the Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a25bed3-a68a-46b3-83e0-d8172ebf062f",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    summ = sum(nums[:k])\n    ans = summ\n\n    for i in range(k, len(nums)):\n      summ += nums[i] - nums[i - k]\n      ans = max(ans, summ)\n\n    return ans / k",
      "title": "643. Maximum Average Subarray I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b30109a-95e8-4e3d-8cdc-85ab265ecee7",
      "code": "class Solution:\n  def findMaxAverage(self, nums: list[int], k: int) -> float:\n    ERR = 1e-5\n    l = min(nums)\n    r = max(nums)\n\n    def check(m: float) -> bool:\n      \"\"\"\n      Returns True if there's a subarray, where its length >= k and its average\n      sum >= m.\n      \"\"\"\n      summ = 0\n      prevSum = 0\n      minPrevSum = 0\n\n      for i, num in enumerate(nums):\n        # Need to substract m for each `num` so that we can check if the sum of\n        # the subarray >= 0.\n        summ += num - m\n        if i >= k:\n          prevSum += nums[i - k] - m\n          minPrevSum = min(minPrevSum, prevSum)\n        if i + 1 >= k and summ >= minPrevSum:\n          return True\n\n      return False\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if check(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "644. Maximum Average Subarray II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88518217-17e3-4634-a503-197e7d615410",
      "code": "class Solution:\n  def findErrorNums(self, nums: list[int]) -> list[int]:\n    for num in nums:\n      if nums[abs(num) - 1] < 0:\n        duplicate = abs(num)\n      else:\n        nums[abs(num) - 1] *= -1\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        return [duplicate, i + 1]",
      "title": "645. Set Mismatch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87baa634-a6d7-4c87-8007-005e39f185a5",
      "code": "class Solution:\n  def findLongestChain(self, pairs: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = -math.inf\n\n    for s, e in sorted(pairs, key=lambda x: x[1]):\n      if s > prevEnd:\n        ans += 1\n        prevEnd = e\n\n    return ans",
      "title": "646. Maximum Length of Pair Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf1a0d91-c53a-40eb-be70-1e23bf8dfcc4",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    def extendPalindromes(l: int, r: int) -> int:\n      count = 0\n\n      while l >= 0 and r < len(s) and s[l] == s[r]:\n        count += 1\n        l -= 1\n        r += 1\n\n      return count\n\n    ans = 0\n\n    for i in range(len(s)):\n      ans += extendPalindromes(i, i)\n      ans += extendPalindromes(i, i + 1)\n\n    return ans",
      "title": "647. Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e183ff14-f9ce-4e3b-bc97-a4ad570123e1",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['word'] = word\n\n  def search(self, word: str) -> str:\n    node = self.root\n    for c in word:\n      if 'word' in node:\n        return node['word']\n      if c not in node:\n        return word\n      node = node[c]\n    return word\n\n  def replaceWords(self, dictionary: list[str], sentence: str) -> str:\n    for word in dictionary:\n      self.insert(word)\n\n    words = sentence.split(' ')\n    return ' '.join([self.search(word) for word in words])",
      "title": "648. Replace Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5078b2d1-2689-4c4f-8fbe-569ea1fc6970",
      "code": "class Solution:\n  def minSteps(self, n: int) -> int:\n    if n <= 1:\n      return 0\n\n    # dp[i] := the minimum steps to get i 'A's\n    # Copy 'A', then paste 'A' i - 1 times.\n    dp = [i for i in range(n + 1)]\n\n    for i in range(2, n + 1):\n      for j in range(i // 2, 2, -1):\n        if i % j == 0:\n          dp[i] = dp[j] + i // j  # Paste dp[j] i / j times.\n          break\n\n    return dp[n]",
      "title": "650. 2 Keys Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "129e2982-9e1d-4597-ab1d-029f9f45089f",
      "code": "class Solution:\n  def findDuplicateSubtrees(self, root: TreeNode | None) -> list[TreeNode | None]:\n    ans = []\n    count = collections.Counter()\n\n    def encode(root: TreeNode | None) -> str:\n      if not root:\n        return ''\n\n      encoded = (str(root.val) + '#' +\n                 encode(root.left) + '#' +\n                 encode(root.right))\n      count[encoded] += 1\n      if count[encoded] == 2:\n        ans.append(root)\n      return encoded\n\n    encode(root)\n    return ans",
      "title": "652. Find Duplicate Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0156f5b-c130-4d2c-bc12-4965007d2842",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def findTarget(self, root: TreeNode | None, k: int) -> bool:\n    if not root:\n      return False\n\n    left = BSTIterator(root, True)\n    right = BSTIterator(root, False)\n\n    l = left.next()\n    r = right.next()\n    while l < r:\n      summ = l + r\n      if summ == k:\n        return True\n      if summ < k:\n        l = left.next()\n      else:\n        r = right.next()\n\n    return False",
      "title": "653. Two Sum IV - Input is a BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9233d907-232a-4d30-8237-76b36cc42d42",
      "code": "class Solution:\n  def constructMaximumBinaryTree(self, nums: list[int]) -> TreeNode | None:\n    def build(i: int, j: int) -> TreeNode | None:\n      if i > j:\n        return None\n\n      maxNum = max(nums[i:j + 1])\n      maxIndex = nums.index(maxNum)\n\n      root = TreeNode(maxNum)\n      root.left = build(i, maxIndex - 1)\n      root.right = build(maxIndex + 1, j)\n      return root\n\n    return build(0, len(nums) - 1)",
      "title": "654. Maximum Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35489ab5-02cd-4c8a-a7a1-73f0649340ef",
      "code": "class Solution:\n  def printTree(self, root: TreeNode | None) -> list[list[str]]:\n    def maxHeight(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(maxHeight(root.left), maxHeight(root.right))\n\n    def dfs(root: TreeNode | None, row: int, left: int, right: int) -> None:\n      if not root:\n        return\n\n      mid = (left + right) // 2\n      ans[row][mid] = str(root.val)\n      dfs(root.left, row + 1, left, mid - 1)\n      dfs(root.right, row + 1, mid + 1, right)\n\n    m = maxHeight(root)\n    n = pow(2, m) - 1\n    ans = [[''] * n for _ in range(m)]\n    dfs(root, 0, 0, len(ans[0]) - 1)\n    return ans",
      "title": "655. Print Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f0daa3b2-6a9c-411b-955e-21c04030653c",
      "code": "class Solution:\n  def cheapestJump(self, coins: list[int], maxJump: int) -> list[int]:\n    if coins[-1] == -1:\n      return []\n\n    n = len(coins)\n    # dp[i] := the minimum cost to jump from i to n - 1\n    dp = [math.inf] * n\n    next = [-1] * n\n\n    def cheapestJump(i: int) -> int:\n      if i == len(coins) - 1:\n        dp[i] = coins[i]\n        return dp[i]\n      if dp[i] < math.inf:\n        return dp[i]\n      if coins[i] == -1:\n        return math.inf\n\n      for j in range(i + 1, min(i + maxJump + 1, n)):\n        res = cheapestJump(j)\n        if res == math.inf:\n          continue\n        cost = coins[i] + res\n        if cost < dp[i]:\n          dp[i] = cost\n          next[i] = j\n\n      return dp[i]\n\n    cheapestJump(0)\n    if dp[0] == math.inf:\n      return []\n    return self._constructPath(next, 0)\n\n  def _constructPath(self, next: list[int], i: int) -> list[int]:\n    ans = []\n    while i != -1:\n      ans.append(i + 1)  # 1-indexed\n      i = next[i]\n    return ans",
      "title": "656. Coin Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7996ee4-f9a6-45c1-8f31-a576bbbf07ad",
      "code": "class Solution:\n  def judgeCircle(self, moves: str) -> bool:\n    return moves.count('R') == moves.count('L') and moves.count('U') == moves.count('D')",
      "title": "657. Robot Return to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be6c7ad5-5c99-474f-a277-39d833b75bcd",
      "code": "class Solution:\n  def findClosestElements(self, arr: list[int], k: int, x: int) -> list[int]:\n    l = 0\n    r = len(arr) - k\n\n    while l < r:\n      m = (l + r) // 2\n      if x - arr[m] <= arr[m + k] - x:\n        r = m\n      else:\n        l = m + 1\n\n    return arr[l:l + k]",
      "title": "658. Find K Closest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5b6381b-b22c-4bbd-a715-ffbb297ffb8b",
      "code": "class Solution:\n  def newInteger(self, n: int) -> int:\n    ans = []\n    while n:\n      ans.append(str(n % 9))\n      n //= 9\n    return ''.join(reversed(ans))",
      "title": "660. Remove 9",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10ef2e51-7897-469a-887b-0487c242fac5",
      "code": "class Solution:\n  def imageSmoother(self, M: list[list[int]]) -> list[list[int]]:\n    m = len(M)\n    n = len(M[0])\n    ans = [[0 for j in range(n)] for i in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ones = 0\n        count = 0\n        for y in range(max(0, i - 1), min(m, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            ones += M[y][x]\n            count += 1\n        ans[i][j] = ones // count\n\n    return ans",
      "title": "661. Image Smoother",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f984c480-beba-42a6-8732-998a94ca0a97",
      "code": "class Solution:\n  def checkEqualTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n\n    seen = set()\n\n    def dfs(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n\n      summ = root.val + dfs(root.left) + dfs(root.right)\n      seen.add(summ)\n      return summ\n\n    summ = root.val + dfs(root.left) + dfs(root.right)\n    return summ % 2 == 0 and summ // 2 in seen",
      "title": "663. Equal Tree Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c6ec577-4f05-4b8e-8018-fb24a93b1806",
      "code": "class Solution:\n  def checkPossibility(self, nums: list[int]) -> bool:\n    j = None\n\n    for i in range(len(nums) - 1):\n      if nums[i] > nums[i + 1]:\n        if j is not None:\n          return False\n        j = i\n\n    return (j is None or j == 0 or j == len(nums) - 2 or\n            nums[j - 1] <= nums[j + 1] or nums[j] <= nums[j + 2])",
      "title": "665. Non-decreasing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c5d1cd0-bb8f-4748-a35e-07bf454f3b46",
      "code": "class Solution:\n  def pathSum(self, nums: list[int]) -> int:\n    ans = 0\n    tree = [[-1] * 8 for _ in range(4)]\n\n    for num in nums:\n      d = num // 100 - 1\n      p = (num % 100) // 10 - 1\n      v = num % 10\n      tree[d][p] = v\n\n    def dfs(i: int, j: int, path: int) -> None:\n      nonlocal ans\n      if tree[i][j] == -1:\n        return\n      if i == 3 or max(tree[i + 1][j * 2], tree[i + 1][j * 2 + 1]) == -1:\n        ans += path + tree[i][j]\n        return\n\n      dfs(i + 1, j * 2, path + tree[i][j])\n      dfs(i + 1, j * 2 + 1, path + tree[i][j])\n\n    dfs(0, 0, 0)\n    return ans",
      "title": "666. Path Sum IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd500cc3-12a3-40db-af6f-fb4e05587524",
      "code": "class Solution:\n  def constructArray(self, n: int, k: int) -> list[int]:\n    ans = list(range(1, n - k + 1))\n\n    for i in range(k):\n      if i % 2 == 0:\n        ans.append(n - i // 2)\n      else:\n        ans.append(n - k + (i + 1) // 2)\n\n    return ans",
      "title": "667. Beautiful Arrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3c93b64-86a1-4d74-9340-b7f0dc4ac808",
      "code": "class Solution:\n  def maximumSwap(self, num: int) -> int:\n    s = list(str(num))\n    dict = {c: i for i, c in enumerate(s)}\n\n    for i, c in enumerate(s):\n      for digit in reversed(string.digits):\n        if digit <= c:\n          break\n        if digit in dict and dict[digit] > i:\n          s[i], s[dict[digit]] = digit, s[i]\n          return int(''.join(s))\n\n    return num",
      "title": "670. Maximum Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c23bfa2-ccae-4eb6-8fb3-8ae337923539",
      "code": "class Solution:\n  def flipLights(self, n: int, m: int) -> int:\n    n = min(n, 3)\n\n    if m == 0:\n      return 1\n    if m == 1:\n      return [2, 3, 4][n - 1]\n    if m == 2:\n      return [2, 4, 7][n - 1]\n\n    return [2, 4, 8][n - 1]",
      "title": "672. Bulb Switcher II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18997ea2-906f-47c8-80c5-aafb5916e0e1",
      "code": "class Solution:\n  def findNumberOfLIS(self, nums: list[int]) -> int:\n    ans = 0\n    maxLength = 0\n    # length[i] := the length of the LIS ending in nums[i]\n    length = [1] * len(nums)\n    # count[i] := the number of LIS's ending in nums[i]\n    count = [1] * len(nums)\n\n    # Calculate the `length` and `count` arrays.\n    for i, num in enumerate(nums):\n      for j in range(i):\n        if nums[j] < num:\n          if length[i] < length[j] + 1:\n            length[i] = length[j] + 1\n            count[i] = count[j]\n          elif length[i] == length[j] + 1:\n            count[i] += count[j]\n\n    # Get the number of LIS.\n    for i, l in enumerate(length):\n      if l > maxLength:\n        maxLength = l\n        ans = count[i]\n      elif l == maxLength:\n        ans += count[i]\n\n    return ans",
      "title": "673. Number of Longest Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "938085bc-9312-4cb8-a74b-270b1e822ea2",
      "code": "class Solution:\n  def findLengthOfLCIS(self, nums: list[int]) -> int:\n    ans = 0\n    j = 0\n\n    for i in range(len(nums)):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        j = i\n      ans = max(ans, i - j + 1)\n\n    return ans",
      "title": "674. Longest Continuous Increasing Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14a99c15-e02a-49e4-8253-4eacaadacaa2",
      "code": "class Solution:\n  def checkValidString(self, s: str) -> bool:\n    low = 0\n    high = 0\n\n    for c in s:\n      if c == '(':\n        low += 1\n        high += 1\n      elif c == ')':\n        if low > 0:\n          low -= 1\n        high -= 1\n      else:\n        if low > 0:\n          low -= 1\n        high += 1\n      if high < 0:\n        return False\n\n    return low == 0",
      "title": "678. Valid Parenthesis String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5b9060b-0729-41d4-8a6f-3c88086e8346",
      "code": "class Solution:\n  def judgePoint24(self, nums: list[int]) -> bool:\n    def generate(a: float, b: float) -> list[float]:\n      return [a * b,\n              math.inf if b == 0 else a / b,\n              math.inf if a == 0 else b / a,\n              a + b, a - b, b - a]\n\n    def dfs(nums: list[float]) -> bool:\n      if len(nums) == 1:\n        return abs(nums[0] - 24.0) < 0.001\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        for num in generate(nums[i], nums[j]):\n          nextRound = [num]\n          for k in range(len(nums)):\n            if k == i or k == j:\n              continue\n            nextRound.append(nums[k])\n          if dfs(nextRound):\n            return True\n\n      return False\n\n    return dfs(nums)",
      "title": "679. 24 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f053a291-a119-4b02-80e8-b2a90cad69ee",
      "code": "class Solution:\n  def validPalindrome(self, s: str) -> bool:\n    def validPalindrome(l: int, r: int) -> bool:\n      return all(s[i] == s[r - i + l] for i in range(l, (l + r) // 2 + 1))\n\n    n = len(s)\n\n    for i in range(n // 2):\n      if s[i] != s[~i]:\n        return validPalindrome(i + 1, n - 1 - i) or validPalindrome(i, n - 2 - i)\n\n    return True",
      "title": "680. Valid Palindrome II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69544cd8-9189-4158-aba5-7ad0b3d790f8",
      "code": "class Solution:\n  def nextClosestTime(self, time: str) -> str:\n    ans = list(time)\n    digits = sorted(ans)\n\n    def nextClosest(digit: str, limit: str) -> str:\n      next = bisect_right(digits, digit)\n      return digits[0] if next == 4 or digits[next] > limit else digits[next]\n\n    ans[4] = nextClosest(ans[4], '9')\n    if time[4] < ans[4]:\n      return ''.join(ans)\n\n    ans[3] = nextClosest(ans[3], '5')\n    if time[3] < ans[3]:\n      return ''.join(ans)\n\n    ans[1] = nextClosest(ans[1], '3' if ans[0] == '2' else '9')\n    if time[1] < ans[1]:\n      return ''.join(ans)\n\n    ans[0] = nextClosest(ans[0], '2')\n    return ''.join(ans)",
      "title": "681. Next Closest Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f5e14b0-f98f-4f50-b507-5ea9943bdd98",
      "code": "class Solution:\n  def calPoints(self, operations: list[str]) -> int:\n    scores = []\n\n    for operation in operations:\n      match operation:\n        case '+':\n          scores.append(scores[-1] + scores[-2])\n        case 'D':\n          scores.append(scores[-1] * 2)\n        case 'C':\n          scores.pop()\n        case default:\n          scores.append(int(operation))\n\n    return sum(scores)",
      "title": "682. Baseball Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f901cbd-ef07-44fc-b1df-91d624ec3800",
      "code": "class Solution:\n  def kEmptySlots(self, bulbs: list[int], k: int) -> int:\n    n = len(bulbs)\n    ans = math.inf\n    # day[i] := the day when bulbs[i] is turned on\n    day = [0] * n\n\n    for i, bulb in enumerate(bulbs):\n      day[bulb - 1] = i + 1\n\n    # Find a subarray of day[l..r], where its length is k + 2.\n    # For each l < i < r, day[i] > max(day[l], day[r]).\n    l = 0\n    r = l + k + 1\n    i = 1\n    while r < n:\n      if i == r:\n        ans = min(ans, max(day[l], day[r]))\n        l = i\n        r = i + k + 1\n      elif day[i] < max(day[l], day[r]):\n        l = i\n        r = i + k + 1\n      i += 1\n\n    return -1 if ans == math.inf else ans",
      "title": "683. K Empty Slots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0e87f74-ba58-4b46-b399-f6e416835503",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantConnection(self, edges: list[list[int]]) -> list[int]:\n    uf = UnionFind(len(edges) + 1)\n\n    for edge in edges:\n      u, v = edge\n      if not uf.unionByRank(u, v):\n        return edge",
      "title": "684. Redundant Connection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "764d1180-7ede-4151-9d92-56c736f18ef7",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findRedundantDirectedConnection(\n      self, edges: list[list[int]],\n  ) -> list[int]:\n    ids = [0] * (len(edges) + 1)\n    nodeWithTwoParents = 0\n\n    for _, v in edges:\n      ids[v] += 1\n      if ids[v] == 2:\n        nodeWithTwoParents = v\n\n    def findRedundantDirectedConnection(skippedEdgeIndex: int) -> list[int]:\n      uf = UnionFind(len(edges) + 1)\n\n      for i, edge in enumerate(edges):\n        if i == skippedEdgeIndex:\n          continue\n        if not uf.unionByRank(edge[0], edge[1]):\n          return edge\n\n      return []\n\n    # If there is no edge with two ids, don't skip any edge.\n    if nodeWithTwoParents == 0:\n      return findRedundantDirectedConnection(-1)\n\n    for i in reversed(range(len(edges))):\n      _, v = edges[i]\n      if v == nodeWithTwoParents:\n        # Try to delete the edges[i].\n        if not findRedundantDirectedConnection(i):\n          return edges[i]",
      "title": "685. Redundant Connection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "778cf5e9-e540-452f-b2ab-643ae8080058",
      "code": "class Solution:\n  def repeatedStringMatch(self, a: str, b: str) -> int:\n    n = math.ceil(len(b) / len(a))\n    s = a * n\n    if b in s:\n      return n\n    if b in s + a:\n      return n + 1\n    return -1",
      "title": "686. Repeated String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f62e2a02-588f-4370-8416-9061119cb86e",
      "code": "class Solution:\n  def longestUnivaluePath(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def longestUnivaluePathDownFrom(root: TreeNode | None) -> int:\n      nonlocal ans\n      if not root:\n        return 0\n\n      l = longestUnivaluePathDownFrom(root.left)\n      r = longestUnivaluePathDownFrom(root.right)\n      arrowLeft = l + 1 if root.left and root.left.val == root.val else 0\n      arrowRight = r + 1 if root.right and root.right.val == root.val else 0\n      ans = max(ans, arrowLeft + arrowRight)\n      return max(arrowLeft, arrowRight)\n\n    longestUnivaluePathDownFrom(root)\n    return ans",
      "title": "687. Longest Univalue Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9082a256-3b3b-4bb2-87bc-92bd102978a0",
      "code": "class Solution:\n  def knightProbability(self, n: int, k: int, row: int, column: int) -> float:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    # dp[i][j] := the probability to stand on (i, j)\n    dp = [[0] * n for _ in range(n)]\n    dp[row][column] = 1.0\n\n    for _ in range(k):\n      newDp = [[0] * n for _ in range(n)]\n      for i in range(n):\n        for j in range(n):\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if 0 <= x < n and 0 <= y < n:\n              newDp[i][j] += dp[x][y]\n      dp = newDp\n\n    return sum(map(sum, dp)) / 8**k",
      "title": "688. Knight Probability in Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae1e4cfd-7fd0-4433-839a-73e12faf681a",
      "code": "class Solution:\n  def maxSumOfThreeSubarrays(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums) - k + 1\n    # sums[i] := sum(nums[i..i + k))\n    sums = [0] * n\n    # l[i] := the index in [0..i] that has the maximum sums[i]\n    l = [0] * n\n    # r[i] := the index in [i..n) that has the maximum sums[i]\n    r = [0] * n\n\n    summ = 0\n    for i, num in enumerate(nums):\n      summ += num\n      if i >= k:\n        summ -= nums[i - k]\n      if i >= k - 1:\n        sums[i - k + 1] = summ\n\n    maxIndex = 0\n    for i in range(n):\n      if sums[i] > sums[maxIndex]:\n        maxIndex = i\n      l[i] = maxIndex\n\n    maxIndex = n - 1\n    for i in range(n - 1, -1, -1):\n      if sums[i] >= sums[maxIndex]:\n        maxIndex = i\n      r[i] = maxIndex\n\n    ans = [-1, -1, -1]\n\n    for i in range(k, n - k):\n      if (ans[0] == -1 or\n          sums[ans[0]] + sums[ans[1]] + sums[ans[2]] <\n              sums[l[i - k]] + sums[i] + sums[r[i + k]]):\n        ans[0] = l[i - k]\n        ans[1] = i\n        ans[2] = r[i + k]\n\n    return ans",
      "title": "689. Maximum Sum of 3 Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a6f5882-8130-4079-9daa-23510789ec4d",
      "code": "class Solution:\n  def getImportance(self, employees: list['Employee'], id: int) -> int:\n    idToEmployee = {employee.id: employee for employee in employees}\n\n    def dfs(id: int) -> int:\n      values = idToEmployee[id].importance\n      for subId in idToEmployee[id].subordinates:\n        values += dfs(subId)\n      return values\n\n    return dfs(id)",
      "title": "690. Employee Importance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f6bfb94-3786-40e3-ad32-e5846f92622e",
      "code": "class Solution:\n  def minStickers(self, stickers: list[str], target: str) -> int:\n    maxMask = 1 << len(target)\n    # dp[i] := the minimum number of stickers to spell out i, where i is the\n    # bit mask of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(maxMask):\n      if dp[mask] == math.inf:\n        continue\n      # Try to expand from `mask` by using each sticker.\n      for sticker in stickers:\n        superMask = mask\n        for c in sticker:\n          for i, t in enumerate(target):\n            # Try to apply it on a missing letter.\n            if c == t and not (superMask >> i & 1):\n              superMask |= 1 << i\n              break\n        dp[superMask] = min(dp[superMask], dp[mask] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "691. Stickers to Spell Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "137634b6-d9d7-4b7c-9e23-72f7cab429ab",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  word: str\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.word > other.word\n    return self.freq < other.freq\n\n\nclass Solution:\n  def topKFrequent(self, words: list[str], k: int) -> list[str]:\n    ans = []\n    heap = []\n\n    for word, freq in collections.Counter(words).items():\n      heapq.heappush(heap, T(word, freq))\n      if len(heap) > k:\n        heapq.heappop(heap)\n\n    while heap:\n      ans.append(heapq.heappop(heap).word)\n\n    return ans[::-1]",
      "title": "692. Top K Frequent Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfe16dc2-6f3b-4ded-a2fa-f8893b07bd02",
      "code": "class Solution:\n  def hasAlternatingBits(self, n: int) -> bool:\n    #            n = 0b010101\n    #       n >> 2 = 0b000101\n    # n ^ (n >> 2) = 0b010000 = a\n    #        a - 1 = 0b001111\n    #  a & (a - 1) = 0\n    a = n ^ (n >> 2)\n    return (a & (a - 1)) == 0",
      "title": "693. Binary Number with Alternating Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c081a583-d4e8-49e4-9b96-9ac6371f95cf",
      "code": "class Solution:\n  def numDistinctIslands(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int, i0: int, j0: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i - i0, j - j0))\n      dfs(i + 1, j, i0, j0)\n      dfs(i - 1, j, i0, j0)\n      dfs(i, j + 1, i0, j0)\n      dfs(i, j - 1, i0, j0)\n\n    islands = set()  # all the different islands\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j, i, j)\n        if island:\n          islands.add(frozenset(island))\n\n    return len(islands)",
      "title": "694. Number of Distinct Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e443756-6293-4d22-a74e-2f5e7ea93133",
      "code": "class Solution:\n  def maxAreaOfIsland(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != 1:\n        return 0\n\n      grid[i][j] = 2\n\n      return 1 + dfs(i + 1, j) + dfs(i - 1, j) + dfs(i, j + 1) + dfs(i, j - 1)\n\n    return max(dfs(i, j) for i in range(len(grid)) for j in range(len(grid[0])))",
      "title": "695. Max Area of Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39f29854-ca04-4a29-a487-7dac31e72d72",
      "code": "class Solution:\n  def countBinarySubstrings(self, s: str) -> int:\n    ans = 0\n    prevCount = 0\n    equals = 1\n\n    for i in range(len(s) - 1):\n      if s[i] == s[i + 1]:\n        equals += 1\n      else:\n        ans += min(prevCount, equals)\n        prevCount = equals\n        equals = 1\n\n    return ans + min(prevCount, equals)",
      "title": "696. Count Binary Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f16128b7-b92a-4f08-99d1-8ec487e488c1",
      "code": "class Solution:\n  def findShortestSubArray(self, nums: list[int]) -> int:\n    ans = 0\n    degree = 0\n    debut = {}\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      debut.setdefault(num, i)\n      count[num] += 1\n      if count[num] > degree:\n        degree = count[num]\n        ans = i - debut[num] + 1\n      elif count[num] == degree:\n        ans = min(ans, i - debut[num] + 1)\n\n    return ans",
      "title": "697. Degree of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c204aa75-6394-43d8-893a-b193919641b3",
      "code": "class Solution:\n  def canPartitionKSubsets(self, nums: list[int], k: int) -> bool:\n    summ = sum(nums)\n    if summ % k != 0:\n      return False\n\n    target = summ // k  # the target sum of each subset\n    if any(num > target for num in nums):\n      return False\n\n    def dfs(s: int, remainingGroups: int, currSum: int, used: int) -> bool:\n      if remainingGroups == 0:\n        return True\n      if currSum > target:\n        return False\n      if currSum == target:  # Find a valid group, so fresh start.\n        return dfs(0, remainingGroups - 1, 0, used)\n\n      for i in range(s, len(nums)):\n        if used >> i & 1:\n          continue\n        if dfs(i + 1, remainingGroups, currSum + nums[i], used | 1 << i):\n          return True\n\n      return False\n\n    nums.sort(reverse=True)\n    return dfs(0, k, 0, 0)",
      "title": "698. Partition to K Equal Sum Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "232fd204-4db4-4b32-952a-71ca77212671",
      "code": "class Solution:\n  def searchBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return None\n    if root.val == val:\n      return root\n    if root.val > val:\n      return self.searchBST(root.left, val)\n    return self.searchBST(root.right, val)",
      "title": "700. Search in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6ad23c8-ed3c-4fb2-aafb-9fa7a07ce5de",
      "code": "class Solution:\n  def insertIntoBST(self, root: TreeNode | None, val: int) -> TreeNode | None:\n    if not root:\n      return TreeNode(val)\n    if root.val > val:\n      root.left = self.insertIntoBST(root.left, val)\n    else:\n      root.right = self.insertIntoBST(root.right, val)\n    return root",
      "title": "701. Insert into a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67df1267-1eb5-4e63-8573-3e6a39e36787",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class ArrayReader:\n#   def get(self, index: int) -> int:\n\nclass Solution:\n  def search(self, reader: 'ArrayReader', target: int) -> int:\n    l = bisect.bisect_left(range(10**4), target,\n                           key=lambda m: reader.get(m))\n    return l if reader.get(l) == target else -1",
      "title": "702. Search in a Sorted Array of Unknown Size",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b67e247-d0b8-4171-bc64-1891388f303c",
      "code": "class Solution:\n  def search(self, nums: list[int], target: int) -> int:\n    i = bisect.bisect_left(nums, target)\n    return -1 if i == len(nums) or nums[i] != target else i",
      "title": "704. Binary Search",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b168e0aa-4edf-4cd1-a565-85c0319e6de7",
      "code": "class Solution:\n  def toLowerCase(self, str: str) -> str:\n    return ''.join(chr(ord(c) + 32) if 'A' <= c <= 'Z' else c for c in str)",
      "title": "709. To Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2ae8a13-5f26-423d-8daa-aff71b3b8432",
      "code": "class Solution:\n  def __init__(self, n: int, blacklist: list[int]):\n    self.validRange = n - len(blacklist)\n    self.dict = {}\n\n    maxAvailable = n - 1\n\n    for b in blacklist:\n      self.dict[b] = -1\n\n    for b in blacklist:\n      if b < self.validRange:\n        # Find the slot that haven't been used.\n        while maxAvailable in self.dict:\n          maxAvailable -= 1\n        self.dict[b] = maxAvailable\n        maxAvailable -= 1\n\n  def pick(self) -> int:\n    value = random.randint(0, self.validRange - 1)\n\n    if value in self.dict:\n      return self.dict[value]\n\n    return value",
      "title": "710. Random Pick with Blacklist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f17d65e-78d6-47fb-9295-e71c0ddd98b6",
      "code": "class Solution:\n  def numDistinctIslands2(self, grid: list[list[int]]) -> int:\n    seen = set()\n\n    def dfs(i: int, j: int):\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] == 0 or (i, j) in seen:\n        return\n\n      seen.add((i, j))\n      island.append((i, j))\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    def normalize(island: list[tuple]) -> list[tuple]:\n      # points[i] := 8 different rotations/reflections of an island\n      points = [[] for _ in range(8)]\n\n      for i, j in island:\n        points[0].append((i, j))\n        points[1].append((i, -j))\n        points[2].append((-i, j))\n        points[3].append((-i, -j))\n        points[4].append((j, i))\n        points[5].append((j, -i))\n        points[6].append((-j, i))\n        points[7].append((-j, -i))\n\n      points = [sorted(p) for p in points]\n\n      # Normalize each p by substracting p[1..7] with p[0].\n      for p in points:\n        for i in range(1, len(island)):\n          p[i] = (p[i][0] - p[0][0],\n                  p[i][1] - p[0][1])\n        p[0] = (0, 0)\n\n      return sorted(points)[0]\n\n    islands = set()  # all the islands with different shapes\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        island = []\n        dfs(i, j)\n        if island:\n          islands.add(frozenset(normalize(island)))\n\n    return len(islands)",
      "title": "711. Number of Distinct Islands II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e61d1d36-d9c7-43dd-9222-c95c0830cdf2",
      "code": "class Solution:\n  def numSubarrayProductLessThanK(self, nums: list[int], k: int) -> int:\n    if k <= 1:\n      return 0\n\n    ans = 0\n    prod = 1\n\n    j = 0\n    for i, num in enumerate(nums):\n      prod *= num\n      while prod >= k:\n        prod /= nums[j]\n        j += 1\n      ans += i - j + 1\n\n    return ans",
      "title": "713. Subarray Product Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d70ea0c0-3136-4e3f-af9b-910183c1b218",
      "code": "class Solution:\n  def maxProfit(self, prices: list[int], fee: int) -> int:\n    sell = 0\n    hold = -math.inf\n\n    for price in prices:\n      sell = max(sell, hold + price)\n      hold = max(hold, sell - price - fee)\n\n    return sell",
      "title": "714. Best Time to Buy and Sell Stock with Transaction Fee",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15b491cd-8a44-467a-9518-3b03ebe19db2",
      "code": "class Solution:\n  def isOneBitCharacter(self, bits: list[int]) -> bool:\n    i = 0\n    while i < len(bits) - 1:\n      i += bits[i] + 1\n\n    return i == len(bits) - 1",
      "title": "717. 1-bit and 2-bit Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29a0b9e6-eccd-4b1c-8f4e-3d21328331d3",
      "code": "class Solution:\n  def findLength(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    ans = 0\n    # dp[i][j] := the maximum length of a subarray that appears in both\n    # nums1[i..m) and nums2[j..n)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        if nums1[i] == nums2[j]:\n          dp[i][j] = dp[i + 1][j + 1] + 1\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "718. Maximum Length of Repeated Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36dbbf8b-f517-4888-9ecf-397d046bdf0c",
      "code": "class Solution:\n  def smallestDistancePair(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    def numPairDistancesNoGreaterThan(m: int) -> int:\n      count = 0\n      j = 1\n      # For each index i, find the first index j s.t. nums[j] > nums[i] + m,\n      # so numPairDistancesNoGreaterThan for the index i will be j - i - 1.\n      for i, num in enumerate(nums):\n        while j < len(nums) and nums[j] <= num + m:\n          j += 1\n        count += j - i - 1\n      return count\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), k,\n                              key=numPairDistancesNoGreaterThan)",
      "title": "719. Find K-th Smallest Pair Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69738b26-0873-46fa-a07b-c6aa882123f7",
      "code": "class Solution:\n  def longestWord(self, words: list[str]) -> str:\n    root = {}\n\n    for word in words:\n      node = root\n      for c in word:\n        if c not in node:\n          node[c] = {}\n        node = node[c]\n      node['word'] = word\n\n    def dfs(node: dict) -> str:\n      ans = node['word'] if 'word' in node else ''\n\n      for child in node:\n        if 'word' in node[child] and len(node[child]['word']) > 0:\n          childWord = dfs(node[child])\n          if len(childWord) > len(ans) or (\n                  len(childWord) == len(ans) and childWord < ans):\n            ans = childWord\n\n      return ans\n\n    return dfs(root)",
      "title": "720. Longest Word in Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e53f9a3-3b72-469f-b053-690996993bf6",
      "code": "class Solution:\n  def removeComments(self, source: list[str]) -> list[str]:\n    ans = []\n    commenting = False\n    modified = ''\n\n    for line in source:\n      i = 0\n      while i < len(line):\n        if i + 1 == len(line):\n          if not commenting:\n            modified += line[i]\n          i += 1\n          break\n        twoChars = line[i:i + 2]\n        if twoChars == '/*' and not commenting:\n          commenting = True\n          i += 2\n        elif twoChars == '*/' and commenting:\n          commenting = False\n          i += 2\n        elif twoChars == '//':\n          if not commenting:\n            break\n          else:\n            i += 2\n        else:\n          if not commenting:\n            modified += line[i]\n          i += 1\n      if modified and not commenting:\n        ans.append(modified)\n        modified = ''\n\n    return ans",
      "title": "722. Remove Comments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0feda8a8-d6af-4c6b-a7d0-880186e409dc",
      "code": "class Solution:\n  def pivotIndex(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      if prefix == summ - prefix - num:\n        return i\n      prefix += num\n\n    return -1",
      "title": "724. Find Pivot Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8eeacd2-8ec4-4a32-a85c-435840237230",
      "code": "class Solution:\n  def splitListToParts(self, root: ListNode, k: int) -> list[ListNode]:\n    ans = [[] for _ in range(k)]\n    length = 0\n    curr = root\n    while curr:\n      length += 1\n      curr = curr.next\n    subLength = length // k\n    remainder = length % k\n\n    prev = None\n    head = root\n\n    for i in range(k):\n      ans[i] = head\n      for j in range(subLength + (1 if remainder > 0 else 0)):\n        prev = head\n        head = head.next\n      if prev:\n        prev.next = None\n      remainder -= 1\n\n    return ans",
      "title": "725. Split Linked List in Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fabb5d9f-923d-4f6b-88af-3c9eb2b25039",
      "code": "class Solution:\n  def countOfAtoms(self, formula: str) -> str:\n    def parse() -> dict:\n      ans = collections.defaultdict(int)\n\n      nonlocal i\n      while i < n:\n        if formula[i] == '(':\n          i += 1\n          for elem, freq in parse().items():\n            ans[elem] += freq\n        elif formula[i] == ')':\n          i += 1\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          factor = int(formula[numStart:i])\n          for elem, freq in ans.items():\n            ans[elem] *= factor\n          return ans\n        elif formula[i].isupper():\n          elemStart = i\n          i += 1\n          while i < n and formula[i].islower():\n            i += 1\n          elem = formula[elemStart:i]\n          numStart = i\n          while i < n and formula[i].isdigit():\n            i += 1\n          num = 1 if i == numStart else int(\n              formula[numStart:i])\n          ans[elem] += num\n\n      return ans\n\n    n = len(formula)\n\n    ans = \"\"\n    i = 0\n    count = parse()\n\n    for elem in sorted(count.keys()):\n      ans += elem\n      if count[elem] > 1:\n        ans += str(count[elem])\n\n    return ans",
      "title": "726. Number of Atoms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bafbfdd-f9e9-4c4b-84a0-f4d4e08cc72a",
      "code": "class Solution:\n  def selfDividingNumbers(self, left: int, right: int) -> list[int]:\n    return [num for num in range(left, right + 1) if all(n != 0 and num % n == 0 for n in map(int, str(num)))]",
      "title": "728. Self Dividing Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26039bb6-31aa-4c1c-b74d-ca78a8af87a4",
      "code": "class Solution:\n  def countPalindromicSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    # dp[i][j] := the number of different non-empty palindromic subsequences in\n    # s[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          lo = i + 1\n          hi = j - 1\n          while lo <= hi and s[lo] != s[i]:\n            lo += 1\n          while lo <= hi and s[hi] != s[i]:\n            hi -= 1\n          if lo > hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 2\n          elif lo == hi:\n            dp[i][j] = dp[i + 1][j - 1] * 2 + 1\n          else:\n            dp[i][j] = dp[i + 1][j - 1] * 2 - dp[lo + 1][hi - 1]\n        else:\n          dp[i][j] = dp[i][j - 1] + dp[i + 1][j] - dp[i + 1][j - 1]\n        dp[i][j] = (dp[i][j] + MOD) % MOD\n\n    return dp[0][n - 1]",
      "title": "730. Count Different Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18b578e3-5fa5-434c-a3d7-fb83ef4515b7",
      "code": "class Solution:\n  def floodFill(self, image: list[list[int]],\n                sr: int, sc: int, newColor: int) -> list[list[int]]:\n    startColor = image[sr][sc]\n    seen = set()\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == len(image) or j < 0 or j == len(image[0]):\n        return\n      if image[i][j] != startColor or (i, j) in seen:\n        return\n\n      image[i][j] = newColor\n      seen.add((i, j))\n\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    dfs(sr, sc)\n    return image",
      "title": "733. Flood Fill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51c4486c-0c44-4c93-99cd-c98ad5c2461a",
      "code": "class Solution:\n  def areSentencesSimilar(\n      self,\n      sentence1: list[str],\n      sentence2: list[str],\n      similarPairs: list[list[str]],\n  ) -> bool:\n    if len(sentence1) != len(sentence2):\n      return False\n\n    # map[key] := all the similar words of key\n    map = collections.defaultdict(set)\n\n    for a, b in similarPairs:\n      map[a].add(b)\n      map[b].add(a)\n\n    for word1, word2 in zip(sentence1, sentence2):\n      if word1 == word2:\n        continue\n      if word1 not in map:\n        return False\n      if word2 not in map[word1]:\n        return False\n\n    return True",
      "title": "734. Sentence Similarity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "860fb3f6-b8a1-4dd0-8f89-61ce5ef2ff5a",
      "code": "class Solution:\n  def asteroidCollision(self, asteroids: list[int]) -> list[int]:\n    stack = []\n\n    for a in asteroids:\n      if a > 0:\n        stack.append(a)\n      else:  # a < 0\n        # Destroy the previous positive one(s).\n        while stack and stack[-1] > 0 and stack[-1] < -a:\n          stack.pop()\n        if not stack or stack[-1] < 0:\n          stack.append(a)\n        elif stack[-1] == -a:\n          stack.pop()  # Both asteroids explode.\n        else:  # stack[-1] > the current asteroid.\n          pass  # Destroy the current asteroid, so do nothing.\n\n    return stack",
      "title": "735. Asteroid Collision",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1631d2a0-6bd6-4150-887b-9ef1a6dbd256",
      "code": "class Solution:\n  def evaluate(self, expression: str) -> int:\n    def evaluate(e: str, prevScope: dict) -> int:\n      if e[0].isdigit() or e[0] == '-':\n        return int(e)\n      if e in prevScope:\n        return prevScope[e]\n\n      scope = prevScope.copy()\n      nextExpression = e[e.index(' ') + 1:-1]\n      tokens = parse(nextExpression)\n\n      if e[1] == 'm':  # 'mult'\n        return evaluate(tokens[0], scope) * evaluate(tokens[1], scope)\n      if e[1] == 'a':  # 'add'\n        return evaluate(tokens[0], scope) + evaluate(tokens[1], scope)\n\n      # 'let'\n      for i in range(0, len(tokens) - 2, 2):\n        scope[tokens[i]] = evaluate(tokens[i + 1], scope)\n\n      return evaluate(tokens[-1], scope)\n\n    def parse(e: str):\n      tokens = []\n      s = ''\n      opened = 0\n\n      for c in e:\n        if c == '(':\n          opened += 1\n        elif c == ')':\n          opened -= 1\n        if opened == 0 and c == ' ':\n          tokens.append(s)\n          s = ''\n        else:\n          s += c\n\n      if len(s) > 0:\n        tokens.append(s)\n      return tokens\n\n    return evaluate(expression, {})",
      "title": "736. Parse Lisp Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccafbfe1-ec52-4fa1-8d7b-e36fe0a7082a",
      "code": "class Solution:\n  def areSentencesSimilarTwo(\n      self,\n      words1: list[str],\n      words2: list[str],\n      pairs: list[list[str]],\n  ) -> bool:\n    if len(words1) != len(words2):\n      return False\n\n    # graph[key] := all the similar words of key\n    graph = collections.defaultdict(set)\n\n    for a, b in pairs:\n      graph[a].add(b)\n      graph[b].add(a)\n\n    def dfs(word1: str, word2: str, seen: set) -> bool:\n      if word1 in graph[word2]:\n        return True\n\n      seen.add(word1)\n\n      for child in graph[word1]:\n        if child in seen:\n          continue\n        if dfs(child, word2, seen):\n          return True\n\n      return False\n\n    for word1, word2 in zip(words1, words2):\n      if word1 == word2:\n        continue\n      if word1 not in graph:\n        return False\n      if not dfs(word1, word2, set()):\n        return False\n\n    return True",
      "title": "737. Sentence Similarity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a01cd36-7d7c-4b4e-90e7-2a3635f1b508",
      "code": "class Solution:\n  def dailyTemperatures(self, temperatures: list[int]) -> list[int]:\n    ans = [0] * len(temperatures)\n    stack = []  # a decreasing stack\n\n    for i, temperature in enumerate(temperatures):\n      while stack and temperature > temperatures[stack[-1]]:\n        index = stack.pop()\n        ans[index] = i - index\n      stack.append(i)\n\n    return ans",
      "title": "739. Daily Temperatures",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be478599-965d-40a3-b454-8fcf833284f2",
      "code": "class Solution:\n  def networkDelayTime(self, times: list[list[int]], n: int, k: int) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in times:\n      graph[u - 1].append((v - 1, w))\n\n    return self._dijkstra(graph, k - 1)\n\n  def _dijkstra(self, graph: list[list[tuple[int, int]]], src: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    maxDist = max(dist)\n    return maxDist if maxDist != math.inf else -1",
      "title": "743. Network Delay Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e3f9b8e-49aa-4f56-a8ae-514a2a8a2541",
      "code": "class Solution:\n  def nextGreatestLetter(self, letters: list[str], target: str) -> str:\n    l = bisect.bisect_right(range(len(letters)), target,\n                            key=lambda m: letters[m])\n    return letters[l % len(letters)]",
      "title": "744. Find Smallest Letter Greater Than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e7cd405-905d-4192-b83a-59045615fd40",
      "code": "class Solution:\n  def minCostClimbingStairs(self, cost: list[int]) -> int:\n    cost.append(0)\n\n    for i in range(2, len(cost)):\n      cost[i] += min(cost[i - 1], cost[i - 2])\n\n    return cost[-1]",
      "title": "746. Min Cost Climbing Stairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "932444c8-4c64-4e30-95a8-d3e50432d2a5",
      "code": "class Solution:\n  def dominantIndex(self, nums: list[int]) -> int:\n    mx = 0\n    secondMax = 0\n\n    for i, num in enumerate(nums):\n      if num > mx:\n        secondMax = mx\n        mx = num\n        ans = i\n      elif num > secondMax:\n        secondMax = num\n\n    return ans if mx >= 2 * secondMax else -1",
      "title": "747. Largest Number At Least Twice of Others",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e48450f1-a6ce-4f7a-a479-7a66cd6ece3b",
      "code": "class Solution:\n  def shortestCompletingWord(self, licensePlate: str, words: list[str]) -> str:\n    def isMatch(word: str) -> bool:\n      wordCount = collections.Counter(word)\n      return False if any(\n          wordCount[i] < count[i] for i in string.ascii_letters) else True\n\n    ans = '*' * 16\n    count = collections.defaultdict(int)\n\n    for c in licensePlate:\n      if c.isalpha():\n        count[c.lower()] += 1\n\n    for word in words:\n      if len(word) < len(ans) and isMatch(word):\n        ans = word\n\n    return ans",
      "title": "748. Shortest Completing Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0510d500-e684-4c68-99ee-75d184a2aa16",
      "code": "class Solution:\n  def ipToCIDR(self, ip: str, n: int) -> list[str]:\n    ans = []\n    num = self._getNum(ip.split('.'))\n\n    while n > 0:\n      lowbit = num & -num\n      count = self._maxLow(n) if lowbit == 0 else self._firstFit(lowbit, n)\n      ans.append(self._getCIDR(num, self._getPrefix(count)))\n      n -= count\n      num += count\n\n    return ans\n\n  def _getNum(self, x: list[str]) -> int:\n    num = 0\n    for i in range(4):\n      num = num * 256 + int(x[i])\n    return num\n\n  def _maxLow(self, n: int) -> int | None:\n    \"\"\"Returns the maximum i s.t. 2^i < n.\"\"\"\n    for i in range(32):\n      if 1 << i + 1 > n:\n        return 1 << i\n\n  def _firstFit(self, lowbit: int, n: int) -> int:\n    while lowbit > n:\n      lowbit >>= 1\n    return lowbit\n\n  def _getCIDR(self, num: int, prefix: int) -> str:\n    d = num & 255\n    num >>= 8\n    c = num & 255\n    num >>= 8\n    b = num & 255\n    num >>= 8\n    a = num & 255\n    return '.'.join([str(s) for s in [a, b, c, d]]) + '/' + str(prefix)\n\n  def _getPrefix(self, count: int) -> int | None:\n    \"\"\"\n    e.g. count = 8 = 2^3 . prefix = 32 - 3 = 29\n         count = 1 = 2^0 . prefix = 32 - 0 = 32\n    \"\"\"\n    for i in range(32):\n      if count == 1 << i:\n        return 32 - i",
      "title": "751. IP to CIDR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "436db8cb-65c8-4496-8e3e-3e33828588e0",
      "code": "class Solution:\n  def crackSafe(self, n: int, k: int) -> str:\n    passwordSize = k**n\n    path = '0' * n\n    seen = set()\n    seen.add(path)\n\n    def dfs(path: str) -> str:\n      if len(seen) == passwordSize:\n        return path\n\n      for c in map(str, range(k)):\n        node = path[-n + 1:] + c if n > 1 else c\n        if node not in seen:\n          seen.add(node)\n          res = dfs(path + c)\n          if res:\n            return res\n          seen.remove(node)\n\n    return dfs(path)",
      "title": "753. Cracking the Safe",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8f4a8e8-cb80-445a-bb67-c87e68af6172",
      "code": "class Solution:\n  def reachNumber(self, target: int) -> int:\n    ans = 0\n    pos = 0\n    target = abs(target)\n\n    while pos < target:\n      ans += 1\n      pos += ans\n\n    while (pos - target) % 2 == 1:\n      ans += 1\n      pos += ans\n\n    return ans",
      "title": "754. Reach a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8358f02-e74e-4525-88c1-7f725ed89305",
      "code": "class Solution:\n  def pourWater(self, heights: list[int], volume: int, k: int) -> list[int]:\n    i = k\n\n    while volume > 0:\n      volume -= 1\n      while i > 0 and heights[i] >= heights[i - 1]:\n        i -= 1\n      while i + 1 < len(heights) and heights[i] >= heights[i + 1]:\n        i += 1\n      while i > k and heights[i] == heights[i - 1]:\n        i -= 1\n      heights[i] += 1\n\n    return heights",
      "title": "755. Pour Water",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c0a0c6f-9dae-4665-888e-911355f7249c",
      "code": "class Solution:\n  def pyramidTransition(self, bottom: str, allowed: list[str]) -> bool:\n    prefixToBlocks = collections.defaultdict(list)\n\n    for a in allowed:\n      prefixToBlocks[a[:2]].append(a[2])\n\n    def dfs(row: str, nextRow: str, i: int) -> bool:\n      if len(row) == 1:\n        return True\n      if len(nextRow) + 1 == len(row):\n        return dfs(nextRow, '', 0)\n\n      for c in prefixToBlocks[row[i:i + 2]]:\n        if dfs(row, nextRow + c, i + 1):\n          return True\n\n      return False\n\n    return dfs(bottom, '', 0)",
      "title": "756. Pyramid Transition Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1450dabb-c7c6-4eba-b19e-68c695bcad03",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def boldWords(self, words: list[str], s: str) -> str:\n    n = len(s)\n    ans = []\n    # bold[i] := True if s[i] should be bolded\n    bold = [0] * n\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        if c not in node.children:\n          node.children[c] = TrieNode()\n        node = node.children[c]\n      node.isWord = True\n\n    def find(s: str, i: int) -> int:\n      node = root\n      ans = -1\n      for j in range(i, len(s)):\n        node = node.children.setdefault(s[j], TrieNode())\n        if node.isWord:\n          ans = j\n      return ans\n\n    for word in words:\n      insert(word)\n\n    boldEnd = -1  # `s[i..boldEnd]` should be bolded.\n    for i in range(n):\n      boldEnd = max(boldEnd, find(s, i))\n      bold[i] = boldEnd >= i\n\n    # Construct the with bold tags\n    i = 0\n    while i < n:\n      if bold[i]:\n        j = i\n        while j < n and bold[j]:\n          j += 1\n        # `s[i..j)` should be bolded.\n        ans.append('<b>' + s[i:j] + '</b>')\n        i = j\n      else:\n        ans.append(s[i])\n        i += 1\n\n    return ''.join(ans)",
      "title": "758. Bold Words in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63f55601-5fef-4a87-94d3-7375e7ea56ac",
      "code": "class Solution:\n  def employeeFreeTime(self, schedule: '[[Interval]]') -> '[Interval]':\n    ans = []\n    intervals = []\n\n    for s in schedule:\n      intervals.extend(s)\n\n    intervals.sort(key=lambda x: x.start)\n\n    prevEnd = intervals[0].end\n\n    for interval in intervals:\n      if interval.start > prevEnd:\n        ans.append(Interval(prevEnd, interval.start))\n      prevEnd = max(prevEnd, interval.end)\n\n    return ans",
      "title": "759. Employee Free Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63415695-621d-4ec3-b6a9-103c5096298b",
      "code": "class Solution:\n  def anagramMappings(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums2):\n      numToIndices[num].append(i)\n\n    return [numToIndices[num].pop() for num in nums1]",
      "title": "760. Find Anagram Mappings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebab98f8-6b26-48e6-bdd1-24aea4bccc95",
      "code": "class Solution:\n  def makeLargestSpecial(self, s: str) -> str:\n    specials = []\n    count = 0\n\n    i = 0\n    for j, c in enumerate(s):\n      count += 1 if c == '1' else -1\n      if count == 0:\n        specials.append(\n            '1' + self.makeLargestSpecial(s[i + 1:j]) + '0')\n        i = j + 1\n\n    return ''.join(sorted(specials)[::-1])",
      "title": "761. Special Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c038c39b-91bb-4176-b4d5-ac09aec099f0",
      "code": "class Solution:\n  def partitionLabels(self, s: str) -> list[int]:\n    ans = []\n    letterToRightmostIndex = {c: i for i, c in enumerate(s)}\n\n    l = 0  # the leftmost index of the current running string\n    r = 0  # the rightmost index of the current running string\n\n    for i, c in enumerate(s):\n      r = max(r, letterToRightmostIndex[c])\n      if i == r:\n        ans.append(r - l + 1)\n        l = r + 1\n\n    return ans",
      "title": "763. Partition Labels",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18c33ec7-0ecd-4c12-9f07-4793d65477af",
      "code": "class Solution:\n  def isToeplitzMatrix(self, matrix: list[list[int]]) -> bool:\n    for i in range(len(matrix) - 1):\n      for j in range(len(matrix[0]) - 1):\n        if matrix[i][j] != matrix[i + 1][j + 1]:\n          return False\n\n    return True",
      "title": "766. Toeplitz Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0176e199-8549-4b60-990b-781843b9a227",
      "code": "class Solution:\n  def reorganizeString(self, s: str) -> str:\n    count = collections.Counter(s)\n    if max(count.values()) > (len(s) + 1) // 2:\n      return ''\n\n    ans = []\n    maxHeap = [(-freq, c) for c, freq in count.items()]\n    heapq.heapify(maxHeap)\n    prevFreq = 0\n    prevChar = '@'\n\n    while maxHeap:\n      # Get the letter with the maximum frequency.\n      freq, c = heapq.heappop(maxHeap)\n      ans.append(c)\n      # Add the previous letter back s.t. any two adjacent characters are not\n      # the same.\n      if prevFreq < 0:\n        heapq.heappush(maxHeap, (prevFreq, prevChar))\n      prevFreq = freq + 1\n      prevChar = c\n\n    return ''.join(ans)",
      "title": "767. Reorganize String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35d19d27-58be-4ec8-abc6-45e385c4b90f",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    mx = -math.inf\n    mn = [arr[-1]] * n\n\n    for i in reversed(range(n - 1)):\n      mn[i] = min(mn[i + 1], arr[i])\n\n    for i in range(n - 1):\n      mx = max(mx, arr[i])\n      if mx <= mn[i + 1]:\n        ans += 1\n\n    return ans + 1",
      "title": "768. Max Chunks To Make Sorted II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6f5aae4-4c8f-4b26-ab52-068c32854d52",
      "code": "class Solution:\n  def maxChunksToSorted(self, arr: list[int]) -> int:\n    ans = 0\n    mx = -math.inf\n\n    for i, a in enumerate(arr):\n      mx = max(mx, a)\n      if mx == i:\n        ans += 1\n\n    return ans",
      "title": "769. Max Chunks To Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a42c52aa-561c-4a2d-86ab-123ddc222423",
      "code": "class Poly:\n  def __init__(self, term: str = None, coef: int = None):\n    if term and coef:\n      self.terms = collections.Counter({term: coef})\n    else:\n      self.terms = collections.Counter()\n\n  def __add__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] += coef\n    return self\n\n  def __sub__(self, other):\n    for term, coef in other.terms.items():\n      self.terms[term] -= coef\n    return self\n\n  def __mul__(self, other):\n    res = Poly()\n    for a, aCoef in self.terms.items():\n      for b, bCoef in other.terms.items():\n        res.terms[self._merge(a, b)] += aCoef * bCoef\n    return res\n\n  # Def __str__(self):\n  #   res = []\n  #   for term, coef in self.terms.items():\n  #     res.append(term + ': ' + str(coef))\n  #   return '{' + ', '.join(res) + '}'\n\n  def toList(self) -> list[str]:\n    for term in list(self.terms.keys()):\n      if not self.terms[term]:\n        del self.terms[term]\n\n    def cmp(term: str) -> tuple:\n      # the minimum degree is the last\n      if term == '1':\n        return (0,)\n      var = term.split('*')\n      # the maximum degree is the first\n      # Break ties by their lexicographic orders.\n      return (-len(var), term)\n\n    def concat(term: str) -> str:\n      if term == '1':\n        return str(self.terms[term])\n      return str(self.terms[term]) + '*' + term\n\n    terms = list(self.terms.keys())\n    terms.sort(key=cmp)\n    return [concat(term) for term in terms]\n\n  def _merge(self, a: str, b: str) -> str:\n    if a == '1':\n      return b\n    if b == '1':\n      return a\n    res = []\n    A = a.split('*')\n    B = b.split('*')\n    i = 0  # A's index\n    j = 0  # B's index\n    while i < len(A) and j < len(B):\n      if A[i] < B[j]:\n        res.append(A[i])\n        i += 1\n      else:\n        res.append(B[j])\n        j += 1\n    return '*'.join(res + A[i:] + B[j:])\n\n\nclass Solution:\n  def basicCalculatorIV(\n      self,\n      expression: str,\n      evalvars: list[str],\n      evalints: list[int],\n  ) -> list[str]:\n    tokens = list(self._getTokens(expression))\n    evalMap = {a: b for a, b in zip(evalvars, evalints)}\n\n    for i, token in enumerate(tokens):\n      if token in evalMap:\n        tokens[i] = str(evalMap[token])\n\n    postfix = self._infixToPostfix(tokens)\n    return self._evaluate(postfix).toList()\n\n  def _getTokens(self, s: str) -> Iterator[str]:\n    i = 0\n    for j, c in enumerate(s):\n      if c == ' ':\n        if i < j:\n          yield s[i:j]\n        i = j + 1\n      elif c in '()+-*':\n        if i < j:\n          yield s[i:j]\n        yield c\n        i = j + 1\n    if i < len(s):\n      yield s[i:]\n\n  def _infixToPostfix(self, tokens: list[str]) -> list[str]:\n    postfix = []\n    ops = []\n\n    def precedes(prevOp: str, currOp: str) -> bool:\n      if prevOp == '(':\n        return False\n      return prevOp == '*' or currOp in '+-'\n\n    for token in tokens:\n      if token == '(':\n        ops.append(token)\n      elif token == ')':\n        while ops[-1] != '(':\n          postfix.append(ops.pop())\n        ops.pop()\n      elif token in '+-*':  # isOperator(token)\n        while ops and precedes(ops[-1], token):\n          postfix.append(ops.pop())\n        ops.append(token)\n      else:  # isOperand(token)\n        postfix.append(token)\n    return postfix + ops[::-1]\n\n  def _evaluate(self, postfix: list[str]) -> Poly:\n    polys: list[Poly] = []\n    for token in postfix:\n      if token in '+-*':\n        b = polys.pop()\n        a = polys.pop()\n        if token == '+':\n          polys.append(a + b)\n        elif token == '-':\n          polys.append(a - b)\n        else:  # token == '*'\n          polys.append(a * b)\n      elif token.lstrip('-').isnumeric():\n        polys.append(Poly(\"1\", int(token)))\n      else:\n        polys.append(Poly(token, 1))\n    return polys[0]",
      "title": "770. Basic Calculator IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1782705-7f99-4df6-beda-8e9a517106e1",
      "code": "class Solution:\n  def numJewelsInStones(self, jewels: str, stones: str) -> int:\n    jewelsSet = set(jewels)\n    return sum(stone in jewelsSet for stone in stones)",
      "title": "771. Jewels and Stones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9265f424-bdf1-4a29-a45d-8a306407bb16",
      "code": "class Solution:\n  def calculate(self, s: str) -> int:\n    nums = []\n    ops = []\n\n    def calc():\n      b = nums.pop()\n      a = nums.pop()\n      op = ops.pop()\n      if op == '+':\n        nums.append(a + b)\n      elif op == '-':\n        nums.append(a - b)\n      elif op == '*':\n        nums.append(a * b)\n      else:  # op == '/'\n        nums.append(int(a / b))\n\n    def precedes(prev: str, curr: str) -> bool:\n      \"\"\"\n      Returns True if the previous character is a operator and the priority of\n      the previous operator >= the priority of the current character (operator).\n      \"\"\"\n      if prev == '(':\n        return False\n      return prev in '*/' or curr in '+-'\n\n    i = 0\n    hasPrevNum = False\n\n    while i < len(s):\n      c = s[i]\n      if c.isdigit():\n        num = int(c)\n        while i + 1 < len(s) and s[i + 1].isdigit():\n          num = num * 10 + int(s[i + 1])\n          i += 1\n        nums.append(num)\n        hasPrevNum = True\n      elif c == '(':\n        ops.append('(')\n        hasPrevNum = False\n      elif c == ')':\n        while ops[-1] != '(':\n          calc()\n        ops.pop()  # Pop '('\n      elif c in '+-*/':\n        if not hasPrevNum:  # Handle input like \"-1-(-1)\"\n          num.append(0)\n        while ops and precedes(ops[-1], c):\n          calc()\n        ops.append(c)\n      i += 1\n\n    while ops:\n      calc()\n\n    return nums.pop()",
      "title": "772. Basic Calculator III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9a1d3b2-7320-4a1e-8949-5f14965be40a",
      "code": "class Solution:\n  def minmaxGasDist(self, stations: list[int], k: int) -> float:\n    ERR = 1e-6\n    l = 0\n    r = stations[-1] - stations[0]\n\n    def possible(k: int, m: float) -> bool:\n      \"\"\"\n      Returns True if can use <= k gas stations to ensure that each adjacent\n      distance between gas stations <= m.\n      \"\"\"\n      for a, b in zip(stations, stations[1:]):\n        diff = b - a\n        if diff > m:\n          k -= math.ceil(diff / m) - 1\n          if k < 0:\n            return False\n      return True\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if possible(k, m):\n        r = m\n      else:\n        l = m\n\n    return l",
      "title": "774. Minimize Max Distance to Gas Station",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4680899e-748f-4d78-9699-da1e8d997751",
      "code": "class Solution:\n  def isIdealPermutation(self, nums: list[int]) -> bool:\n    mx = -1  # the number that is most likely > nums[i + 2]\n\n    for i in range(len(nums) - 2):\n      mx = max(mx, nums[i])\n      if mx > nums[i + 2]:\n        return False\n\n    return True",
      "title": "775. Global and Local Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf2909b7-4be5-4aa1-9ec9-22e314c62c42",
      "code": "class Solution:\n  def splitBST(self, root: TreeNode | None, target: int) -> list[TreeNode | None]:\n    if not root:\n      return None, None\n    if root.val > target:\n      left, right = self.splitBST(root.left, target)\n      root.left = right\n      return left, root\n    else:  # root.val <= target\n      left, right = self.splitBST(root.right, target)\n      root.right = left\n      return root, right",
      "title": "776. Split BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ae0b67d-b0e4-4c14-a43a-974f8267b8e5",
      "code": "class Solution:\n  def canTransform(self, start: str, end: str) -> bool:\n    if start.replace('X', '') != end.replace('X', ''):\n      return False\n\n    i = 0  # start's index\n    j = 0  # end's index\n\n    while i < len(start) and j < len(end):\n      while i < len(start) and start[i] == 'X':\n        i += 1\n      while j < len(end) and end[j] == 'X':\n        j += 1\n      if i == len(start) and j == len(end):\n        return True\n      if i == len(start) or j == len(end):\n        return False\n      # L can only move to left.\n      if start[i] == 'L' and i < j:\n        return False\n      # R can only move to right.\n      if start[i] == 'R' and i > j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "777. Swap Adjacent in LR String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea32a5c1-9bc5-4ecc-a4ea-1c5f8e74dcf7",
      "code": "class Solution:\n  def reachingPoints(self, sx: int, sy: int, tx: int, ty: int) -> bool:\n    while sx < tx and sy < ty:\n      tx, ty = tx % ty, ty % tx\n\n    return (sx == tx and sy <= ty and (ty - sy) % tx == 0 or\n            sy == ty and sx <= tx and (tx - sx) % ty == 0)",
      "title": "780. Reaching Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6c9dd0a-b00c-4f22-87ae-e7b1ee9178d2",
      "code": "class Solution:\n  def numRabbits(self, answers: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for answer in answers:\n      if count[answer] % (answer + 1) == 0:\n        ans += answer + 1\n      count[answer] += 1\n\n    return ans",
      "title": "781. Rabbits in Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eca78b0d-9abf-4ba4-8917-5baef689fad4",
      "code": "class Solution:\n  def movesToChessboard(self, board: list[list[int]]) -> int:\n    n = len(board)\n\n    if any(board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]\n           for i in range(n) for j in range(n)):\n      return -1\n\n    rowSum = sum(board[0])\n    colSum = sum(board[i][0] for i in range(n))\n\n    if rowSum != n // 2 and rowSum != (n + 1) // 2:\n      return -1\n    if colSum != n // 2 and colSum != (n + 1) // 2:\n      return -1\n\n    rowSwaps = sum(board[i][0] == (i & 1) for i in range(n))\n    colSwaps = sum(board[0][i] == (i & 1) for i in range(n))\n\n    if n % 2 == 1:\n      if rowSwaps % 2 == 1:\n        rowSwaps = n - rowSwaps\n      if colSwaps % 2 == 1:\n        colSwaps = n - colSwaps\n    else:\n      rowSwaps = min(rowSwaps, n - rowSwaps)\n      colSwaps = min(colSwaps, n - colSwaps)\n\n    return (rowSwaps + colSwaps) // 2",
      "title": "782. Transform to Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "997c5a9b-02b7-4242-836e-8de382f5064d",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def isBipartite(self, graph: list[list[int]]) -> bool:\n    colors = [Color.WHITE] * len(graph)\n\n    for i in range(len(graph)):\n      # This node has been colored, so do nothing.\n      if colors[i] != Color.WHITE:\n        continue\n      # Always paint red for a white node.\n      colors[i] = Color.RED\n      # BFS.\n      q = collections.deque([i])\n      while q:\n        for _ in range(len(q)):\n          u = q.popleft()\n          for v in graph[u]:\n            if colors[v] == colors[u]:\n              return False\n            if colors[v] == Color.WHITE:\n              colors[v] = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n              q.append(v)\n\n    return True",
      "title": "785. Is Graph Bipartite?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b905c7d7-13fb-4ef5-9204-f75e1b6d2498",
      "code": "class Solution:\n  def kthSmallestPrimeFraction(self, arr: list[int], k: int) -> list[int]:\n    n = len(arr)\n    ans = [0, 1]\n    l = 0\n    r = 1\n\n    while True:\n      m = (l + r) / 2\n      ans[0] = 0\n      count = 0\n      j = 1\n\n      for i in range(n):\n        while j < n and arr[i] > m * arr[j]:\n          j += 1\n        count += n - j\n        if j == n:\n          break\n        if ans[0] * arr[j] < ans[1] * arr[i]:\n          ans[0] = arr[i]\n          ans[1] = arr[j]\n\n      if count < k:\n        l = m\n      elif count > k:\n        r = m\n      else:\n        return ans",
      "title": "786. K-th Smallest Prime Fraction",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad8823c8-7b2e-4d53-b16c-d9e88d898af6",
      "code": "class Solution:\n  def findCheapestPrice(\n      self,\n      n: int,\n      flights: list[list[int]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in flights:\n      graph[u].append((v, w))\n\n    return self._dijkstra(graph, src, dst, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf] * (k + 2) for _ in range(len(graph))]\n\n    dist[src][k + 1] = 0\n    minHeap = [(dist[src][k + 1], src, k + 1)]  # (d, u, stops)\n\n    while minHeap:\n      d, u, stops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if stops == 0 or d > dist[u][stops]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v][stops - 1]:\n          dist[v][stops - 1] = d + w\n          heapq.heappush(minHeap, (dist[v][stops - 1], v, stops - 1))\n\n    return -1",
      "title": "787. Cheapest Flights Within K Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4dbe062-e845-4f24-aeb1-eda61e9265ba",
      "code": "class Solution:\n  def rotatedDigits(self, n: int) -> int:\n    def isGoodNumber(i: int) -> bool:\n      isRotated = False\n\n      for c in str(i):\n        if c == '0' or c == '1' or c == '8':\n          continue\n        if c == '2' or c == '5' or c == '6' or c == '9':\n          isRotated = True\n        else:\n          return False\n\n      return isRotated\n\n    return sum(isGoodNumber(i) for i in range(1, n + 1))",
      "title": "788. Rotated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eea4cdcf-7589-4cc1-b22e-1c438b9abe13",
      "code": "class Solution:\n  def escapeGhosts(self, ghosts: list[list[int]], target: list[int]) -> bool:\n    ghostSteps = min(abs(x - target[0]) +\n                     abs(y - target[1]) for x, y in ghosts)\n\n    return abs(target[0]) + abs(target[1]) < ghostSteps",
      "title": "789. Escape The Ghosts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a9a02b1-72e8-4807-ae4e-b40d9be3555a",
      "code": "class Solution:\n  def numTilings(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = [0, 1, 2, 5] + [0] * 997\n\n    for i in range(4, n + 1):\n      dp[i] = 2 * dp[i - 1] + dp[i - 3]\n\n    return dp[n] % MOD",
      "title": "790. Domino and Tromino Tiling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45ef6522-fe26-4a1a-ab45-3b0a0f0d882a",
      "code": "class Solution:\n  def customSortString(self, order: str, s: str) -> str:\n    ans = \"\"\n    count = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in order:\n      while count[ord(c) - ord('a')] > 0:\n        ans += c\n        count[ord(c) - ord('a')] -= 1\n\n    for c in string.ascii_lowercase:\n      for _ in range(count[ord(c) - ord('a')]):\n        ans += c\n\n    return ans",
      "title": "791. Custom Sort String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b74ba32-3596-424f-8d5d-682662b18f09",
      "code": "class Solution:\n  def numMatchingSubseq(self, s: str, words: list[str]) -> int:\n    ans = 0\n    # [(i, j)] := words[i] and the letter words[i][j] is waiting for\n    bucket = [[] for _ in range(26)]\n\n    # For each word, it's waiting for word[0].\n    for i, word in enumerate(words):\n      bucket[ord(word[0]) - ord('a')].append((i, 0))\n\n    for c in s:\n      # Let prevBucket = bucket[c] and clear bucket[c].\n      index = ord(c) - ord('a')\n      prevBucket = bucket[index]\n      bucket[index] = []\n      for i, j in prevBucket:\n        j += 1\n        if j == len(words[i]):  # All the letters in words[i] are matched.\n          ans += 1\n        else:\n          bucket[ord(words[i][j]) - ord('a')].append((i, j))\n\n    return ans",
      "title": "792. Number of Matching Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1efb9f50-7fe8-4e5a-b103-b0d1ce135448",
      "code": "class Solution:\n  def validTicTacToe(self, board: list[str]) -> bool:\n    def isWin(c: str) -> bool:\n      return (any(row.count(c) == 3 for row in board) or\n              any(row.count(c) == 3 for row in list(zip(*board))) or\n              all(board[i][i] == c for i in range(3)) or\n              all(board[i][2 - i] == c for i in range(3)))\n\n    countX = sum(row.count('X') for row in board)\n    countO = sum(row.count('O') for row in board)\n\n    if countX < countO or countX - countO > 1:\n      return False\n    if isWin('X') and countX == countO or isWin('O') and countX != countO:\n      return False\n\n    return True",
      "title": "794. Valid Tic-Tac-Toe State",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3fb91e6-d832-45bf-9c89-7b199b6f07e9",
      "code": "class Solution:\n  def numSubarrayBoundedMax(\n      self,\n      nums: list[int],\n      left: int,\n      right: int,\n  ) -> int:\n    ans = 0\n    l = -1\n    r = -1\n\n    for i, num in enumerate(nums):\n      if num > right:  # Handle the reset value.\n        l = i\n      if num >= left:  # Handle the reset and the needed value.\n        r = i\n      ans += r - l\n\n    return ans",
      "title": "795. Number of Subarrays with Bounded Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e8ee21a0-a75c-4bec-94b4-e2f388060367",
      "code": "class Solution:\n  def rotateString(self, s: str, goal: str) -> bool:\n    return len(s) == len(goal) and goal in s + s",
      "title": "796. Rotate String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c91bffde-a4c0-44ac-9133-2aead0a7d547",
      "code": "class Solution:\n  def allPathsSourceTarget(self, graph: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(u: int, path: list[int]) -> None:\n      if u == len(graph) - 1:\n        ans.append(path)\n        return\n\n      for v in graph[u]:\n        dfs(v, path + [v])\n\n    dfs(0, [0])\n    return ans",
      "title": "797. All Paths From Source to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a36999b-7b16-4148-8ff4-11ad2736d25d",
      "code": "class Solution:\n  def similarRGB(self, color: str) -> str:\n    SHORTHANDS = ['00', '11', '22', '33', '44', '55', '66', '77', '88', '99',\n                  'aa', 'bb', 'cc', 'dd', 'ee', 'ff']\n    ans = ['#']\n\n    for i in range(1, len(color), 2):\n      currValue = int(color[i:i + 2], 16)\n      closestShorthand = min(SHORTHANDS,\n                             key=lambda x: (currValue - int(x, 16))**2)\n      ans.append(closestShorthand)\n\n    return ''.join(ans)",
      "title": "800. Similar RGB Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb9f30f2-80ee-480c-a596-04487db491dc",
      "code": "class Solution:\n  def minSwap(self, nums1: list[int], nums2: list[int]) -> int:\n    keepAt = [math.inf] * len(nums1)\n    swapAt = [math.inf] * len(nums1)\n    keepAt[0] = 0\n    swapAt[0] = 1\n\n    for i in range(1, len(nums1)):\n      if nums1[i] > nums1[i - 1] and nums2[i] > nums2[i - 1]:\n        keepAt[i] = keepAt[i - 1]\n        swapAt[i] = swapAt[i - 1] + 1\n      if nums1[i] > nums2[i - 1] and nums2[i] > nums1[i - 1]:\n        keepAt[i] = min(keepAt[i], swapAt[i - 1])\n        swapAt[i] = min(swapAt[i], keepAt[i - 1] + 1)\n\n    return min(keepAt[-1], swapAt[-1])",
      "title": "801. Minimum Swaps To Make Sequences Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90584d06-998b-4cda-b843-8a5eeac744cb",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def eventualSafeNodes(self, graph: list[list[int]]) -> list[int]:\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return [i for i in range(len(graph)) if not hasCycle(i)]",
      "title": "802. Find Eventual Safe States",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dbfc912-da20-487b-906c-7f76412526e0",
      "code": "class Solution:\n  def uniqueMorseRepresentations(self, words: list[str]) -> int:\n    morse = [\".-\", \"-...\", \"-.-.\", \"-..\", \".\", \"..-.\", \"--.\", \"....\", \"..\",\n             \".---\", \"-.-\", \".-..\", \"--\", \"-.\", \"---\", \".--.\", \"--.-\", \".-.\",\n             \"...\", \"-\", \"..-\", \"...-\", \".--\", \"-..-\", \"-.--\", \"--..\"]\n    transformations = set()\n\n    for word in words:\n      transformation = ''.join(\n          morse[ord(c) - ord('a')] for c in word)\n      transformations.add(transformation)\n\n    return len(transformations)",
      "title": "804. Unique Morse Code Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce766565-872b-4fe9-9252-cf2ee9d7bae7",
      "code": "class Solution:\n  def splitArraySameAverage(self, nums: list[int]) -> bool:\n    n = len(nums)\n    summ = sum(nums)\n    if not any(i * summ % n == 0 for i in range(1, n // 2 + 1)):\n      return False\n\n    sums = [set() for _ in range(n // 2 + 1)]\n    sums[0].add(0)\n\n    for num in nums:\n      for i in range(n // 2, 0, -1):\n        for val in sums[i - 1]:\n          sums[i].add(num + val)\n\n    for i in range(1, n // 2 + 1):\n      if i * summ % n == 0 and i * summ // n in sums[i]:\n        return True\n\n    return False",
      "title": "805. Split Array With Same Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fde1a0c-cb80-4fc4-9900-b68b70f9d271",
      "code": "class Solution:\n  def numberOfLines(self, widths: list[int], s: str) -> list[int]:\n    numLines = 1\n    runningWidth = 0\n\n    for c in s:\n      width = widths[ord(c) - ord('a')]\n      if runningWidth + width <= 100:\n        runningWidth += width\n      else:\n        numLines += 1\n        runningWidth = width\n\n    return [numLines, runningWidth]",
      "title": "806. Number of Lines To Write String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72c5f99b-7d8a-492a-949c-2880a4efb71f",
      "code": "class Solution:\n  def maxIncreaseKeepingSkyline(self, grid: list[list[int]]) -> int:\n    rowMax = list(map(max, grid))\n    colMax = list(map(max, zip(*grid)))\n    return sum(min(i, j) for i in rowMax for j in colMax) - sum(map(sum, grid))",
      "title": "807. Max Increase to Keep City Skyline",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f88046a-e2bb-4b48-8f13-878517a310de",
      "code": "class Solution:\n  def soupServings(self, n: int) -> float:\n    @functools.lru_cache(None)\n    def dfs(a: int, b: int) -> float:\n      if a <= 0 and b <= 0:\n        return 0.5\n      if a <= 0:\n        return 1.0\n      if b <= 0:\n        return 0.0\n      return 0.25 * (dfs(a - 4, b) +\n                     dfs(a - 3, b - 1) +\n                     dfs(a - 2, b - 2) +\n                     dfs(a - 1, b - 3))\n\n    return 1 if n >= 4800 else dfs((n + 24) // 25, (n + 24) // 25)",
      "title": "808. Soup Servings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edda3634-5715-4d8c-bb22-bbd3f779287d",
      "code": "class Solution:\n  def expressiveWords(self, s: str, words: list[str]) -> int:\n    def isStretchy(word: str) -> bool:\n      n = len(s)\n      m = len(word)\n\n      j = 0\n      for i in range(n):\n        if j < m and s[i] == word[j]:\n          j += 1\n        elif i > 1 and s[i] == s[i - 1] == s[i - 2]:\n          continue\n        elif 0 < i < n - 1 and s[i - 1] == s[i] == s[i + 1]:\n          continue\n        else:\n          return False\n\n      return j == m\n\n    return sum(isStretchy(word) for word in words)",
      "title": "809. Expressive Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "007e4c83-f2d6-4610-b92b-d6fcab195a54",
      "code": "class Solution:\n  def xorGame(self, nums: list[int]) -> bool:\n    return functools.reduce(operator.xor, nums) == 0 or len(nums) % 2 == 0",
      "title": "810. Chalkboard XOR Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f1c1d05-8691-40ae-a2b6-ae7755066048",
      "code": "class Solution:\n  def subdomainVisits(self, cpdomains: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    for cpdomain in cpdomains:\n      num, domains = cpdomain.split()\n      num, domains = int(num), domains.split('.')\n      for i in reversed(range(len(domains))):\n        count['.'.join(domains[i:])] += num\n\n    return [str(freq) + ' ' + domain for domain, freq in count.items()]",
      "title": "811. Subdomain Visit Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11a30b38-2c20-47a5-806f-75ec9891a03c",
      "code": "class Solution:\n  def largestTriangleArea(self, points: list[list[int]]) -> float:\n    ans = 0\n\n    for Ax, Ay in points:\n      for Bx, By in points:\n        for Cx, Cy in points:\n          ans = max(ans, 0.5 * abs((Bx - Ax) * (Cy - Ay) -\n                                   (Cx - Ax) * (By - Ay)))\n\n    return ans",
      "title": "812. Largest Triangle Area",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "756d899c-0a86-4888-bc9e-30bedabb873c",
      "code": "class Solution:\n  def pruneTree(self, root: TreeNode | None) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.pruneTree(root.left)\n    root.right = self.pruneTree(root.right)\n    if not root.left and not root.right and not root.val:\n      return None\n    return root",
      "title": "814. Binary Tree Pruning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d7e2011-cb94-471d-8b59-729e3b46ef2f",
      "code": "class Solution:\n  def numBusesToDestination(\n      self,\n      routes: list[list[int]],\n      source: int,\n      target: int,\n  ) -> int:\n    if source == target:\n      return 0\n\n    graph = collections.defaultdict(list)\n    usedBuses = set()\n\n    for i in range(len(routes)):\n      for route in routes[i]:\n        graph[route].append(i)\n\n    q = collections.deque([source])\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        for bus in graph[q.popleft()]:\n          if bus in usedBuses:\n            continue\n          usedBuses.add(bus)\n          for nextRoute in routes[bus]:\n            if nextRoute == target:\n              return step\n            q.append(nextRoute)\n      step += 1\n\n    return -1",
      "title": "815. Bus Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab58f665-8cb4-40e1-97f0-6bf9cdc7a58b",
      "code": "class Solution:\n  def ambiguousCoordinates(self, s: str) -> list[str]:\n    def splits(s: str) -> list[str]:\n      if not s or len(s) > 1 and s[0] == s[-1] == '0':\n        return []\n      if s[-1] == '0':\n        return [s]\n      if s[0] == '0':\n        return [s[0] + '.' + s[1:]]\n      return [s] + [s[:i] + '.' + s[i:] for i in range(1, len(s))]\n\n    ans = []\n    s = s[1:-1]\n\n    for i in range(1, len(s)):\n      for x in splits(s[:i]):\n        for y in splits(s[i:]):\n          ans.append('(%s, %s)' % (x, y))\n\n    return ans",
      "title": "816. Ambiguous Coordinates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5039554-e289-47e6-9263-2d5257fde4de",
      "code": "class Solution:\n  def numComponents(self, head: ListNode | None, nums: list[int]) -> int:\n    ans = 0\n    numsSet = set(nums)\n\n    while head:\n      if head.val in numsSet and (\n              head.next == None or head.next.val not in numsSet):\n        ans += 1\n      head = head.next\n\n    return ans",
      "title": "817. Linked List Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "437e2a89-1da2-4161-8aa8-b494f2835786",
      "code": "class Solution:\n  def mostCommonWord(self, paragraph: str, banned: list[str]) -> str:\n    banned = set(banned)\n    words = re.findall(r'\\w+', paragraph.lower())\n    return collections.Counter(\n        word for word in words if word not in banned).most_common(1)[0][0]",
      "title": "819. Most Common Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "428184cd-db15-4c06-bd82-fa42f3b47a11",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.depth = 0\n\n\nclass Solution:\n  def minimumLengthEncoding(self, words: list[str]) -> int:\n    root = TrieNode()\n    leaves = []\n\n    def insert(word: str) -> TrieNode:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n      node.depth = len(word)\n      return node\n\n    for word in set(words):\n      leaves.append(insert(word))\n\n    return sum(leaf.depth + 1 for leaf in leaves\n               if not len(leaf.children))",
      "title": "820. Short Encoding of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72a48a32-74ad-4469-8751-c07bfcd60878",
      "code": "class Solution:\n  def shortestToChar(self, s: str, c: str) -> list[int]:\n    n = len(s)\n    ans = [0] * n\n    prev = -n\n\n    for i in range(n):\n      if s[i] == c:\n        prev = i\n      ans[i] = i - prev\n\n    for i in range(prev - 1, -1, -1):\n      if s[i] == c:\n        prev = i\n      ans[i] = min(ans[i], prev - i)\n\n    return ans",
      "title": "821. Shortest Distance to a Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5db762a-fe56-4b19-a9b7-3c6ee69e242f",
      "code": "class Solution:\n  def flipgame(self, fronts: list[int], backs: list[int]) -> int:\n    same = {front\n            for front, back in zip(fronts, backs)\n            if front == back}\n    return min([num for num in fronts + backs\n                if num not in same] or [0])",
      "title": "822. Card Flipping Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81e9dc5b-2ffc-45e1-9010-c026ddde200a",
      "code": "class Solution:\n  def numFactoredBinaryTrees(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    # dp[i] := the number of binary trees with arr[i] as the root\n    dp = [1] * n\n    arr.sort()\n    numToIndex = {a: i for i, a in enumerate(arr)}\n\n    for i, root in enumerate(arr):  # arr[i] is the root\n      for j in range(i):\n        if root % arr[j] == 0:  # arr[j] is the left subtree\n          right = root // arr[j]\n          if right in numToIndex:\n            dp[i] += dp[j] * dp[numToIndex[right]]\n            dp[i] %= MOD\n\n    return sum(dp) % MOD",
      "title": "823. Binary Trees With Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7863069d-41be-4655-9ff0-12fcd30df848",
      "code": "class Solution:\n  def toGoatLatin(self, sentence: str) -> str:\n    ans = []\n    VOWELS = 'aeiouAEIOU'\n\n    i = 1\n    for word in sentence.split():\n      if i > 1:\n        ans.append(' ')\n      if word[0] in VOWELS:\n        ans.append(word)\n      else:\n        ans.append(word[1:] + word[0])\n      ans.append('ma' + 'a' * i)\n      i += 1\n\n    return ''.join(ans)",
      "title": "824. Goat Latin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aee13fa2-fc7b-4bfc-89e5-d43dda64931b",
      "code": "class Solution:\n  def numFriendRequests(self, ages: list[int]) -> int:\n    ans = 0\n    count = [0] * 121\n\n    for age in ages:\n      count[age] += 1\n\n    for i in range(15, 121):\n      ans += count[i] * (count[i] - 1)\n\n    for i in range(15, 121):\n      for j in range(i // 2 + 8, i):\n        ans += count[i] * count[j]\n\n    return ans",
      "title": "825. Friends Of Appropriate Ages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d53c0c92-8c92-4835-8271-3f60c2f601f1",
      "code": "class Solution:\n  def maxProfitAssignment(\n      self,\n      difficulty: list[int],\n      profit: list[int],\n      worker: list[int],\n  ) -> int:\n    ans = 0\n    jobs = sorted(zip(difficulty, profit))\n    worker.sort(reverse=1)\n\n    i = 0\n    maxProfit = 0\n\n    for w in sorted(worker):\n      while i < len(jobs) and w >= jobs[i][0]:\n        maxProfit = max(maxProfit, jobs[i][1])\n        i += 1\n      ans += maxProfit\n\n    return ans",
      "title": "826. Most Profit Assigning Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a270208-92bd-4269-8dea-f53a9220edd1",
      "code": "class Solution:\n  def uniqueLetterString(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time ('a' + i) appeared\n    lastSeen = collections.defaultdict(lambda: -1)\n    # prevSeen[c] := the previous index of the last time ('a' + i) appeared\n    prevLastSeen = collections.defaultdict(lambda: -1)\n\n    for i, c in enumerate(s):\n      if c in lastSeen:\n        ans += (i - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n      prevLastSeen[c] = lastSeen[c]\n      lastSeen[c] = i\n\n    for c in string.ascii_uppercase:\n      ans += (len(s) - lastSeen[c]) * (lastSeen[c] - prevLastSeen[c])\n\n    return ans",
      "title": "828. Count Unique Characters of All Substrings of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7050baa-9fa2-4547-a700-8032c7735454",
      "code": "class Solution:\n  def consecutiveNumbersSum(self, n: int) -> int:\n    ans = 0\n    i = 1\n    triangleNum = 1\n    while triangleNum <= n:\n      if (n - triangleNum) % i == 0:\n        ans += 1\n      i += 1\n      triangleNum += i\n    return ans",
      "title": "829. Consecutive Numbers Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca3c9450-49d1-4a02-92cb-8bfaaa5f2326",
      "code": "class Solution:\n  def largeGroupPositions(self, s: str) -> list[list[int]]:\n    n = len(s)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      while j < n and s[j] == s[i]:\n        j += 1\n      if j - i >= 3:\n        ans.append([i, j - 1])\n      i = j\n\n    return ans",
      "title": "830. Positions of Large Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb1046a9-9ae9-411e-9a79-30d2f89f5545",
      "code": "class Solution:\n  def maskPII(self, s: str) -> str:\n    atIndex = s.find('@')\n    if atIndex != -1:\n      s = s.lower()\n      return s[0] + '*' * 5 + s[atIndex - 1:]\n\n    ans = ''.join(c for c in s if c.isdigit())\n\n    if len(ans) == 10:\n      return '***-***-' + ans[-4:]\n    return '+' + '*' * (len(ans) - 10) + '-***-***-' + ans[-4:]",
      "title": "831. Masking Personal Information",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4b920dd-e3b6-47f5-91fe-6aaff911d85e",
      "code": "class Solution:\n  def flipAndInvertImage(self, A: list[list[int]]) -> list[list[int]]:\n    n = len(A)\n\n    for i in range(n):\n      for j in range((n + 2) // 2):\n        A[i][j], A[i][n - j - 2] = A[i][n - j - 1] ^ 2, A[i][j] ^ 1\n\n    return A",
      "title": "832. Flipping an Image",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b2cfeda-eabf-4384-861e-1f0a79c199ee",
      "code": "class Solution:\n  def findReplaceString(\n      self,\n      s: str,\n      indices: list[int],\n      sources: list[str],\n      targets: list[str]\n  ) -> str:\n    for index, source, target in sorted(zip(indices, sources, targets),\n                                        reverse=True):\n      if s[index:index + len(source)] == source:\n        s = s[:index] + target + s[index + len(source):]\n    return s",
      "title": "833. Find And Replace in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae3b9c2f-041f-4583-a11b-bb21095d9244",
      "code": "class Solution:\n  def sumOfDistancesInTree(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    count = [1] * n\n    tree = [set() for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    def postorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        postorder(v, u)\n        count[u] += count[v]\n        ans[u] += ans[v] + count[v]\n\n    def preorder(u: int, prev: int) -> None:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # count[v] us are 1 step closer from v than prev.\n        # (n - count[v]) us are 1 step farther from v than prev.\n        ans[v] = ans[u] - count[v] + (n - count[v])\n        preorder(v, u)\n\n    postorder(0, -1)\n    preorder(0, -1)\n    return ans",
      "title": "834. Sum of Distances in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec028986-7db8-404e-b75d-e2c852249cdb",
      "code": "class Solution:\n  def largestOverlap(self, img1: list[list[int]], img2: list[list[int]]) -> int:\n    MAGIC = 100\n    ones1 = [(i, j)\n             for i, row in enumerate(img1)\n             for j, num in enumerate(row)\n             if num == 1]\n    ones2 = [(i, j)\n             for i, row in enumerate(img2)\n             for j, num in enumerate(row)\n             if num == 1]\n    offsetCount = collections.Counter()\n\n    for ax, ay in ones1:\n      for bx, by in ones2:\n        offsetCount[(ax - bx) * MAGIC + (ay - by)] += 1\n\n    return max(offsetCount.values()) if offsetCount else 0",
      "title": "835. Image Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72f000b0-236a-40b4-98c6-376dd4678d0f",
      "code": "class Solution:\n  def isRectangleOverlap(self, rec1: list[int], rec2: list[int]) -> bool:\n    return rec1[0] < rec2[2] and rec2[0] < rec1[2] and rec1[1] < rec2[3] and rec2[1] < rec1[3]",
      "title": "836. Rectangle Overlap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69ad559c-4d58-42dc-bbc8-86540e8b762d",
      "code": "class Solution:\n  def new21Game(self, n: int, k: int, maxPts: int) -> float:\n    # When the game ends, the point is in [k..k - 1 maxPts].\n    #   P = 1, if n >= k - 1 + maxPts\n    #   P = 0, if n < k (note that the constraints already have k <= n)\n    if k == 0 or n >= k - 1 + maxPts:\n      return 1.0\n\n    ans = 0.0\n    dp = [1.0] + [0] * n  # dp[i] := the probability to have i points\n    windowSum = dp[0]  # P(i - 1) + P(i - 2) + ... + P(i - maxPts)\n\n    for i in range(1, n + 1):\n      # The probability to get i points is\n      # P(i) = [P(i - 1) + P(i - 2) + ... + P(i - maxPts)] / maxPts\n      dp[i] = windowSum / maxPts\n      if i < k:\n        windowSum += dp[i]\n      else:  # The game ends.\n        ans += dp[i]\n      if i - maxPts >= 0:\n        windowSum -= dp[i - maxPts]\n\n    return ans",
      "title": "837. New 21 Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "745a2b02-f60b-4141-bbb0-2d90190b7f20",
      "code": "class Solution:\n  def pushDominoes(self, dominoes: str) -> str:\n    ans = list(dominoes)\n    L = -1\n    R = -1\n\n    for i in range(len(dominoes) + 1):\n      if i == len(dominoes) or dominoes[i] == 'R':\n        if L < R:\n          while R < i:\n            ans[R] = 'R'\n            R += 1\n        R = i\n      elif dominoes[i] == 'L':\n        if R < L or (L, R) == (-1, -1):\n          if (L, R) == (-1, -1):\n            L += 1\n          while L < i:\n            ans[L] = 'L'\n            L += 1\n        else:\n          l = R + 1\n          r = i - 1\n          while l < r:\n            ans[l] = 'R'\n            ans[r] = 'L'\n            l += 1\n            r -= 1\n        L = i\n\n    return ''.join(ans)",
      "title": "838. Push Dominoes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4c14f1e-b4e1-4a82-94be-858c5e928225",
      "code": "class Solution:\n  def numMagicSquaresInside(self, grid: list[list[int]]) -> int:\n    def isMagic(i: int, j: int) -> int:\n      s = \"\".join(str(grid[i + num // 3][j + num % 3])\n                  for num in [0, 1, 2, 5, 8, 7, 6, 3])\n      return s in \"43816729\" * 2 or s in \"43816729\"[::-1] * 2\n\n    ans = 0\n\n    for i in range(len(grid) - 2):\n      for j in range(len(grid[0]) - 2):\n        if grid[i][j] % 2 == 0 and grid[i + 1][j + 1] == 5:\n          ans += isMagic(i, j)\n\n    return ans",
      "title": "840. Magic Squares In Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f68f878a-60db-42b0-a344-2f4a28a54f5c",
      "code": "class Solution:\n  def canVisitAllRooms(self, rooms: list[list[int]]) -> bool:\n    seen = [False] * len(rooms)\n\n    def dfs(node: int) -> None:\n      seen[node] = True\n      for child in rooms[node]:\n        if not seen[child]:\n          dfs(child)\n\n    dfs(0)\n    return all(seen)",
      "title": "841. Keys and Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cca68d5c-6133-469d-aa53-8b32945a2a66",
      "code": "# \"\"\"\n# This is Master's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class Master:\n#   def guess(self, word: str) -> int:\n\nclass Solution:\n  def findSecretWord(self, words: list[str], master: 'Master') -> None:\n    for _ in range(10):\n      guessedWord = words[random.randint(0, len(words) - 1)]\n      matches = master.guess(guessedWord)\n      if matches == 6:\n        break\n      words = [\n          word for word in words\n          if sum(c1 == c2 for c1, c2 in zip(guessedWord, word)) == matches]",
      "title": "843. Guess the Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1727882-d377-4fe8-9020-35472ffc1214",
      "code": "class Solution:\n  def backspaceCompare(self, s: str, t: str) -> bool:\n    i = len(s) - 1  # s' index\n    j = len(t) - 1  # t's index\n\n    while True:\n      # Delete characters of s if needed.\n      backspace = 0\n      while i >= 0 and (s[i] == '#' or backspace > 0):\n        backspace += 1 if s[i] == '#' else -1\n        i -= 1\n      # Delete characters of t if needed.\n      backspace = 0\n      while j >= 0 and (t[j] == '#' or backspace > 0):\n        backspace += 1 if t[j] == '#' else -1\n        j -= 1\n      if i >= 0 and j >= 0 and s[i] == t[j]:\n        i -= 1\n        j -= 1\n      else:\n        break\n\n    return i == -1 and j == -1",
      "title": "844. Backspace String Compare",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76cfbf31-83f9-42fb-8457-affd6e9c3a30",
      "code": "class Solution:\n  def longestMountain(self, arr: list[int]) -> int:\n    ans = 0\n    i = 0\n\n    while i + 1 < len(arr):\n      while i + 1 < len(arr) and arr[i] == arr[i + 1]:\n        i += 1\n\n      increasing = 0\n      decreasing = 0\n\n      while i + 1 < len(arr) and arr[i] < arr[i + 1]:\n        increasing += 1\n        i += 1\n\n      while i + 1 < len(arr) and arr[i] > arr[i + 1]:\n        decreasing += 1\n        i += 1\n\n      if increasing > 0 and decreasing > 0:\n        ans = max(ans, increasing + decreasing + 1)\n\n    return ans",
      "title": "845. Longest Mountain in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caa03733-24cb-4d57-946a-e2183b14da8c",
      "code": "class Solution:\n  def isNStraightHand(self, hand: list[int], groupSize: int) -> bool:\n    count = collections.Counter(hand)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + groupSize):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "846. Hand of Straights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05bf5abb-2d5f-4907-b2ca-7dc27549aafc",
      "code": "class Solution:\n  def shortestPathLength(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    goal = (1 << n) - 1\n    q = collections.deque()  # (u, state)\n    seen = set()\n\n    for i in range(n):\n      q.append((i, 1 << i))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, state = q.popleft()\n        if state == goal:\n          return step\n        if (u, state) in seen:\n          continue\n        seen.add((u, state))\n        for v in graph[u]:\n          q.append((v, state | 1 << v))\n      step += 1\n\n    return -1",
      "title": "847. Shortest Path Visiting All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "782efd13-070d-4da0-a5ad-6f70ce947c19",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[int]) -> str:\n    ans = []\n\n    for i in reversed(range(len(shifts) - 1)):\n      shifts[i] += shifts[i + 1]\n\n    for c, shift in zip(s, shifts):\n      ans.append(chr((ord(c) - ord('a') + shift) % 26 + ord('a')))\n\n    return ''.join(ans)",
      "title": "848. Shifting Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28a96162-e578-4597-be84-dc1dd626ce9f",
      "code": "class Solution:\n  def maxDistToClosest(self, seats: list[int]) -> int:\n    n = len(seats)\n    ans = 0\n    j = -1\n\n    for i in range(n):\n      if seats[i] == 1:\n        ans = i if j == -1 else max(ans, (i - j) // 2)\n        j = i\n\n    return max(ans, n - j - 1)",
      "title": "849. Maximize Distance to Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e254df62-3eca-49f2-9f4d-21575bca73ef",
      "code": "class Solution:\n  def rectangleArea(self, rectangles: list[list[int]]) -> int:\n    events = []\n\n    for x1, y1, x2, y2 in rectangles:\n      events.append((x1, y1, y2, 's'))\n      events.append((x2, y1, y2, 'e'))\n\n    events.sort(key=lambda x: x[0])\n\n    ans = 0\n    prevX = 0\n    yPairs = []\n\n    def getHeight(yPairs: list[tuple[int, int]]) -> int:\n      height = 0\n      prevY = 0\n\n      for y1, y2 in yPairs:\n        prevY = max(prevY, y1)\n        if y2 > prevY:\n          height += y2 - prevY\n          prevY = y2\n\n      return height\n\n    for currX, y1, y2, type in events:\n      if currX > prevX:\n        width = currX - prevX\n        ans += width * getHeight(yPairs)\n        prevX = currX\n      if type == 's':\n        yPairs.append((y1, y2))\n        yPairs.sort()\n      else:  # type == 'e'\n        yPairs.remove((y1, y2))\n\n    return ans % (10**9 + 7)",
      "title": "850. Rectangle Area II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76a4a12a-0763-4e3b-8857-484d20aec955",
      "code": "class Solution:\n  def loudAndRich(self, richer: list[list[int]], quiet: list[int]) -> list[int]:\n    graph = [[] for _ in range(len(quiet))]\n\n    for v, u in richer:\n      graph[u].append(v)\n\n    @functools.lru_cache(None)\n    def dfs(u: int) -> int:\n      ans = u\n\n      for v in graph[u]:\n        res = dfs(v)\n        if quiet[res] < quiet[ans]:\n          ans = res\n\n      return ans\n\n    return map(dfs, range(len(graph)))",
      "title": "851. Loud and Rich",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c97c33ee-15f8-4a7e-996f-2be2fd1c3266",
      "code": "class Solution:\n  def peakIndexInMountainArray(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] >= arr[m + 1]:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "852. Peak Index in a Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d08238bc-173d-47b8-9081-b615576b0973",
      "code": "class Solution:\n  def carFleet(self, target: int, position: list[int], speed: list[int]) -> int:\n    ans = 0\n    times = [\n        float(target - p) / s for p, s in sorted(zip(position, speed),\n                                                 reverse=True)]\n    maxTime = 0  # the time of the slowest car to reach the target\n\n    for time in times:\n      # A car needs more time to reach the target, so it becomes the slowest.\n      if time > maxTime:\n        maxTime = time\n        ans += 1\n\n    return ans",
      "title": "853. Car Fleet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85edc8e8-1661-4a72-a9c2-67a4f3837979",
      "code": "class Solution:\n  def kSimilarity(self, s1: str, s2: str) -> int:\n    q = collections.deque([s1])\n    seen = {s1}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        if curr == s2:\n          return step\n        for child in self._getChildren(curr, s2):\n          if child in seen:\n            continue\n          q.append(child)\n          seen.add(child)\n      step += 1\n\n    return -1\n\n  def _getChildren(self, curr: str, target: str) -> list[str]:\n    children = []\n    s = list(curr)\n    i = 0  # the first index s.t. curr[i] != target[i]\n    while curr[i] == target[i]:\n      i += 1\n\n    for j in range(i + 1, len(s)):\n      if s[j] == target[i]:\n        s[i], s[j] = s[j], s[i]\n        children.append(''.join(s))\n        s[i], s[j] = s[j], s[i]\n\n    return children",
      "title": "854. K-Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6b61e8a-b19d-490b-8c33-f81878287728",
      "code": "class Solution:\n  def scoreOfParentheses(self, s: str) -> int:\n    ans = 0\n    layer = 0\n\n    for a, b in itertools.pairwise(s):\n      if a + b == '()':\n        ans += 1 << layer\n      layer += 1 if a == '(' else -1\n\n    return ans",
      "title": "856. Score of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "740e67b9-4f11-41b6-bb18-239eff6f5f09",
      "code": "class Solution:\n  def mincostToHireWorkers(\n      self,\n      quality: list[int],\n      wage: list[int],\n      k: int,\n  ) -> float:\n    ans = math.inf\n    qualitySum = 0\n    # (wagePerQuality, quality) sorted by wagePerQuality\n    workers = sorted((w / q, q) for q, w in zip(quality, wage))\n    maxHeap = []\n\n    for wagePerQuality, q in workers:\n      heapq.heappush(maxHeap, -q)\n      qualitySum += q\n      if len(maxHeap) > k:\n        qualitySum += heapq.heappop(maxHeap)\n      if len(maxHeap) == k:\n        ans = min(ans, qualitySum * wagePerQuality)\n\n    return ans",
      "title": "857. Minimum Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61a7c722-aa94-44da-b9f0-13a26a3b1dca",
      "code": "class Solution:\n  def mirrorReflection(self, p: int, q: int) -> int:\n    while p % 2 == 0 and q % 2 == 0:\n      p //= 2\n      q //= 2\n\n    if p % 2 == 0:\n      return 2\n    if q % 2 == 0:\n      return 0\n    return 1",
      "title": "858. Mirror Reflection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d3d693b-8b40-47db-879b-ba0c49165cec",
      "code": "class Solution:\n  def buddyStrings(self, s: str, goal: str) -> bool:\n    if len(s) != len(goal):\n      return False\n    if s == goal and len(set(s)) < len(s):\n      return True\n    diffIndices = [i for i, (a, b) in enumerate(zip(s, goal))\n                   if a != b]\n    return (len(diffIndices) == 2 and\n            s[diffIndices[0]] == goal[diffIndices[1]] and\n            s[diffIndices[1]] == goal[diffIndices[0]])",
      "title": "859. Buddy Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a15e241-f041-458c-999f-f88fc5b6b292",
      "code": "class Solution:\n  def lemonadeChange(self, bills: list[int]) -> bool:\n    fives = 0\n    tens = 0\n\n    for bill in bills:\n      if bill == 5:\n        fives += 1\n      elif bill == 10:\n        fives -= 1\n        tens += 1\n      else:  # bill == 20\n        if tens > 0:\n          tens -= 1\n          fives -= 1\n        else:\n          fives -= 3\n      if fives < 0:\n        return False\n\n    return True",
      "title": "860. Lemonade Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "698776b3-5ca6-4963-bb84-04661def9194",
      "code": "class Solution:\n  def matrixScore(self, grid: list[list[int]]) -> int:\n    # Flip the rows with a leading 0.\n    for row in grid:\n      if row[0] == 0:\n        self._flip(row)\n\n    # Flip the columns with 1s < 0s.\n    for j, col in enumerate(list(zip(*grid))):\n      if sum(col) * 2 < len(grid):\n        self._flipCol(grid, j)\n\n    # Add a binary number for each row.\n    return sum(self._binary(row) for row in grid)\n\n  def _flip(self, row: list[int]) -> None:\n    for i in range(len(row)):\n      row[i] ^= 1\n\n  def _flipCol(self, grid: list[list[int]], j: int) -> None:\n    for i in range(len(grid)):\n      grid[i][j] ^= 1\n\n  def _binary(self, row: list[int]) -> int:\n    res = row[0]\n    for j in range(1, len(row)):\n      res = res * 2 + row[j]\n    return res",
      "title": "861. Score After Flipping Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9f89913-498e-4550-84e5-46c47e0e2f9d",
      "code": "class Solution:\n  def shortestSubarray(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = n + 1\n    dq = collections.deque()\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(n + 1):\n      while dq and prefix[i] - prefix[dq[0]] >= k:\n        ans = min(ans, i - dq.popleft())\n      while dq and prefix[i] <= prefix[dq[-1]]:\n        dq.pop()\n      dq.append(i)\n\n    return ans if ans <= n else -1",
      "title": "862. Shortest Subarray with Sum at Least K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "219e64fb-f204-41ec-864c-ba19f3192ecb",
      "code": "class Solution:\n  def primePalindrome(self, n: int) -> int:\n    def getPalindromes(n: int) -> int:\n      length = n // 2\n      for i in range(10**(length - 1), 10**length):\n        s = str(i)\n        for j in range(10):\n          yield int(s + str(j) + s[::-1])\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    if n <= 2:\n      return 2\n    if n == 3:\n      return 3\n    if n <= 5:\n      return 5\n    if n <= 7:\n      return 7\n    if n <= 11:\n      return 11\n\n    nLength = len(str(n))\n\n    while True:\n      for num in getPalindromes(nLength):\n        if num >= n and isPrime(num):\n          return num\n      nLength += 1",
      "title": "866. Prime Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b22dcaa-39ac-4b6e-a1b3-dc855b3eadfa",
      "code": "class Solution:\n  def transpose(self, A: list[list[int]]) -> list[list[int]]:\n    ans = [[0] * len(A) for _ in range(len(A[0]))]\n\n    for i in range(len(A)):\n      for j in range(len(A[0])):\n        ans[j][i] = A[i][j]\n\n    return ans",
      "title": "867. Transpose Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2762139-9d16-49d8-a9b6-099ba063d9ae",
      "code": "class Solution:\n  def binaryGap(self, n: int) -> int:\n    ans = 0\n    d = -32  # the distance between any two 1s\n\n    while n:\n      if n % 2 == 1:\n        ans = max(ans, d)\n        d = 0\n      n //= 2\n      d += 1\n\n    return ans",
      "title": "868. Binary Gap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffd2b986-713a-4e9b-8445-c3192fa16195",
      "code": "class Solution:\n  def reorderedPowerOf2(self, n: int) -> bool:\n    count = collections.Counter(str(n))\n    return any(Counter(str(1 << i)) == count for i in range(30))",
      "title": "869. Reordered Power of 2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf765249-12bc-4c8a-8545-c18049b23bf4",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def advantageCount(self, nums1: list[int], nums2: list[int]) -> list[int]:\n    sl = SortedList(nums1)\n\n    for i, num in enumerate(nums2):\n      index = 0 if sl[-1] <= num else sl.bisect_right(num)\n      nums1[i] = sl[index]\n      del sl[index]\n\n    return nums1",
      "title": "870. Advantage Shuffle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e1c24f5-1055-4788-9d19-33c5bf1e711a",
      "code": "class Solution:\n  def minRefuelStops(\n      self,\n      target: int,\n      startFuel: int,\n      stations: list[list[int]],\n  ) -> int:\n    ans = 0\n    i = 0  # station's index\n    curr = startFuel\n    maxHeap = []\n\n    while curr < target:\n      # Add all the reachable stops to maxHeap\n      while i < len(stations) and stations[i][0] <= curr:\n        heapq.heappush(maxHeap, -stations[i][1])\n        i += 1\n      if not maxHeap:  # Can't be refueled.\n        return -1\n      curr -= heapq.heappop(maxHeap)  # Pop out the largest gas.\n      ans += 1  # Then, refuel once.\n\n    return ans",
      "title": "871. Minimum Number of Refueling Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3b16239-336a-4b86-bce6-2367f11ef981",
      "code": "class Solution:\n  def leafSimilar(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    def dfs(root: TreeNode | None) -> None:\n      if not root:\n        return\n      if not root.left and not root.right:\n        yield root.val\n        return\n\n      yield from dfs(root.left)\n      yield from dfs(root.right)\n\n    return list(dfs(root1)) == list(dfs(root2))",
      "title": "872. Leaf-Similar Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b83efbf-9077-48c0-91f9-1e3d41d16e01",
      "code": "class Solution:\n  def lenLongestFibSubseq(self, arr: list[int]) -> int:\n    n = len(arr)\n    ans = 0\n    numToIndex = {a: i for i, a in enumerate(arr)}\n    dp = [[2] * n for _ in range(n)]\n\n    for j in range(n):\n      for k in range(j + 1, n):\n        ai = arr[k] - arr[j]\n        if ai < arr[j] and ai in numToIndex:\n          i = numToIndex[ai]\n          dp[j][k] = dp[i][j] + 1\n          ans = max(ans, dp[j][k])\n\n    return ans",
      "title": "873. Length of Longest Fibonacci Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c06cd4d-d80f-463b-98a0-8ae87ad5c1b7",
      "code": "class Solution:\n  def robotSim(self, commands: list[int], obstacles: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = 0\n    d = 0  # 0 := north, 1 := east, 2 := south, 3 := west\n    x = 0  # the start x\n    y = 0  # the start y\n    obstaclesSet = {(x, y) for x, y in obstacles}\n\n    for command in commands:\n      if command == -1:\n        d = (d + 1) % 4\n      elif command == -2:\n        d = (d + 3) % 4\n      else:\n        for _ in range(command):\n          if (x + DIRS[d][0], y + DIRS[d][1]) in obstaclesSet:\n            break\n          x += DIRS[d][0]\n          y += DIRS[d][1]\n      ans = max(ans, x * x + y * y)\n\n    return ans",
      "title": "874. Walking Robot Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dda84664-4fc4-4ced-bd08-3d2bc10d36a6",
      "code": "class Solution:\n  def minEatingSpeed(self, piles: list[int], h: int) -> int:\n    def eatHours(m: int) -> bool:\n      \"\"\"Returns the hours to eat all the piles with speed m.\"\"\"\n      return sum((pile - 1) // m + 1 for pile in piles)\n    l = 1\n    r = max(piles)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: eatHours(m) <= h) + l",
      "title": "875. Koko Eating Bananas",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e070e254-0fb1-46ed-8fc1-a116a35f861e",
      "code": "class Solution:\n  def middleNode(self, head: ListNode) -> ListNode:\n    slow = head\n    fast = head\n\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    return slow",
      "title": "876. Middle of the Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30048e24-7125-484c-9741-5da1a82e9cab",
      "code": "class Solution:\n  def stoneGame(self, piles: list[int]) -> bool:\n    n = len(piles)\n    # dp[i][j] := the maximum stones you can get more than your opponent in piles[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, pile in enumerate(piles):\n      dp[i][i] = pile\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = max(piles[i] - dp[i + 1][j],\n                       piles[j] - dp[i][j - 1])\n\n    return dp[0][n - 1] > 0",
      "title": "877. Stone Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ed32087-5edd-4ee2-b7a7-a74792ed09e3",
      "code": "class Solution:\n  def nthMagicalNumber(self, n: int, a: int, b: int) -> int:\n    lcm = a * b // math.gcd(a, b)\n    l = min(a, b)\n    r = min(a, b) * n\n    ans = bisect.bisect_left(range(l, r), n,\n                             key=lambda m: m // a + m // b - m // lcm) + l\n    return ans % (10**9 + 7)",
      "title": "878. Nth Magical Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44de3fa3-b178-42c0-ab84-b896811fcf05",
      "code": "class Solution:\n  def decodeAtIndex(self, s: str, k: int) -> str:\n    size = 0\n\n    for c in s:\n      if c.isdigit():\n        size *= int(c)\n      else:\n        size += 1\n\n    for c in reversed(s):\n      k %= size\n      if k == 0 and c.isalpha():\n        return c\n      if c.isdigit():\n        size //= int(c)\n      else:\n        size -= 1",
      "title": "880. Decoded String at Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2f44e56-fe8f-4cfb-8a3b-a6531e4c49ae",
      "code": "class Solution:\n  def numRescueBoats(self, people: list[int], limit: int) -> int:\n    ans = 0\n    i = 0\n    j = len(people) - 1\n\n    people.sort()\n\n    while i <= j:\n      remain = limit - people[j]\n      j -= 1\n      if people[i] <= remain:\n        i += 1\n      ans += 1\n\n    return ans",
      "title": "881. Boats to Save People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da79c0ab-c144-46fb-899b-b0b011b55893",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      edges: list[list[int]],\n      maxMoves: int,\n      n: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    dist = [maxMoves + 1] * n\n\n    for u, v, cnt in edges:\n      graph[u].append((v, cnt))\n      graph[v].append((u, cnt))\n\n    reachableNodes = self._dijkstra(graph, 0, maxMoves, dist)\n    reachableSubnodes = 0\n\n    for u, v, cnt in edges:\n      # the number of reachable nodes of (u, v) from `u`\n      a = 0 if dist[u] > maxMoves else min(maxMoves - dist[u], cnt)\n      # the number of reachable nodes of (u, v) from `v`\n      b = 0 if dist[v] > maxMoves else min(maxMoves - dist[v], cnt)\n      reachableSubnodes += min(a + b, cnt)\n\n    return reachableNodes + reachableSubnodes\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      maxMoves: int,\n      dist: list[int],\n  ) -> int:\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      # Already took `maxMoves` to reach `u`, so can't explore anymore.\n      if dist[u] >= maxMoves:\n        break\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        newDist = d + w + 1\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (newDist, v))\n\n    return sum(d <= maxMoves for d in dist)",
      "title": "882. Reachable Nodes In Subdivided Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1383233b-e7e8-4d21-b68b-7d338eee1fac",
      "code": "class Solution:\n  def projectionArea(self, grid: list[list[int]]) -> int:\n    return sum(\n        a > 0 for row in grid for a in row) + sum(\n        max(row) for row in grid) + sum(\n        max(col) for col in zip(*grid))",
      "title": "883. Projection Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b1efcf3-7cca-4c05-a4c6-331943ce9c43",
      "code": "class Solution:\n  def uncommonFromSentences(self, A: str, B: str) -> list[str]:\n    count = collections.Counter((A + ' ' + B).split())\n    return [word for word, freq in count.items() if freq == 1]",
      "title": "884. Uncommon Words from Two Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88d1bf60-1b3e-489d-a46f-c551e92d18c0",
      "code": "class Solution:\n  def spiralMatrixIII(self, rows: int, cols: int, rStart: int, cStart: int) -> list[list[int]]:\n    dx = [1, 0, -1, 0]\n    dy = [0, 1, 0, -1]\n    ans = [[rStart, cStart]]\n    i = 0\n\n    while len(ans) < rows * cols:\n      for _ in range(i // 2 + 1):\n        rStart += dy[i % 4]\n        cStart += dx[i % 4]\n        if 0 <= rStart < rows and 0 <= cStart < cols:\n          ans.append([rStart, cStart])\n      i += 1\n\n    return ans",
      "title": "885. Spiral Matrix III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c45a19f-7a59-4801-bd63-ae67d251b965",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  WHITE = 0\n  RED = 1\n  GREEN = 2\n\n\nclass Solution:\n  def possibleBipartition(self, n: int, dislikes: list[list[int]]) -> bool:\n    graph = [[] for _ in range(n + 1)]\n    colors = [Color.WHITE] * (n + 1)\n\n    for u, v in dislikes:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Reduce to 785. Is Graph Bipartite?\n    def isValidColor(u: int, color: Color) -> bool:\n      # Always paint red for a white node.\n      if colors[u] != Color.WHITE:\n        return colors[u] == color\n\n      colors[u] = color  # Always paint the node with `color`.\n\n      # All the children should have valid colors.\n      childrenColor = Color.RED if colors[u] == Color.GREEN else Color.GREEN\n      return all(isValidColor(v, childrenColor) for v in graph[u])\n\n    return all(colors[i] != Color.WHITE or isValidColor(i, Color.RED)\n               for i in range(1, n + 1))",
      "title": "886. Possible Bipartition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbc956a5-81ea-4194-8486-7bc5f376cffd",
      "code": "class Solution:\n  def superEggDrop(self, k: int, n: int) -> int:\n    moves = 0\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n\n    while dp[moves][k] < n:\n      moves += 1\n      for eggs in range(1, k + 1):\n        dp[moves][eggs] = (dp[moves - 1][eggs - 1] +\n                           dp[moves - 1][eggs] + 1)\n\n    return moves",
      "title": "887. Super Egg Drop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3231d60d-b1c3-44b6-b11b-68cf490c8417",
      "code": "class Solution:\n  def fairCandySwap(\n      self,\n      aliceSizes: list[int],\n      bobSizes: list[int],\n  ) -> list[int]:\n    diff = (sum(aliceSizes) - sum(bobSizes)) // 2\n    bobSizesSet = set(bobSizes)\n\n    for aliceSize in aliceSizes:\n      target = aliceSize - diff\n      if target in bobSizesSet:\n        return [aliceSize, target]",
      "title": "888. Fair Candy Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c8d8621-bdb9-4cc8-9c29-3f25e5db07e6",
      "code": "class Solution:\n  def constructFromPrePost(\n      self,\n      pre: list[int],\n      post: list[int],\n  ) -> TreeNode | None:\n    postToIndex = {num: i for i, num in enumerate(post)}\n\n    def build(preStart: int, preEnd: int, postStart: int, postEnd: int) -> TreeNode | None:\n      if preStart > preEnd:\n        return None\n      if preStart == preEnd:\n        return TreeNode(pre[preStart])\n\n      rootVal = pre[preStart]\n      leftRootVal = pre[preStart + 1]\n      leftRootPostIndex = postToIndex[leftRootVal]\n      leftSize = leftRootPostIndex - postStart + 1\n\n      root = TreeNode(rootVal)\n      root.left = build(preStart + 1, preStart + leftSize,\n                        postStart, leftRootPostIndex)\n      root.right = build(preStart + leftSize + 1, preEnd,\n                         leftRootPostIndex + 1, postEnd - 1)\n      return root\n\n    return build(0, len(pre) - 1, 0, len(post) - 1)",
      "title": "889. Construct Binary Tree from Preorder and Postorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee764b6d-9649-4eaa-868a-7f1e991b312d",
      "code": "class Solution:\n  def findAndReplacePattern(self, words: list[str], pattern: str) -> list[str]:\n    def isIsomorphic(w: str, p: str) -> bool:\n      return [*map(w.index, w)] == [*map(p.index, p)]\n    return [word for word in words if isIsomorphic(word, pattern)]",
      "title": "890. Find and Replace Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa45ae6a-85e2-4b24-8a22-378ed3642f95",
      "code": "class Solution:\n  def sumSubseqWidths(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    exp = 1\n\n    nums.sort()\n\n    for i in range(n):\n      ans += (nums[i] - nums[n - 1 - i]) * exp\n      ans %= MOD\n      exp = exp * 2 % MOD\n\n    return ans",
      "title": "891. Sum of Subsequence Widths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "186814ac-1b79-4a36-bba8-13fc092c4df0",
      "code": "class Solution:\n  def surfaceArea(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(len(grid)):\n      for j in range(len(grid)):\n        if grid[i][j]:\n          ans += grid[i][j] * 4 + 2\n        if i > 0:\n          ans -= min(grid[i][j], grid[i - 1][j]) * 2\n        if j > 0:\n          ans -= min(grid[i][j], grid[i][j - 1]) * 2\n\n    return ans",
      "title": "892. Surface Area of 3D Shapes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96aed02c-7113-43ab-a985-2e545144ebea",
      "code": "class Solution:\n  def numSpecialEquivGroups(self, words: list[str]) -> int:\n    return len({''.join(sorted(word[::2])) + ''.join(sorted(word[1::2]))\n                for word in words})",
      "title": "893. Groups of Special-Equivalent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "767ac90c-b6e7-4493-99f9-a014d7f713c8",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def allPossibleFBT(self, n: int) -> list[TreeNode | None]:\n    if n % 2 == 0:\n      return []\n    if n == 1:\n      return [TreeNode(0)]\n\n    ans = []\n\n    for leftCount in range(n):\n      rightCount = n - 1 - leftCount\n      for left in self.allPossibleFBT(leftCount):\n        for right in self.allPossibleFBT(rightCount):\n          ans.append(TreeNode(0))\n          ans[-1].left = left\n          ans[-1].right = right\n\n    return ans",
      "title": "894. All Possible Full Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e28aff0-058e-4370-bec9-c9fb817be558",
      "code": "class Solution:\n  def isMonotonic(self, nums: list[int]) -> bool:\n    increasing = True\n    decreasing = True\n\n    for i in range(1, len(nums)):\n      increasing &= nums[i - 1] <= nums[i]\n      decreasing &= nums[i - 1] >= nums[i]\n\n    return increasing or decreasing",
      "title": "896. Monotonic Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bdce909-0e50-4266-b32b-7d9ce696270a",
      "code": "class Solution:\n  def increasingBST(self, root: TreeNode, tail: TreeNode = None) -> TreeNode:\n    if not root:\n      return tail\n\n    res = self.increasingBST(root.left, root)\n    root.left = None\n    root.right = self.increasingBST(root.right, tail)\n    return res",
      "title": "897. Increasing Order Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d9dce41-2844-4c0c-9651-1454d6c6ee16",
      "code": "class Solution:\n  def orderlyQueue(self, s: str, k: int) -> str:\n    return (''.join(sorted(s)) if k > 1\n            else min(s[i:] + s[:i] for i in range(len(s))))",
      "title": "899. Orderly Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b65c0b03-f4d3-4eac-b287-980e12d40bb7",
      "code": "class Solution:\n  def atMostNGivenDigitSet(self, digits: list[str], n: int) -> int:\n    ans = 0\n    num = str(n)\n\n    for i in range(1, len(num)):\n      ans += pow(len(digits), i)\n\n    for i, c in enumerate(num):\n      dHasSameNum = False\n      for digit in digits:\n        if digit[0] < c:\n          ans += pow(len(digits), len(num) - i - 1)\n        elif digit[0] == c:\n          dHasSameNum = True\n      if not dHasSameNum:\n        return ans\n\n    return ans + 1",
      "title": "902. Numbers At Most N Given Digit Set",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab569be8-8bf5-4afb-b22e-86cdc75b66b5",
      "code": "class Solution:\n  def totalFruit(self, fruits: list[int]) -> int:\n    ans = 0\n    count = collections.defaultdict(int)\n\n    l = 0\n    for r, fruit in enumerate(fruits):\n      count[fruit] += 1\n      while len(count) > 2:\n        count[fruits[l]] -= 1\n        if count[fruits[l]] == 0:\n          del count[fruits[l]]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "904. Fruit Into Baskets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6f9b8a2-3f1e-45f8-90e2-42ac714ba52c",
      "code": "class Solution:\n  def sortArrayByParity(self, nums: list[int]) -> list[int]:\n    l = 0\n    r = len(nums) - 1\n\n    while l < r:\n      if nums[l] % 2 == 1 and nums[r] % 2 == 0:\n        nums[l], nums[r] = nums[r], nums[l]\n      if nums[l] % 2 == 0:\n        l += 1\n      if nums[r] % 2 == 1:\n        r -= 1\n\n    return nums",
      "title": "905. Sort Array By Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5f65c97-7ead-45c2-b3f2-9ba0149cd616",
      "code": "class Solution:\n  def superpalindromesInRange(self, left: str, right: str) -> int:\n    def nextPalindrome(num: int) -> int:\n      s = str(num)\n      n = len(s)\n\n      half = s[0:(n + 1) // 2]\n      reversedHalf = half[:n // 2][::-1]\n      candidate = int(half + reversedHalf)\n      if candidate >= num:\n        return candidate\n\n      half = str(int(half) + 1)\n      reversedHalf = half[:n // 2][::-1]\n      return int(half + reversedHalf)\n\n    def isPalindrome(num: int) -> bool:\n      s = str(num)\n      l = 0\n      r = len(s) - 1\n\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n\n      return True\n\n    ans = 0\n    l = int(left)\n    r = int(right)\n    i = math.isqrt(l)\n\n    while i * i <= r:\n      palindrome = nextPalindrome(i)\n      squared = palindrome**2\n      if squared <= r and isPalindrome(squared):\n        ans += 1\n      i = palindrome + 1\n\n    return ans",
      "title": "906. Super Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cff8f36-7244-402d-92eb-38a21972ec2c",
      "code": "class Solution:\n  def sumSubarrayMins(self, arr: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(arr)\n    ans = 0\n    # prevMin[i] := index k s.t. arr[k] is the previous minimum in arr[:i]\n    prevMin = [-1] * n\n    # nextMin[i] := index k s.t. arr[k] is the next minimum in arr[i + 1:]\n    nextMin = [n] * n\n    stack = []\n\n    for i, a in enumerate(arr):\n      while stack and arr[stack[-1]] > a:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    for i, a in enumerate(arr):\n      ans += a * (i - prevMin[i]) * (nextMin[i] - i)\n      ans %= MOD\n\n    return ans",
      "title": "907. Sum of Subarray Minimums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c49e627-9f8e-42a5-9f16-3bd7da5b68ed",
      "code": "class Solution:\n  def smallestRangeI(self, nums: list[int], k: int) -> int:\n    return max(0, max(nums) - min(nums) - 2 * k)",
      "title": "908. Smallest Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9791ac45-8baa-4bed-bb00-c87c35611beb",
      "code": "class Solution:\n  def snakesAndLadders(self, board: list[list[int]]) -> int:\n    n = len(board)\n    q = collections.deque([1])\n    seen = set()\n    arr = [0] * (1 + n * n)  # 2D -> 1D\n\n    for i in range(n):\n      for j in range(n):\n        arr[(n - 1 - i) * n + (n - j if (n - i) % 2 == 0 else j + 1)] = board[i][j]\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for next in range(curr + 1, min(curr + 6, n * n) + 1):\n          dest = arr[next] if arr[next] > 0 else next\n          if dest == n * n:\n            return step\n          if dest in seen:\n            continue\n          q.append(dest)\n          seen.add(dest)\n      step += 1\n\n    return -1",
      "title": "909. Snakes and Ladders",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57b7e200-c1c1-46f7-8eaa-dcc9a9858d8f",
      "code": "class Solution:\n  def smallestRangeII(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = nums[-1] - nums[0]\n    left = nums[0] + k\n    right = nums[-1] - k\n\n    for a, b in itertools.pairwise(nums):\n      mn = min(left, b - k)\n      mx = max(right, a + k)\n      ans = min(ans, mx - mn)\n\n    return ans",
      "title": "910. Smallest Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "231387ba-f751-483d-acb5-16ed1052c4b8",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "616bec97-f6aa-45d1-bffb-b8684ce039a6",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> list[int]:\n    self._mergeSort(nums, 0, len(nums) - 1)\n    return nums\n\n  def _mergeSort(self, nums: list[int], l: int, r: int) -> None:\n    if l >= r:\n      return\n\n    def merge(nums: list[int], l: int, m: int, r: int) -> None:\n      sorted = [0] * (r - l + 1)\n      k = 0  # sorted's index\n      i = l  # left's index\n      j = m + 1  # right's index\n\n      while i <= m and j <= r:\n        if nums[i] < nums[j]:\n          sorted[k] = nums[i]\n          k += 1\n          i += 1\n        else:\n          sorted[k] = nums[j]\n          k += 1\n          j += 1\n\n      # Put the possible remaining left part into the sorted array.\n      while i <= m:\n        sorted[k] = nums[i]\n        k += 1\n        i += 1\n\n      # Put the possible remaining right part into the sorted array.\n      while j <= r:\n        sorted[k] = nums[j]\n        k += 1\n        j += 1\n\n      nums[l:l + len(sorted)] = sorted\n\n    m = (l + r) // 2\n    self._mergeSort(nums, l, m)\n    self._mergeSort(nums, m + 1, r)\n    merge(nums, l, m, r)",
      "title": "912. Sort an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e30d0380-b733-4aad-89f7-05c38ca62ccc",
      "code": "from enum import IntEnum\n\n\nclass State(IntEnum):\n  DRAW = 0\n  MOUSE_WIN = 1\n  CAT_WIN = 2\n\n\nclass Solution:\n  def catMouseGame(self, graph: list[list[int]]) -> int:\n    n = len(graph)\n    # result of (cat, mouse, move)\n    # move := 0 (mouse) // 1 (cat)\n    states = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    outDegree = [[[0] * 2 for _ in range(n)] for _ in range(n)]\n    q = collections.deque()  # (cat, mouse, move, state)\n\n    for cat in range(n):\n      for mouse in range(n):\n        outDegree[cat][mouse][0] = len(graph[mouse])\n        outDegree[cat][mouse][1] = len(graph[cat]) - graph[cat].count(0)\n\n    # Start from the states s.t. the winner can be determined.\n    for cat in range(1, n):\n      for move in range(2):\n        # Mouse is in the hole.\n        states[cat][0][move] = int(State.MOUSE_WIN)\n        q.append((cat, 0, move, int(State.MOUSE_WIN)))\n        # Cat catches mouse.\n        states[cat][cat][move] = int(State.CAT_WIN)\n        q.append((cat, cat, move, int(State.CAT_WIN)))\n\n    while q:\n      cat, mouse, move, state = q.popleft()\n      if cat == 2 and mouse == 1 and move == 0:\n        return state\n      prevMove = move ^ 1\n      for prev in graph[cat if prevMove else mouse]:\n        prevCat = prev if prevMove else cat\n        if prevCat == 0:  # invalid\n          continue\n        prevMouse = mouse if prevMove else prev\n        # The state has been determined.\n        if states[prevCat][prevMouse][prevMove]:\n          continue\n        if (prevMove == 0 and state == int(State.MOUSE_WIN) or\n                prevMove == 1 and state == int(State.CAT_WIN)):\n          states[prevCat][prevMouse][prevMove] = state\n          q.append((prevCat, prevMouse, prevMove, state))\n        else:\n          outDegree[prevCat][prevMouse][prevMove] -= 1\n          if outDegree[prevCat][prevMouse][prevMove] == 0:\n            states[prevCat][prevMouse][prevMove] = state\n            q.append((prevCat, prevMouse, prevMove, state))\n\n    return states[2][1][0]",
      "title": "913. Cat and Mouse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f340c810-c947-4ae1-8ef1-1113e8bc90d2",
      "code": "class Solution:\n  def hasGroupsSizeX(self, deck: list[int]) -> bool:\n    count = collections.Counter(deck)\n    return functools.reduce(math.gcd, count.values()) >= 2",
      "title": "914. X of a Kind in a Deck of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62f4bbc0-3514-40d1-8f29-c60c324a3a11",
      "code": "class Solution:\n  def partitionDisjoint(self, nums: list[int]) -> int:\n    n = len(nums)\n    mn = [0] * (n - 1) + [nums[-1]]\n    mx = -math.inf\n\n    for i in range(n - 2, - 1, -1):\n      mn[i] = min(mn[i + 1], nums[i])\n\n    for i, num in enumerate(nums):\n      mx = max(mx, num)\n      if mx <= mn[i + 1]:\n        return i + 1",
      "title": "915. Partition Array into Disjoint Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8abdf97c-d267-4a42-8883-27ef45f856b3",
      "code": "class Solution:\n  def wordSubsets(self, A: list[str], B: list[str]) -> list[str]:\n    count = collections.Counter()\n\n    for b in B:\n      count = count | collections.Counter(b)\n\n    return [a for a in A if collections.Counter(a) & count == count]",
      "title": "916. Word Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d39abac6-d49d-44fa-a68b-3d537c242f14",
      "code": "class Solution:\n  def reverseOnlyLetters(self, s: str) -> str:\n    ans = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      while i < j and not s[i].isalpha():\n        i += 1\n      while i < j and not s[j].isalpha():\n        j -= 1\n      ans[i], ans[j] = ans[j], ans[i]\n      i += 1\n      j -= 1\n\n    return ''.join(ans)",
      "title": "917. Reverse Only Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1623bf3c-1064-4546-85a9-f67ab25cc66c",
      "code": "class Solution:\n  def maxSubarraySumCircular(self, nums: list[int]) -> int:\n    totalSum = 0\n    currMaxSum = 0\n    currMinSum = 0\n    maxSum = -math.inf\n    minSum = math.inf\n\n    for num in nums:\n      totalSum += num\n      currMaxSum = max(currMaxSum + num, num)\n      currMinSum = min(currMinSum + num, num)\n      maxSum = max(maxSum, currMaxSum)\n      minSum = min(minSum, currMinSum)\n\n    return maxSum if maxSum < 0 else max(maxSum, totalSum - minSum)",
      "title": "918. Maximum Sum Circular Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9975ae47-3350-464b-b4a5-08096d6b5d89",
      "code": "class Solution:\n  def minAddToMakeValid(self, s: str) -> int:\n    l = 0\n    r = 0\n\n    for c in s:\n      if c == '(':\n        l += 1\n      else:\n        if l == 0:\n          r += 1\n        else:\n          l -= 1\n\n    return l + r",
      "title": "921. Minimum Add to Make Parentheses Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5ace845-b278-4b6d-b203-5a60b170700e",
      "code": "class Solution:\n  def sortArrayByParityII(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    i = 0\n    j = 1\n    while i < n:\n      while i < n and nums[i] % 2 == 0:\n        i += 2\n      while j < n and nums[j] % 2 == 1:\n        j += 2\n      if i < n:\n        nums[i], nums[j] = nums[j], nums[i]\n\n    return nums",
      "title": "922. Sort Array By Parity II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f74a399-6ce4-4afe-b2e4-bbe03a1472b1",
      "code": "class Solution:\n  def threeSumMulti(self, arr: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(arr)\n\n    for i, x in count.items():\n      for j, y in count.items():\n        k = target - i - j\n        if k not in count:\n          continue\n        if i == j and j == k:\n          ans = (ans + x * (x - 1) * (x - 2) // 6) % MOD\n        elif i == j and j != k:\n          ans = (ans + x * (x - 1) // 2 * count[k]) % MOD\n        elif i < j and j < k:\n          ans = (ans + x * y * count[k]) % MOD\n\n    return ans % MOD",
      "title": "923. 3Sum With Multiplicity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09c9a9db-d904-400e-8c72-6abaa2a106f6",
      "code": "class Solution:\n  def isLongPressedName(self, name: str, typed: str) -> bool:\n    i = 0\n\n    for j, t in enumerate(typed):\n      if i < len(name) and name[i] == t:\n        i += 1\n      elif j == 0 or t != typed[j - 1]:\n        return False\n\n    return i == len(name)",
      "title": "925. Long Pressed Name",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10fc7c7d-3baf-4b75-b2f3-bac1b3e2be10",
      "code": "class Solution:\n  def minFlipsMonoIncr(self, s: str) -> int:\n    # the number of characters to be flilpped to make the substring so far\n    # monotone increasing\n    dp = 0\n    count1 = 0\n\n    for c in s:\n      if c == '0':\n        # 1. Flip '0'.\n        # 2. Keep '0' and flip all the previous 1s.\n        dp = min(dp + 1, count1)\n      else:\n        count1 += 1\n\n    return dp",
      "title": "926. Flip String to Monotone Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6fa1da2-5e16-49eb-afbf-8337903fbed7",
      "code": "class Solution:\n  def threeEqualParts(self, arr: list[int]) -> list[int]:\n    ones = sum(a == 1 for a in arr)\n\n    if ones == 0:\n      return [0, len(arr) - 1]\n    if ones % 3 != 0:\n      return [-1, -1]\n\n    k = ones // 3\n    i = 0\n\n    for i in range(len(arr)):\n      if arr[i] == 1:\n        first = i\n        break\n\n    gapOnes = k\n\n    for j in range(i + 1, len(arr)):\n      if arr[j] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          second = j\n          break\n\n    gapOnes = k\n\n    for i in range(j + 1, len(arr)):\n      if arr[i] == 1:\n        gapOnes -= 1\n        if gapOnes == 0:\n          third = i\n          break\n\n    while third < len(arr) and arr[first] == arr[second] == arr[third]:\n      first += 1\n      second += 1\n      third += 1\n\n    if third == len(arr):\n      return [first - 1, second]\n    return [-1, -1]",
      "title": "927. Three Equal Parts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "300da3e0-8420-483a-83a1-ecffd1b72e1a",
      "code": "class Solution:\n  def numUniqueEmails(self, emails: list[str]) -> int:\n    seen = set()\n\n    for email in emails:\n      local, domain = email.split('@')\n      local = local.split('+')[0].replace('.', '')\n      seen.add(local + '@' + domain)\n\n    return len(seen)",
      "title": "929. Unique Email Addresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ce348ed-1caf-4af1-b495-75da13051cf8",
      "code": "class Solution:\n  def numSubarraysWithSum(self, nums: list[int], goal: int) -> int:\n    def numSubarraysWithSumAtMost(goal: int) -> int:\n      res = 0\n      count = 0\n      l = 0\n      r = 0\n\n      while r < len(nums):\n        count += nums[r]\n        r += 1\n        while l < r and count > goal:\n          count -= nums[l]\n          l += 1\n        # nums[l..r), nums[l + 1..r), ..., nums[r - 1]\n        res += r - l\n\n      return res\n\n    return numSubarraysWithSumAtMost(goal) - numSubarraysWithSumAtMost(goal - 1)",
      "title": "930. Binary Subarrays With Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74283b8b-4b3a-4fb0-9a69-e9e20d57a398",
      "code": "class Solution:\n  def minFallingPathSum(self, A: list[list[int]]) -> int:\n    n = len(A)\n\n    for i in range(1, n):\n      for j in range(n):\n        mn = math.inf\n        for k in range(max(0, j - 1), min(n, j + 2)):\n          mn = min(mn, A[i - 1][k])\n        A[i][j] += mn\n\n    return min(A[-1])",
      "title": "931. Minimum Falling Path Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bc68168-8406-4e84-89e3-98402f96a8ed",
      "code": "class Solution:\n  def beautifulArray(self, n: int) -> list[int]:\n    arr = [i for i in range(1, n + 1)]\n\n    def partition(l: int, r: int, mask: int) -> int:\n      nextSwapped = l\n      for i in range(l, r + 1):\n        if arr[i] & mask:\n          arr[i], arr[nextSwapped] = arr[nextSwapped], arr[i]\n          nextSwapped += 1\n      return nextSwapped - 1\n\n    def divide(l: int, r: int, mask: int) -> None:\n      if l >= r:\n        return\n      m = partition(l, r, mask)\n      divide(l, m, mask << 1)\n      divide(m + 1, r, mask << 1)\n\n    divide(0, n - 1, 1)\n    return arr",
      "title": "932. Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a0576b4-aa90-43f3-9d30-560b4e88923b",
      "code": "class Solution:\n  def knightDialer(self, n: int) -> int:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    MOD = 1_000_000_007\n\n    # dp[i][j] := the number of ways stand on (i, j)\n    dp = [[1] * 3 for _ in range(4)]\n    dp[3][0] = dp[3][2] = 0\n\n    for _ in range(n - 1):\n      newDp = [[0] * 3 for _ in range(4)]\n      for i in range(4):\n        for j in range(3):\n          if (i, j) in ((3, 0), (3, 2)):\n            continue\n          for dx, dy in DIRS:\n            x = i + dx\n            y = j + dy\n            if x < 0 or x >= 4 or y < 0 or y >= 3:\n              continue\n            if (x, y) in ((3, 0), (3, 2)):\n              continue\n            newDp[x][y] = (newDp[x][y] + dp[i][j]) % MOD\n      dp = newDp\n\n    return sum(map(sum, dp)) % MOD",
      "title": "935. Knight Dialer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23923d00-6432-4ea3-8e84-58f82e3f31d8",
      "code": "class Solution:\n  def movesToStamp(self, stamp: str, target: str) -> list[int]:\n    def stampify(s: int) -> int:\n      \"\"\"\n      Stamps target[i..i + |stamp|) and returns the number of newly stamped\n      characters.\n      e.g. stampify(\"abc\", \"ababc\", 2) returns 3 because target becomes \"ab***\".\n      \"\"\"\n      stampified = len(stamp)\n\n      for i, st in enumerate(stamp):\n        if target[s + i] == '*':  # It's already been stamped.\n          stampified -= 1\n        elif target[s + i] != st:  # We can't stamp on the index i.\n          return 0\n\n      for i in range(s, s + len(stamp)):\n        target[i] = '*'\n\n      return stampified\n\n    ans = []\n    target = list(target)\n    # stamped[i] := True if we already stamped target by stamping on index i\n    stamped = [False] * len(target)\n    stampedCount = 0  # Our goal is to make stampedCount = |target|.\n\n    while stampedCount < len(target):\n      isStamped = False\n      # Try to stamp target[i..i + |stamp|) for each index.\n      for i in range(len(target) - len(stamp) + 1):\n        if stamped[i]:\n          continue\n        stampified = stampify(i)\n        if stampified == 0:\n          continue\n        stampedCount += stampified\n        isStamped = True\n        stamped[i] = True\n        ans.append(i)\n      # After trying to stamp on each index, we can't find a valid stamp.\n      if not isStamped:\n        return []\n\n    return ans[::-1]",
      "title": "936. Stamping The Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4155f997-8f67-4560-a472-c981cdb95280",
      "code": "class Solution:\n  def reorderLogFiles(self, logs: list[str]) -> list[str]:\n    digitLogs = []\n    letterLogs = []\n\n    for log in logs:\n      i = log.index(' ')\n      if log[i + 1].isdigit():\n        digitLogs.append(log)\n      else:\n        letterLogs.append((log[:i], log[i + 1:]))\n\n    letterLogs.sort(key=lambda x: (x[1], x[0]))\n    return [identifier + ' ' + letters for identifier, letters in letterLogs] + digitLogs",
      "title": "937. Reorder Data in Log Files",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7462502-1957-47ce-bf10-2f709eca09ad",
      "code": "class Solution:\n  def minAreaRect(self, points: list[list[int]]) -> int:\n    ans = math.inf\n    xToYs = collections.defaultdict(set)\n\n    for x, y in points:\n      xToYs[x].add(y)\n\n    for i in range(len(points)):\n      for j in range(i):\n        x1, y1 = points[i]\n        x2, y2 = points[j]\n        if x1 == x2 or y1 == y2:\n          continue\n        if y2 in xToYs[x1] and y1 in xToYs[x2]:\n          ans = min(ans, abs(x1 - x2) * abs(y1 - y2))\n\n    return ans if ans < math.inf else 0",
      "title": "939. Minimum Area Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c85f05d0-5440-47be-b64d-409796148d6a",
      "code": "class Solution:\n  def distinctSubseqII(self, s: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('a' + i)\n    endsIn = [0] * 26\n\n    for c in s:\n      endsIn[ord(c) - ord('a')] = (sum(endsIn) + 1) % MOD\n\n    return sum(endsIn) % MOD",
      "title": "940. Distinct Subsequences II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b422f59a-0b1a-40bf-b5e7-b1833b15890e",
      "code": "class Solution:\n  def validMountainArray(self, arr: list[int]) -> bool:\n    if len(arr) < 3:\n      return False\n\n    l = 0\n    r = len(arr) - 1\n\n    while l + 1 < len(arr) and arr[l] < arr[l + 1]:\n      l += 1\n    while r > 0 and arr[r] < arr[r - 1]:\n      r -= 1\n\n    return l > 0 and r < len(arr) - 1 and l == r",
      "title": "941. Valid Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b95ae40-afb8-4b2f-a63b-32b6c0106327",
      "code": "class Solution:\n  def diStringMatch(self, s: str) -> list[int]:\n    ans = []\n    mn = 0\n    mx = len(s)\n\n    for c in s:\n      if c == 'I':\n        ans.append(mn)\n        mn += 1\n      else:\n        ans.append(mx)\n        mx -= 1\n\n    return ans + [mn]",
      "title": "942. DI String Match",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23a24875-6a14-4408-ac19-bba287a3849d",
      "code": "class Solution:\n  def minDeletionSize(self, strs: list[str]) -> int:\n    ans = 0\n\n    for j in range(len(strs[0])):\n      for i in range(len(strs) - 1):\n        if strs[i][j] > strs[i + 1][j]:\n          ans += 1\n          break\n\n    return ans",
      "title": "944. Delete Columns to Make Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df9860b5-2370-48ec-9c2d-2f0524f986c9",
      "code": "class Solution:\n  def minIncrementForUnique(self, nums: list[int]) -> int:\n    ans = 0\n    minAvailable = 0\n\n    for num in sorted(nums):\n      ans += max(minAvailable - num, 0)\n      minAvailable = max(minAvailable, num) + 1\n\n    return ans",
      "title": "945. Minimum Increment to Make Array Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35042d52-5734-4fed-a77e-c6a558f40583",
      "code": "class Solution:\n  def validateStackSequences(\n      self,\n      pushed: list[int],\n      popped: list[int],\n  ) -> bool:\n    stack = []\n    i = 0  # popped's index\n\n    for x in pushed:\n      stack.append(x)\n      while stack and stack[-1] == popped[i]:\n        stack.pop()\n        i += 1\n\n    return not stack",
      "title": "946. Validate Stack Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f685b3b-1eab-43bd-9d26-d183b073fed2",
      "code": "class Solution:\n  def bagOfTokensScore(self, tokens: list[int], power: int) -> int:\n    ans = 0\n    score = 0\n    q = collections.deque(sorted(tokens))\n\n    while q and (power >= q[0] or score):\n      while q and power >= q[0]:\n        # Play the smallest face up.\n        power -= q.popleft()\n        score += 1\n      ans = max(ans, score)\n      if q and score:\n        # Play the largest face down.\n        power += q.pop()\n        score -= 1\n\n    return ans",
      "title": "948. Bag of Tokens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1f58b04-7224-46c0-8881-a2b98248db05",
      "code": "class Solution:\n  def largestTimeFromDigits(self, arr: list[int]) -> str:\n    for time in itertools.permutations(sorted(arr, reverse=True)):\n      if time[:2] < (2, 4) and time[2] < 6:\n        return '%d%d:%d%d' % time\n    return ''",
      "title": "949. Largest Time for Given Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b83bde06-40be-4b8a-a9df-9925671a11e2",
      "code": "class Solution:\n  def deckRevealedIncreasing(self, deck: list[int]) -> list[int]:\n    dq = collections.deque()\n\n    for card in reversed(sorted(deck)):\n      dq.rotate()\n      dq.appendleft(card)\n\n    return list(dq)",
      "title": "950. Reveal Cards In Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25e5c712-ad73-44b0-a0db-685f6e65fb6b",
      "code": "class Solution:\n  def flipEquiv(self, root1: TreeNode | None, root2: TreeNode | None) -> bool:\n    if not root1:\n      return not root2\n    if not root2:\n      return not root1\n    if root1.val != root2.val:\n      return False\n    return (self.flipEquiv(root1.left, root2.left) and\n            self.flipEquiv(root1.right, root2.right) or\n            self.flipEquiv(root1.left, root2.right) and\n            self.flipEquiv(root1.right, root2.left))",
      "title": "951. Flip Equivalent Binary Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05188cd7-61bc-4c7c-852e-1a2229545893",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def largestComponentSize(self, nums: list[int]) -> int:\n    ans = 0\n    uf = UnionFind(max(nums) + 1)\n    count = collections.Counter()\n\n    for num in nums:\n      for x in range(2, math.isqrt(num) + 1):\n        if num % x == 0:\n          uf.unionByRank(num, x)\n          uf.unionByRank(num, num // x)\n\n    for num in nums:\n      numRoot = uf.find(num)\n      count[numRoot] += 1\n      ans = max(ans, count[numRoot])\n\n    return ans",
      "title": "952. Largest Component Size by Common Factor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c244bdac-d744-40b4-9918-598c6d048183",
      "code": "class Solution:\n  def isAlienSorted(self, words: list[str], order: str) -> bool:\n    dict = {c: i for i, c in enumerate(order)}\n    words = [[dict[c] for c in word] for word in words]\n    return all(w1 <= w2 for w1, w2 in zip(words, words[1:]))",
      "title": "953. Verifying an Alien Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db1b8494-390b-4095-900c-1040de9332e7",
      "code": "class Solution:\n  def canReorderDoubled(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n\n    for key in sorted(count, key=abs):\n      if count[key] > count[2 * key]:\n        return False\n      count[2 * key] -= count[key]\n\n    return True",
      "title": "954. Array of Doubled Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee4d36e2-fa45-46a8-be14-2b376d0e8afd",
      "code": "class Solution:\n  def prisonAfterNDays(self, cells: list[int], n: int) -> list[int]:\n    nextDayCells = [0] * len(cells)\n    day = 0\n\n    while n > 0:\n      n -= 1\n      for i in range(1, len(cells) - 1):\n        nextDayCells[i] = 1 if cells[i - 1] == cells[i + 1] else 0\n      if day == 0:\n        firstDayCells = nextDayCells.copy()\n      elif nextDayCells == firstDayCells:\n        n %= day\n      cells = nextDayCells.copy()\n      day += 1\n\n    return cells",
      "title": "957. Prison Cells After N Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c8a1803-b0b6-418c-9783-8a43e4a409b3",
      "code": "class Solution:\n  def repeatedNTimes(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2):\n      if nums[i] == nums[i + 1] or nums[i] == nums[i + 2]:\n        return nums[i]\n    return nums[-1]",
      "title": "961. N-Repeated Element in Size 2N Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2367315b-a760-404c-887d-ee0deec43d14",
      "code": "class Solution:\n  def maxWidthRamp(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i, num in enumerate(nums):\n      if stack == [] or num <= nums[stack[-1]]:\n        stack.append(i)\n\n    for i, num in reversed(list(enumerate(nums))):\n      while stack and num >= nums[stack[-1]]:\n        ans = max(ans, i - stack.pop())\n\n    return ans",
      "title": "962. Maximum Width Ramp",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc0b09fe-05fd-4f23-9aad-650412494f6e",
      "code": "class Solution:\n  def minAreaFreeRect(self, points: list[list[int]]) -> float:\n    ans = math.inf\n    # For each A, B pair points, {hash(A, B): (ax, ay, bx, by)}.\n    centerToPoints = collections.defaultdict(list)\n\n    for ax, ay in points:\n      for bx, by in points:\n        center = ((ax + bx) / 2, (ay + by) / 2)\n        centerToPoints[center].append((ax, ay, bx, by))\n\n    def dist(px: int, py: int, qx: int, qy: int) -> float:\n      return (px - qx)**2 + (py - qy)**2\n\n    # For all pair points \"that share the same center\".\n    for points in centerToPoints.values():\n      for ax, ay, _, _ in points:\n        for cx, cy, dx, dy in points:\n          # AC is perpendicular to AD.\n          # AC dot AD = (cx - ax, cy - ay) dot (dx - ax, dy - ay) == 0.\n          if (cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0:\n            squaredArea = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy)\n            if squaredArea > 0:\n              ans = min(ans, squaredArea)\n\n    return 0 if ans == math.inf else math.sqrt(ans)",
      "title": "963. Minimum Area Rectangle II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc718045-658a-4169-8906-9707b0b2a419",
      "code": "class Solution:\n  def leastOpsExpressTarget(self, x: int, target: int) -> int:\n    @functools.lru_cache(None)\n    def dfs(target):\n      if x > target:\n        return min(2 * target - 1, 2 * (x - target))\n      if x == target:\n        return 0\n\n      prod = x\n      n = 0\n      while prod < target:\n        prod *= x\n        n += 1\n      if prod == target:\n        return n\n\n      ans = dfs(target - prod // x) + n\n      if prod < 2 * target:\n        ans = min(ans, dfs(prod - target) + n + 1)\n      return ans\n\n    return dfs(target)",
      "title": "964. Least Operators to Express Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88552ee1-e04e-403b-817e-1b795554f063",
      "code": "class Solution:\n  def isUnivalTree(self, root: TreeNode | None) -> bool:\n    if not root:\n      return True\n    if root.left and root.left.val != root.val:\n      return False\n    if root.right and root.right.val != root.val:\n      return False\n    return self.isUnivalTree(root.left) and self.isUnivalTree(root.right)",
      "title": "965. Univalued Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06cd506e-7165-43ac-860d-75418e4a6858",
      "code": "class Solution:\n  def spellchecker(self, wordlist: list[str], queries: list[str]) -> list[str]:\n    def lowerKey(word: str) -> str:\n      return '$' + ''.join([c.lower() for c in word])\n\n    def vowelKey(word: str) -> str:\n      return ''.join(['*' if c.lower() in 'aeiou' else c.lower() for c in word])\n\n    ans = []\n    dict = {}\n\n    for word in wordlist:\n      dict.setdefault(word, word)\n      dict.setdefault(lowerKey(word), word)\n      dict.setdefault(vowelKey(word), word)\n\n    for query in queries:\n      if query in dict:\n        ans.append(dict[query])\n      elif lowerKey(query) in dict:\n        ans.append(dict[lowerKey(query)])\n      elif vowelKey(query) in dict:\n        ans.append(dict[vowelKey(query)])\n      else:\n        ans.append('')\n\n    return ans",
      "title": "966. Vowel Spellchecker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfd17cb9-5c4e-4d3f-9949-52d52694f668",
      "code": "class Solution:\n  def pancakeSort(self, arr: list[int]) -> list[int]:\n    ans = []\n\n    for target in range(len(arr), 0, -1):\n      index = arr.index(target)\n      arr[:index + 1] = arr[:index + 1][::-1]\n      arr[:target] = arr[:target][::-1]\n      ans.append(index + 1)\n      ans.append(target)\n\n    return ans",
      "title": "969. Pancake Sorting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c03c186-641c-46d7-8ca0-e0557a5e44c9",
      "code": "class Solution:\n  def powerfulIntegers(self, x: int, y: int, bound: int) -> list[int]:\n    xs = {x**i for i in range(20) if x**i < bound}\n    ys = {y**i for i in range(20) if y**i < bound}\n    return list({i + j for i in xs for j in ys if i + j <= bound})",
      "title": "970. Powerful Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fbc9aa9-7e6f-4b3d-9ac8-29a7eab1a88e",
      "code": "class Solution:\n  def isRationalEqual(self, s: str, t: str) -> bool:\n    ratios = [1, 1 / 9, 1 / 99, 1 / 999, 1 / 9999]\n\n    def valueOf(s: str) -> float:\n      if s.find('(') == -1:\n        return float(s)\n\n      # Get the indices.\n      leftParenIndex = s.find('(')\n      rightParenIndex = s.find(')')\n      dotIndex = s.find('.')\n\n      # integerAndNonRepeating := <IntegerPart><.><NonRepeatingPart>\n      integerAndNonRepeating = float(s[:leftParenIndex])\n      nonRepeatingLength = leftParenIndex - dotIndex - 1\n\n      # repeating := <RepeatingPart>\n      repeating = int(s[leftParenIndex + 1:rightParenIndex])\n      repeatingLength = rightParenIndex - leftParenIndex - 1\n      return integerAndNonRepeating + repeating * 0.1**nonRepeatingLength * ratios[repeatingLength]\n\n    return abs(valueOf(s) - valueOf(t)) < 1e-9",
      "title": "972. Equal Rational Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "172109f7-09f3-42f3-8acf-39c2d898aad8",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      randIndex = random.randint(0, r - l + 1) + l\n      points[randIndex], points[r] = points[r], points[randIndex]\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]\n\n\nclass Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    def squareDist(p: list[int]) -> int:\n      return p[0] * p[0] + p[1] * p[1]\n\n    def quickSelect(l: int, r: int, k: int) -> None:\n      pivot = points[r]\n\n      nextSwapped = l\n      for i in range(l, r):\n        if squareDist(points[i]) <= squareDist(pivot):\n          points[nextSwapped], points[i] = points[i], points[nextSwapped]\n          nextSwapped += 1\n      points[nextSwapped], points[r] = points[r], points[nextSwapped]\n\n      count = nextSwapped - l + 1  the number of points <= pivot\n      if count == k:\n        return\n      if count > k:\n        quickSelect(l, nextSwapped - 1, k)\n      else:\n        quickSelect(nextSwapped + 1, r, k - count)\n\n    quickSelect(0, len(points) - 1, k)\n    return points[0:k]",
      "title": "973. K Closest Points to Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9984cebe-eb07-4193-a7fb-0c84fc5b08af",
      "code": "class Solution:\n  def kClosest(self, points: list[list[int]], k: int) -> list[list[int]]:\n    maxHeap = []\n\n    for x, y in points:\n      heapq.heappush(maxHeap, (- x * x - y * y, [x, y]))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n\n    return [pair[1] for pair in maxHeap]",
      "title": "973. K Closest Points to Origin_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3591ceb9-d1b8-4547-80a5-4c2921472959",
      "code": "class Solution:\n  def subarraysDivByK(self, nums: list[int], k: int) -> int:\n    ans = 0\n    prefix = 0\n    count = [0] * k\n    count[0] = 1\n\n    for num in nums:\n      prefix = (prefix + num % k + k) % k\n      ans += count[prefix]\n      count[prefix] += 1\n\n    return ans",
      "title": "974. Subarray Sums Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1e13f50-36b1-4300-958e-6be6cea5a935",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    nums = sorted(nums)\n\n    for i in range(len(nums) - 1, 1, -1):\n      if nums[i - 2] + nums[i - 1] > nums[i]:\n        return nums[i - 2] + nums[i - 1] + nums[i]\n\n    return 0",
      "title": "976. Largest Perimeter Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b0018bc-e978-461f-9a61-cdea23005f31",
      "code": "class Solution:\n  def sortedSquares(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    l = 0\n    r = n - 1\n    ans = [0] * n\n\n    while n:\n      n -= 1\n      if abs(nums[l]) > abs(nums[r]):\n        ans[n] = nums[l] * nums[l]\n        l += 1\n      else:\n        ans[n] = nums[r] * nums[r]\n        r -= 1\n\n    return ans",
      "title": "977. Squares of a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7140570-a35c-41fc-bf2f-a43527236d64",
      "code": "class Solution:\n  def maxTurbulenceSize(self, arr: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(arr)):\n      if arr[i] > arr[i - 1]:\n        increasing = decreasing + 1\n        decreasing = 1\n      elif arr[i] < arr[i - 1]:\n        decreasing = increasing + 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, max(increasing, decreasing))\n\n    return ans",
      "title": "978. Longest Turbulent Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f2a42d7-3820-4744-aab3-bf8dc31d2c81",
      "code": "class Solution:\n  def countTriplets(self, nums: list[int]) -> int:\n    MAX = 1 << 16\n    ans = 0\n    count = [0] * MAX  # {nums[i] & nums[j]: times}\n\n    for a in nums:\n      for b in nums:\n        count[a & b] += 1\n\n    for num in nums:\n      for i in range(MAX):\n        if (num & i) == 0:\n          ans += count[i]\n\n    return ans",
      "title": "982. Triples with Bitwise AND Equal To Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f68f1ae1-b190-4a20-a71e-43904d00a6af",
      "code": "class Solution:\n  def mincostTickets(self, days: list[int], costs: list[int]) -> int:\n    ans = 0\n    last7 = collections.deque()\n    last30 = collections.deque()\n\n    for day in days:\n      while last7 and last7[0][0] + 7 <= day:\n        last7.popleft()\n      while last30 and last30[0][0] + 30 <= day:\n        last30.popleft()\n      last7.append([day, ans + costs[1]])\n      last30.append([day, ans + costs[2]])\n      ans = min(ans + costs[0], last7[0][1], last30[0][1])\n\n    return ans",
      "title": "983. Minimum Cost For Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a5e4d2c-995b-42e4-a3e6-156041ffcf94",
      "code": "class Solution:\n  def sumEvenAfterQueries(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    summ = sum(a for a in nums if a % 2 == 0)\n\n    for val, index in queries:\n      if nums[index] % 2 == 0:\n        summ -= nums[index]\n      nums[index] += val\n      if nums[index] % 2 == 0:\n        summ += nums[index]\n      ans.append(summ)\n\n    return ans",
      "title": "985. Sum of Even Numbers After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66170995-3e91-49cd-86af-a5bc12fff279",
      "code": "class Solution:\n  def intervalIntersection(self, firstList: list[list[int]],\n                           secondList: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0\n    j = 0\n\n    while i < len(firstList) and j < len(secondList):\n      # lo := the start of the intersection\n      # hi := the end of the intersection\n      lo = max(firstlist[i][0], secondlist[j][0])\n      hi = min(firstlist[i][1], secondlist[j][1])\n      if lo <= hi:\n        ans.append([lo, hi])\n      if firstlist[i][1] < secondlist[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return ans",
      "title": "986. Interval List Intersections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3bf893b-01ee-43a3-9627-dc1a4b0e7d7b",
      "code": "class Solution:\n  def verticalTraversal(self, root: TreeNode | None) -> list[list[int]]:\n    ans = []\n    xToNodes = collections.defaultdict(list)\n\n    def dfs(node: TreeNode | None, x: int, y: int) -> None:\n      if not node:\n        return\n      xToNodes[x].append((-y, node.val))\n      dfs(node.left, x - 1, y - 1)\n      dfs(node.right, x + 1, y - 1)\n\n    dfs(root, 0, 0)\n\n    for _, nodes in sorted(xToNodes.items(), key=lambda x: x[0]):\n      ans.append([val for _, val in sorted(nodes)])\n\n    return ans",
      "title": "987. Vertical Order Traversal of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7016e73-02ec-402e-9062-9aec968174a6",
      "code": "class Solution:\n  def addToArrayForm(self, num: list[int], k: int) -> list[int]:\n    for i in reversed(range(len(num))):\n      k, num[i] = divmod(num[i] + k, 10)\n\n    while k > 0:\n      num = [k % 10] + num\n      k //= 10\n\n    return num",
      "title": "989. Add to Array-Form of Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4945042-6e62-4ea4-bae9-909c29101951",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n\n  def union(self, u: int, v: int) -> None:\n    self.id[self.find(u)] = self.find(v)\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def equationsPossible(self, equations: list[str]) -> bool:\n    uf = UnionFind(26)\n\n    for x, op, _, y in equations:\n      if op == '=':\n        uf.union(ord(x) - ord('a'),\n                 ord(y) - ord('a'))\n\n    return all(\n        uf.find(ord(x) - ord('a')) !=\n        uf.find(ord(y) - ord('a'))\n        for x, op, _, y in equations\n        if op == '!')",
      "title": "990. Satisfiability of Equality Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffa05c66-eba1-4b8d-a09e-7d0a64f406bb",
      "code": "class Solution:\n  def brokenCalc(self, startValue: int, target: int) -> int:\n    ops = 0\n\n    while startValue < target:\n      if target % 2 == 0:\n        target //= 2\n      else:\n        target += 1\n      ops += 1\n\n    return ops + startValue - target",
      "title": "991. Broken Calculator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c5cfddf-b12c-4d9f-9ca7-267019dde4c3",
      "code": "class Solution:\n  def subarraysWithKDistinct(self, nums: list[int], k: int) -> int:\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    return subarraysWithAtMostKDistinct(k) - subarraysWithAtMostKDistinct(k - 1)",
      "title": "992. Subarrays with K Different Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b4476f4-05f7-4e78-862a-c580a7a9dc73",
      "code": "class Solution:\n  def minKBitFlips(self, nums: list[int], k: int) -> int:\n    ans = 0\n    flippedTime = 0\n\n    for i, num in enumerate(nums):\n      if i >= k and nums[i - k] == 2:\n        flippedTime -= 1\n      if flippedTime % 2 == num:\n        if i + k > len(nums):\n          return -1\n        ans += 1\n        flippedTime += 1\n        nums[i] = 2\n\n    return ans",
      "title": "995. Minimum Number of K Consecutive Bit Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eda7c1ec-9bd2-45f6-b39b-97b3e82a9277",
      "code": "class Solution:\n  def numSquarefulPerms(self, nums: list[int]) -> int:\n    ans = 0\n    used = [False] * len(nums)\n\n    def isSquare(num: int) -> bool:\n      root = math.isqrt(num)\n      return root * root == num\n\n    def dfs(path: list[int]) -> None:\n      nonlocal ans\n      if len(path) > 1 and not isSquare(path[-1] + path[-2]):\n        return\n      if len(path) == len(nums):\n        ans += 1\n        return\n\n      for i, a in enumerate(nums):\n        if used[i]:\n          continue\n        if i > 0 and nums[i] == nums[i - 1] and not used[i - 1]:\n          continue\n        used[i] = True\n        dfs(path + [a])\n        used[i] = False\n\n    nums.sort()\n    dfs([])\n    return ans",
      "title": "996. Number of Squareful Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d800589-677a-493f-a3aa-faa8729c8e85",
      "code": "class Solution:\n  def findJudge(self, n: int, trust: list[list[int]]) -> int:\n    count = [0] * (n + 1)\n\n    for a, b in trust:\n      count[a] -= 1\n      count[b] += 1\n\n    for i in range(1, n + 1):\n      if count[i] == n - 1:\n        return i\n\n    return -1",
      "title": "997. Find the Town Judge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c437c404-baf1-4a72-bb9d-7bd4e1bad8c0",
      "code": "class Solution:\n  def insertIntoMaxTree(\n      self,\n      root: TreeNode | None,\n      val: int,\n  ) -> TreeNode | None:\n    if root.val < val:\n      return TreeNode(val, root, None)\n    curr = root\n    while curr.right and curr.right.val > val:\n      curr = curr.right\n    inserted = TreeNode(val, curr.right, None)\n    curr.right = inserted\n    return root",
      "title": "998. Maximum Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2833d3c2-878c-4216-b184-d80d964d43c8",
      "code": "class Solution:\n  def numRookCaptures(self, board: list[list[str]]) -> int:\n    ans = 0\n\n    for i in range(8):\n      for j in range(8):\n        if board[i][j] == 'R':\n          i0 = i\n          j0 = j\n\n    for d in [[1, 0], [0, 1], [-1, 0], [0, -1]]:\n      i = i0 + d[0]\n      j = j0 + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if board[i][j] == 'p':\n          ans += 1\n        if board[i][j] != '.':\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "999. Available Captures for Rook",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a6a061e-7268-4f15-958c-b50f7fbd8e25",
      "code": "class Solution:\n  def gridIllumination(\n      self,\n      n: int,\n      lamps: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    rows = collections.Counter()\n    cols = collections.Counter()\n    diag1 = collections.Counter()\n    diag2 = collections.Counter()\n    lampsSet = set()\n\n    for i, j in lamps:\n      if (i, j) not in lampsSet:\n        lampsSet.add((i, j))\n        rows[i] += 1\n        cols[j] += 1\n        diag1[i + j] += 1\n        diag2[i - j] += 1\n\n    for i, j in queries:\n      if rows[i] or cols[j] or diag1[i + j] or diag2[i - j]:\n        ans.append(1)\n        for y in range(max(0, i - 1), min(n, i + 2)):\n          for x in range(max(0, j - 1), min(n, j + 2)):\n            if (y, x) in lampsSet:\n              lampsSet.remove((y, x))\n              rows[y] -= 1\n              cols[x] -= 1\n              diag1[y + x] -= 1\n              diag2[y - x] -= 1\n      else:\n        ans.append(0)\n\n    return ans",
      "title": "1001. Grid Illumination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfc71554-399e-4d95-a86b-0bf87fb34907",
      "code": "class Solution:\n  def commonChars(self, words: list[str]) -> list[str]:\n    return functools.reduce(lambda a, b: a & b,\n                            map(collections.Counter, words)).elements()",
      "title": "1002. Find Common Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e444c94e-7fb3-4f26-8c9f-8545ddfcca55",
      "code": "class Solution:\n  def isValid(self, s: str) -> bool:\n    stack = []\n\n    for c in s:\n      if c == 'c':\n        if len(stack) < 2 or stack[-2] != 'a' or stack[-1] != 'b':\n          return False\n        stack.pop()\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return not stack",
      "title": "1003. Check If Word Is Valid After Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86f15d80-b57d-40cf-90cd-1fb79b02b3f6",
      "code": "class Solution:\n  def longestOnes(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        k -= 1\n      while k < 0:\n        if nums[l] == 0:\n          k += 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1004. Max Consecutive Ones III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "481d5bca-7510-4c8d-97b8-d59e566a469e",
      "code": "class Solution:\n  def largestSumAfterKNegations(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    for i, num in enumerate(nums):\n      if num > 0 or k == 0:\n        break\n      nums[i] = -num\n      k -= 1\n\n    return sum(nums) - (k % 2) * min(nums) * 2",
      "title": "1005. Maximize Sum Of Array After K Negations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a92fb272-3b81-4a7b-a6f3-f6f32655f564",
      "code": "class Solution:\n  def clumsy(self, n: int) -> int:\n    if n == 1:\n      return 1\n    if n == 2:\n      return 2\n    if n == 3:\n      return 6\n    if n == 4:\n      return 7\n    if n % 4 == 1:\n      return n + 2\n    if n % 4 == 2:\n      return n + 2\n    if n % 4 == 3:\n      return n - 1\n    return n + 1",
      "title": "1006. Clumsy Factorial",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89ce544b-c40f-4807-b04e-28818be65984",
      "code": "class Solution:\n  def minDominoRotations(self, tops: list[int], bottoms: list[int]) -> int:\n    for num in range(1, 7):\n      if all(num in pair for pair in zip(tops, bottoms)):\n        return len(tops) - max(tops.count(num), bottoms.count(num))\n    return -1",
      "title": "1007. Minimum Domino Rotations For Equal Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c93563dd-989a-4be1-9356-7bc554afec3b",
      "code": "class Solution:\n  def bstFromPreorder(self, preorder: list[int]) -> TreeNode | None:\n    root = TreeNode(preorder[0])\n    stack = [root]\n\n    for i in range(1, len(preorder)):\n      parent = stack[-1]\n      child = TreeNode(preorder[i])\n      # Adjust the parent.\n      while stack and stack[-1].val < child.val:\n        parent = stack.pop()\n      # Create parent-child link according to BST property.\n      if parent.val > child.val:\n        parent.left = child\n      else:\n        parent.right = child\n      stack.append(child)\n\n    return root",
      "title": "1008. Construct Binary Search Tree from Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a6c84cd-8ce7-44de-9d99-0ec7e4ff7205",
      "code": "class Solution:\n  def bitwiseComplement(self, n: int) -> int:\n    mask = 1\n    while mask < n:\n      mask = (mask << 1) + 1\n    return mask ^ n",
      "title": "1009. Complement of Base 10 Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f494d3f5-0e8e-4353-835e-69f1810ea7ad",
      "code": "class Solution:\n  def numPairsDivisibleBy60(self, time: list[int]) -> int:\n    ans = 0\n    count = [0] * 60\n\n    for t in time:\n      t %= 60\n      ans += count[(60 - t) % 60]\n      count[t] += 1\n\n    return ans",
      "title": "1010. Pairs of Songs With Total Durations Divisible by 60",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7734347-ffd1-45a9-ab6f-5ca991a7b9c6",
      "code": "class Solution:\n  def shipWithinDays(self, weights: list[int], days: int) -> int:\n    def shipDays(shipCapacity: int) -> int:\n      shipDays = 1\n      capacity = 0\n      for weight in weights:\n        if capacity + weight > shipCapacity:\n          shipDays += 1\n          capacity = weight\n        else:\n          capacity += weight\n      return shipDays\n\n    l = max(weights)\n    r = sum(weights)\n    return bisect.bisect_left(range(l, r), True,\n                              key=lambda m: shipDays(m) <= days) + l",
      "title": "1011. Capacity To Ship Packages Within D Days",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7150d457-153c-4099-800c-de20e857c739",
      "code": "class Solution:\n  def numDupDigitsAtMostN(self, n: int) -> int:\n    return n - self._countSpecialNumbers(n)\n\n  # Same as 2376. Count Special Integers\n  def _countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "1012. Numbers With Repeated Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a165f437-59d6-4dcf-96d0-1f93d4f8aaad",
      "code": "class Solution:\n  def canThreePartsEqualSum(self, arr: list[int]) -> bool:\n    summ = sum(arr)\n    if summ % 3 != 0:\n      return False\n\n    average = summ // 3\n    partCount = 0\n    partSum = 0\n\n    for a in arr:\n      partSum += a\n      if partSum == average:\n        partCount += 1\n        partSum = 0\n\n    # edge case: arr = [0, 0, 0, 0] . partCount = 4.\n    return partCount >= 3",
      "title": "1013. Partition Array Into Three Parts With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b9f824e-57f5-4599-8f30-19de08b9a08e",
      "code": "class Solution:\n  def maxScoreSightseeingPair(self, values: list[int]) -> int:\n    ans = 0\n    bestPrev = 0\n\n    for value in values:\n      ans = max(ans, value + bestPrev)\n      bestPrev = max(bestPrev, value) - 1\n\n    return ans",
      "title": "1014. Best Sightseeing Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db7139d2-932c-4dc7-94c5-b821735f2545",
      "code": "class Solution:\n  def smallestRepunitDivByK(self, k: int) -> int:\n    if k % 10 not in {1, 3, 7, 9}:\n      return -1\n\n    seen = set()\n    n = 0\n\n    for length in range(1, k + 1):\n      n = (n * 10 + 1) % k\n      if n == 0:\n        return length\n      if n in seen:\n        return -1\n      seen.add(n)\n\n    return -1",
      "title": "1015. Smallest Integer Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50507ed3-8961-49ed-85ea-3e89da5b3885",
      "code": "class Solution:\n  def queryString(self, s: str, n: int) -> bool:\n    if n > 1511:\n      return False\n\n    for i in range(n, n // 2, -1):\n      if format(i, 'b') not in s:\n        return False\n\n    return True",
      "title": "1016. Binary String With Substrings Representing 1 To N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86559d10-41f6-432f-87a7-28b5d8cffcc7",
      "code": "class Solution:\n  def baseNeg2(self, n: int) -> str:\n    ans = []\n\n    while n != 0:\n      ans.append(str(n % 2))\n      n = -(n >> 1)\n\n    return ''.join(reversed(ans)) if ans else '0'",
      "title": "1017. Convert to Base -2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5237a1e9-1985-491d-9257-7be82a15654d",
      "code": "class Solution:\n  def prefixesDivBy5(self, nums: list[int]) -> list[bool]:\n    ans = []\n    curr = 0\n\n    for num in nums:\n      curr = (curr * 2 + num) % 5\n      ans.append(curr % 5 == 0)\n\n    return ans",
      "title": "1018. Binary Prefix Divisible By 5",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4044f8d-5238-4da1-8896-641be44af8d9",
      "code": "class Solution:\n  def nextLargerNodes(self, head: ListNode) -> list[int]:\n    ans = []\n    stack = []\n\n    while head:\n      while stack and head.val > ans[stack[-1]]:\n        index = stack.pop()\n        ans[index] = head.val\n      stack.append(len(ans))\n      ans.append(head.val)\n      head = head.next\n\n    for i in stack:\n      ans[i] = 0\n\n    return ans",
      "title": "1019. Next Greater Node In Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcb75692-2b06-4b2b-9961-70bf5c69f17e",
      "code": "class Solution:\n  def removeOuterParentheses(self, s: str) -> str:\n    ans = []\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        if opened > 1:\n          ans.append(c)\n      else:  # c == ')'\n        opened -= 1\n        if opened > 0:\n          ans.append(c)\n\n    return ''.join(ans)",
      "title": "1021. Remove Outermost Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f664db22-3467-44b5-8976-a8fea43fbb2f",
      "code": "class Solution:\n  def sumRootToLeaf(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, val: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      val = val * 2 + root.val\n      if not root.left and not root.right:\n        ans += val\n      dfs(root.left, val)\n      dfs(root.right, val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1022. Sum of Root To Leaf Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36a2a9da-17f0-49a3-9e90-d64e3d31bc88",
      "code": "class Solution:\n  def camelMatch(self, queries: list[str], pattern: str) -> list[bool]:\n    def isMatch(query: str) -> bool:\n      j = 0\n      for c in query:\n        if j < len(pattern) and c == pattern[j]:\n          j += 1\n        elif c.isupper():\n          return False\n      return j == len(pattern)\n\n    return [isMatch(query) for query in queries]",
      "title": "1023. Camelcase Matching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b15f048f-9fa6-4c6f-b035-1b3bac5d3152",
      "code": "class Solution:\n  def videoStitching(self, clips: list[list[int]], time: int) -> int:\n    ans = 0\n    end = 0\n    farthest = 0\n\n    clips.sort()\n\n    i = 0\n    while farthest < time:\n      while i < len(clips) and clips[i][0] <= end:\n        farthest = max(farthest, clips[i][1])\n        i += 1\n      if end == farthest:\n        return -1\n      ans += 1\n      end = farthest\n\n    return ans",
      "title": "1024. Video Stitching",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f53a4c1-d2a5-4922-a14b-1d84578fc732",
      "code": "class Solution:\n  def divisorGame(self, n: int) -> bool:\n    return n % 2 == 0",
      "title": "1025. Divisor Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c2787a5-e3ea-475a-9489-b8bac9cf4c6b",
      "code": "class Solution:\n  def longestArithSeqLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    # dp[i][k] := the length of the longest arithmetic subsequence of nums[0..i]\n    # with k = diff + 500\n    dp = [[0] * 1001 for _ in range(n)]\n\n    for i in range(n):\n      for j in range(i):\n        k = nums[i] - nums[j] + 500\n        dp[i][k] = max(2, dp[j][k] + 1)\n        ans = max(ans, dp[i][k])\n\n    return ans",
      "title": "1027. Longest Arithmetic Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5b7d6c5-27fb-4164-9c36-07994147027f",
      "code": "class Solution:\n  def recoverFromPreorder(self, traversal: str) -> TreeNode | None:\n    i = 0\n\n    def recoverFromPreorder(depth: int) -> TreeNode | None:\n      nonlocal i\n      nDashes = 0\n      while i + nDashes < len(traversal) and traversal[i + nDashes] == '-':\n        nDashes += 1\n      if nDashes != depth:\n        return None\n\n      i += depth\n      start = i\n      while i < len(traversal) and traversal[i].isdigit():\n        i += 1\n\n      return TreeNode(int(traversal[start:i]),\n                      recoverFromPreorder(depth + 1),\n                      recoverFromPreorder(depth + 1))\n\n    return recoverFromPreorder(0)",
      "title": "1028. Recover a Tree From Preorder Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09f79885-8b23-4182-b809-a53f46478542",
      "code": "class Solution:\n  def twoCitySchedCost(self, costs: list[list[int]]) -> int:\n    n = len(costs) // 2\n\n    # How much money can we save if we fly a person to A instead of B?\n    # To save money, we should\n    #   1. Fly the person with the maximum saving to A.\n    #   2. Fly the person with the minimum saving to B.\n\n    # Sort `costs` in ascending order by the money saved if we fly a person to\n    # B instead of A.\n    costs.sort(key=lambda x: x[0] - x[1])\n    return sum(costs[i][0] + costs[i + n][1] for i in range(n))",
      "title": "1029. Two City Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "820bb361-a201-4b54-8759-0b775f7c19aa",
      "code": "class Solution:\n  def allCellsDistOrder(self, rows: int, cols: int, rCenter: int, cCenter: int) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = []\n    q = collections.deque([(rCenter, cCenter)])\n    seen = {(rCenter, cCenter)}\n\n    while q:\n      i, j = q.popleft()\n      ans.append([i, j])\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == rows or y < 0 or y == cols:\n          continue\n        if (x, y) in seen:\n          continue\n        seen.add((x, y))\n        q.append((x, y))\n\n    return ans",
      "title": "1030. Matrix Cells in Distance Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bb7b5e9-6600-4863-8d7c-2096b7d0bd0b",
      "code": "class Solution:\n  def maxSumTwoNoOverlap(\n      self,\n      nums: list[int],\n      firstLen: int,\n      secondLen: int,\n  ) -> int:\n    def helper(l: int, r: int) -> int:\n      n = len(nums)\n      left = [0] * n\n      summ = 0\n\n      for i in range(n):\n        summ += nums[i]\n        if i >= l:\n          summ -= nums[i - l]\n        if i >= l - 1:\n          left[i] = max(left[i - 1], summ) if i > 0 else summ\n\n      right = [0] * n\n      summ = 0\n\n      for i in reversed(range(n)):\n        summ += nums[i]\n        if i <= n - r - 1:\n          summ -= nums[i + r]\n        if i <= n - r:\n          right[i] = max(right[i + 1], summ) if i < n - 1 else summ\n\n      return max(left[i] + right[i + 1] for i in range(n - 1))\n\n    return max(helper(firstLen, secondLen), helper(secondLen, firstLen))",
      "title": "1031. Maximum Sum of Two Non-Overlapping Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a92cfa0-a543-4dcf-bf10-25c5f2e9e6fb",
      "code": "class Solution:\n  def numMovesStones(self, a: int, b: int, c: int) -> list[int]:\n    nums = sorted([a, b, c])\n\n    if nums[2] - nums[0] == 2:\n      return [0, 0]\n    return [1 if min(nums[1] - nums[0], nums[2] - nums[1]) <= 2 else 2,\n            nums[2] - nums[0] - 2]",
      "title": "1033. Moving Stones Until Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "296395bd-33df-401c-b115-faefc51e1fd4",
      "code": "class Solution:\n  def colorBorder(\n      self,\n      grid: list[list[int]],\n      r0: int,\n      c0: int,\n      color: int\n  ) -> list[list[int]]:\n    def dfs(i: int, j: int, startColor: int) -> None:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return\n      if grid[i][j] != startColor:\n        return\n\n      grid[i][j] = -startColor\n      dfs(i + 1, j, startColor)\n      dfs(i - 1, j, startColor)\n      dfs(i, j + 1, startColor)\n      dfs(i, j - 1, startColor)\n\n      # If this cell is already on the boarder, it must be painted later.\n      if i == 0 or i == len(grid) - 1 or j == 0 or j == len(grid[0]) - 1:\n        return\n\n      if (abs(grid[i + 1][j]) == startColor and\n          abs(grid[i - 1][j]) == startColor and\n          abs(grid[i][j + 1]) == startColor and\n              abs(grid[i][j - 1]) == startColor):\n        grid[i][j] = startColor\n\n    dfs(r0, c0, grid[r0][c0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num < 0:\n          grid[i][j] = color\n\n    return grid",
      "title": "1034. Coloring A Border",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dc62e4d-4f27-4e1b-9447-5662462874cf",
      "code": "class Solution:\n  def maxUncrossedLines(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        dp[i][j] = (dp[i - 1][j - 1] + 1\n                    if nums1[i - 1] == nums2[j - 1]\n                    else max(dp[i - 1][j], dp[i][j - 1]))\n\n    return dp[m][n]",
      "title": "1035. Uncrossed Lines",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4476f3fc-493a-4814-96c4-00d92545f6f8",
      "code": "class Solution:\n  def isEscapePossible(\n      self,\n      blocked: list[list[int]],\n      source: list[int],\n      target: list[int]\n  ) -> bool:\n    def dfs(i: int, j: int, target: list[int], seen: set) -> bool:\n      if i < 0 or i >= 10**6 or j < 0 or j >= 10**6:\n        return False\n      if (i, j) in blocked or (i, j) in seen:\n        return False\n      seen.add((i, j))\n      return (len(seen) > (1 + 199) * 199 // 2 or [i, j] == target or\n              dfs(i + 1, j, target, seen) or\n              dfs(i - 1, j, target, seen) or\n              dfs(i, j + 1, target, seen) or\n              dfs(i, j - 1, target, seen))\n\n    blocked = set(tuple(b) for b in blocked)\n    return (dfs(source[0], source[1], target, set()) and\n            dfs(target[0], target[1], source, set()))",
      "title": "1036. Escape a Large Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82a329ba-2d01-4a4e-962e-e591ec13341e",
      "code": "class Solution:\n  def isBoomerang(self, points: list[list[int]]) -> bool:\n    return ((points[1][0] - points[0][0]) * (points[2][1] - points[1][1]) !=\n            (points[1][1] - points[0][1]) * (points[2][0] - points[1][0]))",
      "title": "1037. Valid Boomerang",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "885fa182-9b92-48af-91ac-2850006f5d37",
      "code": "class Solution:\n  def minScoreTriangulation(self, values: list[int]) -> int:\n    n = len(values)\n    dp = [[0] * n for _ in range(n)]\n\n    for j in range(2, n):\n      for i in range(j - 2, -1, -1):\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + values[i]\n                         * values[k] * values[j] + dp[k][j])\n\n    return dp[0][n - 1]",
      "title": "1039. Minimum Score Triangulation of Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35feef96-8d27-4f8b-9d26-b1d306fb6de9",
      "code": "class Solution:\n  def numMovesStonesII(self, stones: list[int]) -> list[int]:\n    n = len(stones)\n    minMoves = n\n\n    stones.sort()\n\n    l = 0\n    for r, stone in enumerate(stones):\n      while stone - stones[l] + 1 > n:\n        l += 1\n      alreadyStored = r - l + 1\n      if alreadyStored == n - 1 and stone - stones[l] + 1 == n - 1:\n        minMoves = 2\n      else:\n        minMoves = min(minMoves, n - alreadyStored)\n\n    return [minMoves, max(stones[n - 1] - stones[1] - n + 2, stones[n - 2] - stones[0] - n + 2)]",
      "title": "1040. Moving Stones Until Consecutive II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31805707-4b49-459a-a068-cd32852cc31c",
      "code": "class Solution:\n  def isRobotBounded(self, instructions: str) -> bool:\n    x = 0\n    y = 0\n    d = 0\n    directions = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n\n    for instruction in instructions:\n      if instruction == 'G':\n        x += directions[d][0]\n        y += directions[d][1]\n      elif instruction == 'L':\n        d = (d + 3) % 4\n      else:\n        d = (d + 1) % 4\n\n    return (x, y) == (0, 0) or d > 0",
      "title": "1041. Robot Bounded In Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7131232-a153-4352-b432-945763d6cab2",
      "code": "class Solution:\n  def gardenNoAdj(self, n: int, paths: list[list[int]]) -> list[int]:\n    ans = [0] * n  # ans[i] := 1, 2, 3, or 4\n    graph = [[] for _ in range(n)]\n\n    for x, y in paths:\n      u = x - 1\n      v = y - 1\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u in range(n):\n      used = functools.reduce(operator.or_, (1 << ans[v] for v in graph[u]), 0)\n      ans[u] = next(type_\n                    for type_ in range(1, 5)\n                    if not (used >> type_ & 1))\n\n    return ans",
      "title": "1042. Flower Planting With No Adjacent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25265f33-3ec4-49b8-9e0d-be339b8b79ef",
      "code": "class Solution:\n  def maxSumAfterPartitioning(self, arr: list[int], k: int) -> int:\n    n = len(arr)\n    dp = [0] * (n + 1)\n\n    for i in range(1, n + 1):\n      mx = -math.inf\n      for j in range(1, min(i, k) + 1):\n        mx = max(mx, arr[i - j])\n        dp[i] = max(dp[i], dp[i - j] + mx * j)\n\n    return dp[n]",
      "title": "1043. Partition Array for Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f13efbb-725e-44b1-96bc-63ad13654095",
      "code": "class Solution:\n  def longestDupSubstring(self, s: str) -> str:\n    BASE = 26\n    HASH = 1_000_000_007\n    bestStart = -1\n    l = 1\n    r = len(s)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    # k := the length of the substring to be hashed\n    def getStart(k: int) -> int | None:\n      maxPow = pow(BASE, k - 1, HASH)\n      hashToStart = collections.defaultdict(list)\n      h = 0\n\n      # Compute the hash value of s[:k].\n      for i in range(k):\n        h = (h * BASE + val(s[i])) % HASH\n      hashToStart[h].append(0)\n\n      # Compute the rolling hash by Rabin Karp.\n      for i in range(k, len(s)):\n        startIndex = i - k + 1\n        h = (h - maxPow * val(s[i - k])) % HASH\n        h = (h * BASE + val(s[i])) % HASH\n        if h in hashToStart:\n          currSub = s[startIndex:startIndex + k]\n          for start in hashToStart[h]:\n            if s[start:start + k] == currSub:\n              return startIndex\n        hashToStart[h].append(startIndex)\n\n    while l < r:\n      m = (l + r) // 2\n      start: int | None = getStart(m)\n      if start:\n        bestStart = start\n        l = m + 1\n      else:\n        r = m\n\n    if bestStart == -1:\n      return ''\n    if getStart(l):\n      return s[bestStart:bestStart + l]\n    return s[bestStart:bestStart + l - 1]",
      "title": "1044. Longest Duplicate Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f50f740-4225-4f32-82c2-108f70ad8fa1",
      "code": "class Solution:\n  def lastStoneWeight(self, stones: list[int]) -> int:\n    pq = [-stone for stone in stones]\n    heapq.heapify(pq)\n\n    while len(pq) >= 2:\n      n1 = -heapq.heappop(pq)\n      n2 = -heapq.heappop(pq)\n      if n1 != n2:\n        heapq.heappush(pq, -(n1 - n2))\n\n    return 0 if not pq else -pq[0]",
      "title": "1046. Last Stone Weight",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f1753c5-9e95-4c81-8fdc-b28f3c31fbbe",
      "code": "class Solution:\n  def longestStrChain(self, words: list[str]) -> int:\n    wordsSet = set(words)\n\n    @functools.lru_cache(None)\n    def dp(s: str) -> int:\n      \"\"\"Returns the longest chain where s is the last word.\"\"\"\n      ans = 1\n      for i in range(len(s)):\n        pred = s[:i] + s[i + 1:]\n        if pred in wordsSet:\n          ans = max(ans, dp(pred) + 1)\n      return ans\n\n    return max(dp(word) for word in words)",
      "title": "1048. Longest String Chain",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8054252-2150-4dcb-aa0b-d28b208d49f8",
      "code": "class Solution:\n  def lastStoneWeightII(self, stones: list[int]) -> int:\n    summ = sum(stones)\n    s = 0\n    dp = [True] + [False] * summ\n\n    for stone in stones:\n      for w in range(summ // 2 + 1)[::-1]:\n        if w >= stone:\n          dp[w] = dp[w] or dp[w - stone]\n        if dp[w]:\n          s = max(s, w)\n\n    return summ - 2 * s",
      "title": "1049. Last Stone Weight II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf11f63f-4f54-4ccc-a8a7-050e3f73dbfe",
      "code": "class Solution:\n  def heightChecker(self, heights: list[int]) -> int:\n    ans = 0\n    currentHeight = 1\n    count = [0] * 101\n\n    for height in heights:\n      count[height] += 1\n\n    for height in heights:\n      while count[currentHeight] == 0:\n        currentHeight += 1\n      if height != currentHeight:\n        ans += 1\n      count[currentHeight] -= 1\n\n    return ans",
      "title": "1051. Height Checker",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85f407bf-6e8e-40f6-b901-7af1ed271fef",
      "code": "class Solution:\n  def maxSatisfied(\n      self,\n      customers: list[int],\n      grumpy: list[int],\n      X: int,\n  ) -> int:\n    satisfied = sum(c for i, c in enumerate(customers) if grumpy[i] == 0)\n    madeSatisfied = 0\n    windowSatisfied = 0\n\n    for i, customer in enumerate(customers):\n      if grumpy[i] == 1:\n        windowSatisfied += customer\n      if i >= X and grumpy[i - X] == 1:\n        windowSatisfied -= customers[i - X]\n      madeSatisfied = max(madeSatisfied, windowSatisfied)\n\n    return satisfied + madeSatisfied",
      "title": "1052. Grumpy Bookstore Owner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79e88b4b-d759-4da8-a1d2-5a7849c6e1fa",
      "code": "class Solution:\n  def prevPermOpt1(self, arr: list[int]) -> list[int]:\n    n = len(arr)\n    l = n - 2\n    r = n - 1\n\n    while l >= 0 and arr[l] <= arr[l + 1]:\n      l -= 1\n    if l < 0:\n      return arr\n    while arr[r] >= arr[l] or arr[r] == arr[r - 1]:\n      r -= 1\n    arr[l], arr[r] = arr[r], arr[l]\n\n    return arr",
      "title": "1053. Previous Permutation With One Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18dd5560-7e18-4657-88d9-550e5a6944b4",
      "code": "class Solution:\n  def rearrangeBarcodes(self, barcodes: list[int]) -> list[int]:\n    ans = [0] * len(barcodes)\n    count = collections.Counter(barcodes)\n    i = 0  # ans' index\n    maxNum = max(count, key=count.get)\n\n    def fillAns(num: int) -> None:\n      nonlocal i\n      while count[num]:\n        ans[i] = num\n        i = i + 2 if i + 2 < len(barcodes) else 1\n        count[num] -= 1\n\n    fillAns(maxNum)\n    for num in count.keys():\n      fillAns(num)\n\n    return ans",
      "title": "1054. Distant Barcodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4957b9d8-d216-4565-a314-8806a5acadca",
      "code": "class Solution:\n  def confusingNumber(self, n: int) -> bool:\n    s = str(n)\n    rotated = {'0': '0', '1': '1', '6': '9', '8': '8', '9': '6'}\n    rotatedNum = []\n\n    for c in s[::-1]:\n      if c not in rotated:\n        return False\n      rotatedNum.append(rotated[c])\n\n    return ''.join(rotatedNum) != s",
      "title": "1056. Confusing Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37aea247-30b4-4a41-81de-91e23fc3a662",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(workers)\n    usedBikes = [False] * len(bikes)\n    # buckets[k] := (i, j), where k = dist(workers[i], bikes[j])\n    buckets = [[] for _ in range(2001)]\n\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    for i, worker in enumerate(workers):\n      for j, bike in enumerate(bikes):\n        buckets[dist(worker, bike)].append((i, j))\n\n    for k in range(2001):\n      for i, j in buckets[k]:\n        if ans[i] == -1 and not usedBikes[j]:\n          ans[i] = j\n          usedBikes[j] = True\n\n    return ans",
      "title": "1057. Campus Bikes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f81b147-2634-4aeb-889e-9fdba2b78be1",
      "code": "class Solution:\n  def minimizeError(self, prices: list[str], target: int) -> str:\n    # A[i] := (costCeil - costFloor, costCeil, costFloor)\n    # The lower the costCeil - costFloor is, the cheaper to ceil it.\n    A = []\n    sumFloored = 0\n    sumCeiled = 0\n\n    for price in map(float, prices):\n      floored = math.floor(price)\n      ceiled = math.ceil(price)\n      sumFloored += floored\n      sumCeiled += ceiled\n      costFloor = price - floored\n      costCeil = ceiled - price\n      A.append((costCeil - costFloor, costCeil, costFloor))\n\n    if not sumFloored <= target <= sumCeiled:\n      return '-1'\n\n    A.sort()\n    nCeiled = target - sumFloored\n    return '{:.3f}'.format(sum(a[1] for a in A[:nCeiled]) +\n                           sum(a[2] for a in A[nCeiled:]))",
      "title": "1058. Minimize Rounding Error to Meet Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d699e3f4-2147-4b03-858d-0e4f57557ed2",
      "code": "class Solution:\n  def longestRepeatingSubstring(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    # dp[i][j] := the number of repeating characters of s[0..i) and s[0..j)\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      for j in range(i + 1, n + 1):\n        if s[i - 1] == s[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n          ans = max(ans, dp[i][j])\n\n    return ans",
      "title": "1062. Longest Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "648ba5ce-b91f-4879-9f21-1ce46efe5bb8",
      "code": "class Solution:\n  def validSubarrays(self, nums: list[int]) -> int:\n    # For each `num` in `nums`, each element x in the stack can be the leftmost\n    # element s.t. [x, num] forms a valid subarray, so the size of the stack is\n    # the number of valid subarrays ending in the current number.\n    #\n    # e.g. nums = [1, 3, 2]\n    # num = 1, stack = [1] -> valid subarray is [1]\n    # num = 3, stack = [1, 3] -> valid subarrays are [1, 3], [3]\n    # num = 2, stack = [1, 2] -> valid subarrays are [1, 3, 2], [2]\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      stack.append(num)\n      ans += len(stack)\n\n    return ans",
      "title": "1063. Number of Valid Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a82945a8-2d17-48da-98cd-fd8cbfa5f15b",
      "code": "class Solution:\n  def fixedPoint(self, arr: list[int]) -> int:\n    l = 0\n    r = len(arr) - 1\n\n    # Since arr[i] is strictly increasing, arr[i] - i will also be increasing.\n    # Therefore, binary search `arr` for the first arr[i] - i = 0.\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] - m >= 0:\n        r = m\n      else:\n        l = m + 1\n\n    return l if arr[l] == l else -1",
      "title": "1064. Fixed Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebdafa2b-e951-4c34-884f-eae372d4ce53",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Solution:\n  def indexPairs(self, text: str, words: list[str]) -> list[list[int]]:\n    ans = []\n    root = TrieNode()\n\n    for word in words:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.isWord = True\n\n    # Scan each text[i..j].\n    for i in range(len(text)):\n      node: TrieNode = root\n      for j in range(i, len(text)):\n        c = text[j]\n        if c not in node.children:\n          break\n        node = node.children[c]\n        if node.isWord:\n          ans.append([i, j])\n\n    return ans",
      "title": "1065. Index Pairs of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "491eb599-5ddd-4ba2-80b2-86aeb4345409",
      "code": "class Solution:\n  def assignBikes(\n      self,\n      workers: list[list[int]],\n      bikes: list[list[int]],\n  ) -> int:\n    def dist(p1: list[int], p2: list[int]) -> int:\n      return abs(p1[0] - p2[0]) + abs(p1[1] - p2[1])\n\n    @functools.lru_cache(None)\n    def dp(workerIndex: int, used: int) -> int:\n      \"\"\"\n      Returns the minimum Manhattan distances to assign bikes to\n      workers[workerIndex..n), where `used` is the bitmask of the used bikes.\n      \"\"\"\n      if workerIndex == len(workers):\n        return 0\n      return min(\n          (dist(workers[workerIndex],\n                bike) + dp(workerIndex + 1, used | 1 << i) for i,\n           bike in enumerate(bikes) if not used >> i & 1),\n          default=math.inf)\n\n    return dp(0, 0)",
      "title": "1066. Campus Bikes II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33987633-96b9-4903-a7de-47d6b7fdaeca",
      "code": "class Solution:\n  def gcdOfStrings(self, str1: str, str2: str) -> str:\n    for sz in range(min(len(str1), len(str2)), 0, -1):\n      if self._isDivisible(str1, str2, sz):\n        return str1[:sz]\n    return ''\n\n  def _isDivisible(self, str1: str, str2: str, sz: int) -> bool:\n    \"\"\"Returns True if str1 and str2 are divisible by str1[0..sz).\"\"\"\n    if len(str1) % sz > 0 or len(str2) % sz > 0:\n      return False\n    gcd = str1[:sz]\n    return str1.replace(gcd, '') == '' and str2.replace(gcd, '') == ''",
      "title": "1071. Greatest Common Divisor of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93cccd30-4c16-4b4d-816f-bf7eba502df6",
      "code": "class Solution:\n  def maxEqualRowsAfterFlips(self, matrix: list[list[int]]) -> int:\n    patterns = [tuple(a ^ row[0] for a in row) for row in matrix]\n    return max(Counter(patterns).values())",
      "title": "1072. Flip Columns For Maximum Number of Equal Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a445caec-b727-4185-8f08-4dd78fbe046b",
      "code": "class Solution:\n  def addNegabinary(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    carry = 0\n\n    while carry != 0 or arr1 or arr2:\n      if arr1:\n        carry += arr1.pop()\n      if arr2:\n        carry += arr2.pop()\n      ans.append(carry & 1)\n      carry = -(carry >> 1)\n\n    while len(ans) > 1 and ans[-1] == 0:\n      ans.pop()\n\n    return ans[::-1]",
      "title": "1073. Adding Two Negabinary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "364ac803-04ad-44fc-b957-db13d010da40",
      "code": "class Solution:\n  def numSubmatrixSumTarget(self, matrix: list[list[int]], target: int) -> int:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = 0\n\n    # Transfer each row in the matrix to the prefix sum.\n    for row in matrix:\n      for i in range(1, n):\n        row[i] += row[i - 1]\n\n    for baseCol in range(n):\n      for j in range(baseCol, n):\n        prefixCount = collections.Counter({0: 1})\n        summ = 0\n        for i in range(m):\n          if baseCol > 0:\n            summ -= matrix[i][baseCol - 1]\n          summ += matrix[i][j]\n          ans += prefixCount[summ - target]\n          prefixCount[summ] += 1\n\n    return ans",
      "title": "1074. Number of Submatrices That Sum to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4689ab7-c053-456f-ad10-f6e4d57a20ae",
      "code": "class Solution:\n  def findOcurrences(self, text: str, first: str, second: str) -> list[str]:\n    words = text.split()\n    return [c for a, b, c in zip(words, words[1:], words[2:]) if a == first and b == second]",
      "title": "1078. Occurrences After Bigram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f66c8637-277d-498f-bd12-7c85ea034bbd",
      "code": "class Solution:\n  def numTilePossibilities(self, tiles: str) -> int:\n    count = collections.Counter(tiles)\n\n    def dfs(count: dict[int, int]) -> int:\n      possibleSequences = 0\n\n      for k, v in count.items():\n        if v == 0:\n          continue\n        # Put c in the current position. We only care about the number of possible\n        # sequences of letters but don't care about the actual combination.\n        count[k] -= 1\n        possibleSequences += 1 + dfs(count)\n        count[k] += 1\n\n      return possibleSequences\n\n    return dfs(count)",
      "title": "1079. Letter Tile Possibilities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1bd58891-771f-427b-bf3a-eb518add585b",
      "code": "class Solution:\n  def sufficientSubset(\n      self,\n      root: TreeNode | None,\n      limit: int\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    if not root.left and not root.right:\n      return None if root.val < limit else root\n    root.left = self.sufficientSubset(root.left, limit - root.val)\n    root.right = self.sufficientSubset(root.right, limit - root.val)\n    return None if not root.left and not root.right else root",
      "title": "1080. Insufficient Nodes in Root to Leaf Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e6e1096-5537-40fb-85f5-3b545e09cbd1",
      "code": "class Solution:\n  def smallestSubsequence(self, text: str) -> str:\n    ans = []\n    count = collections.Counter(text)\n    used = [False] * 26\n\n    for c in text:\n      count[c] -= 1\n      if used[ord(c) - ord('a')]:\n        continue\n      while ans and ans[-1] > c and count[ans[-1]] > 0:\n        used[ord(ans[-1]) - ord('a')] = False\n        ans.pop()\n      ans.append(c)\n      used[ord(ans[-1]) - ord('a')] = True\n\n    return ''.join(ans)",
      "title": "1081. Smallest Subsequence of Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39ebff11-ca64-43bd-8fbb-e6b7ef3f3711",
      "code": "class Solution:\n  def sumOfDigits(self, nums: list[int]) -> int:\n    return sum(int(d) for d in str(min(nums))) & 1 ^ 1",
      "title": "1085. Sum of Digits in the Minimum Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cba604b1-0022-4332-b83b-f101b4a893ee",
      "code": "class Solution:\n  def highFive(self, items: list[list[int]]) -> list[list[int]]:\n    idToScores = collections.defaultdict(list)\n\n    for id, score in items:\n      heapq.heappush(idToScores[id], score)\n      if len(idToScores[id]) > 5:\n        heapq.heappop(idToScores[id])\n\n    return [[id, sum(scores) // 5] for id, scores in sorted(idToScores.items())]",
      "title": "1086. High Five",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4fd280ce-0e34-407b-94d7-e7a98fbb1aaf",
      "code": "class Solution:\n  def expand(self, s: str) -> list[str]:\n    ans = []\n\n    def dfs(i: int, path: list[str]) -> None:\n      if i == len(s):\n        ans.append(''.join(path))\n        return\n      if s[i] == '{':\n        nextRightBraceIndex = s.find('}', i)\n        for c in s[i + 1:nextRightBraceIndex].split(','):\n          path.append(c)\n          dfs(nextRightBraceIndex + 1, path)\n          path.pop()\n      else:  # s[i] != '{'\n        path.append(s[i])\n        dfs(i + 1, path)\n        path.pop()\n\n    dfs(0, [])\n    return sorted(ans)",
      "title": "1087. Brace Expansion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "817c5648-48b9-482e-a86d-bd4508fb0423",
      "code": "class Solution:\n  def confusingNumberII(self, n: int) -> int:\n    digitToRotated = [(0, 0), (1, 1), (6, 9), (8, 8), (9, 6)]\n\n    def dfs(num: int, rotatedNum: int, unit: int) -> int:\n      ans = 0 if num == rotatedNum else 1\n      # Add one more digit\n      for digit, rotated in digitToRotated:\n        if digit == 0 and num == 0:\n          continue\n        nextNum = num * 10 + digit\n        if nextNum > n:\n          break\n        ans += dfs(nextNum, rotated * unit + rotatedNum, unit * 10)\n      return ans\n\n    return dfs(0, 0, 1)",
      "title": "1088. Confusing Number II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "367035af-7959-4f9a-8ef1-3e46d505b8a9",
      "code": "class Solution:\n  def duplicateZeros(self, arr: list[int]) -> None:\n    zeros = arr.count(0)\n    i = len(arr) - 1\n    j = len(arr) + zeros - 1\n\n    while i < j:\n      if j < len(arr):\n        arr[j] = arr[i]\n      if arr[i] == 0:\n        j -= 1\n        if j < len(arr):\n          arr[j] = arr[i]\n      i -= 1\n      j -= 1",
      "title": "1089. Duplicate Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4850d98d-0789-4756-acf6-7a18b456f096",
      "code": "class Solution:\n  def sampleStats(self, count: list[int]) -> list[float]:\n    minimum = next((i for i, num in enumerate(count) if num), None)\n    maximum = next((i for i, num in reversed(\n        list(enumerate(count))) if num), None)\n    n = sum(count)\n    mean = sum(i * c / n for i, c in enumerate(count))\n    mode = count.index(max(count))\n\n    numCount = 0\n    leftMedian = 0\n    for i, c in enumerate(count):\n      numCount += c\n      if numCount >= n / 2:\n        leftMedian = i\n        break\n\n    numCount = 0\n    rightMedian = 0\n    for i, c in reversed(list(enumerate(count))):\n      numCount += c\n      if numCount >= n / 2:\n        rightMedian = i\n        break\n\n    return [minimum, maximum, mean, (leftMedian + rightMedian) / 2, mode]",
      "title": "1093. Statistics from a Large Sample",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "229e0b73-caf9-4368-ae06-924ab9377752",
      "code": "# \"\"\"\n# This is MountainArray's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class MountainArray:\n#   def get(self, index: int) -> int:\n#   def length(self) -> int:\n\nclass Solution:\n  def findInMountainArray(\n      self,\n      target: int,\n      mountain_arr: 'MountainArray',\n  ) -> int:\n    n = mountain_arr.length()\n    peakIndex = self.peakIndexInMountainArray(mountain_arr, 0, n - 1)\n\n    leftIndex = self.searchLeft(mountain_arr, target, 0, peakIndex)\n    if mountain_arr.get(leftIndex) == target:\n      return leftIndex\n\n    rightIndex = self.searchRight(mountain_arr, target, peakIndex + 1, n - 1)\n    if mountain_arr.get(rightIndex) == target:\n      return rightIndex\n\n    return -1\n\n  # 852. Peak Index in a Mountain Array\n  def peakIndexInMountainArray(self, A: 'MountainArray', l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < A.get(m + 1):\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchLeft(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) < target:\n        l = m + 1\n      else:\n        r = m\n    return l\n\n  def searchRight(self, A: 'MountainArray', target: int, l: int, r: int) -> int:\n    while l < r:\n      m = (l + r) // 2\n      if A.get(m) > target:\n        l = m + 1\n      else:\n        r = m\n    return l",
      "title": "1095. Find in Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a07c4c58-879c-42f6-bdd8-c72bbb910787",
      "code": "class Solution:\n  def braceExpansionII(self, expression: str) -> list[str]:\n    def merge(groups: list[list[str]], group: list[str]) -> None:\n      if not groups[-1]:\n        groups[-1] = group\n        return\n\n      groups[-1] = [word1 + word2 for word1 in groups[-1]\n                    for word2 in group]\n\n    def dfs(s: int, e: int) -> list[str]:\n      groups = [[]]\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if c == '{':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == '}':\n          layer -= 1\n          if layer == 0:\n            group = dfs(left, i - 1)\n            merge(groups, group)\n        elif c == ',' and layer == 0:\n          groups.append([])\n        elif layer == 0:\n          merge(groups, [c])\n\n      return sorted(list({word for group in groups for word in group}))\n\n    return dfs(0, len(expression) - 1)",
      "title": "1096. Brace Expansion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5efaffe5-d642-432e-ba9c-e32222157280",
      "code": "class Solution:\n  def twoSumLessThanK(self, nums: list[int], k: int) -> int:\n    if len(nums) < 2:\n      return -1\n\n    ans = -1  # Note the constrathat nums[i] > 0.\n    l = 0\n    r = len(nums) - 1\n\n    nums.sort()\n\n    while l < r:\n      if nums[l] + nums[r] < k:\n        ans = max(ans, nums[l] + nums[r])\n        l += 1\n      else:\n        r -= 1\n\n    return ans",
      "title": "1099. Two Sum Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed45a61e-03a2-482c-b793-866aaf4662a6",
      "code": "class Solution:\n  def numKLenSubstrNoRepeats(self, s: str, k: int) -> int:\n    ans = 0\n    unique = 0\n    count = collections.Counter()\n\n    for i, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        unique += 1\n      if i >= k:\n        count[s[i - k]] -= 1\n        if count[s[i - k]] == 0:\n          unique -= 1\n        if unique == k:\n          ans += 1\n\n    return ans",
      "title": "1100. Find K-Length Substrings With No Repeated Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb05c611-a4ba-4db0-a70f-76766c8fa11a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def earliestAcq(self, logs: list[list[int]], n: int) -> int:\n    uf = UnionFind(n)\n\n    # Sort `logs` by timestamp.\n    logs.sort(key=lambda x: x[0])\n\n    for timestamp, x, y in logs:\n      uf.unionByRank(x, y)\n      if uf.getCount() == 1:\n        return timestamp\n\n    return -1",
      "title": "1101. The Earliest Moment When Everyone Become Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2c8fdc0-7bdb-40dc-af82-4d621bcb3c4f",
      "code": "class Solution:\n  def distributeCandies(self, candies: int, n: int) -> list[int]:\n    ans = [0] * n\n    rows = int((-n + (n**2 + 8 * n**2 * candies)**0.5) / (2 * n**2))\n    accumN = rows * (rows - 1) * n // 2\n\n    for i in range(n):\n      ans[i] = accumN + rows * (i + 1)\n\n    givenCandies = (n**2 * rows**2 + n * rows) // 2\n    candies -= givenCandies\n    lastGiven = rows * n\n    i = 0\n\n    while candies > 0:\n      lastGiven += 1\n      actualGiven = min(lastGiven, candies)\n      candies -= actualGiven\n      ans[i] += actualGiven\n      i += 1\n\n    return ans",
      "title": "1103. Distribute Candies to People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2e195a8-c702-4ba1-80c6-06e474a76cfb",
      "code": "class Solution:\n  def pathInZigZagTree(self, label: int) -> list[int]:\n    def boundarySum(level: int):\n      return 2**level + 2**(level + 1) - 1\n\n    ans = []\n\n    for l in range(21):\n      if 2**l > label:\n        level = l - 1\n        break\n\n    if level % 2 == 1:\n      label = boundarySum(level) - label\n\n    for l in reversed(range(level + 1)):\n      ans.append(label if l % 2 == 0 else boundarySum(l) - label)\n      label //= 2\n\n    return ans[::-1]",
      "title": "1104. Path In Zigzag Labelled Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ef0555d-70b0-4c91-b499-29c9a92d4c1b",
      "code": "class Solution:\n  def minHeightShelves(self, books: list[list[int]], shelfWidth: int) -> int:\n    # dp[i] := the minimum height to place the first i books\n    dp = [0] + [math.inf] * len(books)\n\n    for i in range(len(books)):\n      sumThickness = 0\n      maxHeight = 0\n      # Place books[j..i] on a new shelf.\n      for j in range(i, -1, -1):\n        thickness, height = books[j]\n        sumThickness += thickness\n        if sumThickness > shelfWidth:\n          break\n        maxHeight = max(maxHeight, height)\n        dp[i + 1] = min(dp[i + 1], dp[j] + maxHeight)\n\n    return dp[-1]",
      "title": "1105. Filling Bookcase Shelves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52fc21de-1057-42cb-9baa-8dbe066890bb",
      "code": "class Solution:\n  def parseBoolExpr(self, expression: str) -> bool:\n    def dfs(s: int, e: int) -> list[str]:\n      if s == e:\n        return True if expression[s] == 't' else False\n\n      exps = []\n      layer = 0\n\n      for i in range(s, e + 1):\n        c = expression[i]\n        if layer == 0 and c in '!&|':\n          op = c\n        elif c == '(':\n          layer += 1\n          if layer == 1:\n            left = i + 1\n        elif c == ')':\n          layer -= 1\n          if layer == 0:\n            exps.append(dfs(left, i - 1))\n        elif c == ',' and layer == 1:\n          exps.append(dfs(left, i - 1))\n          left = i + 1\n\n      if op == '|':\n        return functools.reduce(operator.or_, exps)\n      if op == '&':\n        return functools.reduce(operator.and_, exps)\n      if op == '!':\n        return not exps[0]\n\n    return dfs(0, len(expression) - 1)",
      "title": "1106. Parsing A Boolean Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ef51f59-7d52-4992-9013-c42ebd8e2aab",
      "code": "class Solution:\n  def defangIPaddr(self, address: str) -> str:\n    return address.replace('.', '[.]')",
      "title": "1108. Defanging an IP Address",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "428d2e0a-ae33-4c67-beb7-40aed392846c",
      "code": "class Solution:\n  def corpFlightBookings(self, bookings: list[list[int]], n: int) -> list[int]:\n    ans = [0] * n\n\n    for booking in bookings:\n      ans[booking[0] - 1] += booking[2]\n      if booking[1] < n:\n        ans[booking[1]] -= booking[2]\n\n    for i in range(1, n):\n      ans[i] += ans[i - 1]\n\n    return ans",
      "title": "1109. Corporate Flight Bookings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb7b2998-c458-48a1-bc5b-3e7de0e68271",
      "code": "class Solution:\n  def delNodes(self, root: TreeNode, to_delete: list[int]) -> list[TreeNode]:\n    ans = []\n    toDeleteSet = set(to_delete)\n\n    def dfs(root: TreeNode, isRoot: bool) -> TreeNode:\n      if not root:\n        return None\n\n      deleted = root.val in toDeleteSet\n      if isRoot and not deleted:\n        ans.append(root)\n\n      # If root is deleted, both children have the possibility to be a new root\n      root.left = dfs(root.left, deleted)\n      root.right = dfs(root.right, deleted)\n      return None if deleted else root\n\n    dfs(root, True)\n    return ans",
      "title": "1110. Delete Nodes And Return Forest",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "012b067b-6530-4ff3-8e70-7a732219da4e",
      "code": "class Solution:\n  def maxDepthAfterSplit(self, seq: str) -> list[int]:\n    ans = []\n    depth = 1\n\n    # Put all odd-depth parentheses in one group and even-depth parentheses in the other group.\n    for c in seq:\n      if c == '(':\n        depth += 1\n        ans.append(depth % 2)\n      else:\n        ans.append(depth % 2)\n        depth -= 1\n\n    return ans",
      "title": "1111. Maximum Nesting Depth of Two Valid Parentheses Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f199d72-152b-4f05-891a-f6cb6145a9e7",
      "code": "class Solution:\n  def numberOfDays(self, year: int, month: int) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n    return 29 if month == 2 and isLeapYear(year) else days[month]",
      "title": "1118. Number of Days in a Month",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f401ca0-5872-4148-b8d5-37e81be02fe7",
      "code": "class Solution:\n  def removeVowels(self, s: str) -> str:\n    return re.sub('a|e|i|o|u', '', s)",
      "title": "1119. Remove Vowels from a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d81dc6c-dcff-4c69-927b-05d9d3db2330",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n  maxAverage: int\n\n\nclass Solution:\n  def maximumAverageSubtree(self, root: TreeNode | None) -> float:\n    def maximumAverage(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0, 0)\n\n      left = maximumAverage(root.left)\n      right = maximumAverage(root.right)\n\n      summ = root.val + left.summ + right.summ\n      count = 1 + left.count + right.count\n      maxAverage = max(summ / count, left.maxAverage, right.maxAverage)\n      return T(summ, count, maxAverage)\n\n    return maximumAverage(root).maxAverage",
      "title": "1120. Maximum Average Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12c8851a-bf21-41e8-a3d1-aed8a2a22604",
      "code": "class Solution:\n  def canDivideIntoSubsequences(self, nums: list[int], k: int) -> bool:\n    # Find the number with the maxFreq, we need at least maxFreq * k elements\n    # e.g. nums = [1, 2, 2, 3, 4], we have maxFreq = 2 (two 2s), so we have to\n    # Split nums into two subsequences say k = 3, the minimum length of nums is 2 x\n    # 3 = 6, which is impossible if len(nums) = 5\n    return len(nums) >= k * max(Counter(nums).values())",
      "title": "1121. Divide Array Into Increasing Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bab806a8-34ae-47e5-b459-e99050fba7fd",
      "code": "class Solution:\n  def relativeSortArray(self, arr1: list[int], arr2: list[int]) -> list[int]:\n    ans = []\n    count = [0] * 1001\n\n    for a in arr1:\n      count[a] += 1\n\n    for a in arr2:\n      while count[a] > 0:\n        ans.append(a)\n        count[a] -= 1\n\n    for num in range(1001):\n      for _ in range(count[num]):\n        ans.append(num)\n\n    return ans",
      "title": "1122. Relative Sort Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0f87d59-49a2-4917-bfbe-58d68f4d5fa3",
      "code": "class Solution:\n  def longestWPI(self, hours: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    dict = {}\n\n    for i in range(len(hours)):\n      prefix += 1 if hours[i] > 8 else -1\n      if prefix > 0:\n        ans = i + 1\n      else:\n        if prefix not in dict:\n          dict[prefix] = i\n        if prefix - 1 in dict:\n          ans = max(ans, i - dict[prefix - 1])\n\n    return ans",
      "title": "1124. Longest Well-Performing Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39e13583-01ef-43e3-b544-cf425b835f25",
      "code": "class Solution:\n  def numEquivDominoPairs(self, dominoes: list[list[int]]) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for domino in dominoes:\n      key = min(domino[0], domino[1]) * 10 + max(domino[0], domino[1])\n      ans += count[key]\n      count[key] += 1\n\n    return ans",
      "title": "1128. Number of Equivalent Domino Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46d6047b-a24c-4657-8877-1db57bf3850c",
      "code": "from enum import Enum\n\n\nclass Color(Enum):\n  INIT = 0\n  RED = 1\n  BLUE = 2\n\n\nclass Solution:\n  def shortestAlternatingPaths(\n      self,\n      n: int,\n      redEdges: list[list[int]],\n      blueEdges: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * n\n    graph = [[] for _ in range(n)]  # graph[u] := [(v, edgeColor)]\n    q = collections.deque([(0, Color.INIT)])  # [(u, prevColor)]\n\n    for u, v in redEdges:\n      graph[u].append((v, Color.RED))\n\n    for u, v in blueEdges:\n      graph[u].append((v, Color.BLUE))\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        u, prevColor = q.popleft()\n        if ans[u] == -1:\n          ans[u] = step\n        for i, (v, edgeColor) in enumerate(graph[u]):\n          if v == -1 or edgeColor == prevColor:\n            continue\n          q.append((v, edgeColor))\n          graph[u][i] = (-1, edgeColor)  # Mark (u, v) as used.\n      step += 1\n\n    return ans",
      "title": "1129. Shortest Path with Alternating Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6a7776e-40a0-40ec-bb9b-a4fe932edb1c",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0fbf1d4-bb6b-450c-a2ae-2ae07c3f0854",
      "code": "class Solution:\n  def mctFromLeafValues(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum cost of arr[i..j]\n    dp = [[0] * n for _ in range(n)]\n    # maxVal[i][j] := the maximum value of arr[i..j]\n    maxVal = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      maxVal[i][i] = arr[i]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        maxVal[i][j] = max(maxVal[i][j - 1], maxVal[i + 1][j])\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j] +\n                         maxVal[i][k] * maxVal[k + 1][j])\n\n    return dp[0][-1]",
      "title": "1130. Minimum Cost Tree From Leaf Values_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c6fe318-98ba-4a17-8f03-a7f49f19465d",
      "code": "class Solution:\n  def maxAbsValExpr(self, arr1: list[int], arr2: list[int]) -> int:\n    n = len(arr1)\n    a = [arr1[i] + arr2[i] + i for i in range(n)]\n    b = [arr1[i] + arr2[i] - i for i in range(n)]\n    c = [arr1[i] - arr2[i] + i for i in range(n)]\n    d = [arr1[i] - arr2[i] - i for i in range(n)]\n    return max(map(lambda x: max(x) - min(x), (a, b, c, d)))",
      "title": "1131. Maximum of Absolute Value Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14f60626-058d-4a39-a792-b745e85d37d9",
      "code": "class Solution:\n  def largestUniqueNumber(self, nums: list[int]) -> int:\n    return max([num for num, freq in collections.Counter(nums).items()\n                if freq == 1], default=-1)",
      "title": "1133. Largest Unique Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3befc955-495a-4f91-9224-d208de3de66a",
      "code": "class Solution:\n  def isArmstrong(self, n: int) -> bool:\n    s = str(n)\n    k = len(s)\n    return sum(pow(int(c), k) for c in s) == n",
      "title": "1134. Armstrong Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d645752-ced7-47e9-81ea-a4e1c745635c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(self, n: int, connections: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n + 1)\n\n    # Sort by cost.\n    connections.sort(key=lambda x: x[2])\n\n    for u, v, cost in connections:\n      if uf.find(u) == uf.find(v):\n        continue\n      uf.unionByRank(u, v)\n      ans += cost\n\n    root = uf.find(1)\n    if any(uf.find(i) != root for i in range(1, n + 1)):\n      return -1\n\n    return ans",
      "title": "1135. Connecting Cities With Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc55549e-e018-44cc-baf3-077b993552d4",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def minimumSemesters(self, n: int, relations: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n    states = [State.INIT] * n\n    depth = [1] * n\n\n    for u, v in relations:\n      graph[u - 1].append(v - 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if hasCycle(v):\n          return True\n        depth[u] = max(depth[u], 1 + depth[v])\n      states[u] = State.VISITED\n      return False\n\n    if any(hasCycle(i) for i in range(n)):\n      return -1\n    return max(depth)",
      "title": "1136. Parallel Courses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac655a9b-d8ec-4991-a97a-5b55e0b7df06",
      "code": "class Solution:\n  def tribonacci(self, n: int) -> int:\n    if n < 2:\n      return n\n\n    dp = [0, 1, 1]\n\n    for _ in range(3, n + 1):\n      dp[0], dp[1], dp[2] = dp[1], dp[2], sum(dp)\n\n    return dp[2]",
      "title": "1137. N-th Tribonacci Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8753d1b-1bcd-40c4-8d12-85eff315bd1e",
      "code": "class Solution:\n  def largest1BorderedSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    # leftOnes[i][j] := consecutive 1s in the left of grid[i][j]\n    leftOnes = [[0] * n for _ in range(m)]\n    # topOnes[i][j] := consecutive 1s in the top of grid[i][j]\n    topOnes = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          leftOnes[i][j] = 1 if j == 0 else 1 + leftOnes[i][j - 1]\n          topOnes[i][j] = 1 if i == 0 else 1 + topOnes[i - 1][j]\n\n    for sz in range(min(m, n), 0, -1):\n      for i in range(m - sz + 1):\n        for j in range(n - sz + 1):\n          x = i + sz - 1\n          y = j + sz - 1\n          # If grid[i..x][j..y] has all 1s on its border.\n          if min(\n                  leftOnes[i][y],\n                  leftOnes[x][y],\n                  topOnes[x][j],\n                  topOnes[x][y]) >= sz:\n            return sz * sz\n\n    return 0",
      "title": "1139. Largest 1-Bordered Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebfb328b-a93f-4e3c-b3c4-f5f32bdae6bc",
      "code": "class Solution:\n  def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n    m = len(text1)\n    n = len(text2)\n    # dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = (1 + dp[i][j] if text1[i] == text2[j]\n                            else max(dp[i][j + 1], dp[i + 1][j]))\n\n    return dp[m][n]",
      "title": "1143. Longest Common Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eb556b39-f514-41fd-a8ad-bb4238e5b00f",
      "code": "class Solution:\n  def movesToMakeZigzag(self, nums: list[int]) -> int:\n    decreasing = [0] * 2\n\n    for i, num in enumerate(nums):\n      l = nums[i - 1] if i > 0 else 1001\n      r = nums[i + 1] if i + 1 < len(nums) else 1001\n      decreasing[i % 2] += max(0, num - min(l, r) + 1)\n\n    return min(decreasing[0], decreasing[1])",
      "title": "1144. Decrease Elements To Make Array Zigzag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "064a43ad-9647-4447-9927-64e9e454f0cb",
      "code": "class Solution:\n  def isMajorityElement(self, nums: list[int], target: int) -> bool:\n    n = len(nums)\n    i = bisect.bisect_left(nums, target)\n    return i + n // 2 < n and nums[i + n // 2] == target",
      "title": "1150. Check If a Number Is Majority Element in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfc76478-ca6c-4d5b-aee2-da695bc5c88b",
      "code": "class Solution:\n  def minSwaps(self, data: list[int]) -> int:\n    k = data.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i, num in enumerate(data):\n      if i >= k and data[i - k]:\n        ones -= 1\n      if num:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "1151. Minimum Swaps to Group All 1's Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "566b2697-1710-4d68-9418-38c56de487d6",
      "code": "class Solution:\n  def mostVisitedPattern(\n      self,\n      username: list[str],\n      timestamp: list[int],\n      website: list[str],\n  ) -> list[str]:\n    userToSites = collections.defaultdict(list)\n\n    # Sort websites of each user by timestamp.\n    for user, _, site in sorted(\n            zip(username, timestamp, website),\n            key=lambda x: x[1]):\n      userToSites[user].append(site)\n\n    # For each of three websites, count its frequency.\n    patternCount = collections.Counter()\n\n    for user, sites in userToSites.items():\n      patternCount.update(Counter(set(itertools.combinations(sites, 3))))\n\n    return max(sorted(patternCount), key=patternCount.get)",
      "title": "1152. Analyze User Website Visit Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f171c4e6-9afc-4e64-b975-ab8792f375ca",
      "code": "class Solution:\n  def canConvert(self, str1: str, str2: str) -> bool:\n    if str1 == str2:\n      return True\n\n    mappings = {}\n\n    for a, b in zip(str1, str2):\n      if mappings.get(a, b) != b:\n        return False\n      mappings[a] = b\n\n    # No letter in the str1 maps to > 1 letter in the str2 and there is at\n    # lest one temporary letter can break any loops.\n    return len(set(str2)) < 26",
      "title": "1153. String Transforms Into Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f342da4-aa36-4561-80f0-4f11bd694ccc",
      "code": "class Solution:\n  def dayOfYear(self, date: str) -> int:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    year = int(date[:4])\n    month = int(date[5:7])\n    day = int(date[8:])\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    return sum(days[:month - 1]) + day",
      "title": "1154. Day of the Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de3dcc30-3e98-4e6f-96f2-4cb9ab5a2b0a",
      "code": "class Solution:\n  def numRollsToTarget(self, n: int, k: int, target: int) -> int:\n    MOD = 1_000_000_007\n    dp = [1] + [0] * target\n\n    for _ in range(n):  # n dices\n      newDp = [0] * (target + 1)\n      for i in range(1, k + 1):  # numbers 1, 2, ..., f\n        for t in range(i, target + 1):  # all the possible targets\n          newDp[t] += dp[t - i]\n          newDp[t] %= MOD\n      dp = newDp\n\n    return dp[target]",
      "title": "1155. Number of Dice Rolls With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdaf086f-9ba8-419d-8389-2ca7e77beac4",
      "code": "class Solution:\n  def maxRepOpt1(self, text: str) -> int:\n    count = collections.Counter(text)\n    groups = [[c, len(list(group))]\n              for c, group in itertools.groupby(text)]\n    ans = max(min(length + 1, count[c]) for c, length in groups)\n\n    for i in range(1, len(groups) - 1):\n      if groups[i - 1][0] == groups[i + 1][0] and groups[i][1] == 1:\n        ans = max(\n            ans,\n            min(groups[i - 1][1] + groups[i + 1][1] + 1, count\n                [groups[i - 1][0]]))\n\n    return ans",
      "title": "1156. Swap For Longest Repeated Character Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85cf7b31-4557-41f1-a646-8fd5e420d404",
      "code": "class Solution:\n  def countCharacters(self, words: list[str], chars: str) -> int:\n    ans = 0\n    count = collections.Counter(chars)\n\n    for word in words:\n      tempCount = count.copy()\n      for c in word:\n        tempCount[c] -= 1\n        if tempCount[c] < 0:\n          ans -= len(word)\n          break\n      ans += len(word)\n\n    return ans",
      "title": "1160. Find Words That Can Be Formed by Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2af1e78-d896-4515-a876-050f06fad9cf",
      "code": "class Solution:\n  def maxLevelSum(self, root: TreeNode | None) -> int:\n    ans = 0\n    maxLevelSum = -math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum > maxLevelSum:\n        maxLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "1161. Maximum Level Sum of a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "409796a9-c911-45ec-8dee-e136436c9578",
      "code": "class Solution:\n  def maxDistance(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    q = collections.deque()\n    water = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          water += 1\n        else:\n          q.append((i, j))\n\n    if water == 0 or water == m * n:\n      return -1\n\n    ans = 0\n    d = 0\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        ans = d\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] > 0:\n            continue\n          q.append((x, y))\n          grid[x][y] = 2  # Mark as visited.\n      d += 1\n\n    return ans",
      "title": "1162. As Far from Land as Possible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67af9afb-63f1-449c-9790-53a4889c95e6",
      "code": "class Solution:\n  def lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "1163. Last Substring in Lexicographical Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2be80fd6-3b9f-441d-bd5f-4f7fe68ef641",
      "code": "class Solution:\n  def calculateTime(self, keyboard: str, word: str) -> int:\n    letterToIndex = {c: i for i, c in enumerate(keyboard)}\n    return (letterToIndex[word[0]] +\n            sum(abs(letterToIndex[a] - letterToIndex[b])\n            for a, b in itertools.pairwise(word)))",
      "title": "1165. Single-Row Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ccecb69-7461-497d-9bd4-209839ef65e3",
      "code": "class Solution:\n  def connectSticks(self, sticks: list[int]) -> int:\n    ans = 0\n    heapq.heapify(sticks)\n\n    while len(sticks) > 1:\n      x = heapq.heappop(sticks)\n      y = heapq.heappop(sticks)\n      ans += x + y\n      heapq.heappush(sticks, x + y)\n\n    return ans",
      "title": "1167. Minimum Cost to Connect Sticks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "912a7280-9b75-4448-8cb0-e6891f80f8bb",
      "code": "class Solution:\n  def minCostToSupplyWater(\n      self,\n      n: int,\n      wells: list[int],\n      pipes: list[list[int]],\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n + 1)]\n    minHeap = []  # (d, u)\n\n    for u, v, w in pipes:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    # Connect virtual 0 with nodes 1 to n.\n    for i, well in enumerate(wells):\n      graph[0].append((i + 1, well))\n      heapq.heappush(minHeap, (well, i + 1))\n\n    mst = {0}\n\n    while len(mst) < n + 1:\n      d, u = heapq.heappop(minHeap)\n      if u in mst:\n        continue\n      # Add the new vertex.\n      mst.add(u)\n      ans += d\n      # Expand if possible.\n      for v, w in graph[u]:\n        if v not in mst:\n          heapq.heappush(minHeap, (w, v))\n\n    return ans",
      "title": "1168. Optimize Water Distribution in a Village",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce48c70a-3c6e-48d4-8590-fd642a2fe65b",
      "code": "class Solution:\n  def invalidTransactions(self, transactions: list[str]) -> list[str]:\n    ans = []\n    nameToTrans = collections.defaultdict(list)\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      nameToTrans[name].append({'time': time, 'city': city})\n\n    for t in transactions:\n      name, time, amount, city = t.split(',')\n      time, amount = int(time), int(amount)\n      if amount > 1000:\n        ans.append(t)\n      elif name in nameToTrans:\n        for sameName in nameToTrans[name]:\n          if abs(sameName['time'] - time) <= 60 and sameName['city'] != city:\n            ans.append(t)\n            break\n\n    return ans",
      "title": "1169. Invalid Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6925d870-fdce-4e91-8ae8-a7af9fdeaea6",
      "code": "class Solution:\n  def numSmallerByFrequency(\n      self,\n      queries: list[str],\n      words: list[str],\n  ) -> list[int]:\n    ans = []\n    wordsFreq = sorted([word.count(min(word)) for word in words])\n\n    for q in queries:\n      count = q.count(min(q))\n      index = bisect.bisect(wordsFreq, count)\n      ans.append(len(words) - index)\n\n    return ans",
      "title": "1170. Compare Strings by Frequency of the Smallest Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68af512e-8500-4872-b0d1-5ca9f41e576c",
      "code": "class Solution:\n  def removeZeroSumSublists(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    prefix = 0\n    prefixToNode = {0: dummy}\n\n    while head:\n      prefix += head.val\n      prefixToNode[prefix] = head\n      head = head.next\n\n    prefix = 0\n    head = dummy\n\n    while head:\n      prefix += head.val\n      head.next = prefixToNode[prefix].next\n      head = head.next\n\n    return dummy.next",
      "title": "1171. Remove Zero Sum Consecutive Nodes from Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90268c8d-ecb1-4e77-8036-febf784b1041",
      "code": "class Solution:\n  def numPrimeArrangements(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def factorial(n: int) -> int:\n      fact = 1\n      for i in range(2, n + 1):\n        fact = fact * i % MOD\n      return fact\n\n    count = self._countPrimes(n)\n    return factorial(count) * factorial(n - count) % MOD\n\n  def _countPrimes(self, n: int) -> int:\n    isPrime = [False] * 2 + [True] * (n - 1)\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n + 1, i):\n          isPrime[j] = False\n    return sum(isPrime)",
      "title": "1175. Prime Arrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdbf84cb-79cf-492d-a4d4-6091b22465c0",
      "code": "class Solution:\n  def dietPlanPerformance(\n      self,\n      calories: list[int],\n      k: int,\n      lower: int,\n      upper: int,\n  ) -> int:\n    ans = 0\n    summ = 0\n\n    for i, calorie in enumerate(calories):\n      summ += calorie\n      if i < k - 1:\n        continue\n      if i >= k:\n        summ -= calories[i - k]\n      if summ < lower:\n        ans -= 1\n      elif summ > upper:\n        ans += 1\n\n    return ans",
      "title": "1176. Diet Plan Performance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e75273e-bbfe-4ecc-8a9c-48a1a2889540",
      "code": "class Solution:\n  def canMakePaliQueries(self, s: str, queries: list[list[int]]) -> list[bool]:\n    dp = [0] * (len(s) + 1)\n\n    for i in range(1, len(s) + 1):\n      dp[i] = dp[i - 1] ^ 1 << ord(s[i - 1]) - ord('a')\n\n    return [\n        (dp[right + 1] ^ dp[left]).bit_count() // 2 <= k\n        for left, right, k in queries\n    ]",
      "title": "1177. Can Make Palindrome from Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e1eade2-1626-48e9-a0fe-2c2d7efa5f4d",
      "code": "class Solution:\n  def findNumOfValidWords(\n      self,\n      words: list[str],\n      puzzles: list[str],\n  ) -> list[int]:\n    ans = []\n    binaryCount = collections.Counter()\n\n    for word in words:\n      mask = 0\n      for c in word:\n        mask |= 1 << ord(c) - ord('a')\n      binaryCount[mask] += 1\n\n    for puzzle in puzzles:\n      valid = 0\n      n = len(puzzle) - 1\n      for i in range(1 << n):\n        mask = 1 << ord(puzzle[0]) - ord('a')\n        for j in range(n):\n          if i >> j & 1:\n            mask |= 1 << ord(puzzle[j + 1]) - ord('a')\n        if mask in binaryCount:\n          valid += binaryCount[mask]\n      ans.append(valid)\n\n    return ans",
      "title": "1178. Number of Valid Words for Each Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ed67e0d-68f9-4718-bb7b-17817a53c3f4",
      "code": "class Solution:\n  def countLetters(self, s: str) -> int:\n    ans = 0\n    dp = 0  # the length of the running letter\n    letter = '@'  # the running letter\n\n    for c in s:\n      if c == letter:\n        dp += 1\n      else:\n        dp = 1\n        letter = c\n      ans += dp  # Add the number of substrings ending in the current letter.\n\n    return ans",
      "title": "1180. Count Substrings with Only One Distinct Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82fa45a4-c144-4cf8-8ff0-de031741cbe4",
      "code": "class Solution:\n  def shortestDistanceColor(\n      self,\n      colors: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    NUM_COLOR = 3\n    n = len(colors)\n    ans = []\n    # left[i][c] := the closest index of color c in index i to the left\n    left = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n    # right[i][c] := the closest index of color c in index i to the right\n    right = [[0] * (NUM_COLOR + 1) for _ in range(n)]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # 0-indexed, -1 means N//A\n    for i, color in enumerate(colors):\n      colorToLatestIndex[color] = i\n      for c in range(1, NUM_COLOR + 1):\n        left[i][c] = colorToLatestIndex[c]\n\n    colorToLatestIndex = [0, -1, -1, -1]  # Reset.\n    for i in range(n - 1, -1, -1):\n      colorToLatestIndex[colors[i]] = i\n      for c in range(1, NUM_COLOR + 1):\n        right[i][c] = colorToLatestIndex[c]\n\n    for i, c in queries:\n      leftDist = math.inf if left[i][c] == -1 else i - left[i][c]\n      rightDist = math.inf if right[i][c] == -1 else right[i][c] - i\n      minDist = min(leftDist, rightDist)\n      ans.append(-1 if minDist == math.inf else minDist)\n\n    return ans",
      "title": "1182. Shortest Distance to Target Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f6e33b4-22a4-472d-92c0-d1f64087f448",
      "code": "class Solution:\n  def maximumNumberOfOnes(\n      self,\n      width: int,\n      height: int,\n      sideLength: int,\n      maxOnes: int,\n  ) -> int:\n    subCount = []\n\n    def getCount(length: int, index: int) -> int:\n      return (length - index - 1) // sideLength + 1\n\n    for i in range(sideLength):\n      for j in range(sideLength):\n        subCount.append(getCount(width, i) * getCount(height, j))\n\n    return sum(sorted(subCount, reverse=True)[:maxOnes])",
      "title": "1183. Maximum Number of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ed610f9-0eb4-4f01-acb4-c8106f182aa7",
      "code": "class Solution:\n  def distanceBetweenBusStops(\n      self,\n      distance: list[int],\n      start: int, destination: int,\n  ) -> int:\n    clockwise = 0\n    counterclockwise = 0\n\n    if start > destination:\n      start, destination = destination, start\n\n    for i, d in enumerate(distance):\n      if i >= start and i < destination:\n        clockwise += d\n      else:\n        counterclockwise += d\n\n    return min(clockwise, counterclockwise)",
      "title": "1184. Distance Between Bus Stops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62d964a2-c07e-4390-9845-ef22ba1a2de8",
      "code": "class Solution:\n  def dayOfTheWeek(self, day: int, month: int, year: int) -> str:\n    def isLeapYear(year: int) -> bool:\n      return (year % 4 == 0 and year % 100 != 0) or year % 400 == 0\n\n    week = [\"Sunday\", \"Monday\", \"Tuesday\",\n            \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"]\n    days = [31, 29 if isLeapYear(\n        year) else 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    count = 0\n\n    for i in range(1971, year):\n      count += 366 if i % 4 == 0 else 365\n    for i in range(month - 1):\n      count += days[i]\n    count += day\n\n    return week[(count + 4) % 7]",
      "title": "1185. Day of the Week",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e4229a9b-2c61-4c5d-9776-578bfcdede53",
      "code": "class Solution:\n  # Similar to 53. Maximum Subarray\n  def maximumSum(self, arr: list[int]) -> int:\n    # dp[0][i] := the maximum sum subarray ending in i (no deletion)\n    # dp[1][i] := the maximum sum subarray ending in i (at most 1 deletion)\n    dp = [[0] * len(arr) for _ in range(2)]\n\n    dp[0][0] = arr[0]\n    dp[1][0] = arr[0]\n    for i in range(1, len(arr)):\n      dp[0][i] = max(arr[i], dp[0][i - 1] + arr[i])\n      dp[1][i] = max(arr[i], dp[1][i - 1] + arr[i], dp[0][i - 1])\n\n    return max(dp[1])",
      "title": "1186. Maximum Subarray Sum with One Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4363d97-444e-4d39-84df-ac5ff04c2125",
      "code": "class Solution:\n  def makeArrayIncreasing(self, arr1: list[int], arr2: list[int]) -> int:\n    # dp[i] := the minimum steps to reach i at previous round\n    dp = {-1: 0}\n\n    arr2.sort()\n\n    for a in arr1:\n      newDp = collections.defaultdict(lambda: math.inf)\n      for val, steps in dp.items():\n        # It's possible to use the value in the arr1.\n        if a > val:\n          newDp[a] = min(newDp[a], steps)\n        # Also try the value in the arr2.\n        i = bisect_right(arr2, val)\n        if i < len(arr2):\n          newDp[arr2[i]] = min(newDp[arr2[i]], steps + 1)\n      if not newDp:\n        return -1\n      dp = newDp\n\n    return min(dp.values())",
      "title": "1187. Make Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64e0a068-5752-4722-a741-ae3dda8a5d8d",
      "code": "class Solution:\n  def maxNumberOfBalloons(self, text: str) -> int:\n    count = collections.Counter(text)\n    return min(\n        count['b'],\n        count['a'],\n        count['l'] // 2, count['o'] // 2, count['n'])",
      "title": "1189. Maximum Number of Balloons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cc5c900-f3eb-41a9-b2c5-cefe41639cef",
      "code": "class Solution:\n  def reverseParentheses(self, s: str) -> str:\n    ans = []\n    stack = []\n    pair = {}\n\n    for i, c in enumerate(s):\n      if c == '(':\n        stack.append(i)\n      elif c == ')':\n        j = stack.pop()\n        pair[i] = j\n        pair[j] = i\n\n    i = 0\n    d = 1\n    while i < len(s):\n      if s[i] in '()':\n        i = pair[i]\n        d = -d\n      else:\n        ans.append(s[i])\n      i += d\n\n    return ''.join(ans)",
      "title": "1190. Reverse Substrings Between Each Pair of Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2753652a-ecd1-4f9a-8601-0f340899c3a5",
      "code": "class Solution:\n  def kConcatenationMaxSum(self, arr: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    sz = len(arr) * (1 if k == 1 else 2)\n    summ = sum(arr)\n    # The concatenated array will be [arr1, arr2, ..., arrk].\n    # If sum(arr) > 0 and k > 2, then arr2, ..., arr(k - 1) should be included.\n    # Equivalently, maxSubarraySum is from arr1 and arrk.\n    if summ > 0 and k > 2:\n      return (self._kadane(arr, sz) + summ * (k - 2)) % MOD\n    return self._kadane(arr, sz) % MOD\n\n  def _kadane(self, arr: list[int], sz: int) -> int:\n    ans = 0\n    summ = 0\n    for i in range(sz):\n      a = arr[i % len(arr)]\n      summ = max(a, summ + a)\n      ans = max(ans, summ)\n    return ans",
      "title": "1191. K-Concatenation Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67813f96-4e5d-4d72-8353-ebb74e17d854",
      "code": "class Solution:\n  def maxNumberOfApples(self, weight: list[int]) -> int:\n    summ = 0\n\n    for i, w in enumerate(sorted(weight)):\n      summ += w\n      if summ > 5000:\n        return i\n\n    return len(weight)",
      "title": "1196. How Many Apples Can You Put into the Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e4b442f-a9b6-4b2b-86b7-1fdbc6e50851",
      "code": "class Solution:\n  def smallestCommonElement(self, mat: list[list[int]]) -> int:\n    MAX = 10000\n    count = [0] * (MAX + 1)\n\n    for row in mat:\n      for a in row:\n        count[a] += 1\n        if count[a] == len(mat):\n          return a\n\n    return -1",
      "title": "1198. Find Smallest Common Element in All Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f73af526-72e9-4892-b82e-ed419e36bd8c",
      "code": "class Solution:\n  def minBuildTime(self, blocks: list[int], split: int) -> int:\n    minHeap = blocks.copy()\n    heapify(minHeap)\n\n    while len(minHeap) > 1:\n      heapq.heappop(minHeap)  # the minimum\n      x = heapq.heappop(minHeap)  # the second minimum\n      heapq.heappush(minHeap, x + split)\n\n    return minHeap[0]",
      "title": "1199. Minimum Time to Build Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e65a52f-2d6a-4fea-97c5-b1ca0c693b66",
      "code": "class Solution:\n  def minimumAbsDifference(self, arr: list[int]) -> list[list[int]]:\n    ans = []\n    mn = math.inf\n\n    arr.sort()\n\n    for a, b in itertools.pairwise(arr):\n      diff = b - a\n      if diff < mn:\n        mn = diff\n        ans = []\n      if diff == mn:\n        ans.append([a, b])\n\n    return ans",
      "title": "1200. Minimum Absolute Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35260780-4e00-4772-ac70-bd5cc6074186",
      "code": "class Solution:\n  def nthUglyNumber(self, n: int, a: int, b: int, c: int) -> int:\n    ab = a * b // math.gcd(a, b)\n    ac = a * c // math.gcd(a, c)\n    bc = b * c // math.gcd(b, c)\n    abc = a * bc // math.gcd(a, bc)\n    return bisect.bisect_left(range(2 * 10**9), n,\n                              key=lambda m: m // a + m // b + m // c\n                              - m // ab - m // ac - m // bc\n                              + m // abc)",
      "title": "1201. Ugly Number III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aa91023-4851-45d6-ad59-354821cc64c7",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def smallestStringWithSwaps(self, s: str, pairs: list[list[int]]) -> str:\n    uf = UnionFind(len(s))\n    indexToLetters = collections.defaultdict(list)\n\n    for a, b in pairs:\n      uf.unionByRank(a, b)\n\n    for i, c in enumerate(s):\n      indexToLetters[uf.find(i)].append(c)\n\n    for key in indexToLetters.keys():\n      indexToLetters[key].sort(reverse=True)\n\n    return ''.join(indexToLetters[uf.find(i)].pop()\n                   for i in range(len(s)))",
      "title": "1202. Smallest String With Swaps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a5ea385-900a-466c-96c6-ce9546e4862e",
      "code": "class Solution:\n  def uniqueOccurrences(self, arr: list[int]) -> bool:\n    count = collections.Counter(arr)\n    occurrences = set()\n\n    for value in count.values():\n      if value in occurrences:\n        return False\n      occurrences.add(value)\n\n    return True",
      "title": "1207. Unique Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76b85bad-c108-4f75-948f-1c7dcbf7df3b",
      "code": "class Solution:\n  def equalSubstring(self, s: str, t: str, maxCost: int) -> int:\n    j = 0\n    for i in range(len(s)):\n      maxCost -= abs(ord(s[i]) - ord(t[i]))\n      if maxCost < 0:\n        maxCost += abs(ord(s[j]) - ord(t[j]))\n        j += 1\n\n    return len(s) - j",
      "title": "1208. Get Equal Substrings Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13bd583f-5422-415c-9ccc-2010872d9c1c",
      "code": "class Solution:\n  def removeDuplicates(self, s: str, k: int) -> str:\n    stack = []\n\n    for c in s:\n      if not stack or stack[-1][0] != c:\n        stack.append([c, 1])\n      else:  # stack[-1][0] == c\n        stack[-1][1] += 1\n        if stack[-1][1] == k:\n          stack.pop()\n\n    return ''.join(c * count for c, count in stack)",
      "title": "1209. Remove All Adjacent Duplicates in String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b61678a8-f0ce-4597-87b4-bf4d38295a1c",
      "code": "from enum import IntEnum\n\n\nclass Pos(IntEnum):\n  HORIZONTAL = 0\n  VERTICAL = 1\n\n\nclass Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # the state of (x, y, pos)\n    # pos := 0 (horizontal) / 1 (vertical)\n    q = collections.deque([(0, 0, Pos.HORIZONTAL)])\n    seen = {(0, 0, Pos.HORIZONTAL)}\n\n    def canMoveRight(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.HORIZONTAL:\n        return y + 2 < n and not grid[x][y + 2]\n      return y + 1 < n and not grid[x][y + 1] and not grid[x + 1][y + 1]\n\n    def canMoveDown(x: int, y: int, pos: Pos) -> bool:\n      if pos == Pos.VERTICAL:\n        return x + 2 < n and not grid[x + 2][y]\n      return x + 1 < n and not grid[x + 1][y] and not grid[x + 1][y + 1]\n\n    def canRotateClockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.HORIZONTAL and x + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x + 1][y])\n\n    def canRotateCounterclockwise(x: int, y: int, pos: Pos) -> bool:\n      return (pos == Pos.VERTICAL and y + 1 < n and\n              not grid[x + 1][y + 1] and not grid[x][y + 1])\n\n    while q:\n      for _ in range(len(q)):\n        x, y, pos = q.popleft()\n        if x == n - 1 and y == n - 2 and pos == Pos.HORIZONTAL:\n          return ans\n        if canMoveRight(x, y, pos) and (x, y + 1, pos) not in seen:\n          q.append((x, y + 1, pos))\n          seen.add((x, y + 1, pos))\n        if canMoveDown(x, y, pos) and (x + 1, y, pos) not in seen:\n          q.append((x + 1, y, pos))\n          seen.add((x + 1, y, pos))\n        newPos = Pos.VERTICAL if pos == Pos.HORIZONTAL else Pos.HORIZONTAL\n        if ((canRotateClockwise(x, y, pos) or\n             canRotateCounterclockwise(x, y, pos)) and\n                (x, y, newPos) not in seen):\n          q.append((x, y, newPos))\n          seen.add((x, y, newPos))\n      ans += 1\n\n    return -1",
      "title": "1210. Minimum Moves to Reach Target with Rotations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22e29fd0-2732-4df1-b5a8-2ee8daf3c2e8",
      "code": "class BSTIterator:\n  def __init__(self, root: TreeNode | None, leftToRight: bool):\n    self.stack = []\n    self.leftToRight = leftToRight\n    self._pushUntilNone(root)\n\n  def hasNext(self) -> bool:\n    return len(self.stack) > 0\n\n  def next(self) -> int:\n    node = self.stack.pop()\n    if self.leftToRight:\n      self._pushUntilNone(node.right)\n    else:\n      self._pushUntilNone(node.left)\n    return node.val\n\n  def _pushUntilNone(self, root: TreeNode | None):\n    while root:\n      self.stack.append(root)\n      root = root.left if self.leftToRight else root.right\n\n\nclass Solution:\n  def twoSumBSTs(\n      self,\n      root1: TreeNode | None,\n      root2: TreeNode | None,\n      target: int,\n  ) -> bool:\n    bst1 = BSTIterator(root1, True)\n    bst2 = BSTIterator(root2, False)\n\n    l = bst1.next()\n    r = bst2.next()\n    while True:\n      summ = l + r\n      if summ == target:\n        return True\n      if summ < target:\n        if not bst1.hasNext():\n          return False\n        l = bst1.next()\n      else:\n        if not bst2.hasNext():\n          return False\n        r = bst2.next()",
      "title": "1214. Two Sum BSTs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be953ae1-1156-4179-aaec-ee97415a9f22",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: int, high: int) -> list[int]:\n    ans = [0] if low == 0 else []\n    q = collections.deque(list(range(1, 10)))\n\n    while q:\n      curr = q.popleft()\n      if curr > high:\n        continue\n      if curr >= low:\n        ans.append(curr)\n      lastDigit = curr % 10\n      if lastDigit > 0:\n        q.append(curr * 10 + lastDigit - 1)\n      if lastDigit < 9:\n        q.append(curr * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1215. Stepping Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d5f8815-d6a1-4c0a-8019-c2c3202c9bdf",
      "code": "class Solution:\n  def isValidPalindrome(self, s: str, k: int) -> bool:\n    return len(s) - self._longestPalindromeSubseq(s) <= k\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1216. Valid Palindrome III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a764816a-36ec-472f-a1b0-105cb51df503",
      "code": "class Solution:\n  def minCostToMoveChips(self, position: list[int]) -> int:\n    count = [0, 0]\n    for p in position:\n      count[p % 2] += 1\n    return min(count[0], count[1])",
      "title": "1217. Play with Chips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9e929e5-0a53-4b97-95f2-6bb82187991a",
      "code": "class Solution:\n  def longestSubsequence(self, arr: list[int], difference: int) -> int:\n    ans = 0\n    lengthAt = {}\n\n    for a in arr:\n      lengthAt[a] = lengthAt.get(a - difference, 0) + 1\n      ans = max(ans, lengthAt[a])\n\n    return ans",
      "title": "1218. Longest Arithmetic Subsequence of Given Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8ff57fb-b516-491a-af68-a0cfa9a7bc78",
      "code": "class Solution:\n  def getMaximumGold(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or j < 0 or i == len(grid) or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n\n      gold = grid[i][j]\n      grid[i][j] = 0  # Mark as visited.\n      maxPath = max(dfs(i + 1, j), dfs(i - 1, j),\n                    dfs(i, j + 1), dfs(i, j - 1))\n      grid[i][j] = gold\n      return gold + maxPath\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "1219. Path with Maximum Gold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf613515-04cc-4800-8d0b-a7ad81517a1e",
      "code": "class Solution:\n  def countVowelPermutation(self, n: int) -> int:\n    MOD = 1_000_000_007\n    dp = {'a': 1, 'e': 1, 'i': 1, 'o': 1, 'u': 1}\n\n    for _ in range(n - 1):\n      newDp = {'a': dp['e'] + dp['i'] + dp['u'],\n               'e': dp['a'] + dp['i'],\n               'i': dp['e'] + dp['o'],\n               'o': dp['i'],\n               'u': dp['i'] + dp['o']}\n      dp = newDp\n\n    return sum(dp.values()) % MOD",
      "title": "1220. Count Vowels Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7eaa261a-8aa1-420c-a32a-6ceaa1f46b06",
      "code": "class Solution:\n  def queensAttacktheKing(self, queens: list[list[int]],\n                          king: list[int]) -> list[list[int]]:\n    ans = []\n    queens = {(i, j) for i, j in queens}\n\n    for d in [\n        [-1, -1],\n        [-1, 0],\n        [-1, 1],\n        [0, -1],\n        [0, 1],\n        [1, -1],\n        [1, 0],\n            [1, 1]]:\n      i = king[0] + d[0]\n      j = king[1] + d[1]\n      while 0 <= i < 8 and 0 <= j < 8:\n        if (i, j) in queens:\n          ans.append([i, j])\n          break\n        i += d[0]\n        j += d[1]\n\n    return ans",
      "title": "1222. Queens That Can Attack the King",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c36e76d-825b-4ac4-97a9-6faa09d50600",
      "code": "class Solution:\n  def dieSimulator(self, n: int, rollMax: list[int]) -> int:\n    MAX_ROLLS = 15\n    MOD = 1_000_000_007\n\n    dp = [[[0] * (MAX_ROLLS + 1) for j in range(6)] for i in range(n + 1)]\n\n    for num in range(6):\n      dp[1][num][1] = 1\n\n    for i in range(2, n + 1):\n      for currNum in range(6):\n        for prevNum in range(6):\n          for k in range(1, 15 + 1):\n            if prevNum != currNum:\n              dp[i][currNum][1] = (\n                  dp[i][currNum][1] + dp[i - 1][prevNum][k]) % MOD\n            elif k < rollMax[currNum]:\n              dp[i][currNum][k + 1] = dp[i - 1][currNum][k]\n\n    ans = 0\n\n    for num in range(6):\n      for k in range(1, 15 + 1):\n        ans += dp[n][num][k]\n\n    return ans % MOD",
      "title": "1223. Dice Roll Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7ecf6cb-5278-48dd-ba3e-d81ebdc57d57",
      "code": "class Solution:\n  def maxEqualFreq(self, nums: list[int]) -> int:\n    ans = 0\n    maxFreq = 0\n    count = collections.Counter()\n    freq = collections.Counter()\n\n    for i, num in enumerate(nums):\n      freq[count[num]] -= 1\n      count[num] += 1\n      freq[count[num]] += 1\n      maxFreq = max(maxFreq, count[num])\n      if maxFreq == 1 or maxFreq * freq[maxFreq] == i or (maxFreq - 1) * (\n              freq[maxFreq - 1] + 1) == i:\n        ans = i + 1\n\n    return ans",
      "title": "1224. Maximum Equal Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "76b375a9-24a0-437e-8fa5-cfb0fdf69134",
      "code": "class Solution:\n  def nthPersonGetsNthSeat(self, n: int) -> float:\n    return 1 if n == 1 else 0.5",
      "title": "1227. Airplane Seat Assignment Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfbff2d2-2159-43bb-ac3c-c44ad019df62",
      "code": "class Solution:\n  def missingNumber(self, arr: list[int]) -> int:\n    n = len(arr)\n    delta = (arr[-1] - arr[0]) // n\n    l = 0\n    r = n - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if arr[m] == arr[0] + m * delta:\n        l = m + 1\n      else:\n        r = m\n\n    return arr[0] + l * delta",
      "title": "1228. Missing Number In Arithmetic Progression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e9bc42f-8d1b-42a6-9818-4d3983bb373b",
      "code": "class Solution:\n  def minAvailableDuration(\n      self,\n      slots1: list[list[int]],\n      slots2: list[list[int]],\n      duration: int,\n  ) -> list[int]:\n    slots1.sort()\n    slots2.sort()\n\n    i = 0  # slots1's index\n    j = 0  # slots2's index\n\n    while i < len(slots1) and j < len(slots2):\n      start = max(slots1[i][0], slots2[j][0])\n      end = min(slots1[i][1], slots2[j][1])\n      if start + duration <= end:\n        return [start, start + duration]\n      if slots1[i][1] < slots2[j][1]:\n        i += 1\n      else:\n        j += 1\n\n    return []",
      "title": "1229. Meeting Scheduler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a74a70f9-1a10-4417-affc-070598952a8d",
      "code": "class Solution:\n  def probabilityOfHeads(self, prob: list[float], target: int) -> float:\n    # dp[i][j] := the probability of tossing the first i coins with j heads\n    dp = [[0] * (target + 1) for _ in range(len(prob) + 1)]\n    dp[0][0] = 1.0\n\n    for i in range(1, len(prob) + 1):\n      for j in range(target + 1):\n        dp[i][j] = ((dp[i - 1][j - 1] * prob[i - 1] if j > 0 else 0) +\n                    dp[i - 1][j] * (1 - prob[i - 1]))\n\n    return dp[len(prob)][target]",
      "title": "1230. Toss Strange Coins",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f5da644-a3b8-4ab0-abcd-6dd9c3c1b86d",
      "code": "class Solution:\n  def maximizeSweetness(self, sweetness: list[int], k: int) -> int:\n    l = len(sweetness) // (k + 1)\n    r = sum(sweetness) // (k + 1)\n\n    def canEat(m: int) -> bool:\n      \"\"\"\n      Returns True if can eat m sweetness (the minimum sweetness of each piece).\n      \"\"\"\n      pieces = 0\n      summ = 0  # the running sum\n      for s in sweetness:\n        summ += s\n        if summ >= m:\n          pieces += 1\n          summ = 0\n      return pieces > k\n\n    while l < r:\n      m = (l + r) // 2\n      if canEat(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l if canEat(l) else l - 1",
      "title": "1231. Divide Chocolate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10fde5b6-86c7-494c-84e6-186d1a6ed5fa",
      "code": "class Solution:\n  def checkStraightLine(self, coordinates: list[list[int]]) -> bool:\n    x0, y0, x1, y1 = *coordinates[0], *coordinates[1]\n    dx = x1 - x0\n    dy = y1 - y0\n\n    return all((x - x0) * dy == (y - y0) * dx for x, y in coordinates)",
      "title": "1232. Check If It Is a Straight Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a12df689-856f-4a4b-b38a-ab50d7065840",
      "code": "class Solution:\n  def removeSubfolders(self, folder: list[str]) -> list[str]:\n    ans = []\n    prev = \"\"\n\n    folder.sort()\n\n    for f in folder:\n      if len(prev) > 0 and f.startswith(prev) and f[len(prev)] == '/':\n        continue\n      ans.append(f)\n      prev = f\n\n    return ans",
      "title": "1233. Remove Sub-Folders from the Filesystem",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5ecabe1-2d00-4809-be88-39f11f3fdc47",
      "code": "class Solution:\n  def balancedString(self, s: str) -> int:\n    ans = len(s)\n    count = collections.Counter(s)\n    j = 0\n\n    for i, c in enumerate(s):\n      count[c] -= 1\n      while j < len(s) and all(count[c] <= len(s) // 4 for c in 'QWER'):\n        ans = min(ans, i - j + 1)\n        count[s[j]] += 1\n        j += 1\n\n    return ans",
      "title": "1234. Replace the Substring for Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "995d4964-f06d-4e8f-8b31-fa01a95d50ae",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    maxProfit = 0\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n    minHeap = []  # (endTime, profit)\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    for s, e, p in jobs:\n      while minHeap and s >= minHeap[0][0]:\n        maxProfit = max(maxProfit, heapq.heappop(minHeap)[1])\n      heapq.heappush(minHeap, (e, p + maxProfit))\n\n    return max(maxProfit, max(p for _, p in minHeap))",
      "title": "1235. Maximum Profit in Job Scheduling",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4dbacb4-5e79-4ace-981f-0a40393b137d",
      "code": "class Solution:\n  def jobScheduling(\n      self,\n      startTime: list[int],\n      endTime: list[int],\n      profit: list[int],\n  ) -> int:\n    jobs = sorted([(s, e, p) for s, e, p in zip(startTime, endTime, profit)])\n\n    # Will use binary search to find the first available startTime\n    for i in range(len(startTime)):\n      startTime[i] = jobs[i][0]\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the maximum profit to schedule jobs[i..n).\"\"\"\n      if i == len(startTime):\n        return 0\n      j = bisect.bisect_left(startTime, jobs[i][1])\n      return max(jobs[i][2] + dp(j), dp(i + 1))\n\n    return dp(0)",
      "title": "1235. Maximum Profit in Job Scheduling_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5df737ba-66a6-40d2-b210-8206fd59e55a",
      "code": "# \"\"\"\n# This is HtmlParser's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class HtmlParser(object):\n#   def getUrls(self, url: str) -> list[str]:\n\nclass Solution:\n  def crawl(self, startUrl: str, htmlParser: 'HtmlParser') -> list[str]:\n    q = collections.deque([startUrl])\n    seen = {startUrl}\n    hostname = startUrl.split('/')[2]\n\n    while q:\n      currUrl = q.popleft()\n      for url in htmlParser.getUrls(currUrl):\n        if url in seen:\n          continue\n        if hostname in url:\n          q.append(url)\n          seen.add(url)\n\n    return seen",
      "title": "1236. Web Crawler",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfd6ecc4-8b8d-4abf-88ef-e456e46f8916",
      "code": "class Solution:\n  def findSolution(self, customfunction: 'CustomFunction', z: int) -> list[list[int]]:\n    ans = []\n    x = 1\n    y = 1000\n\n    while x <= 1000 and y >= 1:\n      f = customfunction.f(x, y)\n      if f < z:\n        x += 1\n      elif f > z:\n        y -= 1\n      else:\n        ans.append([x, y])\n        x += 1\n        y -= 1\n\n    return ans",
      "title": "1237. Find Positive Integer Solution for a Given Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97254919-3a06-4ab3-bb03-0e93e3b9b6d9",
      "code": "class Solution:\n  def circularPermutation(self, n: int, start: int) -> list[int]:\n    return [start ^ i ^ i >> 1 for i in range(1 << n)]",
      "title": "1238. Circular Permutation in Binary Representation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52a6e51d-9668-40ba-bd7e-7385a39213d1",
      "code": "class Solution:\n  def tilingRectangle(self, n: int, m: int) -> int:\n    @functools.lru_cache(None)\n    def dp(heights: int) -> int:\n      minHeight = min(heights)\n      if minHeight == n:  # All filled.\n        return 0\n\n      ans = m * n\n      heightsList = list(heights)\n      start = heightsList.index(minHeight)\n\n      # Try to put square of different size that doesn't exceed the width/height.\n      for sz in range(1, min(m - start + 1, n - minHeight + 1)):\n        # heights[start..start + sz) must has the same height.\n        if heights[start + sz - 1] != minHeight:\n          break\n        # Put a square of size `sz` to cover heights[start..start + sz).\n        heightslist[start:start + sz] = [minHeight + sz] * sz\n        ans = min(ans, dp(tuple(heightsList)))\n\n      return 1 + ans\n\n    return dp(tuple([0] * m))",
      "title": "1240. Tiling a Rectangle with the Fewest Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1472e67e-d9c1-4fd1-a27f-f4c79068a075",
      "code": "class Solution:\n  def transformArray(self, arr: list[int]) -> list[int]:\n    if len(arr) < 3:\n      return arr\n\n    ans = []\n\n    while ans != arr:\n      ans = arr[:]\n      for i in range(1, len(arr) - 1):\n        if ans[i - 1] > ans[i] < ans[i + 1]:\n          arr[i] += 1\n        elif ans[i - 1] < ans[i] > ans[i + 1]:\n          arr[i] -= 1\n\n    return ans",
      "title": "1243. Array Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc985aa-35fa-4f92-ac39-8b14e4b95c67",
      "code": "class Solution:\n  def minimumMoves(self, arr: list[int]) -> int:\n    n = len(arr)\n    # dp[i][j] := the minimum number of moves to remove all numbers from arr[i..j]\n    dp = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for i in range(n - 1):\n      dp[i][i + 1] = 1 if arr[i] == arr[i + 1] else 2\n\n    for d in range(2, n):\n      for i in range(n - d):\n        j = i + d\n        # Remove arr[i] and arr[j] within the move of removing\n        # arr[i + 1..j - 1]\n        if arr[i] == arr[j]:\n          dp[i][j] = dp[i + 1][j - 1]\n        # Try all the possible partitions.\n        for k in range(i, j):\n          dp[i][j] = min(dp[i][j], dp[i][k] + dp[k + 1][j])\n\n    return dp[0][n - 1]",
      "title": "1246. Palindrome Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "916c4bfa-7ca9-40b8-a6fa-c3a7ba4c64ac",
      "code": "class Solution:\n  def minimumSwap(self, s1: str, s2: str) -> int:\n    # ('xx', 'yy') = (2 'xy's) . 1 swap\n    # ('yy', 'xx') = (2 'yx's) . 1 swap\n    # ('xy', 'yx') = (1 'xy' and 1 'yx') . 2 swaps\n    xy = 0  # the number of indices i's s.t. s1[i] = 'x' and s2[i] 'y'\n    yx = 0  # the number of indices i's s.t. s1[i] = 'y' and s2[i] 'x'\n\n    for a, b in zip(s1, s2):\n      if a == b:\n        continue\n      if a == 'x':\n        xy += 1\n      else:\n        yx += 1\n\n    if (xy + yx) % 2 == 1:\n      return -1\n    return xy // 2 + yx // 2 + (0 if xy % 2 == 0 else 2)",
      "title": "1247. Minimum Swaps to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "427b6978-7344-4b95-afa4-2a2333cce9eb",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int], k: int) -> int:\n    def numberOfSubarraysAtMost(k: int) -> int:\n      ans = 0\n      l = 0\n      r = 0\n\n      while r <= len(nums):\n        if k >= 0:\n          ans += r - l\n          if r == len(nums):\n            break\n          if nums[r] & 1:\n            k -= 1\n          r += 1\n        else:\n          if nums[l] & 1:\n            k += 1\n          l += 1\n      return ans\n\n    return numberOfSubarraysAtMost(k) - numberOfSubarraysAtMost(k - 1)",
      "title": "1248. Count Number of Nice Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2a3e65f-8f02-4528-aa85-55367a470bb6",
      "code": "class Solution:\n  def minRemoveToMakeValid(self, s: str) -> str:\n    stack = []  # unpaired '(' indices\n    chars = list(s)\n\n    for i, c in enumerate(chars):\n      if c == '(':\n        stack.append(i)  # Record the unpaired '(' index.\n      elif c == ')':\n        if stack:\n          stack.pop()  # Find a pair\n        else:\n          chars[i] = '*'  # Mark the unpaired ')' as '*'.\n\n    # Mark the unpaired '(' as '*'.\n    while stack:\n      chars[stack.pop()] = '*'\n\n    return ''.join(chars).replace('*', '')",
      "title": "1249. Minimum Remove to Make Valid Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64b12c40-c57c-4509-aaf8-2b8b7cd14389",
      "code": "class Solution:\n  def oddCells(self, m: int, n: int, indices: list[list[int]]) -> int:\n    # rows[i] and cols[i] :=\n    #   1. True (flipped even times)\n    #   2. False (flipped odd times)\n    rows = [False] * m\n    cols = [False] * n\n\n    for r, c in indices:\n      rows[r] ^= True\n      cols[c] ^= True\n\n    oddRowsCount = rows.count(True)\n    oddColsCount = cols.count(True)\n    evenRowsCount = m - oddRowsCount\n    evenColsCount = n - oddColsCount\n    return oddRowsCount * evenColsCount + oddColsCount * evenRowsCount",
      "title": "1252. Cells with Odd Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "30c5405d-af7e-4be7-9641-a81f12f4a69c",
      "code": "class Solution:\n  def reconstructMatrix(self, upper: int, lower: int, colsum: list[int]) -> list[list[int]]:\n    if upper + lower != sum(colsum):\n      return []\n    if min(upper, lower) < colsum.count(2):\n      return []\n\n    ans = [[0] * len(colsum) for _ in range(2)]\n\n    for j, c in enumerate(colsum):\n      if c == 2:\n        ans[0][j] = 1\n        ans[1][j] = 1\n        upper -= 1\n        lower -= 1\n\n    for j, c in enumerate(colsum):\n      if c == 1 and upper > 0:\n        ans[0][j] = 1\n        c -= 1\n        upper -= 1\n      if c == 1 and lower > 0:\n        ans[1][j] = 1\n        lower -= 1\n\n    return ans",
      "title": "1253. Reconstruct a 2-Row Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b6f7529-8dcc-4b7b-ab80-572a9567df29",
      "code": "class Solution:\n  def closedIsland(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(i: int, j: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if grid[i][j] == 1:\n        return\n      grid[i][j] = 1\n      dfs(i + 1, j)\n      dfs(i - 1, j)\n      dfs(i, j + 1)\n      dfs(i, j - 1)\n\n    # Remove the lands connected to the edge.\n    for i in range(m):\n      for j in range(n):\n        if i * j == 0 or i == m - 1 or j == n - 1:\n          if grid[i][j] == 0:\n            dfs(i, j)\n\n    ans = 0\n\n    # Reduce to 200. Number of Islands\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 0:\n          dfs(i, j)\n          ans += 1\n\n    return ans",
      "title": "1254. Number of Closed Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9e839f5-0eea-499d-b227-0cfbb50c32f8",
      "code": "class Solution:\n  def maxScoreWords(\n      self,\n      words: list[str],\n      letters: list[str],\n      score: list[int],\n  ) -> int:\n    count = collections.Counter(letters)\n\n    def useWord(i: int) -> int:\n      isValid = True\n      earned = 0\n      for c in words[i]:\n        count[c] -= 1\n        if count[c] < 0:\n          isValid = False\n        earned += score[ord(c) - ord('a')]\n      return earned if isValid else -1\n\n    def unuseWord(i: int) -> None:\n      for c in words[i]:\n        count[c] += 1\n\n    def dfs(s: int) -> int:\n      \"\"\"Returns the maximum score you can get from words[s..n).\"\"\"\n      ans = 0\n      for i in range(s, len(words)):\n        earned = useWord(i)\n        if earned > 0:\n          ans = max(ans, earned + dfs(i + 1))\n        unuseWord(i)\n      return ans\n\n    return dfs(0)",
      "title": "1255. Maximum Score Words Formed by Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd6c2456-7379-4c69-a2bc-2c6120bf6273",
      "code": "class Solution:\n  def encode(self, num: int) -> str:\n    return bin(num + 1)[3:]",
      "title": "1256. Encode Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca42ab25-bc7e-408d-8275-cae890ff073d",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def generateSentences(\n      self,\n      synonyms: list[list[str]],\n      text: str,\n  ) -> list[str]:\n    ans = SortedSet()\n    graph = collections.defaultdict(list)\n    q = collections.deque([text])\n\n    for s, t in synonyms:\n      graph[s].append(t)\n      graph[t].append(s)\n\n    while q:\n      u = q.popleft()\n      ans.add(u)\n      words = u.split()\n      for i, word in enumerate(words):\n        for synonym in graph[word]:\n          # Replace words[i] with its synonym.\n          words[i] = synonym\n          newText = ' '.join(words)\n          if newText not in ans:\n            q.append(newText)\n\n    return list(ans)",
      "title": "1258. Synonymous Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "775c66cc-821c-42af-888e-3f62327f3d81",
      "code": "class Solution:\n  def numberOfWays(self, numPeople: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways i handshakes could occure s.t. none of the\n    # handshakes cross\n    dp = [1] + [0] * (numPeople // 2)\n\n    for i in range(1, numPeople // 2 + 1):\n      for j in range(i):\n        dp[i] += dp[j] * dp[i - 1 - j]\n        dp[i] %= MOD\n\n    return dp[numPeople // 2]",
      "title": "1259. Handshakes That Don't Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bdb9ebe-41b5-43cd-993b-92a097b7ab05",
      "code": "class Solution:\n  def shiftGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    k %= m * n\n\n    for i in range(m):\n      for j in range(n):\n        index = (i * n + j + k) % (m * n)\n        x = index // n\n        y = index % n\n        ans[x][y] = grid[i][j]\n\n    return ans",
      "title": "1260. Shift 2D Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e392657-d660-4ef6-a51f-5a427f2b351d",
      "code": "class Solution:\n  def minPushBox(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 'B':\n          box = (i, j)\n        elif grid[i][j] == 'S':\n          player = (i, j)\n        elif grid[i][j] == 'T':\n          target = (i, j)\n\n    def isInvalid(playerX: int, playerY: int) -> bool:\n      return (playerX < 0 or playerX == m or playerY < 0 or playerY == n or\n              grid[playerX][playerY] == '#')\n\n    def canGoTo(\n        playerX: int,\n        playerY: int,\n        fromX: int,\n        fromY: int,\n        boxX: int,\n        boxY: int\n    ) -> bool:\n      \"\"\"Returns True if (playerX, playerY) can go to (fromX, fromY).\"\"\"\n      q = collections.deque([(playerX, playerY)])\n      seen = {(playerX, playerY)}\n\n      while q:\n        i, j = q.popleft()\n        if i == fromX and j == fromY:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if isInvalid(x, y):\n            continue\n          if (x, y) in seen:\n            continue\n          if x == boxX and y == boxY:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    # (boxX, boxY, playerX, playerY)\n    q = collections.deque([(box[0], box[1], player[0], player[1])])\n    seen = {(box[0], box[1], player[0], player[1])}\n\n    step = 0\n    while q:\n      for _ in range(len(q)):\n        boxX, boxY, playerX, playerY = q.popleft()\n        if boxX == target[0] and boxY == target[1]:\n          return step\n        for k, (dx, dy) in enumerate(DIRS):\n          nextBoxX = boxX + dx\n          nextBoxY = boxY + dy\n          if isInvalid(nextBoxX, nextBoxY):\n            continue\n          if (nextBoxX, nextBoxY, boxX, boxY) in seen:\n            continue\n          fromX = boxX + DIRS[(k + 2) % 4][0]\n          fromY = boxY + DIRS[(k + 2) % 4][1]\n          if isInvalid(fromX, fromY):\n            continue\n          if canGoTo(playerX, playerY, fromX, fromY, boxX, boxY):\n            q.append((nextBoxX, nextBoxY, boxX, boxY))\n            seen.add((nextBoxX, nextBoxY, boxX, boxY))\n      step += 1\n\n    return -1",
      "title": "1263. Minimum Moves to Move a Box to Their Target Location",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5e236c1-3c7f-4f6e-a1bd-187d6d26fb6d",
      "code": "class Solution:\n  def minTimeToVisitAllPoints(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    for i in range(1, len(points)):\n      ans += max(abs(points[i][0] - points[i - 1][0]),\n                 abs(points[i][1] - points[i - 1][1]))\n\n    return ans",
      "title": "1266. Minimum Time Visiting All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae621302-33ec-46ff-ad2b-55d45d2d2298",
      "code": "class Solution:\n  def countServers(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    rows = [0] * m\n    cols = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and (rows[i] > 1 or cols[j] > 1):\n          ans += 1\n\n    return ans",
      "title": "1267. Count Servers that Communicate",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c0ba8df-a1c1-450b-90b0-5c77dc4c82b7",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.word: str | None = None\n\n\nclass Solution:\n  def suggestedProducts(\n      self,\n      products: list[str],\n      searchWord: str\n  ) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n      node.word = word\n\n    def search(node: TrieNode | None) -> list[str]:\n      res: list[str] = []\n      dfs(node, res)\n      return res\n\n    def dfs(node: TrieNode | None, res: list[str]) -> None:\n      if len(res) == 3:\n        return\n      if not node:\n        return\n      if node.word:\n        res.append(node.word)\n      for c in string.ascii_lowercase:\n        if c in node.children:\n          dfs(node.children[c], res)\n\n    for product in products:\n      insert(product)\n\n    node = root\n\n    for c in searchWord:\n      if not node or c not in node.children:\n        node = None\n        ans.append([])\n        continue\n      node = node.children[c]\n      ans.append(search(node))\n\n    return ans",
      "title": "1268. Search Suggestions System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d07d71d-da55-4f51-8d72-f3001aebe12b",
      "code": "class Solution:\n  def numWays(self, steps: int, arrLen: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to stay at index i\n    dp = [0] * min(steps // 2 + 1, arrLen)\n    dp[0] = 1\n\n    for _ in range(steps):\n      newDp = [0] * min(steps // 2 + 1, arrLen)\n      for i, ways in enumerate(dp):\n        if ways > 0:\n          for dx in (-1, 0, 1):\n            nextIndex = i + dx\n            if 0 <= nextIndex < len(dp):\n              newDp[nextIndex] += ways\n              newDp[nextIndex] %= MOD\n      dp = newDp\n\n    return dp[0]",
      "title": "1269. Number of Ways to Stay in the Same Place After Some Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4426b1f0-cd90-47f9-9f00-6d8cd0d8fc31",
      "code": "class Solution:\n  def toHexspeak(self, num: str) -> str:\n    s = hex(int(num)).upper()[2:].translate(str.maketrans('01', 'OI'))\n    return 'ERROR' if any(c.isdigit() for c in s) else s",
      "title": "1271. Hexspeak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b011526b-c30c-4e5a-af69-f70ab38e0637",
      "code": "class Solution:\n  def removeInterval(self, intervals: list[list[int]],\n                     toBeRemoved: list[int]) -> list[list[int]]:\n    ans = []\n\n    for a, b in intervals:\n      if a >= toBeRemoved[1] or b <= toBeRemoved[0]:\n        ans.append([a, b])\n      else:  # a < toBeRemoved[1] and b > toBeRemoved[0]\n        if a < toBeRemoved[0]:\n          ans.append([a, toBeRemoved[0]])\n        if b > toBeRemoved[1]:\n          ans.append([toBeRemoved[1], b])\n\n    return ans",
      "title": "1272. Remove Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d388ad19-f47b-4fcd-8bd8-4d0097d162db",
      "code": "# \"\"\"\n# This is Sea's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class Sea(object):\n#   def hasShips(self, topRight: 'Point', bottomLeft: 'Point') -> bool:\n#     pass\n#\n# class Point(object):\n# def __init__(self, x: int, y: int):\n# self.x = x\n# self.y = y\n\nclass Solution(object):\n  def countShips(\n      self,\n      sea: 'Sea',\n      topRight: 'Point',\n      bottomLeft: 'Point',\n  ) -> int:\n    if topRight.x < bottomLeft.x or topRight.y < bottomLeft.y:\n      return 0\n    if not sea.hasShips(topRight, bottomLeft):\n      return 0\n\n    # sea.hashShips(topRight, bottomLeft) == True\n    if topRight.x == bottomLeft.x and topRight.y == bottomLeft.y:\n      return 1\n\n    mx = (topRight.x + bottomLeft.x) // 2\n    my = (topRight.y + bottomLeft.y) // 2\n    ans = 0\n    # the top-right\n    ans += self.countShips(sea, topRight, Point(mx + 1, my + 1))\n    # the bottom-right\n    ans += self.countShips(sea, Point(topRight.x, my),\n                           Point(mx + 1, bottomLeft.y))\n    # the top-left\n    ans += self.countShips(sea, Point(mx, topRight.y),\n                           Point(bottomLeft.x, my + 1))\n    # the bottom-left\n    ans += self.countShips(sea, Point(mx, my), bottomLeft)\n    return ans",
      "title": "1274. Number of Ships in a Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df9963b5-edd8-44fc-8fe0-ffa5682d9129",
      "code": "class Solution:\n  def tictactoe(self, moves: list[list[int]]) -> str:\n    row = [[0] * 3 for _ in range(2)]\n    col = [[0] * 3 for _ in range(2)]\n    diag1 = [0] * 2\n    diag2 = [0] * 2\n    i = 0\n\n    for r, c in moves:\n      row[i][r] += 1\n      col[i][c] += 1\n      diag1[i] += r == c\n      diag2[i] += r + c == 2\n      if 3 in (row[i][r], col[i][c], diag1[i], diag2[i]):\n        return 'A' if i == 0 else 'B'\n      i ^= 1\n\n    return 'Draw' if len(moves) == 9 else 'Pending'",
      "title": "1275. Find Winner on a Tic Tac Toe Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bf0ae16-ac9a-4881-a154-8b125040c6b0",
      "code": "class Solution:\n  def numOfBurgers(self, tomatoSlices: int, cheeseSlices: int) -> list[int]:\n    if tomatoSlices % 2 == 1 or tomatoSlices < 2 * cheeseSlices or tomatoSlices > cheeseSlices * 4:\n      return []\n\n    jumboBurgers = (tomatoSlices - 2 * cheeseSlices) // 2\n\n    return [jumboBurgers, cheeseSlices - jumboBurgers]",
      "title": "1276. Number of Burgers with No Waste of Ingredients",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "575ce6e6-553d-4b91-a98b-10634a97f61c",
      "code": "class Solution:\n  def countSquares(self, matrix: list[list[int]]) -> int:\n    for i in range(len(matrix)):\n      for j in range(len(matrix[0])):\n        if matrix[i][j] == 1 and i > 0 and j > 0:\n          matrix[i][j] += min(matrix[i - 1][j - 1],\n                              matrix[i - 1][j], matrix[i][j - 1])\n    return sum(map(sum, matrix))",
      "title": "1277. Count Square Submatrices with All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a309334-a9c0-4079-9174-2e562b535249",
      "code": "class Solution:\n  def subtractProductAndSum(self, n: int) -> int:\n    prod = 1\n    summ = 0\n\n    while n > 0:\n      prod *= n % 10\n      summ += n % 10\n      n //= 10\n\n    return prod - summ",
      "title": "1281. Subtract the Product and Sum of Digits of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92813d71-6988-4819-aec3-08e94a0a0dfd",
      "code": "class Solution:\n  def groupThePeople(self, groupSizes: list[int]) -> list[list[int]]:\n    ans = []\n    groupSizeToIndices = defaultdict(list)\n\n    for i, groupSize in enumerate(groupSizes):\n      groupSizeToIndices[groupSize].append(i)\n\n    for groupSize, indices in groupSizeToIndices.items():\n      groupIndices = []\n      for index in indices:\n        groupIndices.append(index)\n        if len(groupIndices) == groupSize:\n          ans.append(groupIndices.copy())\n          groupIndices.clear()\n\n    return ans",
      "title": "1282. Group the People Given the Group Size They Belong To",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abfd7f64-2b87-4f57-bef2-8b2e917464f0",
      "code": "class Solution:\n  def smallestDivisor(self, nums: list[int], threshold: int) -> int:\n    l = 1\n    r = max(nums)\n\n    while l < r:\n      m = (l + r) // 2\n      if sum((num - 1) // m + 1 for num in nums) <= threshold:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "1283. Find the Smallest Divisor Given a Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cdf0777-986b-4b22-b263-1e2c54d375cc",
      "code": "class Solution:\n  def minFlips(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    hash = self._getHash(mat, m, n)\n    if hash == 0:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    step = 0\n    q = collections.deque([hash])\n    seen = {hash}\n\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for i in range(m):\n          for j in range(n):\n            next = curr ^ 1 << (i * n + j)\n            # Flie the four neighbors.\n            for dx, dy in DIRS:\n              x = i + dx\n              y = j + dy\n              if x < 0 or x == m or y < 0 or y == n:\n                continue\n              next ^= 1 << (x * n + y)\n            if next == 0:\n              return step\n            if next in seen:\n              continue\n            q.append(next)\n            seen.add(next)\n\n    return -1\n\n  def _getHash(self, mat: list[list[int]], m: int, n: int) -> int:\n    hash = 0\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j]:\n          hash |= 1 << (i * n + j)\n    return hash",
      "title": "1284. Minimum Number of Flips to Convert Binary Matrix to Zero Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c964d8-4f2d-4109-be47-3e335f65b462",
      "code": "class Solution:\n  def findSpecialInteger(self, arr: list[int]) -> int:\n    n = len(arr)\n    quarter = n // 4\n\n    for i in range(n - quarter):\n      if arr[i] == arr[i + quarter]:\n        return arr[i]",
      "title": "1287. Element Appearing More Than 25% In Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8e0d3ce-80cf-47cd-88f9-9763f342ce15",
      "code": "class Solution:\n  def removeCoveredIntervals(self, intervals: list[list[int]]) -> int:\n    ans = 0\n    prevEnd = 0\n\n    for _, end in sorted(intervals, key=lambda x: (x[0], -x[1])):\n      # The current interval is not covered by the previous one.\n      if prevEnd < end:\n        prevEnd = end\n        ans += 1\n\n    return ans",
      "title": "1288. Remove Covered Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8525a71-4710-4450-8fe9-c3bb4b4f7836",
      "code": "class Solution:\n  def minFallingPathSum(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n\n    for i in range(1, n):\n      (firstMinNum, firstMinIndex), (secondMinNum, _) = sorted(\n          {(a, i) for i, a in enumerate(grid[i - 1])})[:2]\n      for j in range(n):\n        if j == firstMinIndex:\n          grid[i][j] += secondMinNum\n        else:\n          grid[i][j] += firstMinNum\n\n    return min(grid[-1])",
      "title": "1289. Minimum Falling Path Sum II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}