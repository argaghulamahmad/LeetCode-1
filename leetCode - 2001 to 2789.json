{
  "snippets": [
    {
      "id": "a9943021-86d8-4348-8739-1db4afda82a6",
      "code": "class Solution:\n  def minimumTime(self, grid: list[list[int]]) -> int:\n    if grid[0][1] > 1 and grid[1][0] > 1:\n      return -1\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(0, 0, 0)]  # (time, i, j)\n    seen = {(0, 0)}\n\n    while minHeap:\n      time, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return time\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        extraWait = 1 if (grid[x][y] - time) % 2 == 0 else 0\n        nextTime = max(time + 1, grid[x][y] + extraWait)\n        heapq.heappush(minHeap, (nextTime, x, y))\n        seen.add((x, y))",
      "title": "2577. Minimum Time to Visit a Cell In a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9627ff04-c32b-409b-aa7a-ec4268f32046",
      "code": "class Solution:\n  def splitNum(self, num: int) -> int:\n    s = ''.join(sorted(str(num)))\n    return sum(map(int, (s[::2], s[1::2])))",
      "title": "2578. Split With Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c7d8899-9c44-4797-82c5-6db9d3d61b5b",
      "code": "class Solution:\n  def coloredCells(self, n: int) -> int:\n    return n**2 + (n - 1)**2",
      "title": "2579. Count Total Number of Colored Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee23e070-e717-4514-a6a4-ff8d255c6797",
      "code": "class Solution:\n  def countWays(self, ranges: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevEnd = -1\n\n    for start, end in sorted(ranges):\n      if start > prevEnd:\n        ans = ans * 2 % MOD\n      prevEnd = max(prevEnd, end)\n\n    return ans",
      "title": "2580. Count Ways to Group Overlapping Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4031e85d-2e24-47f7-9dea-04ff11efd4a1",
      "code": "class Solution:\n  def rootCount(\n      self,\n      edges: list[list[int]],\n      guesses: list[list[int]],\n      k: int,\n  ) -> int:\n    ans = 0\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n    guessGraph = [set() for _ in range(n)]\n    parent = [0] * n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for u, v in guesses:\n      guessGraph[u].add(v)\n\n    def dfs(u: int, prev: int) -> None:\n      parent[u] = prev\n      for v in graph[u]:\n        if v != prev:\n          dfs(v, u)\n\n    # Precalculate `parent`.\n    dfs(0, -1)\n\n    # Calculate `correctGuess` for tree rooted at 0.\n    correctGuess = sum(i in guessGraph[parent[i]] for i in range(1, n))\n\n    def reroot(u: int, prev: int, correctGuess: int) -> None:\n      nonlocal ans\n      if u != 0:\n        # The tree is rooted at u, so a guess edge (u, prev) will match the new\n        # `parent` relationship.\n        if prev in guessGraph[u]:\n          correctGuess += 1\n        # A guess edge (prev, u) matching the old `parent` relationship will no\n        # longer be True.\n        if u in guessGraph[prev]:\n          correctGuess -= 1\n      if correctGuess >= k:\n        ans += 1\n      for v in graph[u]:\n        if v != prev:\n          reroot(v, u, correctGuess)\n\n    reroot(0, -1, correctGuess)\n    return ans",
      "title": "2581. Count Number of Possible Root Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "592ca4c2-6b2e-418e-9a12-d411daf7d49d",
      "code": "class Solution:\n  def passThePillow(self, n: int, time: int) -> int:\n    # Repeat every (n - 1) * 2 seconds.\n    time %= (n - 1) * 2\n    if time < n:  # Go forward from 1.\n      return 1 + time\n    return n - (time - (n - 1))  # Go backward from n.",
      "title": "2582. Pass the Pillow",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b432bd1c-7a0f-4aec-b53b-4b7493fa4cfa",
      "code": "class Solution:\n  def kthLargestLevelSum(self, root: TreeNode | None, k: int) -> int:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    dfs(root, 0)\n    if len(levelSums) < k:\n      return -1\n\n    return sorted(levelSums, reverse=True)[k - 1]",
      "title": "2583. Kth Largest Sum in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90f34275-6071-4592-ae1c-87064ecb629e",
      "code": "class Solution:\n  def findValidSplit(self, nums: list[int]) -> int:\n    leftPrimeFactors = collections.Counter()\n    rightPrimeFactors = collections.Counter()\n\n    def getPrimeFactors(num: int) -> list[int]:\n      \"\"\"Gets the prime factors under sqrt(10^6).\"\"\"\n      primeFactors = []\n      for divisor in range(2, min(1000, num) + 1):\n        if num % divisor == 0:\n          primeFactors.append(divisor)\n          while num % divisor == 0:\n            num //= divisor\n      # Handle the case that `num` contains a prime factor > 1000.\n      if num > 1:\n        primeFactors.append(num)\n      return primeFactors\n\n    for num in nums:\n      for primeFactor in getPrimeFactors(num):\n        rightPrimeFactors[primeFactor] += 1\n\n    for i in range(len(nums) - 1):\n      for primeFactor in getPrimeFactors(nums[i]):\n        rightPrimeFactors[primeFactor] -= 1\n        if rightPrimeFactors[primeFactor] == 0:\n          # rightPrimeFactors[primeFactor] == 0, so no need to track\n          # leftPrimeFactors[primeFactor].\n          del rightPrimeFactors[primeFactor]\n          del leftPrimeFactors[primeFactor]\n        else:\n          # Otherwise, need to track leftPrimeFactors[primeFactor].\n          leftPrimeFactors[primeFactor] += 1\n      if not leftPrimeFactors:\n        return i\n\n    return -1",
      "title": "2584. Split the Array to Make Coprime Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23c2f519-313e-4b10-8939-d2bb1f15499b",
      "code": "class Solution:\n  def waysToReachTarget(self, target: int, types: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j] := the number of ways to earn j points with the first i types\n    dp = [[0] * (target + 1) for _ in range(len(types) + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, len(types) + 1):\n      count = types[i - 1][0]\n      mark = types[i - 1][1]\n      for j in range(target + 1):\n        for solved in range(count + 1):\n          if j - solved * mark >= 0:\n            dp[i][j] += dp[i - 1][j - solved * mark]\n            dp[i][j] %= MOD\n\n    return dp[len(types)][target]",
      "title": "2585. Number of Ways to Earn Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c83be395-6f87-4198-bfd6-91358b923bcd",
      "code": "class Solution:\n  def vowelStrings(self, words: list[str], left: int, right: int) -> int:\n    VOWELS = 'aeiou'\n    return sum(word[0] in VOWELS and word[-1] in VOWELS\n               for word in words[left:right + 1])",
      "title": "2586. Count the Number of Vowel Strings in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb361131-9825-489c-acd7-a10fdd707918",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    return sum(num > 0\n               for num in itertools.accumulate(sorted(nums, reverse=True)))",
      "title": "2587. Rearrange Array to Maximize Prefix Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc092284-b2c7-47ac-bacd-963ce87736c4",
      "code": "class Solution:\n  def beautifulSubarrays(self, nums: list[int]) -> int:\n    # A subarray is beautiful if xor(subarray) = 0.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      prefix ^= num\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2588. Count the Number of Beautiful Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ba01cf5-935e-41fc-95dc-e0fc430157eb",
      "code": "class Solution:\n  def findMinimumTime(self, tasks: list[list[int]]) -> int:\n    MAX = 2000\n    running = [False] * (MAX + 1)\n\n    # Sort tasks by end.\n    for start, end, duration in sorted(tasks, key=lambda x: x[1]):\n      neededDuration = (duration -\n                        sum(running[i] for i in range(start, end + 1)))\n      # Greedily run the task as late as possible so that later tasks can run\n      # simultaneously.\n      i = end\n      while neededDuration > 0:\n        if not running[i]:\n          running[i] = True\n          neededDuration -= 1\n        i -= 1\n\n    return sum(running)",
      "title": "2589. Minimum Time to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc840f9f-72b6-4b11-8139-9863a224e43e",
      "code": "class Solution:\n  def distMoney(self, money: int, children: int) -> int:\n    # Everyone must receive at least 1 dollar.\n    money -= children\n    if money < 0:\n      return -1\n\n    count7 = money // 7\n    remaining = money % 7\n\n    # Distribute 8 dollars to every child.\n    if count7 == children and remaining == 0:\n      return count7\n\n    # Need to move 1 dollar from the last child with 4 dollars to one of other\n    # children. That's why we need to substract 1.\n    if count7 == children - 1 and remaining == 3:\n      return count7 - 1\n\n    # Though there might be child with 4 dollars, since count7 < children - 1,\n    # we have 'extra' spot to move money to if needed.\n    return min(children - 1, count7)",
      "title": "2591. Distribute Money to Maximum Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54eb672f-33f7-4d8f-83f1-888e3286a90a",
      "code": "class Solution:\n  def maximizeGreatness(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for num in nums:\n      if num > nums[ans]:\n        ans += 1\n\n    return ans",
      "title": "2592. Maximize Greatness of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "721eaeea-9fb6-4a2d-a4cb-4873a0ffd92f",
      "code": "class Solution:\n  def findScore(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n\n    for num, i in sorted([(num, i) for i, num in enumerate(nums)]):\n      if i in seen:\n        continue\n      seen.add(i - 1)\n      seen.add(i + 1)\n      seen.add(i)\n      ans += num\n\n    return ans",
      "title": "2593. Find Score of an Array After Marking All Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1c93ff7-4f2b-4db3-bbe6-67e819a567c6",
      "code": "class Solution:\n  def repairCars(self, ranks: list[int], cars: int) -> int:\n    def numCarsFixed(minutes: int) -> int:\n      #    r * n^2 = minutes\n      # -> n = sqrt(minutes / r)\n      return sum(math.isqrt(minutes // rank) for rank in ranks)\n\n    return bisect.bisect_left(range(min(ranks) * cars**2), cars,\n                              key=numCarsFixed)",
      "title": "2594. Minimum Time to Repair Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "649f47c1-a33b-4ff2-aa6f-97c8ee85784b",
      "code": "class Solution:\n  def evenOddBit(self, n: int) -> list[int]:\n    ans = [0] * 2\n    i = 0  # 0 := even, 1 := odd\n\n    while n > 0:\n      ans[i] += n & 1\n      n >>= 1\n      i ^= 1\n\n    return ans",
      "title": "2595. Number of Even and Odd Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1497bc30-a0f4-422a-bef3-af95814087b1",
      "code": "class Solution:\n  def checkValidGrid(self, grid: list[list[int]]) -> bool:\n    if grid[0][0] != 0:\n      return False\n\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    n = len(grid)\n    i = 0\n    j = 0\n\n    def nextGrid(i: int, j: int, target: int) -> tuple[int, int]:\n      \"\"\"\n      Returns (x, y), where grid[x][y] == target if (i, j) can reach target.\n      \"\"\"\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x >= n or y < 0 or y >= n:\n          continue\n        if grid[x][y] == target:\n          return (x, y)\n      return (-1, -1)\n\n    for target in range(1, n * n):\n      x, y = nextGrid(i, j, target)\n      if x == -1 and y == -1:\n        return False\n      # Move (x, y) to (i, j).\n      i = x\n      j = y\n\n    return True",
      "title": "2596. Check Knight Tour Configuration",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6a6890e-04bb-4bc6-b623-cf70f86322f1",
      "code": "# e.g. nums = [2, 3, 4, 4], k = 2\n#\n# subset[0] = [2, 4, 4']\n# subset[1] = [1]\n# count = {2: 1, 4: 2, 1: 1}\n#\n# Initially, skip = len([]) = 0, pick = len([]) = 0\n#\n# * For values in subset[0]:\n#   After 2:\n#     skip = skip + pick = len([]) = 0\n#     pick = (2^count[2] - 1) * (1 + skip + pick)\n#          = len([[2]]) * len([[]])\n#          = len([[2]]) = 1\n#   After 4:\n#     skip = skip + pick = len([[2]]) = 1\n#     pick = (2^count[4] - 1) * (1 + skip)\n#          = len([[4], [4'], [4, 4']]) * len([[]])\n#          = len([[4], [4'], [4, 4']]) = 3\n#\n# * For values in subset[1]:\n#   After 1:\n#     skip = skip + pick\n#          = len([[2], [4], [4'], [4, 4']]) = 4\n#     pick = (2^count[1] - 1) * (1 + skip + pick)\n#          = len([[1]]) * len([[], [2], [4], [4'], [4, 4']])\n#          = len([[1], [1, 2], [1, 4], [1, 4'], [1, 4, 4']]) = 5\n#\n# So, ans = skip + pick = 9\n\nclass Solution:\n  def beautifulSubsets(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        nonEmptyCount = 2**count[num] - 1\n        skip, pick = (skip + pick,\n                      nonEmptyCount *\n                      (1 + skip + (0 if num - prevNum == k else pick)))\n        prevNum = num\n\n    return skip + pick",
      "title": "2597. The Number of Beautiful Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11466b80-1d98-431d-a591-7824a617ae3f",
      "code": "class Solution:\n  def findSmallestInteger(self, nums: list[int], value: int) -> int:\n    count = collections.Counter([num % value for num in nums])\n\n    for i in range(len(nums)):\n      if count[i % value] == 0:\n        return i\n      count[i % value] -= 1\n\n    return len(nums)",
      "title": "2598. Smallest Missing Non-negative Integer After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7e058ab-eb1d-433b-bf2c-1ed6d6d9f4a2",
      "code": "class Solution:\n  def makePrefSumNonNegative(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    minHeap = []\n\n    for num in nums:\n      prefix += num\n      if num < 0:\n        heapq.heappush(minHeap, num)\n      while prefix < 0:\n        prefix -= heapq.heappop(minHeap)\n        ans += 1\n\n    return ans",
      "title": "2599. Make the Prefix Sum Non-negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c2d4666-c4c7-4114-b0d1-3132e6e6a4b2",
      "code": "class Solution:\n  def kItemsWithMaximumSum(\n      self,\n      numOnes: int,\n      numZeros: int,\n      numNegOnes: int,\n      k: int,\n  ) -> int:\n    if k <= numOnes:\n      return k\n    if k <= numOnes + numZeros:\n      return numOnes\n    return numOnes - (k - numOnes - numZeros)",
      "title": "2600. K Items With the Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b976b19-68c9-403e-8778-7859f6d61a4a",
      "code": "class Solution:\n  def primeSubOperation(self, nums: list[int]) -> bool:\n    MAX = 1000\n    primes = self._sieveEratosthenes(MAX)\n\n    prevNum = 0\n    for num in nums:\n      # Make nums[i] the smallest as possible and still > nums[i - 1].\n      i = bisect.bisect_left(primes, num - prevNum)\n      if i > 0:\n        num -= primes[i - 1]\n      if num <= prevNum:\n        return False\n      prevNum = num\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return [i for i in range(n) if isPrime[i]]",
      "title": "2601. Prime Subtraction Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b09c540-9acb-4be1-9463-5cac174d129a",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    prefix = list(itertools.accumulate(nums, initial=0))\n    splits = [(query, bisect.bisect_right(nums, query)) for query in queries]\n    return [(query * i - prefix[i]) +\n            (prefix[-1] - prefix[i] - query * (n - i))\n            for query, i in splits]",
      "title": "2602. Minimum Operations to Make All Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "595d0146-aa4a-4086-a117-b49c2aecd268",
      "code": "class Solution:\n  def collectTheCoins(self, coins: list[int], edges: list[list[int]]) -> int:\n    n = len(coins)\n    tree = [set() for _ in range(n)]\n    leavesToBeRemoved = collections.deque()\n\n    for u, v in edges:\n      tree[u].add(v)\n      tree[v].add(u)\n\n    for u in range(n):\n      # Remove the leaves that don't have coins.\n      while len(tree[u]) == 1 and coins[u] == 0:\n        v = tree[u].pop()\n        tree[v].remove(u)\n        u = v  # Walk up to its parent.\n      # After trimming leaves without coins, leaves with coins may satisfy\n      # `leavesToBeRemoved`.\n      if len(tree[u]) == 1:  # coins[u] must be 1.\n        leavesToBeRemoved.append(u)\n\n    # Remove each remaining leaf node and its parent. The remaining nodes are\n    # the ones that must be visited.\n    for _ in range(2):\n      for _ in range(len(leavesToBeRemoved)):\n        u = leavesToBeRemoved.popleft()\n        if tree[u]:\n          v = tree[u].pop()\n          tree[v].remove(u)\n          if len(tree[v]) == 1:  # It's a leaf.\n            leavesToBeRemoved.append(v)\n\n    return sum(len(children) for children in tree)",
      "title": "2603. Collect Coins in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90249a3e-1d49-4667-a15a-6d184ba71b26",
      "code": "class Solution:\n  def minimumTime(self, hens: list[int], grains: list[int]) -> int:\n    hens.sort()\n    grains.sort()\n\n    def canEat(time: int) -> bool:\n      \"\"\"Returns True if `hens` can eat all `grains` within `time`.\"\"\"\n      i = 0  # grains[i] := next grain to be ate\n      for hen in hens:\n        rightMoves = time\n        if grains[i] < hen:\n          # `hen` needs go back to eat `grains[i]`.\n          leftMoves = hen - grains[i]\n          if leftMoves > time:\n            return False\n          leftThenRight = time - 2 * leftMoves\n          rightThenLeft = (time - leftMoves) // 2\n          rightMoves = max(0, leftThenRight, rightThenLeft)\n        i = bisect.bisect_right(grains, hen + rightMoves)\n        if i == len(grains):\n          return True\n      return False\n\n    maxMoves = int(1.5 * (max(hens + grains) - min(hens + grains)))\n    return bisect.bisect_left(range(maxMoves), True, key=canEat)",
      "title": "2604. Minimum Time to Eat All Grains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12d0a608-6bc0-42ec-8e19-b61c4ebf82e5",
      "code": "class Solution:\n  def minNumber(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(a if a == b else min(a, b) * 10 + max(a, b)\n               for a in nums1\n               for b in nums2)",
      "title": "2605. Form Smallest Number From Two Digit Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2ae6af8-ae21-4e2c-a775-ad76ccf8d8fa",
      "code": "class Solution:\n  def maximumCostSubstring(self, s: str, chars: str, vals: list[int]) -> int:\n    ans = 0\n    cost = 0\n    costs = [i for i in range(1, 27)]  # costs[i] := the cost of 'a' + i\n\n    for c, val in zip(chars, vals):\n      costs[ord(c) - ord('a')] = val\n\n    for c in s:\n      cost = max(0, cost + costs[ord(c) - ord('a')])\n      ans = max(ans, cost)\n\n    return ans",
      "title": "2606. Find the Substring With Maximum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e428951d-86f8-45d2-8352-d378acd0549a",
      "code": "class Solution:\n  def makeSubKSumEqual(self, arr: list[int], k: int) -> int:\n    # If the sum of each subarray of length k is equal, then `arr` must have a\n    # repeated pattern of size k. e.g. arr = [1, 2, 3, ...] and k = 3, to have\n    # sum([1, 2, 3)] == sum([2, 3, x]), x must be 1. Therefore, arr[i] ==\n    # arr[(i + k) % n] for every i.\n    n = len(arr)\n    ans = 0\n    seen = [0] * n\n\n    for i in range(n):\n      groups = []\n      j = i\n      while not seen[j]:\n        groups.append(arr[j])\n        seen[j] = True\n        j = (j + k) % n\n      groups.sort()\n      for num in groups:\n        ans += abs(num - groups[len(groups) // 2])\n\n    return ans",
      "title": "2607. Make K-Subarray Sums Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c32ad40f-904d-4ac1-8821-9510ed6fdfb8",
      "code": "class Solution:\n  def findShortestCycle(self, n: int, edges: list[list[int]]) -> int:\n    INF = 1001\n    ans = INF\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def bfs(i: int) -> int:\n      \"\"\"Returns the length of the minimum cycle by starting BFS from node `i`.\n\n      Returns `INF` if there's no cycle.\n      \"\"\"\n      dist = [INF] * n\n      q = collections.deque([i])\n      dist[i] = 0\n      while q:\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == INF:\n            dist[v] = dist[u] + 1\n            q.append(v)\n          elif dist[v] + 1 != dist[u]:   # v is not a parent u.\n            return dist[v] + dist[u] + 1\n      return INF\n\n    ans = min(map(bfs, range(n)))\n    return -1 if ans == INF else ans",
      "title": "2608. Shortest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d98121d-2d4a-41fe-be45-d29b5d7adcd6",
      "code": "class Solution:\n  def findTheLongestBalancedSubstring(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      zeros = 0\n      ones = 0\n      while i < len(s) and s[i] == '0':\n        zeros += 1\n        i += 1\n      while i < len(s) and s[i] == '1':\n        ones += 1\n        i += 1\n      ans = max(ans, min(zeros, ones))\n\n    return ans * 2",
      "title": "2609. Find the Longest Balanced Substring of a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47540508-bca7-4983-9dc0-4030f27142ec",
      "code": "class Solution:\n  def findMatrix(self, nums: list[int]) -> list[list[int]]:\n    # The number of rows we need equals the maximum frequency.\n    ans = []\n    count = [0] * (len(nums) + 1)\n\n    for num in nums:\n      count[num] += 1\n      # Construct `ans` on demand.\n      if count[num] > len(ans):\n        ans.append([])\n      ans[count[num] - 1].append(num)\n\n    return ans",
      "title": "2610. Convert an Array Into a 2D Array With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d78bf9d-b275-4eb1-a4c8-81cefbad26d7",
      "code": "class Solution:\n  def miceAndCheese(\n      self,\n      reward1: list[int],\n      reward2: list[int],\n      k: int,\n  ) -> int:\n    return (sum(reward2) +\n            sum(heapq.nlargest(k, (a - b for a, b in zip(reward1, reward2)))))",
      "title": "2611. Mice and Cheese",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0036f850-490e-482d-933c-cd7fcba74cbf",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minReverseOperations(\n      self,\n      n: int,\n      p: int,\n      banned: list[int],\n      k: int,\n  ) -> list[int]:\n    bannedSet = set(banned)\n    ans = [-1] * n\n    # unseen[i] := the unseen numbers that % 2 == i\n    unseen = [SortedList(), SortedList()]\n\n    for num in range(n):\n      if num != p and num not in bannedSet:\n        unseen[num % 2].add(num)\n\n    # Perform BFS from `p`.\n    q = collections.deque([p])\n    ans[p] = 0\n\n    while q:\n      u = q.popleft()\n      lo = max(u - k + 1, k - 1 - u)\n      hi = min(u + k - 1, n - 1 - (u - (n - k)))\n      # Choose the correct set of numbers.\n      nums = unseen[lo % 2]\n      i = nums.bisect_left(lo)\n      while i < len(nums) and nums[i] <= hi:\n        num = nums[i]\n        ans[num] = ans[u] + 1\n        q.append(num)\n        nums.pop(i)\n\n    return ans",
      "title": "2612. Minimum Reverse Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96cf3208-c31a-4920-974b-4d2cba73f3ff",
      "code": "class Solution:\n  def diagonalPrime(self, nums: list[list[int]]) -> int:\n    def isPrime(n: int) -> bool:\n      if n <= 1:\n        return False\n      for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n          return False\n      return True\n\n    primes1 = [row[i]\n               for i, row in enumerate(nums) if isPrime(row[i])]\n    primes2 = [row[-1 - i]\n               for i, row in enumerate(nums) if isPrime(row[-1 - i])]\n    return max(max(primes1) if primes1 else 0,\n               max(primes2) if primes2 else 0)",
      "title": "2614. Prime In Diagonal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "739c8081-cd27-47a9-96c1-789103df610b",
      "code": "class Solution:\n  def distance(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      n = len(indices)\n      if n == 1:\n        continue\n      sumSoFar = sum(indices)\n      prevIndex = 0\n      for i in range(n):\n        sumSoFar += (i - 1) * (indices[i] - prevIndex)\n        sumSoFar -= (n - 1 - i) * (indices[i] - prevIndex)\n        ans[indices[i]] = sumSoFar\n        prevIndex = indices[i]\n\n    return ans",
      "title": "2615. Sum of Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ddf2fd1-1255-4859-9710-b43798bbe920",
      "code": "class Solution:\n  def minimizeMax(self, nums: list[int], p: int) -> int:\n    nums.sort()\n\n    def numPairs(maxDiff: int) -> int:\n      \"\"\"\n      Returns the number of pairs that can be obtained if the difference between\n      each pair <= `maxDiff`.\n      \"\"\"\n      pairs = 0\n      i = 1\n      while i < len(nums):\n        # Greedily pair nums[i] with nums[i - 1].\n        if nums[i] - nums[i - 1] <= maxDiff:\n          pairs += 1\n          i += 2\n        else:\n          i += 1\n      return pairs\n\n    return bisect.bisect_left(range(nums[-1] - nums[0]), p, key=numPairs)",
      "title": "2616. Minimize the Maximum Difference of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25651aef-48e1-41bb-8c66-b4b893f02b3c",
      "code": "class Solution:\n  def countTheNumOfKFreeSubsets(self, nums: list[int], k: int) -> int:\n    modToSubset = collections.defaultdict(set)\n\n    for num in nums:\n      modToSubset[num % k].add(num)\n\n    prevNum = -k\n    skip = 0\n    pick = 0\n\n    for subset in modToSubset.values():\n      for num in sorted(subset):\n        skip, pick = (skip + pick,\n                      1 + skip + (0 if num - prevNum == k else pick))\n        prevNum = num\n\n    return 1 + skip + pick",
      "title": "2638. Count the Number of K-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f2d0cf6-2b6d-4cb1-9da6-c335ddec07ba",
      "code": "class Solution:\n  def findColumnWidth(self, grid: list[list[int]]) -> list[int]:\n    return [max(map(len, map(str, col))) for col in zip(*grid)]",
      "title": "2639. Find the Width of Columns of a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3565aac8-28de-4f5c-90fd-f6b73f9f9745",
      "code": "class Solution:\n  def findPrefixScore(self, nums: list[int]) -> list[int]:\n    conver = []\n    mx = 0\n\n    for num in nums:\n      mx = max(mx, num)\n      conver.append(num + mx)\n\n    return itertools.accumulate(conver)",
      "title": "2640. Find the Score of All Prefixes of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7147989b-8b3e-41b5-8ffb-42b387a3f371",
      "code": "class Solution:\n  def replaceValueInTree(self, root: TreeNode | None) -> TreeNode | None:\n    levelSums = []\n\n    def dfs(root: TreeNode | None, level: int) -> None:\n      if not root:\n        return\n      if len(levelSums) == level:\n        levelSums.append(0)\n      levelSums[level] += root.val\n      dfs(root.left, level + 1)\n      dfs(root.right, level + 1)\n\n    def replace(\n        root: TreeNode | None,\n        level: int, curr: TreeNode | None,\n    ) -> TreeNode | None:\n      nextLevel = level + 1\n      nextLevelCousinsSum = (\n          (levelSums[nextLevel] if nextLevel < len(levelSums) else 0) -\n          (root.left.val if root.left else 0) -\n          (root.right.val if root.right else 0))\n      if root.left:\n        curr.left = TreeNode(nextLevelCousinsSum)\n        replace(root.left, level + 1, curr.left)\n      if root.right:\n        curr.right = TreeNode(nextLevelCousinsSum)\n        replace(root.right, level + 1, curr.right)\n      return curr\n\n    dfs(root, 0)\n    return replace(root, 0, TreeNode(0))",
      "title": "2641. Cousins in Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6e16326-94a7-4af4-962d-874ee1791b3d",
      "code": "class Solution:\n  def rowAndMaximumOnes(self, mat: list[list[int]]) -> list[int]:\n    ans = [0, 0]\n\n    for i, row in enumerate(mat):\n      ones = row.count(1)\n      if ones > ans[1]:\n        ans[0] = i\n        ans[1] = ones\n\n    return ans",
      "title": "2643. Row With Maximum Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f3a6dcd-9263-4c73-a1fa-98749609ccb0",
      "code": "class Solution:\n  def maxDivScore(self, nums: list[int], divisors: list[int]) -> int:\n    ans = -1\n    maxScore = -1\n\n    for divisor in divisors:\n      score = sum([1 for num in nums if num % divisor == 0])\n      if score > maxScore:\n        ans = divisor\n        maxScore = score\n      elif score == maxScore:\n        ans = min(ans, divisor)\n\n    return ans",
      "title": "2644. Find the Maximum Divisibility Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "058f1ee3-1a18-4340-a9d6-7342a3c8bd1c",
      "code": "class Solution:\n  def addMinimum(self, word: str) -> int:\n    letters = ['a', 'b', 'c']\n    ans = 0\n    i = 0\n\n    while i < len(word):\n      for c in letters:\n        if i < len(word) and word[i] == c:\n          i += 1\n        else:\n          ans += 1\n\n    return ans",
      "title": "2645. Minimum Additions to Make Valid String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f12f404-ed52-4bab-8be8-16243f151b4c",
      "code": "class Solution:\n  def minimumTotalPrice(self, n: int, edges: list[list[int]], price: list[int],\n                        trips: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # count[i] := the number of times i is traversed\n    count = [0] * n\n\n    def dfsCount(u: int, prev: int, end: int, path: list[int]) -> None:\n      path.append(u)\n      if u == end:\n        for i in path:\n          count[i] += 1\n        return\n      for v in graph[u]:\n        if v != prev:\n          dfsCount(v, u, end,  path)\n      path.pop()\n\n    for start, end in trips:\n      dfsCount(start, -1, end, [])\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, parentHalved: bool) -> int:\n      \"\"\"\n      Returns the minimum price sum for the i-th node, where its parent is\n      halved parent or not halved not.\n      \"\"\"\n      sumWithFullNode = price[u] * count[u] + sum(dfs(v, u, False)\n                                                  for v in graph[u]\n                                                  if v != prev)\n      if parentHalved:  # Can't halve this node if its parent was halved.\n        return sumWithFullNode\n      sumWithHalvedNode = (price[u] // 2) * count[u] + sum(dfs(v, u, True)\n                                                           for v in graph[u]\n                                                           if v != prev)\n      return min(sumWithFullNode, sumWithHalvedNode)\n\n    return dfs(0, -1, False)",
      "title": "2646. Minimize the Total Price of the Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bf5c1f0-2b2c-4b28-9ca7-77f98cca40b4",
      "code": "class Solution:\n  def colorRed(self, n: int) -> list[list[int]]:\n    ans = []\n    tipSize = n % 4\n\n    # The tip of the triangle is always painted red.\n    if tipSize >= 1:\n      ans.append([1, 1])\n\n    # Pamost right and most left elements at the following rows.\n    for i in range(2, tipSize + 1):\n      ans.append([i, 1])\n      ans.append([i, 2 * i - 1])\n\n    # Pa4-row chunks.\n    for i in range(tipSize + 1, n, 4):\n      # Fill the first row of the chunk.\n      ans.append([i, 1])\n      # Fill the second row.\n      for j in range(1, i + 1):\n        ans.append([i + 1, 2 * j + 1])\n      # Fill the third row.\n      ans.append([i + 2, 2])\n      # Fill the fourth row.\n      for j in range(i + 2 + 1):\n        ans.append([i + 3, 2 * j + 1])\n\n    return ans",
      "title": "2647. Color the Triangle Red",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd938f56-f2ff-427a-90a3-56304fdf0c2b",
      "code": "class Solution:\n  def findDelayedArrivalTime(self, arrivalTime: int, delayedTime: int) -> int:\n    return (arrivalTime + delayedTime) % 24",
      "title": "2651. Calculate Delayed Arrival Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c58eef6-7df7-4413-8413-0bc54778f364",
      "code": "class Solution:\n  def sumOfMultiples(self, n: int) -> int:\n    def sumOfMultiples(value: int) -> int:\n      \"\"\"Returns the sum of multiples of value in [1, n].\"\"\"\n      lo = value\n      hi = (n // value) * value\n      count = (hi - lo) // value + 1\n      return (lo + hi) * count // 2\n\n    return (sumOfMultiples(3) + sumOfMultiples(5) + sumOfMultiples(7) -\n            (sumOfMultiples(15) + sumOfMultiples(21) + sumOfMultiples(35)) +\n            sumOfMultiples(105))",
      "title": "2652. Sum Multiples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4dcc70b-ae96-4b28-b5f8-fbf8100947f0",
      "code": "class Solution:\n  def getSubarrayBeauty(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    count = [0] * 50  # count[i] := the frequency of (i + 50)\n\n    for i, num in enumerate(nums):\n      if num < 0:\n        count[num + 50] += 1\n      if i - k >= 0 and nums[i - k] < 0:\n        count[nums[i - k] + 50] -= 1\n      if i + 1 >= k:\n        ans.append(self._getXthSmallestNum(count, x))\n\n    return ans\n\n  def _getXthSmallestNum(self, count: list[int], x: int) -> int:\n    prefix = 0\n    for i in range(50):\n      prefix += count[i]\n      if prefix >= x:\n        return i - 50\n    return 0",
      "title": "2653. Sliding Subarray Beauty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "294f6ff7-c135-49e8-80bb-b1a5e2abbb52",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ones = nums.count(1)\n    if ones > 0:\n      return n - ones\n\n    # the minimum operations to make the shortest subarray with a gcd == 1\n    minOps = math.inf\n\n    for i, g in enumerate(nums):\n      for j in range(i + 1, n):\n        g = math.gcd(g, nums[j])\n        if g == 1:   # gcd(nums[i..j]:== 1\n          minOps = min(minOps, j - i)\n          break\n\n    # After making the shortest subarray with `minOps`, need additional n - 1\n    # operations to make the other numbers to 1.\n    return -1 if minOps == math.inf else minOps + n - 1",
      "title": "2654. Minimum Number of Operations to Make All Array Elements Equal to 1",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4435298c-bdf9-4237-86e5-a8a251b8580d",
      "code": "class Solution:\n  def findMaximalUncoveredRanges(self, n: int, ranges: list[list[int]]) -> list[list[int]]:\n    ans = []\n    start = 0\n\n    for l, r in sorted(ranges):\n      if start < l:\n        ans.append([start, l - 1])\n      if start <= r:\n        start = r + 1\n\n    if start < n:\n      ans.append([start, n - 1])\n\n    return ans",
      "title": "2655. Find Maximal Uncovered Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b07b31eb-e430-4fe5-9a02-431f5e5dea74",
      "code": "class Solution:\n  def maximizeSum(self, nums: list[int], k: int) -> int:\n    return max(nums) * k + k * (k - 1) // 2",
      "title": "2656. Maximum Sum With Exactly K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "111e5ea9-e3e6-4cb0-b4ce-2c258c28cf43",
      "code": "class Solution:\n  def findThePrefixCommonArray(self, A: list[int], B: list[int]) -> list[int]:\n    n = len(A)\n    prefixCommon = 0\n    ans = []\n    count = [0] * (n + 1)\n\n    for a, b in zip(A, B):\n      count[a] += 1\n      if count[a] == 2:\n        prefixCommon += 1\n      count[b] += 1\n      if count[b] == 2:\n        prefixCommon += 1\n      ans.append(prefixCommon)\n\n    return ans",
      "title": "2657. Find the Prefix Common Array of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b1b4107-14c2-4213-8c14-e193b903c974",
      "code": "class Solution:\n  def findMaxFish(self, grid: list[list[int]]) -> int:\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] == 0:\n        return 0\n      caughtFish = grid[i][j]\n      grid[i][j] = 0  # Mark 0 as visited\n      return (caughtFish +\n              dfs(i + 1, j) + dfs(i - 1, j) +\n              dfs(i, j + 1) + dfs(i, j - 1))\n\n    return max(dfs(i, j)\n               for i in range(len(grid))\n               for j in range(len(grid[0])))",
      "title": "2658. Maximum Number of Fish in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0251088b-3c0a-46d3-aad1-d873badf24f9",
      "code": "class Solution:\n  def countOperationsToEmptyArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndex = {}\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    nums.sort()\n\n    for i in range(1, n):\n      # On the i-th step we've already removed the i - 1 smallest numbers and\n      # can ignore them. If an element nums[i] has smaller index in origin\n      # array than nums[i - 1], we should rotate the whole left array n - i\n      # times to set nums[i] element on the first position.\n      if numToIndex[nums[i]] < numToIndex[nums[i - 1]]:\n        ans += n - i\n\n    return ans",
      "title": "2659. Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54b0ae0c-59e6-4339-8932-775137dd3d4c",
      "code": "class Solution:\n  def isWinner(self, player1: list[int], player2: list[int]) -> int:\n    def getScore(player: list[int]) -> int:\n      INVALID = -3\n      score = 0\n      last10 = INVALID\n      for i, p in enumerate(player):\n        score += p if i - last10 > 2 else p * 2\n        if p == 10:\n          last10 = i\n      return score\n\n    score1 = getScore(player1)\n    score2 = getScore(player2)\n    if score1 > score2:\n      return 1\n    if score2 > score1:\n      return 2\n    return 0",
      "title": "2660. Determine the Winner of a Bowling Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb15656f-803a-4c8f-ae21-7a1dcb0c9ae5",
      "code": "class Solution:\n  def firstCompleteIndex(self, arr: list[int], mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    # rows[i] := the number of painted grid in the i-th row\n    rows = [0] * m\n    # cols[j] := the number of painted grid in the j-th column\n    cols = [0] * n\n    # numToRow[num] := the i-th row of `num` in `mat`\n    numToRow = [0] * (m * n + 1)\n    # numToCol[num] := the j-th column of `num` in `mat`\n    numToCol = [0] * (m * n + 1)\n\n    for i, row in enumerate(mat):\n      for j, num in enumerate(row):\n        numToRow[num] = i\n        numToCol[num] = j\n\n    for i, a in enumerate(arr):\n      rows[numToRow[a]] += 1\n      if rows[numToRow[a]] == n:\n        return i\n      cols[numToCol[a]] += 1\n      if cols[numToCol[a]] == m:\n        return i",
      "title": "2661. First Completely Painted Row or Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "291c0e57-9e99-40b9-bffd-f11ad45323f8",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      start: list[int],\n      target: list[int],\n      specialRoads: list[list[int]],\n  ) -> int:\n    return self.dijkstra(specialRoads, *start, *target)\n\n  def dijkstra(\n      self,\n      specialRoads: list[list[int]],\n      srcX: int,\n      srcY: int,\n      dstX: int,\n      dstY: int,\n  ) -> int:\n    n = len(specialRoads)\n    # dist[i] := the minimum distance of (srcX, srcY) to specialRoads[i](x2, y2)\n    dist = [math.inf] * n\n    minHeap = []  # (d, u), where u := the i-th specialRoads\n\n    # (srcX, srcY) -> (x1, y1) to cost -> (x2, y2)\n    for u, (x1, y1, _, _, cost) in enumerate(specialRoads):\n      d = abs(x1 - srcX) + abs(y1 - srcY) + cost\n      dist[u] = d\n      heapq.heappush(minHeap, (dist[u], u))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      _, _, ux2, uy2, _ = specialRoads[u]\n      for v in range(n):\n        if v == u:\n          continue\n        vx1, vy1, _, _, vcost = specialRoads[v]\n        # (ux2, uy2) -> (vx1, vy1) to vcost -> (vx2, vy2)\n        newDist = d + abs(vx1 - ux2) + abs(vy1 - uy2) + vcost\n        if newDist < dist[v]:\n          dist[v] = newDist\n          heapq.heappush(minHeap, (dist[v], v))\n\n    ans = abs(dstX - srcX) + abs(dstY - srcY)\n    for u in range(n):\n      _, _, x2, y2, _ = specialRoads[u]\n      # (srcX, srcY) -> (x2, y2) -> (dstX, dstY).\n      ans = min(ans, dist[u] + abs(dstX - x2) + abs(dstY - y2))\n\n    return ans",
      "title": "2662. Minimum Cost of a Path With Special Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "719f25b2-daa9-4d45-b21f-2749cc3a6c90",
      "code": "class Solution:\n  def smallestBeautifulString(self, s: str, k: int) -> str:\n    chars = list(s)\n\n    for i in reversed(range(len(chars))):\n      chars[i] = chr(ord(chars[i]) + 1)\n      while self._containsPalindrome(chars, i):\n        chars[i] = chr(ord(chars[i]) + 1)\n      if chars[i] < chr(ord('a') + k):\n        # If s[i] is among the first k letters, then change the letters after\n        # s[i] to the smallest ones that don't form any palindrome substring.\n        return self._changeSuffix(chars, i + 1)\n\n    return ''\n\n  def _containsPalindrome(self, chars: list[str], i: int) -> bool:\n    \"\"\"Returns True if chars[0..i] contains palindrome.\"\"\"\n    return ((i > 0 and chars[i] == chars[i - 1]) or\n            (i > 1 and chars[i] == chars[i - 2]))\n\n  def _changeSuffix(self, chars: list[str], i: int) -> str:\n    \"\"\"\n    Returns a string, where replacing sb[i..n) with the smallest possible\n    letters don't form any palindrome substring.\n    \"\"\"\n    for j in range(i, len(chars)):\n      chars[j] = 'a'\n      while self._containsPalindrome(chars, j):\n        chars[j] = chr(ord(chars[j]) + 1)\n    return ''.join(chars)",
      "title": "2663. Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8e341ab-12d9-4fdc-8d86-52cd84655bd1",
      "code": "class Solution:\n  def tourOfKnight(self, m: int, n: int, r: int, c: int) -> list[list[int]]:\n    DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n            (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n    ans = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, step: int) -> bool:\n      if step == m * n:\n        return True\n      if i < 0 or i >= m or j < 0 or j >= n:\n        return False\n      if ans[i][j] != -1:\n        return False\n      ans[i][j] = step\n      for dx, dy in DIRS:\n        if dfs(i + dx, j + dy, step + 1):\n          return True\n      ans[i][j] = -1\n      return False\n\n    dfs(r, c, 0)\n    return ans",
      "title": "2664. The Knight’s Tour",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf5f4117-2b02-4a87-8504-d4ad59e8a716",
      "code": "class Solution:\n  def distinctDifferenceArray(self, nums: list[int]) -> list[int]:\n    MAX = 50\n    ans = []\n    prefixCount = [0] * (MAX + 1)\n    suffixCount = [0] * (MAX + 1)\n    distinctPrefix = 0\n    distinctSuffix = 0\n\n    for num in nums:\n      if suffixCount[num] == 0:\n        distinctSuffix += 1\n      suffixCount[num] += 1\n\n    for num in nums:\n      if prefixCount[num] == 0:\n        distinctPrefix += 1\n      prefixCount[num] += 1\n      if suffixCount[num] == 1:\n        distinctSuffix -= 1\n      suffixCount[num] -= 1\n      ans.append(distinctPrefix - distinctSuffix)\n\n    return ans",
      "title": "2670. Find the Distinct Difference Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8cc2620-8677-4f72-8412-b383cebfc6e1",
      "code": "class Solution:\n  def colorTheArray(self, n: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    arr = [0] * n\n    sameColors = 0\n\n    for i, color in queries:\n      if i + 1 < n:\n        if arr[i + 1] > 0 and arr[i + 1] == arr[i]:\n          sameColors -= 1\n        if arr[i + 1] == color:\n          sameColors += 1\n      if i > 0:\n        if arr[i - 1] > 0 and arr[i - 1] == arr[i]:\n          sameColors -= 1\n        if arr[i - 1] == color:\n          sameColors += 1\n      arr[i] = color\n      ans.append(sameColors)\n\n    return ans",
      "title": "2672. Number of Adjacent Elements With the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9e88755-7e86-4df5-9367-ede289c1ef6d",
      "code": "class Solution:\n  def minIncrements(self, n: int, cost: list[int]) -> int:\n    ans = 0\n\n    for i in range(n // 2 - 1, -1, -1):\n      l = i * 2 + 1\n      r = i * 2 + 2\n      ans += abs(cost[l] - cost[r])\n      # Record the information in the parent from the children. So, there's need to actually\n      # update the values in the children.\n      cost[i] += max(cost[l], cost[r])\n\n    return ans",
      "title": "2673. Make Costs of Paths Equal in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18350942-6c0e-433f-98b6-a21b9db7508d",
      "code": "class Solution:\n  def splitCircularLinkedList(self, list: ListNode | None) -> list[ListNode | None]:\n    slow = list\n    fast = list\n\n    # Point `slow` to the last node in the first half.\n    while fast.next != list and fast.next.next != list:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Circle back the second half.\n    secondHead = slow.next\n    if fast.next == list:\n      fast.next = secondHead\n    else:\n      fast.next.next = secondHead\n\n    # Circle back the first half.\n    slow.next = list\n\n    return [list, secondHead]",
      "title": "2674. Split a Circular Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f53ca28f-9f8d-4bd6-9f61-6a5e95ac7eb3",
      "code": "class Solution:\n  def countSeniors(self, details: list[str]) -> int:\n    return sum(int(detail[11:13]) > 60 for detail in details)",
      "title": "2678. Number of Senior Citizens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7799fa8-df21-4a8a-a094-ee61efc25e5f",
      "code": "class Solution:\n  def matrixSum(self, nums: list[list[int]]) -> int:\n    for row in nums:\n      row.sort()\n\n    return sum(max(col) for col in zip(*nums))",
      "title": "2679. Sum in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28c2c1aa-f58a-496f-b5a8-0e325a4a9e0b",
      "code": "class Solution:\n  def maximumOr(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n    prefix = [0] * n\n    # suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n    suffix = [0] * n\n\n    for i in range(1, n):\n      prefix[i] = prefix[i - 1] | nums[i - 1]\n\n    for i in range(n - 2, -1, -1):\n      suffix[i] = suffix[i + 1] | nums[i + 1]\n\n    # For each num, greedily shift it left by k bits.\n    return max(p | num << k | s for num, p, s in zip(nums, prefix, suffix))",
      "title": "2680. Maximum OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db0376b8-093c-4752-b91b-e788a3bc0970",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    summ = 0\n\n    for num in sorted(nums):\n      ans += (num + summ) * num**2\n      ans %= MOD\n      summ = (summ * 2 + num) % MOD\n\n    return ans",
      "title": "2681. Power of Heroes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "28df41f2-c6e4-44fe-a455-ad455869134a",
      "code": "class Solution:\n  def circularGameLosers(self, n: int, k: int) -> list[int]:\n    seen = [False] * n\n    friendIndex = 0\n    turn = 1\n\n    while not seen[friendIndex]:\n      seen[friendIndex] = True\n      friendIndex += turn * k\n      friendIndex %= n\n      turn += 1\n\n    return [friendIndex + 1\n            for friendIndex in range(n)\n            if not seen[friendIndex]]",
      "title": "2682. Find the Losers of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da9c2383-a5de-4fbf-bdc5-f92d40b924f8",
      "code": "class Solution:\n  def doesValidArrayExist(self, derived: list[int]) -> bool:\n    return functools.reduce(operator.xor, derived) == 0",
      "title": "2683. Neighboring Bitwise XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbb97fbe-fe9f-4367-bd07-1cacbf3f43ec",
      "code": "class Solution:\n  def maxMoves(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the maximum number of moves you can perform from (i, j)\n    dp = [[0] * n for _ in range(m)]\n\n    for j in range(n - 2, -1, -1):\n      for i in range(m):\n        if grid[i][j + 1] > grid[i][j]:\n          dp[i][j] = 1 + dp[i][j + 1]\n        if i > 0 and grid[i - 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i - 1][j + 1])\n        if i + 1 < m and grid[i + 1][j + 1] > grid[i][j]:\n          dp[i][j] = max(dp[i][j], 1 + dp[i + 1][j + 1])\n\n    return max(dp[i][0] for i in range(m))",
      "title": "2684. Maximum Number of Moves in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8f12366b-d407-4041-a15d-31fec0c29f4f",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    self.nodeCount = [1] * n\n    self.edgeCount = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    self.edgeCount[i] += 1\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n      self.edgeCount[i] += self.edgeCount[j]\n      self.nodeCount[i] += self.nodeCount[j]\n    else:\n      self.id[i] = j\n      self.edgeCount[j] += self.edgeCount[i]\n      self.nodeCount[j] += self.nodeCount[i]\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n  def isComplete(self, u):\n    return self.nodeCount[u] * (self.nodeCount[u] - 1) // 2 == self.edgeCount[u]\n\n\nclass Solution:\n  def countCompleteComponents(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    uf = UnionFind(n)\n    parents = set()\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    for i in range(n):\n      parent = uf.find(i)\n      if parent not in parents and uf.isComplete(parent):\n        ans += 1\n        parents.add(parent)\n\n    return ans",
      "title": "2685. Count the Number of Complete Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70c0ad06-ec7c-4d08-803b-3bd1a99e8dba",
      "code": "class Solution:\n  def getKthCharacter(self, root: object | None, k: int) -> str:\n    \"\"\":type root: RopeTreeNode | None\"\"\"\n    if root.len == 0:\n      return root.val[k - 1]\n    leftLen = (0 if not root.left\n               else max(root.left.len, len(root.left.val)))\n    if leftLen >= k:\n      return self.getKthCharacter(root.left, k)\n    return self.getKthCharacter(root.right, k - leftLen)",
      "title": "2689. Extract Kth Character From The Rope Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "122a7fab-f62e-40ba-83d7-646a7a4abc3f",
      "code": "class Solution:\n  def minLength(self, s: str) -> int:\n    stack = []\n\n    def match(c: str) -> bool:\n      return stack and stack[-1] == c\n\n    for c in s:\n      if c == 'B' and match('A'):\n        stack.pop()\n      elif c == 'D' and match('C'):\n        stack.pop()\n      else:\n        stack.append(c)\n\n    return len(stack)",
      "title": "2696. Minimum String Length After Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33173484-5519-4910-9429-c38d1dbd0c74",
      "code": "class Solution:\n  def makeSmallestPalindrome(self, s: str) -> str:\n    chars = list(s)\n    i = 0\n    j = len(s) - 1\n\n    while i < j:\n      minChar = min(chars[i], chars[j])\n      chars[i] = minChar\n      chars[j] = minChar\n      i += 1\n      j -= 1\n\n    return ''.join(chars)",
      "title": "2697. Lexicographically Smallest Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fe96f1e-290e-40c7-be3b-92a3d3722884",
      "code": "class Solution:\n  def punishmentNumber(self, n: int) -> int:\n    def isPossible(\n            accumulate: int, running: int, numChars: list[str],\n            s: int, target: int) -> bool:\n      \"\"\"\n      Returns True if the sum of any split of `numChars` equals to the target.\n      \"\"\"\n      if s == len(numChars):\n        return target == accumulate + running\n      d = int(numChars[s])\n      return (\n          # Keep growing `running`.\n          isPossible(accumulate, running * 10 + d, numChars, s + 1, target) or\n          # Start a new `running`.\n          isPossible(accumulate + running, d, numChars, s + 1, target)\n      )\n\n    return sum(i * i\n               for i in range(1, n + 1)\n               if isPossible(0, 0, str(i * i), 0, i))",
      "title": "2698. Find the Punishment Number of an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea135ba7-395a-40f9-86c9-d5848de71e6d",
      "code": "class Solution:\n  def modifiedGraphEdges(self, n: int, edges: list[list[int]], source: int, destination: int, target: int) -> list[list[int]]:\n    MAX = 2_000_000_000\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      if w == -1:\n        continue\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    distToDestination = self._dijkstra(graph, source, destination)\n    if distToDestination < target:\n      return []\n    if distToDestination == target:\n      # Change the weights of negative edges to an impossible value.\n      for edge in edges:\n        if edge[2] == -1:\n          edge[2] = MAX\n      return edges\n\n    for i, (u, v, w) in enumerate(edges):\n      if w != -1:\n        continue\n      edges[i][2] = 1\n      graph[u].append((v, 1))\n      graph[v].append((u, 1))\n      distToDestination = self._dijkstra(graph, source, destination)\n      if distToDestination <= target:\n        edges[i][2] += target - distToDestination\n        # Change the weights of negative edges to an impossible value.\n        for j in range(i + 1, len(edges)):\n          if edges[j][2] == -1:\n            edges[j][2] = MAX\n        return edges\n\n    return []\n\n  def _dijkstra(self, graph: list[list[int]], src: int, dst: int) -> int:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist[dst]",
      "title": "2699. Modify Graph Edge Weights",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d0eec92-9cc0-49a3-95f0-3b6f33b95b34",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int, y: int) -> int:\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if it's possible to make all `nums` <= 0 using m operations.\n      \"\"\"\n      # If we want m operations, first decrease all the numbers by y * m. Then\n      # we have m operations to select indices to decrease them by x - y.\n      return sum(max(0, math.ceil((num - y * m) / (x - y)))\n                 for num in nums) <= m\n\n    return bisect.bisect_left(range(max(nums)), True, key=isPossible)",
      "title": "2702. Minimum Operations to Make Numbers Non-positive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ebe1aaa-03c3-4a79-9b5e-a3735f49d615",
      "code": "class Solution:\n  def buyChoco(self, prices: list[int], money: int) -> int:\n    min1 = math.inf\n    min2 = math.inf\n\n    for price in prices:\n      if price <= min1:\n        min2 = min1\n        min1 = price\n      elif price < min2:\n        min2 = price\n\n    minCost = min1 + min2\n    return money if minCost > money else money - minCost",
      "title": "2706. Buy Two Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16bf4e86-3ed4-4017-91ed-1da2011c72de",
      "code": "class Solution:\n  # Similar to 139. Word Break\n  def minExtraChar(self, s: str, dictionary: list[str]) -> int:\n    n = len(s)\n    dictionarySet = set(dictionary)\n    # dp[i] := the minimum extra letters if breaking up s[0..i) optimally\n    dp = [0] + [n] * n\n\n    for i in range(1, n + 1):\n      for j in range(i):\n        if s[j:i] in dictionarySet:\n          dp[i] = min(dp[i], dp[j])\n        else:\n          dp[i] = min(dp[i], dp[j] + i - j)\n\n    return dp[n]",
      "title": "2707. Extra Characters in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3de6fc29-af7c-412b-800a-507c2668142b",
      "code": "class Solution:\n  def maxStrength(self, nums: list[int]) -> int:\n    posProd = 1\n    negProd = 1\n    maxNeg = -math.inf\n    negCount = 0\n    hasPos = False\n    hasZero = False\n\n    for num in nums:\n      if num > 0:\n        posProd *= num\n        hasPos = True\n      elif num < 0:\n        negProd *= num\n        maxNeg = max(maxNeg, num)\n        negCount += 1\n      else:  # num == 0\n        hasZero = True\n\n    if negCount == 0 and not hasPos:\n      return 0\n    if negCount % 2 == 0:\n      return negProd * posProd\n    if negCount >= 3:\n      return negProd // maxNeg * posProd\n    if hasPos:\n      return posProd\n    if hasZero:\n      return 0\n    return maxNeg",
      "title": "2708. Maximum Strength of a Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd35458d-87a0-4ff3-af67-876b0445559d",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n\n  def getSize(self, i: int) -> int:\n    return self.sz[i]\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canTraverseAllPairs(self, nums: list[int]) -> bool:\n    n = len(nums)\n    mx = max(nums)\n    maxPrimeFactor = self._sieveEratosthenes(mx + 1)\n    primeToFirstIndex = collections.defaultdict(int)\n    uf = UnionFind(n)\n\n    for i, num in enumerate(nums):\n      for prime_factor in self._getPrimeFactors(num, maxPrimeFactor):\n        if prime_factor in primeToFirstIndex:\n          uf.unionBySize(primeToFirstIndex[prime_factor], i)\n        else:\n          primeToFirstIndex[prime_factor] = i\n\n    return any(uf.getSize(i) == n for i in range(n))\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "2709. Greatest Common Divisor Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72306883-776f-4fa1-b7fd-8ca668076964",
      "code": "class Solution:\n  def removeTrailingZeros(self, num: str) -> str:\n    return num.rstrip('0')",
      "title": "2710. Remove Trailing Zeros From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7a80974-f409-4602-9a0a-e185e5855312",
      "code": "class Solution:\n  def differenceOfDistinctValues(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n\n    def fillInDiagonal(i: int, j: int) -> None:\n      topLeft = set()\n      bottomRight = set()\n\n      # Fill in the diagonal from the top-left to the bottom-right.\n      while i < len(grid) and j < len(grid[0]):\n        ans[i][j] = len(topLeft)\n        # Post-addition, so this information can be utilized in subsequent cells.\n        topLeft.add(grid[i][j])\n        i += 1\n        j += 1\n\n      i -= 1\n      j -= 1\n\n      # Fill in the diagonal from the bottom-right to the top-left.\n      while i >= 0 and j >= 0:\n        ans[i][j] = abs(ans[i][j] - len(bottomRight))\n        # Post-addition, so this information can be utilized in subsequent cells.\n        bottomRight.add(grid[i][j])\n        i -= 1\n        j -= 1\n\n    for i in range(m):\n      fillInDiagonal(i, 0)\n\n    for j in range(1, n):\n      fillInDiagonal(0, j)\n\n    return ans",
      "title": "2711. Difference of Number of Distinct Values on Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "652ab5eb-e7d7-4c0e-845a-90d37d9d63f5",
      "code": "class Solution:\n  def minimumCost(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n\n    for i in range(1, n):\n      if s[i] != s[i - 1]:\n        # Invert s[0..i - 1] or s[i..n - 1].\n        ans += min(i, n - i)\n\n    return ans",
      "title": "2712. Minimum Cost to Make All Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2fed51-78cb-43dd-84cd-5dfb4fa03d76",
      "code": "class Solution:\n  def maxIncreasingCells(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    rows = [0] * m  # rows[i] := the maximum path length for the i-th row\n    cols = [0] * n  # cols[j] := the maximum path length for the j-th column\n    valToIndices = collections.defaultdict(list)\n    # maxPathLength[i][j] := the maximum path length from mat[i][j]\n    maxPathLength = [[0] * n for _ in range(m)]\n    # Sort all the unique values in the matrix in non-increasing order.\n    decreasingSet = set()\n\n    for i in range(m):\n      for j in range(n):\n        val = mat[i][j]\n        valToIndices[val].append((i, j))\n        decreasingSet.add(val)\n\n    for val in sorted(decreasingSet, reverse=True):\n      for i, j in valToIndices[val]:\n        maxPathLength[i][j] = max(rows[i], cols[j]) + 1\n      for i, j in valToIndices[val]:\n        rows[i] = max(rows[i], maxPathLength[i][j])\n        cols[j] = max(cols[j], maxPathLength[i][j])\n\n    return max(max(rows), max(cols))",
      "title": "2713. Maximum Strictly Increasing Cells in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e6c9631-f850-45fb-8927-ab28ae0975f9",
      "code": "class Solution:\n  # Similar to 787. Cheapest Flights Within K Stops\n  def shortestPathWithHops(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      d: int,\n      k: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, s, d, k)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      k: int,\n  ) -> int:\n    dist = [[math.inf for _ in range(k + 1)] for _ in range(len(graph))]\n\n    dist[src][k] = 0\n    minHeap = [(dist[src][k], src, k)]  # (d, u, hops)\n\n    while minHeap:\n      d, u, hops = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      if dist[u][hops] > d:\n        continue\n      for v, w in graph[u]:\n        # Go from u -> v with w cost.\n        if d + w < dist[v][hops]:\n          dist[v][hops] = d + w\n          heapq.heappush(minHeap, (dist[v][hops], v, hops))\n        # Hop from u -> v with 0 cost.\n        if hops > 0 and d < dist[v][hops - 1]:\n          dist[v][hops - 1] = d\n          heapq.heappush(minHeap, (dist[v][hops - 1], v, hops - 1))",
      "title": "2714. Find Shortest Path with K Hops",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b59ca15-d7cb-4c2d-a1d6-0f50e1f142cf",
      "code": "class Solution:\n  def minimizedStringLength(self, s: str) -> int:\n    return len({*s})",
      "title": "2716. Minimize String Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7b8e94e-5c28-404c-ac44-a7961cc423a5",
      "code": "class Solution:\n  def semiOrderedPermutation(self, nums: list[int]) -> int:\n    n = len(nums)\n    index1 = nums.index(1)\n    indexN = nums.index(n)\n    return index1 + (n - 1 - indexN) - int(index1 > indexN)",
      "title": "2717. Semi-Ordered Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c175bc3-ebb9-4483-99c0-e8a0a5ceb98f",
      "code": "class Solution:\n  def matrixSumQueries(self, n: int, queries: list[list[int]]) -> int:\n    ans = 0\n    # seen[0] := row, seen[1] := col\n    seen = [[False] * n for _ in range(2)]\n    # notSet[0] = row, notSet[1] := col\n    notSet = [n] * 2\n\n    # Late queries dominate.\n    for type, index, val in reversed(queries):\n      if not seen[type][index]:\n        ans += val * notSet[type ^ 1]\n        seen[type][index] = True\n        notSet[type] -= 1\n\n    return ans",
      "title": "2718. Sum of Matrix After Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b30066b1-8cbf-4a4a-a41d-7c0424ee261d",
      "code": "# Definition for a street.\n# class Street:\n#   def openDoor(self):\n#     pass\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\n#   def moveLeft(self):\n#     pass\n\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    for _ in range(k):\n      if street.isDoorOpen():\n        street.closeDoor()\n      street.moveRight()\n\n    for ans in range(k + 1):\n      if street.isDoorOpen():\n        return ans\n      street.openDoor()\n      street.moveRight()",
      "title": "2728. Count Houses in a Circular Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f09618c-1204-4773-b48b-fbf2ad416232",
      "code": "class Solution:\n  def isFascinating(self, n):\n    s = str(n) + str(2 * n) + str(3 * n)\n    return ''.join(sorted(s)) == '123456789'",
      "title": "2729. Check if The Number is Fascinating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3ddfe3d-271b-438a-9ab1-87b58942d2bc",
      "code": "class Solution:\n  def longestSemiRepetitiveSubstring(self, s: str) -> int:\n    ans = 1\n    prevStart = 0\n    start = 0\n\n    for i in range(1, len(s)):\n      if s[i] == s[i - 1]:\n        if prevStart > 0:\n          start = prevStart\n        prevStart = i\n      ans = max(ans, i - start + 1)\n\n    return ans",
      "title": "2730. Find the Longest Semi-Repetitive Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a9a1549-6419-4d75-8947-52da0569e536",
      "code": "class Solution:\n  def sumDistance(self, nums: list[int], s: str, d: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    pos = sorted([num - d if c == 'L' else num + d\n                  for num, c in zip(nums, s)])\n\n    for i, p in enumerate(pos):\n      ans = ((ans + i * p - prefix) % MOD + MOD) % MOD\n      prefix = ((prefix + p) % MOD + MOD) % MOD\n\n    return ans",
      "title": "2731. Movement of Robots",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5238766-a9b2-456a-9f58-a821fb2d39ca",
      "code": "class Solution:\n  def goodSubsetofBinaryMatrix(self, grid: list[list[int]]) -> list[int]:\n    MAX_BIT = 30\n    maskToIndex = {}\n\n    def getMask(row: list[int]) -> int:\n      mask = 0\n      for i, num in enumerate(row):\n        if num == 1:\n          mask |= 1 << i\n      return mask\n\n    for i, row in enumerate(grid):\n      mask = getMask(row)\n      if mask == 0:\n        return [i]\n      for prevMask in range(1, MAX_BIT):\n        if (mask & prevMask) == 0 and prevMask in maskToIndex:\n          return [maskToIndex[prevMask], i]\n      maskToIndex[mask] = i\n\n    return []",
      "title": "2732. Find a Good Subset of the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc2f84b5-8e0d-4bb5-9478-c1ebf988e6b3",
      "code": "class Solution:\n  def findNonMinOrMax(self, nums: list[int]) -> int:\n    return -1 if len(nums) < 3 else sorted(nums[:3])[1]",
      "title": "2733. Neither Minimum nor Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f5bc62e-1f20-4807-bec0-d4e0489899e7",
      "code": "class Solution:\n  def smallestString(self, s: str) -> str:\n    chars = list(s)\n    n = len(s)\n    i = 0\n\n    while i < n and chars[i] == 'a':\n      i += 1\n    if i == n:\n      chars[-1] = 'z'\n      return ''.join(chars)\n\n    while i < n and s[i] != 'a':\n      chars[i] = chr(ord(chars[i]) - 1)\n      i += 1\n\n    return ''.join(chars)",
      "title": "2734. Lexicographically Smallest String After Substring Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad00e91e-1b39-4eeb-a102-b16c40d55959",
      "code": "class Solution:\n  def minCost(self, nums: list[int], x: int) -> int:\n    n = len(nums)\n    ans = math.inf\n    # minCost[i] := the minimum cost to collect the i-th type\n    minCost = [math.inf] * n\n\n    for rotate in range(n):\n      for i in range(n):\n        minCost[i] = min(minCost[i], nums[(i - rotate + n) % n])\n      ans = min(ans, sum(minCost) + rotate * x)\n\n    return ans",
      "title": "2735. Collecting Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96c39e7c-5dce-4f6d-ab14-227a503b48d7",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Pair:\n  x: int\n  y: int\n\n  def __iter__(self):\n    yield self.x\n    yield self.y\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  minX: int\n  minY: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.minX\n    yield self.minY\n\n\nclass Solution:\n  def maximumSumQueries(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    pairs = sorted([Pair(nums1[i], nums2[i])\n                   for i in range(len(nums1))], key=lambda x: x.x, reverse=True)\n    ans = [0] * len(queries)\n    stack = []  # [(y, x + y)]\n\n    pairsIndex = 0\n    for queryIndex, minX, minY in sorted([IndexedQuery(i, query[0], query[1])\n                                          for i, query in enumerate(queries)],\n                                         key=lambda x: -x.minX):\n      while pairsIndex < len(pairs) and pairs[pairsIndex].x >= minX:\n        # x + y is a better candidate. Given that x is decreasing, the\n        # condition \"x + y >= stack[-1][1]\" suggests that y is relatively\n        # larger, thereby making it a better candidate.\n        x, y = pairs[pairsIndex]\n        while stack and x + y >= stack[-1][1]:\n          stack.pop()\n        if not stack or y > stack[-1][0]:\n          stack.append((y, x + y))\n        pairsIndex += 1\n      j = self._firstGreaterEqual(stack, minY)\n      ans[queryIndex] = -1 if j == len(stack) else stack[j][1]\n\n    return ans\n\n  def _firstGreaterEqual(self, A: list[tuple[int, int]], target: int) -> int:\n    l = 0\n    r = len(A)\n    while l < r:\n      m = (l + r) // 2\n      if A[m][0] >= target:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2736. Maximum Sum Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d40d5fd7-8224-44b0-a882-8ea8cfa91abd",
      "code": "class Solution:\n  def minimumDistance(\n      self,\n      n: int,\n      edges: list[list[int]],\n      s: int,\n      marked: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    dist = self._dijkstra(graph, s)\n    ans = min(dist[u] for u in marked)\n    return -1 if ans == math.inf else ans\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2737. Find the Closest Marked Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54101cc2-d490-46b5-9010-3e1c593654d2",
      "code": "class Solution:\n  def distanceTraveled(self, mainTank: int, additionalTank: int) -> int:\n    # M  M M M M  A  M M M M   A\n    # 1 [2 3 4 5] 6 [7 8 9 10] 11\n    return (mainTank + min((mainTank - 1) // 4, additionalTank)) * 10",
      "title": "2739. Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85827653-7de5-483e-ab2f-bd2bce3dd362",
      "code": "class Solution:\n  def findValueOfPartition(self, nums: list[int]) -> int:\n    return min(b - a for a, b in itertools.pairwise(sorted(nums)))",
      "title": "2740. Find the Value of the Partition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b168a8eb-f804-45a2-85cf-407078a12b13",
      "code": "class Solution:\n  def specialPerm(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxMask = 1 << len(nums)\n\n    @functools.lru_cache(None)\n    def dp(prev: int, mask: int) -> int:\n      \"\"\"\n      Returns the number of special permutations, where the previous number is\n      nums[i] and `mask` is the bitmask of the used numbers.\n      \"\"\"\n      if mask == maxMask - 1:\n        return 1\n\n      res = 0\n\n      for i, num in enumerate(nums):\n        if mask >> i & 1:\n          continue\n        if num % nums[prev] == 0 or nums[prev] % num == 0:\n          res += dp(i, mask | 1 << i)\n          res %= MOD\n\n      return res\n\n    return sum(dp(i, 1 << i)\n               for i in range(len(nums))) % MOD",
      "title": "2741. Special Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b90382ef-a0d1-4a05-b9ba-f5dae44880c6",
      "code": "class Solution:\n  def paintWalls(self, cost: list[int], time: list[int]) -> int:\n    n = len(cost)\n\n    @functools.lru_cache(None)\n    def dp(i: int, walls: int) -> int:\n      \"\"\"Returns the minimum cost to paint j walls by painters[i..n).\"\"\"\n      if walls <= 0:\n        return 0\n      if i == n:\n        return math.inf\n      pick = cost[i] + dp(i + 1, walls - time[i] - 1)\n      skip = dp(i + 1, walls)\n      return min(pick, skip)\n\n    return dp(0, n)",
      "title": "2742. Painting the Walls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5af98ecd-1eea-4a05-965e-4aa9407807be",
      "code": "class Solution:\n  def numberOfSpecialSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == 2:\n        count[s[l]] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2743. Count Substrings Without Repeating Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "497be4c0-b1d4-4257-91d8-e1e91e5e4a14",
      "code": "class Solution:\n  def maximumNumberOfStringPairs(self, words: list[str]) -> int:\n    ans = 0\n    seen = [False] * (26 * 26)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for word in words:\n      if seen[val(word[1]) * 26 + val(word[0])]:\n        ans += 1\n      seen[val(word[0]) * 26 + val(word[1])] = True\n\n    return ans",
      "title": "2744. Find Maximum Number of String Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e999a29-710a-4486-b8f4-b443ca54dfea",
      "code": "class Solution:\n  def longestString(self, x: int, y: int, z: int) -> int:\n    # 'AB' can always be easily appended within the string.\n    # Alternating 'AA' and 'BB' can be appended, creating a pattern like 'AABB'\n    # If x == y, we repeat the pattern 'AABBAABB...AABB'.\n    # If x != y, the pattern becomes 'AABBAABB...AABBAA' or 'BBAABBAABB...AABB'\n    mn = min(x, y)\n    if x == y:\n      return (mn * 2 + z) * 2\n    return (mn * 2 + 1 + z) * 2",
      "title": "2745. Construct the Longest New String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fdfa5fe-9328-4d1c-b4f5-df6e5849cee4",
      "code": "class Solution:\n  def minimizeConcatenatedLength(self, words: list[str]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, first: str, last: str) -> int:\n      \"\"\"\n      Returns the minimum concatenated length of the first i words starting with\n      `first` and ending in `last`.\n      \"\"\"\n      if i == len(words):\n        return 0\n      nextFirst = words[i][0]\n      nextLast = words[i][-1]\n      return len(words[i]) + min(\n          # join(words[i - 1], words[i])\n          dp(i + 1, first, nextLast) - (last == nextFirst),\n          # join(words[i], words[i - 1])\n          dp(i + 1, nextFirst, last) - (first == nextLast)\n      )\n\n    return len(words[0]) + dp(1, words[0][0], words[0][-1])",
      "title": "2746. Decremental String Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11f23662-0ba8-47fe-b17c-ab0b4592fe66",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def countServers(\n      self,\n      n: int,\n      logs: list[list[int]],\n      x: int,\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    count = [0] * (n + 1)\n\n    logs.sort(key=lambda x: x[1])\n\n    i = 0\n    j = 0\n    servers = 0\n\n    # For each query, we care about logs[i..j].\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while j < len(logs) and logs[j][1] <= query:\n        count[logs[j][0]] += 1\n        if count[logs[j][0]] == 1:\n          servers += 1\n        j += 1\n      while i < len(logs) and logs[i][1] < query - x:\n        count[logs[i][0]] -= 1\n        if count[logs[i][0]] == 0:\n          servers -= 1\n        i += 1\n      ans[queryIndex] = n - servers\n\n    return ans",
      "title": "2747. Count Zero Request Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98549cb0-549f-4763-96e0-38f0c90d68dc",
      "code": "class Solution:\n  def countBeautifulPairs(self, nums: list[int]) -> int:\n    def firstDigit(num: int) -> int:\n      return int(str(num)[0])\n\n    def lastDigit(num: int) -> int:\n      return num % 10\n\n    return sum(math.gcd(firstDigit(nums[i]), lastDigit(nums[j])) == 1\n               for i, j in itertools.combinations(range(len(nums)), 2))",
      "title": "2748. Number of Beautiful Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22ac628b-c4e6-45af-9120-92e9fa1e3a47",
      "code": "class Solution:\n  def makeTheIntegerZero(self, num1: int, num2: int) -> int:\n    # If k operations are used, num1 - [(num2 + 2^{i_1}) + (num2 + 2^{i_2}) +\n    # ... + (num2 + 2^{i_k})] = 0. So, num1 - k * num2 = (2^{i_1} + 2^{i_2} +\n    # ... + 2^{i_k}), where i_1, i_2, ..., i_k are in the range [0, 60].\n    # Note that for any number x, we can use \"x's bit count\" operations to make\n    # x equal to 0. Additionally, we can also use x operations to deduct x by\n    # 2^0 (x times), which also results in 0.\n\n    for ops in range(61):\n      target = num1 - ops * num2\n      if target.bit_count() <= ops <= target:\n        return ops\n\n    return -1",
      "title": "2749. Minimum Operations to Make the Integer Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1de3035-c443-45ed-93d3-08e4587d5ac1",
      "code": "class Solution:\n  def numberOfGoodSubarraySplits(self, nums: list[int]) -> int:\n    if 1 not in nums:\n      return 0\n\n    MOD = 1_000_000_007\n    prev = -1  # the previous index of 1\n    ans = 1\n\n    for i, num in enumerate(nums):\n      if num == 1:\n        if prev != -1:\n          ans *= i - prev\n          ans %= MOD\n        prev = i\n\n    return ans",
      "title": "2750. Ways to Split Array Into Good Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96674d4f-96a5-4435-acce-5c231dda383c",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Robot:\n  index: int\n  position: int\n  health: int\n  direction: str\n\n\nclass Solution:\n  def survivedRobotsHealths(\n      self,\n      positions: list[int],\n      healths: list[int],\n      directions: str,\n  ) -> list[int]:\n    robots = sorted([Robot(index, position, health, direction)\n                     for index, (position, health, direction) in\n                     enumerate(zip(positions, healths, directions))],\n                    key=lambda x: x.position)\n    stack: list[Robot] = []  # running robots\n\n    for robot in robots:\n      if robot.direction == 'R':\n        stack.append(robot)\n        continue\n      # Collide with robots going right if any.\n      while stack and stack[-1].direction == 'R' and robot.health > 0:\n        if stack[-1].health == robot.health:\n          stack.pop()\n          robot.health = 0\n        elif stack[-1].health < robot.health:\n          stack.pop()\n          robot.health -= 1\n        else:  # stack[-1].health > robot.health\n          stack[-1].health -= 1\n          robot.health = 0\n      if robot.health > 0:\n        stack.append(robot)\n\n    stack.sort(key=lambda robot: robot.index)\n    return [robot.health for robot in stack]",
      "title": "2751. Robot Collisions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60583ded-4f7f-4463-a582-9a5cec5717c8",
      "code": "# Definition for a street.\n# class Street:\n#   def closeDoor(self):\n#     pass\n#   def isDoorOpen(self):\n#     pass\n#   def moveRight(self):\n#     pass\nclass Solution:\n  def houseCount(self, street: Optional['Street'], k: int) -> int:\n    ans = 0\n\n    # Go to the first open door.\n    while not street.isDoorOpen():\n      street.moveRight()\n\n    street.moveRight()\n\n    for count in range(k):\n      # Each time we encounter an open door, there's a possibility that it's the\n      # first open door we intentionally left open.\n      if street.isDoorOpen():\n        ans = count + 1\n        street.closeDoor()\n      street.moveRight()\n\n    return ans",
      "title": "2753. Count Houses in a Circular Street II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba0d3263-838c-45a3-a821-cb21fe21f795",
      "code": "class Solution:\n  def longestAlternatingSubarray(self, nums: list[int], threshold: int) -> int:\n    ans = 0\n    dp = 0\n\n    def isOddEven(a: int, b: int) -> bool:\n      return a % 2 != b % 2\n\n    for i, num in enumerate(nums):\n      if num > threshold:\n        dp = 0\n      elif i > 0 and dp > 0 and isOddEven(nums[i - 1], num):\n        # Increase the size of the subarray.\n        dp += 1\n      else:\n        # Start a new subarray if the start is valid.\n        dp = 1 if num % 2 == 0 else 0\n      ans = max(ans, dp)\n\n    return ans",
      "title": "2760. Longest Even Odd Subarray With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c74e5038-df0b-45a8-b1d5-c5b65d04c002",
      "code": "class Solution:\n  def findPrimePairs(self, n: int) -> list[list[int]]:\n    isPrime = self._sieveEratosthenes(n + 1)\n    return [[i, n - i] for i in range(2, n // 2 + 1)\n            if isPrime[i] and isPrime[n - i]]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime\n\n\nj",
      "title": "2761. Prime Pairs With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27484b4b-ce34-4b50-b8f9-31a14f1284e6",
      "code": "class Solution:\n  def continuousSubarrays(self, nums: list[int]) -> int:\n    ans = 1  # [nums[0]]\n    left = nums[0] - 2\n    right = nums[0] + 2\n    l = 0\n\n    # nums[l..r] is a valid window.\n    for r in range(1, len(nums)):\n      if left <= nums[r] <= right:\n        left = max(left, nums[r] - 2)\n        right = min(right, nums[r] + 2)\n      else:\n        # nums[r] is out-of-bounds, so reconstruct the window.\n        left = nums[r] - 2\n        right = nums[r] + 2\n        l = r\n        # If we consistently move leftward in each iteration, it implies that\n        # the entire left subarray satisfies the given condition. For every\n        # subarray with l in the range [0, r], the condition is met, preventing\n        # the code from reaching the final \"else\" condition. Instead, it stops\n        # at the \"if\" condition.\n        while nums[r] - 2 <= nums[l] <= nums[r] + 2:\n          left = max(left, nums[l] - 2)\n          right = min(right, nums[l] + 2)\n          l -= 1\n        l += 1\n      # nums[l..r], num[l + 1..r], ..., nums[r]\n      ans += r - l + 1\n\n    return ans",
      "title": "2762. Continuous Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9ffd474-e15e-4271-8c24-21d5b90f5d5b",
      "code": "class Solution:\n  # If sorted(nums)[i + 1] - sorted(nums)[i] > 1, then there's a gap. Instead\n  # of determining the number of gaps in each subarray, let's find out how many\n  # subarrays contain each gap.\n  def sumImbalanceNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # Note that to avoid double counting, only `left` needs to check nums[i].\n    # This adjustment ensures that i represents the position of the leftmost\n    # element of nums[i] within the subarray.\n\n    # left[i] := the maximum index l s.t. nums[l] = nums[i] or nums[i] + 1\n    left = [0] * n\n    # right[i] := the minimum index r s.t. nums[r] = nums[i]\n    right = [0] * n\n\n    numToIndex = [-1] * (n + 2)\n    for i, num in enumerate(nums):\n      left[i] = max(numToIndex[num], numToIndex[num + 1])\n      numToIndex[num] = i\n\n    numToIndex = [n] * (n + 2)\n    for i in range(n - 1, -1, -1):\n      right[i] = numToIndex[nums[i] + 1]\n      numToIndex[nums[i]] = i\n\n    # The gap above nums[i] persists until encountering nums[i] or nums[i] + 1.\n    # Consider subarrays nums[l..r] with l <= i <= r, where l in [left[i], i]\n    # and r in [i, right[i] - 1]. There are (i - left[i]) * (right[i] - i)\n    # subarrays satisfying this condition.\n    #\n    # Subtract n * (n + 1) / 2 to account for the overcounting of elements\n    # initially assumed to have a gap. This adjustment is necessary as the\n    # maximum element of every subarray does not have a gap.\n    return sum((i - left[i]) * (right[i] - i)\n               for i in range(n)) - n * (n + 1) // 2",
      "title": "2763. Sum of Imbalance Numbers of All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b25eeda-1b0a-4b6c-a20a-d2f8b9098112",
      "code": "class Solution:\n  def isPreorder(self, nodes: list[list[int]]) -> bool:\n    stack = []  # Stores `id`s.\n\n    for id, parentId in nodes:\n      if parentId == -1:\n        stack.append(id)\n        continue\n      while stack and stack[-1] != parentId:\n        stack.pop()\n      if not stack:\n        return False\n      stack.append(id)\n\n    return True",
      "title": "2764. is Array a Preorder of Some ‌Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "866bb131-9f5c-44c5-86c0-6d517b1984fc",
      "code": "class Solution:\n  def alternatingSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    dp = 1\n\n    for i in range(1, len(nums)):\n      targetDiff = -1 if dp % 2 == 0 else 1\n      # Append nums[i] to the current alternating subarray.\n      if nums[i] - nums[i - 1] == targetDiff:\n        dp += 1\n      # Reset the alternating subarray to nums[i - 1..i].\n      elif nums[i] - nums[i - 1] == 1:\n        dp = 2\n      # Reset the alternating subarray to nums[i].\n      else:\n        dp = 1\n      ans = max(ans, dp)\n\n    return -1 if ans == 1 else ans",
      "title": "2765. Longest Alternating Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d078a6c1-60d1-483f-96f0-33d57c7a817a",
      "code": "class Solution:\n  def relocateMarbles(\n      self,\n      nums: list[int],\n      moveFrom: list[int],\n      moveTo: list[int],\n  ) -> list[int]:\n    numsSet = set(nums)\n\n    for f, t in zip(moveFrom, moveTo):\n      numsSet.remove(f)\n      numsSet.add(t)\n\n    return sorted(numsSet)",
      "title": "2766. Relocate Marbles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69d2e772-ad9e-4b69-83f5-9fadc5537ce2",
      "code": "class Solution:\n  def minimumBeautifulSubstrings(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of beautiful substrings for the first i chars\n    dp = [0] + [n + 1] * n\n\n    for i in range(1, n + 1):\n      if s[i - 1] == '0':\n        continue\n      num = 0  # the number of s[i - 1..j - 1]\n      for j in range(i, n + 1):\n        num = (num << 1) + int(s[j - 1])\n        if self._isPowerOfFive(num):\n          dp[j] = min(dp[j], dp[i - 1] + 1)\n\n    return -1 if dp[n] == n + 1 else dp[n]\n\n  def _isPowerOfFive(self, num: int) -> bool:\n    while num % 5 == 0:\n      num //= 5\n    return num == 1",
      "title": "2767. Partition String Into Minimum Beautiful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1208128-5910-448f-9665-195b2683f697",
      "code": "class Solution:\n  def countBlackBlocks(\n      self,\n      m: int,\n      n: int,\n      coordinates: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * 5\n    # count[i * n + j] := the number of black cells in\n    # (i - 1, j - 1), (i - 1, j), (i, j - 1), (i, j)\n    count = collections.Counter()\n\n    for x, y in coordinates:\n      for i in range(x, x + 2):\n        for j in range(y, y + 2):\n          # 2 x 2 submatrix with right-bottom conner being (i, j) contains the\n          # current black cell (x, y).\n          if 0 < i < m and 0 < j < n:\n            count[(i, j)] += 1\n\n    for freq in count.values():\n      ans[freq] += 1\n\n    ans[0] = (m - 1) * (n - 1) - sum(ans)\n    return ans",
      "title": "2768. Number of Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fbabda5-9200-4b18-bf94-4c1848949f33",
      "code": "class Solution:\n  def theMaximumAchievableX(self, num: int, t: int) -> int:\n    return num + 2 * t",
      "title": "2769. Find the Maximum Achievable Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4bee82f4-5a68-404e-b721-542164745cb5",
      "code": "class Solution:\n  def maximumJumps(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i] := the maximum number of jumps to reach i from 0\n    dp = [-1] * n\n    dp[0] = 0\n\n    for j in range(1, n):\n      for i in range(j):\n        if dp[i] != -1 and abs(nums[j] - nums[i]) <= target:\n          dp[j] = max(dp[j], dp[i] + 1)\n\n    return dp[-1]",
      "title": "2770. Maximum Number of Jumps to Reach the Last Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00796dda-0b07-440f-a4b1-88a69ad99155",
      "code": "class Solution:\n  def maxNonDecreasingLength(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 1\n    dp1 = 1  # the longest subarray that ends in nums1[i] so far\n    dp2 = 1  # the longest subarray that ends in nums2[i] so far\n\n    for i in range(1, len(nums1)):\n      dp11 = dp1 + 1 if nums1[i - 1] <= nums1[i] else 1\n      dp21 = dp2 + 1 if nums2[i - 1] <= nums1[i] else 1\n      dp12 = dp1 + 1 if nums1[i - 1] <= nums2[i] else 1\n      dp22 = dp2 + 1 if nums2[i - 1] <= nums2[i] else 1\n      dp1 = max(dp11, dp21)\n      dp2 = max(dp12, dp22)\n      ans = max(ans, dp1, dp2)\n\n    return ans",
      "title": "2771. Longest Non-decreasing Subarray From Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb25756c-e4cb-4612-967a-4714763e5d50",
      "code": "class Solution:\n  def checkArray(self, nums: list[int], k: int) -> bool:\n    if k == 1:\n      return True\n\n    needDecrease = 0\n    # Store nums[i - k + 1..i] with decreasing nums[i - k + 1].\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if i >= k:\n        needDecrease -= dq.popleft()\n      if nums[i] < needDecrease:\n        return False\n      decreasedNum = nums[i] - needDecrease\n      dq.append(decreasedNum)\n      needDecrease += decreasedNum\n\n    return dq[-1] == 0",
      "title": "2772. Apply Operations to Make All Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0b9ca5e-0dca-4c34-b746-9d539ef9ee36",
      "code": "class Solution:\n  def heightOfTree(self, root: TreeNode | None) -> int:\n    if not root:\n      return 0\n    # a leaf node\n    if root.left and root.left.right == root:\n      return 0\n    return 1 + max(self.heightOfTree(root.left), self.heightOfTree(root.right))",
      "title": "2773. Height of Special Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f31dbea6-26c1-46aa-b2c5-dc1dfaaf4ceb",
      "code": "class Solution:\n  def sumOfSquares(self, nums: list[int]) -> int:\n    return sum(num**2 for i, num in enumerate(nums)\n               if len(nums) % (i + 1) == 0)",
      "title": "2778. Sum of Squares of Special Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad77dc64-185d-4479-ad2e-cbfaee90cba3",
      "code": "class Solution:\n  def maximumBeauty(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r in range(len(nums)):\n      if nums[r] - nums[l] > 2 * k:\n        l += 1\n\n    return r - l + 1",
      "title": "2779. Maximum Beauty of an Array After Applying Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d101e33-acad-45fc-aea8-b71cd7f94a50",
      "code": "class Solution:\n  def minimumIndex(self, nums: list[int]) -> int:\n    count1 = collections.Counter()\n    count2 = collections.Counter(nums)\n\n    for i, num in enumerate(nums):\n      count1[num] = count1[num] + 1\n      count2[num] = count2[num] - 1\n      if count1[num] * 2 > i + 1 and count2[num] * 2 > len(nums) - i - 1:\n        return i\n\n    return -1",
      "title": "2780. Minimum Index of a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f4f0ba1-4610-4bae-8833-95ef4018a1c7",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str, l: int, r: int) -> bool:\n    node: TrieNode = self.root\n    for i in range(l, r):\n      if word[i] not in node.children:\n        return False\n      node = node.children[word[i]]\n    return node.isWord\n\n\nclass Solution:\n  def longestValidSubstring(self, word: str, forbidden: list[str]) -> int:\n    ans = 0\n    trie = Trie()\n\n    for s in forbidden:\n      trie.insert(s)\n\n    # r is the rightmost index to make word[l..r] a valid substring.\n    r = len(word) - 1\n    for l in range(len(word) - 1, -1, -1):\n      for end in range(l, min(l + 10, r + 1)):\n        if trie.search(word, l, end + 1):\n          r = end - 1\n          break\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2781. Length of the Longest Valid Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22d4ae35-03bc-40ba-bbaf-d615302eeb42",
      "code": "# Definition for a category handler.\n# class CategoryHandler:\n#   def haveSameCategory(self, a: int, b: int) -> bool:\n#     pass\n\nclass Solution:\n  def numberOfCategories(\n      self,\n      n: int,\n      categoryHandler: Optional['CategoryHandler'],\n  ) -> int:\n    ans = 0\n\n    for i in range(n):\n      if not any(categoryHandler.haveSameCategory(i, j) for j in range(i)):\n        ans += 1\n\n    return ans",
      "title": "2782. Number of Unique Categories",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5c41b84-1e03-4e62-b9a1-1a4b9d16927f",
      "code": "class Solution:\n  def isGood(self, nums: list[int]) -> bool:\n    n = len(nums) - 1\n    count = collections.Counter(nums)\n    return all(count[i] == 1 for i in range(1, n)) and count[n] == 2",
      "title": "2784. Check if Array is Good",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf65c085-8287-4fdf-a536-cced965512b4",
      "code": "class Solution:\n  def sortVowels(self, s: str) -> str:\n    VOWELS = 'aeiouAEIOU'\n    ans = []\n    vowels = sorted([c for c in s if c in VOWELS])\n\n    i = 0  # vowels' index\n    for c in s:\n      if c in VOWELS:\n        ans.append(vowels[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "2785. Sort Vowels in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fdf3ebf-4773-4a0e-ab2a-ca6d72fa5141",
      "code": "class Solution:\n  def maxScore(self, nums: list[int], x: int) -> int:\n    # Note that we always need to take nums[0], so the initial definition might\n    # not hold true.\n\n    # dp0 := the maximum score so far with `nums` ending in an even number\n    dp0 = nums[0] - (x if nums[0] % 2 == 1 else 0)\n    # dp0 := the maximum score so far with `nums` ending in an odd number\n    dp1 = nums[0] - (x if nums[0] % 2 == 0 else 0)\n\n    for i in range(1, len(nums)):\n      if nums[i] % 2 == 0:\n        dp0 = nums[i] + max(dp0, dp1 - x)\n      else:\n        dp1 = nums[i] + max(dp1, dp0 - x)\n\n    return max(dp0, dp1)",
      "title": "2786. Visit Array Positions to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3c319c6-3883-489a-ad05-501b37a5cc4e",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to express i\n    dp = [1] + [0] * n\n\n    for a in range(1, n + 1):\n      ax = a**x\n      if ax > n:\n        break\n      for i in range(n, ax - 1, -1):\n        dp[i] += dp[i - ax]\n        dp[i] %= MOD\n\n    return dp[n]",
      "title": "2787. Ways to Express an Integer as Sum of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17c8d2c5-6daa-4f92-ace4-c28d1d0dfc3e",
      "code": "class Solution:\n  def splitWordsBySeparator(\n      self,\n      words: list[str],\n      separator: str,\n  ) -> list[str]:\n    return [splitWord\n            for word in words\n            for splitWord in word.split(separator)\n            if splitWord]",
      "title": "2788. Split Strings by Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf91bd70-ad72-4964-9abc-c50474924d90",
      "code": "class Solution:\n  def maxArrayValue(self, nums: list[int]) -> int:\n    ans = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > ans:\n        ans = nums[i]\n      else:\n        ans += nums[i]\n\n    return ans",
      "title": "2789. Largest Element in an Array after Merge Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c451304-4608-45fd-b411-ec5b5dbd30c7",
      "code": "class Solution:\n  def maxIncreasingGroups(self, usageLimits: list[int]) -> int:\n    ans = 1  # the next target length\n    availableLimits = 0\n\n    for usageLimit in sorted(usageLimits):\n      availableLimits += usageLimit\n      # Can create groups 1, 2, ..., ans.\n      if availableLimits >= ans * (ans + 1) // 2:\n        ans += 1\n\n    return ans - 1",
      "title": "2790. Maximum Number of Groups With Increasing Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef8354d3-4f5b-4ca8-8e1c-2537064551bb",
      "code": "class Solution:\n  def countPalindromePaths(self, parent: list[int], s: str) -> int:\n    # A valid (u, v) has at most 1 letter with odd frequency on its path. The\n    # frequency of a letter on the u-v path is equal to the sum of its\n    # frequencies on the root-u and root-v paths substract twice of its\n    # frequency on the root-LCA(u, v) path. Considering only the parity\n    # (even/odd), the part involving root-LCA(u, v) can be ignored, making it\n    # possible to calculate both parts easily using a simple DFS.\n    tree = [[] for _ in parent]\n    maskToCount = collections.Counter({0: 1})\n\n    for i in range(1, len(parent)):\n      tree[parent[i]].append(i)\n\n    # mask := 26 bits that represent the parity of each character in the alphabet\n    # on the path from node 0 to node u\n    def dfs(u: int, mask: int) -> int:\n      res = 0\n      if u > 0:\n        mask ^= 1 << (ord(s[u]) - ord('a'))\n        # Consider any u-v path with 1 bit set.\n        for i in range(26):\n          res += maskToCount[mask ^ (1 << i)]\n        # Consider u-v path with 0 bit set.\n        res += maskToCount[mask ^ 0]\n        maskToCount[mask] += 1\n      for v in tree[u]:\n        res += dfs(v, mask)\n      return res\n\n    return dfs(0, 0)",
      "title": "2791. Count Paths That Can Form a Palindrome in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bdd5c48-e334-4245-8530-365f317e4cda",
      "code": "class Solution:\n  def countGreatEnoughNodes(self, root: TreeNode | None, k: int) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> list[int]:\n      nonlocal ans\n      if not root:\n        return []\n\n      kSmallest = sorted(dfs(root.left) + dfs(root.right))[:k]\n      if len(kSmallest) == k and root.val > kSmallest[-1]:\n        ans += 1\n\n      return kSmallest + [root.val]\n\n    dfs(root)\n    return ans",
      "title": "2792. Count Nodes That Are Great Enough",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bf6eaff-a4eb-40d0-aede-186cff352832",
      "code": "class Solution:\n  def numberOfEmployeesWhoMetTarget(self, hours: list[int], target: int) -> int:\n    return sum(hour >= target for hour in hours)",
      "title": "2798. Number of Employees Who Met the Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "614140b8-6d3d-4646-9ae8-2700dd603019",
      "code": "class Solution:\n  def countCompleteSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    distinct = len(set(nums))\n    count = collections.Counter()\n\n    l = 0\n    for num in nums:\n      count[num] += 1\n      while len(count) == distinct:\n        count[nums[l]] -= 1\n        if count[nums[l]] == 0:\n          del count[nums[l]]\n        l += 1\n      # Assume nums[r] = num,\n      # nums[0..r], nums[1..r], ..., nums[l - 1..r] have k different values.\n      ans += l\n\n    return ans",
      "title": "2799. Count Complete Subarrays in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cb69f52-7f32-4e20-9603-69ef89d4499e",
      "code": "class Solution:\n  def minimumString(self, a: str, b: str, c: str) -> str:\n    def merge(a: str, b: str) -> str:\n      \"\"\"Merges a and b.\"\"\"\n      if a in b:  # a is a substring of b.\n        return b\n      for i in range(len(a)):\n        aSuffix = a[i:]\n        bPrefix = b[:len(aSuffix)]\n        if aSuffix == bPrefix:\n          return a + b[len(bPrefix):]\n      return a + b\n\n    abc = merge(a, merge(b, c))\n    acb = merge(a, merge(c, b))\n    bac = merge(b, merge(a, c))\n    bca = merge(b, merge(c, a))\n    cab = merge(c, merge(a, b))\n    cba = merge(c, merge(b, a))\n    return self._getMin([abc, acb, bac, bca, cab, cba])\n\n  def _getMin(self, words: list[str]) -> str:\n    \"\"\"Returns the lexicographically smallest string.\"\"\"\n\n    def getMin(a: str, b: str) -> str:\n      \"\"\"Returns the lexicographically smaller string.\"\"\"\n      return a if len(a) < len(b) or (len(a) == len(b) and a < b) else b\n\n    res = words[0]\n    for i in range(1, len(words)):\n      res = getMin(res, words[i])\n    return res",
      "title": "2800. Shortest String That Contains Three Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a59ed2e-360c-48b0-8077-47f0072b2d94",
      "code": "class Solution:\n  def countSteppingNumbers(self, low: str, high: str) -> int:\n    MOD = 1_000_000_007\n    low = '0' * (len(high) - len(low)) + low\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        prevDigit: int,\n        isLeadingZero: bool,\n        tight1: bool,\n        tight2: bool,\n    ) -> int:\n      \"\"\"\n      Returns the number of valid integers, considering the i-th digit, where\n      `prevDigit` is the previous digit, `tight1` indicates if the current\n      digit is tightly bound for `low`, and `tight2` indicates if the current\n      digit is tightly bound for `high`.\n      \"\"\"\n      if i == len(high):\n        return 1\n\n      res = 0\n      minDigit = int(low[i]) if tight1 else 0\n      maxDigit = int(high[i]) if tight2 else 9\n\n      for d in range(minDigit, maxDigit + 1):\n        nextTight1 = tight1 and (d == minDigit)\n        nextTight2 = tight2 and (d == maxDigit)\n        if isLeadingZero:\n          # Can place any digit in [minDigit, maxDigit].\n          res += dp(i + 1, d, isLeadingZero and d ==\n                    0, nextTight1, nextTight2)\n        elif abs(d - prevDigit) == 1:\n          res += dp(i + 1, d, False, nextTight1, nextTight2)\n        res %= MOD\n\n      return res\n\n    return dp(0, -1, True, True, True)",
      "title": "2801. Count Stepping Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b88b67db-a3b2-4401-84e4-9766ee24f392",
      "code": "class Solution:\n  def kthLuckyNumber(self, k: int) -> str:\n    return bin(k + 1)[3:].replace('0', '4').replace('1', '7')",
      "title": "2802. Find The K-th Lucky Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c5feef-2ff1-450b-ac8a-b521d0d18d87",
      "code": "class Solution:\n  def accountBalanceAfterPurchase(self, purchaseAmount: int) -> int:\n    return 100 - ((purchaseAmount + 5) // 10) * 10",
      "title": "2806. Account Balance After Rounded Purchase",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8257802b-1350-4c02-b282-dd693f9ea2ef",
      "code": "class Solution:\n  def insertGreatestCommonDivisors(\n      self, head: ListNode | None\n  ) -> ListNode | None:\n    curr = head\n    while curr.next:\n      inserted = ListNode(math.gcd(curr.val, curr.next.val), curr.next)\n      curr.next = inserted\n      curr = inserted.next\n    return head",
      "title": "2807. Insert Greatest Common Divisors in Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5314b759-cc3a-4bd1-9475-1bd31f36418c",
      "code": "class Solution:\n  def minimumSeconds(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    def getSeconds(i: int, j: int) -> int:\n      \"\"\"Returns the number of seconds required to make nums[i..j] the same.\"\"\"\n      return (i - j) // 2\n\n    for indices in numToIndices.values():\n      seconds = getSeconds(indices[0] + n, indices[-1])\n      for i in range(1, len(indices)):\n        seconds = max(seconds, getSeconds(indices[i], indices[i - 1]))\n      ans = min(ans, seconds)\n\n    return ans",
      "title": "2808. Minimum Seconds to Equalize a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3f6e020-6c23-4dc1-a318-24e590a47dae",
      "code": "class Solution:\n  def minimumTime(self, nums1: list[int], nums2: list[int], x: int) -> int:\n    n = len(nums1)\n    # dp[i][j] := the maximum reduced value if we do j operations on the first\n    # i numbers\n    dp = [[0] * (n + 1) for _ in range(n + 1)]\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n\n    for i, (num2, num1) in enumerate(sorted(zip(nums2, nums1)), 1):\n      for j in range(1, i + 1):\n        dp[i][j] = max(\n            # the maximum reduced value if we do j operations on the first\n            # i - 1 numbers\n            dp[i - 1][j],\n            # the maximum reduced value if we do j - 1 operations on the first\n            # i - 1 numbers + making the i-th number of `nums1` to 0 at the\n            # j-th operation\n            dp[i - 1][j - 1] + num2 * j + num1\n        )\n\n    for op in range(n + 1):\n      if sum1 + sum2 * op - dp[n][op] <= x:\n        return op\n\n    return -1",
      "title": "2809. Minimum Time to Make Array Sum At Most x",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2365399-f2ac-46fb-9f57-b328ef168f15",
      "code": "class Solution:\n  def finalString(self, s: str) -> str:\n    dq = collections.deque()\n    inversed = False\n\n    for c in s:\n      if c == 'i':\n        inversed = not inversed\n      elif inversed:\n        dq.appendleft(c)\n      else:\n        dq.append(c)\n\n    return ''.join(reversed(dq)) if inversed else ''.join(dq)",
      "title": "2810. Faulty Keyboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82849472-b80d-4449-ad01-a52337bcbece",
      "code": "class Solution:\n  def canSplitArray(self, nums: list[int], m: int) -> bool:\n    return len(nums) < 3 or any(a + b >= m for a, b in itertools.pairwise(nums))",
      "title": "2811. Check if it is Possible to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77420459-37b0-4091-ab48-59fb24e84e75",
      "code": "class Solution:\n  def maximumSafenessFactor(self, grid: list[list[int]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    distToThief = self._getDistToThief(grid)\n\n    def hasValidPath(safeness: int) -> bool:\n      if distToThief[0][0] < safeness:\n        return False\n\n      q = collections.deque([(0, 0)])\n      seen = {(0, 0)}\n\n      while q:\n        i, j = q.popleft()\n        if distToThief[i][j] < safeness:\n          continue\n        if i == n - 1 and j == n - 1:\n          return True\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n      return False\n\n    return bisect.bisect_left(range(n * 2), True,\n                              key=lambda m: not hasValidPath(m)) - 1\n\n  def _getDistToThief(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    distToThief = [[0] * n for _ in range(n)]\n    q = collections.deque()\n    seen = set()\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] == 1:\n          q.append((i, j))\n          seen.add((i, j))\n\n    dist = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        distToThief[i][j] = dist\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == n or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      dist += 1\n\n    return distToThief",
      "title": "2812. Find the Safest Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2273e333-e581-4ec2-9951-bae108ea42d5",
      "code": "class Solution:\n  def findMaximumElegance(self, items: list[list[int]], k: int) -> int:\n    ans = 0\n    totalProfit = 0\n    seenCategories = set()\n    decreasingDuplicateProfits = []\n\n    items.sort(reverse=True)\n\n    for i in range(k):\n      profit, category = items[i]\n      totalProfit += profit\n      if category in seenCategories:\n        decreasingDuplicateProfits.append(profit)\n      else:\n        seenCategories.add(category)\n\n    ans = totalProfit + len(seenCategories)**2\n\n    for i in range(k, len(items)):\n      profit, category = items[i]\n      if category not in seenCategories and decreasingDuplicateProfits:\n        # If this is a new category we haven't seen before, it's worth\n        # considering taking it and replacing the one with the least profit\n        # since it will increase the distinct_categories and potentially result\n        # in a larger total_profit + distinct_categories^2.\n        totalProfit -= decreasingDuplicateProfits.pop()\n        totalProfit += profit\n        seenCategories.add(category)\n        ans = max(ans, totalProfit + len(seenCategories)**2)\n\n    return ans",
      "title": "2813. Maximum Elegance of a K-Length Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2f13b77-8bb7-42b6-88dc-665afe27375b",
      "code": "class Solution:\n  def minimumSeconds(self, land: list[list[str]]) -> int:\n    self.DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(land)\n    n = len(land[0])\n    floodDist = self._getFloodDist(land)\n    startPos = self._getStartPos(land, 'S')\n\n    q = collections.deque([startPos])\n    seen = {startPos}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] == 'D':\n            return step\n          if floodDist[x][y] <= step or land[x][y] == 'X' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1\n\n  def _getFloodDist(self, land: list[list[str]]) -> list[list[int]]:\n    m = len(land)\n    n = len(land[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    q = collections.deque()\n    seen = set()\n\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          q.append((i, j))\n          seen.add((i, j))\n\n    d = 0\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        dist[i][j] = d\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if land[x][y] in 'XD' or (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      d += 1\n\n    return dist\n\n  def _getStartPos(self, land: list[list[str]], c: str) -> tuple[int, int]:\n    for i, row in enumerate(land):\n      for j, cell in enumerate(row):\n        if cell == c:\n          return i, j",
      "title": "2814. Minimum Time Takes to Reach Destination Without Drowning",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56e3da50-7bcc-4798-9c10-b7614d44602b",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    ans = 0\n    # maxNum[i] := the maximum num we met so far with the maximum digit i\n    maxNum = [0] * 10\n\n    def getMaxDigit(num: int) -> int:\n      maxDigit = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        num //= 10\n      return maxDigit\n\n    for num in nums:\n      d = getMaxDigit(num)\n      if maxNum[d] > 0:\n        ans = max(ans, num + maxNum[d])\n      maxNum[d] = max(maxNum[d], num)\n\n    return -1 if ans == 0 else ans",
      "title": "2815. Max Pair Sum in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f85c236-d5bf-4c24-a90a-7aa6b53f08d8",
      "code": "class Solution:\n  def doubleIt(self, head: ListNode | None) -> ListNode | None:\n    def getCarry(node: ListNode | None) -> ListNode | None:\n      val = node.val * 2\n      if node.next:\n        val += getCarry(node.next)\n      node.val = val % 10\n      return val // 10\n\n    if getCarry(head) == 1:\n      return ListNode(1, head)\n    return head",
      "title": "2816. Double a Number Represented as a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2080a8fd-259f-4cb0-b255-ce35c42eef70",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def minAbsoluteDifference(self, nums: list[int], x: int) -> int:\n    ans = math.inf\n    seen = SortedSet()\n\n    for i in range(x, len(nums)):\n      seen.add(nums[i - x])\n      it = seen.bisect_left(nums[i])\n      if it != len(seen):\n        ans = min(ans, seen[it] - nums[i])\n      if it != 0:\n        ans = min(ans, nums[i] - seen[it - 1])\n\n    return ans",
      "title": "2817. Minimum Absolute Difference Between Elements With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf67863c-d8f4-4dc9-bb1d-d357395a3db8",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 1\n    minPrimeFactors = self._sieveEratosthenes(max(nums) + 1)\n    primeScores = [self._getPrimeScore(num, minPrimeFactors) for num in nums]\n    # left[i] := the next index on the left (if any)\n    #            s.t. primeScores[left[i]] >= primeScores[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. primeScores[right[i]] > primeScores[i]\n    right = [n] * n\n    stack = []\n\n    # Find the next indices on the left where `primeScores` are greater or equal.\n    for i in reversed(range(n)):\n      while stack and primeScores[stack[-1]] <= primeScores[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    # Find the next indices on the right where `primeScores` are greater.\n    for i in range(n):\n      while stack and primeScores[stack[-1]] < primeScores[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    numAndIndexes = [(num, i) for i, num in enumerate(nums)]\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    for num, i in sorted(numAndIndexes, key=lambda x: (-x[0], x[1])):\n      # nums[i] is the maximum value in the range [left[i] + 1, right[i] - 1]\n      # So, there are (i - left[i]) * (right[i] - 1) ranges where nums[i] will\n      # be chosen.\n      rangeCount = (i - left[i]) * (right[i] - i)\n      actualCount = min(rangeCount, k)\n      k -= actualCount\n      ans *= modPow(num, actualCount)\n      ans %= MOD\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 2 <= i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeScore(self, num: int, minPrimeFactors: list[int]) -> int:\n    primeFactors = set()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.add(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return len(primeFactors)",
      "title": "2818. Apply Operations to Maximize Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d26fa0-b339-4ed8-bb4d-e401354bafc2",
      "code": "class Solution:\n  def minimumRelativeLosses(\n      self,\n      prices: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    prices.sort()\n\n    prefix = list(itertools.accumulate(prices, initial=0))\n\n    for k, m in queries:\n      countFront = self._getCountFront(k, m, prices)\n      countBack = m - countFront\n      ans.append(self._getRelativeLoss(countFront, countBack, k, prefix))\n\n    return ans\n\n  def _getCountFront(\n      self,\n      k: int,\n      m: int,\n      prices: list[int],\n  ) -> int:\n    \"\"\"Returns `countFront` for query (k, m).\n\n    Returns `countFront` for query (k, m) s.t. picking the first `countFront`\n    and the last `m - countFront` chocolates is optimal.\n\n    Define loss[i] := the relative loss of picking `prices[i]`.\n    1. For prices[i] <= k, Bob pays prices[i] while Alice pays 0.\n       Thus, loss[i] = prices[i] - 0 = prices[i].\n    2. For prices[i] > k, Bob pays k while Alice pays prices[i] - k.\n       Thus, loss[i] = k - (prices[i] - k) = 2 * k - prices[i].\n    By observation, we deduce that it is always better to pick from the front\n    or the back since loss[i] is increasing for 1. and is decreasing for 2.\n\n    Assume that picking `left` chocolates from the left and `right = m - left`\n    chocolates from the right is optimal. Therefore, we are selecting\n    chocolates from `prices[0..left - 1]` and `prices[n - right..n - 1]`.\n\n    To determine the optimal `left` in each iteration, we simply compare\n    `loss[left]` with `loss[n - right]` if `loss[left] < loss[n - right]`,\n    it's worth increasing `left`.\n    \"\"\"\n    n = len(prices)\n    countNoGreaterThanK = bisect.bisect_right(prices, k)\n    l = 0\n    r = min(countNoGreaterThanK, m)\n\n    while l < r:\n      mid = (l + r) // 2\n      right = m - mid\n      # Picking prices[mid] is better than picking prices[n - right].\n      if prices[mid] < 2 * k - prices[n - right]:\n        l = mid + 1\n      else:\n        r = mid\n\n    return l\n\n  def _getRelativeLoss(\n      self,\n      countFront: int,\n      countBack: int,\n      k: int,\n      prefix: list[int],\n  ) -> int:\n    \"\"\"\n    Returns the relative loss of picking `countFront` and `countBack` \n    chocolates.\n    \"\"\"\n    lossFront = prefix[countFront]\n    lossBack = 2 * k * countBack - (prefix[-1] - prefix[-countBack - 1])\n    return lossFront + lossBack",
      "title": "2819. Minimum Relative Loss After Buying Chocolates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cb05562-0f7b-4515-bd3d-81237ce527c2",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], target: int) -> int:\n    return sum(nums[i] + nums[j] < target\n               for i in range(len(nums))\n               for j in range(i + 1, len(nums)))",
      "title": "2824. Count Pairs Whose Sum is Less than Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d886230-dfa7-4630-9a1a-a447d5fd0192",
      "code": "class Solution:\n  def canMakeSubsequence(self, str1: str, str2: str) -> bool:\n    i = 0  # str2's index\n\n    for c in str1:\n      if c == str2[i] or chr(\n              ord('a') + (ord(c) - ord('a') + 1) % 26) == str2[i]:\n        i += 1\n        if i == len(str2):\n          return True\n\n    return False",
      "title": "2825. Make String a Subsequence Using Cyclic Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecbe3b37-0c77-4aca-97ed-8bade26874ef",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # dp[i] := the longest non-decreasing subsequence so far with numbers in [1..i]\n    dp = [0] * 4\n\n    for num in nums:\n      dp[num] += 1  # Append num to the sequence so far.\n      dp[2] = max(dp[2], dp[1])\n      dp[3] = max(dp[3], dp[2])\n\n    return len(nums) - dp[3]",
      "title": "2826. Sorting Three Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d03660eb-5394-4133-83dd-faf3a9e6681b",
      "code": "class Solution:\n  def isAcronym(self, words: list[str], s: str) -> bool:\n    return (len(words) == len(s) and\n            all(word[0] == c for word, c in zip(words, s)))",
      "title": "2828. Check if a String Is an Acronym of Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5bb4f76-8bac-4ca9-b3c1-b98777c35195",
      "code": "class Solution:\n  def minimumSum(self, n: int, k: int) -> int:\n    # These are the unique pairs that sum up to k:\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = k // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return trapezoid(1, mid) + trapezoid(k, k + (n - mid - 1))",
      "title": "2829. Determine the Minimum Sum of a k-avoiding Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed8e413-9e22-434f-9eb8-e66e9ba46c20",
      "code": "class Solution:\n  def maximizeTheProfit(self, n: int, offers: list[list[int]]) -> int:\n    # dp[i] := the maximum amount of gold of selling the first i houses\n    dp = [0] * (n + 1)\n    endToStartAndGolds = [[] for _ in range(n)]\n\n    for start, end, gold in offers:\n      endToStartAndGolds[end].append((start, gold))\n\n    for end in range(1, n + 1):\n      # Get at least the same gold as selling the first `end - 1` houses.\n      dp[end] = dp[end - 1]\n      for start, gold in endToStartAndGolds[end - 1]:\n        dp[end] = max(dp[end], dp[start] + gold)\n\n    return dp[n]",
      "title": "2830. Maximize the Profit as the Salesman",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d61fcae-9723-4766-831e-2a61e28fd374",
      "code": "class Solution:\n  def longestEqualSubarray(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    # l and r track the maximum window instead of the valid window.\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      ans = max(ans, count[num])\n      if r - l + 1 - k > ans:\n        count[nums[l]] -= 1\n        l += 1\n\n    return ans",
      "title": "2831. Find the Longest Equal Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ad2969e-883f-43fd-bc5f-7259cf48022e",
      "code": "class Solution:\n  def maximumLengthOfRanges(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    stack = []  # a decreasing stack\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] < nums[i]):\n        index = stack.pop()\n        left = stack[-1] if stack else -1\n        ans[index] = i - left - 1\n      stack.append(i)\n\n    return ans",
      "title": "2832. Maximal Range That Each Element Is Maximum in It",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81287b27-54d5-447f-a11a-517ee6977326",
      "code": "class Solution:\n  def furthestDistanceFromOrigin(self, moves: str) -> int:\n    return abs(moves.count('L') - moves.count('R')) + moves.count('_')",
      "title": "2833. Furthest Point From Origin",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e7c66cd-4dd6-42c2-bd31-d681f40a354f",
      "code": "class Solution:\n  # Same as 2829. Determine the Minimum Sum of a k-avoiding Array\n  def minimumPossibleSum(self, n: int, target: int) -> int:\n    # These are the unique pairs that sum up to k (target):\n    # (1, k - 1), (2, k - 2), ..., (ceil(k // 2), floor(k // 2)).\n    # Our optimal strategy is to select 1, 2, ..., floor(k // 2), and then\n    # choose k, k + 1, ... if necessary, as selecting any number in the range\n    # [ceil(k // 2), k - 1] will result in a pair summing up to k.\n    MOD = 1_000_000_007\n\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    mid = target // 2  # floor(k // 2)\n    if n <= mid:\n      return trapezoid(1, n)\n    return (trapezoid(1, mid) + trapezoid(target, target + (n - mid - 1))) % MOD",
      "title": "2834. Find the Minimum Possible Sum of a Beautiful Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e200289-e4f3-4599-8b47-2cbcd1c9e7dc",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], target: int) -> int:\n    NO_MISSING_BIT = 31\n    maxBit = 31\n    ans = 0\n    minMissingBit = NO_MISSING_BIT\n    # count[i] := the number of occurrences of 2^i\n    count = collections.Counter(int(math.log2(num)) for num in nums)\n\n    for bit in range(maxBit):\n      # Check if `bit` is in the target.\n      if target >> bit & 1:\n        # If there are available bits, use one bit.\n        if count[bit] > 0:\n          count[bit] -= 1\n        else:\n          minMissingBit = min(minMissingBit, bit)\n      # If we previously missed a bit and there are available bits.\n      if minMissingBit != NO_MISSING_BIT and count[bit] > 0:\n        count[bit] -= 1\n        # Count the operations to break `bit` into `minMissingBit`.\n        ans += bit - minMissingBit\n        minMissingBit = NO_MISSING_BIT  # Set it to an the invalid value.\n      # Combining smaller numbers costs nothing.\n      count[bit + 1] += count[bit] // 2\n\n    # Check if all target bits have been covered, otherwise return -1.\n    return ans if minMissingBit == maxBit else -1",
      "title": "2835. Minimum Operations to Form Subsequence With Target Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9ebf87c-8e9f-4110-b91a-e337d5480d3a",
      "code": "class Solution:\n  def getMaxFunctionValue(self, receiver: list[int], k: int) -> int:\n    n = len(receiver)\n    m = int(math.log2(k)) + 1\n    ans = 0\n    # jump[i][j] := the the node you reach after jumping 2^j steps from i\n    jump = [[0] * m for _ in range(n)]\n    # summ[i][j] := the sum of the first 2^j nodes you reach when jumping from i\n    summ = [[0] * m for _ in range(n)]\n\n    for i in range(n):\n      jump[i][0] = receiver[i]\n      summ[i][0] = receiver[i]\n\n    # Calculate binary lifting.\n    for j in range(1, m):\n      for i in range(n):\n        midNode = jump[i][j - 1]\n        #   the the node you reach after jumping 2^j steps from i\n        # = the node you reach after jumping 2^(j - 1) steps from i\n        # + the node you reach after jumping another 2^(j - 1) steps\n        jump[i][j] = jump[midNode][j - 1]\n        #   the sum of the first 2^j nodes you reach when jumping from i\n        # = the sum of the first 2^(j - 1) nodes you reach when jumping from i\n        # + the sum of another 2^(j - 1) nodes you reach\n        summ[i][j] = summ[i][j - 1] + summ[midNode][j - 1]\n\n    for i in range(n):\n      currSum = i\n      currPos = i\n      for j in range(m):\n        if (k >> j) & 1 == 1:\n          currSum += summ[currPos][j]\n          currPos = jump[currPos][j]\n      ans = max(ans, currSum)\n\n    return ans",
      "title": "2836. Maximize Value of Function in a Ball Passing Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a3ae40d-63f0-4eb1-9195-398a8b4cf790",
      "code": "class Solution:\n  def maximumCoins(\n      self,\n      heroes: list[int],\n      monsters: list[int],\n      coins: list[int]\n  ) -> list[int]:\n    monsterAndCoins = sorted(list(zip(monsters, coins)))\n    coinsPrefix = list(itertools.accumulate(\n        (coin for _, coin in monsterAndCoins),\n        initial=0))\n    return [coinsPrefix[self._firstGreaterEqual(monsterAndCoins, hero)]\n            for hero in heroes]\n\n  def _firstGreaterEqual(\n      self,\n      monsterAndCoins: list[tuple[int, int]],\n      hero: int,\n  ) -> int:\n    l, r = 0, len(monsterAndCoins)\n    while l < r:\n      m = (l + r) // 2\n      if monsterAndCoins[m][0] > hero:\n        r = m\n      else:\n        l = m + 1\n    return l",
      "title": "2838. Maximum Coins Heroes Can Collect",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e108a49d-2486-451e-8db5-482905890530",
      "code": "class Solution:\n  def canBeEqual(self, s1: str, s2: str) -> bool:\n    def swappedStrings(s: str) -> list[str]:\n      chars = list(s)\n      return [chars,\n              ''.join([chars[2], chars[1], chars[0], chars[3]]),\n              ''.join([chars[0], chars[3], chars[2], chars[1]]),\n              ''.join([chars[2], chars[3], chars[0], chars[1]])]\n\n    return any(a == b\n               for a in swappedStrings(s1)\n               for b in swappedStrings(s2))",
      "title": "2839. Check if Strings Can be Made Equal With Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95d12b9a-66fc-4de9-990a-094debed3e2c",
      "code": "class Solution:\n  def checkStrings(self, s1: str, s2: str) -> bool:\n    count = [collections.Counter() for _ in range(2)]\n\n    for i, (a, b) in enumerate(zip(s1, s2)):\n      count[i % 2][a] += 1\n      count[i % 2][b] -= 1\n\n    return (all(freq == 0 for freq in count[0].values()) and\n            all(freq == 0 for freq in count[1].values()))",
      "title": "2840. Check if Strings Can be Made Equal With Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fc537bc-8268-495c-a8f8-2bfe4b975685",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], m: int, k: int) -> int:\n    ans = 0\n    summ = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if i >= k:\n        numToRemove = nums[i - k]\n        summ -= numToRemove\n        count[numToRemove] -= 1\n        if count[numToRemove] == 0:\n          del count[numToRemove]\n      if len(count) >= m:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2841. Maximum Sum of Almost Unique Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47a05ff8-2d7a-48fd-888a-908608207011",
      "code": "class Solution:\n  def countKSubsequencesWithMaxBeauty(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(s)\n    if len(count) < k:\n      return 0\n\n    ans = 1\n    # freqCount := (f(c), # of chars with f(c))\n    freqCount = collections.Counter(count.values())\n\n    for fc, numOfChars in list(sorted(freqCount.items(), reverse=True)):\n      if numOfChars >= k:\n        ans *= math.comb(numOfChars, k) * pow(fc, k, MOD)\n        return ans % MOD\n      ans *= pow(fc, numOfChars, MOD)\n      ans %= MOD\n      k -= numOfChars",
      "title": "2842. Count K-Subsequences of a String With Maximum Beauty Solved",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7eae30a8-42c9-4e10-afcc-3be4a83ba142",
      "code": "class Solution:\n  def countSymmetricIntegers(self, low: int, high: int) -> int:\n    def isSymmetricInteger(num: int) -> bool:\n      if num >= 10 and num <= 99:\n        return num // 10 == num % 10\n      if num >= 1000 and num <= 9999:\n        left = num // 100\n        right = num % 100\n        return left // 10 + left % 10 == right // 10 + right % 10\n      return False\n\n    return sum(isSymmetricInteger(num) for num in range(low, high + 1))",
      "title": "2843. Count Symmetric Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c149146-7e18-46df-8335-4776b9d10484",
      "code": "class Solution:\n  def minimumOperations(self, num: str) -> int:\n    n = len(num)\n    seenFive = False\n    seenZero = False\n\n    for i in range(n - 1, -1, -1):\n      if seenZero and num[i] == '0':  # '00'\n        return n - i - 2\n      if seenZero and num[i] == '5':  # '50'\n        return n - i - 2\n      if seenFive and num[i] == '2':  # '25'\n        return n - i - 2\n      if seenFive and num[i] == '7':  # '75'\n        return n - i - 2\n      seenZero = seenZero or num[i] == '0'\n      seenFive = seenFive or num[i] == '5'\n\n    return n - 1 if seenZero else n",
      "title": "2844. Minimum Operations to Make a Special Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01dda62d-18b0-4cae-8af7-4f8ef1f8bbde",
      "code": "class Solution:\n  def countInterestingSubarrays(\n      self,\n      nums: list[int],\n      modulo: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    prefix = 0  # (number of nums[i] % modulo == k so far) % modulo\n    prefixCount = collections.Counter({0: 1})\n\n    for num in nums:\n      if num % modulo == k:\n        prefix = (prefix + 1) % modulo\n      ans += prefixCount[(prefix - k + modulo) % modulo]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2845. Count of Interesting Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "332eeadc-cc51-477e-b106-2688abaf8f84",
      "code": "class Solution:\n  def minOperationsQueries(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    MAX = 26\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    # jump[i][j] := the 2^j-th ancestor of i\n    jump = [[0] * m for _ in range(n)]\n    # depth[i] := the depth of i\n    depth = [0] * n\n    # count[i][j] := the count of j from root to i, where 1 <= j <= 26\n    count = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    count[0] = [0] * (MAX + 1)\n    self._dfs(graph, 0, -1, jump, depth, count)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    def getMinOperations(u: int, v: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to make the edge weight\n      equilibrium between (u, v).\n      \"\"\"\n      lca = self._getLCA(u, v, jump, depth)\n      # the number of edges between (u, v).\n      numEdges = depth[u] + depth[v] - 2 * depth[lca]\n      # the maximum frequency of edges between (u, v)\n      maxFreq = max(count[u][j] + count[v][j] - 2 * count[lca][j]\n                    for j in range(1, MAX + 1))\n      return numEdges - maxFreq\n\n    return [getMinOperations(u, v) for u, v in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      count: list[list[int]]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      count[v] = count[u][:]\n      count[v][w] += 1\n      self._dfs(graph, v, u, jump, depth, count)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]",
      "title": "2846. Minimum Edge Weight Equilibrium Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84f89c0d-adbe-462e-8f33-3761646be102",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> str:\n    if n <= 9:\n      return str(n)\n\n    ans = []\n\n    for divisor in range(9, 1, -1):\n      while n % divisor == 0:\n        ans.append(str(divisor))\n        n //= divisor\n\n    return '-1' if n > 1 else ''.join(reversed(ans))",
      "title": "2847. Smallest Number With Given Digit Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "207beef3-8c11-46e2-a019-1b677ed8d726",
      "code": "class Solution:\n  def numberOfPoints(self, nums: list[list[int]]) -> int:\n    MAX = 100\n    ans = 0\n    runningSum = 0\n    count = [0] * (MAX + 2)\n\n    for start, end in nums:\n      count[start] += 1\n      count[end + 1] -= 1\n\n    for i in range(1, MAX + 1):\n      runningSum += count[i]\n      if runningSum > 0:\n        ans += 1\n\n    return ans",
      "title": "2848. Points That Intersect With Cars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fece91a6-4d85-45cb-ada0-6aeca3a2ae3a",
      "code": "class Solution:\n  def isReachableAtTime(\n      self,\n      sx: int,\n      sy: int,\n      fx: int,\n      fy: int,\n      t: int,\n  ) -> bool:\n    minStep = max(abs(sx - fx), abs(sy - fy))\n    return t != 1 if minStep == 0 else minStep <= t",
      "title": "2849. Determine if a Cell Is Reachable at a Given Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cefe449-93e7-4fc0-a20c-2f2dc31f713b",
      "code": "class Solution:\n  def minimumMoves(self, grid: list[list[int]]) -> int:\n    if sum(row.count(0) for row in grid) == 0:\n      return 0\n\n    ans = math.inf\n\n    for i in range(3):\n      for j in range(3):\n        if grid[i][j] == 0:\n          for x in range(3):\n            for y in range(3):\n              if grid[x][y] > 1:\n                grid[x][y] -= 1\n                grid[i][j] += 1\n                ans = min(ans, abs(x - i) + abs(y - j) +\n                          self.minimumMoves(grid))\n                grid[x][y] += 1\n                grid[i][j] -= 1\n\n    return ans",
      "title": "2850. Minimum Moves to Spread Stones Over Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d26675e2-79f5-4c98-b0c5-6e3e8e53f1b8",
      "code": "class Solution:\n  # This dynamic programming table dp[k][i] represents the number of ways to\n  # rearrange the String s after k steps such that it starts with s[i].\n  # A String can be rotated from 1 to n - 1 times. The transition rule is\n  # dp[k][i] = sum(dp[k - 1][j]) for all j != i. For example, when n = 4 and\n  # k = 3, the table looks like this:\n  #\n  # -----------------------------------------------------------\n  # |       | i = 0 | i = 1 | i = 2 | i = 3 | sum = (n - 1)^k |\n  # -----------------------------------------------------------\n  # | k = 0 |   1   |   0   |   0   |   0   |        1        |\n  # | k = 1 |   0   |   1   |   1   |   1   |        3        |\n  # | k = 2 |   3   |   2   |   2   |   2   |        9        |\n  # | k = 3 |   6   |   7   |   7   |   7   |       27        |\n  # -----------------------------------------------------------\n  #\n  # By observation, we have\n  #   * dp[k][!0] = ((n - 1)^k - (-1)^k) / n\n  #   * dp[k][0] = dp[k][!0] + (-1)^k\n  def numberOfWays(self, s: str, t: str, k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(s)\n    negOnePowK = 1 if k % 2 == 0 else -1  # (-1)^k\n    z = self._zFunction(s + t + t)\n    # indices in `s` s.t. for each `i` in the returned indices,\n    # `s[i..n) + s[0..i) = t`.\n    indices = [i - n for i in range(n, n + n) if z[i] >= n]\n    dp = [0] * 2  # dp[0] := dp[k][0]; dp[1] := dp[k][!0]\n    dp[1] = (pow(n - 1, k, MOD) - negOnePowK) * pow(n, MOD - 2, MOD)\n    dp[0] = dp[1] + negOnePowK\n    return sum(dp[0] if index == 0 else dp[1] for index in indices) % MOD\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "2851. String Transformation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ef78dd3-5bf2-4272-9eec-ef634dc920d0",
      "code": "class Solution:\n  def sumRemoteness(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    n = len(grid)\n    summ = sum(max(0, cell) for row in grid for cell in row)\n    ans = 0\n\n    def dfs(i: int, j: int) -> tuple[int, int]:\n      \"\"\"\n      Returns the (count, componentSum) of the connected component that contains\n      (x, y).\n      \"\"\"\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return (0, 0)\n      if grid[i][j] == -1:\n        return (0, 0)\n\n      count = 1\n      componentSum = grid[i][j]\n      grid[i][j] = -1  # Mark as visited.\n\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        nextCount, nextComponentSum = dfs(x, y)\n        count += nextCount\n        componentSum += nextComponentSum\n\n      return (count, componentSum)\n\n    for i in range(n):\n      for j in range(n):\n        if grid[i][j] > 0:\n          count, componentSum = dfs(i, j)\n          ans += (summ - componentSum) * count\n\n    return ans",
      "title": "2852. Sum of Remoteness of All Cells",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "833d5b24-ab35-451b-80d8-2836dc45a4cd",
      "code": "class Solution:\n  def minimumRightShifts(self, nums: list[int]) -> int:\n    count = 0\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      if a > b:\n        count += 1\n        pivot = i\n\n    if count == 0:\n      return 0\n    if count > 1 or nums[-1] > nums[0]:\n      return -1\n    return len(nums) - pivot - 1",
      "title": "2855. Minimum Right Shifts to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01d8ddb8-7415-4639-bd3c-4fc9bd9af8b2",
      "code": "class Solution:\n  def minLengthAfterRemovals(self, nums: list[int]) -> int:\n    n = len(nums)\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n\n    # The number with the maximum frequency cancel all the other numbers.\n    if maxFreq <= n / 2:\n      return n % 2\n    # The number with the maximum frequency cancel all the remaining numbers.\n    return maxFreq - (n - maxFreq)",
      "title": "2856. Minimum Array Length After Pair Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8dba854f-4e3c-439a-8d84-085c801595cc",
      "code": "class Solution:\n  def countPairs(self, coordinates: list[list[int]], k: int) -> int:\n    ans = 0\n\n    for x in range(k + 1):\n      y = k - x\n      count = collections.Counter()\n      for xi, yi in coordinates:\n        ans += count[(xi ^ x, yi ^ y)]\n        count[(xi, yi)] += 1\n\n    return ans",
      "title": "2857. Count Pairs of Points With Distance k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd8dda67-5d26-47cb-902b-3d955bba6c26",
      "code": "class Solution:\n  def minEdgeReversals(self, n: int, edges: list[list[int]]) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, True))  # 1 means (u -> v)\n      graph[v].append((u, False))  # 0 means (v <- u)\n\n    seen = {0}\n\n    @functools.lru_cache(None)\n    def dp(u: int) -> int:\n      \"\"\"\n      Returns the minimum number of edge reversals so node u can reach every\n      node in its subtree.\n      \"\"\"\n      res = 0\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        res += dp(v) + (0 if isForward else 1)\n      return res\n\n    ans = [0] * n\n    ans[0] = dp(0)\n\n    def dfs(u: int) -> None:\n      for v, isForward in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        ans[v] = ans[u] + (1 if isForward else -1)\n        dfs(v)\n\n    seen = {0}\n    dfs(0)\n    return ans",
      "title": "2858. Minimum Edge Reversals So Every Node Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1694881-0ca0-4071-9c34-d2edc5a6e527",
      "code": "class Solution:\n  def sumIndicesWithKSetBits(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if i.bit_count() == k)",
      "title": "2859. Sum of Values at Indices With K Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0ac1320-9b21-4ce2-8be5-efaf5cca9e07",
      "code": "class Solution:\n  def countWays(self, nums: list[int]) -> int:\n    return sum(a < i < b\n               for i, (a, b) in  # i := the number of the selected numbers\n               enumerate(itertools.pairwise([-1] + sorted(nums) + [math.inf])))",
      "title": "2860. Happy Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56c31baf-a95b-45bb-b7cb-a28fdbcb4cce",
      "code": "class Solution:\n  def maxNumberOfAlloys(self, n: int, k: int, budget: int,\n                        composition: list[list[int]], stock: list[int],\n                        costs: list[int]) -> int:\n    l = 1\n    r = 1_000_000_000\n\n    def isPossible(m: int) -> bool:\n      \"\"\"Returns True if it's possible to create `m` alloys by using any machine.\"\"\"\n      # Try all the possible machines.\n      for machine in composition:\n        requiredMoney = 0\n        for j in range(n):\n          requiredUnits = max(0, machine[j] * m - stock[j])\n          requiredMoney += requiredUnits * costs[j]\n        if requiredMoney <= budget:\n          return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "2861. Maximum Number of Alloys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f149ebe-da7e-416e-9bff-d5dcae89be52",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    ans = 0\n    oddPowerToSum = collections.Counter()\n\n    def divideSquares(val: int) -> int:\n      for num in range(2, val + 1):\n        while val % (num * num) == 0:\n          val //= (num * num)\n      return val\n\n    for i, num in enumerate(nums):\n      oddPower = divideSquares(i + 1)\n      oddPowerToSum[oddPower] += num\n      ans = max(ans, oddPowerToSum[oddPower])\n\n    return ans",
      "title": "2862. Maximum Element-Sum of a Complete Subset of Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2129fa7-cbc0-40d8-9d3c-1f643c771721",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for i in range(len(nums) - 1, -1, -1):\n      # If nums[stack[-1]] <= nums[i], stack[-1] is better than i.\n      # So, no need to append it.\n      if not stack or nums[stack[-1]] > nums[i]:\n        stack.append(i)\n\n    for i, num in enumerate(nums):\n      while stack and num > nums[stack[-1]]:\n        ans = max(ans, stack.pop() - i + 1)\n\n    return ans",
      "title": "2863. Maximum Length of Semi-Decreasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a25facfc-084c-461f-869a-f0d9fdd060b3",
      "code": "class Solution:\n  def maximumOddBinaryNumber(self, s: str) -> str:\n    return '1' * (s.count('1') - 1) + '0' * s.count('0') + '1'",
      "title": "2864. Maximum Odd Binary Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ba2fb0c-b27c-479a-ba9f-0780f1a1b50e",
      "code": "class Solution:\n  def maximumSumOfHeights(self, heights: list[int]) -> int:\n    n = len(heights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and heights[stack[-1]] > heights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are heights[j].\n        summ -= abs(j - stack[-1]) * heights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * heights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(heights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - heights[i]\n\n    return max(maxSum)",
      "title": "2865. Beautiful Towers I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8a14bc2-7607-4efe-8b8d-a3ea2fb6f63c",
      "code": "class Solution:\n  # Same as 2865. Beautiful Towers I\n  def maximumSumOfHeights(self, maxHeights: list[int]) -> int:\n    n = len(maxHeights)\n    maxSum = [0] * n  # maxSum[i] := the maximum sum with peak i\n\n    def process(stack: list[int], i: int, summ: int) -> int:\n      while len(stack) > 1 and maxHeights[stack[-1]] > maxHeights[i]:\n        j = stack.pop()\n        # The last abs(j - stack[-1]) heights are maxHeights[j].\n        summ -= abs(j - stack[-1]) * maxHeights[j]\n      # Put abs(i - stack[-1]) `maxHeight` in heights.\n      summ += abs(i - stack[-1]) * maxHeights[i]\n      stack.append(i)\n      return summ\n\n    stack = [-1]\n    summ = 0\n    for i in range(len(maxHeights)):\n      summ = process(stack, i, summ)\n      maxSum[i] = summ\n\n    stack = [n]\n    summ = 0\n    for i in range(n - 1, -1, -1):\n      summ = process(stack, i, summ)\n      maxSum[i] += summ - maxHeights[i]\n\n    return max(maxSum)",
      "title": "2866. Beautiful Towers II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65b02f9e-a9a1-40c3-bf81-76bbf8d4f658",
      "code": "class Solution:\n  def countPaths(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    isPrime = self._sieveEratosthenes(n + 1)\n    graph = [[] for _ in range(n + 1)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      nonlocal ans\n      countZeroPrimePath = int(not isPrime[u])\n      countOnePrimePath = int(isPrime[u])\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        countZeroPrimeChildPath, countOnePrimeChildPath = dfs(v, u)\n        ans += (countZeroPrimePath * countOnePrimeChildPath +\n                countOnePrimePath * countZeroPrimeChildPath)\n        if isPrime[u]:\n          countOnePrimePath += countZeroPrimeChildPath\n        else:\n          countZeroPrimePath += countZeroPrimeChildPath\n          countOnePrimePath += countOnePrimeChildPath\n\n      return countZeroPrimePath, countOnePrimePath\n\n    dfs(1, -1)\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2867. Count Valid Paths in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccdbbf95-06f3-48b3-bdc1-e474f040e683",
      "code": "class Solution:\n  def canAliceWin(self, a: list[str], b: list[str]) -> bool:\n    # words[0][i] := the biggest word starting with ('a' + i) for Alice\n    # words[1][i] := the biggest word starting with ('a' + i) for Bob\n    words = [[''] * 26 for _ in range(2)]\n\n    # For each letter, only the biggest word is useful.\n    for word in a:\n      words[0][ord(word[0]) - ord('a')] = word\n\n    for word in b:\n      words[1][ord(word[0]) - ord('a')] = word\n\n    # Find Alice's smallest word.\n    i = 0\n    while not words[0][i]:\n      i += 1\n\n    # 0 := Alice, 1 := Bob\n    # Start with Alice, so it's Bob's turn now.\n    turn = 1\n\n    # Iterate through each letter until we find a winner.\n    while True:\n      # If the current player has a word that having the letter that is greater\n      # than the opponent's word, choose it.\n      if words[turn][i] and words[turn][i] > words[1 - turn][i]:\n        # Choose the current words[turn][i].\n        pass\n      elif words[turn][i + 1]:\n        # Choose the next words[turn][i + 1].\n        i += 1\n      else:\n        # Game over. If it's Bob's turn, Alice wins, and vice versa.\n        return turn == 1\n      turn = 1 - turn",
      "title": "2868. The Wording Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66111865-94cb-4125-9ad9-6a3b3ef690e8",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    seen = set()\n\n    for i, num in enumerate(reversed(nums)):\n      if num > k:\n        continue\n      seen.add(num)\n      if len(seen) == k:\n        return i + 1",
      "title": "2869. Minimum Operations to Collect Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af041bed-2de6-4c51-b128-0c8e5f2060b5",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    if 1 in count.values():\n      return -1\n    return sum((freq + 2) // 3 for freq in count.values())",
      "title": "2870. Minimum Number of Operations to Make Array Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89169214-0798-4e79-89cf-c3cfc10cb455",
      "code": "class Solution:\n  def maxSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n\n    for num in nums:\n      score = num if score == 0 else score & num\n      if score == 0:\n        ans += 1\n\n    return max(1, ans)",
      "title": "2871. Split Array Into Maximum Number of Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bf1acae-5624-48e1-81fb-c202ce5bd51f",
      "code": "class Solution:\n  def maxKDivisibleComponents(\n      self,\n      n: int,\n      edges: list[list[int]],\n      values: list[int],\n      k: int,\n  ) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      treeSum = values[u]\n\n      for v in graph[u]:\n        if v != prev:\n          treeSum += dfs(v, u)\n\n      if treeSum % k == 0:\n        ans += 1\n      return treeSum\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    dfs(0, -1)\n    return ans",
      "title": "2872. Maximum Number of K-Divisible Components",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12f6a429-e0b2-4422-8a5b-ce95e9c018fb",
      "code": "class Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2873. Maximum Value of an Ordered Triplet I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2b437e8-d8fe-49b5-8361-c22cc41aca5b",
      "code": "class Solution:\n  # Same as 2873. Maximum Value of an Ordered Triplet I\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    maxDiff = 0  # max(nums[i] - nums[j])\n    maxNum = 0   # max(nums[i])\n\n    for num in nums:\n      ans = max(ans, maxDiff * num)         # num := nums[k]\n      maxDiff = max(maxDiff, maxNum - num)  # num := nums[j]\n      maxNum = max(maxNum, num)             # num := nums[i]\n\n    return ans",
      "title": "2874. Maximum Value of an Ordered Triplet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cbbe271-73ab-424b-942f-4d19d307cd17",
      "code": "class Solution:\n  def minSizeSubarray(self, nums: list[int], target: int) -> int:\n    summ = sum(nums)\n    n = len(nums)\n    remainingTarget = target % summ\n    repeatLength = (target // summ) * n\n    if remainingTarget == 0:\n      return repeatLength\n\n    suffixPlusPrefixLength = n\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i in range(2 * n):\n      prefix += nums[i % n]\n      if prefix - remainingTarget in prefixToIndex:\n        suffixPlusPrefixLength = min(\n            suffixPlusPrefixLength,\n            i - prefixToIndex[prefix - remainingTarget])\n      prefixToIndex[prefix] = i\n\n    return -1 if suffixPlusPrefixLength == n else suffixPlusPrefixLength + repeatLength",
      "title": "2875. Minimum Size Subarray in Infinite Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "503a11da-6667-46d4-b093-5e7a526bbc85",
      "code": "class Solution:\n  def countVisitedNodes(self, edges: list[int]) -> list[int]:\n    n = len(edges)\n    ans = [0] * n\n    inDegrees = [0] * n\n    seen = [False] * n\n    stack = []\n\n    for v in edges:\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    # Push non-cyclic nodes to stack.\n    while q:\n      u = q.popleft()\n      inDegrees[edges[u]] -= 1\n      if inDegrees[edges[u]] == 0:\n        q.append(edges[u])\n      stack.append(u)\n      seen[u] = True\n\n    # Fill the length of cyclic nodes.\n    for i in range(n):\n      if not seen[i]:\n        self._fillCycle(edges, i, seen, ans)\n\n    # Fill the length of non-cyclic nodes.\n    while stack:\n      u = stack.pop()\n      ans[u] = ans[edges[u]] + 1\n\n    return ans\n\n  def _fillCycle(\n      self,\n      edges: list[int],\n      start: int,\n      seen: list[bool],\n      ans: list[int],\n  ) -> None:\n    cycleLength = 0\n    u = start\n    while not seen[u]:\n      cycleLength += 1\n      seen[u] = True\n      u = edges[u]\n    ans[start] = cycleLength\n    u = edges[start]\n    while u != start:\n      ans[u] = cycleLength\n      u = edges[u]",
      "title": "2876. Count Visited Nodes in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ade5e011-81e8-4da1-8161-0f9a6391b357",
      "code": "class Solution:\n  def minArrayLength(self, nums: list[int], k: int) -> int:\n    count = 0\n    prod = -1\n\n    for num in nums:\n      if num == 0:\n        return 1\n      if prod != -1 and prod * num <= k:\n        prod *= num\n      else:\n        prod = num\n        count += 1\n\n    return count",
      "title": "2892. Minimizing Array After Replacing Pairs With Their Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b032002-7787-41e5-911b-e510c6c000fb",
      "code": "class Solution:\n  def differenceOfSums(self, n: int, m: int) -> int:\n    summ = (1 + n) * n // 2\n    num2 = self._getDivisibleSum(n, m)\n    num1 = summ - num2\n    return num1 - num2\n\n  def _getDivisibleSum(self, n: int, m: int) -> int:\n    \"\"\"Returns the sum of all the integers in [1, n] that are divisible by m.\"\"\"\n    last = n // m * m\n    if last == 0:\n      return 0\n    first = m\n    count = (last - first) // m + 1\n    return (first + last) * count // 2",
      "title": "2894. Divisible and Non-divisible Sums Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b072438-785c-4b5e-96d1-8aba9006de39",
      "code": "class Solution:\n  def minProcessingTime(\n      self,\n      processorTime: list[int],\n      tasks: list[int],\n  ) -> int:\n    return max(time + task\n               for (time, task) in zip(\n                   sorted(processorTime),\n                   sorted(tasks)[:: -4]))",
      "title": "2895. Minimum Processing Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06b87e18-b20a-42ec-b881-54af3ba1c5d0",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    #         dp := the minimum cost to correct diffIndices[i:]\n    #     dpNext := the minimum cost to correct diffIndices[i + 1:]\n    # dpNextNext := the minimum cost to correct diffIndices[i + 2:]\n    dpNext = x / 2\n    dpNextNext = 0\n\n    for i in reversed(range(len(diffIndices) - 1)):\n      dp = min(dpNext + x / 2,\n               dpNextNext + diffIndices[i + 1] - diffIndices[i])\n      dpNextNext = dpNext\n      dpNext = dp\n\n    return int(dp)",
      "title": "2896. Apply Operations to Make Two Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dba2160a-4d81-4bee-910f-505489c5f413",
      "code": "class Solution:\n  def minOperations(self, s1: str, s2: str, x: int) -> int:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    if not diffIndices:\n      return 0\n    # It's impossible to make two strings equal if there are odd number of\n    # differences.\n    if len(diffIndices) & 1:\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"Returns the minimum cost to correct diffIndices[i..n).\"\"\"\n      if i == len(diffIndices):\n        return 0\n      if i == len(diffIndices) - 1:\n        return x / 2\n      return min(dp(i + 1) + x / 2,\n                 dp(i + 2) + diffIndices[i + 1] - diffIndices[i])\n\n    return int(dp(0))",
      "title": "2896. Apply Operations to Make Two Strings Equal_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8acdf173-f2e9-4ecc-a878-c512d931877a",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = 0\n    # minIndices[i] := the minimum index in `optimalNums` that the i-th bit\n    # should be moved to\n    minIndices = [0] * MAX_BIT\n    optimalNums = [0] * len(nums)\n\n    for num in nums:\n      for i in range(MAX_BIT):\n        if num >> i & 1:\n          optimalNums[minIndices[i]] |= 1 << i\n          minIndices[i] += 1\n\n    for i in range(k):\n      ans += optimalNums[i]**2\n      ans %= MOD\n\n    return ans",
      "title": "2897. Apply Operations on Array to Maximize Sum of Squares",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c1c04eb-5e6a-4d34-886f-6c96c2b02856",
      "code": "class Solution:\n  def maxScore(self, prices: list[int]) -> int:\n    groupIdToSum = collections.defaultdict(int)\n\n    for i, price in enumerate(prices):\n      groupIdToSum[price - i] += price\n\n    return max(groupIdToSum.values())",
      "title": "2898. Maximum Linear Stock Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d2820a4-b715-4b29-9e23-62b1558d03a3",
      "code": "class Solution:\n  def lastVisitedIntegers(self, words: list[str]) -> list[int]:\n    ans = []\n    nums = []\n    k = 0\n\n    for word in words:\n      if word == 'prev':\n        k += 1\n        ans.append(-1 if k > len(nums) else nums[-k])\n      else:\n        k = 0\n        nums.append(int(word))\n\n    return ans",
      "title": "2899. Last Visited Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9a91a7f-dbc8-4674-af1d-b0979876f654",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    groupId = -1\n\n    for word, group in zip(words, groups):\n      if group != groupId:\n        groupId = group\n        ans.append(word)\n\n    return ans",
      "title": "2900. Longest Unequal Adjacent Groups Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9425ea27-6365-43b7-ae3e-c03bb7a80b0a",
      "code": "class Solution:\n  def getWordsInLongestSubsequence(\n      self,\n      n: int,\n      words: list[str],\n      groups: list[int],\n  ) -> list[str]:\n    ans = []\n    # dp[i] := the length of the longest subsequence ending in `words[i]`\n    dp = [1] * n\n    # prev[i] := the best index of words[i]\n    prev = [-1] * n\n\n    for i in range(1, n):\n      for j in range(i):\n        if groups[i] == groups[j]:\n          continue\n        if len(words[i]) != len(words[j]):\n          continue\n        if sum(a != b for a, b in zip(words[i], words[j])) != 1:\n          continue\n        if dp[i] < dp[j] + 1:\n          dp[i] = dp[j] + 1\n          prev[i] = j\n\n    # Find the last index of the subsequence.\n    index = dp.index(max(dp))\n    while index != -1:\n      ans.append(words[index])\n      index = prev[index]\n\n    return ans[::-1]",
      "title": "2901. Longest Unequal Adjacent Groups Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb396839-d764-478b-99c9-125a0abf575b",
      "code": "class Solution:\n  def countSubMultisets(self, nums: list[int], l: int, r: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of submultisets of `nums` with sum i\n    dp = [1] + [0] * r\n    count = collections.Counter(nums)\n    zeros = count.pop(0, 0)\n\n    for num, freq in count.items():\n      # stride[i] := dp[i] + dp[i - num] + dp[i - 2 * num] + ...\n      stride = dp.copy()\n      for i in range(num, r + 1):\n        stride[i] += stride[i - num]\n      for i in range(r, 0, -1):\n        if i >= num * (freq + 1):\n          # dp[i] + dp[i - num] + dp[i - freq * num]\n          dp[i] = stride[i] - stride[i - num * (freq + 1)]\n        else:\n          dp[i] = stride[i]\n\n    return (zeros + 1) * sum(dp[l:r + 1]) % MOD",
      "title": "2902. Count of Sub-Multisets With Bounded Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e42b7f0d-1e09-4d5b-94e8-0295e742077c",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the\n    # current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the\n    # current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2903. Find Indices With Index and Value Difference I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "476cd77a-5919-482a-92a7-1b63fb61e553",
      "code": "class Solution:\n  # Same as 76. Minimum Window Substring\n  def shortestBeautifulSubstring(self, s: str, k: int) -> str:\n    bestLeft = -1\n    minLength = len(s) + 1\n    ones = 0\n\n    l = 0\n    for r, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      while ones == k:\n        if r - l + 1 < minLength:\n          bestLeft = l\n          minLength = r - l + 1\n        elif r - l + 1 == minLength and s[l:l + minLength] < s[bestLeft:bestLeft + minLength]:\n          bestLeft = l\n        if s[l] == '1':\n          ones -= 1\n        l += 1\n\n    return \"\" if bestLeft == -1 else s[bestLeft:bestLeft + minLength]",
      "title": "2904. Shortest and Lexicographically Smallest Beautiful String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ebe4688-789b-48bd-8d56-9476dc1b4892",
      "code": "class Solution:\n  def findIndices(\n      self,\n      nums: list[int],\n      indexDifference: int,\n      valueDifference: int,\n  ) -> list[int]:\n    # nums[minIndex] := the minimum number with enough index different from the current number\n    minIndex = 0\n    # nums[maxIndex] := the maximum number with enough index different from the current number\n    maxIndex = 0\n\n    for i in range(indexDifference, len(nums)):\n      if nums[i - indexDifference] < nums[minIndex]:\n        minIndex = i - indexDifference\n      if nums[i - indexDifference] > nums[maxIndex]:\n        maxIndex = i - indexDifference\n      if nums[i] - nums[minIndex] >= valueDifference:\n        return [i, minIndex]\n      if nums[maxIndex] - nums[i] >= valueDifference:\n        return [i, maxIndex]\n\n    return [-1, -1]",
      "title": "2905. Find Indices With Index and Value Difference II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccce419d-6e04-40b7-a888-240f322d56d9",
      "code": "class Solution:\n  def constructProductMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    MOD = 12345\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [1]\n    suffix = 1\n\n    for row in grid:\n      for num in row:\n        prefix.append(prefix[-1] * num % MOD)\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        ans[i][j] = prefix[i * n + j] * suffix % MOD\n        suffix = suffix * grid[i][j] % MOD\n\n    return ans",
      "title": "2906. Construct Product Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "418b162a-b420-43c5-a772-a27e6065ef13",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2907. Maximum Profitable Triplets With Increasing Prices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6542fcd-237a-44f0-826a-7f417c253b05",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2908. Minimum Sum of Mountain Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "563da14b-8a3a-4830-b76a-f006baa0ad5c",
      "code": "class Solution:\n  # Same as 2908. Minimum Sum of Mountain Triplets I\n  def minimumSum(self, nums: list[int]) -> int:\n    ans = math.inf\n    minPrefix = list(itertools.accumulate(nums, min))\n    minSuffix = list(itertools.accumulate(reversed(nums), min))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > minPrefix[i] and num > minSuffix[i]:\n        ans = min(ans, num + minPrefix[i] + minSuffix[i])\n\n    return -1 if ans == math.inf else ans",
      "title": "2909. Minimum Sum of Mountain Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b40cbb4d-a145-4d11-9f8e-6e3e2a1a3bfb",
      "code": "class Solution:\n  def minGroupsForValidAssignment(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    minFreq = min(count.values())\n\n    for groupSize in range(minFreq, 0, -1):\n      numGroups = self.getNumGroups(count, groupSize)\n      if numGroups > 0:\n        return numGroups\n\n    raise ValueError(\"Invalid argument\")\n\n  def getNumGroups(self, count: dict[int, int], groupSize: int) -> int:\n    \"\"\"Returns the number of groups if each group's size is `groupSize` or `groupSize + 1`.\"\"\"\n    numGroups = 0\n    for freq in count.values():\n      a = freq // (groupSize + 1)\n      b = freq % (groupSize + 1)\n      if b == 0:\n        # Assign 1 number from `groupSize - b` out of `a` groups to this group,\n        # so we'll have `a - (groupSize - b)` groups of size `groupSize + 1`\n        # and `groupSize - b + 1` groups of size `groupSize`. In total, we have\n        # `a + 1` groups.\n        numGroups += a\n      elif groupSize - b <= a:\n        numGroups += a + 1\n      else:\n        return 0\n    return numGroups",
      "title": "2910. Minimum Number of Groups to Create a Valid Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5db810b6-66b1-40c0-b633-d91b693455e3",
      "code": "class Solution:\n  def minimumChanges(self, s: str, k: int) -> int:\n    n = len(s)\n    # factors[i] := factors of i\n    factors = self._getFactors(n)\n    # cost[i][j] := changes to make s[i..j] a semi-palindrome\n    cost = self._getCost(s, n, factors)\n    # dp[i][j] := the minimum changes to split s[i:] into j valid parts\n    dp = [[n] * (k + 1) for _ in range(n + 1)]\n\n    dp[n][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(1, k + 1):\n        for l in range(i + 1, n):\n          dp[i][j] = min(dp[i][j], dp[l + 1][j - 1] + cost[i][l])\n\n    return dp[0][k]\n\n  def _getFactors(self, n: int) -> list[list[int]]:\n    factors = [[1] for _ in range(n + 1)]\n    for d in range(2, n):\n      for i in range(d * 2, n + 1, d):\n        factors[i].append(d)\n    return factors\n\n  def _getCost(self, s: str, n: int, factors: list[list[int]]) -> list[list[int]]:\n    cost = [[0] * n for _ in range(n)]\n    for i, j in itertools.combinations(range(n), 2):\n      length = j - i + 1\n      minCost = length\n      for d in factors[length]:\n        minCost = min(minCost, self._getCostD(s, i, j, d))\n      cost[i][j] = minCost\n    return cost\n\n  def _getCostD(self, s: str, i: int, j: int, d: int) -> int:\n    \"\"\"Returns the cost to make s[i..j] a semi-palindrome of `d`.\"\"\"\n    cost = 0\n    for offset in range(d):\n      l = i + offset\n      r = j - d + 1 + offset\n      while l < r:\n        if s[l] != s[r]:\n          cost += 1\n        l += d\n        r -= d\n    return cost",
      "title": "2911. Minimum Changes to Make K Semi-palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d483c51-23c4-4c05-96a4-9acd3c27ec8a",
      "code": "class Solution:\n  def numberOfWays(\n      self,\n      n: int,\n      m: int,\n      k: int,\n      source: list[int],\n      dest: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i][0] := the the number of ways of `source` to `dest` using i steps\n    # dp[i][1] := the the number of ways of `source` to dest's row using i steps\n    # dp[i][2] := the the number of ways of `source` to dest's col using i steps\n    # dp[i][3] := the the number of ways of `source` to others using i steps\n    dp = [[0] * 4 for _ in range(k + 1)]\n    if source == dest:\n      dp[0][0] = 1\n    elif source[0] == dest[0]:\n      dp[0][1] = 1\n    elif source[1] == dest[1]:\n      dp[0][2] = 1\n    else:\n      dp[0][3] = 1\n\n    for i in range(1, k + 1):\n      dp[i][0] = (dp[i - 1][1] + dp[i - 1][2]) % MOD\n      dp[i][1] = (dp[i - 1][0] * (m - 1) +  # -self\n                  dp[i - 1][1] * (m - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][2] = (dp[i - 1][0] * (n - 1) +  # -self\n                  dp[i - 1][2] * (n - 2) +  # -self, -center\n                  dp[i - 1][3]) % MOD\n      dp[i][3] = (dp[i - 1][1] * (n - 1) +  # -self\n                  dp[i - 1][2] * (m - 1) +  # -self\n                  dp[i - 1][3] * (m + n - 1 - 3)) % MOD  # -self, -row, -col\n\n    return dp[k][0]",
      "title": "2912. Number of Ways to Reach Destination in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4aaadad2-9d5d-4441-b58f-2b17628e81c5",
      "code": "class Solution:\n  def minChanges(self, s: str) -> int:\n    return sum(a != b for a, b in zip(s[::2], s[1::2]))",
      "title": "2914. Minimum Number of Changes to Make Binary String Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03f24bf8-47ef-4ef4-9479-301b645fa07e",
      "code": "class Solution:\n  def lengthOfLongestSubsequence(self, nums: list[int], target: int) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum length of any subsequence of the first i numbers\n    # that sum to j\n    dp = [[-1] * (target + 1) for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      dp[i][0] = 0\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(1, target + 1):\n        # 1. Skip `num`.\n        if j < num or dp[i - 1][j - num] == -1:\n          dp[i][j] = dp[i - 1][j]\n        # 2. Skip `num` or pick `num`.\n        else:\n          dp[i][j] = max(dp[i - 1][j], 1 + dp[i - 1][j - num])\n\n    return dp[n][target]",
      "title": "2915. Length of the Longest Subsequence That Sums to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6e4cd15-6d51-4187-a566-e64a6732d874",
      "code": "class Solution:\n  def findKOr(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    return sum(2**i\n               for i in range(MAX_BIT + 1)\n               if sum(num >> i & 1 for num in nums) >= k)",
      "title": "2917. Find the K-or of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8fea0a6-0dd4-47be-9450-6366d282ed3f",
      "code": "class Solution:\n  def minSum(self, nums1: list[int], nums2: list[int]) -> int:\n    sum1 = sum(nums1)\n    sum2 = sum(nums2)\n    zero1 = nums1.count(0)\n    zero2 = nums2.count(0)\n    if zero1 == 0 and sum1 < sum2 + zero2:\n      return -1\n    if zero2 == 0 and sum2 < sum1 + zero1:\n      return -1\n    return max(sum1 + zero1, sum2 + zero2)",
      "title": "2918. Minimum Equal Sum of Two Arrays After Replacing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dce8c60a-90ed-4b2c-9c88-fe5f70c9a8d7",
      "code": "class Solution:\n  def minIncrementOperations(self, nums: list[int], k: int) -> int:\n    # the minimum operations to increase nums[i - 3] and nums[0..i - 3)\n    prev3 = 0\n    # the minimum operations to increase nums[i - 2] and nums[0..i - 2)\n    prev2 = 0\n    # the minimum operations to increase nums[i - 1] and nums[0..i - 1)\n    prev1 = 0\n\n    for num in nums:\n      dp = min(prev1, prev2, prev3) + max(0, k - num)\n      prev3 = prev2\n      prev2 = prev1\n      prev1 = dp\n\n    return min(prev1, prev2, prev3)",
      "title": "2919. Minimum Increment Operations to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfe4dcee-fe86-4867-bcb3-c987bb8c819c",
      "code": "class Solution:\n  def maximumPoints(\n      self,\n      edges: list[list[int]],\n      coins: list[int],\n      k: int,\n  ) -> int:\n    MAX_COIN = 10000\n    MAX_HALVED = int(MAX_COIN).bit_length()\n    n = len(coins)\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dfs(u: int, prev: int, halved: int) -> int:\n      # All the children will be 0, so no need to explore.\n      if halved > MAX_HALVED:\n        return 0\n\n      val = coins[u] // (1 << halved)\n      takeAll = val - k\n      takeHalf = math.floor(val / 2)\n\n      for v in graph[u]:\n        if v == prev:\n          continue\n        takeAll += dfs(v, u, halved)\n        takeHalf += dfs(v, u, halved + 1)\n\n      return max(takeAll, takeHalf)\n\n    return dfs(0, -1, 0)",
      "title": "2920. Maximum Points After Collecting Coins From All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ee0e05b-5bcf-46c4-ba28-519e7a793345",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  # Same as 2907. Maximum Profitable Triplets With Increasing Prices I\n  def maxProfit(self, prices: list[int], profits: list[int]) -> int:\n    ans = -1\n    maxPrice = max(prices)\n    maxProfitTree1 = FenwickTree(maxPrice)\n    maxProfitTree2 = FenwickTree(maxPrice)\n\n    for price, profit in zip(prices, profits):\n      # max(proftis[i])\n      maxProfit1 = maxProfitTree1.get(price - 1)\n      # max(proftis[i]) + max(profits[j])\n      maxProfit2 = maxProfitTree2.get(price - 1)\n      maxProfitTree1.maximize(price, profit)\n      if maxProfit1 > 0:\n        maxProfitTree2.maximize(price, profit + maxProfit1)\n      if maxProfit2 > 0:\n        ans = max(ans, profit + maxProfit2)\n\n    return ans",
      "title": "2921. Maximum Profitable Triplets With Increasing Prices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9d39c214-11d5-4415-9dc9-06a475cd5995",
      "code": "class Solution:\n  def findChampion(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    inDegrees = [0] * n\n\n    for i in range(n):\n      for j in range(n):\n        if i == j:\n          continue\n        if grid[i][j] == 1:\n          inDegrees[j] += 1\n        else:\n          inDegrees[i] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2923. Find Champion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd0845c0-689c-4cb8-9125-741365d51bdc",
      "code": "class Solution:\n  def findChampion(self, n: int, edges: list[list[int]]) -> int:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return (-1 if inDegrees.count(0) > 1\n            else inDegrees.index(0))",
      "title": "2924. Find Champion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e573ff9-00c1-4fe0-a589-6268c192db9c",
      "code": "class Solution:\n  def maximumScoreAfterOperations(\n      self,\n      edges: list[list[int]],\n      values: list[int],\n  ) -> int:\n    tree = [[] for _ in values]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      if u > 0 and len(tree[u]) == 1:\n        return values[u]\n      childrenSum = sum(dfs(v, u)\n                        for v in tree[u]\n                        if v != prev)\n      return min(childrenSum, values[u])\n\n    return sum(values) - dfs(0, -1)",
      "title": "2925. Maximum Score After Applying Operations on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25dd8bd4-118c-47ac-b9ef-09d2beb63097",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    \"\"\"Updates the maximum sum of subsequence ending in (i - 1) with `val`.\"\"\"\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    \"\"\"Returns the maximum sum of subsequence ending in (i - 1).\"\"\"\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowbit(i)\n    return res\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def maxBalancedSubsequenceSum(self, nums: list[int]) -> int:\n    # Let's define maxSum[i] := subsequence with the maximum sum ending in i\n    # By observation:\n    #    nums[i] - nums[j] >= i - j\n    # => nums[i] - i >= nums[j] - j\n    # So, if nums[i] - i >= nums[j] - j, where i > j,\n    # maxSum[i] = max(maxSum[i], maxSum[j] + nums[i])\n    ans = -math.inf\n    tree = FenwickTree(len(nums))\n\n    for _, i in sorted([(num - i, i) for i, num in enumerate(nums)]):\n      subseqSum = tree.get(i) + nums[i]\n      tree.maximize(i + 1, subseqSum)\n      ans = max(ans, subseqSum)\n\n    return ans",
      "title": "2926. Maximum Balanced Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea1ea507-a9f3-4264-aae1-e6b30c5cb7e7",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2927. Distribute Candies Among Children III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9de88f0-4d30-48c3-bdca-1b00c20cdd89",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2928. Distribute Candies Among Children I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57ed26cd-96d6-44f9-8bb3-75aec67f91ae",
      "code": "class Solution:\n  def distributeCandies(self, n: int, limit: int) -> int:\n    def ways(n: int) -> int:\n      \"\"\"Returns the number of ways to distribute n candies to 3 children.\"\"\"\n      if n < 0:\n        return 0\n      # Stars and bars method:\n      # e.g. '**|**|*' means to distribute 5 candies to 3 children, where\n      # stars (*) := candies and bars (|) := dividers between children.\n      return math.comb(n + 2, 2)\n\n    limitPlusOne = limit + 1\n    oneChildExceedsLimit = ways(n - limitPlusOne)\n    twoChildrenExceedLimit = ways(n - 2 * limitPlusOne)\n    threeChildrenExceedLimit = ways(n - 3 * limitPlusOne)\n    # Principle of Inclusion-Exclusion (PIE)\n    return (ways(n)\n            - 3 * oneChildExceedsLimit\n            + 3 * twoChildrenExceedLimit\n            - threeChildrenExceedLimit)",
      "title": "2929. Distribute Candies Among Children II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "873dac4b-25bd-46c1-b265-53b84f416e65",
      "code": "class Solution:\n  def stringCount(self, n: int) -> int:\n    # There're three invalid conditions:\n    #   a. count('l') == 0\n    #   b. count('e') < 2\n    #   c. count('t') == 0\n    #\n    # By Principle of Inclusion-Exclusion (PIE):\n    #   ans = allCount - a - b - c + ab + ac + bc - abc\n    MOD = 1_000_000_007\n    allCount = pow(26, n, MOD)\n    a = pow(25, n, MOD)\n    b = pow(25, n, MOD)\n    c = pow(25, n, MOD) + n * pow(25, n - 1, MOD)\n    ab = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    ac = pow(24, n, MOD)\n    bc = pow(24, n, MOD) + n * pow(24, n - 1, MOD)\n    abc = pow(23, n, MOD) + n * pow(23, n - 1, MOD)\n    return (allCount - a - b - c + ab + ac + bc - abc) % MOD",
      "title": "2930. Number of Strings Which Can Be Rearranged to Contain Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c57d507-18bd-4d41-bff7-1f133ceb67c4",
      "code": "class Solution:\n  def maxSpending(self, values: list[list[int]]) -> int:\n    items = sorted(item for shop in values for item in shop)\n    return sum(item * d for d, item in enumerate(items, 1))",
      "title": "2931. Maximum Spending After Buying Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27786cfe-141f-43dd-aba5-ab2834e34841",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Similar to 421. Maximum XOR of Two Numbers in an Array\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2932. Maximum Strong Pair XOR I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ac243f1-aff9-483a-9516-56632dadcbe4",
      "code": "class Solution:\n  def findHighAccessEmployees(self, access_times: list[list[str]]) -> list[str]:\n    ans = set()\n\n    access_times.sort()\n\n    for i in range(len(access_times) - 2):\n      name = access_times[i][0]\n      if name in ans:\n        continue\n      if name != access_times[i + 2][0]:\n        continue\n      if int(access_times[i + 2][1]) - int(access_times[i][1]) < 100:\n        ans.add(name)\n\n    return list(ans)",
      "title": "2933. High-Access Employees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a56a558-a766-4774-bbd1-fab788953f41",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    mn = min(nums1[-1], nums2[-1])\n    mx = max(nums1[-1], nums2[-1])\n    # the number of the minimum operations, where nums1[n - 1] is not swapped\n    # with nums2[n - 1]\n    dp1 = 0\n    # the number of the minimum operations, where nums1[n - 1] is swapped with\n    # nums2[n - 1]\n    dp2 = 0\n\n    for a, b in zip(nums1, nums2):\n      if min(a, b) > mn:\n        return -1\n      if max(a, b) > mx:\n        return -1\n      if a > nums1[-1] or b > nums2[-1]:\n        dp1 += 1\n      if a > nums2[-1] or b > nums1[-1]:\n        dp2 += 1\n\n    return min(dp1, dp2)",
      "title": "2934. Minimum Operations to Maximize Last Elements in Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ec1f308-5f3e-4694-92b6-be8d9817896c",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.mn = math.inf\n    self.mx = -math.inf\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.mn = min(node.mn, num)\n      node.mx = max(node.mx, num)\n\n  def getMaxXor(self, x: int) -> int:\n    \"\"\"Returns max(x ^ y) where |x - y| <= min(x, y).\n\n    If x <= y, |x - y| <= min(x, y) can be written as y - x <= x.\n    So, y <= 2 * x.\n    \"\"\"\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = x >> i & 1\n      toggleBit = bit ^ 1\n      # If `node.children[toggleBit].mx > x`, it means there's a number in the\n      # node that satisfies the condition to ensure that x <= y among x and y.\n      # If `node.children[toggleBit].mn <= 2 * x`, it means there's a number in\n      # the node that satisfies the condition for a valid y.\n      if (node.children[toggleBit] and\n          node.children[toggleBit].mx > x and\n              node.children[toggleBit].mn <= 2 * x):\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  # Same as 2932. Maximum Strong Pair XOR I\n  def maximumStrongPairXor(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    maxBit = int(math.log2(maxNum))\n    bitTrie = BitTrie(maxBit)\n\n    for num in nums:\n      bitTrie.insert(num)\n\n    return max(bitTrie.getMaxXor(num) for num in nums)",
      "title": "2935. Maximum Strong Pair XOR II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5698da3e-3d1e-43d7-811b-aee68bca548f",
      "code": "# Definition for BigArray.\n# class BigArray:\n#   def at(self, index: long) -> int:\n#     pass\n#   def size(self) -> long:\n#     pass\n\nclass Solution(object):\n  def countBlocks(self, nums: Optional['BigArray']) -> int:\n    def countBlocks(l: int, r: int, leftValue: int, rightValue: int) -> int:\n      \"\"\"Returns the number of maximal blocks in nums[l..r].\"\"\"\n      if leftValue == rightValue:\n        return 1\n      if l + 1 == r:\n        return 2\n      m = (l + r) // 2\n      midValue = nums.at(m)\n      return (countBlocks(l, m, leftValue, midValue) +\n              countBlocks(m, r, midValue, rightValue) - 1)\n    # Substract nums[m], which will be counted twice.\n    return countBlocks(0, nums.size() - 1,\n                       nums.at(0), nums.at(nums.size() - 1))",
      "title": "2936. Number of Equal Numbers Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba42855e-1e83-4669-a31b-b82587523768",
      "code": "class Solution:\n  def findMinimumOperations(self, s1: str, s2: str, s3: str) -> int:\n    minLength = min(map(len, [s1, s2, s3]))\n    i = 0\n    while i < minLength and s1[i] == s2[i] and s2[i] == s3[i]:\n      i += 1\n    return -1 if i == 0 else len(s1) + len(s2) + len(s3) - i * 3",
      "title": "2937. Make Three Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1e33863-27d1-471c-bf3d-f89b552b4000",
      "code": "class Solution:\n  def minimumSteps(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for c in s:\n      if c == '1':\n        ones += 1\n      else:  # Move 1s to the front of the current '0'.\n        ans += ones\n\n    return ans",
      "title": "2938. Separate Black and White Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "116d6e21-ee49-4b1e-80d3-640ed8615363",
      "code": "class Solution:\n  def maximumXorProduct(self, a: int, b: int, n: int) -> int:\n    MOD = 1_000_000_007\n    for bit in (2**i for i in range(n)):\n      # Pick a bit if it makes min(a, b) larger.\n      if a * b < (a ^ bit) * (b ^ bit):\n        a ^= bit\n        b ^= bit\n    return a * b % MOD",
      "title": "2939. Maximum Xor Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a2ff08a-945f-42ac-886b-68d138d40675",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass IndexedQuery:\n  queryIndex: int\n  a: int  # Alice's index\n  b: int  # Bob's index\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.a\n    yield self.b\n\n\nclass Solution:\n  # Similar to 2736. Maximum Sum Queries\n  def leftmostBuildingQueries(\n      self,\n      heights: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [-1] * len(queries)\n    # Store indices (heightsIndex) of heights with heights[heightsIndex] in\n    # descending order.\n    stack = []\n\n    # Iterate through queries and heights simultaneously.\n    heightsIndex = len(heights) - 1\n    for queryIndex, a, b in sorted([IndexedQuery(i, min(a, b), max(a, b))\n                                    for i, (a, b) in enumerate(queries)],\n                                   key=lambda x: -x.b):\n      if a == b or heights[a] < heights[b]:\n        # 1. Alice and Bob are already in the same index (a == b) or\n        # 2. Alice can jump from a -> b (heights[a] < heights[b]).\n        ans[queryIndex] = b\n      else:\n        # Now, a < b and heights[a] >= heights[b].\n        # Gradually add heights with an index > b to the monotonic stack.\n        while heightsIndex > b:\n          # heights[heightsIndex] is a better candidate, given that\n          # heightsIndex is smaller than the indices in the stack and\n          # heights[heightsIndex] is larger or equal to the heights mapped in\n          # the stack.\n          while stack and heights[stack[-1]] <= heights[heightsIndex]:\n            stack.pop()\n          stack.append(heightsIndex)\n          heightsIndex -= 1\n        # Binary search to find the smallest index j such that j > b and\n        # heights[j] > heights[a], thereby ensuring heights[j] > heights[b].\n        j = self._lastGreater(stack, a, heights)\n        if j != -1:\n          ans[queryIndex] = stack[j]\n\n    return ans\n\n  def _lastGreater(self, A: list[int], target: int, heights: list[int]):\n    \"\"\"\n    Returns the last index i in A s.t. heights[A.get(i)] is > heights[target].\n    \"\"\"\n    l = -1\n    r = len(A) - 1\n    while l < r:\n      m = (l + r + 1) // 2\n      if heights[A[m]] > heights[target]:\n        l = m\n      else:\n        r = m - 1\n    return l",
      "title": "2940. Find Building Where Alice and Bob Can Meet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f202e72f-a5dc-4b70-8141-552beb478dcf",
      "code": "class Solution:\n  def maxGcdSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # [(startIndex, gcd of subarray starting at startIndex)]\n    startIndexAndGcds = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i, num in enumerate(nums):\n      nextStartIndexAndGcds = []\n      for startIndex, gcd in startIndexAndGcds:\n        nextGcd = math.gcd(gcd, nums[i])\n        if (not nextStartIndexAndGcds or\n                nextStartIndexAndGcds[-1][1] != nextGcd):  # Skip duplicates.\n          nextStartIndexAndGcds.append((startIndex, nextGcd))\n      startIndexAndGcds = nextStartIndexAndGcds\n      startIndexAndGcds.append((i, nums[i]))\n      for startIndex, gcd in startIndexAndGcds:\n        if i - startIndex + 1 >= k:\n          ans = max(ans, (prefix[i + 1] - prefix[startIndex]) * gcd)\n\n    return ans",
      "title": "2941. Maximum GCD-Sum of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4958d950-ccbc-4623-9b3a-64529f118253",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2944. Minimum Number of Coins for Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57b643d0-6443-4746-a7f6-cfc256206d49",
      "code": "class Solution:\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2944. Minimum Number of Coins for Fruits_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ef0d9146-ae05-46b5-8d36-c80a25df9fcf",
      "code": "class Solution:\n  def findMaximumLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefix[i] := the sum of the first i nums\n    prefix = list(itertools.accumulate(nums, initial=0))\n    # dp[i] := the maximum number of elements in the increasing\n    # sequence after processing the first i nums\n    dp = [0] * (n + 1)\n    # bestLeft[i] := the index l s.t. merging nums[l..i) is the\n    # optimal strategy among processing the first i nums\n    bestLeft = [0] * (n + 2)\n\n    for i in range(1, n + 1):\n      bestLeft[i] = max(bestLeft[i], bestLeft[i - 1])\n      # When merging nums[l, i), consider the next segment as [i, r).\n      # Find the minimum `r` where sum(nums[l, i)) <= sum(nums[i, r)).\n      # Equivalently, prefix[i] - prefix[l] <= prefix[r] - prefix[i].\n      #            => prefix[r] >= prefix[i] * 2 - prefix[l]\n      # Therefore, we can binary search `prefix` to find the minimum `r`.\n      l = bestLeft[i]\n      r = bisect.bisect_left(prefix, 2 * prefix[i] - prefix[l])\n      dp[i] = dp[l] + 1\n      bestLeft[r] = i\n\n    return dp[n]",
      "title": "2945. Find Maximum Non-decreasing Array Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1f99d13-1294-4424-b530-bdef2341f356",
      "code": "class Solution:\n  def areSimilar(self, mat: list[list[int]], k: int) -> bool:\n    n = len(mat[0])\n    for row in mat:\n      for j in range(n):\n        if row[j] != row[(j + k) % n]:\n          return False\n    return True",
      "title": "2946. Matrix Similarity After Cyclic Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4961623d-2d75-4166-b97e-e6089a4c9249",
      "code": "class Solution:\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2947. Count Beautiful Substrings I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7fe2e71-5481-46c6-b3fe-ea327ec315c0",
      "code": "class Solution:\n  def lexicographicallySmallestArray(\n      self,\n      nums: list[int],\n      limit: int,\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums)])\n    # [[(num, index)]], where the difference between in each pair in each\n    # `[(num, index)]` group <= `limit`\n    numAndIndexesGroups: list[list[tuple[int, int]]] = []\n\n    for numAndIndex in numAndIndexes:\n      if (not numAndIndexesGroups or\n              numAndIndex[0] - numAndIndexesGroups[-1][-1][0] > limit):\n        # Start a new group.\n        numAndIndexesGroups.append([numAndIndex])\n      else:\n        # Append to the existing group.\n        numAndIndexesGroups[-1].append(numAndIndex)\n\n    for numAndIndexesGroup in numAndIndexesGroups:\n      sortedNums = [num for num, _ in numAndIndexesGroup]\n      sortedIndices = sorted([index for _, index in numAndIndexesGroup])\n      for num, index in zip(sortedNums, sortedIndices):\n        ans[index] = num\n\n    return ans",
      "title": "2948. Make Lexicographically Smallest Array by Swapping Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "234f2890-e920-4705-bcb4-70e8037f3b70",
      "code": "class Solution:\n  # Same as 2947. Count Beautiful Substrings I\n  def beautifulSubstrings(self, s: str, k: int) -> int:\n    VOWELS = 'aeiou'\n    root = self._getRoot(k)\n    ans = 0\n    vowels = 0\n    vowelsMinusConsonants = 0\n    # {(vowels, vowelsMinusConsonants): count}\n    prefixCount = collections.Counter({(0, 0): 1})\n\n    for c in s:\n      if c in VOWELS:\n        vowelsMinusConsonants += 1\n        vowels = (vowels + 1) % root\n      else:\n        vowelsMinusConsonants -= 1\n      ans += prefixCount[(vowels, vowelsMinusConsonants)]\n      prefixCount[(vowels, vowelsMinusConsonants)] += 1\n\n    return ans\n\n  def _getRoot(self, k: int) -> int:\n    for i in range(1, k + 1):\n      if i * i % k == 0:\n        return i",
      "title": "2949. Count Beautiful Substrings II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5127def8-a36d-487d-b4e9-8ee98047e159",
      "code": "class Solution:\n  def countDivisibleSubstrings(self, word: str) -> int:\n    # Let f(c) = d, where d = 1, 2, ..., 9.\n    # Rephrase the question to return the number of substrings that satisfy\n    #    f(c1) + f(c2) + ... + f(ck) // k = avg\n    # => f(c1) + f(c2) + ... + f(ck) - k * avg, where avg in [1, 9].\n    ans = 0\n\n    def f(c: str) -> int:\n      return 9 - (ord('z') - ord(c)) // 3\n\n    for avg in range(1, 10):\n      prefix = 0\n      prefixCount = collections.Counter({0: 1})\n      for c in word:\n        prefix += f(c) - avg\n        ans += prefixCount[prefix]\n        prefixCount[prefix] += 1\n\n    return ans",
      "title": "2950. Number of Divisible Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44d4e98a-6189-4848-af73-a2007c071795",
      "code": "class Solution:\n  def findPeaks(self, mountain: list[int]) -> list[int]:\n    return [i for i in range(1, len(mountain) - 1)\n            if mountain[i - 1] < mountain[i] > mountain[i + 1]]",
      "title": "2951. Find the Peaks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b40e4b0d-020c-4348-914d-fbcb109afc0e",
      "code": "class Solution:\n  # Same as 330. Patching Array\n  def minimumAddedCoins(self, coins: list[int], target: int) -> int:\n    ans = 0\n    i = 0  # coins' index\n    miss = 1  # the minimum sum in [1, n] we might miss\n\n    coins.sort()\n\n    while miss <= target:\n      if i < len(coins) and coins[i] <= miss:\n        miss += coins[i]\n        i += 1\n      else:\n        # Greedily add `miss` itself to increase the range from\n        # [1, miss) to [1, 2 * miss).\n        miss += miss\n        ans += 1\n\n    return ans",
      "title": "2952. Minimum Number of Coins to be Added",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c67dc7fe-e6d1-4f76-940b-9a7455596925",
      "code": "class Solution:\n  def countCompleteSubstrings(self, word: str, k: int) -> int:\n    uniqueLetters = len(set(word))\n    return sum(self._countCompleteStrings(word, k, windowSize)\n               for windowSize in range(k, k * uniqueLetters + 1, k))\n\n  def _countCompleteStrings(self, word: str, k: int, windowSize: int) -> int:\n    \"\"\"\n    Returns the number of complete substrings of `windowSize` of `word`.\n    \"\"\"\n    res = 0\n    countLetters = 0  # the number of letters in the running substring\n    count = collections.Counter()\n\n    for i, c in enumerate(word):\n      count[c] += 1\n      countLetters += 1\n      if i > 0 and abs(ord(c) - ord(word[i - 1])) > 2:\n        count = collections.Counter()\n        # Start a new substring starting at word[i].\n        count[c] += 1\n        countLetters = 1\n      if countLetters == windowSize + 1:\n        count[word[i - windowSize]] -= 1\n        countLetters -= 1\n      if countLetters == windowSize:\n        res += all(freq == 0 or freq == k for freq in count.values())\n\n    return res",
      "title": "2953. Count Complete Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b5ac39b-ed97-49e1-9755-39958ab4274a",
      "code": "class Solution:\n  def numberOfSequence(self, n: int, sick: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    ans = fact(n - len(sick))  # the number of infected children\n    prevSick = -1\n\n    for i, s in enumerate(sick):\n      # The segment [prevSick + 1, sick - 1] are the current non-infected\n      # children.\n      nonInfected = sick[i] - prevSick - 1\n      prevSick = sick[i]\n      if nonInfected == 0:\n        continue\n      ans *= inv(fact(nonInfected))\n      ans %= MOD\n      if i > 0:\n        # There're two choices per second since the children at the two\n        # endpoints can both be the infect candidates. So, there are\n        # 2^[nonInfected - 1] ways to infect all children in the current\n        # segment.\n        ans *= pow(2, nonInfected - 1, MOD)\n\n    nonInfected = n - sick[-1] - 1\n    return ans * inv(fact(nonInfected)) % MOD",
      "title": "2954. Count the Number of Infection Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec0445f5-9117-4075-a48e-b4fab0d81f9f",
      "code": "class Solution:\n  def sameEndSubstringCount(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[int]:\n    count = collections.Counter()\n    # counts[i] := the count of s[0..i)\n    counts = [count.copy()]\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n\n    ans = []\n\n    for l, r in queries:\n      sameEndCount = 0\n      for c in string.ascii_lowercase:\n        #   the count of s[0..r] - the count of s[0..l - 1]\n        # = the count of s[l..r]\n        freq = counts[r + 1][c] - counts[l][c]\n        #   C(freq, 2) + freq\n        # = freq * (freq - 1) / 2 + freq\n        # = freq * (freq + 1) / 2\n        sameEndCount += freq * (freq + 1) // 2\n      ans.append(sameEndCount)\n\n    return ans",
      "title": "2955. Number of Same-End Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed6036e9-5951-43d5-9dc4-ecdb92572c11",
      "code": "class Solution:\n  def findIntersectionValues(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n  ) -> list[int]:\n    nums1Set = set(nums1)\n    nums2Set = set(nums2)\n    return [sum(num in nums2Set for num in nums1),\n            sum(num in nums1Set for num in nums2)]",
      "title": "2956. Find Common Elements Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c55f751-41c2-4fa3-a027-a86138baa9b4",
      "code": "class Solution:\n  def removeAlmostEqualCharacters(self, word: str) -> int:\n    ans = 0\n    i = 1\n    while i < len(word):\n      if abs(ord(word[i]) - ord(word[i - 1])) <= 1:\n        ans += 1\n        i += 2\n      else:\n        i += 1\n    return ans",
      "title": "2957. Remove Adjacent Almost-Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "765084be-a77f-462a-8720-2751a5b8aa67",
      "code": "class Solution:\n  def maxSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      count[num] += 1\n      while count[num] == k + 1:\n        count[nums[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2958. Length of Longest Subarray With at Most K Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c4a3653-c16f-4ae5-843d-5d5d5de9428d",
      "code": "class Solution:\n  def numberOfSets(\n      self,\n      n: int,\n      maxDistance: int,\n      roads: list[list[int]],\n  ) -> int:\n    return sum(self._floydWarshall(n, maxDistance, roads, mask) <= maxDistance\n               for mask in range(1 << n))\n\n  def _floydWarshall(\n      self,\n      n: int,\n      maxDistanceThreshold: int,\n      roads: list[list[int]],\n      mask: int,\n  ) -> list[list[int]]:\n    \"\"\"\n    Returns the maximum distance between any two branches, where the mask\n    represents the selected branches.\n    \"\"\"\n    maxDistance = 0\n    dist = [[maxDistanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      if mask >> i & 1:\n        dist[i][i] = 0\n\n    for u, v, w in roads:\n      if mask >> u & 1 and mask >> v & 1:\n        dist[u][v] = min(dist[u][v], w)\n        dist[v][u] = min(dist[v][u], w)\n\n    for k in range(n):\n      if mask >> k & 1:\n        for i in range(n):\n          if mask >> i & 1:\n            for j in range(n):\n              if mask >> j & 1:\n                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for i in range(n):\n      if mask >> i & 1:\n        for j in range(i + 1, n):\n          if mask >> j & 1:\n            maxDistance = max(maxDistance, dist[i][j])\n\n    return maxDistance",
      "title": "2959. Number of Possible Sets of Closing Branches",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f9534c6-9187-4b28-b667-5e4fb634bdd2",
      "code": "class Solution:\n  def countTestedDevices(self, batteryPercentages: list[int]) -> int:\n    ans = 0\n\n    for batteryPercentage in batteryPercentages:\n      if batteryPercentage - ans > 0:\n        ans += 1\n\n    return ans",
      "title": "2960. Count Tested Devices After Test Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cf1e48d-26b1-48f7-9e07-f6bd2f8f8205",
      "code": "class Solution:\n  def getGoodIndices(\n      self,\n      variables: list[list[int]],\n      target: int,\n  ) -> list[int]:\n    return [i for i, (a, b, c, m) in enumerate(variables)\n            if pow(pow(a, b, 10), c, m) == target]",
      "title": "2961. Double Modular Exponentiation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c0fb1bf-52c6-4e86-9fd1-0b1648542956",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    maxNum = max(nums)\n    ans = 0\n    count = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == maxNum:\n        count += 1\n      # Keep the window to include k - 1 times of the maxNummum number.\n      while count == k:\n        if nums[l] == maxNum:\n          count -= 1\n        l += 1\n      # If l > 0, nums[l:r+1] has k - 1 times of the maxNummum number. For any\n      # subarray nums[i:r+1], where i < l, it will have at least k times of the\n      # maxNummum number, since nums[l - 1] equals the maxNummum number.\n      ans += l\n\n    return ans",
      "title": "2962. Count Subarrays Where Max Element Appears at Least K Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b79ee6d-2306-4974-95a9-b7646547b983",
      "code": "class Solution:\n  def numberOfGoodPartitions(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    # lastSeen[num] := the index of the last time `num` appeared\n    lastSeen = {}\n\n    for i, num in enumerate(nums):\n      lastSeen[num] = i\n\n    # Track the maximum right index of each running partition by ensuring that\n    # the first and last occurrences of a number fall within the same partition.\n    maxRight = 0\n    for i, num in enumerate(nums):\n      if i > maxRight:\n        # Start a new partition that starts from nums[i].\n        # Each partition doubles the total number of good partitions.\n        ans = ans * 2 % MOD\n      maxRight = max(maxRight, lastSeen[num])\n\n    return ans",
      "title": "2963. Count the Number of Good Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea79411c-eaa6-441b-af66-4312a90d31b0",
      "code": "class Solution:\n  # Similar to 1995. Count Special Quadruplets\n  def divisibleTripletCount(self, nums: list[int], d: int) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for j in range(len(nums) - 1, 0, -1):  # `j` also represents k.\n      for i in range(j - 1, -1, -1):\n        ans += count[-(nums[i] + nums[j]) % d]\n      count[nums[j] % d] += 1  # j := k\n\n    return ans",
      "title": "2964. Number of Divisible Triplet Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e873de13-6bfb-468d-84d8-df471b2f7ce5",
      "code": "class Solution:\n  def findMissingAndRepeatedValues(self, grid: list[list[int]]) -> list[int]:\n    count = [1] + [0] * len(grid)**2  # padding for 1-indexed\n\n    for row in grid:\n      for num in row:\n        count[num] += 1\n\n    return [count.index(2), count.index(0)]",
      "title": "2965. Find Missing and Repeated Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "292e8793-6002-4b72-844e-64e55dc302df",
      "code": "class Solution:\n  def divideArray(self, nums: list[int], k: int) -> list[list[int]]:\n    ans = []\n\n    nums.sort()\n\n    for i in range(2, len(nums), 3):\n      if nums[i] - nums[i - 2] > k:\n        return []\n      ans.append([nums[i - 2], nums[i - 1], nums[i]])\n\n    return ans",
      "title": "2966. Divide Array Into Arrays With Max Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd65f01e-237f-4441-9292-976f38711b2b",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    nums.sort()\n    median = nums[len(nums) // 2]\n    nextPalindrome = self._getPalindrome(median, delta=1)\n    prevPalindrome = self._getPalindrome(median, delta=-1)\n    return min(self._cost(nums, nextPalindrome),\n               self._cost(nums, prevPalindrome))\n\n  def _cost(self, nums: list[int], palindrome: int) -> int:\n    \"\"\"Returns the cost to change all the numbers to `palindrome`.\"\"\"\n    return sum(abs(palindrome - num) for num in nums)\n\n  def _getPalindrome(self, num: int, delta: int) -> int:\n    \"\"\"Returns the palindrome `p`, where p = num + a * delta and a > 0.\"\"\"\n    while not self._isPalindrome(num):\n      num += delta\n    return num\n\n  def _isPalindrome(self, num: int) -> int:\n    original = str(num)\n    return original == original[::-1]",
      "title": "2967. Minimum Cost to Make Array Equalindromic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "344a25f0-485c-45f8-aa74-ce1a646ac070",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = 0\n    cost = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      cost += num - nums[(l + r) // 2]\n      while cost > k:\n        cost -= nums[(l + r + 1) // 2] - nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2968. Apply Operations to Maximize Frequency Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65e8efc2-c8c8-4f2b-9f83-4d6e4ffb2c3b",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    ans = math.inf\n    # Stores (dp[i], i), where dp[i] := the minimum number of coins to acquire\n    # fruits[i:] (0-indexed) in ascending order.\n    minQ = collections.deque([(0, n)])\n\n    for i in range(n - 1, -1, -1):\n      while minQ and minQ[0][1] > (i + 1) * 2:\n        minQ.popleft()\n      ans = prices[i] + minQ[0][0]\n      while minQ and minQ[-1][0] >= ans:\n        minQ.pop()\n      minQ.append((ans, i))\n\n    return ans",
      "title": "2969. Minimum Number of Coins for Fruits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39842dab-56ee-4180-9e59-efea8ba70164",
      "code": "class Solution:\n  # Same as 2944. Minimum Number of Coins for Fruits\n  def minimumCoins(self, prices: list[int]) -> int:\n    n = len(prices)\n    # Convert to 0-indexed for easy computation.\n    # dp[i] := the minimum number of coins to acquire fruits[i:]\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      # Convert back to 1-indexed.\n      for j in range(i + 1, min((i + 1) * 2 + 1, n + 1)):\n        dp[i] = min(dp[i], prices[i] + dp[j])\n\n    return dp[0]",
      "title": "2969. Minimum Number of Coins for Fruits II_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e84f06e6-1372-4a93-b124-adbec1dd7b0a",
      "code": "class Solution:\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2970. Count the Number of Incremovable Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d21e57a0-88bc-4aa9-8fee-a0db52ec84d6",
      "code": "class Solution:\n  def largestPerimeter(self, nums: list[int]) -> int:\n    prefix = sum(nums)\n\n    for num in sorted(nums, reverse=True):\n      prefix -= num\n      # Let `num` be the longest side. Check if the sum of all the edges with\n      # length no longer than `num` > `num``.\n      if prefix > num:\n        return prefix + num\n\n    return -1",
      "title": "2971. Find Polygon With the Largest Perimeter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d196d3f-c30a-4b31-a8b9-f79fffdb09b0",
      "code": "class Solution:\n  # Same as 2970. Count the Number of Incremovable Subarrays I\n  def incremovableSubarrayCount(self, nums: list[int]) -> int:\n    n = len(nums)\n    startIndex = self._getStartIndexOfSuffix(nums)\n    # If the complete array is strictly increasing, the total number of ways we\n    # can remove elements equals the total number of possible subarrays.\n    if startIndex == 0:\n      return n * (n + 1) // 2\n\n    # The valid removals starting from nums[0] include nums[0..startIndex - 1],\n    # nums[0..startIndex], ..., nums[0..n).\n    ans = n - startIndex + 1\n\n    # Enumerate each prefix subarray that is strictly increasing.\n    j = startIndex\n    for i in range(startIndex):\n      if i > 0 and nums[i] <= nums[i - 1]:\n        break\n      # Since nums[0..i] is strictly increasing, move j to the place such that\n      # nums[j] > nums[i]. The valid removals will then be nums[i + 1..j - 1],\n      # nums[i + 1..j], ..., nums[i + 1..n).\n      while j < n and nums[i] >= nums[j]:\n        j += 1\n      ans += n - j + 1\n\n    return ans\n\n  def _getStartIndexOfSuffix(self, nums: list[int]) -> int:\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] >= nums[i + 1]:\n        return i + 1\n    return 0",
      "title": "2972. Count the Number of Incremovable Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2da92e90-5cb0-4d01-99b5-154f937789cf",
      "code": "class ChildCost:\n  def __init__(self, cost: int):\n    self.numNodes = 1\n    self.maxPosCosts = [cost] if cost > 0 else []\n    self.minNegCosts = [cost] if cost < 0 else []\n\n  def update(self, childCost: 'ChildCost') -> None:\n    self.numNodes += childCost.numNodes\n    self.maxPosCosts.extend(childCost.maxPosCosts)\n    self.minNegCosts.extend(childCost.minNegCosts)\n    self.maxPosCosts.sort(reverse=True)\n    self.minNegCosts.sort()\n    self.maxPosCosts = self.maxPosCosts[:3]\n    self.minNegCosts = self.minNegCosts[:2]\n\n  def maxProduct(self) -> int:\n    if self.numNodes < 3:\n      return 1\n    if not self.maxPosCosts:\n      return 0\n    res = 0\n    if len(self.maxPosCosts) == 3:\n      res = self.maxPosCosts[0] * self.maxPosCosts[1] * self.maxPosCosts[2]\n    if len(self.minNegCosts) == 2:\n      res = max(res,\n                self.minNegCosts[0] * self.minNegCosts[1] * self.maxPosCosts[0])\n    return res\n\n\nclass Solution:\n  def placedCoins(self, edges: list[list[int]], cost: list[int]) -> list[int]:\n    n = len(cost)\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> None:\n      res = ChildCost(cost[u])\n      for v in tree[u]:\n        if v != prev:\n          res.update(dfs(v, u))\n      ans[u] = res.maxProduct()\n      return res\n\n    dfs(0, -1)\n    return ans",
      "title": "2973. Find Number of Coins to Place in Tree Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46339549-3a7c-4284-b302-3d3b0c82d87c",
      "code": "class Solution:\n  def numberGame(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    return [nums[i + 1] if i % 2 == 0\n            else nums[i - 1]\n            for i in range(len(nums))]",
      "title": "2974. Minimum Number Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbc959a3-7bb2-4c48-870e-b2c290729fbb",
      "code": "class Solution:\n  def maximizeSquareArea(\n      self,\n      m: int,\n      n: int,\n      hFences: list[int],\n      vFences: list[int],\n  ) -> int:\n    hFences = sorted(hFences + [1, m])\n    vFences = sorted(vFences + [1, n])\n    hGaps = {hFences[i] - hFences[j]\n             for i in range(len(hFences))\n             for j in range(i)}\n    vGaps = {vFences[i] - vFences[j]\n             for i in range(len(vFences))\n             for j in range(i)}\n    maxGap = next((hGap\n                  for hGap in sorted(hGaps, reverse=True)\n                  if hGap in vGaps), -1)\n    return -1 if maxGap == -1 else maxGap**2 % (10**9 + 7)",
      "title": "2975. Maximum Square Area by Removing Fences From a Field",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8d2f136-0e8f-4d02-b203-354792aad808",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    ans = 0\n    # dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n    dist = [[math.inf] * 26 for _ in range(26)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = ord(a) - ord('a')\n      v = ord(b) - ord('a')\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(26):\n      for i in range(26):\n        if dist[i][k] < math.inf:\n          for j in range(26):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    for s, t in zip(source, target):\n      if s == t:\n        continue\n      u = ord(s) - ord('a')\n      v = ord(t) - ord('a')\n      if dist[u][v] == math.inf:\n        return -1\n      ans += dist[u][v]\n\n    return ans",
      "title": "2976. Minimum Cost to Convert String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38f9e7c5-8566-4112-b0da-4c9e469b1572",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      source: str,\n      target: str,\n      original: list[str],\n      changed: list[str],\n      cost: list[int],\n  ) -> int:\n    subLengths = set(len(s) for s in original)\n    subToId = self._getSubToId(original, changed)\n    subCount = len(subToId)\n    # dist[u][v] := the minimum distance to change the substring with id u to\n    # the substring with id v\n    dist = [[math.inf for _ in range(subCount)] for _ in range(subCount)]\n    # dp[i] := the minimum cost to change the first i letters of `source` into\n    # `target`, leaving the suffix untouched\n    dp = [math.inf for _ in range(len(source) + 1)]\n\n    for a, b, c in zip(original, changed, cost):\n      u = subToId[a]\n      v = subToId[b]\n      dist[u][v] = min(dist[u][v], c)\n\n    for k in range(subCount):\n      for i in range(subCount):\n        if dist[i][k] < math.inf:\n          for j in range(subCount):\n            if dist[k][j] < math.inf:\n              dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    dp[0] = 0\n\n    for i, (s, t) in enumerate(zip(source, target)):\n      if dp[i] == math.inf:\n        continue\n      if s == t:\n        dp[i + 1] = min(dp[i + 1], dp[i])\n      for subLength in subLengths:\n        if i + subLength > len(source):\n          continue\n        subSource = source[i:i + subLength]\n        subTarget = target[i:i + subLength]\n        if subSource not in subToId or subTarget not in subToId:\n          continue\n        u = subToId[subSource]\n        v = subToId[subTarget]\n        if dist[u][v] != math.inf:\n          dp[i + subLength] = min(dp[i + subLength], dp[i] + dist[u][v])\n\n    return -1 if dp[len(source)] == math.inf else dp[len(source)]\n\n  def _getSubToId(self, original: str, changed: str) -> dict[str, int]:\n    subToId = {}\n    for s in original + changed:\n      if s not in subToId:\n        subToId[s] = len(subToId)\n    return subToId",
      "title": "2977. Minimum Cost to Convert String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9722f2ac-dac3-4028-8192-5ff54e590634",
      "code": "class Solution:\n  def mostExpensiveItem(self, primeOne: int, primeTwo: int) -> int:\n    # https://en.wikipedia.org/wiki/Coin_problem\n    return primeOne * primeTwo - primeOne - primeTwo",
      "title": "2979. Most Expensive Item That Can Not Be Bought",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00ed1bb5-17f3-42a2-bdfa-654917f78edf",
      "code": "class Solution:\n  def hasTrailingZeros(self, nums: list[int]) -> bool:\n    return sum(num % 2 == 0 for num in nums) >= 2",
      "title": "2980. Check if Bitwise OR Has Trailing Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed280011-e55b-428b-a2db-863b1d6b5d13",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2981. Find Longest Special Substring That Occurs Thrice I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63206f70-47cb-4018-9dda-64eef0d3e84d",
      "code": "class Solution:\n  def maximumLength(self, s: str) -> int:\n    n = len(s)\n    runningLen = 0\n    prevLetter = '@'\n    # counts[i][j] := the frequency of ('a' + i) repeating j times\n    counts = [[0] * (n + 1) for _ in range(26)]\n\n    for c in s:\n      if c == prevLetter:\n        runningLen += 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n      else:\n        runningLen = 1\n        counts[ord(c) - ord('a')][runningLen] += 1\n        prevLetter = c\n\n    def getMaxFreq(count: list[int]) -> int:\n      \"\"\"Returns the maximum frequency that occurs more than three times.\"\"\"\n      times = 0\n      for freq in range(n, 0, -1):\n        times += count[freq]\n        if times >= 3:\n          return freq\n      return -1\n\n    return max(getMaxFreq(count) for count in counts)",
      "title": "2982. Find Longest Special Substring That Occurs Thrice II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84cc850c-c70f-4b60-ad4a-4ba97fa7bf48",
      "code": "class Solution:\n  def canMakePalindromeQueries(\n      self,\n      s: str,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    n = len(s)\n    # mirroredDiffs[i] := the number of different letters between the first i\n    # letters of s[0..n / 2) and the first i letters of s[n / 2..n)[::-1]\n    mirroredDiffs = self._getMirroredDiffs(s)\n    # counts[i] := the count of s[0..i)\n    counts = self._getCounts(s)\n    ans = []\n\n    def subtractArrays(a: list[int], b: list[int]):\n      return [x - y for x, y in zip(a, b)]\n\n    for a, b, c, d in queries:\n      # Use left-closed, right-open intervals to facilitate the calculation.\n      #   ...... [a, b) ...|... [rb, ra) ......\n      #   .... [rd, rc) .....|..... [c, d) ....\n      b += 1\n      d += 1\n      ra = n - a  # the reflected index of a in s[n / 2..n)\n      rb = n - b  # the reflected index of b in s[n / 2..n)\n      rc = n - c  # the reflected index of c in s[n / 2..n)\n      rd = n - d  # the reflected index of d in s[n / 2..n)\n      # No difference is allowed outside the query ranges.\n      if ((min(a, rd) > 0 and mirroredDiffs[min(a, rd)] > 0) or\n         (n // 2 > max(b, rc) and\n          mirroredDiffs[n // 2] - mirroredDiffs[max(b, rc)] > 0) or\n         (rd > b and mirroredDiffs[rd] - mirroredDiffs[b] > 0) or\n         (a > rc and mirroredDiffs[a] - mirroredDiffs[rc] > 0)):\n        ans.append(False)\n      else:\n        # The `count` map of the intersection of [a, b) and [rd, rc) in\n        # s[0..n / 2) must equate to the `count` map of the intersection of\n        # [c, d) and [rb, ra) in s[n / 2..n).\n        leftRangeCount = subtractArrays(counts[b], counts[a])\n        rightRangeCount = subtractArrays(counts[d], counts[c])\n        if a > rd:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[min(a, rc)], counts[rd]))\n        if rc > b:\n          rightRangeCount = subtractArrays(\n              rightRangeCount, subtractArrays(counts[rc], counts[max(b, rd)]))\n        if c > rb:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[min(c, ra)], counts[rb]))\n        if ra > d:\n          leftRangeCount = subtractArrays(\n              leftRangeCount, subtractArrays(counts[ra], counts[max(d, rb)]))\n        ans.append(min(leftRangeCount) >= 0\n                   and min(rightRangeCount) >= 0\n                   and leftRangeCount == rightRangeCount)\n\n    return ans\n\n  def _getMirroredDiffs(self, s: str) -> list[int]:\n    diffs = [0]\n    for i, j in zip(range(len(s)), reversed(range(len(s)))):\n      if i >= j:\n        break\n      diffs.append(diffs[-1] + (s[i] != s[j]))\n    return diffs\n\n  def _getCounts(self, s: str) -> list[list[int]]:\n    count = [0] * 26\n    counts = [count.copy()]\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n      counts.append(count.copy())\n    return counts",
      "title": "2983. Palindrome Rearrangement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1fba4a9c-25ad-4b6c-bb4f-af497febe0dd",
      "code": "class Solution:\n  def selfDivisiblePermutationCount(self, n: int) -> int:\n    def dfs(num: int, used: int) -> int:\n      if num > n:\n        return 1\n\n      count = 0\n      for i in range(1, n + 1):\n        if (used >> i & 1) == 0 and (num % i == 0 or i % num == 0):\n          count += dfs(num + 1, used | 1 << i)\n\n      return count\n\n    return dfs(1, 0)",
      "title": "2992. Number of Self-Divisible Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a558f4d-947e-4da2-8d3c-c4428dbf174b",
      "code": "class Solution:\n  def missingInteger(self, nums: list[int]) -> int:\n    numsSet = set(nums)\n    ans = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1] + 1:\n        break\n      ans += nums[i]\n\n    while ans in numsSet:\n      ans += 1\n\n    return ans",
      "title": "2996. Smallest Missing Integer Greater Than Sequential Prefix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57e1d7ee-da07-4ca4-802a-4439801440b8",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return functools.reduce(operator.xor, nums, k).bit_count()",
      "title": "2997. Minimum Number of Operations to Make Array XOR Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3f08bd8-257c-4245-b2ba-8a76e691574f",
      "code": "class Solution:\n  def minimumOperationsToMakeEqual(self, x, y):\n    if x <= y:\n      return y - x\n\n    queue = collections.deque([x])\n    seen = set()\n\n    ans = 0\n    while queue:\n      for _ in range(len(queue)):\n        num = queue.popleft()\n        if num == y:\n          return ans\n        if num in seen:\n          continue\n        seen.add(num)\n        if num % 11 == 0:\n          queue.append(num // 11)\n        if num % 5 == 0:\n          queue.append(num // 5)\n        queue.append(num - 1)\n        queue.append(num + 1)\n      ans += 1",
      "title": "2998. Minimum Number of Operations to Make X and Y Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfa818e9-b81c-4c15-95bf-126f6d6649c1",
      "code": "class Solution:\n  def areaOfMaxDiagonal(self, dimensions: list[list[int]]) -> int:\n    a, b = max(dimensions, key=lambda x: (x[0]**2 + x[1]**2, x[0] * x[1]))\n    return a * b",
      "title": "3000. Maximum Area of Longest Diagonal Rectangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10dded5c-0727-4e28-ba48-bc0b72a96451",
      "code": "class Solution:\n  def minMovesToCaptureTheQueen(\n      self, a: int, b: int, c: int, d: int, e: int, f: int,\n  ) -> int:\n    # The rook is in the same row as the queen.\n    if a == e:\n      # The bishop blocks the rook or not.\n      return 2 if c == a and (b < d < f or b > d > f) else 1\n    # The rook is in the same column as the queen.\n    if b == f:\n      # The bishop blocks the rook or not.\n      return 2 if d == f and (a < c < e or a > c > e) else 1\n    # The bishop is in the same up-diagonal as the queen.\n    if c + d == e + f:\n      # The rook blocks the bishop or not.\n      return 2 if a + b == c + d and (c < a < e or c > a > e) else 1\n    # The bishop is in the same down-diagonal as the queen.\n    if c - d == e - f:\n      # The rook blocks the bishop or not.\n      return 2 if a - b == c - d and (c < a < e or c > a > e) else 1\n    # The rook can always get the green in two steps.\n    return 2",
      "title": "3001. Minimum Moves to Capture The Queen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce9c386-7b29-4ae4-83cd-a16056dbc790",
      "code": "class Solution:\n  def maximumSetSize(self, nums1: list[int], nums2: list[int]) -> int:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    common = set1.intersection(set2)\n\n    n = len(nums1)\n    n1 = len(set1)\n    n2 = len(set2)\n    nc = len(common)\n    maxUniqueNums1 = min(n1 - nc, n // 2)\n    maxUniqueNums2 = min(n2 - nc, n // 2)\n    return min(n, maxUniqueNums1 + maxUniqueNums2 + nc)",
      "title": "3002. Maximum Size of a Set After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b2bbfd0-b9d2-4e6e-99cd-42f8881eae80",
      "code": "class Solution:\n  def maxPartitionsAfterOperations(self, s: str, k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, canChange: bool, mask: int) -> int:\n      \"\"\"\n      Returns the maximum number of partitions of s[i..n), where `canChange` is\n      True if we can still change a letter, and `mask` is the bitmask of the\n      letters we've seen.\n      \"\"\"\n      if i == len(s):\n        return 0\n\n      def getRes(newBit: int, nextCanChange: bool) -> int:\n        newMask = mask | newBit\n        if newMask.bit_count() > k:\n          return 1 + dp(i + 1, nextCanChange, newBit)\n        return dp(i + 1, nextCanChange, newMask)\n\n      # Initialize the result based on the current letter.\n      res = getRes(1 << (ord(s[i]) - ord('a')), canChange)\n\n      # If allowed, explore the option to change the current letter.\n      if canChange:\n        for j in range(26):\n          res = max(res, getRes(1 << j, False))\n      return res\n\n    return dp(0, True, 0) + 1",
      "title": "3003. Maximize the Number of Partitions After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e78b71f-fd75-4324-8dcc-7b34b8c0136f",
      "code": "class Solution:\n  def maximumSubtreeSize(\n      self,\n      edges: list[list[int]],\n      colors: list[int],\n  ) -> int:\n    ans = 1\n    tree = [[] for _ in range(len(colors))]\n\n    for u, v in edges:\n      tree[u].append(v)\n\n    def dfs(u: int) -> int:\n      \"\"\"\n      Returns the size of subtree of u if every node in the subtree has the same\n      color. Otherwise, returns -1.\n      \"\"\"\n      nonlocal ans\n      res = 1\n      for v in tree[u]:\n        if colors[v] != colors[u]:\n          res = -1\n        # If any node in the subtree of v has a different color, the result of\n        # the subtree of u will be -1 as well.\n        subtreeSize = dfs(v)\n        if subtreeSize == -1:\n          res = -1\n        elif res != -1:\n          res += subtreeSize\n      ans = max(ans, res)\n      return res\n\n    dfs(0)\n    return ans",
      "title": "3004. Maximum Subtree of the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e21e4428-1f6e-4166-b90f-7de1a327773a",
      "code": "class Solution:\n  def maxFrequencyElements(self, nums: list[int]) -> int:\n    count = collections.Counter(nums)\n    maxFreq = max(count.values())\n    return sum(freq == maxFreq for freq in count.values()) * maxFreq",
      "title": "3005. Count Elements With Maximum Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9ce4049-6cec-42a3-97e4-eb754f2f7812",
      "code": "class Solution:\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    res = []\n    lps = getLPS(pattern)\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3006. Find Beautiful Indices in the Given Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6447d3c-3b52-496d-805e-7ad80f995146",
      "code": "class Solution:\n  def findMaximumNumber(self, k: int, x: int) -> int:\n    def getSumPrices(num: int) -> int:\n      \"\"\"Returns the sum of prices of all numbers from 1 to `num`.\"\"\"\n      sumPrices = 0\n      # Increment `num` to account the 0-th row in the count of groups.\n      num += 1\n      for i in range(num.bit_length(), 0, -1):\n        if i % x == 0:\n          groupSize = 1 << i\n          halfGroupSize = 1 << i - 1\n          sumPrices += num // groupSize * halfGroupSize\n          sumPrices += max(0, (num % groupSize) - halfGroupSize)\n      return sumPrices\n\n    l = 1\n    r = 10**15\n    return bisect.bisect_right(range(l, r + 1), k, key=getSumPrices) - 1 + l",
      "title": "3007. Maximum Number That Sum of the Prices Is Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2730d29f-e222-4d61-8780-7c1acfbcb12b",
      "code": "class Solution:\n  # Same as 3006. Find Beautiful Indices in the Given Array I\n  def beautifulIndices(self, s: str, a: str, b: str, k: int) -> list[int]:\n    ans = []\n    indicesA = self._kmp(s, a)\n    indicesB = self._kmp(s, b)\n    indicesBIndex = 0  # indicesB' index\n\n    for i in indicesA:\n      # The constraint is: |j - i| <= k. So, -k <= j - i <= k. So, move\n      # `indicesBIndex` s.t. j - i >= -k, where j := indicesB[indicesBIndex].\n      while indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i < -k:\n        indicesBIndex += 1\n      if indicesBIndex < len(indicesB) and indicesB[indicesBIndex] - i <= k:\n        ans.append(i)\n\n    return ans\n\n  def _kmp(self, s: str, pattern: str) -> list[int]:\n    \"\"\"Returns the starting indices of all occurrences of the pattern in `s`.\"\"\"\n\n    def getLPS(pattern: str) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      pattern[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(pattern)\n      j = 0\n      for i in range(1, len(pattern)):\n        while j > 0 and pattern[j] != pattern[i]:\n          j = lps[j - 1]\n        if pattern[i] == pattern[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = []\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(s):\n      if s[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res.append(i - j)\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3008. Find Beautiful Indices in the Given Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb8c395a-2071-4946-985a-f6b090819cda",
      "code": "class Solution:\n  def maxIntersectionCount(self, y: list[int]) -> int:\n    ans = 0\n    intersectionCount = 0\n    line = collections.Counter()\n\n    for i, (a, b) in enumerate(itertools.pairwise(y)):\n      start = 2 * a\n      end = 2 * b + (0 if i == len(y) - 2 else -1 if b > a else 1)\n      line[min(start, end)] += 1\n      line[max(start, end) + 1] -= 1\n\n    for count in sorted(line):\n      intersectionCount += line[count]\n      ans = max(ans, intersectionCount)\n\n    return ans",
      "title": "3009. Maximum Number of Intersections on the Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcf7105b-e21f-4c7c-b97e-692e88d977af",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int]) -> int:\n    MAX = 50\n    min1 = MAX\n    min2 = MAX\n\n    for i in range(1, len(nums)):\n      if nums[i] < min1:\n        min2 = min1\n        min1 = nums[i]\n      elif nums[i] < min2:\n        min2 = nums[i]\n\n    return nums[0] + min1 + min2",
      "title": "3010. Divide an Array Into Subarrays With Minimum Cost I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7ca4b1a-718f-44a4-a036-644886d71415",
      "code": "class Solution:\n  def canSortArray(self, nums: list[int]) -> int:\n    # Divide the array into distinct segments where each segment is comprised\n    # of consecutive elements sharing an equal number of set bits. Ensure that\n    # for each segment, when moving from left to right, the maximum of a\n    # preceding segment is less than the minimum of the following segment.\n    prevSetBits = 0\n    prevMax = -math.inf  # the maximum of the previous segment\n    currMax = -math.inf  # the maximum of the current segment\n    currMin = math.inf   # the minimum of the current segment\n\n    for num in nums:\n      setBits = num.bit_count()\n      if setBits != prevSetBits:  # Start a new segment.\n        if prevMax > currMin:\n          return False\n        prevSetBits = setBits\n        prevMax = currMax\n        currMax = num\n        currMin = num\n      else:  # Continue with the current segment.\n        currMax = max(currMax, num)\n        currMin = min(currMin, num)\n\n    return prevMax <= currMin",
      "title": "3011. Find if Array Can Be Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69b9a736-2fab-42c4-88da-549f38d7aea1",
      "code": "class Solution:\n  def minimumArrayLength(self, nums: list[int]) -> int:\n    # Let the minimum number in the array `nums` be x.\n    # * If there exists any element nums[i] where nums[i] % x > 0, a new\n    #   minimum can be generated and all other numbers can be removed.\n    # * If not, count the frequency of x in `nums`. For each pair of x, a 0 is\n    #   generated which cannot be removed. Therefore, the result will be\n    #   (frequency of x + 1) / 2.\n    minNum = min(nums)\n    if any(num % minNum > 0 for num in nums):\n      return 1\n    return (nums.count(minNum) + 1) // 2",
      "title": "3012. Minimize Length of Array Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "713227a4-fdb5-4257-a53e-86a132f9af99",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumCost(self, nums: list[int], k: int, dist: int) -> int:\n    # Equivalently, the problem is to find nums[0] + the minimum sum of the top\n    # k - 1 numbers in nums[i..i + dist], where i > 0 and i + dist < n.\n    windowSum = sum(nums[i] for i in range(1, dist + 2))\n    selected = SortedList(nums[i] for i in range(1, dist + 2))\n    candidates = SortedList()\n\n    def balance() -> int:\n      \"\"\"\n      Returns the updated `windowSum` by balancing the multiset `selected` to\n      keep the top k - 1 numbers.\n      \"\"\"\n      nonlocal windowSum\n      while len(selected) < k - 1:\n        minCandidate = candidates[0]\n        windowSum += minCandidate\n        selected.add(minCandidate)\n        candidates.remove(minCandidate)\n      while len(selected) > k - 1:\n        maxSelected = selected[-1]\n        windowSum -= maxSelected\n        selected.remove(maxSelected)\n        candidates.add(maxSelected)\n      return windowSum\n\n    windowSum = balance()\n    minWindowSum = windowSum\n\n    for i in range(dist + 2, len(nums)):\n      outOfScope = nums[i - dist - 1]\n      if outOfScope in selected:\n        windowSum -= outOfScope\n        selected.remove(outOfScope)\n      else:\n        candidates.remove(outOfScope)\n      if nums[i] < selected[-1]:  # nums[i] is a better number.\n        windowSum += nums[i]\n        selected.add(nums[i])\n      else:\n        candidates.add(nums[i])\n      windowSum = balance()\n      minWindowSum = min(minWindowSum, windowSum)\n\n    return nums[0] + minWindowSum",
      "title": "3013. Divide an Array Into Subarrays With Minimum Cost II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c68a9182-d5bd-4d52-a42d-be585f24fb2c",
      "code": "class Solution:\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3014. Minimum Number of Pushes to Type Word I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1cfe2794-388c-4c50-983f-1925e7d5069b",
      "code": "class Solution:\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3015. Count the Number of Houses at a Certain Distance I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e975c47f-3882-4ae7-9ada-fa453a146405",
      "code": "class Solution:\n  # Same as 3014. Minimum Number of Pushes to Type Word I\n  def minimumPushes(self, word: str) -> int:\n    freqs = sorted(collections.Counter(word).values(), reverse=True)\n    return sum(freq * (i // 8 + 1) for i, freq in enumerate(freqs))",
      "title": "3016. Minimum Number of Pushes to Type Word II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ace12df0-b5b8-4d9b-b55b-91e27a82eeb0",
      "code": "class Solution:\n  # Same as 3015. Count the Number of Houses at a Certain Distance I\n  def countOfPairs(self, n: int, x: int, y: int) -> list[int]:\n    if x > y:\n      x, y = y, x\n\n    def bothInRing(ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are located\n      in the ring.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, (ringLen - 1) // 2 + 1):\n        res[k - 1] += ringLen\n      if ringLen % 2 == 0:\n        res[ringLen // 2 - 1] += ringLen // 2\n      return res\n\n    def bothInTheSameLine(lineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where two houses are either\n      located in the left line [1, x) or the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + 1):\n        res[k - 1] += lineLen - k\n      return res\n\n    def lineToRing(lineLen: int, ringLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is either\n      located in the left line [1, x) or the right line (y, n] and the\n      other house is located in the cycle.\n      \"\"\"\n      res = [0] * n\n      for k in range(1, lineLen + ringLen):\n        # min(\n        #   at most k - 1 since we need to give 1 to the line,\n        #   at most ringLen / 2 since for length > ringLen / 2, it can always be\n        #     calculated as ringLen - ringLen / 2\n        # )\n        maxInRingLen = min(k - 1, ringLen // 2)\n        # max(at least 0, at lest k - lineLen)\n        minInRingLen = max(0, k - lineLen)\n        if minInRingLen <= maxInRingLen:\n          # Each ring length contributes 2 to the count due to the split of\n          # paths when entering the ring: One path traverses the upper half of\n          # the ring, and the other traverses the lower half.\n          # This is illustrated as follows:\n          #   Path 1: ... -- x -- (upper half of the ring)\n          #   Path 2: ... -- x -- (lower half of the ring)\n          res[k - 1] += (maxInRingLen - minInRingLen + 1) * 2\n          if minInRingLen == 0:\n            # Subtract 1 since there's no split.\n            res[k - 1] -= 1\n          if maxInRingLen * 2 == ringLen:\n            # Subtract 1 since the following case only contribute one:\n            #   ... -- x -- (upper half of the ring) -- middle point\n            #   ... -- x -- (upper half of the ring) -- middle point\n            res[k - 1] -= 1\n      return res\n\n    def lineToLine(leftLineLen: int, rightLineLen: int) -> list[int]:\n      \"\"\"\n      Returns the contribution from the scenario where one house is in the left\n      line [1, x) and the other house is in the right line (y, n].\n      \"\"\"\n      res = [0] * n\n      for k in range(leftLineLen + rightLineLen + 2):\n        # min(\n        #   at most leftLineLen,\n        #   at most k - 1 - (x < y) since we need to give 1 to the right line\n        #     and if x < y we need to give another 1 to \"x - y\".\n        # )\n        maxInLeft = min(leftLineLen, k - 1 - (x < y))\n        # max(at least 1, at least k - rightLineLen - (x < y))\n        minInLeft = max(1, k - rightLineLen - (x < y))\n        if minInLeft <= maxInLeft:\n          res[k - 1] += maxInLeft - minInLeft + 1\n      return res\n\n    ringLen = y - x + 1\n    leftLineLen = x - 1\n    rightLineLen = (n - y)\n\n    ans = [0] * n\n    ans = list(map(operator.add, ans, bothInRing(ringLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(leftLineLen)))\n    ans = list(map(operator.add, ans, bothInTheSameLine(rightLineLen)))\n    ans = list(map(operator.add, ans, lineToRing(leftLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToRing(rightLineLen, ringLen)))\n    ans = list(map(operator.add, ans, lineToLine(leftLineLen, rightLineLen)))\n    return [freq * 2 for freq in ans]",
      "title": "3017. Count the Number of Houses at a Certain Distance II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37912939-2c31-4795-86cd-1b8380abb87a",
      "code": "class Solution:\n  def maximumProcessableQueries(\n      self,\n      nums: list[int],\n      queries: list[int],\n  ) -> int:\n    n = len(nums)\n    # dp[i][j] := the maximum number of queries processed if nums[i..j] are not\n    # removed after processing dp[i][j] queries\n    dp = [[0] * n for _ in range(n)]\n\n    for d in range(n - 1, -1, -1):\n      for i in range(n):\n        j = i + d\n        if j >= n:\n          continue\n        if i > 0:\n          # Remove nums[i - 1] from nums[i - 1..j] if possible.\n          dp[i][j] = max(dp[i][j], dp[i - 1][j] +\n                         (nums[i - 1] >= queries[dp[i - 1][j]]))\n        if j + 1 < n:\n          # Remove nums[j + 1] from nums[i..j + 1] if possible.\n          dp[i][j] = max(dp[i][j], dp[i][j + 1] +\n                         (nums[j + 1] >= queries[dp[i][j + 1]]))\n        if dp[i][j] == len(queries):\n          return len(queries)\n\n    return max(dp[i][i] + (nums[i] >= queries[dp[i][i]])\n               for i in range(n))",
      "title": "3018. Maximum Number of Removal Queries That Can Be Processed I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f767d529-5d06-4e82-a0d3-2402699da784",
      "code": "class Solution:\n  def countKeyChanges(self, s: str) -> int:\n    return sum(a.lower() != b.lower()\n               for a, b in itertools.pairwise(s))",
      "title": "3019. Number of Changing Keys",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6dfbf379-3e9f-460e-a00f-516ed1a64104",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    maxNum = max(nums)\n    count = collections.Counter(nums)\n    ans = count[1] - (count[1] % 2 == 0) if 1 in count else 1\n\n    for num in nums:\n      if num == 1:\n        continue\n      length = 0\n      x = num\n      while x <= maxNum and x in count and count[x] >= 2:\n        length += 2\n        x *= x\n      # x is now x^k, and the pattern is [x, ..., x^(k/2), x^(k/2), ..., x].\n      # The goal is to determine if we can insert x^k in the middle of the\n      # pattern to increase the length by 1. If not, we make x^(k/2) the middle\n      # and decrease the length by 1.\n      ans = max(ans, length + (1 if x in count else -1))\n\n    return ans",
      "title": "3020. Find the Maximum Number of Elements in Subset",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "04ddef6d-104a-4871-b040-6d15fa3d5ac1",
      "code": "class Solution:\n  def flowerGame(self, n: int, m: int) -> int:\n    # Alice wins if x + y is odd, occurring when:\n    #   1. x is even and y is odd, or\n    #   2. y is even and x is odd.\n    xEven = n // 2\n    yEven = m // 2\n    xOdd = (n + 1) // 2\n    yOdd = (m + 1) // 2\n    return xEven * yOdd + yEven * xOdd",
      "title": "3021. Alice and Bob Playing Flower Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e017af6-aa3f-4517-a57a-7fc981cd3936",
      "code": "class Solution:\n  def minOrAfterOperations(self, nums: list[int], k: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n    prefixMask = 0  # Grows like: 10000 -> 11000 -> ... -> 11111\n\n    for i in range(MAX_BIT, -1, -1):\n      # Add the i-th bit to `prefixMask` and attempt to \"turn off\" the\n      # currently added bit within k operations. If it's impossible, then we\n      # add the i-th bit to the answer.\n      prefixMask |= 1 << i\n      if self._getMergeOps(nums, prefixMask, ans) > k:\n        ans |= 1 << i\n\n    return ans\n\n  def _getMergeOps(self, nums: list[int], prefixMask: int, target: int) -> int:\n    \"\"\"\n    Returns the number of merge operations to turn `prefixMask` to the target\n    by ANDing `nums`.\n    \"\"\"\n    mergeOps = 0\n    ands = prefixMask\n    for num in nums:\n      ands &= num\n      if (ands | target) == target:\n        ands = prefixMask\n      else:\n        mergeOps += 1  # Keep merging the next num\n    return mergeOps",
      "title": "3022. Minimize OR of Remaining Elements Using Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba9b6088-ab56-4eea-926e-5f8a6b14f512",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int],\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3023. Find Pattern in Infinite Stream I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7cc2bbd-d8ad-4ffc-a376-d80f6105d683",
      "code": "class Solution:\n  def triangleType(self, nums: list[int]) -> str:\n    nums.sort()\n    if nums[0] + nums[1] <= nums[2]:\n      return 'none'\n    if nums[0] == nums[1] and nums[1] == nums[2]:\n      return 'equilateral'\n    if nums[0] == nums[1] or nums[1] == nums[2]:\n      return 'isosceles'\n    return 'scalene'",
      "title": "3024. Type of Triangle II Easy",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1d72f97-8dfb-47a9-bc44-c7a80ba29a68",
      "code": "class Solution:\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3025. Find the Number of Ways to Place People I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4cc54d4-75c7-4175-8786-04952d809bc8",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    numToMinPrefix = {}\n\n    for num in nums:\n      if num not in numToMinPrefix or numToMinPrefix[num] > prefix:\n        numToMinPrefix[num] = prefix\n      prefix += num\n      if num + k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num + k])\n      if num - k in numToMinPrefix:\n        ans = max(ans, prefix - numToMinPrefix[num - k])\n\n    return 0 if ans == -math.inf else ans",
      "title": "3026. Maximum Good Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a009bd5c-72e1-466b-abfd-f29fa988daea",
      "code": "class Solution:\n  # Same as 3025. Find the Number of Ways to Place People I\n  def numberOfPairs(self, points: list[list[int]]) -> int:\n    ans = 0\n\n    points.sort(key=lambda x: (x[0], -x[1]))\n\n    for i, (_, yi) in enumerate(points):\n      maxY = -math.inf\n      for j in range(i + 1, len(points)):\n        _, yj = points[j]\n        # Chisato is in the upper-left corner at (xi, yi), and Takina is in the\n        # lower-right corner at (xj, yj). Also, if yj > maxY, it means that\n        # nobody other than Chisato and Takina is inside or on the fence.\n        if yi >= yj > maxY:\n          ans += 1\n          maxY = yj\n\n    return ans",
      "title": "3027. Find the Number of Ways to Place People II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf4b7305-aed5-49e4-87b2-0318641b546a",
      "code": "class Solution:\n  def returnToBoundaryCount(self, nums: list[int]) -> int:\n    return sum(prefix == 0 for prefix in itertools.accumulate(nums))",
      "title": "3028. Ant on the Boundary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae5ea6d2-566b-4822-98f1-e56c0f40e3ea",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3029. Minimum Time to Revert Word to Initial State I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e416b8fb-a701-4ff1-ba0e-0bae3bfeab64",
      "code": "class Solution:\n  def resultGrid(\n      self,\n      image: list[list[int]],\n      threshold: int,\n  ) -> list[list[int]]:\n    m = len(image)\n    n = len(image[0])\n    sums = [[0] * n for _ in range(m)]\n    counts = [[0] * n for _ in range(m)]\n\n    for i in range(m - 2):\n      for j in range(n - 2):\n        if self._isRegion(image, i, j, threshold):\n          subgridSum = sum(image[x][y]\n                           for x in range(i, i + 3)\n                           for y in range(j, j + 3))\n          for x in range(i, i + 3):\n            for y in range(j, j + 3):\n              sums[x][y] += subgridSum // 9\n              counts[x][y] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if counts[i][j] > 0:\n          image[i][j] = sums[i][j] // counts[i][j]\n\n    return image\n\n  def _isRegion(\n      self,\n      image: list[list[int]],\n      i: int,\n      j: int,\n      threshold: int,\n  ) -> bool:\n    \"\"\"Returns True if image[i..i + 2][j..j + 2] is a region.\"\"\"\n    for x in range(i, i + 3):\n      for y in range(j, j + 3):\n        if x > i and abs(image[x][y] - image[x - 1][y]) > threshold:\n          return False\n        if y > j and abs(image[x][y] - image[x][y - 1]) > threshold:\n          return False\n    return True",
      "title": "3030. Find the Grid of Region Average",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fd41e73-8d19-4c34-b74d-26c1cfe2d925",
      "code": "class Solution:\n  # Same as 3029. Minimum Time to Revert Word to Initial State I\n  def minimumTimeToInitialState(self, word: str, k: int) -> int:\n    n = len(word)\n    maxOps = (n - 1) // k + 1\n    z = self._zFunction(word)\n\n    for ans in range(1, maxOps):\n      if z[ans * k] >= n - ans * k:\n        return ans\n\n    return maxOps\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3031. Minimum Time to Revert Word to Initial State II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b57fb3cd-ff76-4462-9832-b9e539a3d8fe",
      "code": "class Solution:\n  def numberCount(self, a: int, b: int) -> int:\n    return sum(len(set(str(num))) == len(str(num))\n               for num in range(a, b + 1))",
      "title": "3032. Count Numbers With Unique Digits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2125ba6e-6382-4429-bb0c-d080f7a1ea10",
      "code": "class Solution:\n  def modifiedMatrix(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = matrix.copy()\n\n    for j in range(n):\n      mx = max(matrix[i][j] for i in range(m))\n      for i in range(m):\n        if matrix[i][j] == -1:\n          ans[i][j] = mx\n\n    return ans",
      "title": "3033. Modify the Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5875c5f0-ffb3-4cf1-b9e6-728e8917fa5a",
      "code": "class Solution:\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3034. Number of Subarrays That Match a Pattern I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac393d3e-167a-42f0-a965-0a555372170e",
      "code": "class Solution:\n  def maxPalindromesAfterOperations(self, words: list[str]) -> int:\n    ans = 0\n    count = collections.Counter(''.join(words))\n    pairs = sum(value // 2 for value in count.values())\n\n    for length in sorted(len(word) for word in words):\n      needPairs = length // 2\n      if pairs < needPairs:\n        return ans\n      ans += 1\n      pairs -= needPairs\n\n    return ans",
      "title": "3035. Maximum Palindromes After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ed7d2e1-7f69-4daa-a28c-5a9ec6678791",
      "code": "class Solution:\n  # Same as 3034. Number of Subarrays That Match a Pattern I\n  def countMatchingSubarrays(self, nums: list[int], pattern: list[int]) -> int:\n    def getNum(a: int, b: int) -> int:\n      if a < b:\n        return 1\n      if a > b:\n        return -1\n      return 0\n\n    numsPattern = [getNum(a, b) for a, b in itertools.pairwise(nums)]\n    return self._kmp(numsPattern, pattern)\n\n  def _kmp(self, nums: list[int], pattern: list[int]) -> int:\n    \"\"\"Returns the number of occurrences of the pattern in `nums`.\"\"\"\n\n    def getLPS(nums: list[int]) -> list[int]:\n      \"\"\"\n      Returns the lps array, where lps[i] is the length of the longest prefix of\n      nums[0..i] which is also a suffix of this substring.\n      \"\"\"\n      lps = [0] * len(nums)\n      j = 0\n      for i in range(1, len(nums)):\n        while j > 0 and nums[j] != nums[i]:\n          j = lps[j - 1]\n        if nums[i] == nums[j]:\n          lps[i] = j + 1\n          j += 1\n      return lps\n\n    lps = getLPS(pattern)\n    res = 0\n    i = 0  # s' index\n    j = 0  # pattern's index\n    while i < len(nums):\n      if nums[i] == pattern[j]:\n        i += 1\n        j += 1\n        if j == len(pattern):\n          res += 1\n          j = lps[j - 1]\n      elif j != 0:  # Mismatch after j matches.\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n    return res",
      "title": "3036. Number of Subarrays That Match a Pattern II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db2fd6ff-191a-4711-8b9b-385d148fa616",
      "code": "# Definition for an infinite stream.\n# class InfiniteStream:\n#   def next(self) -> int:\n#     pass\n\nclass Solution:\n  # Same as 3023. Find Pattern in Infinite Stream I\n  def findPattern(\n      self,\n      stream: Optional['InfiniteStream'],\n      pattern: list[int]\n  ) -> int:\n    lps = self._getLPS(pattern)\n    i = 0  # stream's index\n    j = 0  # pattern's index\n    bit = 0  # the bit in the stream\n    readNext = False\n    while True:\n      if not readNext:\n        bit = stream.next()\n        readNext = True\n      if bit == pattern[j]:\n        i += 1\n        readNext = False\n        j += 1\n        if j == len(pattern):\n          return i - j\n      # Mismatch after j matches.\n      elif j > 0:\n        # Don't match lps[0..lps[j - 1]] since they will match anyway.\n        j = lps[j - 1]\n      else:\n        i += 1\n        readNext = False\n\n  def _getLPS(self, pattern: list[int]) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        j += 1\n        lps[i] = j\n    return lps",
      "title": "3037. Find Pattern in Infinite Stream II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79f148a8-f014-4ab7-b654-547ebb6f6cd8",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    ans = 1\n    summ = nums[0] + nums[1]\n\n    for i in range(2, len(nums) - 1, 2):\n      if nums[i] + nums[i + 1] == summ:\n        ans += 1\n      else:\n        break\n\n    return ans",
      "title": "3038. Maximum Number of Operations With the Same Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "627e9872-fa93-4a4e-9489-3b9c763b4fd1",
      "code": "class Solution:\n  def lastNonEmptyString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    maxFreq = max(count.values())\n\n    for c in reversed(s):\n      if count[c] == maxFreq:\n        ans.append(c)\n        count[c] -= 1\n\n    return ''.join(reversed(ans))",
      "title": "3039. Apply Operations to Make String Empty",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09359d64-e174-4001-a6ba-1c211ef9a247",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, score: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      nums[i..j], s.t. all operations have the same `score`.\n      \"\"\"\n      if i >= j:\n        return 0\n      deleteFirstTwo = (1 + dp(i + 2, j, score)\n                        if nums[i] + nums[i + 1] == score else 0)\n      deleteLastTwo = (1 + dp(i, j - 2, score)\n                       if nums[j] + nums[j - 1] == score else 0)\n      deleteFirstAndLast = (1 + dp(i + 1, j - 1, score)\n                            if nums[i] + nums[j] == score else 0)\n      return max(deleteFirstTwo, deleteLastTwo, deleteFirstAndLast)\n\n    n = len(nums)\n    return max(dp(0, n - 1, nums[0] + nums[1]),\n               dp(0, n - 1, nums[-1] + nums[-2]),\n               dp(0, n - 1, nums[0] + nums[-1]))",
      "title": "3040. Maximum Number of Operations With the Same Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2499a4e1-4421-4ce7-adf1-73c98454c065",
      "code": "class Solution:\n  def maxSelectedElements(self, nums: list[int]) -> int:\n    ans = 1\n    prev = -math.inf\n    # the length of the longest consecutive elements (seq0) ending in the\n    # previous number\n    dp0 = 1\n    # the length of the longest consecutive elements (seq1) ending in the\n    # previous number + 1\n    dp1 = 1\n\n    for num in sorted(nums):\n      if num == prev:\n        dp1 = dp0 + 1  # Append `num + 1` to seq0.\n      elif num == prev + 1:\n        dp0 += 1  # Append `num` to seq0.\n        dp1 += 1  # Add 1 to every number in seq0 and append `num + 1` to seq0.\n      elif num == prev + 2:\n        dp0 = dp1 + 1  # Append `num` to seq1.\n        dp1 = 1        # Start a new sequence [`num + 1`].\n      else:\n        dp0 = 1  # Start a new sequence [`num`].\n        dp1 = 1  # Start a new sequence [`num + 1`].\n      ans = max(ans, dp0, dp1)\n      prev = num\n\n    return ans",
      "title": "3041. Maximize Consecutive Elements in an Array After Modification",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "168deb55-524f-4c11-87d3-aafe69e1fac4",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3042. Count Prefix and Suffix Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b2a05c5-439a-4572-a0b7-d2a09e40458b",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n    node.isWord = True\n\n  def search(self, word: str) -> int:\n    prefixLength = 0\n    node = self.root\n    for c in word:\n      if c not in node.children:\n        break\n      node = node.children[c]\n      prefixLength += 1\n    return prefixLength\n\n\nclass Solution:\n  def longestCommonPrefix(self, arr1: list[int], arr2: list[int]) -> int:\n    trie = Trie()\n\n    for num in arr1:\n      trie.insert(str(num))\n\n    return max(trie.search(str(num)) for num in arr2)",
      "title": "3043. Find the Length of the Longest Common Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd39c250-e96c-4b6d-9962-42f07e2f255d",
      "code": "class Solution:\n  def mostFrequentPrime(self, mat: list[list[int]]) -> int:\n    DIRS = ((1, 0), (1, -1), (0, -1), (-1, -1),\n            (-1, 0), (-1, 1), (0, 1), (1, 1))\n    m = len(mat)\n    n = len(mat[0])\n    count = collections.Counter()\n\n    def isPrime(num: int) -> bool:\n      return not any(num % i == 0 for i in range(2, int(num**0.5 + 1)))\n\n    for i in range(m):\n      for j in range(n):\n        for dx, dy in DIRS:\n          num = 0\n          x = i\n          y = j\n          while 0 <= x < m and 0 <= y < n:\n            num = num * 10 + mat[x][y]\n            if num > 10 and isPrime(num):\n              count[num] += 1\n            x += dx\n            y += dy\n\n    if not count.items():\n      return -1\n    return max(count.items(), key=lambda x: (x[1], x[0]))[0]",
      "title": "3044. Most Frequent Prime",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "876b5fa7-6963-47ad-b059-df39207f2cb2",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[tuple[str, str], TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> int:\n    node = self.root\n    count = 0\n    for i, prefix in enumerate(word):\n      suffix = word[-1 - i]\n      node = node.children.setdefault((prefix, suffix), TrieNode())\n      count += node.count\n    node.count += 1\n    return count\n\n\nclass Solution:\n  # Same as 3045. Count Prefix and Suffix Pairs II\n  def countPrefixSuffixPairs(self, words: list[str]) -> int:\n    trie = Trie()\n    return sum(trie.insert(word) for word in words)",
      "title": "3045. Count Prefix and Suffix Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0085d055-c8c0-4bcd-aa6f-e1d7f56b80bf",
      "code": "class Solution:\n  def isPossibleToSplit(self, nums: list[int]) -> bool:\n    return all(freq <= 2 for freq in collections.Counter(nums).values())",
      "title": "3046. Split the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "353f4964-6f84-41e9-b859-118ee228e721",
      "code": "class Solution:\n  def largestSquareArea(\n      self,\n      bottomLeft: list[list[int]],\n      topRight: list[list[int]],\n  ) -> int:\n    minSide = 0\n\n    for ((ax1, ay1), (ax2, ay2)), ((bx1, by1), (bx2, by2)) in (\n            itertools.combinations(zip(bottomLeft, topRight), 2)):\n      overlapX = min(ax2, bx2) - max(ax1, bx1)\n      overlapY = min(ay2, by2) - max(ay1, by1)\n      minSide = max(minSide, min(overlapX, overlapY))\n\n    return minSide**2",
      "title": "3047. Find the Largest Area of Square Inside Two Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4de99a2-17bb-47f5-99a7-e3afd01fa4c4",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    def canMark(second: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `second`.\n      \"\"\"\n      numMarked = 0\n      decrement = 0\n      indexToLastSecond = {}\n\n      for i in range(second):\n        indexToLastSecond[changeIndices[i] - 1] = i\n\n      for i in range(second):\n        index = changeIndices[i] - 1  # Convert to 0-indexed\n        if i == indexToLastSecond[index]:\n          # Reach the last occurrence of the number.\n          # So, the current second will be used to mark the index.\n          if nums[index] > decrement:\n            # The decrement is less than the number to be marked.\n            return False\n          decrement -= nums[index]\n          numMarked += 1\n        else:\n          decrement += 1\n\n      return numMarked == len(nums)\n\n    l = 1\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1",
      "title": "3048. Earliest Second to Mark Indices I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "203c69d3-2766-4e17-81ae-63e65f3382e0",
      "code": "class Solution:\n  def earliestSecondToMarkIndices(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> int:\n    # {the second: the index of nums can be zeroed at the current second}\n    secondToIndex = self._getSecondToIndex(nums, changeIndices)\n    numsSum = sum(nums)\n\n    def canMark(maxSecond: int) -> bool:\n      \"\"\"\n      Returns True if all indices of `nums` can be marked within `maxSecond`.\n      \"\"\"\n      # Use a min-heap to greedily pop out the minimum number, which yields the\n      # least saving.\n      minHeap = []\n      marks = 0\n\n      for second in range(maxSecond - 1, -1, -1):\n        if second in secondToIndex:\n          # The number mapped by the index is a candidate to be zeroed out.\n          index = secondToIndex[second]\n          heapq.heappush(minHeap, nums[index])\n          if marks == 0:\n            # Running out of marks, so need to pop out the minimum number.\n            # So, the current second will be used to mark an index.\n            heapq.heappop(minHeap)\n            marks += 1\n          else:\n            # There're enough marks.\n            # So, the current second will be used to zero out a number.\n            marks -= 1\n        else:\n          # There's no candidate to be zeroed out.\n          # So, the current second will be used to mark an index.\n          marks += 1\n\n      decrementAndMarkCost = ((numsSum - sum(minHeap)) +\n                              (len(nums) - len(minHeap)))\n      zeroAndMarkCost = len(minHeap) + len(minHeap)\n      return decrementAndMarkCost + zeroAndMarkCost <= maxSecond\n\n    l = 0\n    r = len(changeIndices) + 1\n    ans = bisect.bisect_left(range(l, r), True, key=canMark) + l\n    return ans if ans <= len(changeIndices) else -1\n\n  def _getSecondToIndex(\n      self,\n      nums: list[int],\n      changeIndices: list[int],\n  ) -> dict[int, int]:\n    # {the `index` of nums: the earliest second to zero out nums[index]}\n    indexToFirstSecond = {}\n    for zeroIndexedSecond, oneIndexedIndex in enumerate(changeIndices):\n      index = oneIndexedIndex - 1  # Convert to 0-indexed.\n      if nums[index] > 0 and index not in indexToFirstSecond:\n        indexToFirstSecond[index] = zeroIndexedSecond\n    return {second: index for index, second in indexToFirstSecond.items()}",
      "title": "3049. Earliest Second to Mark Indices II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e217423-6aae-4e71-baf4-7f2393d20bb3",
      "code": "class Solution:\n  def gameResult(self, head: ListNode | None) -> str:\n    even = 0\n    odd = 0\n\n    while head:\n      if head.val > head.next.val:\n        even += 1\n      elif head.val < head.next.val:\n        odd += 1\n      head = head.next.next\n\n    if even > odd:\n      return 'Even'\n    if even < odd:\n      return 'Odd'\n    return 'Tie'",
      "title": "3062. Winner of the Linked List Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07a027d4-10dc-4f7d-b728-99787ceefa32",
      "code": "class Solution:\n  def frequenciesOfElements(self, head: ListNode | None) -> ListNode | None:\n    count = collections.Counter()\n    curr = head\n\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    dummy = ListNode(0)\n    tail = dummy\n\n    for freq in count.values():\n      tail.next = ListNode(freq)\n      tail = tail.next\n\n    return dummy.next",
      "title": "3063. Linked List Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53a6bf8e-61a9-458d-bd8e-7af350621c4f",
      "code": "# Definition of commonSetBits API.\n# def commonSetBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    return sum(1 << i for i in range(31)\n               if commonSetBits(1 << i) == 1)",
      "title": "3064. Guess the Number Using Bitwise Questions I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8e3d464-1694-4290-8d47-98d642305664",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(num < k for num in nums)",
      "title": "3065. Minimum Operations to Exceed Threshold Value I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d9e0fae-ec1d-456b-8fd8-5decfb8da8f8",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    ans = 0\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    while len(minHeap) > 1 and minHeap[0] < k:\n      x = heapq.heappop(minHeap)\n      y = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, min(x, y) * 2 + max(x, y))\n      ans += 1\n\n    return ans",
      "title": "3066. Minimum Operations to Exceed Threshold Value II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6af3f278-a6e7-47ac-b21e-6f3c6c839b2d",
      "code": "class Solution:\n  def countPairsOfConnectableServers(\n      self,\n      edges: list[list[int]],\n      signalSpeed: int,\n  ) -> list[int]:\n    n = len(edges) + 1\n    tree = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      tree[u].append((v, w))\n      tree[v].append((u, w))\n\n    def connectablePairsRootedAt(u: int) -> int:\n      pairs = 0\n      count = 0\n      for v, w in tree[u]:\n        childCount = dfs(v, u, w)\n        pairs += count * childCount\n        count += childCount\n      return pairs\n\n    def dfs(u: int, prev: int, dist: int) -> int:\n      return (int(dist % signalSpeed == 0) +\n              sum(dfs(v, u, dist + w)\n              for v, w in tree[u]\n              if v != prev))\n\n    return [connectablePairsRootedAt(i) for i in range(n)]",
      "title": "3067. Count Pairs of Connectable Servers in a Weighted Tree Network",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "847a4af1-5105-403c-9bf1-4b821921c504",
      "code": "class Solution:\n  def maximumValueSum(\n      self,\n      nums: list[int],\n      k: int,\n      edges: list[list[int]],\n  ) -> int:\n    maxSum = sum(max(num, num ^ k) for num in nums)\n    changedCount = sum((num ^ k) > num for num in nums)\n    if changedCount % 2 == 0:\n      return maxSum\n    minChangeDiff = min(abs(num - (num ^ k)) for num in nums)\n    return maxSum - minChangeDiff",
      "title": "3068. Find the Maximum Sum of Node Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94bb11d8-02fa-4122-8c0d-0d62a00e706a",
      "code": "class Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = [nums[0]]\n    arr2 = [nums[1]]\n\n    for i in range(2, len(nums)):\n      if arr1[-1] > arr2[-1]:\n        arr1.append(nums[i])\n      else:\n        arr2.append(nums[i])\n\n    return arr1 + arr2",
      "title": "3069. Distribute Elements Into Two Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dc2373f-32cc-4771-8dc6-aa35a1475959",
      "code": "class Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # prefix[i][j] := the sum of matrix[0..i)[0..j)\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (grid[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n        if prefix[i + 1][j + 1] <= k:\n          ans += 1\n\n    return ans",
      "title": "3070. Count Submatrices with Top-Left Element and Sum Less Than k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "335aab95-895e-4eb3-a698-f5abb7f7c10f",
      "code": "class Solution:\n  def minimumOperationsToWriteY(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    mid = n // 2\n\n    def getOperations(a: int, b: int) -> int:\n      \"\"\"Returns the number of operations to turn Y into a and non-Y into b.\"\"\"\n      operations = 0\n      for i, row in enumerate(grid):\n        for j, num in enumerate(row):\n          # For the 'Y' pattern, before the midpoint, check the diagonal and\n          # anti-diagonal. After the midpoint, check the middle column.\n          if (i < mid and (i == j or i + j == n - 1)) or i >= mid and j == mid:\n            if num != a:\n              operations += 1\n          elif num != b:\n            operations += 1\n      return operations\n\n    return min(getOperations(0, 1), getOperations(0, 2),\n               getOperations(1, 0), getOperations(1, 2),\n               getOperations(2, 0), getOperations(2, 1))",
      "title": "3071. Minimum Operations to Write the Letter Y on a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2322a862-c386-4327-9192-b8a392f07960",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def resultArray(self, nums: list[int]) -> list[int]:\n    arr1 = []\n    arr2 = []\n    ranks = self._getRanks(nums)\n    tree1 = FenwickTree(len(ranks))\n    tree2 = FenwickTree(len(ranks))\n\n    def add(num: int, arr: list[int], tree: FenwickTree) -> None:\n      arr.append(num)\n      tree.add(ranks[num], 1)\n\n    add(nums[0], arr1, tree1)\n    add(nums[1], arr2, tree2)\n\n    for i in range(2, len(nums)):\n      greaterCount1 = len(arr1) - tree1.get(ranks[nums[i]])\n      greaterCount2 = len(arr2) - tree2.get(ranks[nums[i]])\n      if greaterCount1 > greaterCount2:\n        add(nums[i], arr1, tree1)\n      elif greaterCount1 < greaterCount2:\n        add(nums[i], arr2, tree2)\n      elif len(arr1) > len(arr2):\n        add(nums[i], arr2, tree2)\n      else:\n        add(nums[i], arr1, tree1)\n\n    return arr1 + arr2\n\n  def _getRanks(self, nums: list[int]) -> dict[int, int]:\n    ranks = collections.Counter()\n    rank = 0\n    for num in sorted(set(nums)):\n      rank += 1\n      ranks[num] = rank\n    return ranks",
      "title": "3072. Distribute Elements Into Two Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5173de79-7f77-4dad-8fd4-02d7941bb63e",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def maximumTripletValue(self, nums: list[int]) -> int:\n    ans = 0\n    rightMax = [0] * len(nums)  # rightMax[i] := max(nums[i + 1..n))\n    leftSortedSet = SortedSet([nums[0]])\n\n    for i in range(len(nums) - 2, -1, -1):\n      rightMax[i] = max(nums[i + 1], rightMax[i + 1])\n\n    for j in range(1, len(nums) - 1):\n      i = bisect.bisect_left(leftSortedSet, nums[j])\n      if i > 0 and rightMax[j] > nums[j]:\n        ans = max(ans, leftSortedSet[i - 1] - nums[j] + rightMax[j])\n      leftSortedSet.add(nums[j])\n\n    return ans",
      "title": "3073. Maximum Increasing Triplet Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9f2c18e-4f3d-4dd5-996c-f614804be591",
      "code": "class Solution:\n  def minimumBoxes(self, apple: list[int], capacity: list[int]) -> int:\n    appleSum = sum(apple)\n    capacitySum = 0\n\n    for i, c in enumerate(sorted(capacity, reverse=True)):\n      capacitySum += c\n      if capacitySum >= appleSum:\n        return i + 1\n\n    return len(capacity)",
      "title": "3074. Apple Redistribution into Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f274185-ec8e-4c38-be79-3d5e203a6a68",
      "code": "class Solution:\n  def maximumHappinessSum(self, happiness: list[int], k: int) -> int:\n    ans = 0\n    decremented = 0\n\n    happiness.sort(reverse=True)\n\n    for i in range(k):\n      ans += max(0, happiness[i] - decremented)\n      decremented += 1\n\n    return ans",
      "title": "3075. Maximize Happiness of Selected Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71b53115-5178-4a67-99da-0a54a7b0972e",
      "code": "class Solution:\n  def shortestSubstrings(self, arr: list[str]) -> list[str]:\n    ans = []\n    count = collections.Counter()\n\n    def getSubstrings(s: str) -> Iterator[str]:\n      for i in range(len(s)):\n        for j in range(i + 1, len(s) + 1):\n          yield s[i:j]\n\n    def add(s: str) -> None:\n      \"\"\"Adds all substrings of s to `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] += 1\n\n    def remove(s: str) -> None:\n      \"\"\"Removes all substrings of s from `count`.\"\"\"\n      for sub in getSubstrings(s):\n        count[sub] -= 1\n\n    def getMinSub(s: str) -> str:\n      minSub = ''\n      for sub in getSubstrings(s):\n        if count[sub] > 0:\n          continue\n        if minSub == ('' or\n                      len(sub) < len(minSub) or\n                      len(sub) == len(minSub) and sub < minSub):\n          minSub = sub\n      return minSub\n\n    for s in arr:\n      add(s)\n\n    for s in arr:\n      remove(s)\n      ans.append(getMinSub(s))\n      add(s)\n\n    return ans",
      "title": "3076. Shortest Uncommon Substring in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51579baa-c85e-45a1-af00-c8b299493045",
      "code": "class Solution:\n  def maximumStrength(self, nums: list[int], k: int) -> int:\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, fresh: bool) -> int:\n      \"\"\"\n      Returns the maximum strength of nums[i..n) with k operations left, where\n      `fresh` means we're starting a new subarray.\n      \"\"\"\n      if len(nums) - i < k:\n        return -math.inf\n      if k == 0:\n        return 0\n      if i == len(nums):\n        return 0 if k == 0 else -math.inf\n      # If it's not fresh, we can't skip the current number and consider it as a\n      # fresh start, since the case where it's fresh is already covered by\n      # `includeAndFreshStart`.\n      skip = dp(i + 1, k, True) if fresh else -math.inf\n      gain = (-1 if k % 2 == 0 else 1) * nums[i] * k\n      includeAndContinue = dp(i + 1, k, False) + gain\n      includeAndFreshStart = dp(i + 1, k - 1, True) + gain\n      return max(skip, includeAndContinue, includeAndFreshStart)\n\n    return dp(0, k, True)",
      "title": "3077. Maximum Strength of K Disjoint Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9815e176-6297-4fe2-9b38-d138b9ee2be0",
      "code": "class Solution:\n  def findPattern(\n      self,\n      board: list[list[int]],\n      pattern: list[str],\n  ) -> list[int]:\n    def isMatch(x: int, y: int) -> bool:\n      digitToLetter = {}\n      letterToDigit = {}\n      for i, row in enumerate(pattern):\n        for j, c in enumerate(row):\n          digit = board[i + x][j + y]\n          if c.isdigit():\n            if int(c) != digit:\n              return False\n          else:\n            if digitToLetter.get(digit, c) != c:\n              return False\n            if letterToDigit.get(c, digit) != digit:\n              return False\n            digitToLetter[digit] = c\n            letterToDigit[c] = digit\n      return True\n\n    for x in range(len(board) - len(pattern) + 1):\n      for y in range(len(board[0]) - len(pattern[0]) + 1):\n        if isMatch(x, y):\n          return [x, y]\n\n    return [-1, -1]",
      "title": "3078. Match Alphanumerical Pattern in Matrix I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0464f312-8192-4a7e-bd17-3d820f303f55",
      "code": "class Solution:\n  def sumOfEncryptedInt(self, nums: list[int]) -> int:\n    def getEncrypted(num: int) -> int:\n      maxDigit = 0\n      base = 0\n      while num > 0:\n        maxDigit = max(maxDigit, num % 10)\n        base = base * 10 + 1\n        num //= 10\n      return base * maxDigit\n\n    return sum(getEncrypted(num) for num in nums)",
      "title": "3079. Find the Sum of Encrypted Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ada2450-485c-4dc0-9ded-7c326cfcea12",
      "code": "class Solution:\n  def unmarkedSumArray(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    marked = set()\n    summ = sum(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for index, k in queries:\n      if index not in marked:\n        marked.add(index)\n        summ -= nums[index]\n      popped = 0\n      while popped < k and minHeap:\n        num, i = heapq.heappop(minHeap)\n        if i not in marked:\n          marked.add(i)\n          summ -= num\n          popped += 1\n      ans.append(summ)\n\n    return ans",
      "title": "3080. Mark Elements on Array by Performing Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed04fa07-40b9-4cf1-a529-0ec496c2fa32",
      "code": "class Solution:\n  def minimizeStringValue(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    letters = []\n\n    del count['?']\n\n    def getMinFreqLetter(count: dict[str, int]) -> str:\n      minFreqLetter = 'a'\n      for c in string.ascii_lowercase:\n        if count[c] < count[minFreqLetter]:\n          minFreqLetter = c\n      return minFreqLetter\n\n    for c in s:\n      if c == '?':\n        minFreqLetter = getMinFreqLetter(count)\n        letters.append(minFreqLetter)\n        count[minFreqLetter] += 1\n\n    letters.sort()\n    i = 0  # letters' index\n\n    for c in s:\n      if c == '?':\n        ans.append(letters[i])\n        i += 1\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3081. Replace Question Marks in String to Minimize Its Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f236f15-148a-49a9-87a9-75e2811b1d70",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of subsequences in nums[0..i) that sums to k\n    dp = [[0] * (k + 1) for _ in range(n + 1)]\n    dp[0][0] = 1\n\n    for i in range(1, n + 1):\n      num = nums[i - 1]\n      for j in range(k + 1):\n        if j < num:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          dp[i][j] = (dp[i - 1][j] * 2) % MOD\n        else:\n          # 1. Exclude nums[i] in the subsequence.\n          # 2. Include nums[i] in the subsequence and skip it.\n          # 3. Include nums[i] in the subsequence and pick it.\n          dp[i][j] = (dp[i - 1][j] * 2 + dp[i - 1][j - num]) % MOD\n\n    return dp[n][k]",
      "title": "3082. Find the Sum of the Power of All Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d057763-8433-44c3-b277-03b20f3c85f3",
      "code": "class Solution:\n  def sumOfPower(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of subsequences in nums[i..n) that sums to j.\"\"\"\n      if j == 0:\n        # For each of the remaining number, we can either pick it or skip it.\n        return pow(2, len(nums) - i, MOD)\n      if i == len(nums) or j < 0:\n        return 0\n        # 1. Include nums[i] in the subsequence and pick it.\n        # 2. Include nums[i] in the subsequence and skip it.\n        # 3. Exclude nums[i] in the subsequence.\n      return (dp(i + 1, j - nums[i]) + 2 * dp(i + 1, j)) % MOD\n\n    return dp(0, k)",
      "title": "3082. Find the Sum of the Power of All Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61e263bd-31b9-4877-9ac5-78da86c99722",
      "code": "class Solution:\n  def isSubstringPresent(self, s: str) -> bool:\n    return any(s[i:i + 2] in s[::-1] for i in range(len(s) - 1))",
      "title": "3083. Existence of a Substring in a String and Its Reverse",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e944c94f-4a1b-4cdc-8f8a-92fe19a5bf66",
      "code": "class Solution:\n  def countSubstrings(self, s: str, c: str) -> int:\n    freq = s.count(c)\n    return freq * (freq + 1) // 2",
      "title": "3084. Count Substrings Starting and Ending with Given Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dadcbf9b-9269-4c06-8218-e032cb53d6c2",
      "code": "class Solution:\n  def minimumDeletions(self, word: str, k: int) -> int:\n    ans = math.inf\n    count = collections.Counter(word)\n\n    for minFreq in count.values():\n      deletions = 0\n      for freq in count.values():\n        if freq < minFreq:\n          deletions += freq\n        else:\n          deletions += max(0, freq - (minFreq + k))\n      ans = min(ans, deletions)\n\n    return ans",
      "title": "3085. Minimum Deletions to Make String K-Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "738b6a25-3d99-488e-9ab4-67208942d8d4",
      "code": "class Solution:\n  def minimumMoves(self, nums: list[int], k: int, maxChanges: int) -> int:\n    # Dylan has two actions for collecting '1's in a sequence:\n    # Action 1: Put a '1' next to him and pick it up.\n    #           The cost is 2.\n    # Action 2: Swap a '1' towards him and collect it.\n    #           The cost equals the distance to the '1'.\n    #\n    # To minimize the swapping cost, Dylan can use a sliding window strategy,\n    # selecting the optimal position (middle '1' in the window) for efficient\n    # collection. The window's size is crucial:\n\n    # The minimum window size: min(0, k - maxChanges), ensuring the window\n    # isn't too small.\n    # The maximum window size: min(k, minOnesByTwo + 3, the number of ones),\n    # preventing overly ambitious swaps.\n    #\n    # Note that if needing to move a '1' beyond `minOnesByTwo + 3`, it's\n    # cheaper to use Action 1.\n\n    # At most three indices, (dylanIndex - 1, dylanIndex, dylanIndex + 1), have\n    # a distance <= 1 from dylanIndex, implying that we'll be taking at most\n    # `maxOnesByTwo + 3` using Action 2. Any more Action 2 is not optimal and\n    # should be replaced with Action 1.\n    NUM_OF_INDICES_WITHIN_ONE_DISTANCE = 3\n    ans = math.inf\n    oneIndices = [i for i, num in enumerate(nums) if num == 1]\n    prefix = list(itertools.accumulate(oneIndices, initial=0))\n\n    minOnesByTwo = max(0, k - maxChanges)\n    maxOnesByTwo = min(\n        k, minOnesByTwo + NUM_OF_INDICES_WITHIN_ONE_DISTANCE, len(oneIndices))\n\n    for onesByTwo in range(minOnesByTwo, maxOnesByTwo + 1):\n      for l in range(len(prefix) - onesByTwo):\n        r = l + onesByTwo  # Collect 1s in oneIndices[l - 1..r - 1].\n        cost1 = (k - onesByTwo) * 2\n        cost2 = ((prefix[r] - prefix[(l + r) // 2]) -\n                 (prefix[(l + r + 1) // 2] - prefix[l]))\n        ans = min(ans, cost1 + cost2)\n\n    return ans",
      "title": "3086. Minimum Moves to Pick K Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54217f79-8473-44f4-a379-460b0d862a49",
      "code": "class Solution:\n  def makeAntiPalindrome(self, s: str) -> str:\n    n = len(s)\n    i = n // 2\n    chars = sorted(list(s))\n    if chars[i] != chars[n - 1 - i]:\n      return ''.join(chars)\n\n    j = self._getFirstDiffIndexInSecondHalf(chars)\n    while chars[i] == chars[n - 1 - i]:\n      if j == n:\n        return '-1'\n      chars[i], chars[j] = chars[j], chars[i]\n      i += 1\n      j += 1\n\n    return ''.join(chars)\n\n  def _getFirstDiffIndexInSecondHalf(self, chars: list[str]) -> int:\n    \"\"\"\n    Returns the first index in chars[n / 2..n) that is different from the first\n    letter of the second half, chars[n / 2].\n    \"\"\"\n    n = len(chars)\n    firstLetter = chars[n // 2]\n    firstDiffIndex = n // 2\n    while firstDiffIndex < n and chars[firstDiffIndex] == firstLetter:\n      firstDiffIndex += 1\n    return firstDiffIndex",
      "title": "3088. Make String Anti-palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9287169-adc6-42c5-9254-680f7f86cfce",
      "code": "class Solution:\n  def maximumLengthSubstring(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] > 2:\n        count[s[l]] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "3090. Maximum Length Substring With Two Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a1eba2-dff6-47f3-97b1-2915c570fddb",
      "code": "class Solution:\n  def minOperations(self, k: int) -> int:\n    # The required operations are\n    #   1. Increase `1` to `x`\n    #   2. Duplicate `x`, `y` times, to `sum` s.t. x * (1 + y) >= k.\n    # The number of operations used would be (x - 1) + y. Equivalently, the\n    # problem can be rephrased as finding min(x - 1 + y) s.t. x * (1 + y) >= k.\n    # Optimally, `x` should equal to `1 + y`, implying that x^2 >= k, and\n    # hence, x >= sqrt(k) and y = ceil(k / x) - 1.\n    x = math.ceil(math.sqrt(k))\n    y = (k - 1) // x + 1 - 1  # ceil(k / x) - 1\n    return x - 1 + y",
      "title": "3091. Apply Operations to Make Sum of Array Greater Than or Equal to k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6f74067-ec26-4673-ac2c-c9a51d7e1213",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def mostFrequentIDs(self, nums: list[int], freq: list[int]) -> list[int]:\n    ans = []\n    numCount = collections.Counter()  # {num: freq}\n    freqCount = SortedDict()  # {num's freq: freq}\n\n    for num, f in zip(nums, freq):\n      if numCount[num] > 0:\n        numFreq = numCount[num]\n        freqCount[numFreq] -= 1\n        if freqCount[numFreq] == 0:\n          del freqCount[numFreq]\n      newFreq = numCount[num] + f\n      if newFreq == 0:\n        del numCount[num]\n      else:\n        numCount[num] = newFreq\n        freqCount[newFreq] = freqCount.get(newFreq, 0) + 1\n      ans.append(freqCount.peekitem(-1)[0] if freqCount else 0)\n\n    return ans",
      "title": "3092. Most Frequent IDs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c890d1b-1453-4d5c-9ec0-10ddb79c45ae",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n    self.length = math.inf\n    self.index = -1\n\n\nclass Solution:\n  def stringIndices(\n      self,\n      wordsContainer: list[str],\n      wordsQuery: list[str],\n  ) -> list[int]:\n    ans = []\n    root = TrieNode()\n    minIndex = min(enumerate(wordsContainer), key=lambda x: len(x[1]))[0]\n\n    def insert(word: str, index: int) -> None:\n      node = root\n      for c in reversed(word):\n        node = node.children.setdefault(c, TrieNode())\n        if node.length > len(word):\n          node.length = len(word)\n          node.index = index\n\n    def search(word: str) -> int:\n      node = root\n      for c in reversed(word):\n        if c not in node.children:\n          return node.index\n        node = node.children[c]\n      return node.index\n\n    for i, word in enumerate(wordsContainer):\n      insert(word, i)\n\n    for query in wordsQuery:\n      index = search(query)\n      ans.append(minIndex if index == -1 else index)\n\n    return ans",
      "title": "3093. Longest Common Suffix Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f509872-4ce7-4535-8d7b-0883f87be06c",
      "code": "# Definition of commonBits API.\n# def commonBits(num: int) -> int:\n\nclass Solution:\n  def findNumber(self) -> int:\n    ans = 0\n    sameCount = commonBits(0)\n\n    for i in range(31):\n      if commonBits(1 << i) > sameCount:\n        ans |= 1 << i\n      commonBits(1 << i)  # Revert the XOR.\n\n    return ans",
      "title": "3094. Guess the Number Using Bitwise Questions II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b5b7741-4d0f-4bc3-ac42-29c78b92ef24",
      "code": "class Solution:\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3095. Shortest Subarray With OR at Least K I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8896a1a4-f435-4bba-bae8-cf201fb296ed",
      "code": "class Solution:\n  def minimumLevels(self, possible: list[int]) -> int:\n    n = len(possible)\n    nums = [num if num == 1 else -1 for num in possible]\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(1, n):\n      if prefix[i] > prefix[n] - prefix[i]:\n        return i\n\n    return -1",
      "title": "3096. Minimum Levels to Gain More Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "188eee3a-5d32-49b4-876f-c6837664c63b",
      "code": "class Solution:\n  # Same as 3095. Shortest Subarray With OR at Least K I\n  def minimumSubarrayLength(self, nums: list[int], k: int) -> int:\n    ans = len(nums) + 1\n    ors = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, num in enumerate(nums):\n      ors = self._orNum(ors, num, count)\n      while ors >= k and l <= r:\n        ans = min(ans, r - l + 1)\n        ors = self._undoOrNum(ors, nums[l], count)\n        l += 1\n\n    return -1 if ans == len(nums) + 1 else ans\n\n  def _orNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] += 1\n        if count[i] == 1:\n          ors += 1 << i\n    return ors\n\n  def _undoOrNum(self, ors: int, num: int, count: dict[int, int]) -> int:\n    for i in range(30):\n      if num >> i & 1:\n        count[i] -= 1\n        if count[i] == 0:\n          ors -= 1 << i\n    return ors",
      "title": "3097. Shortest Subarray With OR at Least K II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efa613cb-b2f6-4612-b6b9-afdf9966c00a",
      "code": "class Solution:\n  def sumOfPowers(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    nums.sort()\n\n    @functools.lru_cache(None)\n    def dp(\n        i: int,\n        k: int,\n        lastPickedIndex: int,\n        firstIndex: int,\n        secondIndex: int\n    ) -> int:\n      if k == 0:\n        return nums[secondIndex] - nums[firstIndex]\n      if i == len(nums):\n        return 0\n      newFirstIndex = firstIndex\n      newSecondIndex = secondIndex\n      if firstIndex == -1:\n        newFirstIndex = i\n      elif secondIndex == -1:\n        newSecondIndex = i\n      elif nums[i] - nums[lastPickedIndex] < nums[secondIndex] - nums[firstIndex]:\n        newFirstIndex = lastPickedIndex\n        newSecondIndex = i\n      pick = dp(i + 1, k - 1, i, newFirstIndex, newSecondIndex)\n      skip = dp(i + 1, k, lastPickedIndex, firstIndex, secondIndex)\n      return (pick + skip) % MOD\n\n    return dp(0, k, -1, -1, -1)",
      "title": "3098. Find the Sum of Subsequence Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08ed239c-fb1c-446e-b388-db3883adec63",
      "code": "class Solution:\n  def sumOfTheDigitsOfHarshadNumber(self, x: int) -> int:\n    digitSum = self._getDigitSum(x)\n    return digitSum if x % digitSum == 0 else -1\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3099. Harshad Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c671aec-048f-44f4-990e-8542034ad86d",
      "code": "class Solution:\n  def maxBottlesDrunk(self, numBottles: int, numExchange: int) -> int:\n    ans = numBottles\n\n    while numBottles >= numExchange:\n      numBottles = numBottles - numExchange + 1\n      numExchange += 1\n      ans += 1\n\n    return ans",
      "title": "3100. Water Bottles II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01bc56cf-d465-4a50-a1af-def0e5840b61",
      "code": "class Solution:\n  def countAlternatingSubarrays(self, nums: list[int]) -> int:\n    # dp[i] := the number of alternating subarrays ending in index i\n    dp = [1] * len(nums)\n\n    for i in range(1, len(nums)):\n      if nums[i] != nums[i - 1]:\n        dp[i] += dp[i - 1]\n\n    return sum(dp)",
      "title": "3101. Count Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5ef7197-bdc3-4a32-a1da-7b9fbaa0e5c8",
      "code": "class Solution:\n  def minimumDistance(self, points: list[list[int]]) -> int:\n    i, j = self._maxManhattanDistance(points, -1)\n    xi, yi = self._maxManhattanDistance(points, i)\n    xj, yj = self._maxManhattanDistance(points, j)\n    return min(self._manhattan(points, xi, yi),\n               self._manhattan(points, xj, yj))\n\n  def _maxManhattanDistance(\n      self,\n      points: list[list[int]],\n      excludedIndex: int,\n  ) -> int:\n    minSum = math.inf\n    maxSum = -math.inf\n    minDiff = math.inf\n    maxDiff = -math.inf\n    minSumIndex = -1\n    maxSumIndex = -1\n    minDiffIndex = -1\n    maxDiffIndex = -1\n\n    for i, (x, y) in enumerate(points):\n      if i == excludedIndex:\n        continue\n      summ = x + y\n      diff = x - y\n      if summ < minSum:\n        minSum = summ\n        minSumIndex = i\n      if summ > maxSum:\n        maxSum = summ\n        maxSumIndex = i\n      if diff < minDiff:\n        minDiff = diff\n        minDiffIndex = i\n      if diff > maxDiff:\n        maxDiff = diff\n        maxDiffIndex = i\n\n    return ([minSumIndex, maxSumIndex] if maxSum - minSum >= maxDiff - minDiff\n            else [minDiffIndex, maxDiffIndex])\n\n  def _manhattan(self, points: list[list[int]], i: int, j: int) -> int:\n    return abs(points[i][0] - points[j][0]) + abs(points[i][1] - points[j][1])",
      "title": "3102. Minimize Manhattan Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15f48154-e124-4dd6-bb42-6699506c32d5",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str) -> int:\n    allCount = collections.Counter(s)\n\n    # Similar to 395. Longest Substring with At Least K Repeating Characters\n    def maxSubstringLengthWithNUniqueLetters(n: int) -> int:\n      res = -1\n      # the number of unique letters\n      uniqueLetters = 0\n      # the number of letters that have all their frequency in the substring\n      lettersHavingAllFreq = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(s):\n        count[c] += 1\n        if count[c] == 1:\n          uniqueLetters += 1\n        if count[c] == allCount[c]:\n          lettersHavingAllFreq += 1\n        while uniqueLetters > n:\n          if count[s[l]] == allCount[s[l]]:\n            lettersHavingAllFreq -= 1\n          count[s[l]] -= 1\n          if count[s[l]] == 0:\n            uniqueLetters -= 1\n          l += 1\n        # Since both the number of unique letters and the number of letters\n        # having all their frequency are equal to n, this is a valid window.\n        # Implcit: uniqueLetters == n\n        if lettersHavingAllFreq == n and r - l + 1 < len(s):\n          res = max(res, r - l + 1)\n\n      return res\n\n    return max(maxSubstringLengthWithNUniqueLetters(n)\n               for n in range(1, 27))",
      "title": "3104. Find Longest Self-Contained Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea2315ad-51a8-43e5-b5a0-b931ef30e8d4",
      "code": "class Solution:\n  # Similar to 978. Longest Turbulent Subarray\n  def longestMonotonicSubarray(self, nums: list[int]) -> int:\n    ans = 1\n    increasing = 1\n    decreasing = 1\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        increasing += 1\n        decreasing = 1\n      elif nums[i] < nums[i - 1]:\n        decreasing += 1\n        increasing = 1\n      else:\n        increasing = 1\n        decreasing = 1\n      ans = max(ans, increasing, decreasing)\n\n    return ans",
      "title": "3105. Longest Strictly Increasing or Strictly Decreasing Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ece75c9-4691-4366-a748-84a6cfce8157",
      "code": "class Solution:\n  def getSmallestString(self, s: str, k: int) -> str:\n    ans = list(s)\n\n    for i, c in enumerate(s):\n      if k == 0:\n        break\n      distToA = min(ord(c) - ord('a'), ord('z') - ord(c) + 1)\n      if k >= distToA:\n        k -= distToA\n        ans[i] = 'a'\n      else:\n        # k is not enough to change the current letter to 'a', so move as closer\n        # to 'a' as possible.\n        ans[i] = chr(ord(c) - k)\n        k = 0\n\n    return ''.join(ans)",
      "title": "3106. Lexicographically Smallest String After Operations With Constraint",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c09ec26-6a38-4bc2-828a-5c8c78c60c84",
      "code": "class Solution:\n  def minOperationsToMakeMedianK(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    for i in range(n // 2 + 1):\n      ans += max(0, nums[i] - k)\n\n    for i in range(n // 2, n):\n      ans += max(0, k - nums[i])\n\n    return ans",
      "title": "3107. Minimum Operations to Make Median of Array Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae21154f-d317-4ef7-88e0-f5cdd02659d7",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n    # 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    self.weight = [(1 << 17) - 1] * n\n\n  def unionByRank(self, u: int, v: int, w: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    newWeight = self.weight[i] & self.weight[j] & w\n    self.weight[i] = newWeight\n    self.weight[j] = newWeight\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def getMinCost(self, u: int, v: int) -> int:\n    if u == v:\n      return 0\n    i = self._find(u)\n    j = self._find(v)\n    return self.weight[i] if i == j else -1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumCost(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    uf = UnionFind(n)\n\n    for u, v, w in edges:\n      uf.unionByRank(u, v, w)\n\n    return [uf.getMinCost(u, v) for u, v in query]",
      "title": "3108. Minimum Cost Walk in Weighted Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27dc50a9-f98f-4259-9615-423e8ecd3764",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getPermutationIndex(self, perm: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(perm)\n    ans = 0\n    tree = FenwickTree(n)\n    fact = [1] * (n + 1)  # fact[i] := i!\n\n    for i in range(2, n + 1):\n      fact[i] = (fact[i - 1] * i) % MOD\n\n    for i, num in enumerate(perm):\n      # the number of unused numbers less than `num`\n      unusedNums = num - 1 - tree.get(num - 1)\n      suffixLength = fact[n - 1 - i]\n      ans += unusedNums * suffixLength\n      ans %= MOD\n      tree.add(num, 1)\n\n    return ans",
      "title": "3109. Find the Index of Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a1930aa-5857-4d4f-a9fa-719546e8441e",
      "code": "class Solution:\n  def scoreOfString(self, s: str) -> int:\n    return sum(abs(ord(a) - ord(b))\n               for a, b in itertools.pairwise(s))",
      "title": "3110. Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d5f0ad8-ecdf-42eb-a801-31828f7e0af8",
      "code": "class Solution:\n  def minRectanglesToCoverPoints(self, points: list[list[int]], w: int) -> int:\n    ans = 0\n    prevX = -w - 1\n    xs = sorted([x for x, _ in points])\n\n    for x in xs:\n      if x > prevX + w:\n        ans += 1\n        prevX = x\n\n    return ans",
      "title": "3111. Minimum Rectangles to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8410c38e-cbaf-4201-9aca-a5c99c12182b",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      edges: list[list[int]],\n      disappear: list[int],\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, disappear)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      disappear: list[int],\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < disappear[v] and d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return [d if d != math.inf else -1\n            for d in dist]",
      "title": "3112. Minimum Time to Visit Disappearing Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "094fc196-f0d5-4df7-87e0-081776f7c415",
      "code": "class Solution:\n  def numberOfSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n\n    for num in nums:\n      while stack and stack[-1][0] < num:\n        stack.pop()\n      if not stack or stack[-1][0] != num:\n        stack.append([num, 0])\n      stack[-1][1] += 1\n      ans += stack[-1][1]\n\n    return ans",
      "title": "3113. Find the Number of Subarrays Where Boundary Elements Are Maximum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c2ad109-053d-40a3-a230-96bf1f42ad6e",
      "code": "class Solution:\n  # Similar to 1736. Latest Time by Replacing Hidden Digits\n  def findLatestTime(self, s: str) -> str:\n    ans = list(s)\n    if s[0] == '?':\n      ans[0] = '1' if s[1] == '?' or s[1] < '2' else '0'\n    if s[1] == '?':\n      ans[1] = '1' if ans[0] == '1' else '9'\n    if s[3] == '?':\n      ans[3] = '5'\n    if s[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "3114. Latest Time You Can Obtain After Replacing Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "937bc9e6-db9f-4e51-9102-1c395e7a951c",
      "code": "class Solution:\n  def maximumPrimeDifference(self, nums: list[int]) -> int:\n    MAX = 100\n    isPrime = self._sieveEratosthenes(MAX + 1)\n    minPrimeIndex = -1\n    maxPrimeIndex = -1\n\n    for i, num in enumerate(nums):\n      if isPrime[num]:\n        if minPrimeIndex == -1:\n          minPrimeIndex = i\n        maxPrimeIndex = i\n\n    return maxPrimeIndex - minPrimeIndex\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3115. Maximum Prime Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39d662da-1bdb-4b9f-a228-7282e96ed464",
      "code": "class Solution:\n  def findKthSmallest(self, coins: list[int], k: int) -> int:\n    sizeToLcms = self._getSizeToLcms(coins)\n\n    def count(m: int) -> int:\n      \"\"\"Returns the number of denominations <= m.\"\"\"\n      res = 0\n      for sz, lcms in enumerate(sizeToLcms):\n        for lcm in lcms:\n          # Principle of Inclusion-Exclusion (PIE)\n          res += m // lcm * pow(-1, sz + 1)\n      return res\n\n    return bisect.bisect_left(range(k * min(coins)), k, key=count)\n\n  def _getSizeToLcms(self, coins: list[int]) -> list[list[int]]:\n    # Returns the LCMs for each number of combination of coins.\n    sizeToLcms = [[] for _ in range(len(coins) + 1)]\n    for sz in range(1, len(coins) + 1):\n      for combination in itertools.combinations(coins, sz):\n        sizeToLcms[sz].append(math.lcm(*combination))\n    return sizeToLcms",
      "title": "3116. Kth Smallest Amount With Single Denomination Combination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81bcd27e-206c-45ea-9f75-b0750fdcae3c",
      "code": "class Solution:\n  def minimumValueSum(self, nums: list[int], andValues: list[int]) -> int:\n    n = len(nums)\n    m = len(andValues)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum value sum of nums[i..n) and andValues[j..m), where\n      `mask` is the running value of the current subarray.\n      \"\"\"\n      if i == n and j == m:\n        return 0\n      if i == n or j == m:\n        return math.inf\n      mask &= nums[i]\n      if mask < andValues[j]:\n        return math.inf\n      if mask == andValues[j]:\n        # 1. Keep going.\n        # 2. End the subarray here and pick nums[i], then fresh start.\n        return min(dp(i + 1, j, mask),\n                   nums[i] + dp(i + 1, j + 1, -1))\n      return dp(i + 1, j, mask)  # Keep going.\n\n    ans = dp(0, 0, -1)\n    return ans if ans < math.inf else -1",
      "title": "3117. Minimum Sum of Values by Dividing Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0b02bca-f46d-457b-87b1-d2ebb7a5f379",
      "code": "class Solution:\n  def maxPotholes(self, road: str, budget: int) -> int:\n    ans = 0\n\n    for length in sorted(map(len, road.split('.')), reverse=True):\n      canRepair = max(0, budget - 1)\n      if length > canRepair:\n        return ans + canRepair\n      ans += length\n      budget -= length + 1\n\n    return ans",
      "title": "3119. Maximum Number of Potholes That Can Be Fixed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffd39542-1caf-46ac-9f4c-5026c3e62592",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = True\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3120. Count the Number of Special Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdff59f1-8722-4105-8841-eb04ef7ed572",
      "code": "class Solution:\n  def numberOfSpecialChars(self, word: str) -> int:\n    lower = collections.defaultdict(bool)\n    upper = collections.defaultdict(bool)\n\n    for c in word:\n      if c.islower():\n        lower[c] = not upper[c.upper()]\n      else:\n        upper[c] = True\n\n    return sum(lower[a] and upper[b]\n               for a, b in zip(string.ascii_lowercase,\n                               string.ascii_uppercase))",
      "title": "3121. Count the Number of Special Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ada22e8c-2b22-4316-8c7e-c70ef20f0bd2",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    count = [[0] * 10 for _ in range(n)]\n\n    for row in grid:\n      for j, num in enumerate(row):\n        count[j][num] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of minimum operations needed to make grid[:][j..n)\n      satisfy the conditions, where the (j - 1)-th column is filled with `prev`.\n      \"\"\"\n      if i == n:\n        return 0\n\n      res = math.inf\n\n      for num in range(10):\n        if i == 0 or num != prev:\n          res = min(res, m - count[i][num] + dp(i + 1, num))\n\n      return res\n\n    return dp(0, 0)",
      "title": "3122. Minimum Number of Operations to Satisfy Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6f4b5e8-65e7-46ae-ade4-f279081921d2",
      "code": "class Solution:\n  # Similar to 2203. Minimum Weighted Subgraph With the Required Paths\n  def findAnswer(self, n: int, edges: list[list[int]]) -> list[bool]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    from0 = self._dijkstra(graph, 0)\n    from1 = self._dijkstra(graph, n - 1)\n    return [from0[u] + w + from1[v] == from0[-1] or\n            from0[v] + w + from1[u] == from0[-1]\n            for u, v, w in edges]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [10**9] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "3123. Find Edges in Shortest Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de0e30c4-37ec-4973-a48c-1602258fa47d",
      "code": "class Solution:\n  def maxNumber(self, n: int) -> int:\n    # assume n = 0b00...11???\n    #        x = 0b00...01111\n    #  since y = 0b00...10000 is in [x, n]\n    #    and x & y = 0\n    return (1 << n.bit_length() - 1) - 1",
      "title": "3125. Maximum Number That Makes Result of Bitwise AND Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f2daa94-ad37-42c6-8921-bf35cae4c50e",
      "code": "class Solution:\n  def canMakeSquare(self, grid: list[list[str]]) -> bool:\n    for i in range(2):\n      for j in range(2):\n        black = 0\n        white = 0\n        for x in range(2):\n          for y in range(2):\n            if grid[i + x][j + y] == 'B':\n              black += 1\n            else:\n              white += 1\n        if black >= 3 or white >= 3:\n          return True\n    return False",
      "title": "3127. Make a Square with the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95b3c80e-b034-434c-a8eb-2e9065050f97",
      "code": "class Solution:\n  def numberOfRightTriangles(self, grid: list[list[int]]) -> int:\n    rows = [0] * len(grid)\n    cols = [0] * len(grid[0])\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          rows[i] += 1\n          cols[j] += 1\n\n    return sum((rows[i] - 1) * (cols[j] - 1)\n               for i, row in enumerate(grid)\n               for j, num in enumerate(row)\n               if num == 1)",
      "title": "3128. Right Triangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8328bfeb-679e-4737-962a-e89a2c9a85aa",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n           for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3129. Find All Possible Stable Binary Arrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf464e9e-ccdf-4ce2-8855-ea086a0a00d6",
      "code": "class Solution:\n  # Same as 3129. Find All Possible Stable Binary Arrays I\n  def numberOfStableArrays(self, zero: int, one: int, limit: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of stable arrays, where the number of\n    # occurrences of 0 is i and the number of occurrences of 1 is j and the last\n    # number is k (0/1)\n    dp = [[[0] * 2\n          for _ in range(one + 1)]\n          for _ in range(zero + 1)]\n\n    for i in range(min(zero, limit) + 1):\n      dp[i][0][0] = 1\n\n    for j in range(min(one, limit) + 1):\n      dp[0][j][1] = 1\n\n    for i in range(1, zero + 1):\n      for j in range(1, one + 1):\n        dp[i][j][0] = (\n            dp[i - 1][j][0] + dp[i - 1][j][1] -\n            (dp[i - limit - 1][j][1] if i - limit >= 1 else 0) + MOD) % MOD\n        dp[i][j][1] = (\n            dp[i][j - 1][0] + dp[i][j - 1][1] -\n            (dp[i][j - limit - 1][0] if j - limit >= 1 else 0) + MOD) % MOD\n\n    return (dp[zero][one][0] + dp[zero][one][1]) % MOD",
      "title": "3130. Find All Possible Stable Binary Arrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f9bd9171-46a0-4fc9-b4c5-344105130388",
      "code": "class Solution:\n  def addedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    return min(nums2) - min(nums1)",
      "title": "3131. Find the Integer Added to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2694e89a-6b1d-468d-b840-2c4182aad10b",
      "code": "class Solution:\n  def minimumAddedInteger(self, nums1: list[int], nums2: list[int]) -> int:\n    # After removing two elements from nums1, either nums1[0], nums1[1], or\n    # nums1[2] will persist. Therefore, the difference between nums1 (with two\n    # elements removed) and nums2 is represented by nums2[0] - nums1[i], where\n    # 0 <= i <= 2.\n    ans = math.inf\n\n    nums1.sort()\n    nums2.sort()\n\n    for i in range(3):\n      inc = nums2[0] - nums1[i]\n      if self._isValidDiff(nums1, nums2, inc):\n        ans = min(ans, inc)\n\n    return ans\n\n  def _isValidDiff(self, nums1: list[int], nums2: list[int], inc: int) -> bool:\n    \"\"\"\n    Returns True if it's possible to increase nums1 (with two elements removed)\n    by `inc` to nums2.\n    \"\"\"\n    removed = 0\n    i = 0  # nums2's index\n\n    for num in nums1:\n      if num + inc == nums2[i]:\n        i += 1\n        if i == len(nums2):\n          break\n      else:\n        removed += 1\n\n    return removed <= 2",
      "title": "3132. Find the Integer Added to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "676f7fad-acf1-4daa-a013-a59305badbcb",
      "code": "class Solution:\n  def minEnd(self, n: int, x: int) -> int:\n    # Set x's 0s with (n - 1)'s LSb-to-MSb bits, preserving x's 1s. This\n    # operation increase x for (n - 1) iterations while preserving x's 1s.\n    MAX_BIT = n.bit_length() + x.bit_length()\n    k = n - 1\n    BINARY_INDEX = 0\n\n    for i in range(MAX_BIT):\n      if x >> i & 1 == 0:\n        # Set x's 0 with k's bit if the running bit of k is 1.\n        if k >> BINARY_INDEX & 1:\n          x |= 1 << i\n        BINARY_INDEX += 1\n\n    return x",
      "title": "3133. Minimum Array End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ebc69637-4163-46f7-93ad-08aa26139576",
      "code": "class Solution:\n  def medianOfUniquenessArray(self, nums: list[int]):\n    n = len(nums)\n    subarrayCount = n * (n + 1) // 2\n    medianCount = (subarrayCount + 1) // 2\n\n    # Similar to 992. Subarrays with K Different Integers\n    def subarraysWithAtMostKDistinct(k: int) -> int:\n      res = 0\n      count = collections.Counter()\n\n      l = 0\n      for r, num in enumerate(nums):\n        count[num] += 1\n        if count[num] == 1:\n          k -= 1\n        while k < 0:\n          count[nums[l]] -= 1\n          if count[nums[l]] == 0:\n            k += 1\n          l += 1\n        res += r - l + 1  # nums[l..r], nums[l + 1..r], ..., nums[r]\n\n      return res\n\n    l = 1\n    r = n\n    return bisect.bisect_left(range(l, r), medianCount,\n                              key=subarraysWithAtMostKDistinct) + l",
      "title": "3134. Find the Median of the Uniqueness Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfe4d9fb-69ed-42c8-b121-197c875098f1",
      "code": "class Solution:\n  def minOperations(self, initial: str, target: str) -> int:\n    m = len(initial)\n    n = len(target)\n    # dp[i][j] := the length of LCS(initial[0..i), target[0..j))\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        if initial[i - 1] == target[j - 1]:\n          dp[i][j] = 1 + dp[i - 1][j - 1]\n\n    return m + n - 2 * max(map(max, dp))",
      "title": "3135. Equalize Strings by Adding or Removing Characters at Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e95faf1b-f711-4b13-b2d5-6b5eeef32327",
      "code": "class Solution:\n  def isValid(self, word: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n\n    def isConsonant(c: str) -> bool:\n      return c.isalpha() and c not in VOWELS\n\n    return (len(word) >= 3 and\n            all(c.isalnum() for c in word) and\n            any(c in VOWELS for c in word) and\n            any(isConsonant(c) for c in word))",
      "title": "3136. Valid Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8a7cada-9668-41d5-8e50-a9522ff09ddf",
      "code": "class Solution:\n  def minimumOperationsToMakeKPeriodic(self, word: str, k: int) -> int:\n    count = collections.Counter(word[i:i + k] for i in range(0, len(word), k))\n    return len(word) // k - max(count.values())",
      "title": "3137. Minimum Number of Operations to Make Word K-Periodic",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c3f40d-c234-46e7-a98f-1aae524d55df",
      "code": "class Solution:\n  def minAnagramLength(self, s: str) -> int:\n    n = len(s)\n    for k in range(1, n + 1):\n      if n % k == 0 and self._canFormAnagram(s, k):\n        return k\n    return n\n\n  def _canFormAnagram(self, s: str, k: int) -> bool:\n    \"\"\"Returns True if we can concatenate an anagram of length k to s.\"\"\"\n    anagramCount = collections.Counter(s[:k])\n    return all(collections.Counter(s[i:i + k]) == anagramCount\n               for i in range(k, len(s), k))",
      "title": "3138. Minimum Length of Anagram Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7af0ea7f-fe05-4aae-9322-7623d9b2c755",
      "code": "class Solution:\n  def minCostToEqualizeArray(\n      self,\n      nums: list[int],\n      cost1: int,\n      cost2: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    minNum = min(nums)\n    maxNum = max(nums)\n    summ = sum(nums)\n\n    if cost1 * 2 <= cost2 or n < 3:\n      totalGap = maxNum * n - summ\n      return (cost1 * totalGap) % MOD\n\n    def getMinCost(target: int) -> int:\n      \"\"\"Returns the minimum cost to make all numbers equal to `target`.\"\"\"\n      maxGap = target - minNum\n      totalGap = target * n - summ\n      # Pair one shallowest number with one non-shallowest number, so the worst\n      # case is that we have `totalGap - maxGap` non-shallowest numbers to pair.\n      pairs = min(totalGap // 2, totalGap - maxGap)\n      return cost1 * (totalGap - 2 * pairs) + cost2 * pairs\n\n    return min(getMinCost(target)\n               for target in range(maxNum, 2 * maxNum)) % MOD",
      "title": "3139. Minimum Cost to Equalize Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c97b4da-0842-44c3-8db8-efd748342a0e",
      "code": "class Solution:\n  def maxHammingDistances(self, nums: list[int], m: int) -> list[int]:\n    MAX_MASK = 1 << m\n    # dp[i] := the maximum hamming distance from i to any number in `nums`\n    dp = [-math.inf] * MAX_MASK\n\n    for num in nums:\n      dp[num] = 0\n\n    for bit in range(m):\n      newDp = [0] * MAX_MASK\n      for mask in range(MAX_MASK):\n        newDp[mask] = max(dp[mask], dp[mask ^ (1 << bit)] + 1)\n      dp = newDp\n\n    return [dp[num] for num in nums]",
      "title": "3141. Maximum Hamming Distances",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4774f07f-0bdd-418e-b588-cff91824550b",
      "code": "class Solution:\n  def satisfiesConditions(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    return (all(grid[i][j] == grid[i + 1][j]\n                for i in range(m - 1)\n                for j in range(n)) and\n            all(grid[i][j] != grid[i][j + 1]\n                for i in range(m)\n                for j in range(n - 1)))",
      "title": "3142. Check if Grid Satisfies Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eda3543e-ebc4-45dc-86b8-4cfcb9ca09d9",
      "code": "class Solution:\n  def maxPointsInsideSquare(self, points: list[list[int]], s: str) -> int:\n    secondMinSize = math.inf\n    minSizes = {}\n\n    for (x, y), c in zip(points, s):\n      sz = max(abs(x), abs(y))\n      if c not in minSizes:\n        minSizes[c] = sz\n      elif sz < minSizes[c]:\n        # This is because minSizes[j] is about to be replaced by a smaller\n        # value, so it becomes a candidate for the second minimum size.\n        secondMinSize = min(secondMinSize, minSizes[c])\n        minSizes[c] = sz\n      else:\n        # `sz` is not smaller than the current minimum size, but it could be\n        # smaller than the current second minimum size.\n        secondMinSize = min(secondMinSize, sz)\n\n    return sum(sz < secondMinSize for sz in minSizes.values())",
      "title": "3143. Maximum Points Inside the Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67416672-9026-419f-8419-626f43d59a1b",
      "code": "class Solution:\n  def minimumSubstringsInPartition(self, s: str) -> int:\n    n = len(s)\n    # dp[i] := the minimum number of substrings in s[0..i]\n    dp = [n] * n\n\n    for i in range(n):\n      count = collections.Counter()\n      for j in range(i, -1, -1):\n        count[s[j]] += 1\n        # word[j..i] is balanced.\n        if min(count.values()) == max(count.values()):\n          dp[i] = min(dp[i], 1 + dp[j - 1] if j > 0 else 1)\n\n    return dp[-1]",
      "title": "3144. Minimum Substring Partition of Equal Character Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40a95cd4-7ac5-48c1-b2ae-0c4a721e0b14",
      "code": "class Solution:\n  def findProductsOfElements(self, queries: list[list[int]]) -> list[int]:\n    def sumBitsTill(x: int) -> int:\n      \"\"\"Returns sum(i.bit_count()), where 1 <= i <= x.\"\"\"\n      sumBits = 0\n      powerOfTwo = 1\n      while powerOfTwo <= x:\n        sumBits += (x // (2 * powerOfTwo)) * powerOfTwo\n        sumBits += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo)\n        powerOfTwo *= 2\n      return sumBits\n\n    def sumPowersTill(x: int) -> int:\n      \"\"\"Returns sum(all powers of i), where 1 <= i <= x.\"\"\"\n      sumPowers = 0\n      powerOfTwo = 1\n      for power in range(x.bit_length()):\n        sumPowers += (x // (2 * powerOfTwo)) * powerOfTwo * power\n        sumPowers += max(0, x % (2 * powerOfTwo) + 1 - powerOfTwo) * power\n        powerOfTwo *= 2\n      return sumPowers\n\n    def sumPowersFirstKBigNums(k: int) -> int:\n      \"\"\"Returns the sum of powers of the first k numbers in `big_nums`.\"\"\"\n      # Find the first number in [1, k] that has sumBitsTill(num) >= k.\n      num = bisect.bisect_left(range(k), k, key=sumBitsTill)\n      sumPowers = sumPowersTill(num - 1)\n      remainingCount = k - sumBitsTill(num - 1)\n      for power in range(num.bit_length()):\n        if num >> power & 1:\n          sumPowers += power\n          remainingCount -= 1\n          if remainingCount == 0:\n            break\n      return sumPowers\n\n    return [pow(2,\n                sumPowersFirstKBigNums(b + 1) -\n                sumPowersFirstKBigNums(a), mod)\n            for a, b, mod in queries]",
      "title": "3145. Find Products of Elements of Big Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bc2264f-1a6f-4907-8ac5-e7b15c48edea",
      "code": "class Solution:\n  def findPermutationDifference(self, s: str, t: str) -> int:\n    indices = {c: i for i, c in enumerate(s)}\n    return sum([abs(indices[c] - i) for i, c in enumerate(t)])",
      "title": "3146. Permutation Difference between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51336f9e-33b3-4418-97a9-4e6c4a93573f",
      "code": "class Solution:\n  def maximumEnergy(self, energy: list[int], k: int) -> int:\n    # dp[i] := the sum of energy starting at i\n    dp = energy.copy()\n    for i in range(len(energy) - 1 - k, -1, -1):\n      dp[i] += dp[i + k]\n    return max(dp)",
      "title": "3147. Taking Maximum Energy From the Mystic Dungeon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b7d076a-f4ea-48b1-b768-7083cd221e1e",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    MAX = 200000\n    ans = -MAX\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        prevMin = min(grid[i - 1][j] if i > 0 else MAX,\n                      grid[i][j - 1] if j > 0 else MAX)\n        ans = max(ans, num - prevMin)\n        grid[i][j] = min(num, prevMin)\n\n    return ans",
      "title": "3148. Maximum Difference Score in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4b288c5-df53-49e2-9398-5c35b79ba839",
      "code": "class Solution:\n  def findPermutation(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    bestPick = [[0] * (1 << n) for _ in range(n)]\n\n    @functools.lru_cache(None)\n    def getScore(last: int, mask: int) -> int:\n      if mask.bit_count() == len(nums):\n        return abs(last - nums[0])\n\n      minScore = math.inf\n      for i in range(1, len(nums)):\n        if mask >> i & 1:\n          continue\n        nextMinScore = abs(last - nums[i]) + getScore(i, mask | (1 << i))\n        if nextMinScore < minScore:\n          minScore = nextMinScore\n          bestPick[last][mask] = i\n\n      return minScore\n\n    getScore(0, 1)\n    return self._construct(bestPick)\n\n  def _construct(self, bestPick: list[list[int]]) -> list[int]:\n    ans = []\n    last = 0\n    mask = 1\n    for _ in range(len(bestPick)):\n      ans.append(last)\n      last = bestPick[last][mask]\n      mask |= 1 << last\n    return ans",
      "title": "3149. Find the Minimum Cost Array Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5470fbc0-3c2e-4092-8452-01841eacb15e",
      "code": "class Solution:\n  def isArraySpecial(self, nums: list[int]) -> bool:\n    return all(a % 2 != b % 2 for a, b in itertools.pairwise(nums))",
      "title": "3151. Special Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f184648f-2d5e-422d-95db-2cd6c8ddabf2",
      "code": "class Solution:\n  def isArraySpecial(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    id = 0\n    # parityIds[i] := the id of the parity group that nums[i] belongs to\n    parityIds = [id]\n\n    for a, b in itertools.pairwise(nums):\n      if a % 2 == b % 2:\n        id += 1\n      parityIds.append(id)\n\n    for _from, to in queries:\n      ans.append(parityIds[_from] == parityIds[to])\n\n    return ans",
      "title": "3152. Special Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c031e36-19d0-4bae-87be-e0172477f150",
      "code": "class Solution:\n  def sumDigitDifferences(self, nums: list[int]) -> int:\n    n = len(nums)\n    digitSize = len(str(nums[0]))\n    ans = 0\n\n    denominator = 1\n    for _ in range(digitSize):\n      count = [0] * 10\n      for num in nums:\n        count[num // denominator % 10] += 1\n      ans += sum(freq * (n - freq) for freq in count)\n      denominator *= 10\n\n    return ans // 2",
      "title": "3153. Sum of Digit Differences of All Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b521d52d-a6dc-4594-901d-de86c57dd008",
      "code": "class Solution:\n  def waysToReachStair(self, k: int) -> int:\n    # Let's say we have `down` operation 1 and `jump` operation 2.\n    # The final stair is 1 + (2^0 + 2^1 + ... + 2^(jump - 1)) - down = k.\n    # => 1 + (2^jump - 1) - down = k.\n    # => down = 2^jump - k.\n    # Since `down` operations cannot be used consecutively, there're jump + 1\n    # positions (before and after each `jump`) for  `down`. The maximum jump is\n    # 29, as it satisfies the condition down = 2^jump - k <= jump + 1, with k\n    # being the maximum value of 10^9.\n    MAX_JUMP = 29\n    ans = 0\n\n    for jump in range(MAX_JUMP + 1):\n      down = (1 << jump) - k\n      if down < 0 or down > jump + 1:\n        continue\n      ans += math.comb(jump + 1, down)\n\n    return ans",
      "title": "3154. Find Number of Ways to Reach the K-th Stair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7e6658e-5205-4560-a8c6-76c476657d12",
      "code": "class Solution:\n  def maxUpgrades(\n      self,\n      count: list[int],\n      upgrade: list[int],\n      sell: list[int],\n      money: list[int],\n  ) -> list[int]:\n    # If there's enough money, upgrade all servers; otherwise, optimize by\n    # upgrading x servers. We have x * upgrade <= money + (count - x) * sell.\n    # Therefore, x = (money + count * sell) / (sell + upgrade).\n    return [min(c, (m + c * s) // (s + u))\n            for c, u, s, m in zip(count, upgrade, sell, money)]",
      "title": "3155. Maximum Number of Upgradable Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91064fe7-18e6-47bd-a21b-ac514f58ecaf",
      "code": "class Solution:\n  # Similar to 1161. Maximum Level Sum of a Binary Tree\n  def minimumLevel(self, root: TreeNode | None) -> int:\n    ans = 0\n    minLevelSum = math.inf\n    q = collections.deque([root])\n\n    level = 1\n    while q:\n      levelSum = 0\n      for _ in range(len(q)):\n        node = q.popleft()\n        levelSum += node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      if levelSum < minLevelSum:\n        minLevelSum = levelSum\n        ans = level\n      level += 1\n\n    return ans",
      "title": "3157. Find the Level of Tree with Minimum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be49c803-73da-4246-bb51-724d1ebe00fe",
      "code": "class Solution:\n  def duplicateNumbersXOR(self, nums):\n    count = collections.Counter(nums)\n    return functools.reduce(\n        operator.xor, [num for num, freq in count.items() if freq == 2],\n        0)",
      "title": "3158. Find the XOR of Numbers Which Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d171abf-5342-41b0-a2df-4327dca43ffd",
      "code": "class Solution:\n  def occurrencesOfElement(\n      self,\n      nums: list[int],\n      queries: list[int],\n      x: int,\n  ) -> list[int]:\n    indices = [i for i, num in enumerate(nums) if num == x]\n    return [indices[query - 1] if query <= len(indices) else -1\n            for query in queries]",
      "title": "3159. Find Occurrences of an Element in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3325ce89-2a41-42d2-ad62-c75fdcc23008",
      "code": "class Solution:\n  def queryResults(self, limit: int, queries: list[list[int]]) -> list[int]:\n    ans = []\n    ballToColor = {}\n    colorCount = collections.Counter()\n\n    for ball, color in queries:\n      if ball in ballToColor:\n        prevColor = ballToColor[ball]\n        colorCount[prevColor] -= 1\n        if colorCount[prevColor] == 0:\n          del colorCount[prevColor]\n      ballToColor[ball] = color\n      colorCount[color] += 1\n      ans.append(len(colorCount))\n\n    return ans",
      "title": "3160. Find the Number of Distinct Colors Among the Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53653e84-c244-4492-bdfd-c52a50f4e538",
      "code": "from sortedcontainers import SortedList\n\n\nclass FenwickTree:\n  def __init__(self, n: int):\n    self.vals = [0] * (n + 1)\n\n  def maximize(self, i: int, val: int) -> None:\n    while i < len(self.vals):\n      self.vals[i] = max(self.vals[i], val)\n      i += FenwickTree.lowtree(i)\n\n  def get(self, i: int) -> int:\n    res = 0\n    while i > 0:\n      res = max(res, self.vals[i])\n      i -= FenwickTree.lowtree(i)\n    return res\n\n  @staticmethod\n  def lowtree(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def getResults(self, queries: list[list[int]]) -> list[bool]:\n    n = min(50000, len(queries) * 3)\n    ans = []\n    tree = FenwickTree(n + 1)\n    obstacles = SortedList([0, n])  # sentinel values\n\n    for query in queries:\n      type = query[0]\n      if type == 1:\n        x = query[1]\n        obstacles.add(x)\n\n    for x1, x2 in itertools.pairwise(obstacles):\n      tree.maximize(x2, x2 - x1)\n\n    for query in reversed(queries):\n      type = query[0]\n      x = query[1]\n      if type == 1:\n        i = obstacles.index(x)\n        next = obstacles[i + 1]\n        prev = obstacles[i - 1]\n        obstacles.remove(x)\n        tree.maximize(next, next - prev)\n      else:\n        sz = query[2]\n        i = obstacles.bisect_right(x)\n        prev = obstacles[i - 1]\n        ans.append(tree.get(prev) >= sz or x - prev >= sz)\n\n    return ans[::-1]",
      "title": "3161. Block Placement Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1d6bdb4-14a5-489a-abe1-d3c353fdd423",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    return sum(num1 % (num2 * k) == 0\n               for num1 in nums1\n               for num2 in nums2)",
      "title": "3162. Find the Number of Good Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1354a78-baeb-4a14-9af2-50cd990d17bc",
      "code": "class Solution:\n  def compressedString(self, word: str) -> str:\n    n = len(word)\n    ans = []\n    i = 0\n    j = 0\n\n    while i < n:\n      count = 0\n      while j < n and word[j] == word[i] and count < 9:\n        j += 1\n        count += 1\n      ans.append(str(count) + word[i])\n      i = j\n\n    return ''.join(ans)",
      "title": "3163. String Compression III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a306600-eda2-49e7-9e52-23093ba5e4d9",
      "code": "class Solution:\n  def numberOfPairs(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    count = collections.Counter(num * k for num in nums2)\n    ans = 0\n\n    for num in nums1:\n      for divisor in range(1, int(num ** 0.5) + 1):\n        if num % divisor == 0:\n          ans += count[divisor]\n          if num // divisor != divisor:\n            ans += count[num // divisor]\n\n    return ans",
      "title": "3164. Find the Number of Good Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cf34341-6879-4120-9619-4ad8c5c0bc4f",
      "code": "class Solution:\n  def betterCompression(self, compressed: str) -> str:\n    count = collections.Counter()\n    i = 0\n\n    while i < len(compressed):\n      c = compressed[i]\n      i += 1\n      freq = 0\n      while i < len(compressed) and compressed[i].isdigit():\n        freq = freq * 10 + int(compressed[i])\n        i += 1\n      count[c] += freq\n\n    return ''.join([c + str(count[c])\n                    for c in sorted(count.keys())])",
      "title": "3167. Better Compression of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ebb20ba-57ad-4f18-9d85-69024203c432",
      "code": "class Solution:\n  def minimumChairs(self, s: str) -> int:\n    ans = 0\n    chairs = 0\n\n    for c in s:\n      chairs += 1 if c == 'E' else -1\n      ans = max(ans, chairs)\n\n    return ans",
      "title": "3168. Minimum Number of Chairs in a Waiting Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b549520b-a0c6-471a-a591-48e2420a186e",
      "code": "class Solution:\n  def countDays(self, days: int, meetings: list[list[int]]) -> int:\n    freeDays = 0\n    prevEnd = 0\n\n    for start, end in sorted(meetings):\n      if start > prevEnd:\n        freeDays += start - prevEnd - 1\n      prevEnd = max(prevEnd, end)\n\n    return freeDays + max(0, days - prevEnd)",
      "title": "3169. Count Days Without Meetings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b936de1d-76f3-4a99-9e73-7604dc1ec78c",
      "code": "class Solution:\n  def clearStars(self, s: str) -> str:\n    ans = list(s)\n    buckets = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      if c == '*':\n        ans[i] = ''\n        j = next(j for j, bucket in enumerate(buckets) if bucket)\n        ans[buckets[j].pop()] = ''\n      else:\n        buckets[ord(c) - ord('a')].append(i)\n\n    return ''.join(ans)",
      "title": "3170. Lexicographically Minimum String After Removing Stars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec357726-db74-4d19-860d-b163f7879783",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in nums:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the OR operation, the size of `next_set` will be at most\n      # bin(num).count('1') + 1.\n      dp = {num} | {val | num for val in dp}\n      ans = min(ans, min(abs(k - val) for val in dp))\n\n    return ans",
      "title": "3171. Find Subarray With Bitwise AND Closest to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "519b017f-6aae-47e1-be9f-5ee845ea337d",
      "code": "class Solution:\n  def orArray(self, nums: list[int]) -> list[int]:\n    return [a | b for a, b in itertools.pairwise(nums)]",
      "title": "3173. Bitwise OR of Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c514f4-3e21-4552-aa71-3447d4c6dd56",
      "code": "class Solution:\n  def clearDigits(self, s: str) -> str:\n    ans = []\n\n    for c in s:\n      if c.isdigit():\n        # Since `ans` only contains non-digit characters, removing the last\n        # character is equivalent to deleting the closest non-digit character.\n        ans.pop()\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "3174. Clear Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c1ef725-80bb-428d-977f-d58fa324ed0c",
      "code": "class Solution:\n  # Similar to 1535. Find the Winner of an Array Game\n  def findWinningPlayer(self, skills: list[int], k: int) -> int:\n    ans = 0\n    wins = 0\n\n    i = 1\n    while i < len(skills) and wins < k:\n      if skills[i] > skills[ans]:\n        ans = i\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "3175. Find The First Player to win K Games in a Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "123f9d71-30a0-4cf3-8574-84952a4fe8f1",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3176. Find the Maximum Length of a Good Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33a454a7-1385-43ed-98db-1d77736e52bf",
      "code": "class Solution:\n  # Same as 3176. Find the Maximum Length of a Good Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[count][num] := the maximum length of a good subsequence with at most\n    # `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\n    dp = [collections.Counter() for _ in range(k + 1)]\n    # maxLen[count] := the maximum length of a good subsequence with `count`\n    # indices where seq[i] != seq[i + 1]\n    maxLen = [0] * (k + 1)\n\n    for num in nums:\n      for count in range(k, -1, -1):\n        # Append `num` to the subsequence.\n        dp[count][num] += 1\n        if count > 0:\n          dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1)\n        maxLen[count] = max(maxLen[count], dp[count][num])\n\n    return maxLen[k]",
      "title": "3177. Find the Maximum Length of a Good Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac8d489d-fc9c-4804-9578-259b1d1c381a",
      "code": "class Solution:\n  def numberOfChild(self, n: int, k: int) -> int:\n    # the time for the ball to return to 0\n    roundTime = 2 * (n - 1)\n    pos = k % roundTime\n    return pos if pos < n else roundTime - pos",
      "title": "3178. Find the Child Who Has the Ball After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69760120-7486-43f2-94a9-88059495730d",
      "code": "class Solution:\n  def valueAfterKSeconds(self, n: int, k: int) -> int:\n    return math.comb(n + k - 1, n - 1) % 1_000_000_007",
      "title": "3179. Find the N-th Value After K Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a891cbc-f275-4c03-8c49-cda767c83625",
      "code": "# According to the constraint rewardValues[i] <= 5 * 10^4, the maximum total\n# reward < 2 * (5 * 10^4) = 10^5. We can use bitset to record whether each\n# `rewardValue` is achievable in O(1).\n#\n# Let's use `rewardValues = [1, 3, 4]` as an example.\n#\n# The maximum reward is 4, so the maximum possible total < 2 * 4 = 8.\n# Therefore, we can set the size of the bitset to 8 to represent possible\n# total rewards from 0 to 7.\n#\n# Let's define a bitset `dp` to record whether each total reward is\n# achievable. dp[num] = true if reward `num` is achievable.\n#\n# Initially, dp = 0b00000001 := reward 0 is achievable.\n#\n# * rewardValues[0] = 1, for each dp[i] = 1, where i + 1 < 10, dp[i + 1] = 1.\n#   => dp = 0b00000011 := rewards 0 and 1 are achievable.\n#\n# * rewardValues[1] = 3, for each dp[i] = 1, where i + 3 < 10, dp[i + 3] = 1.\n#   => dp = 0b00011011 := rewards 0, 1, 3, and 4 are achievable.\n#\n# * rewardValues[2] = 4, for each dp[i] = 1, where i + 4 < 10, dp[i + 4] = 1.\n#   => dp = 0b10011011 := rewards 0, 1, 3, 4, 5, and 7 are achievable.\n#\n# Therefore, the maximum total reward is 7.\n\nclass Solution:\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3180. Maximum Total Reward Using Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a7b5300-3485-4e1c-96c5-170e99cd5ba9",
      "code": "class Solution:\n  # Same as 3180. Maximum Total Reward Using Operations I\n  def maxTotalReward(self, rewardValues: list[int]) -> int:\n    dp = 1  # the possible rewards (initially, 0 is achievable)\n\n    for num in sorted(rewardValues):\n      # Remove the numbers >= the current number.\n      smallerNums = dp & ((1 << num) - 1)\n      dp |= smallerNums << num\n\n    return dp.bit_length() - 1",
      "title": "3181. Maximum Total Reward Using Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a91f9aa-b99e-4bf2-9634-fa362c687a42",
      "code": "class Solution:\n  def numberOfWays(self, n: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of ways to make the sum of i using coins 1, 2, and 6\n    dp = [1] + [0] * n\n\n    for coin in (1, 2, 6):\n      for i in range(coin, n + 1):\n        dp[i] = (dp[i] + dp[i - coin]) % MOD\n\n    ans = dp[n]\n    if n - 4 >= 0:\n      ans = (ans + dp[n - 4]) % MOD\n    if n - 8 >= 0:\n      ans = (ans + dp[n - 8]) % MOD\n    return ans",
      "title": "3183. The Number of Ways to Make the Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "813ca10d-0da7-41db-adc7-052f9852cabd",
      "code": "class Solution:\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3184. Count Pairs That Form a Complete Day I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "692e366e-beb0-4fd7-a65b-c06d67e646f9",
      "code": "class Solution:\n  # Same as 3184. Count Pairs That Form a Complete Day I\n  def countCompleteDayPairs(self, hours: list[int]) -> int:\n    ans = 0\n    count = [0] * 24\n\n    for hour in hours:\n      ans += count[(24 - hour % 24) % 24]\n      count[hour % 24] += 1\n\n    return ans",
      "title": "3185. Count Pairs That Form a Complete Day II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d03f2910-c9ba-4b0a-b127-60d76e173d1b",
      "code": "class Solution:\n  def maximumTotalDamage(self, power: list[int]) -> int:\n    count = collections.Counter(power)\n    uniqueDamages = sorted(count.keys())\n    # dp[i][k] := the maximum damage using uniqueDamages[0..i], where k\n    # indicates if the i-th damage is used\n    dp = [[0] * 2 for _ in range(len(uniqueDamages))]\n\n    for i, damage in enumerate(uniqueDamages):\n      if i == 0:\n        dp[0] = [0, damage * count[damage]]\n        continue\n      dp[i][0] = max(dp[i - 1])\n      dp[i][1] = damage * count[damage]\n      if i >= 1 and uniqueDamages[i - 1] not in (damage - 1, damage - 2):\n        dp[i][1] += max(dp[i - 1])\n      elif i >= 2 and uniqueDamages[i - 2] != damage - 2:\n        dp[i][1] += max(dp[i - 2])\n      elif i >= 3:\n        dp[i][1] += max(dp[i - 3])\n\n    return max(dp[-1])",
      "title": "3186. Maximum Total Damage With Spell Casting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f091d5b-0bd5-442e-aab1-bf68e780eb41",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def countOfPeaks(\n      self,\n      nums: list[int],\n      queries:\n      list[list[int]],\n  ) -> list[int]:\n    ans = []\n    peak = [0] + [int(a < b > c)\n                  for a, b, c in zip(nums[:-2], nums[1:-1], nums[2:])] + [0]\n    tree = FenwickTree(len(peak))\n\n    for i, p in enumerate(peak):\n      tree.add(i + 1, p)\n\n    def update(i: int) -> None:\n      \"\"\"\n      Update the peak array and Fenwick tree if the peak status of nums[i]\n      changes.\n      \"\"\"\n      newPeak = self._isPeak(nums, i)\n      if newPeak != peak[i]:\n        tree.add(i + 1, newPeak - peak[i])\n        peak[i] = newPeak\n\n    for query in queries:\n      if query[0] == 1:\n        l = query[1]\n        r = query[2]\n        ans.append(0 if r - l < 2 else tree.get(r) - tree.get(l + 1))\n      elif query[0] == 2:\n        index = query[1]\n        val = query[2]\n        nums[index] = val\n        update(index)\n        if index > 0:\n          update(index - 1)\n        if index + 1 < len(nums):\n          update(index + 1)\n\n    return ans\n\n  def _isPeak(self, nums: list[int], i: int) -> bool:\n    return i > 0 and i + 1 < len(nums) and nums[i - 1] < nums[i] > nums[i + 1]",
      "title": "3187. Peaks in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0612fc02-6b01-41d5-b705-674de6348436",
      "code": "class Solution:\n  def minMoves(self, rooks: list[list[int]]) -> int:\n    n = len(rooks)\n    sortedByRow = sorted(rooks, key=lambda x: x[0])\n    sortedByCol = sorted(rooks, key=lambda x: x[1])\n    return (sum(abs(i - row) for (i, _), row in zip(sortedByRow, range(n))) +\n            sum(abs(j - col) for (_, j), col in zip(sortedByCol, range(n))))",
      "title": "3189. Minimum Moves to Get a Peaceful Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de1911b7-6d21-47cb-b009-fa7dce002301",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return sum(num % 3 != 0 for num in nums)",
      "title": "3190. Find Minimum Operations to Make All Elements Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f1cb0ef-814b-4117-bceb-44603df390db",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2):\n      if nums[i] == 0:\n        nums[i + 1] ^= 1\n        nums[i + 2] ^= 1\n        ans += 1\n\n    return -1 if nums[-1] == 0 or nums[-2] == 0 else ans",
      "title": "3191. Minimum Operations to Make Binary Array Elements Equal to One I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0216b62-04d9-460f-ba73-afa6f412c687",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    target = 1\n\n    for num in nums:\n      if num != target:\n        ans += 1\n        target ^= 1\n\n    return ans",
      "title": "3192. Minimum Operations to Make Binary Array Elements Equal to One II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf95d684-7884-4ee7-ad45-81b1a6bb7bd2",
      "code": "class Solution:\n  def numberOfPermutations(self, n: int, requirements: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    MAX_INVERSIONS = 400\n    # dp[i][j] := the number of ways to arrange the first i numbers of the\n    # permutation s.t. there are j inversions\n    dp = [[0] * (MAX_INVERSIONS + 1) for _ in range(n + 1)]\n    endToCnt = {end + 1: cnt for end, cnt in requirements}\n\n    # There's only one way to arrange a single number with zero inversions.\n    dp[1][0] = 1\n\n    for i in range(2, n + 1):\n      for newInversions in range(i):\n        for j in range(MAX_INVERSIONS - newInversions + 1):\n          inversionsAfterInsertion = j + newInversions\n          if i in endToCnt and inversionsAfterInsertion != endToCnt[i]:\n            continue\n          dp[i][inversionsAfterInsertion] += dp[i - 1][j]\n          dp[i][inversionsAfterInsertion] %= MOD\n\n    return dp[n][endToCnt[n]]",
      "title": "3193. Count the Number of Inversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8048f7a3-d8af-403b-953d-7570c67956df",
      "code": "class Solution:\n  def minimumAverage(self, nums: list[int]) -> float:\n    nums.sort()\n    return min((nums[i] + nums[~i]) / 2\n               for i in range(len(nums) // 2 + 1))",
      "title": "3194. Minimum Average of Smallest and Largest Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7355c2b-f692-4321-ae51-dda64b1f40e1",
      "code": "class Solution:\n  def minimumArea(self, grid: list[list[int]]) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3195. Find the Minimum Area to Cover All Ones I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e243ac1-4cb1-4d6e-907a-527db35f280c",
      "code": "class Solution:\n  def maximumTotalCost(self, nums: list[int]) -> int:\n    # A small trick so that we don't need to handle the edge case and can use\n    # ranged-based for loop.\n    keep = -math.inf  # the maximum cost if the last number is kept\n    flip = 0  # the maximum cost if the last number is flipped\n\n    for num in nums:\n      keep, flip = max(keep, flip) + num, keep - num\n\n    return max(keep, flip)",
      "title": "3196. Maximize Total Cost of Alternating Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0395aeff-6314-44f8-a5e7-be019994cb0d",
      "code": "class Solution:\n  def minimumSum(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = m * n\n\n    for i in range(m):\n      top = self._minimumArea(grid, 0, i, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, top +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for i in range(m):\n      bottom = self._minimumArea(grid, i, m - 1, 0, n - 1)\n      for j in range(n):\n        ans = min(ans, bottom +\n                  self._minimumArea(grid, 0, i - 1, 0, j) +\n                  self._minimumArea(grid, 0, i - 1, j + 1, n - 1))\n\n    for j in range(n):\n      left = self._minimumArea(grid, 0, m - 1, 0, j)\n      for i in range(m):\n        ans = min(ans, left +\n                  self._minimumArea(grid, 0, i, j + 1, n - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, j + 1, n - 1))\n\n    for j in range(n):\n      right = self._minimumArea(grid, 0, m - 1, j, n - 1)\n      for i in range(m):\n        ans = min(ans, right +\n                  self._minimumArea(grid, 0, i, 0, j - 1) +\n                  self._minimumArea(grid, i + 1, m - 1, 0, j - 1))\n\n    for i1 in range(m):\n      for i2 in range(i1 + 1, m):\n        ans = min(ans, self._minimumArea(grid, 0, i1, 0, n - 1) +\n                  self._minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                  self._minimumArea(grid, i2 + 1, m - 1, 0, n - 1))\n\n    for j1 in range(n):\n      for j2 in range(j1 + 1, n):\n        ans = min(ans, self._minimumArea(grid, 0, m - 1, 0, j1) +\n                  self._minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                  self._minimumArea(grid, 0, m - 1, j2 + 1, n - 1))\n\n    return ans\n\n  def _minimumArea(\n      self,\n      grid: list[list[int]],\n      si: int,\n      ei: int,\n      sj: int,\n      ej: int,\n  ) -> int:\n    x1 = math.inf\n    y1 = math.inf\n    x2 = 0\n    y2 = 0\n    for i in range(si, ei + 1):\n      for j in range(sj, ej + 1):\n        if grid[i][j] == 1:\n          x1 = min(x1, i)\n          y1 = min(y1, j)\n          x2 = max(x2, i)\n          y2 = max(y2, j)\n    return 0 if x1 == math.inf else (x2 - x1 + 1) * (y2 - y1 + 1)",
      "title": "3197. Find the Minimum Area to Cover All Ones II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59584d9a-9d48-4987-9aca-311e387b7ddf",
      "code": "class Solution:\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3199. Count Triplets with Even XOR Set Bits I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "88c0de89-ecac-41e6-870d-f95ce8ea668d",
      "code": "class Solution:\n  def maxHeightOfTriangle(self, red: int, blue: int) -> int:\n    return max(self._maxHeight(red, blue),\n               self._maxHeight(blue, red))\n\n  def _maxHeight(self, n1: int, n2: int) -> int:\n    \"\"\"\n    Returns the maximum height of a triangle with the odd levels having `n1`\n    balls and the even levels having `n2` balls.\n    \"\"\"\n    #             1 + 3 + ... + h <= n1\n    # ((1 + h) * (n + 1) / 2) / 2 <= n1\n    #                           h <= sqrt(4 * n1) - 1\n    oddHeight = math.isqrt(4 * n1) - 1\n    #       2 + 4 + ... + h <= n2\n    # ((2 + h) * h / 2) / 2 <= n2\n    #                     h <= sqrt(4 * n2 + 1) - 1\n    evenHeight = math.isqrt(4 * n2 + 1) - 1\n    # If the difference between the odd and even heights is >= 1, we can add an\n    # extra level to the minimum height.\n    return min(oddHeight, evenHeight) + (1 if abs(oddHeight - evenHeight) >= 1\n                                         else 0)",
      "title": "3200. Maximum Height of a Triangle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "091eb750-ed80-4133-b83f-4aacd9aeaa9a",
      "code": "class Solution:\n  def maximumLength(self, nums: list[int]) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * 2 for _ in range(2)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(2):\n        dp[x % 2][y] = dp[y][x % 2] + 1\n\n    return max(map(max, dp))",
      "title": "3201. Find the Maximum Length of Valid Subsequence I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e97fbee-a242-433d-b061-42ff87ead575",
      "code": "class Solution:\n  # Similar to 3201. Find the Maximum Length of Valid Subsequence I\n  def maximumLength(self, nums: list[int], k: int) -> int:\n    # dp[i][j] := the maximum length of a valid subsequence, where the last\n    # number mod k equal to i and the next desired number mod k equal to j\n    dp = [[0] * k for _ in range(k)]\n\n    # Extend the pattern xyxyxy...xy.\n    for x in nums:\n      for y in range(k):\n        dp[x % k][y] = dp[y][x % k] + 1\n\n    return max(map(max, dp))",
      "title": "3202. Find the Maximum Length of Valid Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65590519-d6ac-400f-9103-dc78b1d727db",
      "code": "class Solution:\n  def minimumDiameterAfterMerge(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n  ) -> int:\n    diameter1 = self._getDiameter(edges1)\n    diameter2 = self._getDiameter(edges2)\n    combinedDiameter = (diameter1 + 1) // 2 + (diameter2 + 1) // 2 + 1\n    return max(diameter1, diameter2, combinedDiameter)\n\n  def _getDiameter(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    maxDiameter = [0]\n    self._maxDepth(graph, 0, -1, maxDiameter)\n    return maxDiameter[0]\n\n  # Similar to 1522. Diameter of N-Ary Tree\n  def _maxDepth(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      maxDiameter: list[int],\n  ) -> int:\n    \"\"\"Returns the maximum depth of the subtree rooted at u.\"\"\"\n    maxSubDepth1 = 0\n    maxSubDepth2 = 0\n    for v in graph[u]:\n      if v == prev:\n        continue\n      maxSubDepth = self._maxDepth(graph, v, u, maxDiameter)\n      if maxSubDepth > maxSubDepth1:\n        maxSubDepth2 = maxSubDepth1\n        maxSubDepth1 = maxSubDepth\n      elif maxSubDepth > maxSubDepth2:\n        maxSubDepth2 = maxSubDepth\n    maxDiameter[0] = max(maxDiameter[0], maxSubDepth1 + maxSubDepth2)\n    return 1 + maxSubDepth1",
      "title": "3203. Find Minimum Diameter After Merging Two Trees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "74f14e84-6c2a-49d6-a075-128969bd0f79",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # dp[i] := the maximum score to jump from index i to n - 1\n    dp = [0] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        # Jump from i to j, and then jump from j to n - 1.\n        dp[i] = max(dp[i], (j - i) * nums[j] + dp[j])\n\n    return dp[0]",
      "title": "3205. Maximum Array Hopping Score I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c153dc7-a846-4797-9605-6236774fc8f7",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int]) -> int:\n    n = len(colors)\n    return sum(colors[i] != colors[i - 1] and\n               colors[i] != colors[(i + 1) % n]\n               for i in range(n))",
      "title": "3206. Alternating Groups I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b3b9fb5-8994-4dd1-aa17-b5b5bf533475",
      "code": "class Solution:\n  def maximumPoints(self, enemyEnergies: list[int], currentEnergy: int) -> int:\n    minEnergy = min(enemyEnergies)\n    return (0 if currentEnergy < minEnergy\n            else (currentEnergy + sum(enemyEnergies) - minEnergy) // minEnergy)",
      "title": "3207. Maximum Points After Enemy Battles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73984ee1-a4da-423a-bb4e-429eccdad26b",
      "code": "class Solution:\n  def numberOfAlternatingGroups(self, colors: list[int], k: int) -> int:\n    n = len(colors)\n    ans = 0\n    alternating = 1\n\n    for i in range(n + k - 2):\n      alternating = (1 if colors[i % n] == colors[(i - 1) % n]\n                     else alternating + 1)\n      if alternating >= k:\n        ans += 1\n\n    return ans",
      "title": "3208. Alternating Groups II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "089f9719-8ad7-4809-b9da-e69ef0bd3db9",
      "code": "class Solution:\n  # Similar to 1521. Find a Value of a Mysterious Function Closest to Target\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    # the counter of all the values of subarrays that end in the previous\n    # number\n    prev = collections.Counter()\n\n    for num in nums:\n      # Extend each subarray that ends in the previous number. Due to\n      # monotonicity of the AND operation, the size of `curr` will be at most\n      # num.bit_count() + 1.\n      curr = collections.Counter({num: 1})\n      for val, freq in prev.items():\n        curr[val & num] += freq\n      ans += curr[k]\n      prev = curr\n\n    return ans",
      "title": "3209. Number of Subarrays With AND Value of K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b44b1bdc-f224-42a9-bd0d-f49411373472",
      "code": "class Solution:\n  def getEncryptedString(self, s: str, k: int) -> str:\n    k %= len(s)\n    return s[k:] + s[0:k]",
      "title": "3210. Find the Encrypted String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab9f37ad-bdf9-43b7-ac98-13ab4e9e719e",
      "code": "class Solution:\n  def validStrings(self, n: int) -> list[str]:\n    ans = []\n\n    def dfs(n: int, s: list[str]) -> None:\n      if n == 0:\n        ans.append(''.join(s))\n        return\n      if not s or s[-1] == '1':\n        s.append('0')\n        dfs(n - 1, s)\n        s.pop()\n      s.append('1')\n      dfs(n - 1, s)\n      s.pop()\n\n    dfs(n, [])\n    return ans",
      "title": "3211. Generate Binary Strings Without Adjacent Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e73d9608-0221-4b81-9fe9-91b63801e1d8",
      "code": "class Solution:\n  def numberOfSubmatrices(self, grid: list[list[str]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    x = [[0] * (n + 1) for _ in range(m + 1)]\n    # y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    y = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        x[i + 1][j + 1] = (cell == 'X') + x[i][j + 1] + x[i + 1][j] - x[i][j]\n        y[i + 1][j + 1] = (cell == 'Y') + y[i][j + 1] + y[i + 1][j] - y[i][j]\n        if x[i + 1][j + 1] > 0 and x[i + 1][j + 1] == y[i + 1][j + 1]:\n          ans += 1\n\n    return ans",
      "title": "3212. Count Submatrices With Equal Frequency of X and Y",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92dc2bc4-047b-4a28-b7b2-df401a6355a0",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0..i)\n    dp = [0] + [math.inf] * n\n    # minCost[c][word] := the minimum cost to construct word starting with `c`\n    minCost: dict[str, dict[str, int]] = collections.defaultdict(dict)\n\n    for word, cost in zip(words, costs):\n      c = word[0]\n      minCost[c][word] = min(minCost[c].get(word, math.inf), cost)\n\n    for i, c in enumerate(target):\n      for word, cost in minCost[c].items():\n        j = i + len(word)\n        if j <= n and cost + dp[i] < dp[j] and target[i:j] == word:\n          dp[j] = cost + dp[i]\n\n    return -1 if dp[n] == math.inf else dp[n]",
      "title": "3213. Construct String with Minimum Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae34c27-98ee-40ce-81b2-57d766bc2e6d",
      "code": "class Solution:\n  # Same as 3199. Count Triplets with Even XOR Set Bits I\n  def tripletCount(self, a: list[int], b: list[int], c: list[int]) -> int:\n    evenA, oddA = self._getEvenOddBitCount(a)\n    evenB, oddB = self._getEvenOddBitCount(b)\n    evenC, oddC = self._getEvenOddBitCount(c)\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC + evenA * evenB * evenC\n\n  def _getEvenOddBitCount(self, nums: list[int]) -> tuple[int, int]:\n    \"\"\"\n    Returns the count of numbers in the `nums` arrays that have even number of\n    ones and odd number of ones in their binary representation.\n    \"\"\"\n    even = sum(num.bit_count() % 2 == 0 for num in nums)\n    return (even, len(nums) - even)",
      "title": "3215. Count Triplets with Even XOR Set Bits II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd99b313-b024-4d0d-8755-767eef4d35b1",
      "code": "class Solution:\n  def getSmallestString(self, s: str) -> str:\n    chars = list(s)\n    for i, (a, b) in enumerate(itertools.pairwise(chars)):\n      if ord(a) % 2 == ord(b) % 2 and a > b:\n        chars[i], chars[i + 1] = chars[i + 1], chars[i]\n        return ''.join(chars)\n    return s",
      "title": "3216. Lexicographically Smallest String After a Swap",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14c5cbaa-58fb-4d7d-96f7-f6ae286c7f3d",
      "code": "class Solution:\n  def modifiedList(\n      self,\n      nums: list[int],\n      head: ListNode | None,\n  ) -> ListNode | None:\n    dummy = ListNode(0, head)\n    numsSet = set(nums)\n\n    curr = dummy\n    while curr.next:\n      if curr.next.val in numsSet:\n        curr.next = curr.next.next\n      else:\n        curr = curr.next\n\n    return dummy.next",
      "title": "3217. Delete Nodes From Linked List Present in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14a0680a-d7bd-4d2e-b10f-90bb9bc42e65",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3218. Minimum Cost for Cutting Cake I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4f0c63b-b398-4836-810e-e1ce87a6de6a",
      "code": "class Solution:\n  # Same as 3218. Minimum Cost for Cutting Cake I\n  def minimumCost(\n      self,\n      m: int,\n      n: int,\n      horizontalCut: list[int],\n      verticalCut: list[int],\n  ) -> int:\n    ans = 0\n    sumH = sum(horizontalCut)\n    sumV = sum(verticalCut)\n\n    horizontalCut.sort()\n    verticalCut.sort()\n\n    while horizontalCut and verticalCut:\n      if horizontalCut[-1] > verticalCut[-1]:\n        ans += horizontalCut[-1] + sumV\n        sumH -= horizontalCut.pop()\n      else:\n        ans += verticalCut[-1] + sumH\n        sumV -= verticalCut.pop()\n\n    return ans + sumH + sumV",
      "title": "3219. Minimum Cost for Cutting Cake II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9901900e-3ce5-4d0b-8394-255b47688ef9",
      "code": "class Solution:\n  # Same as 3205. Maximum Array Hopping Score I\n  def maxScore(self, nums: list[int]) -> int:\n    # The optimal jump is the maximum number in the remaining suffix.\n    return sum(itertools.accumulate(nums[:0:-1], max))",
      "title": "3221. Maximum Array Hopping Score II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59c6c92f-f813-41c1-8fa0-15e63cea38ce",
      "code": "class Solution:\n  def losingPlayer(self, x: int, y: int) -> str:\n    return 'Bob' if min(x, y // 4) % 2 == 0 else 'Alice'",
      "title": "3222. Find the Winning Player in Coin Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7994068-adbf-44fb-bdee-77c50677e908",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    count = collections.Counter(s)\n    return sum(2 if freq % 2 == 0 else 1 for freq in count.values())",
      "title": "3223. Minimum Length of String After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83118bcf-0152-4fb7-b428-e79d69f63f6a",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    pairSize = len(nums) // 2\n    diffCount = collections.Counter()  # {nums[-1 - i] - nums[i]: freq}\n    # oneChangeCount[i] := the number of pairs that need only one change to\n    # to achieve a difference of `i`\n    oneChangeCount = [0] * (k + 1)\n\n    for i in range(pairSize):\n      a = nums[i]\n      b = nums[-1 - i]\n      diffCount[abs(a - b)] += 1\n      oneChangeCount[max(a, b, k - a, k - b)] += 1\n\n    # prefixOneChangeCount[i] := the number of pairs that need only one change\n    # to achieve a difference >= `i`\n    # prefixOneChangeCount[i] = sum(oneChangeCount[i..k])\n    prefixOneChangeCount = list(\n        itertools.accumulate(reversed(oneChangeCount)))[::-1]\n\n    return min(prefixOneChangeCount[diff] - freq +  # one change\n               (pairSize - prefixOneChangeCount[diff]) * 2  # two changes\n               for diff, freq in diffCount.items())",
      "title": "3224. Minimum Array Changes to Make Differences Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca1bf305-043d-4928-a0b7-2e834dc572a9",
      "code": "class Solution:\n  def maximumScore(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    # prefix[j][i] := the sum of the first i elements in the j-th column\n    prefix = [[0] * (n + 1) for _ in range(n)]\n    # prevPick[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the previous column is in row (i - 1)\n    prevPick = [0] * (n + 1)\n    # prevSkip[i] := the maximum score up to the previous column, where the\n    # bottommost selected element in the column before the previous one is in\n    # row (i - 1)\n    prevSkip = [0] * (n + 1)\n\n    for j in range(n):\n      for i in range(n):\n        prefix[j][i + 1] = prefix[j][i] + grid[i][j]\n\n    for j in range(1, n):\n      currPick = [0] * (n + 1)\n      currSkip = [0] * (n + 1)\n      # Consider all possible combinations of the number of current and\n      # previous selected elements.\n      for curr in range(n + 1):  # the number of current selected elements\n        for prev in range(n + 1):  # the number of previous selected elements\n          if curr > prev:\n            # 1. The current bottom is deeper than the previous bottom.\n            # Get the score of grid[prev..curr)[j - 1] for both pick and skip.\n            score = prefix[j - 1][curr] - prefix[j - 1][prev]\n            currPick[curr] = max(currPick[curr], prevSkip[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevSkip[prev] + score)\n          else:\n            # 2. The previous bottom is deeper than the current bottom.\n            # Get the score of grid[curr..prev)[j] for pick only.\n            score = prefix[j][prev] - prefix[j][curr]\n            currPick[curr] = max(currPick[curr], prevPick[prev] + score)\n            currSkip[curr] = max(currSkip[curr], prevPick[prev])\n      prevPick = currPick\n      prevSkip = currSkip\n\n    return max(prevPick)",
      "title": "3225. Maximum Score From Grid Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5f00e71-8a25-435e-a199-007cd55d7ea8",
      "code": "class Solution:\n  def minChanges(self, n: int, k: int) -> int:\n    # n needs to be a superset of k.\n    return (n ^ k).bit_count() if (n & k) == k else -1",
      "title": "3226. Number of Bit Changes to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63ef043b-56cf-47f5-9c70-8c8fe7684aa2",
      "code": "class Solution:\n  def doesAliceWin(self, s: str) -> bool:\n    # Let k be the number of vowels in s.\n    # 1. If k == 0, Bob wins since Alice has no vowels to pick.\n    # 2. If k % 2 == 1, Alice wins since Alice can pick the entire string.\n    # 3. If k % 2 == 0, Alice wins since Alice can pick (k - 1) vowels,\n    # then Bob will either pick a substring containing 0 vowels, resulting in\n    # Alice picking the remaining entire string, or Bob couldn't pick at all\n    # (the last vowel).\n    VOWELS = 'aeiou'\n    return any(c in VOWELS for c in s)",
      "title": "3227. Vowels Game in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af35e6d5-0316-4fb9-a8a6-f4eaf9d57f76",
      "code": "class Solution:\n  def maxOperations(self, s: str) -> int:\n    ans = 0\n    ones = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        ones += 1\n      elif i + 1 == len(s) or s[i + 1] == '1':\n        ans += ones\n\n    return ans",
      "title": "3228. Maximum Number of Operations to Move Ones to the End",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e87ca758-4654-4eeb-b108-41ddd960b50a",
      "code": "class Solution:\n  # Similar to 1526. Minimum Number of Increments on Subarrays to Form a Target Array\n  def minimumOperations(self, nums: list[int], target: list[int]) -> int:\n    ans = abs(nums[0] - target[0])\n\n    for (prevNum, prevTarget), (currNum, currTarget) in (\n        itertools.pairwise(zip(nums, target))\n    ):\n      currDiff = currTarget - currNum\n      prevDiff = prevTarget - prevNum\n      if currDiff >= 0 and prevDiff >= 0:\n        ans += max(0, currDiff - prevDiff)\n      elif currDiff <= 0 and prevDiff <= 0:\n        ans += max(0, abs(currDiff) - abs(prevDiff))\n      else:\n        ans += abs(currDiff)\n\n    return ans",
      "title": "3229. Minimum Operations to Make Array Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3796119-488c-4730-b357-994e767eb49d",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return self._lengthOfLIS(nums[::-1])\n\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num >= tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_right(tails, num)] = num\n    return len(tails)",
      "title": "3231. Minimum Number of Increasing Subsequence to Be Removed",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0bdc45d-8f15-4c25-9b41-fbf8719625df",
      "code": "class Solution:\n  def canAliceWin(self, nums: list[int]) -> bool:\n    return sum(num if num < 10 else -num for num in nums) != 0",
      "title": "3232. Find if Digit Game Can Be Won",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fed8e8b3-e91d-4df6-ab37-92acdcaa3947",
      "code": "class Solution:\n  def nonSpecialCount(self, l: int, r: int) -> int:\n    maxRoot = math.isqrt(r)\n    isPrime = self._sieveEratosthenes(maxRoot + 1)\n    specialCount = 0\n\n    for num in range(2, math.isqrt(r) + 1):\n      if isPrime[num] and l <= num**2 <= r:\n        specialCount += 1\n\n    return r - l + 1 - specialCount\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3233. Find the Count of Numbers Which Are Not Special",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85cb98d7-7c3d-48d8-bfd5-a31f1bcb877d",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    #    z^2 + z = n.\n    # => z^2 + z - n = 0.\n    # => z = (-1 + sqrt(1 + 4n)) / 2.\n    maxZero = (-1 + math.sqrt(1 + 4 * len(s))) // 2\n\n    # Iterate through all possible number of 0s.\n    for zero in range(int(maxZero) + 1):\n      lastInvalidPos = -1\n      count = [0, 0]\n      l = 0\n      for r, c in enumerate(s):\n        count[int(c)] += 1\n        # Try to shrink the window to maintain the \"minimum\" length of the\n        # valid substring.\n        while l < r:\n          if s[l] == '0' and count[0] > zero:\n            count[0] -= 1  # Remove an extra '0'.\n            lastInvalidPos = l\n            l += 1\n          elif s[l] == '1' and count[1] - 1 >= zero * zero:\n            count[1] -= 1  # Remove an extra '1'.\n            l += 1\n          else:\n            break  # Cannot remove more characters.\n        if count[0] == zero and count[1] >= zero * zero:\n          # Add valid substrings ending in s[r] to the answer. They are\n          # s[lastInvalidPos + 1..r], s[lastInvalidPos + 2..r], ..., s[l..r].\n          ans += l - lastInvalidPos\n\n    return ans",
      "title": "3234. Count the Number of Substrings With Dominant Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa81cd8e-3bb0-456b-ba2e-4a411acbb61c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def canReachCorner(self, X: int, Y: int, circles: list[list[int]]) -> bool:\n    n = len(circles)\n    # Add two virtual nodes, where node n represents (0, 0) and node n + 1\n    # represents (X, Y).\n    uf = UnionFind(n + 2)\n\n    # Iterate through each circle.\n    for i, (x, y, r) in enumerate(circles):\n      # Union the current circle with the node (0, 0) if the circle overlaps\n      # with the left or top edges.\n      if x - r <= 0 or y + r >= Y:\n        uf.unionByRank(i, n)\n      # Union the current circle with the node (X, Y) if the circle overlaps\n      # with the right or bottom edges.\n      if x + r >= X or y - r <= 0:\n        uf.unionByRank(i, n + 1)\n      # Union the current circle with previous circles if they overlap.\n      for j in range(i):\n        x2, y2, r2 = circles[j]\n        if (x - x2)**2 + (y - y2)**2 <= (r + r2)**2:\n          uf.unionByRank(i, j)\n\n    # If nodes (0, 0) and (X, Y) are in the same union set, that means there's\n    # a path of overlapping circles that connects the left or top edges to the\n    # right or bottom edges, implying that (0, 0) cannot reach (X, Y).\n    return uf.find(n) != uf.find(n + 1)",
      "title": "3235. Check if the Rectangle Corner Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d57de66d-9fcf-48d8-9c0f-d00596edd192",
      "code": "class Solution:\n  def simulationResult(\n      self,\n      windows: list[int],\n      queries: list[int],\n  ) -> list[int]:\n    ans = []\n    seen = set()\n\n    for query in reversed(queries):\n      if query not in seen:\n        ans.append(query)\n        seen.add(query)\n\n    for window in windows:\n      if window not in seen:\n        ans.append(window)\n        seen.add(window)\n\n    return ans",
      "title": "3237. Alt and Tab Simulation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca6cbefb-3a2b-4b74-ae50-e275e2fc62cc",
      "code": "class Solution:\n  def winningPlayerCount(self, n: int, pick: list[list[int]]) -> int:\n    counts = [collections.Counter() for _ in range(n)]\n    for player, color in pick:\n      counts[player][color] += 1\n    return sum(max(count.values(), default=0) > i\n               for i, count in enumerate(counts))",
      "title": "3238. Find the Number of Winning Players",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "316548c5-e85f-4f20-8a5c-49e0882b4c34",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    rowFlips = sum(row[i] != row[-1 - i]\n                   for row in grid for i in range(len(row) // 2))\n    colFlips = sum(col[i] != col[-1 - i] for col in zip(*grid)\n                   for i in range(len(col) // 2))\n    return min(rowFlips, colFlips)",
      "title": "3239. Minimum Number of Flips to Make Binary Grid Palindromic I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d31d314-4325-4b4a-8db8-df84b35ab3b2",
      "code": "class Solution:\n  def minFlips(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    middleOnes = 0\n    mismatchedPairs = 0\n\n    # Handle top-left, top-right, bottom-left, bottom-right cells.\n    for i in range(m // 2):\n      for j in range(n // 2):\n        ones = (grid[i][j] + grid[i][n - 1 - j] +\n                grid[m - 1 - i][j] + grid[m - 1 - i][n - 1 - j])\n        ans += min(ones, 4 - ones)\n\n    # Handle the middle row if the number of m is odd.\n    if m % 2 == 1:\n      for j in range(n // 2):\n        leftCell = grid[m // 2][j]\n        rightCell = grid[m // 2][n - 1 - j]\n        mismatchedPairs += leftCell ^ rightCell\n        middleOnes += leftCell + rightCell\n\n    # Handle the middle column if the number of columns is odd.\n    if n % 2 == 1:\n      for i in range(m // 2):\n        topCell = grid[i][n // 2]\n        bottomCell = grid[m - 1 - i][n // 2]\n        mismatchedPairs += topCell ^ bottomCell\n        middleOnes += topCell + bottomCell\n\n    if mismatchedPairs == 0:\n      # Since there's no mismatched pairs, middleOnes % 4 must be 0 or 2.\n      if middleOnes % 4 == 2:\n        ans += 2  # Flip two 1s to 0s.\n    else:\n      # Flip every mismatched pair 01 to 00 or 11. It doesn't matter.\n      ans += mismatchedPairs\n\n    # Handle the center cell if both dimensions are odd.\n    if m % 2 == 1 and n % 2 == 1:\n      ans += grid[m // 2][n // 2]\n\n    return ans",
      "title": "3240. Minimum Number of Flips to Make Binary Grid Palindromic II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "33960178-e6f2-4e25-8474-d40729430f18",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time taken to mark the entire subtree rooted at the node\n\n\nclass Top2:\n  def __init__(self, top1: Node = Node(), top2: Node = Node()):\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the maximum\n    self.top1 = top1\n    # the direct child node, where the time taken to mark the entire subtree\n    # rooted at the node is the second maximum\n    self.top2 = top2\n\n\nclass Solution:\n  def timeTaken(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the top two direct child nodes for subtree rooted at node i,\n    # where each node contains the time taken to mark the entire subtree rooted\n    # at the node itself\n    dp = [Top2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, 0, dp, ans)\n    return ans\n\n  def _getTime(self, u: int) -> int:\n    \"\"\"Returns the time taken to mark node u.\"\"\"\n    return 2 if u % 2 == 0 else 1\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Top2]\n  ) -> int:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the top two direct\n    child nodes, where the time taken to mark the subtree rooted at each of the\n    child nodes is maximized, and returns the top child node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    top1 = Node()\n    top2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      time = self._dfs(tree, v, u, dp) + self._getTime(v)\n      if time >= top1.time:\n        top2 = top1\n        top1 = Node(v, time)\n      elif time > top2.time:\n        top2 = Node(v, time)\n    dp[u] = Top2(top1, top2)\n    return top1.time\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      maxTime: int,\n      dp: list[Top2],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `maxTime`\n    is the longest path that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = max(maxTime, dp[u].top1.time)\n\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newMaxTime = self._getTime(u) + max(\n          maxTime,\n          dp[u].top2.time if dp[u].top1.node == v else dp[u].top1.time\n      )\n      self._reroot(tree, v, u, newMaxTime, dp, ans)",
      "title": "3241. Time Taken to Mark All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af1c724c-fead-498e-ba61-db047051d484",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    dist = list(range(n))\n    graph = [[] for _ in range(n)]\n\n    for i in range(n - 1):\n      graph[i].append(i + 1)\n\n    for u, v in queries:\n      graph[u].append(v)\n      if dist[u] + 1 < dist[v]:\n        dist[v] = dist[u] + 1\n        self._bfs(graph, v, dist)\n      ans.append(dist[n - 1])\n\n    return ans\n\n  def _bfs(self, graph: list[list[int]], start: int, dist: list[int]) -> None:\n    \"\"\"\n    Performs a BFS to update the shortest distances from the given `start` node\n    to all other reachable nodes in the graph. It updates the `dist` vector\n    with the new shortest distances.\n    \"\"\"\n    q = collections.deque([start])\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        if dist[u] + 1 < dist[v]:\n          dist[v] = dist[u] + 1\n          q.append(v)",
      "title": "3243. Shortest Distance After Road Addition Queries I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85440626-e419-4abe-b585-24df2f19a195",
      "code": "class Solution:\n  def shortestDistanceAfterQueries(\n      self,\n      n: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    nodeToFarthestNode = {i: i + 1 for i in range(n - 1)}\n\n    for u, v in queries:\n      # If `u` exists in the map and `v` is farther than the current farthest\n      # node for `u`, we need to update the map and remove intermediate nodes.\n      if u in nodeToFarthestNode and nodeToFarthestNode[u] < v:\n        node = nodeToFarthestNode[u]\n        while node < v:\n          node = nodeToFarthestNode.pop(node)\n        nodeToFarthestNode[u] = v\n      ans.append(len(nodeToFarthestNode))\n\n    return ans",
      "title": "3244. Shortest Distance After Road Addition Queries II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cc10804-b25b-46f9-ac1a-8242df01c671",
      "code": "class Solution:\n  def subsequenceCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    even = 0  # the number of subsequences with even sum\n    odd = 0  # the number of subsequences with odd sum\n\n    for num in nums:\n      if num % 2 == 0:\n        # Appending an even number to a subsequence doesn't change the parity.\n        # The even number itself is also a valid subsequence.\n        even, odd = even + even + 1, odd + odd\n      else:\n        # Appending an odd number to a subsequence changes the parity.\n        # The odd number itself is also a valid subsequence.\n        even, odd = even + odd, odd + even + 1\n\n    return odd % MOD",
      "title": "3247. Number of Subsequences with Odd Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a79903b-b54b-4fdc-9853-04798ab3da62",
      "code": "class Solution:\n  def finalPositionOfSnake(self, n: int, commands: list[str]) -> int:\n    directions = {\n        \"UP\": (-1, 0),\n        \"RIGHT\": (0, 1),\n        \"DOWN\": (1, 0),\n        \"LEFT\": (0, -1),\n    }\n    i = 0\n    j = 0\n\n    for command in commands:\n      dx, dy = directions[command]\n      i += dx\n      j += dy\n\n    return i * n + j",
      "title": "3248. Snake in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc783635-83fa-4f39-9f44-7a143a6b3fb2",
      "code": "class Solution:\n  def countGoodNodes(self, edges: list[list[int]]) -> int:\n    n = len(edges) + 1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    ans = 0\n\n    def dfs(u: int, prev: int) -> int:\n      \"\"\"Returns the size of the subtree rooted at u.\"\"\"\n      nonlocal ans\n      size = 1\n      childrenSizes = []\n      for v in graph[u]:\n        if v == prev:\n          continue\n        child_size = dfs(v, u)\n        size += child_size\n        childrenSizes.append(child_size)\n\n      if not childrenSizes or all(s == childrenSizes[0]\n                                  for s in childrenSizes):\n        ans += 1\n\n      return size\n\n    dfs(0, -1)\n    return ans",
      "title": "3249. Count the Number of Good Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54fa04fc-d2b6-4825-88c8-28095e877674",
      "code": "class Solution:\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3250. Find the Count of Monotonic Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc3da7fd-994d-410d-aad9-11f8b2ab04aa",
      "code": "class Solution:\n  # Same as 3250. Find the Count of Monotonic Pairs I\n  def countOfPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = 1000\n    n = len(nums)\n    # dp[i][num] := the number of valid ways to fill the arrays up to index i\n    # with arr1[i] = num\n    dp = [[0] * (MAX + 1) for _ in range(n)]\n\n    for num in range(nums[0] + 1):\n      dp[0][num] = 1\n\n    for i in range(1, n):\n      ways = 0\n      prevNum = 0\n      # To satisfy arr1, prevNum <= num.\n      # To satisfy arr2, nums[i - 1] - prevNum >= nums[i] - num.\n      #               => prevNum <= min(num, num - (nums[i] - nums[i - 1])).\n      # As we move from `num` to `num + 1`, the range of valid `prevNum` values\n      # becomes prevNum <= min(num + 1, num + 1 - (nums[i] - nums[i - 1])).\n      # Since the range of `prevNum` can only increase by at most 1, there's\n      # no need to iterate through all possible values of `prevNum`. We can\n      # simply increment `prevNum` by 1 if it meets the condition.\n      for num in range(nums[i] + 1):\n        if prevNum <= min(num, num - (nums[i] - nums[i - 1])):\n          ways = (ways + dp[i - 1][prevNum]) % MOD\n          prevNum += 1\n        dp[i][num] = ways\n\n    return sum(dp[n - 1]) % MOD",
      "title": "3251. Find the Count of Monotonic Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3494f56-dbfa-444b-b18b-23544c399222",
      "code": "class Solution:\n  def minimumCost(self, target: str, words: list[str], costs: list[int]) -> int:\n    n = len(target)\n    # dp[i] := the minimum cost to construct target[0:i]\n    dp = [0] + [math.inf] * n\n\n    for i in range(1, n + 1):\n      for j, (word, cost) in enumerate(zip(words, costs)):\n        if (i >= len(word) and\n            target[i - len(word):i] == word and\n                dp[i - len(word)] != math.inf):\n          dp[i] = min(dp[i], dp[i - len(word)] + cost)\n\n    return dp[n] if dp[n] != math.inf else -1",
      "title": "3253. Construct String with Minimum Cost (Easy)",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "099818b6-edc6-41c8-a8b9-95dedaa922d5",
      "code": "class Solution:\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3254. Find the Power of K-Size Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "371be480-97de-46ab-a096-4d4b8192febb",
      "code": "class Solution:\n  # Same as 3254. Find the Power of K-Size Subarrays I\n  def resultsArray(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    start = 0\n\n    for i, num in enumerate(nums):\n      if i > 0 and num != nums[i - 1] + 1:\n        start = i\n      if i >= k - 1:\n        ans.append(num if i - start + 1 >= k else -1)\n\n    return ans",
      "title": "3255. Find the Power of K-Size Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64df7493-71f8-4ed5-9923-08c2cd086b25",
      "code": "class Solution:\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3256. Maximum Value Sum by Placing Three Rooks I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d418489f-9198-4ba8-8446-47ff15d2588e",
      "code": "class Solution:\n  # Same as 3256. Maximum Value Sum by Placing Three Rooks I\n  def maximumValueSum(self, board: list[list[int]]) -> int:\n    rows = [heapq.nlargest(3, [(val, i, j)\n            for j, val in enumerate(row)])\n            for i, row in enumerate(board)]\n    cols = [heapq.nlargest(3, [(val, i, j)\n            for i, val in enumerate(col)])\n            for j, col in enumerate(zip(*board))]\n    topNine = heapq.nlargest(9,\n                             set(itertools.chain(*rows)) &\n                             set(itertools.chain(*cols)))\n    return max(\n        (val1 + val2 + val3 for\n         (val1, i1, j1),\n         (val2, i2, j2),\n         (val3, i3, j3) in (itertools.combinations(topNine, 3))\n         if len({i1, i2, i3}) == 3 and len({j1, j2, j3}) == 3))",
      "title": "3257. Maximum Value Sum by Placing Three Rooks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f99a8299-c4d1-401e-99db-eb3147cd42b0",
      "code": "class Solution:\n  def countKConstraintSubstrings(self, s: str, k: int) -> int:\n    ans = 0\n    count = [0, 0]\n\n    l = 0\n    for r, c in enumerate(s):\n      count[int(c)] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "3258. Count Substrings That Satisfy K-Constraint I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63177be8-ec23-4a9a-976c-2d1debcf4bdd",
      "code": "class Solution:\n  def maxEnergyBoost(\n      self,\n      energyDrinkA: list[int],\n      energyDrinkB: list[int]\n  ) -> int:\n    dpA = 0  # the maximum energy boost if the last drink is A\n    dpB = 0  # the maximum energy boost if the last drink is B\n\n    for a, b in zip(energyDrinkA, energyDrinkB):\n      dpA, dpB = max(dpB, dpA + a), max(dpA, dpB + b)\n\n    return max(dpA, dpB)",
      "title": "3259. Maximum Energy Boost From Two Drinks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f66405ed-1f26-47e2-8640-830e6abeb722",
      "code": "class Solution:\n  def largestPalindrome(self, n: int, k: int) -> str:\n    match k:\n      case 1:\n        return '9' * n\n      case 2:\n        return '8' * n if n <= 2 else '8' + '9' * (n - 2) + '8'\n      case 3 | 9:\n        return '9' * n\n      case 4:\n        return '8' * n if n <= 4 else '88' + '9' * (n - 4) + '88'\n      case 5:\n        return '5' * n if n <= 2 else '5' + '9' * (n - 2) + '5'\n      case 6:\n        if n <= 2:\n          return '6' * n\n        elif n % 2 == 1:\n          l = n // 2 - 1\n          return '8' + '9' * l + '8' + '9' * l + '8'\n        else:\n          l = n // 2 - 2\n          return '8' + '9' * l + '77' + '9' * l + '8'\n      case 8:\n        return '8' * n if n <= 6 else '888' + '9' * (n - 6) + '888'\n      case _:\n        middle = {\n            0: '', 1: '7', 2: '77', 3: '959', 4: '9779', 5: '99799',\n            6: '999999', 7: '9994999', 8: '99944999', 9: '999969999',\n            10: '9999449999', 11: '99999499999'\n        }\n        q, r = divmod(n, 12)\n        return '999999' * q + middle[r] + '999999' * q",
      "title": "3260. Find the Largest Palindrome Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "175f6cd6-ea8e-4e76-9e9b-c4f8e5390908",
      "code": "class Solution:\n  def countKConstraintSubstrings(\n      self,\n      s: str,\n      k: int,\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(s)\n    ans = []\n    count = [0, 0]\n    # leftToRight[l] := the maximum right index r s.t. s[l..r] is valid\n    leftToRight = [0] * n\n    # rightToLeft[r] := the minimum left index l s.t. s[l..r] is valid\n    rightToLeft = [0] * n\n\n    l = 0\n    for r in range(n):\n      count[int(s[r])] += 1\n      while min(count) > k:\n        count[int(s[l])] -= 1\n        l += 1\n      rightToLeft[r] = l\n\n    count = [0, 0]\n    r = n - 1\n    for l in reversed(range(n)):\n      count[int(s[l])] += 1\n      while min(count) > k:\n        count[int(s[r])] -= 1\n        r -= 1\n      leftToRight[l] = r\n\n    # prefix[i] := the number of valid substrings ending in [0..i - 1].\n    prefix = list(itertools.accumulate((r - l + 1\n                                       for r, l in enumerate(rightToLeft)),\n                                       initial=0))\n\n    for l, r in queries:\n      if r > leftToRight[l]:\n        # If r is beyond leftToRight[l], compute the number of valid substrings\n        # from l to leftToRight[l] and add the number of valid substrings\n        # ending in [leftToRight[l] + 1..r].\n        #\n        # prefix[r + 1] := the number of valid substrings ending in [0..r].\n        # prefix[leftToRight[l] + 1] := the number of valid substrings ending\n        # in [0..leftToRight].\n        # => prefix[r + 1] - prefix[leftToRight[l] + 1] := the number of valid\n        # substrings ending in [leftToRight[l] + 1..r].\n        sz = leftToRight[l] - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2 + (\n            prefix[r + 1] - prefix[leftToRight[l] + 1])\n      else:\n        # If r is within the range of leftToRight[l], compute the number of\n        # valid substrings directly from l to r.\n        sz = r - l + 1\n        numValidSubstrings = sz * (sz + 1) // 2\n      ans.append(numValidSubstrings)\n\n    return ans",
      "title": "3261. Count Substrings That Satisfy K-Constraint II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1a926f0-7bd6-4776-acc7-5ba50b419f5d",
      "code": "class Solution:\n  def toArray(self, head: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = head\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3263. Convert Doubly Linked List to Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8097ec82-99bd-4fec-baf3-097fc4a4fd39",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    ans = [0] * len(nums)\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n\n    for num, i in minHeap:\n      ans[i] = num\n\n    return ans",
      "title": "3264. Final Array State After K Multiplication Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89b076ae-3e7a-4492-b47b-1b71316b00ca",
      "code": "class Solution:\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 swap.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3265. Count Almost Equal Pairs I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fd76d40-dfd1-495c-a2d3-f6c13796e7ad",
      "code": "class Solution:\n  def getFinalState(\n      self,\n      nums: list[int],\n      k: int,\n      multiplier: int\n  ) -> list[int]:\n    if multiplier == 1:\n      return nums\n\n    MOD = 1_000_000_007\n    n = len(nums)\n    maxNum = max(nums)\n    ans = [0] * n\n    minHeap = [(num, i) for i, num in enumerate(nums)]\n\n    heapq.heapify(minHeap)\n\n    # Keep multiplying the minimum number as close as possible to the maximum\n    # number in the array. After that, stop multiplying the minimum number\n    # because it will be greater than the maximum number in the array and break\n    # the circularity.\n    while k > 0 and minHeap[0][0] * multiplier <= maxNum:\n      num, i = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, (num * multiplier, i))\n      k -= 1\n\n    sortedIndexedNums = sorted(minHeap)\n    multipliesPerNum, remainingK = divmod(k, n)\n\n    # Evenly distribute the remaining multiplications to each number by using\n    # fast exponentiation.\n    for index, (num, i) in enumerate(sortedIndexedNums):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] *\n          pow(multiplier, multipliesPerNum, MOD) % MOD, i)\n\n    # Distribute the remaining multiplications to the minimum `remainingK`\n    # numbers.\n    for index in range(remainingK):\n      sortedIndexedNums[index] = (\n          sortedIndexedNums[index][0] * multiplier % MOD,\n          sortedIndexedNums[index][1])\n\n    for num, i in sortedIndexedNums:\n      ans[i] = num\n\n    return ans",
      "title": "3266. Final Array State After K Multiplication Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4c6e133-9894-46da-adba-e446a92bbf1c",
      "code": "class Solution:\n  # Similar to 3265. Count Almost Equal Pairs I\n  def countPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()\n    maxLen = len(str(max(nums)))\n\n    for num in nums:\n      digits = list(str(num).zfill(maxLen))\n      for swap in self._getSwaps(digits):\n        ans += count[swap]\n      count[num] += 1\n\n    return ans\n\n  def _getSwaps(self, digits: str) -> set[int]:\n    \"\"\"Returns all possible numbers after 1 or 2 swaps.\"\"\"\n    n = len(digits)\n    swaps = set([int(''.join(digits))])\n\n    # Add all numbers after 1 swap.\n    for i, j in itertools.combinations(range(n), 2):\n      newDigits = digits[:]\n      newDigits[i], newDigits[j] = newDigits[j], newDigits[i]\n      swaps.add(int(''.join(newDigits)))\n\n    # Add all numbers after 2 swaps.\n    for (i1, j1), (i2, j2) in itertools.combinations(\n            itertools.combinations(range(n), 2), 2):\n      newDigits = digits[:]\n      newDigits[i1], newDigits[j1] = newDigits[j1], newDigits[i1]\n      newDigits[i2], newDigits[j2] = newDigits[j2], newDigits[i2]\n      swaps.add(int(''.join(newDigits)))\n\n    return swaps",
      "title": "3267. Count Almost Equal Pairs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64a7fea8-8345-4bdd-b778-0e9c27f252af",
      "code": "class Solution:\n  def minLargest(self, nums1: list[int], nums2: list[int]) -> int:\n    m = len(nums1)\n    n = len(nums2)\n    # dp[i][j] := the minimum largest number for the first i nums1 and the\n    # first j nums2\n    dp = [[math.inf] * (n + 1) for _ in range(m + 1)]\n    dp[0][0] = 0\n\n    def f(prev: int, num: int) -> int:\n      \"\"\"\n      Returns the next number to fill in the array based on the previous number\n      and the current number.\n      \"\"\"\n      return prev + (2 if prev % 2 == num else 1)\n\n    for i in range(m + 1):\n      for j in range(n + 1):\n        if i > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i - 1][j], nums1[i - 1]))\n        if j > 0:\n          dp[i][j] = min(dp[i][j], f(dp[i][j - 1], nums2[j - 1]))\n\n    return dp[m][n]",
      "title": "3269. Constructing Two Increasing Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbba76a5-7e7c-4381-9d89-9cf8367f4173",
      "code": "class Solution:\n  def generateKey(self, num1: int, num2: int, num3: int) -> int:\n    return int(''.join(min(a, b, c)\n                       for a, b, c in zip(str(num1).zfill(4),\n                                          str(num2).zfill(4),\n                                          str(num3).zfill(4))))",
      "title": "3270. Find the Key of the Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c67a208-34cc-4896-b7b7-25dd76275ede",
      "code": "class Solution:\n  def stringHash(self, s: str, k: int) -> str:\n    ans = []\n\n    for i in range(0, len(s), k):\n      sumHash = sum(string.ascii_lowercase.index(s[j])\n                    for j in range(i, i + k))\n      ans.append(string.ascii_lowercase[sumHash % 26])\n\n    return ''.join(ans)",
      "title": "3271. Hash Divided String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58292228-6e19-4d67-96b9-ede2dc32abd7",
      "code": "class Solution:\n  def countGoodIntegers(self, n: int, k: int) -> int:\n    halfLength = (n + 1) // 2\n    minHalf = 10**(halfLength - 1)\n    maxHalf = 10**halfLength\n    ans = 0\n    seen = set()\n\n    for num in range(minHalf, maxHalf):\n      palindrome = str(num) + str(num)[::-1][n % 2:]\n      sortedDigits = ''.join(sorted(palindrome))\n      if int(palindrome) % k != 0 or sortedDigits in seen:\n        continue\n      seen.add(sortedDigits)\n      digitCount = collections.Counter(palindrome)\n      # Leading zeros are not allowed, so the first digit is special.\n      firstDigitChoices = n - digitCount['0']\n      permutations = firstDigitChoices * math.factorial(n - 1)\n      # For each repeated digit, divide by the factorial of the frequency since\n      # permutations that swap identical digits don't create a new number.\n      for freq in digitCount.values():\n        permutations //= math.factorial(freq)\n      ans += permutations\n\n    return ans",
      "title": "3272. Find the Count of Good Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be87a9d8-247b-4e25-b2ba-4b1d372fed83",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Enemy:\n  damage: int\n  timeTakenDown: int\n\n\nclass Solution:\n  def minDamage(self, power: int, damage: list[int], health: list[int]) -> int:\n    ans = 0\n    sumDamage = sum(damage)\n    enemies = [Enemy(d, (h + power - 1) // power)\n               for d, h in zip(damage, health)]\n\n    # It's better to take down the enemy i first if the damage dealt of taking\n    # down i first is less than the damage dealt of taking down j first. So,\n    #    damage[i] * t[i] + (t[i] + t[j]) * damage[j] <\n    #    damage[j] * t[j] + (t[i] + t[j]) * damage[i]\n    # => damage[i] * t[i] + damage[j] * t[i] + damage[j] * t[j] <\n    #    damage[j] * t[j] + damage[i] * t[j] + damage[i] * t[i]\n    # => damage[j] * t[i] < damage[i] * t[j]\n    # => damage[j] / t[j] < damage[i] / t[i]\n    enemies.sort(key=lambda x: -x.damage / x.timeTakenDown)\n\n    for enemy in enemies:\n      ans += sumDamage * enemy.timeTakenDown\n      sumDamage -= enemy.damage\n\n    return ans",
      "title": "3273. Minimum Amount of Damage Dealt to Bob",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9cbf9ff-efbe-48aa-85f4-a697e6e06086",
      "code": "class Solution:\n  def checkTwoChessboards(self, coordinate1: str, coordinate2: str) -> bool:\n    # Same as 1812. Determine Color of a Chessboard Square\n    def squareIsWhite(coordinate: str) -> bool:\n      letter, digit = coordinate\n      return ord(letter) % 2 != int(digit) % 2\n\n    return squareIsWhite(coordinate1) == squareIsWhite(coordinate2)",
      "title": "3274. Check if Two Chessboard Squares Have the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "765207e5-5b4c-4431-a34d-b74e968e2c20",
      "code": "class Solution:\n  def resultsArray(self, queries: list[list[int]], k: int) -> list[int]:\n    ans = []\n    maxHeap = []\n\n    for x, y in queries:\n      heapq.heappush(maxHeap, -(abs(x) + abs(y)))\n      if len(maxHeap) > k:\n        heapq.heappop(maxHeap)\n      ans.append(-maxHeap[0] if len(maxHeap) == k else -1)\n\n    return ans",
      "title": "3275. K-th Nearest Obstacle Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2503d34f-7abf-4f2d-b7e8-883b854234cd",
      "code": "class Solution:\n  def maxScore(self, grid: list[list[int]]) -> int:\n    numToIndices = collections.defaultdict(set)\n    for index, row in enumerate(grid):\n      for num in row:\n        numToIndices[num].add(index)\n    numToIndices = list(numToIndices.items())\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score by selecting numbers from numToIndices[i..],\n      where `mask` is the bitmask of the used row indices.\n      \"\"\"\n      if i == len(numToIndices):\n        return 0\n      # Skip numToIndices[i][0].\n      res = dp(i + 1, mask)\n      for index in numToIndices[i][1]:\n        if (mask >> index & 1) == 0:\n          # Take numToIndices[i][0].\n          res = max(res, numToIndices[i][0] + dp(i + 1, mask | 1 << index))\n      return res\n\n    return dp(0, 0)",
      "title": "3276. Select Cells in Grid With Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c76c117d-6c42-404e-aab4-e21506583403",
      "code": "class Solution:\n  def maximumSubarrayXor(\n      self,\n      nums: list[int],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(nums)\n    # xors[i][j] := the XOR score of nums[i..j]\n    xors = [[0] * n for _ in range(n)]\n    # dp[i][j] := the maximum XOR score of nums[i..j]\n    dp = [[0] * n for _ in range(n)]\n\n    for i, num in enumerate(nums):\n      xors[i][i] = num\n      dp[i][i] = num\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        xors[i][j] = xors[i][j - 1] ^ xors[i + 1][j]\n        dp[i][j] = max(xors[i][j], dp[i][j - 1], dp[i + 1][j])\n\n    return [dp[l][r] for l, r in queries]",
      "title": "3277. Maximum XOR Score Subarray Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "615c8dd4-2d42-4d22-afea-926d419da2bc",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxArea(self, height: int, positions: list[int], directions: str) -> int:\n    area = sum(positions)\n    ans = area\n    diffPerSecond = 0\n    timeToIndices: SortedDict[int, list[int]] = SortedDict()\n\n    for i, (position, direction) in enumerate(zip(positions, directions)):\n      if direction == 'U':\n        timeToIndices.setdefault(height - position, []).append(i)\n        timeToIndices.setdefault(height - position + height, []).append(i)\n        diffPerSecond += 1\n      else:\n        timeToIndices.setdefault(position, []).append(i)\n        timeToIndices.setdefault(position + height, []).append(i)\n        diffPerSecond -= 1\n\n    prevTime = 0\n    directionsList = list(directions)\n\n    for time, indices in timeToIndices.items():\n      area += (time - prevTime) * diffPerSecond\n      ans = max(ans, area)\n      prevTime = time\n      for i in indices:\n        if directionsList[i] == 'U':\n          directionsList[i] = 'D'\n          diffPerSecond -= 2\n        else:\n          directionsList[i] = 'U'\n          diffPerSecond += 2\n\n    return ans",
      "title": "3279. Maximum Total Area Occupied by Pistons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "801db995-d8e9-4815-ae4c-c5586ac10c2d",
      "code": "class Solution:\n  def convertDateToBinary(self, date: str) -> str:\n    year, month, day = map(int, date.split('-'))\n\n    def toBinary(value: int) -> str:\n      \"\"\"Converts an integer to binary without leading zeros.\"\"\"\n      return bin(value)[2:]\n\n    return '-'.join([toBinary(year), toBinary(month), toBinary(day)])",
      "title": "3280. Convert Date to Binary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63b58312-5920-4ce4-869b-3020cd25db3b",
      "code": "class Solution:\n  def maxPossibleScore(self, start: list[int], d: int) -> int:\n    def isPossible(m: int) -> bool:\n      lastPick = start[0]\n      for i in range(1, len(start)):\n        if lastPick + m > start[i] + d:\n          return False\n        lastPick = max(lastPick + m, start[i])\n      return True\n\n    start.sort()\n\n    maxScore = (start[-1] + d) - start[0] + 1\n    l = bisect.bisect_left(range(maxScore), True,\n                           key=lambda m: not isPossible(m))\n    return l - 1",
      "title": "3281. Maximize Score of Numbers in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bb7254e-d60b-40dd-847f-d840cbf568f0",
      "code": "class Solution:\n  # Similar to 3205. Maximum Array Hopping Score I\n  def findMaximumScore(self, nums: list[int]) -> int:\n    return sum(itertools.accumulate(nums[:-1], max))",
      "title": "3282. Reach End of Array With Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3e87ab5-83e6-4167-82a2-63bb8c9df31c",
      "code": "class Solution:\n  def __init__(self):\n    self.SIZE = 50\n    self.MAX = 1_000_000\n    self.DIRS = ((1, 2), (2, 1), (2, -1), (1, -2),\n                 (-1, -2), (-2, -1), (-2, 1), (-1, 2))\n\n  def maxMoves(self, kx: int, ky: int, positions: list[list[int]]) -> int:\n    n = len(positions)\n    positions.append([kx, ky])\n    hashedPositionToIndex = {}\n    # dist[i][j] := the minimum distance from positions[i] to positions[j]\n    dist = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i, (x, y) in enumerate(positions):\n      hashedPositionToIndex[self._hash(x, y)] = i\n\n    for sourceIndex in range(n + 1):\n      self._bfs(positions, sourceIndex, hashedPositionToIndex, dist)\n\n    MAX_MASK = 1 << (n + 1)\n    # dp[i][mask][turn] := the maximum (Alice) or the minimum (Bob) cost to\n    # kill all pawns, where i is the current pawn, mask is the set of pawns\n    # that have been killed, and turn is the current player's turn (0 for Alice\n    # and 1 for Bob)\n    dp = [[[0, 0]\n          for _ in range(1 << (n + 1))]\n          for _ in range(n + 1)]\n\n    for i in range(n + 1):\n      for mask in range(MAX_MASK - 1):\n        dp[i][mask] = [-self.MAX, self.MAX]\n\n    for mask in range(MAX_MASK - 2, -1, -1):\n      for i in range(n + 1):\n        for turn in range(2):\n          for j in range(n):\n            if mask >> j & 1:\n              continue\n            moves = dist[i][j] + dp[j][mask | 1 << j][1 - turn]\n            dp[i][mask][turn] = (max(dp[i][mask][turn], moves) if turn == 0 else\n                                 min(dp[i][mask][turn], moves))\n\n    # Returns the maximum cost to kill all pawns, i.e., the original positions\n    # array without the knight (kx, ky).\n    return dp[n][1 << n][0]\n\n  def _hash(self, x: int, y: int) -> int:\n    return x * self.SIZE + y\n\n  def _bfs(\n      self,\n      positions: list[list[int]],\n      sourceIndex: int,\n      hashedPositionToIndex: dict[int, int],\n      dist: list[list[int]]\n  ) -> None:\n    \"\"\"\n    Computes the distance between positions[sourceIndex] and other positions.\n    \"\"\"\n    sx, sy = positions[sourceIndex]\n    q = collections.deque([(sx, sy)])\n    seen = {(sx, sy)}\n    seenPositions = 0\n\n    step = 0\n    while q and seenPositions < len(positions):\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        hashedPosition = self._hash(i, j)\n        if hashedPosition in hashedPositionToIndex:\n          dist[sourceIndex][hashedPositionToIndex[hashedPosition]] = step\n          seenPositions += 1\n        for dx, dy in self.DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x >= self.SIZE or y < 0 or y >= self.SIZE:\n            continue\n          if (x, y) in seen:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1",
      "title": "3283. Maximum Number of Moves to Kill All Pawns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8415526b-deb7-44ed-ad15-f49cafb5f4a1",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    def getSum(diff: int) -> int:\n      \"\"\"Returns the sum of all subarrays with a difference of `diff`.\"\"\"\n      res = nums[0]\n      summ = nums[0]\n      count = 1\n      for prev, num in itertools.pairwise(nums):\n        if num == prev + diff:\n          count += 1\n          summ += count * num\n        else:\n          count = 1\n          summ = num\n        res += summ\n      return res\n\n    return (getSum(1) + getSum(-1) - sum(nums)) % 1_000_000_007",
      "title": "3284. Sum of Consecutive Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b83699a8-8d81-4019-8c5c-9d6ab346a8ff",
      "code": "class Solution:\n  def stableMountains(self, height: list[int], threshold: int) -> list[int]:\n    return [i for i in range(1, len(height))\n            if height[i - 1] > threshold]",
      "title": "3285. Find Indices of Stable Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98366192-54bb-489c-a6fe-6a8616c78db4",
      "code": "class Solution:\n  def findSafeWalk(self, grid: list[list[int]], health: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    initialHealth = health - grid[0][0]\n    q = collections.deque([(0, 0, initialHealth)])\n    seen = {(0, 0, initialHealth)}\n\n    while q:\n      for _ in range(len(q)):\n        i, j, h = q.popleft()\n        if i == m - 1 and j == n - 1 and h > 0:\n          return True\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          nextHealth = h - grid[x][y]\n          if nextHealth <= 0 or (x, y, nextHealth) in seen:\n            continue\n          q.append((x, y, nextHealth))\n          seen.add((x, y, nextHealth))\n\n    return False",
      "title": "3286. Find a Safe Walk Through a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cd6fc4d-3834-471f-bed2-dfe17135d323",
      "code": "class Solution:\n  def maxValue(self, nums: list[int], k: int) -> int:\n    left = self._getPossibleORs(nums, k)\n    right = self._getPossibleORs(nums[::-1], k)[::-1]\n    return max(a ^ b\n               for i in range(k - 1, len(nums) - k)\n               for a in range(128 + 1)\n               for b in range(128 + 1)\n               if left[i][k][a] and right[i + 1][k][b])\n\n  def _getPossibleORs(self, nums: list[int], k: int) -> list[list[list[bool]]]:\n    dp = [[[False] * (128 + 1)\n          for _ in range(k + 1)]\n          for _ in range(len(nums))]\n\n    dp[0][1][nums[0]] = True\n\n    for i in range(len(nums)):\n      dp[i][0][0] = True\n\n    for i in range(1, len(nums)):\n      for j in range(1, k + 1):\n        for x in range(128 + 1):\n          if dp[i - 1][j][x]:\n            dp[i][j][x] = True\n          if dp[i - 1][j - 1][x]:\n            dp[i][j][nums[i] | x] = True\n\n    return dp",
      "title": "3287. Find the Maximum Sequence Value of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cfd58a4-9c73-404a-b83f-d49956e383ba",
      "code": "class Solution:\n  def maxPathLength(self, coordinates: list[list[int]], k: int) -> int:\n    xk, yk = coordinates[k]\n    leftCoordinates = [(x, y) for x, y in coordinates if x < xk and y < yk]\n    rightCoordinates = [(x, y) for x, y in coordinates if x > xk and y > yk]\n    return (1 +\n            self._lengthOfLIS(leftCoordinates) +\n            self._lengthOfLIS(rightCoordinates))\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, coordinates: list[tuple[int, int]]) -> int:\n    coordinates.sort(key=lambda x: (x[0], -x[1]))\n    # tail[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tail = []\n    for _, y in coordinates:\n      if not tail or y > tail[-1]:\n        tail.append(y)\n      else:\n        tail[bisect.bisect_left(tail, y)] = y\n    return len(tail)",
      "title": "3288. Length of the Longest Increasing Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5b26de00-e9b7-40ad-a20c-e58e6daec53f",
      "code": "class Solution:\n  def getSneakyNumbers(self, nums: list[int]) -> list[int]:\n    return [num for num, freq in collections.Counter(nums).items()\n            if freq == 2]",
      "title": "3289. The Two Sneaky Numbers of Digitville",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b86482e5-854e-4f62-9363-5a33d4f958cb",
      "code": "class Solution:\n  def maxScore(self, a: list[int], b: list[int]) -> int:\n    n = len(b)\n    # dp[i][j] := the maximum score by selecting 4 - i numbers from b[j..n - 1]\n    # using the corresponding numbers from a[i..3]\n    dp = [[0] * (n + 1) for _ in range(5)]\n\n    # Run out of numbers in b but still need to select numbers from a.\n    for i in range(4):\n      dp[i][n] = -math.inf\n\n    for i in reversed(range(4)):\n      for j in reversed(range(n)):\n        # Skip b[j] or pair a[i] with b[j].\n        dp[i][j] = max(dp[i][j + 1], a[i] * b[j] + dp[i + 1][j + 1])\n\n    return -1 if dp[0][0] == -math.inf else dp[0][0]",
      "title": "3290. Maximum Multiplication Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1833c63b-fcd3-4034-a046-9b396f69626f",
      "code": "class Solution:\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3291. Minimum Number of Valid Strings to Form Target I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d99d63a4-38e5-4070-9dd9-5bfab2d84771",
      "code": "class Solution:\n  # 3291. Minimum Number of Valid Strings to Form Target I\n  def minValidStrings(self, words: list[str], target: str) -> int:\n    ans = 0\n    unmatchedPrefix = len(target)\n    lpsList = [self._getLPS(word + '#' + target) for word in words]\n\n    while unmatchedPrefix > 0:\n      # Greedily choose the word that has the longest suffix match with the\n      # remaining unmatched prefix.\n      maxMatchSuffix = 0\n      for lps, word in zip(lpsList, words):\n        maxMatchSuffix = max(maxMatchSuffix, lps[len(word) + unmatchedPrefix])\n      if maxMatchSuffix == 0:\n        return -1\n      ans += 1\n      unmatchedPrefix -= maxMatchSuffix\n\n    return ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3292. Minimum Number of Valid Strings to Form Target II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c03ec3c-5ec5-4c78-b509-4e520b9bc151",
      "code": "class Solution:\n  def toArray(self, node: 'Optional[Node]') -> list[int]:\n    ans = []\n    curr = node\n\n    while curr.prev:\n      curr = curr.prev\n\n    while curr:\n      ans.append(curr.val)\n      curr = curr.next\n\n    return ans",
      "title": "3294. Convert Doubly Linked List to Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bb02a7fd-854f-4d25-8a3c-d8ffe8fa2b5e",
      "code": "class Solution:\n  def reportSpam(self, message: list[str], bannedWords: list[str]) -> bool:\n    bannedWordsSet = set(bannedWords)\n    return sum(word in bannedWordsSet for word in message) > 1",
      "title": "3295. Report Spam Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f401b727-e9db-445d-adcc-ae8eb79f773d",
      "code": "class Solution:\n  def minNumberOfSeconds(\n      self,\n      mountainHeight: int,\n      workerTimes: list[int]\n  ) -> int:\n    def getReducedHeight(m: int) -> int:\n      \"\"\"Returns the total height reduced by all workers in `m` seconds.\"\"\"\n      # The height `x` that a worker with working time `w` reduces in `m`\n      # seconds.\n      # w * (1 + 2 + ... + x) <= m\n      #       (1 + x) * x / 2 <= m / w\n      #   x^2 + x - 2 * m / w <= 0\n      #                     x <= (-1 + sqrt(1 + 8 * m / w)) / 2\n      return sum((-1 + math.sqrt(1 + 8 * m // workerTime)) // 2\n                 for workerTime in workerTimes)\n\n    l = 1\n    r = min(workerTimes) * mountainHeight * (mountainHeight + 1) // 2\n    return bisect.bisect_left(range(l, r), mountainHeight,\n                              key=getReducedHeight) + l",
      "title": "3296. Minimum Number of Seconds to Make Mountain Height Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c8d1cbd-056a-4659-89bd-d726eb1632c4",
      "code": "class Solution:\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3297. Count Substrings That Can Be Rearranged to Contain a String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0732a237-7885-419c-b9d5-7f5968710623",
      "code": "class Solution:\n  # Same as 3297. Count Substrings That Can Be Rearranged to Contain a String I\n  def validSubstringCount(self, word1: str, word2: str) -> int:\n    ans = 0\n    count = collections.Counter(word2)\n    required = len(word2)\n\n    l = 0\n    for r, c in enumerate(word1):\n      count[c] -= 1\n      if count[c] >= 0:\n        required -= 1\n      while required == 0:\n        # Add valid substrings containing word1[l..r] to the answer. They are\n        # word1[l..r], word1[l..r + 1], ..., word1[l..n - 1].\n        ans += len(word1) - r\n        count[word1[l]] += 1\n        if count[word1[l]] > 0:\n          required += 1\n        l += 1\n\n    return ans",
      "title": "3298. Count Substrings That Can Be Rearranged to Contain a String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f97f13cd-9417-41e4-928b-d9aef2c4b71b",
      "code": "class Solution:\n  def getSum(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getSequenceSum(nums: list[int], direction: int) -> int:\n      \"\"\"\n      Returns the sum of all sequences in the array that are in consecutive\n      increasing order if `direction` is 1, or in consecutive decreasing order\n      if `direction` is -1.\"\"\"\n      sequenceSum = 0\n      # {num: the number of subsequences ending in `num` so far}\n      prefixCount = collections.Counter()\n      # {num: the number of subsequences starting from `num` so far}\n      suffixCount = collections.Counter()\n      # prefixSubseqs[i] := the number of subsequences ending in nums[i]\n      prefixSubseqs = [0] * n\n      # suffixSubseqs[i] := the number of subsequences starting from nums[i]\n      suffixSubseqs = [0] * n\n\n      for i, num in enumerate(nums):\n        prevNum = num - direction\n        freq = prefixCount[prevNum] + 1\n        prefixSubseqs[i] = freq\n        prefixCount[num] += freq\n        prefixCount[num] %= MOD\n\n      for i, num in reversed(list(enumerate(nums))):\n        nextNum = num + direction\n        freq = suffixCount[nextNum] + 1\n        suffixSubseqs[i] = freq\n        suffixCount[num] += freq\n        suffixCount[num] %= MOD\n\n      for num, prefixSubseq, suffixSubseq in zip(\n              nums, prefixSubseqs, suffixSubseqs):\n        sequenceSum += num * prefixSubseq * suffixSubseq\n        sequenceSum %= MOD\n\n      return sequenceSum\n\n    increasingSequenceSum = getSequenceSum(nums, 1)\n    decreasingSequenceSum = getSequenceSum(nums, -1)\n    return (increasingSequenceSum + decreasingSequenceSum - sum(nums) + MOD) % MOD",
      "title": "3299. Sum of Consecutive Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3b9f8b6-0848-480d-b80c-cee4e6458b00",
      "code": "class Solution:\n  def minElement(self, nums: list[int]) -> int:\n    return min(sum(map(int, str(num))) for num in nums)",
      "title": "3300. Minimum Element After Replacement With Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5b82320-c2af-468f-b9fb-8e9ab453140c",
      "code": "class Solution:\n  def maximumTotalSum(self, maximumHeight: list[int]) -> int:\n    ans = 0\n    mn = math.inf\n\n    for height in sorted(maximumHeight, reverse=True):\n      assigned = min(height, mn - 1)\n      if assigned == 0:\n        return -1\n      ans += assigned\n      mn = assigned\n\n    return ans",
      "title": "3301. Maximize the Total Height of Unique Towers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "854c0f9d-a493-4443-bf18-f1dd817d285e",
      "code": "class Solution:\n  def validSequence(self, word1: str, word2: str) -> list[int]:\n    ans = []\n    # last[j] := the index i of the last occurrence in word1, where\n    # word1[i] == word2[j]\n    last = [-1] * len(word2)\n\n    i = len(word1) - 1\n    j = len(word2) - 1\n    while i >= 0 and j >= 0:\n      if word1[i] == word2[j]:\n        last[j] = i\n        j -= 1\n      i -= 1\n\n    canSkip = True\n    j = 0\n    for i, c in enumerate(word1):\n      if j == len(word2):\n        break\n      if c == word2[j]:\n        ans.append(i)\n        j += 1\n      elif canSkip and (j == len(word2) - 1 or i < last[j + 1]):\n        canSkip = False\n        ans.append(i)\n        j += 1\n\n    return ans if j == len(word2) else []",
      "title": "3302. Find the Lexicographically Smallest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "300211e9-1b5b-4e3f-85cd-cbd3342a5e5f",
      "code": "class Solution:\n  def minStartingIndex(self, s: str, pattern: str) -> int:\n    z1 = self._zFunction(pattern + s)\n    z2 = self._zFunction(pattern[::-1] + s[::-1])\n\n    # Match s[i..i + len(pattern) - 1] with `pattern` from both the prefix and\n    # the suffix.\n    for i in range(len(s) - len(pattern) + 1):\n      if z1[len(pattern) + i] + z2[len(s) - i] >= len(pattern) - 1:\n        return i\n\n    return -1\n\n  def _zFunction(self, s: str) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    s[i..n) which is also a prefix of s.\n\n    https://cp-algorithms.com/string/z-function.html#implementation\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    l = 0\n    r = 0\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3303. Find the Occurrence of First Almost Equal Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e91463a7-d9a7-4708-93ac-6e587ac2a5b9",
      "code": "class Solution:\n  def kthCharacter(self, k: int) -> str:\n    return string.ascii_lowercase[(k - 1).bit_count()]",
      "title": "3304. Find the K-th Character in String Game I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1d1b9b1-d9ee-4ff9-a4c5-0fd5c7e7b24d",
      "code": "class Solution:\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k == -1:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3305. Count of Substrings Containing Every Vowel and K Consonants I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f657c1b-6492-4ec8-a483-eddf8c002edf",
      "code": "class Solution:\n  # Same as 3305. Count of Substrings Containing Every Vowel and K Consonants I\n  def countOfSubstrings(self, word: str, k: int) -> int:\n    VOWELS = 'aeiou'\n\n    def substringsWithAtMost(k: int) -> int:\n      \"\"\"\n      Return the number of substrings containing every vowel with at most k\n      consonants.\n      \"\"\"\n      if k < 0:\n        return 0\n\n      res = 0\n      vowels = 0\n      uniqueVowels = 0\n      vowelLastSeen = {}\n\n      l = 0\n      for r, c in enumerate(word):\n        if c in VOWELS:\n          vowels += 1\n          if c not in vowelLastSeen or vowelLastSeen[c] < l:\n            uniqueVowels += 1\n          vowelLastSeen[c] = r\n        while r - l + 1 - vowels > k:\n          if word[l] in VOWELS:\n            vowels -= 1\n            if vowelLastSeen[word[l]] == l:\n              uniqueVowels -= 1\n          l += 1\n        if uniqueVowels == 5:\n          # Add substrings containing every vowel with at most k consonants to\n          # the answer. They are\n          # word[l..r], word[l + 1..r], ..., word[min(vowelLastSeen[vowel])..r]\n          res += min(vowelLastSeen[vowel] for vowel in VOWELS) - l + 1\n\n      return res\n\n    return substringsWithAtMost(k) - substringsWithAtMost(k - 1)",
      "title": "3306. Count of Substrings Containing Every Vowel and K Consonants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "235bf33b-695b-40d0-8e23-b140a9e5b198",
      "code": "class Solution:\n  def kthCharacter(self, k: int, operations: list[int]) -> str:\n    operationsCount = math.ceil(math.log2(k))\n    increases = 0\n\n    for i in range(operationsCount - 1, -1, -1):\n      halfSize = 2**i\n      if k > halfSize:\n        k -= halfSize  # Move k from the right half to the left half.\n        increases += operations[i]\n\n    return string.ascii_lowercase[increases % 26]",
      "title": "3307. Find the K-th Character in String Game II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d37bde5f-d812-4425-a9e0-b064b6f3366b",
      "code": "class Solution:\n  def maxGoodNumber(self, nums: list[int]) -> int:\n    ans = 0\n\n    def concat(a: int, b: int) -> int:\n      \"\"\"Returns the concatenation of the binary representations of a and b.\"\"\"\n      return (a << b.bit_length()) + b\n\n    nums.sort(key=functools.cmp_to_key(\n        lambda a, b: concat(b, a) - concat(a, b)))\n\n    for num in nums:\n      ans = concat(ans, num)\n\n    return ans",
      "title": "3309. Maximum Possible Number by Binary Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e86caec8-138c-4c9f-9b8f-2f2bd81b6944",
      "code": "class Solution:\n  def remainingMethods(\n      self,\n      n: int,\n      k: int,\n      invocations: list[list[int]]\n  ) -> list[int]:\n    ans = []\n    graph = [[] for _ in range(n)]\n\n    for u, v in invocations:\n      graph[u].append(v)\n\n    q = collections.deque([k])\n    seen = {k}\n\n    while q:\n      for _ in range(len(q)):\n        for v in graph[q.popleft()]:\n          if v not in seen:\n            q.append(v)\n            seen.add(v)\n\n    for u in range(n):\n      if u in seen:\n        continue\n      for v in graph[u]:\n        if v in seen:\n          return list(range(n))\n      ans.append(u)\n\n    return ans",
      "title": "3310. Remove Methods From Project",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38900cac-4161-4e99-99d6-afcadd6d3d29",
      "code": "class Solution:\n  def constructGridLayout(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    # Randomly choose a node with the minimum degree as the corner.\n    corner = min(range(len(graph)), key=lambda x: len(graph[x]))\n\n    seen = {corner}\n    firstRow = self._getFirstRow(graph, corner, seen)\n    cols = len(firstRow)\n    rows = n // cols\n\n    ans = [[0] * cols for _ in range(rows)]\n    ans[0] = firstRow\n\n    for i in range(1, rows):\n      for j in range(cols):\n        for v in graph[ans[i - 1][j]]:\n          if v not in seen:\n            ans[i][j] = v\n            seen.add(v)\n            break\n\n    return ans\n\n  def _getFirstRow(\n      self,\n      graph: list[list[int]],\n      corner: int,\n      seen: set[int]\n  ) -> list[int]:\n    cornerDegree = len(graph[corner])\n    row = [corner]\n    # Continue appending neighbors until we hit another corner.\n    while len(row) == 1 or len(graph[row[-1]]) == cornerDegree + 1:\n      # Sort neighbors by degree to prioritize smaller ones (shortest row built first).\n      graph[row[-1]].sort(key=lambda x: len(graph[x]))\n      for v in graph[row[-1]]:\n        if v not in seen and len(graph[v]) in (cornerDegree, cornerDegree + 1):\n          row.append(v)\n          seen.add(v)\n          break\n    return row",
      "title": "3311. Construct 2D Grid Matching Graph Layout",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c6a1b4f-9801-444b-9b24-59a9b598fec6",
      "code": "class Solution:\n  def gcdValues(self, nums: list[int], queries: list[int]) -> list[int]:\n    maxNum = max(nums)\n    # countDivisor[d] := the number of `nums` having `num % d == 0`\n    countDivisor = [0] * (maxNum + 1)\n    # countGcdPair[g] := the number of pairs having gcd == g\n    countGcdPair = [0] * (maxNum + 1)\n\n    for num in nums:\n      for i in range(1, math.isqrt(num) + 1):\n        if num % i == 0:\n          countDivisor[i] += 1\n          if i != num // i:\n            countDivisor[num // i] += 1\n\n    for gcd in range(maxNum, 0, -1):\n      # There are C(countDivisor[gcd], 2) pairs that have a common divisor\n      # that's a multiple of `gcd` (including the one that equals to `gcd`).\n      # So, substract the multiples of `gcd` to have the number of pairs with a\n      # gcd that's exactly `gcd`.\n      countGcdPair[gcd] = countDivisor[gcd] * (countDivisor[gcd] - 1) // 2\n      for largerGcd in range(2 * gcd, maxNum + 1, gcd):\n        countGcdPair[gcd] -= countGcdPair[largerGcd]\n\n    # prefixCountGcdPair[g] := the number of pairs having gcd <= g\n    prefixCountGcdPair = list(itertools.accumulate(countGcdPair))\n    return [bisect.bisect_left(prefixCountGcdPair, query + 1)\n            for query in queries]",
      "title": "3312. Sorted GCD Pair Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f304e12d-1b3b-43a5-8521-0da3541ac421",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Node:\n  node: int = 0  # the node number\n  time: int = 0  # the time it got marked\n\n\nclass Last2:\n  def __init__(self, last1: Node = Node(), last2: Node = Node()):\n    self.last1 = last1  # the last marked node\n    self.last2 = last2  # the second last marked node\n\n\nclass Solution:\n  # Similar to 3241. Time Taken to Mark All Nodes\n  def lastMarkedNodes(self, edges: list[list[int]]) -> list[int]:\n    n = len(edges) + 1\n    ans = [0] * n\n    tree = [[] for _ in range(n)]\n    # dp[i] := the last marked two nodes for subtree rooted at node i, where\n    # each node contains the time it got marked\n    dp = [Last2()] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    self._dfs(tree, 0, -1, dp)\n    self._reroot(tree, 0, -1, Node(), dp, ans)\n    return ans\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      dp: list[Last2]\n  ) -> Node:\n    \"\"\"\n    Performs a DFS traversal of the subtree rooted at node `u`, computes the\n    time taken to mark all nodes in the subtree, records the last two marked\n    nodes, and returns the last marked node.\n\n    These values are used later in the rerooting process.\n    \"\"\"\n    last1 = Node(u, 0)\n    last2 = Node()\n    for v in tree[u]:\n      if v == prev:\n        continue\n      child = self._dfs(tree, v, u, dp)\n      time = child.time + 1\n      if time > last1.time:\n        last2 = last1\n        last1 = Node(child.node, time)\n      elif time > last2.time:\n        last2 = Node(child.node, time)\n    dp[u] = Last2(last1, last2)\n    return last1\n\n  def _reroot(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      last: Node,\n      dp: list[list[int]],\n      ans: list[int]\n  ) -> None:\n    \"\"\"\n    Reroots the tree at node `u` and updates the answer array, where `last`\n    is the last marked node that doesn't go through `u`'s subtree.\n    \"\"\"\n    ans[u] = last.node if last.time > dp[u].last1.time else dp[u].last1.node\n    for v in tree[u]:\n      if v == prev:\n        continue\n      newLast = Node(last.node, last.time + 1)\n      if dp[u].last1.node == dp[v].last1.node:\n        alternativeTime = 1 + dp[u].last2.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last2.node, alternativeTime)\n      else:\n        alternativeTime = 1 + dp[u].last1.time\n        if alternativeTime > newLast.time:\n          newLast = Node(dp[u].last1.node, alternativeTime)\n      self._reroot(tree, v, u, newLast, dp, ans)",
      "title": "3313. Find the Last Marked Nodes in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cb3f655-81e5-44be-8743-8d3cf643b933",
      "code": "class Solution:\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3314. Construct the Minimum Bitwise Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8af8cb6-c6fe-4458-9a93-20522a48805c",
      "code": "class Solution:\n  # Same as 3314. Construct the Minimum Bitwise Array I\n  def minBitwiseArray(self, nums: list[int]) -> list[int]:\n    return [-1 if num == 2 else num - self._getLeadingOneOfLastGroupOfOnes(num)\n            for num in nums]\n\n  def _getLeadingOneOfLastGroupOfOnes(self, num: int) -> int:\n    \"\"\"\n    Returns the leading one of the last group of 1s in the binary\n    representation of num. For example, if num = 0b10111, the leading one of\n    the last group of 1s is 0b100.\n    \"\"\"\n    leadingOne = 1\n    while (num & leadingOne) > 0:\n      leadingOne <<= 1\n    return leadingOne >> 1",
      "title": "3315. Construct the Minimum Bitwise Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "152c180f-0454-4e5d-bc7f-e1af55e480d8",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3a94004-7a53-442c-8a38-f3c5df1bf00a",
      "code": "class Solution:\n  def maxRemovals(\n      self,\n      source: str,\n      pattern: str,\n      targetIndices: list[int]\n  ) -> int:\n    m = len(source)\n    n = len(pattern)\n    target = set(targetIndices)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"\n      Returns the maximum number of operations that can be performed for\n      source[i..m) and pattern[j..n).\n      \"\"\"\n      if i == m:\n        return 0 if j == n else -math.inf\n      if j == n:\n        return int(i in target) + dp(i + 1, j)\n      pick = dp(i + 1, j + 1) if source[i] == pattern[j] else -math.inf\n      skip = int(i in target) + dp(i + 1, j)\n      return max(pick, skip)\n\n    ans = dp(0, 0)\n    return 0 if ans == -math.inf else ans",
      "title": "3316. Find Maximum Removals From Source String_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "033e9c5f-0d80-4a84-9196-9b2598ceec9f",
      "code": "class Solution:\n  def numberOfWays(self, n: int, x: int, y: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    @functools.lru_cache(None)\n    def stirling(n: int, k: int) -> int:\n      \"\"\"\n      Returns the number of ways to partition a set of n objects into k\n      non-empty subsets.\n\n      https://en.wikipedia.org/wiki/Stirling_numbers_of_the_second_kind\n      \"\"\"\n      if k == 0 or n < k:\n        return 0\n      if k == 1 or n == k:\n        return 1\n      return (k * stirling(n - 1, k) + stirling(n - 1, k - 1)) % MOD\n\n    # 1. Choose `k` stages from `x` stages.\n    # 2. Partition `n` performers into `k` stages.\n    # 3. Permute `k` stages.\n    # 4. Score `k` stages with score in the range [1, y], so y^k ways.\n    return sum(nCk(x, k) * stirling(n, k) * fact(k) * pow(y, k, MOD) % MOD\n               for k in range(1, min(n, x) + 1)) % MOD",
      "title": "3317. Find the Number of Possible Ways for an Event",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fac5b1d5-5ef1-4447-bb3d-a46f15f250a1",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()\n    bot = SortedList()\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up old values.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom element to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        windowSum -= t * countT\n        top.add([countB, b])\n        windowSum += b * countB\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3318. Find X-Sum of All K-Long Subarrays I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "251abfee-733b-43e9-830d-b095a0932418",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  isPerfect: bool\n  sz: int\n\n\nclass Solution:\n  def kthLargestPerfectSubtree(self, root: TreeNode | None, k: int) -> int:\n    ans = []\n    self._dfs(root, ans)\n    if len(ans) < k:\n      return -1\n    return sorted(ans, reverse=True)[k - 1]\n\n  def _dfs(self, root: TreeNode, ans: list[int]) -> T:\n    if not root:\n      return T(True, 0)\n    l = self._dfs(root.left, ans)\n    r = self._dfs(root.right, ans)\n    if l.isPerfect and r.isPerfect and l.sz == r.sz:\n      sz = 1 + l.sz + r.sz\n      ans.append(sz)\n      return T(True, sz)\n    return T(False, 0)",
      "title": "3319. K-th Largest Perfect Subtree Size in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cfdea69-27b6-473e-8020-2c0726334a3e",
      "code": "class Solution:\n  def countWinningSequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int, bob: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences Bob can use to beat Alice for\n      s[i..n), where the previous character is `prev` (0: F, 1: W, 2: E) and the\n      number of points that Bob is having is `bob`.\n      \"\"\"\n      if i == len(s):\n        return int(bob > 0)\n\n      f = 0  # If Bob summons a Fire Dragon at i.\n      w = 0  # If Bob summons a Water Serpent at i.\n      e = 0  # If Bob summons a Earth Golem at i.\n\n      match s[i]:\n        case 'F':\n          if prev != 0:\n            f = dp(i + 1, 0, bob) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob + 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob - 1) % MOD\n        case 'W':\n          if prev != 0:\n            f = dp(i + 1, 0, bob - 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob + 1) % MOD\n        case 'E':\n          if prev != 0:\n            f = dp(i + 1, 0, bob + 1) % MOD\n          if prev != 1:\n            w = dp(i + 1, 1, bob - 1) % MOD\n          if prev != 2:\n            e = dp(i + 1, 2, bob) % MOD\n\n      return f + w + e\n\n    return (dp(0, 0, 0) + dp(0, 1, 0) + dp(0, 2, 0)) // 2 % MOD",
      "title": "3320. Count The Number of Winning Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c6137e0-b8d9-4891-87d1-0bcec26a7ce4",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  # Same as 3318. Find X-Sum of All K-Long Subarrays I\n  def findXSum(self, nums: list[int], k: int, x: int) -> list[int]:\n    ans = []\n    windowSum = 0\n    count = collections.Counter()\n    top = SortedList()  # the top x elements\n    bot = SortedList()  # the rest of the elements\n\n    def update(num: int, freq: int) -> None:\n      \"\"\"Updates the count of num by freq and the window sum accordingly.\"\"\"\n      nonlocal windowSum\n      if count[num] > 0:  # Clean up the old count.\n        if [count[num], num] in bot:\n          bot.remove([count[num], num])\n        else:\n          top.remove([count[num], num])\n          windowSum -= num * count[num]\n      count[num] += freq\n      if count[num] > 0:\n        bot.add([count[num], num])\n\n    for i, num in enumerate(nums):\n      update(num, 1)\n      if i >= k:\n        update(nums[i - k], -1)\n      # Move the bottom elements to the top if needed.\n      while bot and len(top) < x:\n        countB, b = bot.pop()\n        top.add([countB, b])\n        windowSum += b * countB\n      # Swap the bottom and top elements if needed.\n      while bot and bot[-1] > top[0]:\n        countB, b = bot.pop()\n        countT, t = top.pop(0)\n        bot.add([countT, t])\n        top.add([countB, b])\n        windowSum += b * countB\n        windowSum -= t * countT\n      if i >= k - 1:\n        ans.append(windowSum)\n\n    return ans",
      "title": "3321. Find X-Sum of All K-Long Subarrays II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "765241b4-6ae6-4ff9-8e20-2489d1bc965e",
      "code": "class Solution:\n  def minConnectedGroups(self, intervals: list[list[int]], k: int) -> int:\n    mergedIntervals = 0\n    maxMergedIntervals = 0\n\n    intervals = self._merge(intervals)\n\n    i = 0\n    for _, end in intervals:\n      while i < len(intervals) and end + k >= intervals[i][0]:\n        mergedIntervals += 1\n        i += 1\n      mergedIntervals -= 1  # Exclude intervals[i].\n      maxMergedIntervals = max(maxMergedIntervals, mergedIntervals)\n\n    return len(intervals) - maxMergedIntervals\n\n  # Same as 56. Merge Intervals\n  def _merge(self, intervals: list[list[int]]) -> list[list[int]]:\n    res = []\n    for interval in sorted(intervals):\n      if not res or res[-1][1] < interval[0]:\n        res.append(interval)\n      else:\n        res[-1][1] = max(res[-1][1], interval[1])\n    return res",
      "title": "3323. Minimize Connected Groups by Inserting Interval",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4dd5d85a-1ca8-40be-adbb-e462d7bdcef5",
      "code": "class Solution:\n  def stringSequence(self, target: str) -> list[str]:\n    ans = []\n    s = []\n\n    for targetChar in target:\n      s.append('a')\n      ans.append(''.join(s))\n      for offset in range(ord('b'), ord(targetChar) + 1):\n        s[-1] = chr(offset)\n        ans.append(''.join(s))\n\n    return ans",
      "title": "3324. Find the Sequence of Strings Appeared on the Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f878302b-2ad4-441a-a5cd-b301197029e0",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3325. Count Substrings With K-Frequency Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c86dc94d-f8a4-43dd-9025-e4ff19ffec6b",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > nums[i + 1]:\n        minDivisor = self._getMinDivisor(nums[i])\n        if minDivisor > nums[i + 1]:\n          return -1\n        nums[i] = minDivisor\n        ans += 1\n\n    return ans\n\n  def _getMinDivisor(self, num: int) -> int:\n    for divisor in range(2, math.isqrt(num) + 1):\n      if num % divisor == 0:\n        return divisor\n    return num",
      "title": "3326. Minimum Division Operations to Make Array Non Decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "174f49ad-301a-4570-a9dd-7fbde2211157",
      "code": "class Solution:\n  def findAnswer(self, parent: list[int], s: str) -> list[bool]:\n    n = len(parent)\n    tree = [[] for _ in parent]\n    start = [0] * n  # start[i] := the start index of `dfsStr` of node i\n    end = [0] * n  # end[i] := the end index of `dfsStr` of node i\n    dfsStr = []\n\n    for i in range(1, n):\n      tree[parent[i]].append(i)\n\n    self._dfs(tree, 0, 0, s, start, end, dfsStr)\n    t = '#'.join('@' + ''.join(dfsStr) + '$')\n    p = self._manacher(t)\n    return [self._isPalindrome(s, e, p)\n            for s, e in zip(start, end)]\n\n  def _dfs(\n      self,\n      tree: list[list[int]],\n      u: int,\n      index: int,\n      s: str,\n      start: list[int],\n      end: list[int],\n      dfsStr: list[str]\n  ) -> int:\n    \"\"\"Returns the start index of the \"DFS string\" of u's next node.\"\"\"\n    start[u] = index\n    for v in tree[u]:\n      index = self._dfs(tree, v, index, s, start, end, dfsStr)\n    end[u] = index\n    dfsStr.append(s[u])\n    return index + 1\n\n  def _manacher(self, t: str) -> list[int]:\n    \"\"\"\n    Returns an array `p` s.t. `p[i]` is the length of the longest palindrome\n    centered at `t[i]`, where `t` is a string with delimiters and sentinels.\n    \"\"\"\n    p = [0] * len(t)\n    center = 0\n    for i in range(1, len(t) - 1):\n      rightBoundary = center + p[center]\n      mirrorIndex = center - (i - center)\n      if rightBoundary > i:\n        p[i] = min(rightBoundary - i, p[mirrorIndex])\n      # Try to expand the palindrome centered at i.\n      while t[i + 1 + p[i]] == t[i - 1 - p[i]]:\n        p[i] += 1\n      # If a palindrome centered at i expands past `rightBoundary`, adjust\n      # the center based on the expanded palindrome.\n      if i + p[i] > rightBoundary:\n        center = i\n    return p\n\n  def _isPalindrome(self, s: int, e: int, p: list[int]) -> bool:\n    \"\"\"\n    Returns true if `dfsStr[s..e]` is a palindrome by using the precomputed\n    array `p` from the Manacher's algorithm.\n\n    The precomputed array `p` is based on the string `t` with delimiters and\n    sentinels. Let `t = '#'.join('@' + dfsStr + '$')`. Then, the center of\n    `dfsStr` maps to `t[s + e + 2]` since `dfsStr[s]` maps to `t[2 * s + 2]`\n    and `dfsStr[e]` maps to `t[2 * e + 2]`. So, the center of `dfsStr` is\n    `t[(2 * s + 2 + 2 * e + 2) / 2] = t[s + e + 2]`.\n    \"\"\"\n    length = e - s + 1\n    center = s + e + 2\n    return p[center] >= length",
      "title": "3327. Check if DFS Strings Are Palindromes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "310526b7-3bd9-4eb5-b1c9-c59c644f47fe",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n * (n + 1) // 2\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      while count[c] == k:\n        count[s[l]] -= 1\n        l += 1\n      ans -= r - l + 1\n\n    return ans",
      "title": "3329. Count Substrings With K-Frequency Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "912b8d6b-ed2a-41c6-8882-1fcef985c066",
      "code": "class Solution:\n  def possibleStringCount(self, word: str) -> int:\n    return 1 + sum(a == b\n                   for a, b in itertools.pairwise(word))",
      "title": "3330. Find the Original Typed String I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f085fad-9269-4f47-b635-de3f26d4a934",
      "code": "class Solution:\n  def findSubtreeSizes(self, parent: list[int], s: str) -> list[int]:\n    n = len(parent)\n    ans = [0] * n\n    newParent = parent.copy()\n    tree = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      closest = self._findClosestAncestor(i, parent, s)\n      if closest != -1:\n        newParent[i] = closest\n\n    for i in range(1, n):\n      tree[newParent[i]].append(i)\n\n    self._dfs(tree, 0, ans)\n    return ans\n\n  def _findClosestAncestor(self, u: int, parent: list[int], s: str) -> int:\n    \"\"\"\n    Returns the closest ancestor of node `u` that has the same value as `u`.\n    \"\"\"\n    curr = parent[u]\n    while curr != -1:\n      if s[curr] == s[u]:\n        return curr\n      curr = parent[curr]\n    return -1\n\n  def _dfs(self, tree: list[list[int]], u: int, ans: list[int]) -> int:\n    sz = 1\n    for v in tree[u]:\n      sz += self._dfs(tree, v, ans)\n    ans[u] = sz\n    return sz",
      "title": "3331. Find Subtree Sizes After Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7a762bc-7fdb-4e4c-8d79-8f69786de64a",
      "code": "class Solution:\n  def maxScore(\n      self,\n      n: int,\n      k: int,\n      stayScore: list[list[int]],\n      travelScore: list[list[int]]\n  ) -> int:\n    # dp[i][j] := the maximum score after i days being at city j\n    dp = [[0] * n for _ in range(k + 1)]\n\n    for i in range(1, k + 1):\n      for dest in range(n):\n        # 1. Stay at the current city.\n        dp[i][dest] = dp[i - 1][dest] + stayScore[i - 1][dest]\n        # 2. Travel from any other city.\n        for curr in range(n):\n          if curr != dest:\n            dp[i][dest] = max(dp[i][dest],\n                              dp[i - 1][curr] + travelScore[curr][dest])\n\n    return max(dp[k])",
      "title": "3332. Maximum Points Tourist Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ed2c293-9406-4629-ac81-e733846fcb1c",
      "code": "class Solution:\n  def possibleStringCount(self, word: str, k: int) -> int:\n    MOD = 1_000_000_007\n    groups = self._getConsecutiveLetters(word)\n    totalCombinations = functools.reduce(lambda subtotal, group:\n                                         subtotal * group % MOD, groups)\n    if k <= len(groups):\n      return totalCombinations\n\n    # dp[j] := the number of ways to form strings of length j using groups[0..i]\n    dp = [0] * k\n    dp[0] = 1  # Base case: empty string\n\n    for i, group in enumerate(groups):\n      newDp = [0] * k\n      windowSum = 0\n      for j in range(i, k):\n        newDp[j] = (newDp[j] + windowSum) % MOD\n        windowSum = (windowSum + dp[j]) % MOD\n        if j >= group:\n          windowSum = (windowSum - dp[j - group] + MOD) % MOD\n      dp = newDp\n\n    return (totalCombinations - sum(dp)) % MOD\n\n  def _getConsecutiveLetters(self, word: str) -> list[int]:\n    \"\"\"\n    Returns consecutive identical letters in the input string.\n    e.g. \"aabbbc\" -> [2, 3, 1].\n    \"\"\"\n    groups = []\n    group = 1\n    for i in range(1, len(word)):\n      if word[i] == word[i - 1]:\n        group += 1\n      else:\n        groups.append(group)\n        group = 1\n    groups.append(group)\n    return groups",
      "title": "3333. Find the Original Typed String II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4933dec2-2c8f-4982-9fff-7a3ad9c9e22a",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixGcd[i] := GCD of nums[0..i]\n    # prefixLcm[i] := LCM of nums[0..i]\n    prefixGcd, prefixLcm = self._getPrefix(nums)\n    # suffixGcd[i] := GCD of nums[i..n - 1]\n    # suffixLcm[i] := LCM of nums[i..n - 1]\n    suffixGcd, suffixLcm = self._getSuffix(nums)\n    ans = suffixGcd[0] * suffixLcm[0]\n\n    for i in range(n):\n      gcd1 = prefixGcd[i - 1] if i > 0 else 0\n      gcd2 = suffixGcd[i + 1] if i + 1 < n else 0\n      lcm1 = prefixLcm[i - 1] if i > 0 else 1\n      lcm2 = suffixLcm[i + 1] if i + 1 < n else 1\n      score = math.gcd(gcd1, gcd2) * math.lcm(lcm1, lcm2)\n      ans = max(ans, score)\n\n    return ans\n\n  def _getPrefix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the prefix GCD and LCM arrays.\"\"\"\n    prefixGcd = []\n    prefixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in nums:\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      prefixGcd.append(currGcd)\n      prefixLcm.append(currLcm)\n    return prefixGcd, prefixLcm\n\n  def _getSuffix(self, nums: list[int]) -> tuple[list[int], list[int]]:\n    \"\"\"Returns the suffix GCD and LCM arrays.\"\"\"\n    suffixGcd = []\n    suffixLcm = []\n    currGcd = 0\n    currLcm = 1\n    for num in reversed(nums):\n      currGcd = math.gcd(currGcd, num)\n      currLcm = math.lcm(currLcm, num)\n      suffixGcd.append(currGcd)\n      suffixLcm.append(currLcm)\n    return list(reversed(suffixGcd)), list(reversed(suffixLcm))",
      "title": "3334. Find the Maximum Factor Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03ebb004-9f91-4fa6-a61a-c9811c8ac00d",
      "code": "class Solution:\n  def lengthAfterTransformations(self, s: str, t: int) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix()\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    # 'z' -> 'ab'\n    T[25][0] = 1\n    T[25][1] = 1\n    # 'a' -> 'b', 'b' -> 'c', ..., 'y' -> 'z'\n    for i in range(25):\n      T[i][i + 1] = 1\n    return T",
      "title": "3335. Total Characters in String After Transformations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a0a5179c-4976-41fd-8607-359de23517a1",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    maxNum = max(nums)\n    # dp[i][x][y] := number of disjoint pairs `seq1` and `seq2` of\n    # nums[0..i - 1], where GCD(seq1) == x and GCD(seq2) == y\n    dp = [[[0] * (maxNum + 1)\n          for _ in range(maxNum + 1)]\n          for _ in range(len(nums) + 1)]\n    dp[0][0][0] = 1\n\n    for i, num in enumerate(nums):\n      for x in range(maxNum + 1):\n        for y in range(maxNum + 1):\n          # 1. Skip nums[i].\n          dp[i + 1][x][y] += dp[i][x][y]\n          dp[i + 1][x][y] %= MOD\n          # 2. Pick nums[i] in the first subsequence.\n          newX = math.gcd(x, num)\n          dp[i + 1][newX][y] += dp[i][x][y]\n          dp[i + 1][newX][y] %= MOD\n          # 3. Pick nums[i] in the second subsequence.\n          newY = math.gcd(y, num)\n          dp[i + 1][x][newY] += dp[i][x][y]\n          dp[i + 1][x][newY] %= MOD\n\n    return sum(dp[-1][g][g]\n               for g in range(1, maxNum + 1)) % MOD",
      "title": "3336. Find the Number of Subsequences With Equal GCD",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd7fb391-e2f7-4260-9962-217afb006b79",
      "code": "class Solution:\n  def subsequencePairCount(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, x: int, y: int) -> int:\n      if i == len(nums):\n        return int(x > 0 and x == y)\n      # 1. Skip nums[i]\n      skip = dp(i + 1, x, y)\n      # 2. Pick nums[i] in the first subsequence\n      take1 = dp(i + 1, math.gcd(x, nums[i]), y)\n      # 3. Pick nums[i] in the second subsequence\n      take2 = dp(i + 1, x, math.gcd(y, nums[i]))\n      return (skip + take1 + take2) % MOD\n\n    return dp(0, 0, 0)",
      "title": "3336. Find the Number of Subsequences With Equal GCD_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "da28c9b0-503d-423d-998a-edd356cb2521",
      "code": "class Solution:\n  # Similar to 3335. Total Characters in String After Transformations I\n  def lengthAfterTransformations(self, s: str, t: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    def matrixMult(A: list[list[int]], B: list[list[int]]) -> list[list[int]]:\n      \"\"\"Returns A * B.\"\"\"\n      sz = len(A)\n      C = [[0] * sz for _ in range(sz)]\n      for i in range(sz):\n        for j in range(sz):\n          for k in range(sz):\n            C[i][j] += A[i][k] * B[k][j]\n            C[i][j] %= MOD\n      return C\n\n    def matrixPow(M: list[list[int]], n: int) -> list[list[int]]:\n      \"\"\"Returns M^n.\"\"\"\n      if n == 0:\n        return [[1 if i == j else 0  # identity matrix\n                for j in range(len(M))]\n                for i in range(len(M))]\n      if n % 2 == 1:\n        return matrixMult(M, matrixPow(M, n - 1))\n      return matrixPow(matrixMult(M, M), n // 2)\n\n    # T[i][j] := the number of ways to transform ('a' + i) to ('a' + j)\n    T = self._getTransformationMatrix(nums)\n    poweredT = matrixPow(T, t)\n    count = [0] * 26\n    lengths = [0] * 26\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for i in range(26):\n      for j in range(26):\n        lengths[j] += count[i] * poweredT[i][j]\n        lengths[j] %= MOD\n\n    return sum(lengths) % MOD\n\n  def _getTransformationMatrix(self, nums: list[int]) -> list[list[int]]:\n    T = [[0] * 26 for _ in range(26)]\n    for i, steps in enumerate(nums):\n      for step in range(1, steps + 1):\n        T[i][(i + step) % 26] += 1\n    return T",
      "title": "3337. Total Characters in String After Transformations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5738f457-5b7e-4d42-aafd-69e0787d3375",
      "code": "class Solution:\n  def countOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 10**9 + 7\n    even = m // 2  # the number of even numbers in [1, m]\n    odd = m - even  # the number of odd numbers in [1, m]\n    # dp[i][j][0/1] := the number of arrays of length i with j consecutive even\n    # number pairs ending in an even number (0) or an odd number (1)\n    dp = [[[0] * 2\n          for _ in range(k + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: arrays of length 1\n    # For an array of length 1, we can't have any even number pairs yet.\n    dp[1][0][0] = even\n    dp[1][0][1] = odd\n\n    for i in range(2, n + 1):\n      for j in range(k + 1):\n        # 1. Appending an even number to an array ending in an even number\n        #    creates a new consecutive even number pair.\n        # 2. Appending an even number to an array ending in an odd number.\n        dp[i][j][0] = ((dp[i - 1][j - 1][0] if j > 0 else 0) * even +\n                       dp[i - 1][j][1] * even) % MOD\n        # 3. Appending an odd number to an array.\n        dp[i][j][1] = sum(dp[i - 1][j]) * odd % MOD\n\n    return sum(dp[n][k]) % MOD",
      "title": "3339. Find the Number of K-Even Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2cc6fbd-695b-4129-b7d1-bb80c5b9d8ef",
      "code": "class Solution:\n  def isBalanced(self, num: str) -> bool:\n    nums = list(map(int, num))\n    return sum(nums[::2]) == sum(nums[1::2])",
      "title": "3340. Check Balanced String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e4a57fc-d8ec-4cc3-a650-3bf092f884ed",
      "code": "class Solution:\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0), (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3341. Find Minimum Time to Reach Last Room I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d2c91e5-888e-4ae0-800c-7053dbd6c8e1",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minTimeToReach(self, moveTime: list[list[int]]) -> int:\n    return self._dijkstra(moveTime,\n                          (0, 0),\n                          (len(moveTime) - 1, len(moveTime[0]) - 1))\n\n  def _dijkstra(\n      self,\n      moveTime: list[list[int]],\n      src: tuple[int, int],\n      dst: tuple[int, int]\n  ) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(moveTime)\n    n = len(moveTime[0])\n    dist = [[math.inf] * n for _ in range(m)]\n\n    dist[0][0] = 0\n    minHeap = [(0, src)]  # (d, (ux, uy))\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = max(moveTime[x][y], d) + (i + j) % 2 + 1\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, (x, y)))\n\n    return -1",
      "title": "3342. Find Minimum Time to Reach Last Room II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f29db004-763f-40a7-9401-c75ab6018b1e",
      "code": "class Solution:\n  def countBalancedPermutations(self, num: str) -> int:\n    nums = list(map(int, num))\n    summ = sum(nums)\n    if summ % 2 == 1:\n      return 0\n\n    nums.sort(reverse=True)\n\n    @functools.lru_cache(None)\n    def dp(even: int, odd: int, evenBalance: int) -> int:\n      \"\"\"\n      Returns the number of permutations where there are `even` even indices\n      left, `odd` odd indices left, and `evenBalance` is the target sum of the\n      remaining numbers to be placed in even indices.\n      \"\"\"\n      if evenBalance < 0:\n        return 0\n      if even == 0:\n        return (evenBalance == 0) * math.factorial(odd)\n      if odd == 0:\n        return (sum(nums[-(even + odd):]) == evenBalance) * math.factorial(even)\n      return (dp(even - 1, odd, evenBalance - nums[-(odd + even)]) * even +\n              dp(even, odd - 1, evenBalance) * odd)\n\n    MOD = 1_000_000_007\n    perm = functools.reduce(lambda x, y: x * math.factorial(y),\n                            collections.Counter(nums).values(), 1)\n    return (dp(even=(len(nums) + 1) // 2,\n               odd=len(nums) // 2,\n               evenBalance=summ // 2) // perm) % MOD",
      "title": "3343. Count Number of Balanced Permutations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23895630-9234-4fcf-99c0-c4ddf8139c6f",
      "code": "class Solution:\n  def maxSizedArray(self, s: int) -> int:\n    def getNumbersWithBitSet(n: int, i: int) -> int:\n      \"\"\"\n      Returns the number of integers in [0, n - 1] with the i-th bit set.\n\n      For the i-th bit, numbers in the range [0, n - 1] can be divided into\n      groups of 2^(i + 1) numbers. In each group, exactly half of the numbers\n      have the i-th bit set.\n      \"\"\"\n      groupSize = 1 << (i + 1)\n      halfGroupSize = 1 << i\n      fullGroups = n // groupSize\n      remaining = max(0, (n % groupSize) - halfGroupSize)\n      return fullGroups * halfGroupSize + remaining\n\n    def getArraySum(n: int) -> int:\n      \"\"\"\n      Returns the sum of all i * (j OR k) values in 3D arrays of size n^3.\n\n        sum(i * (j OR k)), where 0 <= i, j, k < n\n      = 0 * (j OR k) + 1 * (j OR k) + ... + (n - 1) * (j OR k)\n      = (0 + 1 + ... + n - 1) * sum(j OR k)\n      = (n * (n - 1) / 2) * sum(j OR k)\n      \"\"\"\n      arithmeticSum = n * (n - 1) // 2  # 0 + 1 + ... + n - 1\n      orSum = 0  # the sum of (j OR k) values in 2D arrays of size n^2\n      for i in range(n.bit_length()):\n        numbersWithoutBit = n - getNumbersWithBitSet(n, i)\n        pairsWithBit = n**2 - numbersWithoutBit**2\n        orSum += pairsWithBit * (1 << i)  # Add contribution of this bit.\n      return arithmeticSum * orSum\n\n    if s == 0:\n      return 1\n    l = 0\n    r = 1196  # when s = 10^15, n = 1196\n    return bisect.bisect_right(range(l, r + 1), s, key=getArraySum) - 1 + l",
      "title": "3344. Maximum Sized Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e822e7c-92a6-4eea-979e-791d03a3ec64",
      "code": "class Solution:\n  def smallestNumber(self, n: int, t: int) -> int:\n    return next(num for num in range(n, n + 10)\n                if self._getDigitProd(num) % t == 0)\n\n  def _getDigitProd(self, num: int) -> int:\n    digitProd = 1\n    while num > 0:\n      digitProd *= num % 10\n      num //= 10\n    return digitProd",
      "title": "3345. Smallest Divisible Digit Product I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90e50469-e267-4102-9b17-14a4dd18e5ad",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3346. Maximum Frequency of an Element After Performing Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a580af4-f953-4274-a440-5af3ca351d6e",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  # Same as 3346. Maximum Frequency of an Element After Performing Operations I\n  def maxFrequency(self, nums: list[int], k: int, numOperations: int) -> int:\n    ans = 1\n    adjustable = 0\n    count = collections.Counter(nums)\n    line = SortedDict()\n    candidates = set()\n\n    for num in nums:\n      line[num - k] = line.get(num - k, 0) + 1\n      line[num + k + 1] = line.get(num + k + 1, 0) - 1\n      candidates.add(num)\n      candidates.add(num - k)\n      candidates.add(num + k + 1)\n\n    for num in sorted(candidates):\n      adjustable += line.get(num, 0)\n      adjusted = adjustable - count[num]\n      ans = max(ans, count[num] + min(numOperations, adjusted))\n\n    return ans",
      "title": "3347. Maximum Frequency of an Element After Performing Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b48a2467-8ff0-44f7-bcf2-0f35c47f09d6",
      "code": "FACTOR_COUNTS = {\n    0: collections.Counter(),\n    1: collections.Counter(),\n    2: collections.Counter([2]),\n    3: collections.Counter([3]),\n    4: collections.Counter([2, 2]),\n    5: collections.Counter([5]),\n    6: collections.Counter([2, 3]),\n    7: collections.Counter([7]),\n    8: collections.Counter([2, 2, 2]),\n    9: collections.Counter([3, 3]),\n}\n\n\nclass Solution:\n  def smallestNumber(self, num: str, t: int) -> str:\n    primeCount, isDivisible = self._getPrimeCount(t)\n    if not isDivisible:\n      return '-1'\n\n    factorCount = self._getFactorCount(primeCount)\n    if sum(factorCount.values()) > len(num):\n      return ''.join(factor * freq for factor, freq in factorCount.items())\n\n    primeCountPrefix = sum((FACTOR_COUNTS[int(c)]\n                            for c in num), start=collections.Counter())\n    firstZeroIndex = next((i for i, d in enumerate(num) if d == '0'), len(num))\n    if firstZeroIndex == len(num) and primeCount <= primeCountPrefix:\n      return num\n\n    for i, c in reversed(list(enumerate(num))):\n      d = int(c)\n      # Remove the current digit's factors from primeCountPrefix.\n      primeCountPrefix -= FACTOR_COUNTS[d]\n      spaceAfterThisDigit = len(num) - 1 - i\n      if i <= firstZeroIndex:\n        for biggerDigit in range(d + 1, 10):\n          # Compute the required factors after replacing with a larger digit.\n          factorsAfterReplacement = self._getFactorCount(\n              primeCount - primeCountPrefix - FACTOR_COUNTS[biggerDigit]\n          )\n          # Check if the replacement is possible within the available space.\n          if sum(factorsAfterReplacement.values()) <= spaceAfterThisDigit:\n            # Fill extra space with '1', if any, and construct the result.\n            fillOnes = spaceAfterThisDigit - sum(\n                factorsAfterReplacement.values())\n            return (\n                num[:i]  # Keep the prefix unchanged.\n                + str(biggerDigit)  # Replace the current digit.\n                + '1' * fillOnes  # Fill remaining space with '1'.\n                + ''.join(factor * freq for factor,\n                          freq in factorsAfterReplacement.items())\n            )\n\n    # No solution of the same length exists, so we need to extend the number\n    # by prepending '1's and adding the required factors.\n    factorCount = self._getFactorCount(primeCount)\n    return (\n        '1' * (len(num) + 1 - sum(factorCount.values()))\n        + ''.join(factor * freq for factor, freq in factorCount.items())\n    )\n\n  def _getPrimeCount(self, t: int) -> tuple[dict[int, int], bool]:\n    \"\"\"\n    Returns the count of prime factors of t and if t is divisible by 2, 3, 5, 7.\n    \"\"\"\n    count = collections.Counter()\n    for prime in [2, 3, 5, 7]:\n      while t % prime == 0:\n        t //= prime\n        count[prime] += 1\n    return count, t == 1\n\n  def _getFactorCount(self, count: dict[int, int]) -> dict[str, int]:\n    \"\"\"Returns the required factors to form the smallest number.\"\"\"\n    count8, remaining2 = divmod(count[2], 3)  # 2^3 = 8\n    count9, count3 = divmod(count[3], 2)  # 3^2 = 9\n    count4, count2 = divmod(remaining2, 2)  # 2^2 = 4\n    # Combine 2 and 3 to 6 if both are present.\n    count2, count3, count6 = ((0, 0, 1) if count2 == 1 and count3 == 1\n                              else (count2, count3, 0))\n    # Combine 3 and 4 to 2 and 6 if both are present.\n    count2, count6, count3, count4 = ((1, 1, 0, 0)\n                                      if count3 == 1 and count4 == 1\n                                      else (count2, count6, count3, count4))\n    return {'2': count2, '3': count3, '4': count4, '5': count[5],\n            '6': count6, '7': count[7], '8': count8, '9': count9}",
      "title": "3348. Smallest Divisible Digit Product II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c9824589-b568-40c2-aa26-41684acfb9d4",
      "code": "class Solution:\n  def hasIncreasingSubarrays(self, nums: list[int], k: int) -> bool:\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      if increasing // 2 >= k or min(prevIncreasing, increasing) >= k:\n        return True\n\n    return False",
      "title": "3349. Adjacent Increasing Subarrays Detection I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bd1b5b9-1571-4661-a088-c0f70d0fc7a2",
      "code": "class Solution:\n  # Similar to 3349. Adjacent Increasing Subarrays Detection I\n  def maxIncreasingSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n    increasing = 1\n    prevIncreasing = 0\n\n    for a, b in itertools.pairwise(nums):\n      if b > a:\n        increasing += 1\n      else:\n        prevIncreasing = increasing\n        increasing = 1\n      ans = max(ans, increasing // 2)\n      ans = max(ans, min(prevIncreasing, increasing))\n\n    return ans",
      "title": "3350. Adjacent Increasing Subarrays Detection II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dacbced8-60e6-4e8a-ba4f-7ca3a9c0584d",
      "code": "class Solution:\n  def sumOfGoodSubsequences(self, nums: list[int]) -> int:\n    MOD = 10**9 + 7\n    maxNum = max(nums)\n    # endsIn[i] := the number of good subsequences ending in i\n    endsIn = [0] * (maxNum + 2)\n    # dp[i] := the sum of good subsequences ending in i\n    dp = [0] * (maxNum + 2)\n\n    for num in nums:\n      seqsToAppend = 1 + endsIn[num - 1] + endsIn[num + 1]\n      dp[num] = (seqsToAppend * num +\n                 (dp[num] + dp[num - 1] + dp[num + 1])) % MOD\n      endsIn[num] += seqsToAppend % MOD\n\n    return sum(dp) % MOD",
      "title": "3351. Sum of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a6ffb57-39a5-4337-bce6-c6a187334732",
      "code": "class Solution:\n  def countKReducibleNumbers(self, s: str, k: int) -> int:\n    MOD = 1_000_000_007\n    ops = self._getOps(s)\n\n    @functools.lru_cache(None)\n    def dp(i: int, setBits: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of positive integers less than n that are k-reducible,\n      considering the i-th digit, where `setBits` is the number of set bits in\n      the current number, and `tight` indicates if the current digit is\n      tightly bound.\n      \"\"\"\n      if i == len(s):\n        return int(ops[setBits] < k and not tight)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 1\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        res += dp(i + 1, setBits + d, nextTight)\n        res %= MOD\n      return res\n\n    return dp(0, 0, True) - 1  # - 0\n\n  def _getOps(self, s: str) -> int:\n    \"\"\"Returns the number of operations to reduce a number to 0.\"\"\"\n    ops = [0] * (len(s) + 1)\n    for num in range(2, len(s) + 1):\n      ops[num] = 1 + ops[num.bit_count()]\n    return ops",
      "title": "3352. Count K-Reducible Numbers Less Than N",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75c34220-72ce-43c1-80b4-7f807910c478",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    return sum(a != b for a, b in itertools.pairwise(nums))",
      "title": "3353. Minimum Total Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87602fea-4781-498e-b4d6-dfab853a306a",
      "code": "class Solution:\n  def countValidSelections(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n\n    for i, num in enumerate(nums):\n      if num > 0:\n        continue\n      if prefix[i] == suffix[i]:\n        ans += 2  # Go to either direction.\n      if abs(prefix[i] - suffix[i]) == 1:\n        ans += 1  # Go to the direction with the larger sum.\n\n    return ans",
      "title": "3354. Make Array Elements Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "354b8ffd-b7ac-48d9-b42e-2dd6825ba223",
      "code": "class Solution:\n  def isZeroArray(self, nums: list[int], queries: list[list[int]]) -> bool:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n\n    for l, r in queries:\n      line[l] += 1\n      line[r + 1] -= 1\n\n    for i, num in enumerate(nums):\n      decrement += line[i]\n      if decrement < num:\n        return False\n\n    return True",
      "title": "3355. Zero Array Transformation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63e54707-c63f-42ba-8772-d2250ee7b657",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    line = [0] * (len(nums) + 1)\n    decrement = 0\n    k = 0\n\n    for i, num in enumerate(nums):\n      while decrement + line[i] < num:\n        if k == len(queries):\n          return -1\n        l, r, val = queries[k]\n        k += 1\n        if r < i:\n          continue\n        line[max(l, i)] += val\n        line[r + 1] -= val\n      decrement += line[i]\n\n    return k",
      "title": "3356. Zero Array Transformation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e7751ed-7373-4372-ab75-86548453a7a9",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    maxPositiveGap = 0\n    mn = 1_000_000_000\n    mx = 0\n\n    for a, b in itertools.pairwise(nums):\n      if (a == -1) != (b == -1):\n        positive = max(a, b)\n        mn = min(mn, positive)\n        mx = max(mx, positive)\n      else:\n        maxPositiveGap = max(maxPositiveGap, abs(a - b))\n\n    l = maxPositiveGap\n    r = (mx - mn + 1) // 2\n    return bisect.bisect_left(\n        range(l, r), True,\n        key=lambda m: self._check(nums, m, mn + m, mx - m)) + l\n\n  def _check(self, nums: list[int], m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns True if it's possible have `m` as maximum absolute difference\n    between adjacent numbers, where -1s are replaced with `x` or `y`.\n    \"\"\"\n    gapLength = 0\n    prev = 0\n\n    for num in nums:\n      if num == -1:\n        gapLength += 1\n        continue\n      if prev > 0 and gapLength > 0:\n        if gapLength == 1 and not self._checkSingleGap(prev, num, m, x, y):\n          return False\n        if gapLength > 1 and not self._checkMultipleGaps(prev, num, m, x, y):\n          return False\n      prev = num\n      gapLength = 0\n\n    # Check leading gaps\n    if nums[0] == -1:\n      num = next((num for num in nums if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    # Check trailing gaps\n    if nums[-1] == -1:\n      num = next((num for num in reversed(nums) if num != -1), -1)\n      if num != -1 and not self._checkBoundaryGaps(num, m, x, y):\n        return False\n\n    return True\n\n  def _checkSingleGap(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with a single -1 between two numbers.\n    e.g. [a, -1, b] can be filled with either x or y.\n    \"\"\"\n    gapWithX = max(abs(a - x), abs(b - x))  # [a, x, b]\n    gapWithY = max(abs(a - y), abs(b - y))  # [a, y, b]\n    return min(gapWithX, gapWithY) <= m\n\n  def _checkMultipleGaps(self, a: int, b: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a sequence with multiple -1s between two numbers.\n    e.g. [a, -1, -1, ..., -1, b] can be filled with x and y.\n    \"\"\"\n    ax = abs(a - x)\n    ay = abs(a - y)\n    bx = abs(b - x)\n    by = abs(b - y)\n    xy = abs(x - y)\n    gapAllX = max(ax, bx)  # [a, x, x, ..., x, b]\n    gapAllY = max(ay, by)  # [a, y, y, ..., y, b]\n    gapXToY = max(ax, xy, by)  # [a, x, ..., y, b]\n    gapYToX = max(ay, xy, bx)  # [a, y, ..., x, b]\n    return min(gapAllX, gapAllY, gapXToY, gapYToX) <= m\n\n  def _checkBoundaryGaps(self, a: int, m: int, x: int, y: int) -> bool:\n    \"\"\"\n    Returns true if it's possible to have at most `m` as the minimized maximum\n    difference for a boundary sequence starting or ending with -1s.\n    e.g. [a, -1, -1, ...] or [..., -1, -1, a].\n    \"\"\"\n    gapAllX = abs(a - x)  # [x, x, ..., x, a]\n    gapAllY = abs(a - y)  # [y, y, ..., y, a]\n    return min(gapAllX, gapAllY) <= m",
      "title": "3357. Minimize the Maximum Adjacent Element Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2819b6c-a753-4bcd-a7f9-7785ebb5a241",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  subarrayWidth: int\n  rowIndex: int\n  accumulatedSubmatrices: int\n\n\nclass Solution:\n  def countSubmatrices(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    # dp[i][j] := the number of valid subarrays ending in grid[i][j]\n    dp = [[0] * n for _ in range(m)]\n    # stacks[j] := the stack of valid\n    # (subarray width, row index, number of accumulated submatrices) ending in\n    # column j\n    stacks: list[T] = [[T(0, -1, 0)] for _ in range(n)]\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        if num > k:\n          stacks[j] = [T(0, i, 0)]\n        else:\n          dp[i][j] = 1\n          if j > 0 and row[j - 1] <= k and row[j - 1] >= row[j]:\n            # Extend the valid subarrays to the current number.\n            dp[i][j] += dp[i][j - 1]\n          width = dp[i][j]\n          # Remove subarray widths greater than the current count since they\n          # will become invalid.\n          while stacks[j] and width < stacks[j][-1].subarrayWidth:\n            stacks[j].pop()\n          height = i - stacks[j][-1].rowIndex\n          newSubmatrices = width * height\n          accumulatedSubmatrices = (stacks[j][-1].accumulatedSubmatrices +\n                                    newSubmatrices)\n          ans += accumulatedSubmatrices\n          stacks[j].append(T(width, i, accumulatedSubmatrices))\n\n    return ans",
      "title": "3359. Find Sorted Submatrices With Maximum Element at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c73ce66-f1ad-4424-94d2-3f9b0a4e1027",
      "code": "class Solution:\n  def canAliceWin(self, n: int) -> bool:\n    for stones in range(10, -1, -1):\n      if stones > n:\n        return stones % 2 == 1\n      n -= stones",
      "title": "3360. Stone Removal Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3baace04-82d9-4632-80e3-a074a8ef6c1d",
      "code": "class Solution:\n  def shiftDistance(\n      self,\n      s: str,\n      t: str,\n      nextCost: list[int],\n      previousCost: list[int]\n  ) -> int:\n    ans = 0\n    # prev[i][j]: the prev cost to shift from ('a' + i) to ('a' + j)\n    prev = [[0] * 26 for _ in range(26)]\n    # next[i][j]: the next cost to shift from ('a' + i) to ('a' + j)\n    next = [[0] * 26 for _ in range(26)]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        next[i][(i + j) % 26] = cost\n        cost += nextCost[(i + j) % 26]\n\n    for i in range(26):\n      cost = 0\n      for j in range(26):\n        prev[i][(i - j + 26) % 26] = cost\n        cost += previousCost[(i - j + 26) % 26]\n\n    for a, b in zip(s, t):\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      ans += min(next[i][j], prev[i][j])\n\n    return ans",
      "title": "3361. Shift Distance Between Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61a4ee48-cd9e-4bbf-a287-9210f22c7585",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxRemoval(self, nums: list[int], queries: list[list[int]]) -> int:\n    q = collections.deque(sorted(queries))\n    available = SortedList()  # available `r`s\n    running = SortedList()  # running `r`s\n\n    for i, num in enumerate(nums):\n      while q and q[0][0] <= i:\n        available.add(q.popleft()[1])\n      while running and running[0] < i:\n        running.pop(0)\n      while num > len(running):\n        if not available or available[-1] < i:\n          return -1\n        running.add(available.pop())\n\n    return len(available)",
      "title": "3362. Zero Array Transformation III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5c4dad8-93b7-43a9-bb41-d445444905b8",
      "code": "class Solution:\n  def maxCollectedFruits(self, fruits: list[list[int]]) -> int:\n    n = len(fruits)\n\n    def getTopLeft() -> int:\n      return sum(fruits[i][i] for i in range(n))\n\n    def getTopRight() -> int:\n      # dp[i][j] := the number of fruits collected from (0, n - 1) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[0][-1] = fruits[0][-1]\n      for x in range(n):\n        for y in range(n):\n          if x >= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(1, -1), (1, 0), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if i < j < n - 1 - i:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    def getBottomLeft() -> int:\n      # dp[i][j] := the number of fruits collected from (n - 1, 0) to (i, j)\n      dp = [[0] * n for _ in range(n)]\n      dp[-1][0] = fruits[-1][0]\n      for y in range(n):\n        for x in range(n):\n          if x <= y and (x, y) != (n - 1, n - 1):\n            continue\n          for dx, dy in [(-1, 1), (0, 1), (1, 1)]:\n            i = x - dx\n            j = y - dy\n            if i < 0 or i == n or j < 0 or j == n:\n              continue\n            if j < i < n - 1 - j:\n              continue\n            dp[x][y] = max(dp[x][y], dp[i][j] + fruits[x][y])\n      return dp[-1][-1]\n\n    return getTopLeft() + getTopRight() + getBottomLeft() - 2 * fruits[-1][-1]",
      "title": "3363. Find the Maximum Number of Fruits Collected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "feb23168-3361-412e-8b39-8538be56c751",
      "code": "class Solution:\n  def minimumSumSubarray(self, nums: list[int], l: int, r: int) -> int:\n    ans = math.inf\n\n    for windowSize in range(l, r + 1):\n      windowSum = sum(nums[:windowSize])\n      if windowSum > 0:\n        ans = min(ans, windowSum)\n      for i in range(windowSize, len(nums)):\n        windowSum -= nums[i - windowSize]\n        windowSum += nums[i]\n        if windowSum > 0:\n          ans = min(ans, windowSum)\n\n    return -1 if ans == math.inf else ans",
      "title": "3364. Minimum Positive Sum Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ba175d4-3cb4-4b7d-a88e-4d51316ef93a",
      "code": "class Solution:\n  def isPossibleToRearrange(self, s: str, t: str, k: int) -> bool:\n    n = len(s)\n    return (collections.Counter(s[i:i + n // k] for i in range(0, n, n // k)) ==\n            collections.Counter(t[i:i + n // k] for i in range(0, n, n // k)))",
      "title": "3365. Rearrange K Substrings to Form Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa50fdbb-5dc2-450e-aea4-303e85cd40ea",
      "code": "class Solution:\n  def minArraySum(self, nums: list[int], k: int, op1: int, op2: int) -> int:\n    n = len(nums)\n    # dp[i][j][k] := the minimum sum of nums[i..n - 1] with j operations of op1\n    # and k operations of op2\n    dp = [[[math.inf] * (op2 + 1)\n          for _ in range(op1 + 1)]\n          for _ in range(n + 1)]\n\n    # Base case: When index reaches the end of the array, the result is 0.\n    for i in range(op1 + 1):\n      for j in range(op2 + 1):\n        dp[n][i][j] = 0\n\n    for i in range(n - 1, -1, -1):\n      for o1 in range(op1 + 1):\n        for o2 in range(op2 + 1):\n          summ = nums[i] + dp[i + 1][o1][o2]\n          if o1 > 0:\n            summ = min(summ, (nums[i] + 1) // 2 + dp[i + 1][o1 - 1][o2])\n          if o2 > 0 and nums[i] >= k:\n            summ = min(summ, nums[i] - k + dp[i + 1][o1][o2 - 1])\n          if o1 > 0 and o2 > 0:\n            if (nums[i] + 1) // 2 >= k:\n              summ = min(summ,\n                         (nums[i] + 1) // 2 - k + dp[i + 1][o1 - 1][o2 - 1])\n            if nums[i] >= k:\n              summ = min(summ,\n                         (nums[i] - k + 1) // 2 + dp[i + 1][o1 - 1][o2 - 1])\n          dp[i][o1][o2] = summ\n\n    return dp[0][op1][op2]",
      "title": "3366. Minimum Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9ba9adf8-632e-4a9d-acc9-a0550e614b44",
      "code": "class Solution:\n  def maximizeSumOfWeights(self, edges: list[list[int]], k: int) -> int:\n    graph = [[] for _ in range(len(edges) + 1)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    def dfs(u: int, prev: int) -> tuple[int, int]:\n      \"\"\"\n      Returns\n      (the weight sum of the subtree rooted at u with at most k - 1 children,\n       the weight sum of the subtree rooted at u with at most k children).\n      \"\"\"\n      weightSum = 0\n      diffs = []\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        subK1, subK = dfs(v, u)\n        weightSum += subK\n        # If picking (u, v) makes the sum larger, we should pick it.\n        diffs.append(max(0, subK1 - subK + w))\n      return (weightSum + sum(heapq.nlargest(k - 1, diffs)),\n              weightSum + sum(heapq.nlargest(k, diffs)))\n\n    return dfs(0, -1)[1]",
      "title": "3367. Maximize Sum of Weights after Edge Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27486b24-262b-42b2-ab96-f823ef8edcd2",
      "code": "class Solution:\n  def smallestNumber(self, n: int) -> int:\n    return (1 << n.bit_length()) - 1",
      "title": "3370. Smallest Number With All Set Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e9cd7b51-cb3d-4357-bed9-a96d1f4b92f0",
      "code": "class Solution:\n  def getLargestOutlier(self, nums: list[int]) -> int:\n    ans = -math.inf\n    summ = sum(nums)\n    count = collections.Counter(nums)\n\n    for num in nums:\n      withoutNum = summ - num\n      if withoutNum % 2 == 0:\n        specialSum = withoutNum // 2  # the sum of special numbers\n        if count[specialSum] > (1 if num == specialSum else 0):\n          ans = max(ans, num)\n\n    return ans",
      "title": "3371. Identify the Largest Outlier in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de8bd316-61c3-4bcf-bc5d-b64cea7db745",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]],\n      k: int\n  ) -> list[int]:\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    maxReachableInGraph2 = 0\n\n    if k > 0:\n      for i in range(len(edges2) + 1):\n        maxReachableInGraph2 = max(maxReachableInGraph2,\n                                   self._dfs(graph2, i, -1, k - 1))\n\n    return [maxReachableInGraph2 + self._dfs(graph1, i, -1, k)\n            for i in range(len(edges1) + 1)]\n\n  def _dfs(self, graph: list[list[int]], u: int, prev: int, k: int) -> int:\n    \"\"\"Returns the number of nodes that can be reached from u with k steps.\"\"\"\n    if k == 0:\n      return 1\n    res = 0\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, k - 1)\n    return 1 + res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3372. Maximize the Number of Target Nodes After Connecting Trees I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a557191f-0ee1-45ad-949c-a1bea813203c",
      "code": "class Solution:\n  def maxTargetNodes(\n      self,\n      edges1: list[list[int]],\n      edges2: list[list[int]]\n  ) -> list[int]:\n    n = len(edges1) + 1\n    m = len(edges2) + 1\n    graph1 = self._buildGraph(edges1)\n    graph2 = self._buildGraph(edges2)\n    parity1 = [False] * n\n    parity2 = [False] * m  # placeholder (parity2 is not used)\n    even1 = self._dfs(graph1, 0, -1, parity1, True)\n    even2 = self._dfs(graph2, 0, -1, parity2, True)\n    odd1 = n - even1\n    odd2 = m - even2\n\n    # Can connect the current node in tree1 to either an even node or an odd\n    # node in tree2.\n    return [(even1 if parity1[i] else odd1) + max(even2, odd2)\n            for i in range(n)]\n\n  def _dfs(\n      self,\n      graph: list[list[int]],\n      u: int,\n      prev: int,\n      parity: list[bool],\n      isEven: bool\n  ) -> int:\n    \"\"\"\n    Returns the number of nodes that can be reached from u with even steps.\n    \"\"\"\n    res = 1 if isEven else 0\n    parity[u] = isEven\n    for v in graph[u]:\n      if v != prev:\n        res += self._dfs(graph, v, u, parity, not isEven)\n    return res\n\n  def _buildGraph(self, edges: list[list[int]]) -> list[list[int]]:\n    graph = [[] for _ in range(len(edges) + 1)]\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n    return graph",
      "title": "3373. Maximize the Number of Target Nodes After Connecting Trees II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "964259a0-7bbb-464f-b51d-079ba17367f9",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    numsSet = set(nums)\n    mn = min(nums)\n    if mn < k:\n      return -1\n    if mn > k:\n      return len(numsSet)\n    return len(numsSet) - 1",
      "title": "3375. Minimum Operations to Make Array Values Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "36a52dd2-61e7-40c8-aebc-4d57dc8eedcd",
      "code": "class Solution:\n  def minOperations(self, n: int, m: int) -> int:\n    isPrime = self._sieveEratosthenes(10000)\n    if isPrime[n] or isPrime[m]:\n      return -1\n    return self._dijkstra(n, m, isPrime)\n\n  def _dijkstra(self, src: int, dst: int, isPrime: list[bool]) -> int:\n    seen = {src}\n    minHeap = [(src, src)]  # (cost, num)\n\n    while minHeap:\n      cost, curr = heapq.heappop(minHeap)\n      if curr == dst:\n        return cost\n      s = list(str(curr))\n      for i, c in enumerate(s):\n        if c < '9':\n          s[i] = str(int(c) + 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n        if c > '0' and not (i == 0 and c == '1'):\n          s[i] = str(int(c) - 1)\n          nextNum = int(''.join(s))\n          if not isPrime[nextNum] and nextNum not in seen:\n            heapq.heappush(minHeap, (cost + nextNum, nextNum))\n            seen.add(nextNum)\n          s[i] = c\n\n    return -1\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "3377. Digit Operations to Make Two Integers Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d05f06ab-1ce9-4597-bbdf-6e611f0d34f4",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n    self.rank = collections.Counter()\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if u not in self.id:\n      self.id[u] = u\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def countComponents(self, nums: list[int], threshold: int) -> int:\n    uf = UnionFind()\n\n    for num in nums:\n      for multiple in range(2 * num, threshold + 1, num):\n        uf.unionByRank(num, multiple)\n\n    return len(set(uf.find(num) for num in nums))",
      "title": "3378. Count Connected Components in LCM Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fdcae8de-8a0b-494f-bbf7-57e32884ea54",
      "code": "class Solution:\n  def constructTransformedArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    return [nums[(i + num % n + n) % n]\n            for i, num in enumerate(nums)]",
      "title": "3379. Transformed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92c68764-47f2-406a-924e-85064910c517",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = -math.inf\n    prefix = 0\n    # minPrefix[i % k] := the minimum prefix sum of the first i numbers\n    minPrefix = [math.inf] * k\n    minPrefix[k - 1] = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      ans = max(ans, prefix - minPrefix[i % k])\n      minPrefix[i % k] = min(minPrefix[i % k], prefix)\n\n    return ans",
      "title": "3381. Maximum Subarray Sum With Length Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4310d5b3-607d-4811-bbdb-01048f6adbb7",
      "code": "class Solution:\n  def minRunesToAdd(\n      self,\n      n: int,\n      crystals: list[int],\n      flowFrom: list[int],\n      flowTo: list[int]\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v in zip(flowFrom, flowTo):\n      graph[u].append(v)\n      reversedGraph[v].append(u)\n\n    # Identify Strongly Connected Components (SCC) using Kosaraju's Algorithm.\n    seen = set()\n    orderStack = []\n    componentIds = [-1] * n\n    componentCount = 0\n\n    for i in range(n):\n      if i not in seen:\n        self._kosaraju(graph, i, seen, orderStack)\n\n    while orderStack:\n      u = orderStack.pop()\n      if componentIds[u] == -1:\n        self._identifySCC(reversedGraph, u, componentIds, componentCount)\n        componentCount += 1\n\n    # Track crystal-containing components and inter-component edges.\n    hasCrystal = [False] * componentCount\n    hasInterComponentEdge = [False] * componentCount\n\n    for u in crystals:\n      hasCrystal[componentIds[u]] = True\n\n    for u, v in zip(flowFrom, flowTo):\n      id1 = componentIds[u]\n      id2 = componentIds[v]\n      if id1 != id2:  # Edge is inter-component.\n        hasInterComponentEdge[id2] = True\n\n    return sum(not hasCrystal[i] and not hasInterComponentEdge[i]\n               for i in range(componentCount))\n\n  def _kosaraju(\n      self,\n      graph: list[list[int]],\n      u: int,\n      seen: set[int],\n      orderStack: list\n  ) -> None:\n    \"\"\"Creates a topological order stack using Kosaraju's Algorithm.\"\"\"\n    seen.add(u)\n    for v in graph[u]:\n      if v not in seen:\n        self._kosaraju(graph, v, seen, orderStack)\n    orderStack.append(u)\n\n  def _identifySCC(\n      self,\n      reversedGraph: list[list[int]],\n      u: int,\n      componentIds: list[int],\n      componentId: int\n  ) -> None:\n    \"\"\"Assigns component IDs during SCC identification in the second DFS.\"\"\"\n    if componentIds[u] != -1:\n      return\n    componentIds[u] = componentId\n    for v in reversedGraph[u]:\n      if componentIds[v] == -1:\n        self._identifySCC(reversedGraph, v, componentIds, componentId)",
      "title": "3383. Minimum Runes to Add to Cast Spell",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "355d16b8-0e62-45ca-90de-dd644ffacbeb",
      "code": "class Solution:\n  def findMinimumTime(self, strength: list[int]) -> int:\n    costs = [[(s + turn - 1) // turn\n             for s in strength]\n             for turn in range(1, len(strength) + 1)]\n    return self._hungarian(costs)[-1]\n\n  def _hungarian(self, costs):\n    \"\"\"\n    Returns an array `res` of length n (costs.length), with `res[i]` equaling\n    the minimum cost to assign the first (i + 1) turns to the first (i + 1)\n    locks using Hungarian algorithm, where costs[i][j] is the energy required\n    to break j-th lock in i-th turn.\n\n    https://en.wikipedia.org/wiki/Hungarian_algorithm\n    \"\"\"\n    numLocks = len(costs)\n    turnPotentials = [0] * numLocks\n    lockPotentials = [0] * (numLocks + 1)\n    lockAssignments = [-1] * (numLocks + 1)\n    res = []\n\n    for currentTurn in range(numLocks):\n      currentLock = numLocks\n      lockAssignments[currentLock] = currentTurn\n      minReducedCosts = [math.inf] * (numLocks + 1)\n      previousLockAssignments = [-1] * (numLocks + 1)\n      locksInOptimalPath = [False] * (numLocks + 1)\n\n      while lockAssignments[currentLock] != -1:\n        locksInOptimalPath[currentLock] = True\n        assignedTurn = lockAssignments[currentLock]\n        minCostDelta = math.inf\n        nextLock = None\n\n        for lock in range(numLocks):\n          if not locksInOptimalPath[lock]:\n            reducedCost = (\n                costs[assignedTurn][lock] -\n                turnPotentials[assignedTurn] -\n                lockPotentials[lock]\n            )\n            oldMin = minReducedCosts[lock]\n            minReducedCosts[lock] = min(oldMin, reducedCost)\n            if minReducedCosts[lock] < oldMin:\n              previousLockAssignments[lock] = currentLock\n            if minReducedCosts[lock] < minCostDelta:\n              minCostDelta = minReducedCosts[lock]\n              nextLock = lock\n\n        for lock in range(numLocks + 1):\n          if locksInOptimalPath[lock]:\n            turnPotentials[lockAssignments[lock]] += minCostDelta\n            lockPotentials[lock] -= minCostDelta\n          else:\n            minReducedCosts[lock] -= minCostDelta\n\n        currentLock = nextLock\n\n      while currentLock != numLocks:\n        lockAssignments[currentLock] = lockAssignments[previousLockAssignments[currentLock]]\n        currentLock = previousLockAssignments[currentLock]\n\n      res.append(-lockPotentials[numLocks])\n\n    return res",
      "title": "3385. Minimum Time to Break Locks II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e48f582-dacb-4fc7-ab1b-cde90ad31c9d",
      "code": "class Solution:\n  def buttonWithLongestTime(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxTimeTaken = 0\n    prevTime = 0\n\n    for index, time in events:\n      timeTaken = time - prevTime\n      if timeTaken > maxTimeTaken or timeTaken == maxTimeTaken and index < ans:\n        maxTimeTaken = timeTaken\n        ans = index\n      prevTime = time\n\n    return ans",
      "title": "3386. Button with Longest Push Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2014216e-d90c-4e5f-ab32-aa799b925e45",
      "code": "class Solution:\n  def maxAmount(\n      self,\n      initialCurrency: str,\n      pairs1: list[list[str]],\n      rates1: list[float],\n      pairs2: list[list[str]],\n      rates2: list[float]\n  ) -> float:\n    # dp[currency] := the maximum amount of money to convert to `currency`\n    dp: dict[str, float] = collections.defaultdict(float)\n    dp[initialCurrency] = 1.0\n    self._bellman(dp, pairs1, rates1)\n    self._bellman(dp, pairs2, rates2)\n    return dp[initialCurrency]\n\n  def _bellman(\n      self,\n      dp: dict[str, float],\n      pairs: list[list[str]],\n      rates: list[float]\n  ) -> None:\n    for _ in range(len(pairs)):\n      for (start, target), rate in zip(pairs, rates):\n        dp[target] = max(dp[target], dp[start] * rate)\n        dp[start] = max(dp[start], dp[target] / rate)",
      "title": "3387. Maximize Amount After Two Days of Conversions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "816f4e2e-2a4d-41f0-a104-e2ec12b6548b",
      "code": "class Solution:\n  def beautifulSplits(self, nums: list[int]) -> int:\n    n = len(nums)\n    # z[start][i] := the z array of nums[i..n) with respect to nums[start..n)\n    z = [self._zFunction(nums, start)\n         for start in range(n)]\n    # nums1 | nums2 | nums3 = nums[0..i] | nums[i + 1..j] | nums[j + 1..n - 1]\n    return sum((j - i >= i + 1 and z[0][i + 1] >= i + 1)  # nums1 is a prefix of nums2\n               or z[i + 1][j + 1] >= j - i  # nums2 is a suffix of nums3.\n               for i in range(n - 2)\n               for j in range(i + 1, n - 1))\n\n  def _zFunction(self, nums: list[int], start: int) -> list[int]:\n    \"\"\"\n    Returns the z array, where z[i] is the length of the longest prefix of\n    nums[i..n) which is also a prefix of nums[start..n).\n    \"\"\"\n    n = len(nums)\n    z = [0] * n\n    l = start\n    r = start\n    for i in range(1 + start, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l + start])\n      while i + z[i] < n and nums[z[i] + start] == nums[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n    return z",
      "title": "3388. Count Beautiful Splits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb145f95-ec20-4a99-a48f-a3ec48412cdf",
      "code": "class Solution:\n  def makeStringGood(self, s: str) -> int:\n    count = [0] * 26\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n    return min(self._getMinOperations(count, target)\n               for target in range(1, max(count) + 1))\n\n  def _getMinOperations(self, count: list[int], target: int) -> int:\n    # dp[i] represents the minimum number of operations to make the frequency of\n    # (i..25)-th (0-indexed) letters equal to `target`.\n    dp = [0] * 27\n\n    for i in range(25, -1, -1):\n      # 1. Delete all the i-th letters.\n      deleteAllToZero = count[i]\n      # 2. Insert/delete the i-th letters to have `target` number of letters.\n      deleteOrInsertToTarget = abs(target - count[i])\n      dp[i] = min(deleteAllToZero, deleteOrInsertToTarget) + dp[i + 1]\n      if i + 1 < 26 and count[i + 1] < target:\n        nextDeficit = target - count[i + 1]\n        # Make the frequency of the i-th letter equal to the `target` or 0.\n        needToChange = count[i] if count[i] <= target else count[i] - target\n        changeToTarget = (\n            # 3. Change all the i-th letters to the next letter and then\n            # insert the remaining deficit for the next letter.\n            needToChange + (nextDeficit - needToChange) if nextDeficit > needToChange\n            # 4. Change `nextDeficit` i-th letters to the next letter and\n            # then delete the remaining i-th letters.\n            else nextDeficit + (needToChange - nextDeficit)\n        )\n        dp[i] = min(dp[i], changeToTarget + dp[i + 2])\n\n    return dp[0]",
      "title": "3389. Minimum Operations to Make Character Frequencies Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17b0af31-cf8d-4bfc-8172-c2076871bbb2",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    return sum(b == (a + c) * 2\n               for a, b, c in zip(nums, nums[1:], nums[2:]))",
      "title": "3392. Count Subarrays of Length Three With a Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ea573d4-0b17-4413-9fd3-05fe20cde976",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid, k):\n    MOD = 1_000_000_007\n    MAX = 15\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][xors] := the number of paths from (i, j) to (m - 1, n - 1) with\n    # XOR value `xors`\n    dp = [[[0] * (MAX + 1)\n          for _ in range(n)]\n          for _ in range(m)]\n\n    dp[-1][-1][grid[-1][-1]] = 1\n\n    for i in reversed(range(m)):\n      for j in reversed(range(n)):\n        for xors in range(MAX + 1):\n          if i - 1 >= 0:\n            newXor = xors ^ grid[i - 1][j]\n            dp[i - 1][j][newXor] += dp[i][j][xors]\n            dp[i - 1][j][newXor] %= MOD\n          if j - 1 >= 0:\n            newXor = xors ^ grid[i][j - 1]\n            dp[i][j - 1][newXor] += dp[i][j][xors]\n            dp[i][j - 1][newXor] %= MOD\n\n    return dp[0][0][k]",
      "title": "3393. Count Paths With the Given XOR Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b6ed960-9b91-4b20-ac72-49bfb71161ec",
      "code": "class Solution:\n  def countPathsWithXorValue(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def count(i: int, j: int, xors: int) -> int:\n      \"\"\"\n      Return the number of paths from (i, j) to (m - 1, n - 1) with XOR value\n      `xors`.\n      \"\"\"\n      if i == m or j == n:\n        return 0\n      xors ^= grid[i][j]\n      if i == m - 1 and j == n - 1:\n        return int(xors == k)\n      right = count(i, j + 1, xors)\n      down = count(i + 1, j, xors)\n      return (right + down) % MOD\n\n    return count(0, 0, 0)",
      "title": "3393. Count Paths With the Given XOR Value_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "533ee345-ddab-47a3-8c27-0b96ded63544",
      "code": "class Solution:\n  def checkValidCuts(self, n: int, rectangles: list[list[int]]) -> bool:\n    xs = [(startX, endX) for startX, _, endX, _ in rectangles]\n    ys = [(startY, endY) for _, startY, _, endY in rectangles]\n    return max(self._countMerged(xs),\n               self._countMerged(ys)) >= 3\n\n  def _countMerged(self, intervals: list[tuple[int, int]]) -> int:\n    count = 0\n    prevEnd = 0\n    for start, end in sorted(intervals):\n      if start < prevEnd:\n        prevEnd = max(prevEnd, end)\n      else:\n        prevEnd = end\n        count += 1\n    return count",
      "title": "3394. Check if Grid can be Cut into Sections",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15a96d2f-5c4a-4a1a-b056-0bdfcf8d79fd",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3395. Subsequences with a Unique Middle Mode I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "14d3baac-cb9d-4a55-b266-8d78d2e92eaa",
      "code": "class Solution:\n  def __init__(self):\n    self.MOD = 1_000_000_007\n\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    left = collections.Counter()\n    right = collections.Counter()\n\n    for i in range(2):\n      left[nums[i]] += 1\n\n    for i in range(2, n):\n      right[nums[i]] += 1\n\n    for i in range(2, n - 2):\n      num = nums[i]\n      right[num] -= 1\n      if right[num] == 0:\n        del right[num]\n\n      leftCount = left[num]\n      rightCount = right[num]\n      leftOther = i - leftCount\n      rightOther = n - 1 - i - rightCount\n\n      # count[mode] = 5 -- [a a] a [a a]\n      ans += math.comb(leftCount, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 4 -- [a a] a [a ?]\n      ans += math.comb(leftCount, 2) * rightCount * rightOther\n\n      # count[mode] = 4 -- [a ?] a [a a]\n      ans += leftCount * leftOther * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a a] a [? ?]\n      ans += math.comb(leftCount, 2) * math.comb(rightOther, 2)\n\n      # count[mode] = 3 -- [? ?] a [a a]\n      ans += math.comb(leftOther, 2) * math.comb(rightCount, 2)\n\n      # count[mode] = 3 -- [a ?] a [a ?]\n      ans += leftCount * leftOther * rightCount * rightOther\n\n      # count[mode] = 2 -- [a ?] a [? ?]\n      ans += leftCount * self._calc(num, leftOther, rightOther, left, right)\n\n      # count[mode] = 2 -- [? ?] a [a ?]\n      ans += rightCount * self._calc(num, rightOther, leftOther, right, left)\n\n      ans %= self.MOD\n      left[num] += 1\n\n    return ans\n\n  def _calc(\n      self,\n      a: int,\n      other1: int,\n      other2: int,\n      count1: dict[int, int],\n      count2: dict[int, int]\n  ) -> int:\n    \"\"\"\n    Returns the count of subsequences that have `a` as the middle number, where\n    invalid subsequences are excluded.\n    \"\"\"\n    # [a ?] a [? ?]\n    res = (other1 * math.comb(other2, 2)) % self.MOD\n\n    for b, b1 in count1.items():\n      if b == a:\n        continue\n      b2 = count2[b]\n      # Exclude triples -- [a b] a [b b].\n      res = (res - b1 * math.comb(b2, 2)) % self.MOD\n      # Exclude doubles -- [a b] a [b ?].\n      res = (res - b1 * b2 * (other2 - b2)) % self.MOD\n\n    for b, b2 in count2.items():\n      if b == a:\n        continue\n      b1 = count1[b]\n      # Exclude doubles -- [a ?] a [b b].\n      res = (res - (other1 - b1) * math.comb(b2, 2)) % self.MOD\n\n    return (res + self.MOD) % self.MOD",
      "title": "3395. Subsequences with a Unique Middle Mode I_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "314f2a0d-5848-469b-8dea-dd1763a6bcdc",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    seen = set()\n    for i, num in reversed(list(enumerate(nums))):\n      if num in seen:\n        return (i + 1 + 2) // 3  # ceil((i + 1) / 3)\n      seen.add(num)\n    return 0",
      "title": "3396. Minimum Number of Operations to Make Elements in Array Distinct",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ad69177-efab-4669-aa97-45bac8f1aeac",
      "code": "class Solution:\n  def maxDistinctElements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    occupied = -math.inf\n\n    for num in sorted(nums):\n      if occupied < num + k:\n        occupied = max(occupied + 1, num - k)\n        ans += 1\n\n    return ans",
      "title": "3397. Maximum Number of Distinct Elements After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0879d9cc-3612-436f-9532-2ed3017b3fa8",
      "code": "class Solution:\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3398. Smallest Substring With Identical Characters I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbc26370-b949-4ae6-bc8c-0eb3e92f2d2d",
      "code": "class Solution:\n  # Same as 3398. Smallest Substring With Identical Characters I\n  def minLength(self, s: str, numOps: int) -> int:\n    def getMinOps(k: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations needed to make all groups of\n      identical characters of length k or less.\n      \"\"\"\n      if k == 1:\n        res = sum(1 for i, c in enumerate(s) if int(c) == i % 2)\n        return min(res, len(s) - res)\n\n      res = 0\n      runningLen = 1\n\n      for a, b in itertools.pairwise(s):\n        if a == b:\n          runningLen += 1\n        else:\n          res += runningLen // (k + 1)\n          runningLen = 1\n\n      return res + runningLen // (k + 1)\n\n    return bisect_left(range(1, len(s) + 1),\n                       True, key=lambda m: getMinOps(m) <= numOps)",
      "title": "3399. Smallest Substring With Identical Characters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06763842-4486-4b43-aa7a-600a375948eb",
      "code": "class Solution:\n  def maximumMatchingIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n\n    for shift in range(n):\n      matches = 0\n      for i, num2 in enumerate(nums2):\n        if nums1[(i + shift) % n] == num2:\n          matches += 1\n      ans = max(ans, matches)\n\n    return ans",
      "title": "3400. Maximum Number of Matching Indices After Right Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a209370-9ccc-438f-9bc7-7b4b291b7f6d",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    ans = 0\n\n    for j in range(len(grid[0])):\n      for i in range(1, len(grid)):\n        if grid[i][j] <= grid[i - 1][j]:\n          ans += grid[i - 1][j] - grid[i][j] + 1\n          grid[i][j] = grid[i - 1][j] + 1\n\n    return ans",
      "title": "3402. Minimum Operations to Make Columns Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e1bd630-a07e-405b-85ec-056e589b76f4",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3403. Find the Lexicographically Largest String From the Box I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "054fd09a-3685-4a5e-94ac-c9a4a9b84d25",
      "code": "class Solution:\n  def numberOfSubsequences(self, nums: list[int]) -> int:\n    n = len(nums)\n    mx = max(nums)\n    ans = 0\n    count = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    # nums[p] * nums[r] == nums[q] * nums[s]\n    # nums[p] / nums[q] == nums[s] / nums[r]\n    for r in range(4, n - 1 - 2 + 1):\n      q = r - 2\n      for p in range(0, q - 2 + 1):\n        g = math.gcd(nums[p], nums[q])\n        count[nums[p] // g][nums[q] // g] += 1\n      for s in range(r + 2, n):\n        g = math.gcd(nums[s], nums[r])\n        ans += count[nums[s] // g][nums[r] // g]\n\n    return ans",
      "title": "3404. Count Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1cfcbac-0480-42ef-8506-3e8ff1b2d92c",
      "code": "class Solution:\n  def countGoodArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    return m * pow(m - 1, n - k - 1, MOD) * math.comb(n - 1, k) % MOD",
      "title": "3405. Count the Number of Arrays with K Matching Adjacent Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e955b067-c773-4cd6-b39f-99fe47ef5a97",
      "code": "class Solution:\n  def answerString(self, word: str, numFriends: int) -> str:\n    if numFriends == 1:\n      return word\n    s = self._lastSubstring(word)\n    sz = len(word) - numFriends + 1\n    return s[:min(len(s), sz)]\n\n  # Same as 1163. Last Substring in Lexicographical Order\n  def _lastSubstring(self, s: str) -> str:\n    i = 0\n    j = 1\n    k = 0  # the number of the same letters of s[i..n) and s[j..n)\n\n    while j + k < len(s):\n      if s[i + k] == s[j + k]:\n        k += 1\n      elif s[i + k] > s[j + k]:\n        # Skip s[j..j + k) and advance to s[j + k + 1] to find a possible\n        # lexicographically larger substring since s[i..i + k) == s[j..j + k)\n        # and s[i + k] > s[j + k).\n        j = j + k + 1\n        k = 0\n      else:\n        # Skip s[i..i + k) and advance to s[i + k + 1] or s[j] to find a\n        # possible lexicographically larger substring since\n        # s[i..i + k) == s[j..j + k) and s[i + k] < s[j + k).\n        # Note that it's unnecessary to explore s[i + k + 1..j) if\n        # i + k + 1 < j since they are already explored by j.\n        i = max(i + k + 1, j)\n        j = i + 1\n        k = 0\n\n    return s[i:]",
      "title": "3406. Find the Lexicographically Largest String From the Box II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cdc4ed65-48ad-4bc9-ad16-cf582cdc1de6",
      "code": "class Solution:\n  def hasMatch(self, s: str, p: str) -> bool:\n    prefix, suffix = p.split('*')\n    i = s.find(prefix)\n    return i != -1 and s.find(suffix, i + len(prefix)) != -1",
      "title": "3407. Substring Matching Pattern",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3359039-37bd-45f0-b4bb-a4642d9f90f0",
      "code": "class Solution:\n  def longestSubsequence(self, nums: list[int]) -> int:\n    mx = max(nums)\n    # dp[num][diff] := the length of the longest subsequence ending in `num`\n    # s.t. the last absolute difference between consecutive elements is `diff`\n    dp = [[0] * (mx + 1) for _ in range(mx + 1)]\n\n    for num in nums:\n      for prev in range(1, mx + 1):\n        diff = abs(num - prev)\n        dp[num][diff] = max(dp[num][diff], dp[prev][diff] + 1)\n      # dp[num][diff] := max(dp[num][j]) for j >= diff\n      for j in range(mx - 1, -1, -1):\n        dp[num][j] = max(dp[num][j], dp[num][j + 1])\n\n    return max(map(max, dp))",
      "title": "3409. Longest Subsequence With Decreasing Adjacent Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e1cbdf2-d68c-49c1-8455-19fa64e430a1",
      "code": "class Solution:\n  def maxSubarraySum(self, nums: list[int]) -> int:\n    ans = max(nums)\n    prefix = 0\n    minPrefix = 0\n    # the minimum prefix sum that can have a negative number removed\n    modifiedMinPrefix = 0\n    count = collections.Counter()\n    # minPrefixPlusRemoval[num] := the minimum prefix sum plus removed `num`\n    minPrefixPlusRemoval = {}\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix - modifiedMinPrefix)\n      if num < 0:\n        count[num] += 1\n        minPrefixPlusRemoval[num] = (\n            min(minPrefixPlusRemoval.get(num, 0), minPrefix) + num)\n        modifiedMinPrefix = min(modifiedMinPrefix,\n                                count[num] * num,\n                                minPrefixPlusRemoval[num])\n      minPrefix = min(minPrefix, prefix)\n      modifiedMinPrefix = min(modifiedMinPrefix, minPrefix)\n\n    return ans",
      "title": "3410. Maximize Subarray Sum After Removing All Occurrences of One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98eab1ed-0f70-4e93-a678-a4d57c9f679e",
      "code": "class Solution:\n  def maxLength(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n\n    for i in range(n):\n      prod = 1\n      l = 1\n      g = 0\n      for j in range(i, n):\n        prod *= nums[j]\n        l = math.lcm(l, nums[j])\n        g = math.gcd(g, nums[j])\n        if prod == l * g:\n          ans = max(ans, j - i + 1)\n\n    return ans",
      "title": "3411. Maximum Subarray With Equal Products",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31c41985-fcd8-4781-8a1e-86dfce528dc6",
      "code": "class Solution:\n  def calculateScore(self, s: str) -> int:\n    ans = 0\n    indices = [[] for _ in range(26)]\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      oppositeIndex = 25 - index\n      if indices[oppositeIndex]:\n        ans += i - indices[oppositeIndex].pop()\n      else:\n        indices[index].append(i)\n\n    return ans",
      "title": "3412. Find Mirror Score of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b27db0cd-7934-4b04-8271-5298c9a3eba4",
      "code": "class Solution:\n  def maximumCoins(self, coins: list[list[int]], k: int) -> int:\n    return max(self._slide(coins, k),\n               self._slide([[-r, -l, c] for l, r, c in coins], k))\n\n  def _slide(self, coins: list[list[int]], k: int) -> int:\n    coins.sort()\n    res = 0\n    windowSum = 0\n    j = 0\n    for li, ri, ci in coins:  # Consider the number line [li..li + k).\n      rightBoundary = li + k\n\n      # [lj, rj] is fully in [li..li + k).\n      while j + 1 < len(coins) and coins[j + 1][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        windowSum += (rj - lj + 1) * cj\n        j += 1\n\n      # [lj, rj] may be partially in [l..l + k).\n      last = 0\n      if j < len(coins) and coins[j][0] < rightBoundary:\n        lj, rj, cj = coins[j]\n        last = (min(rightBoundary - 1, rj) - lj + 1) * cj\n\n      res = max(res, windowSum + last)\n      windowSum -= (ri - li + 1) * ci\n    return res",
      "title": "3413. Maximum Coins From K Consecutive Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a2859ae-1ad7-419f-9464-740f80aed68b",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  weight: int\n  selected: tuple[int]\n\n  def __iter__(self):\n    yield self.weight\n    yield self.selected\n\n\nclass Solution:\n  def maximumWeight(self, intervals: list[list[int]]) -> list[int]:\n    intervals = sorted((*interval, i) for i, interval in enumerate(intervals))\n\n    @functools.lru_cache(None)\n    def dp(i: int, quota: int) -> T:\n      \"\"\"\n      Returns the maximum weight and the selected intervals for intervals[i..n),\n      where `quota` is the number of intervals that can be selected.\n      \"\"\"\n      if i == len(intervals) or quota == 0:\n        return T(0, ())\n\n      skip = dp(i + 1, quota)\n\n      _, r, weight, originalIndex = intervals[i]\n      j = bisect.bisect_right(intervals, (r, math.inf))\n      nextRes = dp(j, quota - 1)\n      pick = T(weight + nextRes.weight,\n               sorted((originalIndex, *nextRes.selected)))\n      return (pick if (pick.weight > skip.weight or\n                       pick.weight == skip.weight and pick.selected < skip.selected)\n              else skip)\n\n    return list(dp(0, 4).selected)",
      "title": "3414. Maximum Score of Non-overlapping Intervals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1411d96-a6c3-4c16-99a0-f21d712b8e73",
      "code": "# Recall from solution 1 that after counting all the subsequences with `a` as\n# the middle mode number, we need to subtract the cases where `a` is not a\n# unique mode or not a mode.\n#\n# To avoid the need of looping through all numbers that are not `a`, we can\n# maintain the sums that are not related to `a` in the loop.\n#\n# So, during the simplification of the formula, keep the running sums of\n# pss, spp, pp, ss, and ps as the first item.\n# (for cleaner notation, abbreviate p[b] and s[b] to just p and s)\n#\n#   sum(b != a) (p[a] * p * s) * (r - s[a] - s)\n#             + (s[a] * s * p) * (l - p[a] - p)\n#             + (p, 2) * s[a] * (r - s[a])\n#             + (s, 2) * p[a] * (l - p[a])\n#\n#   sum(b != a) (p * s) * (p[a] * (r - s[a])) + (p * s^2) * (-p[a])\n#             + (s * p) * (s[a] * (l - p[a])) + (s * p^2) * (-s[a])\n#             + (p^2 - p) * (s[a] * (r - s[a]) / 2)\n#             + (s^2 - s) * (p[a] * (l - p[a]) / 2)\n\n\nclass Solution:\n  # Same as 3395. Subsequences with a Unique Middle Mode I\n  def subsequencesWithMiddleMode(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    p = collections.Counter()  # prefix counter\n    s = collections.Counter(nums)  # suffix counter\n\n    def nC2(n: int) -> int:\n      return n * (n - 1) // 2\n\n    pss = 0\n    spp = 0\n    pp = 0\n    ss = sum(freq**2 for freq in s.values())\n    ps = 0\n\n    for i, a in enumerate(nums):\n      # Update running sums after decrementing s[a].\n      pss += p[a] * (-s[a]**2 + (s[a] - 1)**2)\n      spp += -p[a]**2  # (-s[a] + (s[a] - 1)) * p[a]**2\n      ss += -s[a]**2 + (s[a] - 1)**2\n      ps += -p[a]  # -p[a] * (-s[a] + (s[a] - 1))\n\n      s[a] -= 1\n\n      l = i\n      r = len(nums) - i - 1\n\n      # Start with all possible subsequences with `a` as the middle number.\n      ans += nC2(l) * nC2(r)\n\n      # Minus the cases where the frequency of `a` is 1, so it's not a mode.\n      ans -= nC2(l - p[a]) * nC2(r - s[a])\n\n      # Minus the values where `b != a`.\n      pss_ = pss - p[a] * s[a]**2\n      spp_ = spp - s[a] * p[a]**2\n      pp_ = pp - p[a]**2\n      ss_ = ss - s[a]**2\n      ps_ = ps - p[a] * s[a]\n      p_ = l - p[a]\n      s_ = r - s[a]\n\n      # Minus the cases where the `a` is not a \"unique\" mode or not a mode.\n      ans -= ps_ * (p[a] * (r - s[a])) + pss_ * (-p[a])\n      ans -= ps_ * (s[a] * (l - p[a])) + spp_ * (-s[a])\n      ans -= (pp_ - p_) * s[a] * (r - s[a]) // 2\n      ans -= (ss_ - s_) * p[a] * (l - p[a]) // 2\n      ans %= MOD\n\n      # Update running sums after incrementing p[a].\n      pss += s[a]**2  # (-p[a] + (p[a] + 1)) * s[a]**2\n      spp += s[a] * (-p[a]**2 + (p[a] + 1)**2)\n      pp += -p[a]**2 + (p[a] + 1)**2\n      ps += s[a]  # (-p[a] + (p[a] + 1)) * s[a]\n\n      p[a] += 1\n\n    return ans",
      "title": "3416. Subsequences with a Unique Middle Mode II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bdc5c97-4dd4-4bf6-8431-4ede7f5df8ae",
      "code": "class Solution:\n  def zigzagTraversal(self, grid: list[list[int]]) -> list[int]:\n    zigzag = [row[::-1] if i % 2 else row for i, row in enumerate(grid)]\n    return [num for row in zigzag for num in row][::2]",
      "title": "3417. Zigzag Grid Traversal With Skip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69057dc1-3803-488c-b7dd-772572f8d0d8",
      "code": "class Solution:\n  def maximumAmount(self, coins: list[list[int]]) -> int:\n    m = len(coins)\n    n = len(coins[0])\n    # dp[i][j][k] := the maximum profit at position (i, j) with k remaining\n    # neutralizations\n    dp = [[[-math.inf] * 4 for _ in range(n)] for _ in range(m)]\n\n    # Base case: the robot starts at the top-left corner.\n    dp[0][0][2] = coins[0][0]\n    if coins[0][0] < 0:\n      dp[0][0][1] = 0  # Neutralize the robber.\n\n    for i in range(m):\n      for j in range(n):\n        for k in range(3):  # for each number of remaining neutralizations\n          if i > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i - 1][j][k] + coins[i][j],\n                              dp[i - 1][j][k + 1])\n          if j > 0:\n            dp[i][j][k] = max(dp[i][j][k],\n                              dp[i][j - 1][k] + coins[i][j],\n                              dp[i][j - 1][k + 1])\n\n    return max(dp[-1][-1])",
      "title": "3418. Maximum Amount of Money Robot Can Earn",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "565558ee-ddc6-4f81-aa50-546b2e13c9b5",
      "code": "class Solution:\n  def minMaxWeight(self, n: int, edges: list[list[int]], threshold: int) -> int:\n    MAX = 1000000\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      reversedGraph[v].append((u, w))\n\n    l = 1\n    r = MAX + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if self._dfs(reversedGraph, 0, m, set()) == n:\n        r = m\n      else:\n        l = m + 1\n\n    return -1 if l == MAX + 1 else l\n\n  def _dfs(\n      self,\n      reversedGraph: list[list[tuple]],\n      u: int,\n      maxWeight: int,\n      seen: set[int]\n  ) -> int:\n    \"\"\"Returns the number of nodes reachable from u with weight <= maxWeight.\"\"\"\n    res = 1\n    seen.add(u)\n    for v, w in reversedGraph[u]:\n      if w > maxWeight or v in seen:\n        continue\n      res += self._dfs(reversedGraph, v, maxWeight, seen)\n    return res",
      "title": "3419. Minimize the Maximum Edge Weight of Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73226e9a-d9ba-41d1-bd59-66c54fe7d7b0",
      "code": "class Solution:\n  def countNonDecreasingSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    cost = 0\n    # Store (number, count) pairs in non-increasing order. The numbers in the\n    # queue represent what nums[i..j] look like after adjustments.\n    dq = collections.deque()\n\n    j = len(nums) - 1\n    for i, num in reversed(list(enumerate(nums))):\n      count = 1\n      while dq and dq[-1][0] < num:\n        nextNum, nextCount = dq.pop()\n        count += nextCount\n        cost += (num - nextNum) * nextCount  # Adjust `nextNum`s to `num`.\n      dq.append((num, count))\n      while cost > k:  # Remove the rightmost number.\n        rightmostNum, rightmostCount = dq.popleft()\n        cost -= (rightmostNum - nums[j])\n        j -= 1\n        if rightmostCount > 1:\n          dq.appendleft((rightmostNum, rightmostCount - 1))\n      ans += j - i + 1\n\n    return ans",
      "title": "3420. Count Non-Decreasing Subarrays After K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e76b0867-a329-4426-b48f-361a1895a16c",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    window = SortedList(nums[:k])\n    median = window[(k - 1) // 2]\n    ops = sum(abs(median - nums[j]) for j in range(k))\n    ans = ops\n\n    for i in range(k, len(nums)):\n      window.remove(nums[i - k])\n      window.add(nums[i])\n      ops -= abs(median - nums[i - k])\n      ops += abs(median - nums[i])\n      newMedian = window[(k - 1) // 2]\n      medianMultiplier = (\n          2\n          if k % 2 == 0 and median <= newMedian <= window[k // 2]\n          else k % 2)\n      ops -= abs(newMedian - median) * medianMultiplier\n      median = newMedian\n      ans = min(ans, ops)\n\n    return ans",
      "title": "3422. Minimum Operations to Make Subarray Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68f139ad-4fad-4a5c-9329-6e917c9c2768",
      "code": "class Solution:\n  def maxAdjacentDistance(self, nums: list[int]) -> int:\n    return max(abs(nums[i] - nums[i - 1])\n               for i in range(len(nums)))",
      "title": "3423. Maximum Difference Between Adjacent Elements in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5fbbb73-eede-44b2-a819-41a4f24cdd6b",
      "code": "class Solution:\n  def minCost(self, arr: list[int], brr: list[int], k: int) -> int:\n    def cost(arr: list[int], brr: list[int]) -> int:\n      return sum(abs(a - b) for a, b in zip(arr, brr))\n    return min(cost(arr, brr), cost(sorted(arr), sorted(brr)) + k)",
      "title": "3424. Minimum Cost to Make Arrays Identical",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf8cb5fa-b1de-470c-affe-96984d36ad2c",
      "code": "class Solution:\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: int,\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n      leftBoundary = max(leftBoundary, prevDepth)\n\n      length = prefix[-1] - prefix[leftBoundary]\n      nodes = len(prefix) - leftBoundary\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=0)\n    return [maxLength, minNodes]",
      "title": "3425. Longest Special Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fba8e8f2-557d-4bd8-b182-e6ac33254846",
      "code": "class Solution:\n  def distanceSum(self, m: int, n: int, k: int) -> int:\n    # For each distance d, where 1 < d < m, there are `m - d` ways to choose\n    # the two columns that the two pieces are on. For each of the two pieces,\n    # there are `n` ways to choose the row that the piece is on.\n    # Therefore, the contribution of row differences is\n    #   sum(d * (m - d) * n^2), where 1 < d <= m - 1\n    # = n^2 * sum(d * m - d^2)\n    # = n^2 * (d * m * (m - 1) / 2 - m * (m - 1) * (2m - 1) / 6)\n    # = n^2 * (m^3 - m) / 6\n    # Similarly, the contribution of column differences is\n    #   m^2 * (n^3 - n) / 6\n    MOD = 1_000_000_007\n    return (n**2 * (m**3 - m) // 6 +\n            m**2 * (n**3 - n) // 6) * math.comb(m * n - 2, k - 2) % MOD",
      "title": "3426. Manhattan Distances of All Arrangements of Pieces",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15d19957-f3d1-45f4-90b9-0914a7c301f2",
      "code": "class Solution:\n  def subarraySum(self, nums: list[int]) -> int:\n    prefix = list(itertools.accumulate(nums, initial=0))\n    return sum(prefix[i + 1] - prefix[max(0, i - num)]\n               for i, num in enumerate((nums)))",
      "title": "3427. Sum of Variable Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "072117c7-6752-4b17-a432-92b2a8234a3a",
      "code": "class Solution:\n  def minMaxSums(self, nums: list[int], k: int) -> int:\n    # In a sorted array, nums[i] will be\n    #   1. The maximum for subsequences formed by nums[0..i].\n    #   2. The minimum for subsequences formed by nums[i..n - 1].\n    #\n    # The number of times nums[i] is the maximum is the same as the number of\n    # times nums[n - 1 - i] is the minimum, due to the symmetry in subsequences\n    # derived from the sorted order.\n    #\n    # To calculate the contribution of nums[i], we need to find the number of\n    # ways to select at most (k - 1) elements from the range of indices where\n    # nums[i] is the smallest or nums[n - 1 - i] is the largest.\n    MOD = 1_000_000_007\n    n = len(nums)\n\n    def getComb(n: int, k: int) -> list[list[int]]:\n      \"\"\"C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\"\"\"\n      comb = [[0] * (k + 1) for _ in range(n + 1)]\n      for i in range(n + 1):\n        comb[i][0] = 1\n      for i in range(1, n + 1):\n        for j in range(1, k + 1):\n          comb[i][j] = (comb[i - 1][j] + comb[i - 1][j - 1]) % MOD\n      return comb\n\n    comb = getComb(n, k - 1)\n    ans = 0\n\n    nums.sort()\n\n    # i: available numbers from the left of nums[i] or\n    #    available numbers from the right of nums[-1 - i]\n    for i in range(n):\n      count = 0\n      for j in range(k):  # selected numbers\n        count = (count + comb[i][j]) % MOD\n      ans += nums[i] * count\n      ans += nums[-1 - i] * count\n      ans %= MOD\n\n    return ans",
      "title": "3428. Maximum and Minimum Sums of at Most Size K Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f019c969-dc63-48a1-b114-f7ba11d214fd",
      "code": "class Solution:\n  def minCost(self, n: int, costs: list[list[int]]) -> int:\n    INVALID_COLOR = 3\n\n    def getValidColors(prevColor: int) -> list[int]:\n      return [color for color in range(3) if color != prevColor]\n\n    @functools.lru_cache(None)\n    def minCost(i: int, prevLeftColor: int, prevRightColor: int) -> int:\n      if i == len(costs) // 2:\n        return 0\n      res = math.inf\n      for leftColor in getValidColors(prevLeftColor):\n        for rightColor in getValidColors(prevRightColor):\n          if leftColor == rightColor:\n            continue\n          leftCost = costs[i][leftColor]\n          rightCost = costs[-1 - i][rightColor]\n          res = min(res, leftCost + rightCost +\n                    minCost(i + 1, leftColor, rightColor))\n      return res\n\n    return minCost(0, INVALID_COLOR, INVALID_COLOR)",
      "title": "3429. Paint House IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba9fdfc7-2f05-4cd7-8e1e-7b8cdae9d91e",
      "code": "class Solution:\n  # Similar to 2104. Sum of Subarray Ranges\n  def minMaxSubarraySum(self, nums: list[int], k: int) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return (self._subarraySum(nums, prevGt, nextGt, k) +\n            self._subarraySum(nums, prevLt, nextLt, k))\n\n  def _subarraySum(\n      self,\n      nums: list[int],\n      prev: list[int],\n      next: list[int],\n      k: int\n  ) -> int:\n    \"\"\"\n    Returns the sum of all subarrays with a size <= k, The `prev` and `next`\n    arrays are used to store the indices of the nearest numbers that are\n    smaller or larger than the current number, respectively.\n    \"\"\"\n    res = 0\n    for i, num in enumerate(nums):\n      l = min(i - prev[i], k)\n      r = min(next[i] - i, k)\n      extra = max(0, l + r - 1 - k)\n      res += num * (l * r - extra * (extra + 1) // 2)\n    return res\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "3430. Maximum and Minimum Sums of at Most Size K Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fac0a8d7-9cc7-4466-aa85-1332ccf34515",
      "code": "class Solution:\n  def minUnlockedIndices(self, nums: list[int], locked: list[int]) -> int:\n    first2 = next((i for i, x in enumerate(nums) if x == 2), -1)\n    first3 = next((i for i, x in enumerate(nums) if x == 3), -1)\n    last1 = next((i for i, x in reversed(list(enumerate(nums))) if x == 1), -1)\n    last2 = next((i for i, x in reversed(list(enumerate(nums))) if x == 2), -1)\n    if first3 != -1 and last1 != -1 and first3 < last1:\n      return -1\n    return (sum(locked[i] == 1 for i in range(first2, last1)\n                if first2 != -1 and last1 != -1) +\n            sum(locked[i] == 1 for i in range(first3, last2)\n                if first3 != -1 and last2 != -1))",
      "title": "3431. Minimum Unlocked Indices to Sort Nums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "61604155-d088-49c0-b3da-7ed11f128827",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int]) -> int:\n    # If we add the same number in the left subarray and remove it from the\n    # right subarray, then the difference remains the same parity. So, just\n    # return the number of ways to partition the array into two subarrays when\n    # the array sum is even.\n    return len(nums) - 1 if sum(nums) % 2 == 0 else 0",
      "title": "3432. Count Partitions with Even Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b721374e-20b8-4faf-a99f-027d6cbec00d",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass OfflineUser:\n  returnTimestamp: int\n  userId: int\n\n  def __lt__(self, other):\n    return self.returnTimestamp < other.returnTimestamp\n\n\nclass Solution:\n  def countMentions(\n      self,\n      numberOfUsers: int,\n      events: list[list[str]]\n  ) -> list[int]:\n    ans = [0] * numberOfUsers\n    online = [True] * numberOfUsers\n    offlineQueue = []  # min-heap to track users that are offline\n    allMentionsCount = 0\n\n    events.sort(key=lambda x: (int(x[1]), -ord(x[0][0])))\n\n    for eventType, t, messageContent in events:\n      timestamp = int(t)\n      # Bring users back online if their offline period has ended.\n      while offlineQueue and offlineQueue[0].returnTimestamp <= timestamp:\n        user = heapq.heappop(offlineQueue)\n        online[user.userId] = True\n      if eventType == \"MESSAGE\":\n        match messageContent:\n          case \"ALL\":\n            allMentionsCount += 1\n          case \"HERE\":\n            for userId in range(numberOfUsers):\n              if online[userId]:\n                ans[userId] += 1\n          case _:\n            for userId in [int(part[2:]) for part in messageContent.split()]:\n              ans[userId] += 1\n      elif eventType == \"OFFLINE\":\n        userId = int(messageContent)\n        online[userId] = False\n        # Add to queue to bring back online after 60 units.\n        heapq.heappush(offlineQueue, OfflineUser(timestamp + 60, userId))\n\n    # Add the \"ALL\" mentions to all users.\n    for userId in range(numberOfUsers):\n      ans[userId] += allMentionsCount\n    return ans",
      "title": "3433. Count Mentions Per User",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56676e4e-d45b-4495-ba91-9c581e7c7e43",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    return nums.count(k) + max(self._kadane(nums, target, k)\n                               for target in range(1, 51)\n                               if target != k)\n\n  def _kadane(self, nums: list[int], target: int, k: int) -> int:\n    \"\"\"\n    Returns the maximum achievable frequency of `k` by Kakane's algorithm,\n    where each `target` in subarrays is transformed to `k`.\n    \"\"\"\n    maxSum = 0\n    sum = 0\n    for num in nums:\n      if num == target:\n        sum += 1\n      elif num == k:\n        sum -= 1\n      if sum < 0:  # Reset sum if it becomes negative (Kadane's spirit).\n        sum = 0\n      maxSum = max(maxSum, sum)\n    return maxSum",
      "title": "3434. Maximum Frequency After Subarray Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0858d5cd-4d4c-48f7-8e7a-bd07bfeb7f93",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def supersequences(self, words: list[str]) -> list[list[int]]:\n    ans = []\n    edges = [(string.ascii_lowercase.index(words[0]),\n              string.ascii_lowercase.index(words[1]))\n             for words in words]\n    nodes = sorted({u for u, _ in edges} | {v for _, v in edges})\n    letterToIndex = {letter: i for i, letter in enumerate(nodes)}\n    graph = [[] for _ in range(len(nodes))]\n\n    for u, v in edges:\n      graph[letterToIndex[u]].append(letterToIndex[v])\n\n    for doubledSubset in self._getMinimumSubsets(graph):\n      freq = [0] * 26\n      for letter in nodes:\n        freq[letter] = 1\n      for index in doubledSubset:\n        freq[nodes[index]] = 2\n      ans.append(freq)\n\n    return ans\n\n  def _getMinimumSubsets(self, graph: list[list[int]]) -> list[tuple[int]]:\n    \"\"\"\n    Returns a list of the minimum subsets of nodes that do not create a cycle\n    when skipped.\n    \"\"\"\n    n = len(graph)\n    for subsetSize in range(n + 1):\n      doubleSubsets = []\n      for doubledSubset in itertools.combinations(range(n), subsetSize):\n        if not self._hasCycleSkipping(graph, set(doubledSubset)):\n          doubleSubsets.append(doubledSubset)\n      if doubleSubsets:\n        return doubleSubsets\n    return []\n\n  def _hasCycleSkipping(\n      self,\n      graph: list[list[int]],\n      doubledSubset: set[int]\n  ) -> bool:\n    \"\"\"\n    Returns True if there is a cycle in the `graph` when skipping any edges\n    whose both endpoints are in `doubledSubset`.\n    \"\"\"\n    states = [State.INIT] * len(graph)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if u not in doubledSubset:\n        for v in graph[u]:\n          if v in doubledSubset:\n            continue\n          if hasCycle(v):\n            return True\n      states[u] = State.VISITED\n      return False\n\n    return any(hasCycle(i) for i in range(len(graph)))",
      "title": "3435. Frequencies of Shortest Supersequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecd81422-7b3a-4c38-a843-c359dfc80c42",
      "code": "class Solution:\n  def permute(self, n: int) -> list[list[int]]:\n    ans = []\n    used = [False] * (n + 1)\n\n    def dfs(path: list[int]) -> None:\n      if len(path) == n:\n        ans.append(path.copy())\n        return\n      for num in range(1, n + 1):\n        if used[num]:\n          continue\n        if path and path[-1] % 2 == num % 2:\n          continue\n        used[num] = True\n        path.append(num)\n        dfs(path)\n        path.pop()\n        used[num] = False\n\n    dfs([])\n    return ans",
      "title": "3437. Permutations III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6652aaeb-4a8a-466a-830d-0082a294840f",
      "code": "class Solution:\n  def findValidPair(self, s: str) -> str:\n    count = collections.Counter(s)\n    return next((a + b\n                for a, b in itertools.pairwise(s)\n                if a != b and count[a] == int(a) and count[b] == int(b)), '')",
      "title": "3438. Find Valid Pair of Adjacent Digits in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efd4979c-0e67-4e25-8578-6ec0f0bb620b",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      k: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    windowSum = sum(gaps[:k + 1])\n    ans = windowSum\n\n    for i in range(k + 1, len(gaps)):\n      windowSum += gaps[i] - gaps[i - k - 1]\n      ans = max(ans, windowSum)\n\n    return ans",
      "title": "3439. Reschedule Meetings for Maximum Free Time I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f19b0966-688d-4867-b39f-0ca36922babe",
      "code": "class Solution:\n  def maxFreeTime(\n      self,\n      eventTime: int,\n      startTime: list[int],\n      endTime: list[int]\n  ) -> int:\n    n = len(startTime)\n    gaps = ([startTime[0]] +\n            [startTime[i] - endTime[i - 1] for i in range(1, len(startTime))] +\n            [eventTime - endTime[-1]])\n    ans = 0\n    maxLeft = [gaps[0]] + [0] * n  # maxLeft[i] := max(gaps[0..i])\n    maxRight = [0] * n + [gaps[n]]  # maxRight[i] := max(gaps[i..n])\n\n    for i in range(1, n + 1):\n      maxLeft[i] = max(gaps[i], maxLeft[i - 1])\n\n    for i in range(n - 1, -1, -1):\n      maxRight[i] = max(gaps[i], maxRight[i + 1])\n\n    for i, (start, end) in enumerate(zip(startTime, endTime)):\n      currMeetingTime = end - start\n      adjacentGapsSum = gaps[i] + gaps[i + 1]\n      canMoveMeeting = currMeetingTime <= max(\n          maxLeft[i - 1] if i > 0 else 0,\n          maxRight[i + 2] if i + 2 < n + 1 else 0\n      )\n      ans = max(ans, adjacentGapsSum +\n                (currMeetingTime if canMoveMeeting else 0))\n\n    return ans",
      "title": "3440. Reschedule Meetings for Maximum Free Time II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0af8e0aa-420c-4d6a-a458-cef4e485bf7c",
      "code": "class Solution:\n\n  def minCostGoodCaption(self, caption: str) -> str:\n    n = len(caption)\n    if n < 3:\n      return ''\n\n    MAX_COST = 1_000_000_000\n    # dp[i][j][k] := the minimum cost of caption[i..n - 1], where j is the last\n    # letter used, and k is the count of consecutive letters\n    dp = [[[MAX_COST] * 3 for _ in range(26)] for _ in range(n)]\n\n    for c in range(26):\n      dp[-1][c][0] = abs(string.ascii_lowercase.index(caption[-1]) - c)\n\n    minCost = MAX_COST\n\n    for i in range(n - 2, -1, -1):\n      newMinCost = MAX_COST\n      for c in range(26):\n        changeCost = abs(string.ascii_lowercase.index(caption[i]) - c)\n        dp[i][c][0] = changeCost + minCost\n        dp[i][c][1] = changeCost + dp[i + 1][c][0]\n        dp[i][c][2] = changeCost + min(dp[i + 1][c][1], dp[i + 1][c][2])\n        newMinCost = min(newMinCost, dp[i][c][2])\n      minCost = newMinCost\n\n    # Reconstruct the string.\n    ans = []\n    cost = MAX_COST\n    letter = -1\n\n    # Find the initial best letter.\n    for c in range(25, -1, -1):\n      if dp[0][c][2] <= cost:\n        letter = c\n        cost = dp[0][c][2]\n\n    # Add the initial triplet.\n    cost -= self._appendLetter(caption, 0, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 1, chr(ord('a') + letter), ans)\n    cost -= self._appendLetter(caption, 2, chr(ord('a') + letter), ans)\n\n    # Build the rest of the string.\n    i = 3\n    while i < n:\n      nextLetter = self._getNextLetter(dp, i, cost)\n      if nextLetter < letter or min(dp[i][letter]) > cost:\n        letter = nextLetter\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 1, chr(ord('a') + letter), ans)\n        cost -= self._appendLetter(caption, i + 2, chr(ord('a') + letter), ans)\n        i += 3\n      else:\n        cost -= self._appendLetter(caption, i, chr(ord('a') + letter), ans)\n        i += 1\n\n    return ''.join(ans)\n\n  def _getNextLetter(self, dp: list[list[list[int]]], i: int, cost: int) -> int:\n    nextLetter = 26\n    for c in range(25, -1, -1):\n      if cost == dp[i][c][2]:\n        nextLetter = c\n    return nextLetter\n\n  def _appendLetter(\n      self,\n      caption: str,\n      i: int,\n      letter: str,\n      ans: list[str]\n  ) -> int:\n    ans.append(letter)\n    return abs(ord(caption[i]) - ord(letter))",
      "title": "3441. Minimum Cost Good Caption",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3fb086ce-a1b6-4716-abe6-7bcc63690482",
      "code": "class Solution:\n  def maxDifference(self, s: str) -> int:\n    count = collections.Counter(s)\n    maxOdd = max((freq for freq in count.values()\n                  if freq % 2 == 1), default=0)\n    minEven = min((freq for freq in count.values()\n                   if freq % 2 == 0), default=len(s))\n    return maxOdd - minEven",
      "title": "3442. Maximum Difference Between Even and Odd Frequency I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66b813d9-04a4-474e-a0e4-1e455fa4a87a",
      "code": "class Solution:\n  def maxDistance(self, s: str, k: int) -> int:\n    return max(self._flip(s, k, 'NE'), self._flip(s, k, 'NW'),\n               self._flip(s, k, 'SE'), self._flip(s, k, 'SW'))\n\n  def _flip(self, s: str, k: int, direction: str) -> int:\n    res = 0\n    pos = 0\n    opposite = 0\n\n    for c in s:\n      if c in direction:\n        pos += 1\n      else:\n        pos -= 1\n        opposite += 1\n      res = max(res, pos + 2 * min(k, opposite))\n\n    return res",
      "title": "3443. Maximum Manhattan Distance After K Changes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "29f45cf1-d20d-4524-a197-4eebf98e11c7",
      "code": "class Solution:\n  def minimumIncrements(self, nums: list[int], target: list[int]) -> int:\n    maxMask = 1 << len(target)\n    maskToLcm = {}\n\n    for mask in range(1, maxMask):\n      subset = [num for i, num in enumerate(target) if mask >> i & 1]\n      maskToLcm[mask] = functools.reduce(math.lcm, subset, 1)\n\n    # dp[mask] := the minimum number of increments to make each number in the\n    # subset of target have at least one number that is a multiple in `num`,\n    # where `mask` is the bitmask of the subset of target\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for num in nums:\n      # maskToCost := (mask, cost), where `mask` is the bitmask of the subset\n      # of target and `cost` is the minimum number of increments to make each\n      # number in the subset of target have at least one number that is a\n      # multiple in `num`\n      maskToCost = [\n          (mask, 0 if (remainder := num % lcm) == 0 else lcm - remainder) for mask,\n          lcm in maskToLcm.items()]\n      newDp = dp[:]\n      for prevMask in range(maxMask):\n        if dp[prevMask] == float('inf'):\n          continue\n        for mask, cost in maskToCost:\n          newMask = prevMask | mask\n          newDp[newMask] = min(newDp[newMask], dp[prevMask] + cost)\n      dp = newDp\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "3444. Minimum Increments for Target Multiples in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d7d1a73-718f-4688-b61e-048e5a5a98d8",
      "code": "class Solution:\n  def maxDifference(self, s: str, k: int) -> int:\n    ans = -math.inf\n    permutations = [(a, b) for a in '01234' for b in '01234' if a != b]\n\n    for a, b in permutations:\n      # minDiff[(parityA, parityB)] := min(a - b) of all valid windows with\n      # parityA and parityB\n      minDiff = collections.defaultdict(lambda: math.inf)\n      prefixA = [0]  # prefixA[i] := the number of 'a's in s[0..i)\n      prefixB = [0]  # prefixB[i] := the number of 'b's in s[0..i)\n\n      l = 0\n      for r, c in enumerate(s):\n        prefixA.append(prefixA[-1] + int(c == a))\n        prefixB.append(prefixB[-1] + int(c == b))\n        while (r - l + 1 >= k and  # the window size >= k\n               prefixA[l] < prefixA[-1] and  # the number of 'a's > 0\n               prefixB[l] < prefixB[-1]):  # the number of 'b's > 0\n          paritiesKey = (prefixA[l] % 2, prefixB[l] % 2)\n          minDiff[paritiesKey] = min(minDiff[paritiesKey],\n                                     prefixA[l] - prefixB[l])\n          l += 1\n        ans = max(ans, (prefixA[-1] - prefixB[-1]) -\n                  minDiff[(1 - prefixA[-1] % 2, prefixB[-1] % 2)])\n\n    return ans",
      "title": "3445. Maximum Difference Between Even and Odd Frequency II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d426d06-2599-430f-a12c-1b5048ab7237",
      "code": "class Solution:\n  def sortMatrix(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * n for _ in range(n)]\n    diag = collections.defaultdict(list)\n\n    for i, row in enumerate(grid):\n      for j, num in enumerate(row):\n        diag[i - j].append(num)\n\n    for key in diag:\n      diag[key].sort(reverse=key < 0)\n\n    for i in range(n):\n      for j in range(n):\n        ans[i][j] = diag[i - j].pop()\n\n    return ans",
      "title": "3446. Sort Matrix by Diagonals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78638062-f5ef-4b31-b446-ee4dfe6aff13",
      "code": "class Solution:\n  def assignElements(self, groups: list[int], elements: list[int]) -> list[int]:\n    ans = []\n    elementToMinIndex = {}\n\n    for i, element in enumerate(elements):\n      if element not in elementToMinIndex:\n        elementToMinIndex[element] = i\n\n    for num in groups:\n      ans.append(self._getMinIndex(num, elementToMinIndex))\n\n    return ans\n\n  def _getMinIndex(self, num: int, elementToMinIndex: dict[int, int]) -> int:\n    res = math.inf\n    i = 1\n    while i * i <= num:\n      if num % i != 0:\n        continue\n      if i in elementToMinIndex:\n        res = min(res, elementToMinIndex[i])\n      if num // i != i and (num // i) in elementToMinIndex:\n        res = min(res, elementToMinIndex[num // i])\n      i += 1\n    return -1 if res == math.inf else res",
      "title": "3447. Assign Elements to Groups with Constraints",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb2474a9-b59d-415d-97ea-9868c68b5209",
      "code": "class Solution:\n  def countSubstrings(self, s: str) -> int:\n    ans = 0\n    # dp[i][num][rem] := the number of first `i` digits of s that have a\n    # remainder of `rem` when divided by `num`\n    dp = [[[0] * 10 for _ in range(10)] for _ in range(len(s) + 1)]\n\n    for i in range(1, len(s) + 1):\n      digit = int(s[i - 1])\n      for num in range(1, 10):\n        for rem in range(num):\n          dp[i][num][(rem * 10 + digit) % num] += dp[i - 1][num][rem]\n        dp[i][num][digit % num] += 1\n      ans += dp[i][digit][0]\n\n    return ans",
      "title": "3448. Count Substrings Divisible By Last Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a99cb75c-bafc-49cb-855a-96454bbbc072",
      "code": "class Solution:\n  def maxScore(self, points: list[int], m: int) -> int:\n    def isPossible(minVal: int, m: int) -> bool:\n      \"\"\"\n      Returns True if it is possible to achieve the maximum minimum value `x`\n      with `m` number of moves.\n      \"\"\"\n      moves = 0\n      prevMoves = 0  # to track remaining moves from the previous point\n      for i, point in enumerate(points):\n        required = (minVal + point - 1) // point  # ceil(minVal / point)\n        required = max(0, required - prevMoves)\n        if required > 0:\n          moves += 2 * required - 1\n          prevMoves = required - 1\n        elif i + 1 < len(points):\n          moves += 1\n          prevMoves = 0\n        if moves > m:\n          return False\n      return True\n\n    l = 0\n    r = (m + 1) // 2 * points[0] + 1\n\n    while l < r:\n      mid = (l + r + 1) // 2\n      if isPossible(mid, m):\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "3449. Maximize the Minimum Game Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c0c25e5-8a91-478c-922a-705114d7d2a0",
      "code": "class Solution:\n  def maxStudentsOnBench(self, students: list[list[int]]) -> int:\n    benchToStudents = collections.defaultdict(set)\n    for studentId, benchId in students:\n      benchToStudents[benchId].add(studentId)\n    return max(map(len, benchToStudents.values()), default=0)",
      "title": "3450. Maximum Students on a Single Bench",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0efb447-440d-4e86-af8d-137837a0d993",
      "code": "class Solution:\n  def sumOfGoodNumbers(self, nums: list[int], k: int) -> int:\n    return sum(num for i, num in enumerate(nums)\n               if (i - k < 0 or num > nums[i - k])\n               and (i + k >= len(nums) or num > nums[i + k]))",
      "title": "3452. Sum of Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd74a0e4-a015-4f14-92bd-3327cca39bb2",
      "code": "class Solution:\n  def separateSquares(self, squares: list[list[int]]) -> float:\n    halfArea = sum((l**2 for _, _, l in squares)) / 2\n    events = sorted([(y, True, l) for _, y, l in squares] +\n                    [(y + l, False, l) for _, y, l in squares])\n    area = 0\n    width = 0\n    prevY = 0\n\n    for y, isStart, l in events:\n      areaGain = width * (y - prevY)\n      if area + areaGain >= halfArea:\n        return prevY + (halfArea - area) / width\n      area += areaGain\n      width += l if isStart else -l\n      prevY = y",
      "title": "3453. Separate Squares I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "052dcc4d-0db8-4eb6-8038-b481fb224958",
      "code": "class Solution:\n  def shortestMatchingSubstring(self, s: str, p: str) -> int:\n    n = len(s)\n    a, b, c = p.split('*')\n    lpsA = self._getLPS(a + '#' + s)[len(a) + 1:]\n    lpsB = self._getLPS(b + '#' + s)[len(b) + 1:]\n    lpsC = self._getLPS(c + '#' + s)[len(c) + 1:]\n    ans = math.inf\n\n    i = 0  # lpsA's index\n    j = 0  # lpsB's index\n    k = 0  # lpsC's index\n    while i + len(b) + len(c) < n:\n      while i < n and lpsA[i] != len(a):\n        i += 1\n      while j < n and (j < i + len(b) or lpsB[j] != len(b)):\n        j += 1\n      while k < n and (k < j + len(c) or lpsC[k] != len(c)):\n        k += 1\n      if k == n:\n        break\n      ans = min(ans, k - i + len(a))\n      i += 1\n\n    return -1 if ans == math.inf else ans\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "3455. Shortest Matching Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0ec7263-c441-41a8-8c08-a79c21294e9f",
      "code": "class Solution:\n  def hasSpecialSubstring(self, s: str, k: int) -> bool:\n    return any(len(list(group)) == k for _, group in groupby(s))",
      "title": "3456. Find Special Substring of Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77e62ac8-d3ea-49b3-932e-030ae6453ba0",
      "code": "class Solution:\n  def maxWeight(self, pizzas: list[int]) -> int:\n    eat = len(pizzas) // 4\n    odd = math.ceil(eat / 2)\n    even = eat - odd\n    pizzas.sort(reverse=True)\n    return (sum(pizzas[:odd]) +\n            sum(pizzas[odd + 1:odd + 1 + even * 2:2]))",
      "title": "3457. Eat Pizzas!",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9fd5606-1ec9-40bd-97c5-b0713aa4ed90",
      "code": "class Solution:\n  def maxSubstringLength(self, s: str, k: int) -> bool:\n    n = len(s)\n    first = [n] * 26\n    last = [-1] * 26\n    # dp[i] := the maximum disjoint special substrings for the first i letters\n    dp = [0] * (n + 1)\n    seenOrder = []\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if first[a] == n:\n        first[a] = i\n        seenOrder.append(c)\n      last[a] = i\n\n    for c in seenOrder:\n      a = ord(c) - ord('a')\n      for j in range(first[a], last[a]):\n        b = ord(s[j]) - ord('a')\n        first[a] = min(first[a], first[b])\n        last[a] = max(last[a], last[b])\n\n    for i, c in enumerate(s):\n      a = ord(c) - ord('a')\n      if last[a] != i or (first[a] == 0 and i == n - 1):\n        dp[i + 1] = dp[i]\n      else:  # Start a new special substring.\n        dp[i + 1] = max(dp[i], 1 + dp[first[a]])\n\n    return dp[n] >= k",
      "title": "3458. Select K Disjoint Special Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89840c51-9073-4e2d-a1b3-382f7696b2b7",
      "code": "class Solution:\n  def lenOfVDiagonal(self, grid: list[list[int]]) -> int:\n    DIRS = ((-1, 1), (1, 1), (1, -1), (-1, -1))\n\n    @functools.lru_cache(None)\n    def dfs(i: int, j: int, turned: bool, num: int, dir: int) -> int:\n      if i < 0 or i == len(grid) or j < 0 or j == len(grid[0]):\n        return 0\n      if grid[i][j] != num:\n        return 0\n\n      nextNum = 0 if num == 2 else 2\n      dx, dy = DIRS[dir]\n      res = 1 + dfs(i + dx, j + dy, turned, nextNum, dir)\n\n      if not turned:\n        nextDir = (dir + 1) % 4\n        nextDx, nextDy = DIRS[nextDir]\n        res = max(res, 1 + dfs(i + nextDx, j + nextDy, 1, nextNum, nextDir))\n\n      return res\n\n    return max((1 + dfs(i + dx, j + dy, 0, 2, d)\n                for i, row in enumerate(grid)\n                for j, num in enumerate(row)\n                if num == 1\n                for d, (dx, dy) in enumerate(DIRS)),\n               default=0)",
      "title": "3459. Length of Longest V-Shaped Diagonal Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b145b3e-22a2-4a7c-86cb-b60409a085b8",
      "code": "class Solution:\n  def longestCommonPrefix(self, s: str, t: str) -> int:\n    i = 0  # s's index\n    j = 0  # t's index\n    canSkip = True\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        i += 1\n        j += 1\n      elif canSkip:\n        i += 1\n        canSkip = False\n      else:\n        return j\n\n    return j",
      "title": "3460. Longest Common Prefix After at Most One Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "078a8d4e-ea2a-45f3-86d7-64cf6f507d5c",
      "code": "class Solution:\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3461. Check If Digits Are Equal in String After Operations I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "132aae47-e124-48b6-b039-20ed79f11135",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]], limits: list[int], k: int) -> int:\n    minHeap = []\n\n    for row, limit in zip(grid, limits):\n      row.sort(reverse=True)\n      for i in range(limit):\n        heapq.heappush(minHeap, row[i])\n        if len(minHeap) == k + 1:\n          heapq.heappop(minHeap)\n\n    return sum(minHeap)",
      "title": "3462. Maximum Sum With at Most K Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32e065db-7233-435a-a721-0d82e45987d4",
      "code": "class Solution:\n  # Same as 3461. Check If Digits Are Equal in String After Operations I\n  def hasSameDigits(self, s: str) -> bool:\n    n = len(s)\n    num1 = 0\n    num2 = 0\n\n    for i in range(n - 1):\n      coefficient = self._nCMOD10(n - 2, i)\n      num1 += (coefficient * (int(s[i]) - 0)) % 10\n      num1 %= 10\n      num2 += (coefficient * (int(s[i + 1]) - 0)) % 10\n      num2 %= 10\n\n    return num1 == num2\n\n  def _nCMOD10(self, n: int, k: int) -> int:\n    \"\"\"Returns (n, k) % 10.\"\"\"\n    mod2 = self._lucasTheorem(n, k, 2)\n    mod5 = self._lucasTheorem(n, k, 5)\n    lookup = [\n        [0, 6, 2, 8, 4],  # mod2 == 0\n        [5, 1, 7, 3, 9]   # mod2 == 1\n    ]\n    return lookup[mod2][mod5]\n\n  def _lucasTheorem(self, n: int, k: int, prime: int) -> int:\n    \"\"\"Returns (n, k) % prime.\"\"\"\n    res = 1\n    while n > 0 or k > 0:\n      nMod = n % prime\n      MOD = k % prime\n      res *= math.comb(nMod, MOD)\n      res %= prime\n      n //= prime\n      k //= prime\n    return res",
      "title": "3463. Check If Digits Are Equal in String After Operations II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9b038bc-f364-438e-b52b-f7d27a52975d",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Sequence:\n  startX: int\n  startY: int\n  endX: int\n  endY: int\n  length: int\n\n  def __iter__(self):\n    yield self.startX\n    yield self.startY\n    yield self.endX\n    yield self.endY\n    yield self.length\n\n\nclass Solution:\n  def maxDistance(self, side: int, points: list[list[int]], k: int) -> int:\n    ordered = self._getOrderedPoints(side, points)\n\n    def isValidDistance(m: int) -> bool:\n      \"\"\"\n      Returns True if we can select `k` points such that the minimum Manhattan\n      distance between any two consecutive chosen points is at least `m`.\n      \"\"\"\n      dq = collections.deque([Sequence(*ordered[0], *ordered[0], 1)])\n      maxLength = 1\n\n      for i in range(1, len(ordered)):\n        x, y = ordered[i]\n        startX, startY = ordered[i]\n        length = 1\n        while dq and abs(x - dq[0].endX) + abs(y - dq[0].endY) >= m:\n          if (abs(x - dq[0].startX) + abs(y - dq[0].startY) >= m\n                  and dq[0].length + 1 >= length):\n            startX = dq[0].startX\n            startY = dq[0].startY\n            length = dq[0].length + 1\n            maxLength = max(maxLength, length)\n          dq.popleft()\n        dq.append(Sequence(startX, startY, x, y, length))\n\n      return maxLength >= k\n\n    l = 0\n    r = side\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if isValidDistance(m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _getOrderedPoints(self, side: int, points: list[list[int]]) -> list[list[int]]:\n    \"\"\"\n    Returns the ordered points on the perimeter of a square of side length\n    `side`, starting from left, top, right, and bottom boundaries.\n    \"\"\"\n    left = sorted([(x, y) for x, y in points if x == 0 and y > 0])\n    top = sorted([(x, y) for x, y in points if x > 0 and y == side])\n    right = sorted([(x, y) for x, y in points if x == side and y < side],\n                   reverse=True)\n    bottom = sorted([(x, y) for x, y in points if y == 0], reverse=True)\n    return left + top + right + bottom",
      "title": "3464. Maximize the Distance Between Points on a Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7dabf199-f2a2-41ef-a09b-a2411c953be7",
      "code": "class Solution:\n  def maxCoins(self, lane1: list[int], lane2: list[int]) -> int:\n    n = len(lane1)\n    # dp[i][k] := the maximum number of coins at i-th mile with k switches\n    dp = [[-math.inf] * 3 for _ in range(n)]\n    dp[0][0] = lane1[0]\n    dp[0][1] = lane2[0]\n\n    for i in range(1, n):\n      dp[i][0] = max(0, dp[i - 1][0]) + lane1[i]\n      dp[i][1] = max(0, dp[i - 1][0], dp[i - 1][1]) + lane2[i]\n      dp[i][2] = max(dp[i - 1][1], dp[i - 1][2]) + lane1[i]\n\n    return max(map(max, dp))",
      "title": "3466. Maximum Coin Collection",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccd740e0-565f-4c0c-ae81-6538729bfd8a",
      "code": "class Solution:\n  def transformArray(self, nums: list[int]) -> list[int]:\n    return ([0] * sum(num % 2 == 0 for num in nums) +\n            [1] * sum(num % 2 == 1 for num in nums))",
      "title": "3467. Transform Array by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ae740df-9ada-43f7-bb18-554e03ed7fe6",
      "code": "class Solution:\n  def countArrays(self, original: list[int], bounds: list[list[int]]) -> int:\n    mn, mx = bounds[0]\n\n    for i in range(1, len(original)):\n      diff = original[i] - original[i - 1]\n      mn = max(mn + diff, bounds[i][0])\n      mx = min(mx + diff, bounds[i][1])\n\n    return max(0, mx - mn + 1)",
      "title": "3468. Find the Number of Copy Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b75c3f7-7dc4-4cd1-953e-e873b86d0319",
      "code": "class Solution:\n  def minCost(self, nums: list[int]) -> int:\n    n = len(nums)\n\n    @functools.lru_cache(None)\n    def dp(last: int, i: int) -> int:\n      if i == n:  # Single element left.\n        return nums[last]\n      if i == n - 1:  # Two elements left.\n        return max(nums[last], nums[i])\n      a = max(nums[i], nums[i + 1]) + dp(last, i + 2)\n      b = max(nums[last], nums[i]) + dp(i + 1, i + 2)\n      c = max(nums[last], nums[i + 1]) + dp(i, i + 2)\n      return min(a, b, c)\n\n    return dp(0, 1)",
      "title": "3469. Find Minimum Cost to Remove Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd899cd3-c68b-4c8b-916c-291c5ee3f2ce",
      "code": "class Solution:\n  def permute(self, n: int, k: int) -> list[int]:\n    ans = []\n    isLookingForEven = True\n    remainingNumbers = list(range(1, n + 1))\n\n    for turn in range(n):\n      remainingPermutations = (math.factorial((n - 1 - turn) // 2) *\n                               math.factorial((n - turn) // 2))\n      found = False\n      for index, number in enumerate(remainingNumbers):\n        if number % 2 != isLookingForEven and (turn > 0 or n % 2 == 1):\n          continue\n        if k <= remainingPermutations:\n          ans.append(remainingNumbers.pop(index))\n          isLookingForEven = ans[-1] % 2 == 0\n          found = True\n          break\n        k -= remainingPermutations\n      if not found:\n        return []\n\n    return ans",
      "title": "3470. Permutations IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "933dc106-65e8-47b7-849a-f7ce5a82ab26",
      "code": "class Solution:\n  def largestInteger(self, nums: list[int], k: int) -> int:\n    if k == len(nums):\n      return max(nums)\n    count = collections.Counter(nums)\n    if k == 1:\n      return max([num for num in nums if count[num] == 1], default=-1)\n    return max(\n        nums[0] if count[nums[0]] == 1 else -1,\n        nums[-1] if count[nums[-1]] == 1 else -1\n    )",
      "title": "3471. Find the Largest Almost Missing Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72ec2ad4-d3a8-4377-8b7b-36e710dcc959",
      "code": "class Solution:\n  # Similar to 516. Longest Palindromic Subsequence\n  def longestPalindromicSubsequence(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i][j][op] := the length of LPS(s[i..j]) with at most `op` operations\n    dp = [[[0] * (k + 1) for _ in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      for op in range(k + 1):\n        dp[i][i][op] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for op in range(k + 1):\n          if s[i] == s[j]:\n            dp[i][j][op] = 2 + dp[i + 1][j - 1][op]\n          else:\n            dp[i][j][op] = max(dp[i + 1][j][op], dp[i][j - 1][op])\n            cost = self._getCost(s[i], s[j])\n            if cost <= op:\n              dp[i][j][op] = max(dp[i][j][op], 2 + dp[i + 1][j - 1][op - cost])\n\n    return dp[0][n - 1][k]\n\n  def _getCost(self, a: str, b: str) -> int:\n    dist = abs(ord(a) - ord(b))\n    return min(dist, 26 - dist)",
      "title": "3472. Longest Palindromic Subsequence After at Most K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c18b21b2-b630-4bc3-8d38-d245cde8e286",
      "code": "class Solution:\n  def maxSum(self, nums: list[int], k: int, m: int) -> int:\n    INF = 20_000_000\n    n = len(nums)\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    # dp[i][ongoing][r] := the maximum sum of nums[i:], with `ongoing`\n    # indicating if a subarray is currently being extended (1) or not (0),\n    # and `r` segments left to choose\n    dp = [[[-INF] * (k + 1) for _ in range(2)] for _ in range(n + 1)]\n\n    # Base case: At the end of the array, if no segments are left, score is 0\n    dp[n][0][0] = dp[n][1][0] = 0\n\n    for i in range(n - 1, -1, -1):\n      for rem in range(k + 1):\n        # When no subarray is ongoing:\n        # 1. Skip nums[i]\n        dp[i][0][rem] = dp[i + 1][0][rem]\n        # 2. Start a new segment of length m (only if rem > 0 and there're enough elements)\n        if rem > 0 and i + m <= n:\n          dp[i][0][rem] = max(\n              dp[i][0][rem],\n              dp[i + m][1][rem - 1] + (prefix[i + m] - prefix[i]))\n        # When a subarray is ongoing:\n        # 1. End the current subarray (transition to state 0, same index i)\n        # 2. Extend the current subarray by picking nums[i] and move to i + 1\n        dp[i][1][rem] = max(dp[i][0][rem], dp[i + 1][1][rem] + nums[i])\n\n    return dp[0][0][k]",
      "title": "3473. Sum of K Subarrays With Length at Least M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaacb2fb-f815-4a2d-ad6b-3aaab705636a",
      "code": "class Solution:\n  def generateString(self, str1: str, str2: str) -> str:\n    n = len(str1)\n    m = len(str2)\n    sz = n + m - 1\n    ans = [None] * sz\n    modifiable = [True] * sz\n\n    # 1. Handle all 'T' positions first.\n    for i, tf in enumerate(str1):\n      if tf == 'T':\n        for j, c in enumerate(str2):\n          pos = i + j\n          if ans[pos] and ans[pos] != c:\n            return ''\n          ans[pos] = c\n          modifiable[pos] = False\n\n    # 2. Fill all remaining positions with 'a'.\n    for i in range(sz):\n      if not ans[i]:\n        ans[i] = 'a'\n\n    # 3. Handle all 'F' positions.\n    for i in range(n):\n      if str1[i] == 'F' and self._match(ans, i, str2):\n        modifiablePos = self._lastModifiablePosition(i, m, modifiable)\n        if modifiablePos == -1:\n          return ''\n        ans[modifiablePos] = 'b'\n        modifiable[modifiablePos] = False\n\n    return ''.join(ans)\n\n  def _match(self, ans: list, i: int, s: str) -> bool:\n    \"\"\"Returns True if the substring of ans starting at `i` matches `s`.\"\"\"\n    for j, c in enumerate(s):\n      if ans[i + j] != c:\n        return False\n    return True\n\n  def _lastModifiablePosition(self, i: int, m: int, modifiable: list) -> int:\n    \"\"\"\n    Finds the last modifiable position in the substring of ans starting at `i`.\n    \"\"\"\n    modifiablePos = -1\n    for j in range(m):\n      pos = i + j\n      if modifiable[pos]:\n        modifiablePos = pos\n    return modifiablePos",
      "title": "3474. Lexicographically Smallest Generated String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e571914-53ed-4701-8876-3853cef8e5d1",
      "code": "class Solution:\n  def maxProfit(self, workers: list[int], tasks: list[list[int]]) -> int:\n    totalProfit = 0\n    skillToProfits = collections.defaultdict(list)\n\n    for skill, profit in tasks:\n      skillToProfits[skill].append(profit)\n\n    for skill in skillToProfits:\n      skillToProfits[skill].sort(reverse=True)\n\n    for workerSkill in workers:\n      if workerSkill in skillToProfits and skillToProfits[workerSkill]:\n        profit = skillToProfits[workerSkill][0]\n        skillToProfits[workerSkill].pop(0)\n        totalProfit += profit\n\n    return totalProfit + max(max(profits, default=0)\n                             for profits in skillToProfits.values())",
      "title": "3476. Maximize Profit from Task Assignment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32a87ef6-72c4-4ae7-8108-294e60713774",
      "code": "class Solution:\n  def findMaxSum(self, nums1: list[int], nums2: list[int], k: int) -> list[int]:\n    ans = [0] * len(nums1)\n    numAndIndexes = sorted([(num, i) for i, num in enumerate(nums1)])\n    minHeap = []\n\n    firstIndex = numAndIndexes[0][1]\n    heapq.heappush(minHeap, nums2[firstIndex])\n    summ = nums2[firstIndex]\n\n    for (prevNum, prevIndex), (currNum, currIndex) in itertools.pairwise(numAndIndexes):\n      if currNum == prevNum:\n        ans[currIndex] = ans[prevIndex]\n      else:\n        ans[currIndex] = summ\n      heapq.heappush(minHeap, nums2[currIndex])\n      summ += nums2[currIndex]\n      if len(minHeap) == k + 1:\n        summ -= heapq.heappop(minHeap)\n\n    return ans",
      "title": "3478. Choose K Elements With Maximum Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3530328d-3bde-4d79-bd46-0c96a8c5e3e0",
      "code": "class Solution:\n  def maxSubarrays(self, n: int, conflictingPairs: list[list[int]]) -> int:\n    validSubarrays = 0\n    maxLeft = 0\n    secondMaxLeft = 0\n    # gains[i] := the number of additional valid subarrays we can gain if the\n    # restriction at index `i` is removed\n    gains = [0] * (n + 1)\n    # conflicts[r] := left endpoints that conflict with subarrays ending in r\n    conflicts = [[] for _ in range(n + 1)]\n\n    for a, b in conflictingPairs:\n      conflicts[max(a, b)].append(min(a, b))\n\n    for right in range(1, n + 1):\n      for left in conflicts[right]:\n        if left > maxLeft:\n          secondMaxLeft = maxLeft\n          maxLeft = left\n        elif left > secondMaxLeft:\n          secondMaxLeft = left\n      # Subarrays [maxLeft + 1..right],\n      #           [maxLeft + 2..right],\n      #           ...\n      #           [right..right] are valid.\n      validSubarrays += right - maxLeft\n      # If we remove `maxLeft` (the most restrictive conflict), we gain\n      # `maxLeft - secondMaxLeft` new subarrays:\n      # [secondMaxLeft + 1..right],\n      # [secondMaxLeft + 2..right],\n      # ...\n      # [maxLeft..right].\n      gains[maxLeft] += maxLeft - secondMaxLeft\n\n    return validSubarrays + max(gains)",
      "title": "3480. Maximize Subarrays After Removing One Conflicting Pair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e020d02-aad9-456b-9e8c-9756d5032746",
      "code": "class Solution:\n  def applySubstitutions(self, replacements: list[list[str]], text: str) -> str:\n    replaceMap = {key: value for key, value in replacements}\n\n    def evaluate(text: str) -> str:\n      \"\"\"\n      Evaluates the text and replaces the placeholders with the values\n      from the replace_map recursively.\n      \"\"\"\n      res = []\n      i = 0\n      while i < len(text):\n        if text[i] == '%':\n          j = i + 1 + text[i + 1:].find('%')\n          key = text[i + 1:j]\n          value = replaceMap[key]\n          res.append(evaluate(value))\n          i = j + 1\n        else:\n          res.append(text[i])\n          i += 1\n      return ''.join(res)\n\n    return evaluate(text)",
      "title": "3481. Apply Substitutions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22eebfdd-0f55-480f-b0d9-9926591bd097",
      "code": "class Solution:\n  def totalNumbers(self, digits: list[int]) -> int:\n    nums = set()\n\n    for a, b, c in itertools.permutations(digits, 3):\n      if a != 0 and c % 2 == 0:\n        nums.add(a * 100 + b * 10 + c)\n\n    return len(nums)",
      "title": "3483. Unique 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a36415a-f96b-4fc6-8fe2-8696ecfed21a",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self, k: int):\n    self.k = k\n    self.root = TrieNode()\n    self.prefixLengthsCount = collections.Counter()\n    self.prefixLengths = SortedList()\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children.setdefault(c, TrieNode())\n      node.count += 1\n      if node.count >= self.k:\n        self.prefixLengthsCount[sz] += 1\n        if self.prefixLengthsCount[sz] == 1:\n          self.prefixLengths.add(-sz)\n\n  def erase(self, word: str) -> None:\n    node = self.root\n    for i, c in enumerate(word):\n      sz = i + 1\n      node = node.children[c]\n      if node.count == self.k:\n        self.prefixLengthsCount[sz] -= 1\n        if self.prefixLengthsCount[sz] == 0:\n          self.prefixLengths.remove(-sz)\n      node.count -= 1\n\n  def getLongestCommonPrefix(self) -> int:\n    return 0 if not self.prefixLengths else -self.prefixLengths[0]\n\n\nclass Solution:\n  def longestCommonPrefix(self, words: list[str], k: int) -> list[int]:\n    ans = []\n    trie = Trie(k)\n\n    for word in words:\n      trie.insert(word)\n\n    for word in words:\n      trie.erase(word)\n      ans.append(trie.getLongestCommonPrefix())\n      trie.insert(word)\n\n    return ans",
      "title": "3485. Longest Common Prefix of K Strings After Removal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6f93e0b-e75d-4730-8d20-816f83cebeaa",
      "code": "class Solution:\n  # Similar to 3425. Longest Special Path\n  def longestSpecialPath(\n      self,\n      edges: list[list[int]],\n      nums: list[int]\n  ) -> list[int]:\n    maxLength = 0\n    minNodes = 1\n    graph = [[] for _ in range(len(nums))]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    prefix = [0]\n    lastSeenDepth = {}\n\n    def dfs(\n        u: int,\n        prev: int,\n        leftBoundary: list[int],\n    ) -> None:\n      nonlocal maxLength, minNodes\n      prevDepth = lastSeenDepth.get(nums[u], 0)\n      lastSeenDepth[nums[u]] = len(prefix)\n\n      if prevDepth != 0:\n        leftBoundary = sorted(leftBoundary + [prevDepth])[-2:]\n\n      length = prefix[-1] - prefix[leftBoundary[0]]\n      nodes = len(prefix) - leftBoundary[0]\n      if length > maxLength or (length == maxLength and nodes < minNodes):\n        maxLength = length\n        minNodes = nodes\n\n      for v, w in graph[u]:\n        if v == prev:\n          continue\n        prefix.append(prefix[-1] + w)\n        dfs(v, u, leftBoundary)\n        prefix.pop()\n\n      lastSeenDepth[nums[u]] = prevDepth\n\n    dfs(0, -1, leftBoundary=[0, 0])\n    return [maxLength, minNodes]",
      "title": "3486. Longest Special Path II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51732846-a878-464a-b31c-2afa3fef2708",
      "code": "class Solution:\n  def maxSum(self, nums: list[int]) -> int:\n    mx = max(nums)\n    if mx <= 0:\n      return mx\n    return sum(max(0, num) for num in set(nums))",
      "title": "3487. Maximum Unique Subarray Sum After Deletion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22bc313f-516b-4f7c-b08c-420180e68c5b",
      "code": "class Solution:\n  def solveQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    n = len(nums)\n    # minDist[i] := the minimum distance between nums[i], and any other index j\n    # in the circular array, where nums[j] == nums[i]\n    minDist = [n] * n\n    lastSeen = {}\n\n    for i in range(n * 2):\n      index = i % n\n      num = nums[index]\n      if num in lastSeen:\n        prevIndex = lastSeen[num] % n\n        d = i - prevIndex\n        minDist[index] = min(minDist[index], d)\n        minDist[prevIndex] = min(minDist[prevIndex], d)\n      lastSeen[num] = i\n\n    return [-1 if minDist[query] == n\n            else minDist[query]\n            for query in queries]",
      "title": "3488. Closest Equal Element Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98cb930a-3894-41dc-9ddb-7528dca7ad0b",
      "code": "class Solution:\n  def minZeroArray(self, nums: list[int], queries: list[list[int]]) -> int:\n    if all(num == 0 for num in nums):\n      return 0\n\n    n = len(nums)\n    subsetSums = [{0} for _ in range(n)]\n\n    for k, (l, r, val) in enumerate(queries):\n      for i in range(l, r + 1):\n        newSums = {subsetSum + val for subsetSum in subsetSums[i]}\n        subsetSums[i].update(newSums)\n      if all(nums[i] in subsetSums[i] for i in range(n)):\n        return k + 1\n\n    return -1",
      "title": "3489. Zero Array Transformation IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aff7b9bf-532f-4ba8-8f5b-6aec9d590ca2",
      "code": "class Solution:\n  def beautifulNumbers(self, l: int, r: int) -> int:\n    @functools.lru_cache(None)\n    def dp(\n        s: str,\n        i: int,\n        tight: bool,\n        isLeadingZero: bool,\n        hasZero: bool,\n        sum: int,\n        prod: int,\n    ) -> int:\n      if i == len(s):\n        if isLeadingZero:\n          return 0\n        return 1 if hasZero or prod % sum == 0 else 0\n      if not isLeadingZero and hasZero and not tight:\n        return 10 ** (len(s) - i)\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        nextTight = tight and (d == maxDigit)\n        nextIsLeadingZero = isLeadingZero and d == 0\n        nextHasZero = not nextIsLeadingZero and d == 0\n        nextProd = 1 if nextIsLeadingZero else prod * d\n        res += dp(s, i + 1, nextTight, nextIsLeadingZero,\n                  nextHasZero, sum + d, nextProd)\n\n      return res\n\n    return (dp(str(r), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1) -\n            dp(str(l - 1), 0, tight=True, isLeadingZero=True, hasZero=False, sum=0, prod=1))",
      "title": "3490. Count Beautiful Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2cf0b4f-ab66-4d66-8f70-238970617490",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.isWord = False\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, number: str) -> None:\n    node: TrieNode = self.root\n    for d in number:\n      node = node.children.setdefault(d, TrieNode())\n    node.isWord = True\n\n  def search(self, number: str) -> bool:\n    \"\"\"\n    Returns True if the number is a prefix of any number in the trie or any\n    number in the trie is a prefix of the number.\n    \"\"\"\n    node: TrieNode = self.root\n    for d in number:\n      if d not in node.children:\n        return False\n      node = node.children[d]\n      if node.isWord:\n        return True\n    return True  # The number is a prefix of some number in the trie.\n\n\nclass Solution:\n  def phonePrefix(self, numbers: list[str]) -> bool:\n    trie = Trie()\n\n    for number in numbers:\n      if trie.search(number):\n        return False\n      trie.insert(number)\n\n    return True",
      "title": "3491. Phone Number Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "015d1790-dd6e-4c96-b812-df85293e1ebc",
      "code": "class Solution:\n  def maxContainers(self, n: int, w: int, maxWeight: int) -> int:\n    return min(n * n, maxWeight // w)",
      "title": "3492. Maximum Containers on a Ship",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4c6cf0a-4677-4591-ac9d-3aaa2209fe7e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n\n  def getCount(self) -> int:\n    return self.count\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def numberOfComponents(self, properties: list[list[int]], k: int) -> int:\n    n = len(properties)\n    uf = UnionFind(n)\n    propertySets = [set(property) for property in properties]\n\n    for i, j in itertools.combinations(range(n), 2):\n      if len(propertySets[i] & propertySets[j]) >= k:\n        uf.unionByRank(i, j)\n\n    return uf.getCount()",
      "title": "3493. Properties Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53871ff9-3869-4037-8eb9-ada0c5d0554d",
      "code": "class Solution:\n  def minTime(self, skill: list[int], mana: list[int]) -> int:\n    sumSkill = sum(skill)\n    prevWizardDone = sumSkill * mana[0]\n\n    for j in range(1, len(mana)):\n      prevPotionDone = prevWizardDone\n      for i in range(len(skill) - 2, -1, -1):\n        # start time for wizard i brewing potion j\n        # = max(end time for wizard i brewing potion j - 1,\n        #       the earliest start time for wizard i + 1 brewing potion j\n        #       (coming from previous iteration)\n        #       - time for wizard i brewing potion j)\n        prevPotionDone -= skill[i + 1] * mana[j - 1]\n        prevWizardDone = max(prevPotionDone,\n                             prevWizardDone - skill[i] * mana[j])\n      prevWizardDone += sumSkill * mana[j]\n\n    return prevWizardDone",
      "title": "3494. Find the Minimum Amount of Time to Brew Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f67428b6-fd20-4e38-a721-07814c06271e",
      "code": "class Solution:\n  def minOperations(self, queries: list[list[int]]) -> int:\n    return sum((self._getOperations(r) - self._getOperations(l - 1) + 1) // 2\n               for l, r in queries)\n\n  def _getOperations(self, n: int) -> int:\n    \"\"\"Returns the number of operations required for [1, n].\"\"\"\n    res = 0\n    ops = 0\n    powerOfFour = 1\n    while powerOfFour <= n:\n      l = powerOfFour\n      r = min(n, powerOfFour * 4 - 1)\n      ops += 1\n      res += (r - l + 1) * ops\n      powerOfFour *= 4\n    return res",
      "title": "3495. Minimum Operations to Make Array Elements Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53dc3a9c-5eea-4c88-9dbd-32433c49fa01",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    summ = sum(nums)\n    if len(nums) % 2 == 1:\n      return summ - min(nums)\n    return summ - min(a + b for a, b in itertools.pairwise(nums))",
      "title": "3496. Maximize Score After Pair Deletions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b82170da-15b1-42e0-8235-48017e35616e",
      "code": "class Solution:\n  def reverseDegree(self, s: str) -> int:\n    return sum((26 - (ord(c) - ord('a'))) * (i + 1)\n               for i, c in enumerate(s))",
      "title": "3498. Reverse Degree of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a3d3cdc-1bd1-4c39-a1da-79859c04f114",
      "code": "class Solution:\n  def maxActiveSectionsAfterTrade(self, s: str) -> int:\n    zeroGroups = [len(list(g)) for c, g in itertools.groupby(s) if c == '0']\n    return s.count('1') + max(map(sum, pairwise(zeroGroups)), default=0)",
      "title": "3499. Maximize Active Section with Trade I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ed37e59e-1f75-4233-b646-8daeb328aaf4",
      "code": "class Solution:\n  def minimumCost(self, nums: list[int], cost: list[int], k: int) -> int:\n    n = len(nums)\n    prefixNums = list(itertools.accumulate(nums, initial=0))\n    prefixCost = list(itertools.accumulate(cost, initial=0))\n    # dp[i] := the minimum cost to divide nums[i..n - 1] into subarrays\n    dp = [math.inf] * n + [0]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i],\n                    prefixNums[j + 1] * (prefixCost[j + 1] - prefixCost[i]) +\n                    k * (prefixCost[n] - prefixCost[i]) + dp[j + 1])\n\n    return dp[0]",
      "title": "3500. Minimum Cost to Divide Array Into Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "681fc873-196c-40af-8eb4-67e55afa4019",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Group:\n  start: int\n  length: int\n\n\nclass SparseTable:\n  def __init__(self, nums: list[int]):\n    self.n = len(nums)\n    # st[i][j] := max(nums[j..j + 2^i - 1])\n    self.st = [[0] * (self.n + 1) for _ in range(self.n.bit_length() + 1)]\n    self.st[0] = nums.copy()\n    for i in range(1, self.n.bit_length() + 1):\n      for j in range(self.n - (1 << i) + 1):\n        self.st[i][j] = max(\n            self.st[i - 1][j],\n            self.st[i - 1][j + (1 << (i - 1))])\n\n  def query(self, l: int, r: int) -> int:\n    \"\"\"Returns max(nums[l..r]).\"\"\"\n    i = (r - l + 1).bit_length() - 1\n    return max(self.st[i][l], self.st[i][r - (1 << i) + 1])\n\n\nclass Solution:\n  def maxActiveSectionsAfterTrade(\n      self,\n      s: str,\n      queries: list[list[int]]\n  ) -> list[int]:\n    ones = s.count('1')\n    zeroGroups, zeroGroupIndex = self._getZeroGroups(s)\n    if not zeroGroups:\n      return [ones] * len(queries)\n\n    st = SparseTable(self._getZeroMergeLengths(zeroGroups))\n\n    def getMaxActiveSections(l: int, r: int) -> int:\n      left = (-1 if zeroGroupIndex[l] == -1\n              else (zeroGroups[zeroGroupIndex[l]].length -\n                    (l - zeroGroups[zeroGroupIndex[l]].start)))\n      right = (-1 if zeroGroupIndex[r] == -1\n               else (r - zeroGroups[zeroGroupIndex[r]].start + 1))\n      startAdjacentGroupIndex, endAdjacentGroupIndex = self._mapToAdjacentGroupIndices(\n          zeroGroupIndex[l] + 1, zeroGroupIndex[r] if s[r] == '1' else zeroGroupIndex[r] - 1)\n      activeSections = ones\n      if (s[l] == '0' and s[r] == '0' and\n              zeroGroupIndex[l] + 1 == zeroGroupIndex[r]):\n        activeSections = max(activeSections, ones + left + right)\n      elif startAdjacentGroupIndex <= endAdjacentGroupIndex:\n        activeSections = max(\n            activeSections,\n            ones + st.query(startAdjacentGroupIndex, endAdjacentGroupIndex))\n      if (s[l] == '0' and\n          zeroGroupIndex[l] + 1 <= (zeroGroupIndex[r]\n                                    if s[r] == '1' else zeroGroupIndex[r] - 1)):\n        activeSections = max(activeSections, ones + left +\n                             zeroGroups[zeroGroupIndex[l] + 1].length)\n      if (s[r] == '0' and zeroGroupIndex[l] < zeroGroupIndex[r] - 1):\n        activeSections = max(activeSections, ones + right +\n                             zeroGroups[zeroGroupIndex[r] - 1].length)\n      return activeSections\n\n    return [getMaxActiveSections(l, r) for l, r in queries]\n\n  def _getZeroGroups(self, s: str) -> tuple[list[Group], list[int]]:\n    \"\"\"\n    Returns the zero groups and the index of the zero group that contains the\n    i-th character.\n    \"\"\"\n    zeroGroups = []\n    zeroGroupIndex = []\n    for i in range(len(s)):\n      if s[i] == '0':\n        if i > 0 and s[i - 1] == '0':\n          zeroGroups[-1].length += 1\n        else:\n          zeroGroups.append(Group(i, 1))\n      zeroGroupIndex.append(len(zeroGroups) - 1)\n    return zeroGroups, zeroGroupIndex\n\n  def _getZeroMergeLengths(self, zeroGroups: list[Group]) -> list[int]:\n    \"\"\"Returns the sums of the lengths of the adjacent groups.\"\"\"\n    return [a.length + b.length for a, b in itertools.pairwise(zeroGroups)]\n\n  def _mapToAdjacentGroupIndices(\n      self,\n      startGroupIndex: int,\n      endGroupIndex: int\n  ) -> tuple[int, int]:\n    \"\"\"\n    Returns the indices of the adjacent groups that contain l and r completely.\n\n    e.g.    groupIndices = [0, 1, 2, 3]\n    adjacentGroupIndices = [0 (0, 1), 1 (1, 2), 2 (2, 3)]\n    map(startGroupIndex = 1, endGroupIndex = 3) -> (1, 2)\n    \"\"\"\n    return startGroupIndex, endGroupIndex - 1",
      "title": "3501. Maximize Active Section with Trade II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32c4c9be-a7fd-4268-82ec-e4038b48630a",
      "code": "class Solution:\n  def minCosts(self, cost: list[int]) -> list[int]:\n    return list(itertools.accumulate(cost, min))",
      "title": "3502. Minimum Cost to Reach Every Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "691cb691-d0f3-44be-9445-8b535f346a1f",
      "code": "class Solution:\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3503. Longest Palindrome After Substring Concatenation I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9174d57e-83ab-4dbb-bef9-157b8d02bed5",
      "code": "class Solution:\n  # 3503. Longest Palindrome After Substring Concatenation I\n  def longestPalindrome(self, s: str, t: str) -> int:\n    m = len(s)\n    n = len(t)\n    suffix = self._getPalindromeLengths(s, True)\n    prefix = self._getPalindromeLengths(t, False)\n    ans = max(max(suffix), max(prefix))\n    # dp[i][j] := the longest length of palindrome starting in s[i] and ending\n    # in t[j]\n    dp = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n - 1, -1, -1):\n        if s[i] == t[j]:\n          dp[i][j] = 2 + (dp[i - 1][j + 1] if i > 0 and j < n - 1 else 0)\n          extend = max(suffix[i + 1] if i + 1 < m else 0,\n                       prefix[j - 1] if j > 0 else 0)\n          ans = max(ans, dp[i][j] + extend)\n\n    return ans\n\n  def _getPalindromeLengths(self, s: str, isSuffix: bool) -> list[int]:\n    n = len(s)\n    # dp[i][j] := True if s[i..j] is a palindrome\n    dp = [[False] * n for _ in range(n)]\n    # lengths[i] := length of longest palindrome in s[i..n - 1]\n    lengths = [0] * n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        if s[i] == s[j] and (j - i < 2 or dp[i + 1][j - 1]):\n          dp[i][j] = True\n          index = i if isSuffix else j\n          lengths[index] = max(lengths[index], j - i + 1)\n    return lengths",
      "title": "3504. Longest Palindrome After Substring Concatenation II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ad69c2b-50d5-48c7-8b98-d6dbb3730972",
      "code": "class Solution:\n  def minEliminationTime(self, timeReq: list[int], splitTime: int) -> int:\n    minHeap = timeReq.copy()\n    heapq.heapify(minHeap)\n    heapq.heappop(minHeap)\n\n    while True:\n      bacterial = splitTime + heapq.heappop(minHeap)\n      if not minHeap:\n        return bacterial\n      heapq.heappushpop(minHeap, bacterial)",
      "title": "3506. Find Time Required to Eliminate Bacterial Strains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67691476-3977-47fb-89fe-546c3d9ae162",
      "code": "class Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    ans = 0\n\n    while any(x > y for x, y in itertools.pairwise(nums)):\n      pairSums = [x + y for x, y in itertools.pairwise(nums)]\n      minPairSum = min(pairSums)\n      minPairIndex = pairSums.index(minPairSum)\n      nums[minPairIndex] = minPairSum\n      nums.pop(minPairIndex + 1)\n      ans += 1\n\n    return ans",
      "title": "3507. Minimum Pair Removal to Sort Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10c03390-1fe3-4d29-9873-e47bb99e3f75",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  FIRST = 0  # first element - add to sum and start product\n  SUBTRACT = 1  # second element - subtract from sum and multiply product\n  ADD = 2  # third element - add to sum and multiply product\n\n\nclass Solution:\n  def maxProduct(self, nums: list[int], k: int, limit: int) -> int:\n    MIN = -5000\n    if abs(k) > sum(nums):\n      return -1\n\n    @functools.lru_cache(None)\n    def dp(i: int, product: int, state: State, k: int) -> int:\n      if i == len(nums):\n        return (product if k == 0 and state != State.FIRST and product <= limit\n                else MIN)\n      res = dp(i + 1, product, state, k)\n      if state == State.FIRST:\n        res = max(res, dp(i + 1, nums[i], State.SUBTRACT, k - nums[i]))\n      if state == State.SUBTRACT:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.ADD, k + nums[i]))\n      if state == State.ADD:\n        res = max(res, dp(i + 1, min(product * nums[i], limit + 1),\n                          State.SUBTRACT, k - nums[i]))\n      return res\n\n    ans = dp(0, 1, State.FIRST, k)\n    return -1 if ans == MIN else ans",
      "title": "3509. Maximum Product of Subsequences With an Alternating Sum Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "274057a4-d813-4fbf-8bb2-153f16f6701d",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def minimumPairRemoval(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    inversionsCount = sum(nums[i + 1] < nums[i] for i in range(n - 1))\n    nextIndices = [i + 1 for i in range(n)]\n    prevIndices = [i - 1 for i in range(n)]\n    pairSums = SortedList((a + b, i)\n                          for i, (a, b) in enumerate(itertools.pairwise(nums)))\n\n    while inversionsCount > 0:\n      ans += 1\n      smallestPair = pairSums.pop(0)\n      pairSum, currIndex = smallestPair\n      nextIndex = nextIndices[currIndex]\n      prevIndex = prevIndices[currIndex]\n\n      if prevIndex >= 0:\n        oldPairSum = nums[prevIndex] + nums[currIndex]\n        newPairSum = nums[prevIndex] + pairSum\n        pairSums.remove((oldPairSum, prevIndex))\n        pairSums.add((newPairSum, prevIndex))\n        if nums[prevIndex] > nums[currIndex]:\n          inversionsCount -= 1\n        if nums[prevIndex] > pairSum:\n          inversionsCount += 1\n\n      if nums[nextIndex] < nums[currIndex]:\n        inversionsCount -= 1\n\n      nextNextIndex = nextIndices[nextIndex] if nextIndex < n else n\n      if nextNextIndex < n:\n        oldPairSum = nums[nextIndex] + nums[nextNextIndex]\n        newPairSum = pairSum + nums[nextNextIndex]\n        pairSums.remove((oldPairSum, nextIndex))\n        pairSums.add((newPairSum, currIndex))\n        if nums[nextNextIndex] < nums[nextIndex]:\n          inversionsCount -= 1\n        if nums[nextNextIndex] < pairSum:\n          inversionsCount += 1\n        prevIndices[nextNextIndex] = currIndex\n\n      nextIndices[currIndex] = nextNextIndex\n      nums[currIndex] = pairSum\n\n    return ans",
      "title": "3510. Minimum Pair Removal to Sort Array II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5678206-85d8-4125-997a-4f1996d23ea3",
      "code": "class Solution:\n  def makeArrayPositive(self, nums: list[int]) -> int:\n    MAX = 10**18\n    ans = 0\n    minSum = nums[0] + nums[1]\n\n    for i in range(2, len(nums)):\n      a, b, c = nums[i - 2], nums[i - 1], nums[i]\n      minSum = min(minSum + c, a + b + c)\n      if minSum <= 0:\n        nums[i] = MAX\n        minSum = MAX\n        ans += 1\n\n    return ans",
      "title": "3511. Make a Positive Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9132f77d-4304-4722-9be1-c5a68052a3a4",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], k: int) -> int:\n    return sum(nums) % k",
      "title": "3512. Minimum Operations to Make Array Sum Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c77fa774-d995-4113-a519-d7ce447f3c6a",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 3:\n      return n\n    return 1 << (int(math.log2(n)) + 1)",
      "title": "3513. Number of Unique XOR Triplets I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79204f50-ca27-4036-983c-d063ed91be09",
      "code": "class Solution:\n  def uniqueXorTriplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n == 1:\n      return 1\n    pairs = set(nums[i] ^ nums[j]\n                for i, j in itertools.combinations(range(n), 2))\n    return len(set(pair ^ num\n                   for pair in pairs\n                   for num in nums))",
      "title": "3514. Number of Unique XOR Triplets II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a83bc884-9e15-4fe2-9c30-91f32a4434ee",
      "code": "class Solution:\n  def findClosest(self, x: int, y: int, z: int) -> int:\n    xz = abs(x - z)\n    yz = abs(y - z)\n    if xz == yz:\n      return 0\n    return 1 if xz < yz else 2",
      "title": "3516. Find Closest Person",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccc52ac4-6236-4c51-9d9d-36e13c570f44",
      "code": "class Solution:\n  def smallestPalindrome(self, s: str) -> str:\n    n = len(s)\n    sortedHalf = sorted(s[:n // 2])\n    return ''.join(sortedHalf +\n                   ([s[n // 2]] if n % 2 else []) +\n                   sortedHalf[::-1])",
      "title": "3517. Smallest Palindromic Rearrangement I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41dd312a-7481-4745-a9de-b3ffd84e6cd5",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX = 10**6 + 1\n\n  def smallestPalindrome(self, s: str, k: int) -> str:\n    count = collections.Counter(s)\n    if not self._isPalindromePossible(count):\n      return ''\n\n    halfCount, midLetter = self._getHalfCountAndMidLetter(count)\n    totalPerm = self._calculateTotalPermutations(halfCount)\n    if k > totalPerm:\n      return ''\n    leftHalf = self._generateLeftHalf(halfCount, k)\n    return ''.join(leftHalf) + midLetter + ''.join(reversed(leftHalf))\n\n  def _isPalindromePossible(self, count: collections.Counter) -> bool:\n    oddCount = sum(1 for count in count.values() if count % 2 == 1)\n    return oddCount <= 1\n\n  def _getHalfCountAndMidLetter(self, count: collections.Counter) -> tuple[list[int], str]:\n    halfCount = [0] * 26\n    midLetter = ''\n    for c, freq in count.items():\n      halfCount[ord(c) - ord('a')] = freq // 2\n      if freq % 2 == 1:\n        midLetter = c\n    return halfCount, midLetter\n\n  def _calculateTotalPermutations(self, halfCount: list[int]) -> int:\n    \"\"\"Calculate the total number of possible permutations.\"\"\"\n    return self._countArrangements(halfCount)\n\n  def _generateLeftHalf(self, halfCount: list[int], k: int) -> list[str]:\n    \"\"\"Generate the left half of the palindrome based on k.\"\"\"\n    halfLen = sum(halfCount)\n    left = []\n    for _ in range(halfLen):\n      for i, freq in enumerate(halfCount):\n        if freq == 0:\n          continue\n        halfCount[i] -= 1\n        arrangements = self._countArrangements(halfCount)\n        if arrangements >= k:\n          left.append(chr(i + ord('a')))\n          break\n        else:\n          k -= arrangements\n          halfCount[i] += 1\n    return left\n\n  def _countArrangements(self, count: list[int]) -> int:\n    \"\"\"Calculate the number of possible arrangements of characters.\"\"\"\n    total = sum(count)\n    res = 1\n    for freq in count:\n      res *= self._nCk(total, freq)\n      if res >= self.MAX:\n        return self.MAX\n      total -= freq\n    return res\n\n  def _nCk(self, n: int, k: int) -> int:\n    res = 1\n    for i in range(1, min(k, n - k) + 1):\n      res = res * (n - i + 1) // i\n      if res >= self.MAX:\n        return self.MAX\n    return res",
      "title": "3518. Smallest Palindromic Rearrangement II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a530f626-9427-4a82-9532-19ddf5274274",
      "code": "class Solution:\n  def calculateScore(self, instructions: list[str], values: list[int]) -> int:\n    n = len(instructions)\n    ans = 0\n    i = 0\n    seen = set()\n\n    while 0 <= i < n and i not in seen:\n      seen.add(i)\n      if instructions[i] == 'add':\n        ans += values[i]\n        i += 1\n      elif instructions[i] == 'jump':\n        i += values[i]\n\n    return ans",
      "title": "3522. Calculate Score After Performing Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d46004e-41c4-48f1-9e3e-f311a7fc879b",
      "code": "class Solution:\n  def maximumPossibleSize(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n\n    for num in nums:\n      if num >= prev:\n        prev = num\n        ans += 1\n\n    return ans",
      "title": "3523. Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a738e3ea-1e47-44fc-956c-383726acff4e",
      "code": "class Solution:\n  def resultArray(self, nums: list[int], k: int) -> list[int]:\n    ans = [0] * k\n    # dp[r] := the number of subarrays ending at current position with\n    # product % k == r\n    dp = [0] * k\n\n    for num in nums:\n      newDp = [0] * k\n      numMod = num % k\n      # Start new subarray with only `num`\n      newDp[numMod] = 1\n      # Extend all previous subarrays\n      for i in range(k):\n        newMod = (i * numMod) % k\n        newDp[newMod] += dp[i]\n      # Accumulate counts into ans\n      for i in range(k):\n        ans[i] += newDp[i]\n      dp = newDp\n\n    return ans",
      "title": "3524. Find X Value of Array I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e91437df-995b-4972-b3c3-17eb214fdf0b",
      "code": "class Solution:\n  def findCommonResponse(self, responses: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for response in responses:\n      for response in set(response):\n        count[response] += 1\n\n    maxFreq = max(count.values())\n    return min([response\n                for response, count in count.items()\n                if count == maxFreq])",
      "title": "3527. Find the Most Common Response",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d40250d8-929f-4f69-9be9-d4b07e7276a8",
      "code": "class Solution:\n  def baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    n = len(conversions) + 1\n    ans = [0] * n\n    ans[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        ans[v] = (ans[u] * factor) % MOD\n        q.append(v)\n\n    return ans",
      "title": "3528. Unit Conversion I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f76532c-644f-4103-bc57-c1bf49454778",
      "code": "class Solution:\n  def countCells(self, grid: list[list[str]], pattern: str) -> int:\n    BASE = 13\n    HASH = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n\n    def markMatchedCells(flattenedGrid: str, isHorizontal: bool) -> list[list[bool]]:\n      matchMatrix = [[False] * n for _ in range(m)]\n      matchPrefix = [0] * (len(flattenedGrid) + 1)\n      pows = [1]  # pows[i] := BASE^i % HASH\n      patternHash = 0\n      runningHash = 0\n\n      for i in range(1, len(pattern)):\n        pows.append((pows[-1] * BASE) % HASH)\n\n      for c in pattern:\n        patternHash = (patternHash * BASE + (ord(c) - ord('a'))) % HASH\n\n      for i in range(len(flattenedGrid)):\n        runningHash = (\n            runningHash * BASE + (ord(flattenedGrid[i]) - ord('a'))) % HASH\n        if i >= len(pattern) - 1:\n          if runningHash == patternHash:  # Match found.\n            matchPrefix[i - len(pattern) + 1] += 1\n            matchPrefix[i + 1] -= 1\n          # Remove the contribution of the oldest letter.\n          oldestLetterHash = (\n              pows[len(pattern) - 1] *\n              (ord(flattenedGrid[i - len(pattern) + 1]) - ord('a'))) % HASH\n          runningHash = (runningHash - oldestLetterHash + HASH) % HASH\n\n      for k in range(len(flattenedGrid)):\n        if k > 0:\n          matchPrefix[k] += matchPrefix[k - 1]\n        if matchPrefix[k] > 0:\n          i = k // n if isHorizontal else k % m\n          j = k % n if isHorizontal else k // m\n          matchMatrix[i][j] = True\n\n      return matchMatrix\n\n    # Find matching positions.\n    flattenedGridRow = ''.join(cell for row in grid for cell in row)\n    flattenedGridCol = ''.join(cell for col in zip(*grid) for cell in col)\n    horizontalMatches = markMatchedCells(flattenedGridRow, True)\n    verticalMatches = markMatchedCells(flattenedGridCol, False)\n    return sum(horizontalMatches[i][j] and verticalMatches[i][j]\n               for i in range(m)\n               for j in range(n))",
      "title": "3529. Count Cells in Overlapping Horizontal and Vertical Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57317292-4edd-4c5a-8507-355718085f23",
      "code": "class Solution:\n  def maxProfit(self, n: int, edges: list[list[int]], score: list[int]) -> int:\n    # need[i] := the bitmask representing all nodes that must be placed before\n    # node i\n    need = [0] * n\n    # dp[mask] := the maximum profit achievable by placing the set of nodes\n    # represented by `mask`\n    dp = [-1] * (1 << n)\n    dp[0] = 0\n\n    for u, v in edges:\n      need[v] |= 1 << u\n\n    # Iterate over all subsets of nodes (represented by bitmask `mask`)\n    for mask in range(1 << n):\n      if dp[mask] == -1:\n        continue\n      # Determine the position of the next node to be placed (1-based).\n      pos = mask.bit_count() + 1\n      # Try to place each node `i` that hasn't been placed yet.\n      for i in range(n):\n        if mask >> i & 1:\n          continue\n        # Check if all dependencies of node `i` are already placed.\n        if (mask & need[i]) == need[i]:\n          newMask = mask | 1 << i  # Mark node `i` as placed.\n          dp[newMask] = max(dp[newMask], dp[mask] + score[i] * pos)\n\n    return dp[-1]",
      "title": "3530. Maximum Profit from Valid Topological Order in DAG",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "171d02f8-b5ef-4bb1-8028-f110eadf1ec2",
      "code": "class Solution:\n  def countCoveredBuildings(self, n: int, buildings: list[list[int]]) -> int:\n    northernmost = [math.inf] * (n + 1)\n    southernmost = [0] * (n + 1)\n    westernmost = [math.inf] * (n + 1)\n    easternmost = [0] * (n + 1)\n\n    for x, y in buildings:\n      northernmost[x] = min(northernmost[x], y)\n      southernmost[x] = max(southernmost[x], y)\n      westernmost[y] = min(westernmost[y], x)\n      easternmost[y] = max(easternmost[y], x)\n\n    return sum(northernmost[x] < y < southernmost[x]\n               and westernmost[y] < x < easternmost[y]\n               for x, y in buildings)",
      "title": "3531. Count Covered Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1f999d1-0f9e-471d-850d-b9b7d03daf79",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]]\n  ) -> list[bool]:\n    uf = UnionFind(n)\n\n    for i in range(1, n):\n      if abs(nums[i] - nums[i - 1]) <= maxDiff:\n        uf.unionByRank(i, i - 1)\n\n    return [uf.find(u) == uf.find(v)\n            for u, v in queries]",
      "title": "3532. Path Existence Queries in a Graph I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31478864-6fee-43f9-afc0-b68278221cff",
      "code": "class Solution:\n  def concatenatedDivisibility(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    nums.sort()\n    lengths = [len(str(num)) for num in nums]\n    pows = [pow(10, length, k) for length in lengths]\n\n    @functools.lru_cache(None)\n    def dp(mask: int, mod: int) -> bool:\n      \"\"\"\n      Returns True if there is a way to form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      if mask == (1 << n) - 1:\n        return mod == 0\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return True\n      return False\n\n    def reconstruct(mask: int, mod: int) -> list[int]:\n      \"\"\"\n      Reconstructs the numbers that form a number divisible by `k` using the\n      numbers in `nums`, where nums[i] is used iff `mask & (1 << i)`.\n      \"\"\"\n      for i in range(n):\n        if (mask >> i & 1) == 0:\n          newMod = (mod * pows[i] + nums[i]) % k\n          if dp(mask | 1 << i, newMod):\n            return [nums[i]] + reconstruct(mask | 1 << i, newMod)\n      return []\n\n    return reconstruct(0, 0) if dp(0, 0) else []",
      "title": "3533. Concatenated Divisibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8fa8b252-2892-424d-805e-16c43808ce31",
      "code": "class Solution:\n  def pathExistenceQueries(\n      self,\n      n: int,\n      nums: list[int],\n      maxDiff: int,\n      queries: list[list[int]],\n  ) -> list[int]:\n    sortedNumAndIndexes = sorted((num, i) for i, num in enumerate(nums))\n    sortedNums = [num for num, _ in sortedNumAndIndexes]\n    indexMap = {originalIndex: sortedIndex for sortedIndex,\n                (_, originalIndex) in enumerate(sortedNumAndIndexes)}\n    maxLevel = n.bit_length() + 1\n    # jump[i][j] is the index of the j-th ancestor of i\n    jump = [[0] * maxLevel for _ in range(n)]\n\n    right = 0\n    for i in range(n):\n      while right + 1 < n and sortedNums[right + 1] - sortedNums[i] <= maxDiff:\n        right += 1\n      jump[i][0] = right\n\n    for level in range(1, maxLevel):\n      for i in range(n):\n        prevJump = jump[i][level - 1]\n        jump[i][level] = jump[prevJump][level - 1]\n\n    def minJumps(start: int, end: int, level: int) -> int:\n      \"\"\"\n      Returns the minimum number of jumps from `start` to `end` using binary\n      lifting.\n      \"\"\"\n      if start == end:\n        return 0\n      if jump[start][0] >= end:\n        return 1\n      if jump[start][level] < end:\n        return math.inf\n      for j in range(level, -1, -1):\n        if jump[start][j] < end:\n          break\n      return (1 << j) + minJumps(jump[start][j], end, j)\n\n    def minDist(u: int, v: int) -> int:\n      uIndex = indexMap[u]\n      vIndex = indexMap[v]\n      start = min(uIndex, vIndex)\n      end = max(uIndex, vIndex)\n      res = minJumps(start, end, maxLevel - 1)\n      return res if res < math.inf else -1\n\n    return [minDist(u, v) for u, v in queries]",
      "title": "3534. Path Existence Queries in a Graph II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "130f4e4f-563d-40b0-af26-1826178604c9",
      "code": "class Solution:\n  def queryConversions(\n      self,\n      conversions: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    self.MOD = 1_000_000_007\n    units = self._baseUnitConversions(conversions)\n    # By Fermat's little theorem.\n    return [units[v] * self._modPow(units[u], self.MOD - 2) % self.MOD\n            for u, v in queries]\n\n  # Same as 3528. Unit Conversion I\n  def _baseUnitConversions(self, conversions: list[list[int]]) -> list[int]:\n    n = len(conversions) + 1\n    res = [0] * n\n    res[0] = 1\n    q = collections.deque([0])\n    graph = [[] for _ in range(n)]\n\n    for u, v, factor in conversions:\n      graph[u].append((v, factor))\n\n    while q:\n      u = q.popleft()\n      for v, factor in graph[u]:\n        res[v] = (res[u] * factor) % self.MOD\n        q.append(v)\n\n    return res\n\n  def _modPow(self, x: int, n: int) -> int:\n    if n == 0:\n      return 1\n    if n % 2 == 1:\n      return x * self._modPow(x, n - 1) % self.MOD\n    return self._modPow(x * x % self.MOD, n // 2)",
      "title": "3535. Unit Conversion II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6aade02d-5665-416b-8799-fc652e697c18",
      "code": "class Solution:\n  def maxProduct(self, n: int) -> int:\n    s = sorted(str(n))\n    return int(s[-1]) * int(s[-2])",
      "title": "3536. Maximum Product of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aef07bf-3868-4617-a2ac-8f154e6e9e2d",
      "code": "class Solution:\n  def specialGrid(self, n: int) -> list[list[int]]:\n    sz = 1 << n\n    grid = [[0] * sz for _ in range(sz)]\n    count = 0\n\n    def fill(x1: int, x2: int, y1: int, y2: int) -> None:\n      nonlocal count\n      if x2 - x1 == 1:\n        grid[x1][y1] = count\n        count += 1\n        return\n      midRow = (x1 + x2) // 2\n      midCol = (y1 + y2) // 2\n      fill(x1, midRow, midCol, y2)\n      fill(midRow, x2, midCol, y2)\n      fill(midRow, x2, y1, midCol)\n      fill(x1, midRow, y1, midCol)\n\n    fill(0, sz, 0, sz)\n    return grid",
      "title": "3537. Fill a Special Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "189134b7-7f73-443d-a17e-78e6725e4b40",
      "code": "class Solution:\n  def minTravelTime(\n      self,\n      l: int,\n      n: int,\n      k: int,\n      position: list[int],\n      time: list[int]\n  ) -> int:\n    prefix = list(itertools.accumulate(time))\n\n    @functools.lru_cache(None)\n    def dp(i: int, skips: int, last: int) -> int:\n      \"\"\"\n      Returns the minimum travel time to reach the last stop from i-th stop,\n      with `skips` skips remaining, and the last stop being `last`.\n      \"\"\"\n      if i == n - 1:\n        return 0 if skips == 0 else math.inf\n      res = math.inf\n      rate = prefix[i] - (prefix[last - 1] if last > 0 else 0)\n      end = min(n - 1, i + skips + 1)\n      for j in range(i + 1, end + 1):\n        distance = position[j] - position[i]\n        res = min(res, distance * rate + dp(j, skips - (j - i - 1), i + 1))\n      return res\n\n    return dp(0, k, 0)",
      "title": "3538. Merge Operations for Minimum Travel Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a70fa04-1506-4cd1-b9f9-028d3aa864d8",
      "code": "class Solution:\n  def magicalSum(self, m: int, k: int, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(m: int, k: int, i: int, carry: int) -> int:\n      \"\"\"\n      Returns the number of magical sequences of length `k` that can be formed\n      from the first `i` numbers in `nums` with at most `m` elements.\n      \"\"\"\n      if m < 0 or k < 0 or (m + carry.bit_count() < k):\n        return 0\n      if m == 0:\n        return int(k == carry.bit_count())\n      if i == len(nums):\n        return 0\n      res = 0\n      for count in range(m + 1):\n        contribution = math.comb(m, count) * pow(nums[i], count, MOD) % MOD\n        newCarry = carry + count\n        res += dp(m - count, k - (newCarry % 2),\n                  i + 1, newCarry // 2) * contribution\n        res %= MOD\n      return res\n\n    return dp(m, k, 0, 0)",
      "title": "3539. Find Sum of Array Product of Magical Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9bec5e6-326e-4873-8e3c-4571c1fb071a",
      "code": "class Solution:\n  def minTotalTime(\n      self,\n      forward: list[int],\n      backward: list[int],\n      queries: list[int]\n  ) -> int:\n    summ = sum(backward)\n    ans = 0\n    pos = 0\n    prefixF = [0] + list(itertools.accumulate(forward))\n    prefixB = list(itertools.accumulate(backward)) + [0]\n\n    for q in queries:\n      r = int(q < pos) * prefixF[-1] + prefixF[q] - prefixF[pos]\n      l = int(q > pos) * summ + prefixB[pos] - prefixB[q]\n      ans += min(l, r)\n      pos = q\n\n    return ans",
      "title": "3540. Minimum Time to Visit All Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "825aa23a-e785-468d-9fe5-6c0ef655a757",
      "code": "class Solution:\n  def maxFreqSum(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    count = collections.Counter(s)\n    maxVowel = max((count[c] for c in VOWELS if c in count), default=0)\n    maxConsonant = max((count[c] for c in count if c not in VOWELS), default=0)\n    return maxVowel + maxConsonant",
      "title": "3541. Find Most Frequent Vowel and Consonant",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cae96ecb-e9a8-4de4-a9a6-e8e614feb2b6",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    stack = [0]\n\n    for num in nums:\n      while stack and stack[-1] > num:\n        stack.pop()\n      if not stack or stack[-1] < num:\n        ans += 1\n        stack.append(num)\n\n    return ans",
      "title": "3542. Minimum Operations to Convert All Elements to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d3a65ea-846c-4366-a4b0-3e69cf018cfe",
      "code": "class Solution:\n  def maxWeight(self, n: int, edges: list[list[int]], k: int, t: int) -> int:\n    graph = [[] for _ in range(n)]\n    # dp[u][i] := the set of possible path sums ending at node u with i edges\n    dp = [defaultdict(set) for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n\n    for u in range(n):\n      dp[u][0].add(0)  # zero edges = sum 0\n\n    for i in range(k):\n      for u in range(n):\n        for currSum in dp[u][i]:\n          for v, w in graph[u]:\n            newSum = currSum + w\n            if newSum < t:\n              dp[v][i + 1].add(newSum)\n\n    ans = -1\n\n    for u in range(n):\n      if k in dp[u]:\n        ans = max(ans, max(dp[u][k]))\n\n    return ans",
      "title": "3543. Maximum Weighted K-Edge Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "576ee095-e540-471f-87a9-7ab59ab0275d",
      "code": "class Solution:\n  def subtreeInversionSum(\n      self,\n      edges: list[list[int]],\n      nums: list[int],\n      k: int\n  ) -> int:\n    n = len(edges) + 1\n    parent = [-1] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    @functools.lru_cache(None)\n    def dp(u: int, stepsSinceInversion: int, inverted: bool) -> int:\n      \"\"\"\n      Returns the maximum sum for subtree rooted at u, with\n      `stepsSinceInversion` steps of inversion and `inverted` is true if the\n      subtree is inverted.\n      \"\"\"\n      num = -nums[u] if inverted else nums[u]\n      negNum = -num\n      for v in graph[u]:\n        if v == parent[u]:\n          continue\n        parent[v] = u\n        num += dp(v, min(k, stepsSinceInversion + 1), inverted)\n        if stepsSinceInversion == k:\n          negNum += dp(v, 1, not inverted)\n      return max(num, negNum) if stepsSinceInversion == k else num\n\n    return dp(0, k, False)",
      "title": "3544. Subtree Inversion Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "242f4ef9-1339-4e9c-b0b2-bd6388169fb6",
      "code": "class Solution:\n  def minDeletion(self, s: str, k: int) -> int:\n    count = collections.Counter(s)\n    if len(count) <= k:\n      return 0\n    freqs = sorted(count.values())\n    return sum(freqs[:len(freqs) - k])",
      "title": "3545. Minimum Deletions for At Most K Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c48a4b78-7345-413e-a29a-e5114fe31f1e",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    totalSum = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      runningSum = 0\n      for row in grid:\n        runningSum += sum(row)\n        if runningSum * 2 == totalSum:\n          return True\n      return False\n\n    return canPartition(grid) or canPartition(zip(*grid))",
      "title": "3546. Equal Sum Grid Partition I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86b90c23-7c17-43d1-a04a-881b964ea05d",
      "code": "class Solution:\n  def maxScore(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    cycleSizes = []  # components where all nodes have degree 2\n    pathSizes = []  # components that are not cycleSizes\n    seen = set()\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      if i in seen:\n        continue\n      component = self._getComponent(graph, i, seen)\n      if all(len(graph[u]) == 2 for u in component):\n        cycleSizes.append(len(component))\n      elif len(component) > 1:\n        pathSizes.append(len(component))\n\n    for cycleSize in cycleSizes:\n      ans += self._calculateScore(n - cycleSize + 1, n, True)\n      n -= cycleSize\n\n    for pathSize in sorted(pathSizes, reverse=True):\n      ans += self._calculateScore(n - pathSize + 1, n, False)\n      n -= pathSize\n\n    return ans\n\n  def _getComponent(\n      self,\n      graph: list[list[int]],\n      start: int,\n      seen: set[int],\n  ) -> list[int]:\n    component = [start]\n    seen.add(start)\n    for u in component:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        component.append(v)\n        seen.add(v)\n    return component\n\n  def _calculateScore(self, left: int, right: int, isCycle: bool) -> int:\n    window = collections.deque([right, right])\n    score = 0\n    for value in range(right - 1, left - 1, -1):\n      windowValue = window.popleft()\n      score += windowValue * value\n      window.append(value)\n    return score + window[0] * window[1] * isCycle",
      "title": "3547. Maximum Sum of Edge Values in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2dfb7851-e2aa-46f7-9cd4-22ceb7b135be",
      "code": "class Solution:\n  def canPartitionGrid(self, grid: list[list[int]]) -> bool:\n    summ = sum(map(sum, grid))\n\n    def canPartition(grid: list[list[int]]) -> bool:\n      topSum = 0\n      seen = set()\n      for i, row in enumerate(grid):\n        topSum += sum(row)\n        botSum = summ - topSum\n        seen |= set(row)\n        if topSum - botSum in (0, grid[0][0],  grid[0][-1], row[0]):\n          return True\n        if len(grid[0]) > 1 and i > 0 and topSum - botSum in seen:\n          return True\n      return False\n\n    return (canPartition(grid) or\n            canPartition(grid[::-1]) or\n            canPartition(list(zip(*grid))[::-1]) or\n            canPartition(list(zip(*grid))))",
      "title": "3548. Equal Sum Grid Partition II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0caed308-24a4-41d7-be1e-69ee6c44977c",
      "code": "from numpy import array, round\nfrom numpy.fft import fft, ifft\n\n\nclass Solution:\n  def multiply(self, poly1: list[int], poly2: list[int]) -> list[int]:\n    n1 = len(poly1)\n    n2 = len(poly2)\n    n = n1 + n2 - 1\n    sz = 1 << (n - 1).bit_length()\n    arr1 = array(poly1 + [0] * (sz - n1))\n    arr2 = array(poly2 + [0] * (sz - n2))\n    ans = ifft(fft(arr1) * fft(arr2))\n    return round(ans).astype(int).tolist()[:n]",
      "title": "3549. Multiply Two Polynomials",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4b57c31-0805-4192-8a65-86225f251626",
      "code": "class Solution:\n  def smallestIndex(self, nums: List[int]) -> int:\n    return next((i\n                 for i, num in enumerate(nums)\n                 if self._getDigitSum(num) == i), -1)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3550. Smallest Index With Digit Sum Equal to Index",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bf6e05b-4b1d-463e-871b-709352c1d8ce",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    ans = 0\n    seen = set()\n    sortedNums = sorted(nums, key=lambda x: (self._getDigitSum(x), x))\n    numToIndex = {num: i for i, num in enumerate(sortedNums)}\n\n    for i, num in enumerate(nums):\n      if i in seen or numToIndex[num] == i:\n        continue\n      cycleSize = 0\n      j = i\n      while j not in seen:\n        seen.add(j)\n        j = numToIndex[nums[j]]\n        cycleSize += 1\n      ans += max(cycleSize - 1, 0)\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "3551. Minimum Swaps to Sort by Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c5bfc602-0c9e-4e6a-ba4c-53fe65e45cfe",
      "code": "class Solution:\n  # Similar to 3341. Find Minimum Time to Reach Last Room I\n  def minMoves(self, matrix: list[str]) -> int:\n    if matrix[-1][-1] == '#':\n      return -1\n\n    teleportPositions = [[] for _ in range(26)]\n\n    for i, row in enumerate(matrix):\n      for j, c in enumerate(row):\n        if c not in ('.', '#'):\n          teleportPositions[ord(c) - ord('A')].append((i, j))\n\n    return self._dijkstra(matrix, teleportPositions,\n                          (0, 0), (len(matrix) - 1, len(matrix[0]) - 1))\n\n  def _dijkstra(\n      self,\n      matrix: list[str],\n      teleportPositions: list[list[tuple[int, int]]],\n      src: tuple[int, int],\n      dst: tuple[int, int],\n  ) -> int:\n    DIRS = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    m = len(matrix)\n    n = len(matrix[0])\n    dist = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    dist[0][0] = 0\n    minHeap = [(dist[0][0], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return d\n      i, j = u\n      if d > dist[i][j]:\n        continue\n      c = matrix[i][j]\n      if c.isupper() and c not in seen:\n        seen.add(c)\n        for x, y in teleportPositions[ord(c) - ord('A')]:\n          if d < dist[x][y]:\n            dist[x][y] = d\n            heapq.heappush(minHeap, (d, (x, y)))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if matrix[x][y] == '#':\n          continue\n        if d + 1 < dist[x][y]:\n          dist[x][y] = d + 1\n          heapq.heappush(minHeap, (d + 1, (x, y)))\n\n    return -1",
      "title": "3552. Grid Teleportation Traversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "149ab646-cbcd-4c80-b06f-a6f25bbc5f6f",
      "code": "class Solution:\n  # Similar to 2846. Minimum Edge Weight Equilibrium Queries in a Tree\n  def minimumWeight(\n      self,\n      edges: list[list[int]],\n      queries: list[list[int]]\n  ) -> list[int]:\n    n = len(edges) + 1\n    m = math.ceil(math.log2(n))\n    graph = [[] for _ in range(n)]\n    jump = [[0] * m for _ in range(n)]  # jump[i][j] := the 2^j-th ancestor of i\n    depth = [0] * n  # depth[i] := the depth of i\n    dist = [0] * n  # dist[i] := the distance from root to i\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    self._dfs(graph, 0, -1, jump, depth, dist)\n\n    for j in range(1, m):\n      for i in range(n):\n        jump[i][j] = jump[jump[i][j - 1]][j - 1]\n\n    return [(self._distance(src1, src2, jump, depth, dist) +\n             self._distance(src1, dest, jump, depth, dist) +\n             self._distance(src2, dest, jump, depth, dist)) // 2\n            for src1, src2, dest in queries]\n\n  def _dfs(\n      self,\n      graph: list[list[tuple[int, int]]],\n      u: int,\n      prev: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> None:\n    for v, w in graph[u]:\n      if v == prev:\n        continue\n      jump[v][0] = u\n      depth[v] = depth[u] + 1\n      dist[v] = dist[u] + w\n      self._dfs(graph, v, u, jump, depth, dist)\n\n  def _getLCA(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int]\n  ) -> int:\n    \"\"\"Returns the lca(u, v) by binary jump.\"\"\"\n    # v is always deeper than u.\n    if depth[u] > depth[v]:\n      return self._getLCA(v, u, jump, depth)\n    # Jump v to the same height of u.\n    for j in range(len(jump[0])):\n      if depth[v] - depth[u] >> j & 1:\n        v = jump[v][j]\n    if u == v:\n      return u\n    # Jump u and v to the node right below the lca.\n    for j in range(len(jump[0]) - 1, -1, -1):\n      if jump[u][j] != jump[v][j]:\n        u = jump[u][j]\n        v = jump[v][j]\n    return jump[u][0]\n\n  def _distance(\n      self,\n      u: int,\n      v: int,\n      jump: list[list[int]],\n      depth: list[int],\n      dist: list[int]\n  ) -> int:\n    \"\"\"Returns the distance between u and v.\"\"\"\n    lca = self._getLCA(u, v, jump, depth)\n    return dist[u] + dist[v] - 2 * dist[lca]",
      "title": "3553. Minimum Weighted Subgraph With the Required Paths II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2a85e05-b0e8-4d3e-9c60-efd4a9dd3ebe",
      "code": "class Solution:\n  def minSubarraySort(self, nums: list[int], k):\n    ans = []\n\n    for i in range(len(nums) - k + 1):\n      window = nums[i:i+k]\n      sortedWindow = sorted(window)\n      l = 0\n      r = k - 1\n      while l < k and window[l] == sortedWindow[l]:\n        l += 1\n      while r >= 0 and window[r] == sortedWindow[r]:\n        r -= 1\n      ans.append(0 if l > r else r - l + 1)\n\n    return ans",
      "title": "3555. Smallest Subarray to Sort in Every Sliding Window",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d24ac16-870e-42f2-82f3-4690feee06fc",
      "code": "class Solution:\n  def sumOfLargestPrimes(self, s: str) -> int:\n    primes = set()\n    n = len(s)\n\n    for i in range(n):\n      for j in range(i + 1, n + 1):\n        num = int(s[i:j])\n        if num not in primes and self._isPrime(num):\n          primes.add(num)\n\n    top3 = sorted(primes, reverse=True)[:3]\n    return sum(top3)\n\n  def _isPrime(self, n: int) -> bool:\n    return n > 1 and all(n % i != 0 for i in range(2, math.isqrt(n) + 1))",
      "title": "3556. Sum of Largest Prime Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7a63c23b-09e2-4bca-99f6-3fb37dc26c8c",
      "code": "class Solution:\n  def maxSubstrings(self, word: str) -> int:\n    ans = 0\n    firstSeen = {}\n\n    for i, c in enumerate(word):\n      if c not in firstSeen:\n        firstSeen[c] = i\n      elif i - firstSeen[c] + 1 >= 4:\n        ans += 1\n        firstSeen.clear()\n\n    return ans",
      "title": "3557. Find Maximum Number of Non Intersecting Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}