{
  "snippets": [
    {
      "id": "acebb7f6-826e-4906-9f8d-111bf32a2433",
      "code": "class Solution:\n  def getDecimalValue(self, head: ListNode) -> int:\n    ans = 0\n\n    while head:\n      ans = ans * 2 + head.val\n      head = head.next\n\n    return ans",
      "title": "1290. Convert Binary Number in a Linked List to Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "649ccd82-749d-4365-bea0-8c7de4a02585",
      "code": "class Solution:\n  def sequentialDigits(self, low: int, high: int) -> list[int]:\n    ans = []\n    q = collections.deque([num for num in range(1, 10)])\n\n    while q:\n      num = q.popleft()\n      if num > high:\n        return ans\n      if low <= num and num <= high:\n        ans.append(num)\n      lastDigit = num % 10\n      if lastDigit < 9:\n        q.append(num * 10 + lastDigit + 1)\n\n    return ans",
      "title": "1291. Sequential Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a6253bc-917d-41c4-82d4-319374848d93",
      "code": "class Solution:\n  def maxSideLength(self, mat: list[list[int]], threshold: int) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def squareSum(r1: int, c1: int, r2: int, c2: int) -> int:\n      return prefix[r2 + 1][c2 + 1] - prefix[r1][c2 + 1] - prefix[r2 + 1][c1] + prefix[r1][c1]\n\n    for i in range(m):\n      for j in range(n):\n        for length in range(ans, min(m - i, n - j)):\n          if squareSum(i, j, i + length, j + length) > threshold:\n            break\n          ans = max(ans, length + 1)\n\n    return ans",
      "title": "1292. Maximum Side Length of a Square with Sum Less than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6c9475c-68ee-4b9b-9f1f-2dd8faa14099",
      "code": "class Solution:\n  def shortestPath(self, grid: list[list[int]], k: int) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    if m == 1 and n == 1:\n      return 0\n\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    q = collections.deque([(0, 0, k)])\n    seen = {(0, 0, k)}\n\n    step = 0\n    while q:\n      step += 1\n      for _ in range(len(q)):\n        i, j, eliminate = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if x == m - 1 and y == n - 1:\n            return step\n          if grid[x][y] == 1 and eliminate == 0:\n            continue\n          newEliminate = eliminate - grid[x][y]\n          if (x, y, newEliminate) in seen:\n            continue\n          q.append((x, y, newEliminate))\n          seen.add((x, y, newEliminate))\n\n    return -1",
      "title": "1293. Shortest Path in a Grid with Obstacles Elimination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20197b85-6d1b-4f8b-84ab-026831564ce7",
      "code": "class Solution:\n  def findNumbers(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      if 9 < num < 100 or 999 < num < 10000 or num == 100000:\n        ans += 1\n\n    return ans",
      "title": "1295. Find Numbers with Even Number of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a3ac15f-191a-45b5-9248-e0d2d77128d7",
      "code": "class Solution:\n  def isPossibleDivide(self, nums: list[int], k: int) -> bool:\n    count = collections.Counter(nums)\n\n    for start in sorted(count):\n      value = count[start]\n      if value > 0:\n        for i in range(start, start + k):\n          count[i] -= value\n          if count[i] < 0:\n            return False\n\n    return True",
      "title": "1296. Divide Array in Sets of K Consecutive Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e327b6ac-b537-4baf-b47b-52a5d2a16ea0",
      "code": "class Solution:\n  def maxFreq(self, s: str, maxLetters: int, minSize: int, maxSize: int) -> int:\n    # Greedily consider strings with `minSize`, so ignore `maxSize`.\n    ans = 0\n    letters = 0\n    count = collections.Counter()\n    substringCount = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] += 1\n      if count[c] == 1:\n        letters += 1\n      while letters > maxLetters or r - l + 1 > minSize:\n        count[s[l]] -= 1\n        if count[s[l]] == 0:\n          letters -= 1\n        l += 1\n      if r - l + 1 == minSize:\n        sub = s[l:l + minSize]\n        substringCount[sub] += 1\n        ans = max(ans, substringCount[sub])\n\n    return ans",
      "title": "1297. Maximum Number of Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c2bc8ad-53b7-4c27-a3be-4299e4042583",
      "code": "class Solution:\n  def maxCandies(\n      self,\n      status: list[int],\n      candies: list[int],\n      keys: list[list[int]],\n      containedBoxes: list[list[int]],\n      initialBoxes: list[int],\n  ) -> int:\n    ans = 0\n    q = collections.deque()\n    reachedClosedBoxes = [0] * len(status)\n\n    def pushBoxesIfPossible(boxes: list[int]) -> None:\n      for box in boxes:\n        if status[box]:\n          q.append(box)\n        else:\n          reachedClosedBoxes[box] = True\n\n    pushBoxesIfPossible(initialBoxes)\n\n    while q:\n      currBox = q.popleft()\n\n      # Add the candies.\n      ans += candies[currBox]\n\n      # Push `reachedClosedBoxes` by `key` obtained in this turn and change\n      # their statuses.\n      for key in keys[currBox]:\n        if not status[key] and reachedClosedBoxes[key]:\n          q.append(key)\n        status[key] = 1  # boxes[key] is now open\n\n      # Push the boxes contained in `currBox`.\n      pushBoxesIfPossible(containedBoxes[currBox])\n\n    return ans",
      "title": "1298. Maximum Candies You Can Get from Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8fb32a8-ebba-4dcd-b91c-c625a20ada89",
      "code": "class Solution:\n  def replaceElements(self, arr: list[int]) -> list[int]:\n    maxOfRight = -1\n    for i in reversed(range(len(arr))):\n      arr[i], maxOfRight = maxOfRight, max(maxOfRight, arr[i])\n    return arr",
      "title": "1299. Replace Elements with Greatest Element on Right Side",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "783d7df8-bbaf-4043-a7fa-89f5dcefc4d4",
      "code": "class Solution:\n  def findBestValue(self, arr: list[int], target: int) -> int:\n    prefix = 0\n\n    arr.sort()\n\n    for i, a in enumerate(arr):\n      ans = round((target - prefix) / (len(arr) - i))\n      if ans <= a:\n        return ans\n      prefix += a\n\n    return arr[-1]",
      "title": "1300. Sum of Mutated Array Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dace485a-30f5-4378-bb7e-1cd27e29b35a",
      "code": "class Solution:\n  def pathsWithMaxScore(self, board: list[str]) -> list[int]:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (1, 1))\n    n = len(board)\n    # dp[i][j] := the maximum sum from (n - 1, n - 1) to (i, j)\n    dp = [[-1] * (n + 1) for _ in range(n + 1)]\n    # count[i][j] := the number of paths to get dp[i][j] from (n - 1, n - 1) to\n    # (i, j)\n    count = [[0] * (n + 1) for _ in range(n + 1)]\n\n    dp[0][0] = 0\n    dp[n - 1][n - 1] = 0\n    count[n - 1][n - 1] = 1\n\n    for i in reversed(range(n)):\n      for j in reversed(range(n)):\n        if board[i][j] == 'S' or board[i][j] == 'X':\n          continue\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if dp[i][j] < dp[x][y]:\n            dp[i][j] = dp[x][y]\n            count[i][j] = count[x][y]\n          elif dp[i][j] == dp[x][y]:\n            count[i][j] += count[x][y]\n            count[i][j] %= MOD\n\n        # If there's path(s) from 'S' to (i, j) and the cell is not 'E'.\n        if dp[i][j] != -1 and board[i][j] != 'E':\n          dp[i][j] += int(board[i][j])\n          dp[i][j] %= MOD\n\n    return [dp[0][0], count[0][0]]",
      "title": "1301. Number of Paths with Max Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "238bc381-e8d7-431d-8aad-5131b349cf9d",
      "code": "class Solution:\n  def sumZero(self, n: int) -> list[int]:\n    return list(range(1 - n, n, 2))",
      "title": "1304. Find N Unique Integers Sum up to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71022133-1006-42fe-b255-9010c8bc4968",
      "code": "class Solution:\n  def isSolvable(self, words: list[str], result: str) -> bool:\n    words.append(result)\n    rows = len(words)\n    cols = max(map(len, words))\n    letterToDigit = {}\n    usedDigit = [False] * 10\n\n    def dfs(row: int, col: int, summ: int) -> bool:\n      if col == cols:\n        return summ == 0\n      if row == rows:\n        return summ % 10 == 0 and dfs(0, col + 1, summ // 10)\n\n      word = words[row]\n      if col >= len(word):\n        return dfs(row + 1, col, summ)\n\n      letter = word[~col]\n      sign = -1 if row == rows - 1 else 1\n\n      if letter in letterToDigit and (\n              letterToDigit[letter] > 0 or col < len(word) - 1):\n        return dfs(row + 1, col, summ + sign * letterToDigit[letter])\n\n      for digit, used in enumerate(usedDigit):\n        if not used and (digit > 0 or col < len(word) - 1):\n          letterToDigit[letter] = digit\n          usedDigit[digit] = True\n          if dfs(row + 1, col, summ + sign * digit):\n            return True\n          usedDigit[digit] = False\n          if letter in letterToDigit:\n            del letterToDigit[letter]\n\n      return False\n\n    return dfs(0, 0, 0)",
      "title": "1307. Verbal Arithmetic Puzzle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67bc1e4f-a0ff-4fbc-a478-637484a9f251",
      "code": "class Solution:\n  def freqAlphabets(self, s: str) -> str:\n    ans = ''\n    i = 0\n\n    while i < len(s):\n      if i + 2 < len(s) and s[i + 2] == '#':\n        ans += chr(int(s[i:i + 2]) + ord('a') - 1)\n        i += 3\n      else:\n        ans += chr(int(s[i]) + ord('a') - 1)\n        i += 1\n\n    return ans",
      "title": "1309. Decrypt String from Alphabet to Integer Mapping",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cab81b17-a579-403c-a921-6b7a98520ec2",
      "code": "class Solution:\n  def xorQueries(self, arr: list[int], queries: list[list[int]]) -> list[int]:\n    ans = []\n    xors = [0] * (len(arr) + 1)\n\n    for i, a in enumerate(arr):\n      xors[i + 1] = xors[i] ^ a\n\n    for left, right in queries:\n      ans.append(xors[left] ^ xors[right + 1])\n\n    return ans",
      "title": "1310. XOR Queries of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c46ba54-7f40-4346-9f52-efe976e99b5d",
      "code": "class Solution:\n  def watchedVideosByFriends(\n      self,\n      watchedVideos: list[list[str]],\n      friends: list[list[int]],\n      id: int,\n      level: int,\n  ) -> list[str]:\n    seen = [False] * 100\n    seen[id] = True\n    q = collections.deque([id])\n    count = collections.Counter()\n\n    for _ in range(level):\n      for _ in range(len(q)):\n        curr = q.popleft()\n        for friend in friends[curr]:\n          if not seen[friend]:\n            seen[friend] = True\n            q.append(friend)\n\n    for friend in q:\n      for video in watchedVideos[friend]:\n        count[video] += 1\n\n    return sorted(count, key=lambda video: (count[video], video))",
      "title": "1311. Get Watched Videos by Your Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e6775a3-0386-41a9-b837-967acba8fec4",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    return len(s) - self._longestPalindromeSubseq(s)\n\n  # Same as 516. Longest Palindromic Subsequence\n  def _longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j] := the length of LPS(s[i..j])\n    dp = [[0] * n for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i] = 1\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        if s[i] == s[j]:\n          dp[i][j] = 2 + dp[i + 1][j - 1]\n        else:\n          dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    return dp[0][n - 1]",
      "title": "1312. Minimum Insertion Steps to Make a String Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ea3f116-3e32-442e-b41b-2e9b2eb4babe",
      "code": "class Solution:\n  def decompressRLElist(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for i in range(0, len(nums), 2):\n      ans += [nums[i + 1]] * nums[i]\n\n    return ans",
      "title": "1313. Decompress Run-Length Encoded List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6ff6a20-e603-437f-a530-00e02d87d9be",
      "code": "class Solution:\n  def matrixBlockSum(self, mat: list[list[int]], k: int) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n    ans = [[0] * n for _ in range(m)]\n    prefix = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        prefix[i + 1][j + 1] = (mat[i][j] + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    for i in range(m):\n      for j in range(n):\n        r1 = max(0, i - k) + 1\n        c1 = max(0, j - k) + 1\n        r2 = min(m - 1, i + k) + 1\n        c2 = min(n - 1, j + k) + 1\n        ans[i][j] = (prefix[r2][c2] - prefix[r2][c1 - 1] -\n                     prefix[r1 - 1][c2] + prefix[r1 - 1][c1 - 1])\n\n    return ans",
      "title": "1314. Matrix Block Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4e15445-c9b4-4070-b304-3379edba2c42",
      "code": "class Solution:\n  def distinctEchoSubstrings(self, text: str) -> int:\n    seen = set()\n\n    for k in range(1, len(text) // 2 + 1):  # the target length\n      same = 0\n      l = 0\n      for r in range(k, len(text)):\n        if text[l] == text[r]:\n          same += 1\n        else:\n          same = 0\n        if same == k:\n          seen.add(text[l - k + 1:l + 1])\n          # Move the window thus leaving a letter behind, so we need to\n          # decrease the counter.\n          same -= 1\n        l += 1\n\n    return len(seen)",
      "title": "1316. Distinct Echo Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "64c958dd-63c4-482e-90e1-c5b66b0e4d25",
      "code": "class Solution:\n  def getNoZeroIntegers(self, n: int) -> list[int]:\n    for A in range(n):\n      B = n - A\n      if '0' not in str(A) and '0' not in str(B):\n        return A, B",
      "title": "1317. Convert Integer to the Sum of Two No-Zero Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ee6e984-0b45-47ce-9dd8-bc946779b343",
      "code": "class Solution:\n  def minFlips(self, a: int, b: int, c: int) -> int:\n    MAX_BIT = 30\n    ans = 0\n\n    for i in range(MAX_BIT):\n      if c >> i & 1:\n        ans += (a >> i & 1) == 0 and (b >> i & 1) == 0\n      else:  # (c >> i & 1) == 0\n        ans += (a >> i & 1) + (b >> i & 1)\n\n    return ans",
      "title": "1318. Minimum Flips to Make a OR b Equal to c",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7017cd47-e5c1-46e2-aea9-cb02601ff1db",
      "code": "class Solution:\n  def minimumDistance(self, word: str) -> int:\n    def dist(a: int, b: int) -> int:\n      if a == 26:  # the first hovering state\n        return 0\n      x1, y1 = a // 6, a % 6\n      x2, y2 = b // 6, b % 6\n      return abs(x1 - x2) + abs(y1 - y2)\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to type the `word`, where the left finger is\n      on the i-th letter, the right finger is on the j-th letter, and the\n      words[0..k) have been written.\n      \"\"\"\n      if k == len(word):\n        return 0\n      nxt = ord(word[k]) - ord('A')\n      moveLeft = dist(i, nxt) + dp(nxt, j, k + 1)\n      moveRight = dist(j, nxt) + dp(i, nxt, k + 1)\n      return min(moveLeft, moveRight)\n\n    return dp(26, 26, 0)",
      "title": "1320. Minimum Distance to Type a Word Using Two Fingers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40b93def-e4b2-4d87-bdac-a019b159d63c",
      "code": "class Solution:\n  def maximum69Number(self, num: int) -> int:\n    return int(str(num).replace('6', '9', 1))",
      "title": "1323. Maximum 69 Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "25b68c38-4e17-4e31-bd36-80686e30150d",
      "code": "class Solution:\n  def printVertically(self, s: str) -> list[str]:\n    ans = []\n    words = s.split()\n    maxLength = max(len(word) for word in words)\n\n    for i in range(maxLength):\n      row = []\n      for word in words:\n        row.append(word[i] if i < len(word) else ' ')\n      ans.append(''.join(row).rstrip())\n\n    return ans",
      "title": "1324. Print Words Vertically",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09bc07eb-a67d-4e88-b33c-a00158dd36a1",
      "code": "class Solution:\n  def removeLeafNodes(\n      self,\n      root: TreeNode | None,\n      target: int,\n  ) -> TreeNode | None:\n    if not root:\n      return None\n    root.left = self.removeLeafNodes(root.left, target)\n    root.right = self.removeLeafNodes(root.right, target)\n    return None if self._isLeaf(root) and root.val == target else root\n\n  def _isLeaf(self, root: TreeNode | None) -> bool:\n    return not root.left and not root.right",
      "title": "1325. Delete Leaves With a Given Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54638da4-0a88-434a-a2fa-4223340335ff",
      "code": "class Solution:\n  def minTaps(self, n: int, ranges: list[int]) -> int:\n    nums = [0] * (n + 1)\n\n    for i, range_ in enumerate(ranges):\n      l = max(0, i - range_)\n      r = min(n, range_ + i)\n      nums[l] = max(nums[l], r - l)\n\n    ans = 0\n    end = 0\n    farthest = 0\n\n    for i in range(n):\n      farthest = max(farthest, i + nums[i])\n      if i == end:\n        ans += 1\n        end = farthest\n\n    return ans if end == n else -1",
      "title": "1326. Minimum Number of Taps to Open to Water a Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f09ee85-fdec-4cd9-8c90-372664ddb0a7",
      "code": "class Solution:\n  def breakPalindrome(self, palindrome: str) -> str:\n    if len(palindrome) == 1:\n      return ''\n\n    ans = list(palindrome)\n\n    for i in range(len(palindrome) // 2):\n      if palindrome[i] != 'a':\n        ans[i] = 'a'\n        return ''.join(ans)\n\n    ans[-1] = 'b'\n    return ''.join(ans)",
      "title": "1328. Break a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20d07c19-f8fa-4d34-8892-04d698492807",
      "code": "class Solution:\n  def diagonalSort(self, mat: list[list[int]]) -> list[list[int]]:\n    m = len(mat)\n    n = len(mat[0])\n\n    count = collections.defaultdict(list)\n\n    for i in range(m):\n      for j in range(n):\n        count[i - j].append(mat[i][j])\n\n    for value in count.values():\n      value.sort(reverse=1)\n\n    for i in range(m):\n      for j in range(n):\n        mat[i][j] = count[i - j].pop()\n\n    return mat",
      "title": "1329. Sort the Matrix Diagonally",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d8a7acd-af65-47ab-bb0c-9c3ec9b6413e",
      "code": "class Solution:\n  def maxValueAfterReverse(self, nums: list[int]) -> int:\n    mn = math.inf\n    mx = -math.inf\n\n    for a, b in zip(nums, nums[1:]):\n      mn = min(mn, max(a, b))\n      mx = max(mx, min(a, b))\n    diff = max(0, (mx - mn) * 2)\n\n    for a, b in zip(nums, nums[1:]):\n      headDiff = -abs(a - b) + abs(nums[0] - b)\n      tailDiff = -abs(a - b) + abs(nums[-1] - a)\n      diff = max(diff, headDiff, tailDiff)\n\n    return sum(abs(a - b) for a, b in zip(nums, nums[1:])) + diff",
      "title": "1330. Reverse Subarray To Maximize Array Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b467a889-d580-4d66-8342-29a135d95571",
      "code": "class Solution:\n  def arrayRankTransform(self, arr: list[int]) -> list[int]:\n    rank = {}\n\n    for a in sorted(arr):\n      if a not in rank:\n        rank[a] = len(rank) + 1\n\n    return map(rank.get, arr)",
      "title": "1331. Rank Transform of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "92677e90-1be7-4731-a3f4-4ff0fc39d1c7",
      "code": "class Solution:\n  def removePalindromeSub(self, s: str) -> int:\n    return 1 if s == s[::-1] else 2",
      "title": "1332. Remove Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cb50de75-d053-4fb7-b5f8-3859d1542ae8",
      "code": "class Solution:\n  def filterRestaurants(\n      self,\n      restaurants: list[list[int]],\n      veganFriendly: int,\n      maxPrice: int,\n      maxDistance: int,\n  ) -> list[int]:\n    restaurants.sort(key=lambda x: (-x[1], -x[0]))\n    return [i for i, _, v, p, d in restaurants\n            if v >= veganFriendly and p <= maxPrice and d <= maxDistance]",
      "title": "1333. Filter Restaurants by Vegan-Friendly, Price and Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9db38ac-f1af-43ad-b913-44553e7f668a",
      "code": "class Solution:\n  def findTheCity(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> int:\n    ans = -1\n    minCitiesCount = n\n    dist = self._floydWarshall(n, edges, distanceThreshold)\n\n    for i in range(n):\n      citiesCount = sum(dist[i][j] <= distanceThreshold for j in range(n))\n      if citiesCount <= minCitiesCount:\n        ans = i\n        minCitiesCount = citiesCount\n\n    return ans\n\n  def _floydWarshall(\n      self,\n      n: int,\n      edges: list[list[int]],\n      distanceThreshold: int,\n  ) -> list[list[int]]:\n    dist = [[distanceThreshold + 1] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v, w in edges:\n      dist[u][v] = w\n      dist[v][u] = w\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist",
      "title": "1334. Find the City With the Smallest Number of Neighbors at a Threshold Distance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c12fde0-ffb8-445c-a5e9-dd960d9ac691",
      "code": "class Solution:\n  def minDifficulty(self, jobDifficulty: list[int], d: int) -> int:\n    n = len(jobDifficulty)\n    if d > n:\n      return -1\n\n    # dp[i][k] := the minimum difficulty to schedule the first i jobs in k days\n    dp = [[math.inf] * (d + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i in range(1, n + 1):\n      for k in range(1, d + 1):\n        maxDifficulty = 0  # max(job[j + 1..i])\n        for j in range(i - 1, k - 2, -1):  # 1-based\n          maxDifficulty = max(maxDifficulty, jobDifficulty[j])  # 0-based\n          dp[i][k] = min(dp[i][k], dp[j][k - 1] + maxDifficulty)\n\n    return dp[n][d]",
      "title": "1335. Minimum Difficulty of a Job Schedule",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3f0dfd3a-83a7-416e-b3b8-04caddd8d06f",
      "code": "class Solution:\n  def kWeakestRows(self, mat: list[list[int]], k: int) -> list[int]:\n    rowSums = [(sum(row), i) for i, row in enumerate(mat)]\n    return [i for _, i in sorted(rowSums)[:k]]",
      "title": "1337. The K Weakest Rows in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b84eb66-0b21-4bd4-b55e-dbf6b42bd0d6",
      "code": "class Solution:\n  def minSetSize(self, arr: list[int]) -> int:\n    count = collections.Counter(arr).most_common()\n    count.sort(key=lambda x: -x[1])\n\n    summ = 0\n    for i, (_, freq) in enumerate(count):\n      summ += freq\n      if summ >= len(arr) // 2:\n        return i + 1",
      "title": "1338. Reduce Array Size to The Half",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "98c8a96e-ab8f-49ad-80fc-b827559fd842",
      "code": "class Solution:\n  def maxJumps(self, arr: list[int], d: int) -> int:\n    n = len(arr)\n    # dp[i] := the maximum jumps starting from arr[i]\n    dp = [1] * n\n    # a dcreasing stack that stores indices\n    stack = []\n\n    for i in range(n + 1):\n      while stack and (i == n or arr[stack[-1]] < arr[i]):\n        indices = [stack.pop()]\n        while stack and arr[stack[-1]] == arr[indices[0]]:\n          indices.append(stack.pop())\n        for j in indices:\n          if i < n and i - j <= d:\n            # Can jump from i to j.\n            dp[i] = max(dp[i], dp[j] + 1)\n          if stack and j - stack[-1] <= d:\n            # Can jump from stack[-1] to j\n            dp[stack[-1]] = max(dp[stack[-1]], dp[j] + 1)\n      stack.append(i)\n\n    return max(dp)",
      "title": "1340. Jump Game V",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40b53038-ca18-4d4f-a6cc-8e0e5a1f969c",
      "code": "class Solution:\n  def numberOfSteps(self, num: int) -> int:\n    if num == 0:\n      return 0\n    subtractSteps = num.bit_count()\n    divideSteps = num.bit_length() - 1\n    return subtractSteps + divideSteps",
      "title": "1342. Number of Steps to Reduce a Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fea42979-4eab-4c89-8e46-3bbc7ab97009",
      "code": "class Solution:\n  def numOfSubarrays(self, arr: list[int], k: int, threshold: int) -> int:\n    ans = 0\n    windowSum = 0\n\n    for i in range(len(arr)):\n      windowSum += arr[i]\n      if i >= k:\n        windowSum -= arr[i - k]\n      if i >= k - 1 and windowSum // k >= threshold:\n        ans += 1\n\n    return ans",
      "title": "1343. Number of Sub-arrays of Size K and Average Greater than or Equal to Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee3e6917-9150-4874-8c7e-0cff9ac8fd9c",
      "code": "class Solution:\n  def angleClock(self, hour: int, minutes: int) -> float:\n    hourAngle = (hour % 12) * 30 + minutes * 0.5\n    minuteAngle = minutes * 6\n    ans = abs(hourAngle - minuteAngle)\n\n    return min(ans, 360 - ans)",
      "title": "1344. Angle Between Hands of a Clock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9f8067bd-7b96-4aa4-a683-73da0c160558",
      "code": "class Solution:\n  def minJumps(self, arr: list[int]) -> int:\n    n = len(arr)\n    # {num: indices}\n    graph = collections.defaultdict(list)\n    step = 0\n    q = collections.deque([0])\n    seen = {0}\n\n    for i, a in enumerate(arr):\n      graph[a].append(i)\n\n    while q:\n      for _ in range(len(q)):\n        i = q.popleft()\n        if i == n - 1:\n          return step\n        seen.add(i)\n        u = arr[i]\n        if i + 1 < n:\n          graph[u].append(i + 1)\n        if i - 1 >= 0:\n          graph[u].append(i - 1)\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n        graph[u].clear()\n      step += 1",
      "title": "1345. Jump Game IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "40070671-5cb5-4337-99d0-f3178ed2232f",
      "code": "class Solution:\n  def checkIfExist(self, arr: list[int]) -> bool:\n    seen = set()\n\n    for a in arr:\n      if a * 2 in seen or a % 2 == 0 and a // 2 in seen:\n        return True\n      seen.add(a)\n\n    return False",
      "title": "1346. Check If N and Its Double Exist",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f2162f0-d30a-42bf-a1a7-ed7705a154b2",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum(abs(value) for value in count.values()) // 2",
      "title": "1347. Minimum Number of Steps to Make Two Strings Anagram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37449f25-2014-462d-9a10-c9182d9213ee",
      "code": "class Solution:\n  def maxStudents(self, seats: list[list[str]]) -> int:\n    m = len(seats)\n    n = len(seats[0])\n    DIRS = ((-1, -1), (0, -1), (1, -1), (-1, 1), (0, 1), (1, 1))\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if seats[x][y] != '.' or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    def hungarian() -> int:\n      count = 0\n      for i in range(m):\n        for j in range(n):\n          if seats[i][j] == '.' and match[i][j] == -1:\n            sessionId = i * n + j\n            seen[i][j] = sessionId\n            count += dfs(i, j, sessionId)\n      return count\n\n    return sum(seats[i][j] == '.'\n               for i in range(m)\n               for j in range(n)) - hungarian()",
      "title": "1349. Maximum Students Taking Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fd04f26-e6f4-41e5-b7cb-a793cfe34d60",
      "code": "class Solution:\n  def countNegatives(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    i = m - 1\n    j = 0\n\n    while i >= 0 and j < n:\n      if grid[i][j] < 0:\n        ans += n - j\n        i -= 1\n      else:\n        j += 1\n\n    return ans",
      "title": "1351. Count Negative Numbers in a Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "110f7f2a-ac49-4043-8531-b779c3d1dd10",
      "code": "class Solution:\n  def maxEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    minHeap = []\n    i = 0  # events' index\n\n    events.sort(key=lambda x: x[0])\n\n    while minHeap or i < len(events):\n      # If no events are available to attend today, let time flies to the next\n      # available event.\n      if not minHeap:\n        d = events[i][0]\n      # All the events starting from today are newly available.\n      while i < len(events) and events[i][0] == d:\n        heapq.heappush(minHeap, events[i][1])\n        i += 1\n      # Greedily attend the event that'll end the earliest since it has higher\n      # chance can't be attended in the future.\n      heapq.heappop(minHeap)\n      ans += 1\n      d += 1\n      # Pop the events that can't be attended.\n      while minHeap and minHeap[0] < d:\n        heapq.heappop(minHeap)\n\n    return ans",
      "title": "1353. Maximum Number of Events That Can Be Attended",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57900e0a-7be3-49e6-9b37-3028433323f7",
      "code": "class Solution:\n  def isPossible(self, target: list[int]) -> bool:\n    if len(target) == 1:\n      return target[0] == 1\n\n    summ = sum(target)\n    maxHeap = [-num for num in target]\n    heapq.heapify(maxHeap)\n\n    while -maxHeap[0] > 1:\n      mx = -heapq.heappop(maxHeap)\n      restSum = summ - mx\n      # Only occurs if n == 2.\n      if restSum == 1:\n        return True\n      updated = mx % restSum\n      # updated == 0 (invalid) or didn't change.\n      if updated == 0 or updated == mx:\n        return False\n      heapq.heappush(maxHeap, -updated)\n      summ = summ - mx + updated\n\n    return True",
      "title": "1354. Construct Target Array With Multiple Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5895ece0-770f-4b4c-9c32-41a581f14ab1",
      "code": "class Solution:\n  def sortByBits(self, arr: list[int]) -> list[int]:\n    return sorted(arr, key=lambda x: (x.bit_count(), x))",
      "title": "1356. Sort Integers by The Number of 1 Bits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8270881-a687-4ca9-a6c8-962fa4b20028",
      "code": "class Solution:\n  # Similar to 3. Longest SubWithout Repeating Characters\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    # lastSeen[c] := the index of the last time c appeared\n    lastSeen = {c: -1 for c in 'abc'}\n\n    for i, c in enumerate(s):\n      lastSeen[c] = i\n      # s[0..i], s[1..i], s[min(lastSeen)..i] are satisfied strings.\n      ans += 1 + min(lastSeen.values())\n\n    return ans",
      "title": "1358. Number of Substrings Containing All Three Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a4c5219f-125f-44cd-bed5-15478c6c4471",
      "code": "class Solution:\n  def countOrders(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n\n    for i in range(1, n + 1):\n      ans = ans * i * (i * 2 - 1) % MOD\n\n    return ans",
      "title": "1359. Count All Valid Pickup and Delivery Options",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7514cf97-2ce0-4bb7-be17-0f4f0b512e75",
      "code": "class Solution:\n  def daysBetweenDates(self, date1: str, date2: str) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def isLeapYear(year: int) -> bool:\n      return year % 4 == 0 and year % 100 != 0 or year % 400 == 0\n\n    def daysFrom1971(date: str) -> int:\n      year, month, day = map(int, date.split('-'))\n      return (365 * (year - 1971) + sum(map(isLeapYear, range(1971, year))) +\n              sum(days[:month]) + day + (month > 2 and isLeapYear(year)))\n\n    return abs(daysFrom1971(date1) - daysFrom1971(date2))",
      "title": "1360. Number of Days Between Two Dates",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa62c797-5671-4a5c-8b8a-d4d154cd1fb8",
      "code": "class Solution:\n  def closestDivisors(self, num: int) -> list[int]:\n    for root in reversed(range(math.isqrt(num + 2) + 1)):\n      for cand in [num + 1, num + 2]:\n        if cand % root == 0:\n          return [root, cand // root]",
      "title": "1362. Closest Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0bc0e3c-c635-4464-9f9c-751750723a7a",
      "code": "class Solution:\n  def largestMultipleOfThree(self, digits: list[int]) -> str:\n    ans = ''\n    mod1 = [1, 4, 7, 2, 5, 8]\n    mod2 = [2, 5, 8, 1, 4, 7]\n    count = collections.Counter(digits)\n    summ = sum(digits)\n\n    while summ % 3 != 0:\n      for digit in (mod1 if summ % 3 == 1 else mod2):\n        if count[digit]:\n          count[digit] -= 1\n          summ -= digit\n          break\n\n    for digit in reversed(range(10)):\n      ans += str(digit) * count[digit]\n\n    return '0' if len(ans) and ans[0] == '0' else ans",
      "title": "1363. Largest Multiple of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00eab9b0-7926-4ecb-8538-f606ccfcb591",
      "code": "class Solution:\n  def smallerNumbersThanCurrent(self, nums: list[int]) -> list[int]:\n    MAX = 100\n    count = collections.Counter(nums)\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    return [0 if num == 0 else count[num - 1]\n            for num in nums]",
      "title": "1365. How Many Numbers Are Smaller Than the Current Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a41302aa-e170-42de-9ddc-4c8474ea085b",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Team:\n  name: str\n  rank: list[int]\n\n  def __init__(self, name: str, teamSize: int):\n    self.name = name\n    self.rank = [0] * teamSize\n\n\nclass Solution:\n  def rankTeams(self, votes: list[str]) -> str:\n    teamSize = len(votes[0])\n    teams = [Team(chr(ord('A') + i), teamSize) for i in range(26)]\n\n    for vote in votes:\n      for i in range(teamSize):\n        teams[ord(vote[i]) - ord('A')].rank[i] += 1\n\n    teams.sort(key=lambda x: (x.rank, -ord(x.name)), reverse=True)\n    return ''.join(team.name for team in teams[:teamSize])",
      "title": "1366. Rank Teams by Votes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27aed4ba-24c2-41f6-8834-9f8a3174da48",
      "code": "class Solution:\n  def isSubPath(self, head: ListNode | None, root: TreeNode | None) -> bool:\n    if not root:\n      return False\n    return (self._isContinuousSubPath(head, root) or\n            self.isSubPath(head, root.left) or\n            self.isSubPath(head, root.right))\n\n  def _isContinuousSubPath(\n      self,\n      head: ListNode | None,\n      root: TreeNode | None,\n  ) -> bool:\n    if not head:\n      return True\n    if not root:\n      return False\n    return (head.val == root.val and\n            (self._isContinuousSubPath(head.next, root.left) or\n             self._isContinuousSubPath(head.next, root.right)))",
      "title": "1367. Linked List in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b16e8854-bdb2-4f12-abd4-f14a87f939fc",
      "code": "class Solution:\n  def minCost(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    DIRS = ((0, 1), (0, -1), (1, 0), (-1, 0))\n    dp = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    def dfs(i: int, j: int, cost: int) -> None:\n      if i < 0 or i == m or j < 0 or j == n:\n        return\n      if dp[i][j] != -1:\n        return\n      dp[i][j] = cost\n      q.append((i, j))\n      dx, dy = DIRS[grid[i][j] - 1]\n      dfs(i + dx, j + dy, cost)\n\n    dfs(0, 0, 0)\n\n    cost = 0\n    while q:\n      cost += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          dfs(i + dx, j + dy, cost)\n\n    return dp[-1][-1]",
      "title": "1368. Minimum Cost to Make at Least One Valid Path in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7971fde4-b497-4c50-8e3a-ab43eb95aa25",
      "code": "class Solution:\n  def sortString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n\n    while count:\n      for chars in string.ascii_lowercase, reversed(string.ascii_lowercase):\n        ans += [c for c in chars if c in count]\n        count -= dict.fromkeys(count, 1)\n\n    return ''.join(ans)",
      "title": "1370. Increasing Decreasing String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f15ffa18-f78e-43e3-b2b7-39b30168b4ff",
      "code": "class Solution:\n  def findTheLongestSubstring(self, s: str) -> int:\n    VOWELS = 'aeiou'\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = {0: -1}\n\n    for i, c in enumerate(s):\n      index = VOWELS.find(c)\n      if index != -1:\n        prefix ^= 1 << index\n      prefixToIndex.setdefault(prefix, i)\n      ans = max(ans, i - prefixToIndex[prefix])\n\n    return ans",
      "title": "1371. Find the Longest Substring Containing Vowels in Even Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "684f13f0-6f52-40fa-ba8b-c49f184da7bb",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  leftMax: int\n  rightMax: int\n  subtreeMax: int\n\n\nclass Solution:\n  def longestZigZag(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(-1, -1, -1)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      leftZigZag = left.rightMax + 1\n      rightZigZag = right.leftMax + 1\n      subtreeMax = max(leftZigZag, rightZigZag,\n                       left.subtreeMax, right.subtreeMax)\n      return T(leftZigZag, rightZigZag, subtreeMax)\n\n    return dfs(root).subtreeMax",
      "title": "1372. Longest ZigZag Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3e73db2-cee8-42e6-9cb9-466ac4dffcb0",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass T:\n  isBST: bool | None = False\n  mx: int | None = None\n  mn: int | None = None\n  summ: int | None = None\n\n\nclass Solution:\n  def maxSumBST(self, root: TreeNode | None) -> int:\n    self.ans = 0\n\n    def traverse(root: TreeNode | None) -> T:\n      if not root:\n        return T(True, -math.inf, math.inf, 0)\n\n      left: T = traverse(root.left)\n      right: T = traverse(root.right)\n\n      if not left.isBST or not right.isBST:\n        return T()\n      if root.val <= left.mx or root.val >= right.mn:\n        return T()\n\n      # The `root` is a valid BST.\n      summ = root.val + left.summ + right.summ\n      self.ans = max(self.ans, summ)\n      return T(True, max(root.val, right.mx), min(root.val, left.mn), summ)\n\n    traverse(root)\n    return self.ans",
      "title": "1373. Maximum Sum BST in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27e1a0a8-1fbb-403c-b679-a6777457d7a0",
      "code": "class Solution:\n  def generateTheString(self, n: int) -> str:\n    s = 'a' * n\n    if n % 2 == 0:\n      s = s[:-1] + 'b'\n    return s",
      "title": "1374. Generate a String With Characters That Have Odd Counts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e26cf0e-44cb-4643-b8d8-34a5e5c85c26",
      "code": "class Solution:\n  def numTimesAllBlue(self, flips: list[int]) -> int:\n    ans = 0\n    rightmost = 0\n\n    for i, flip in enumerate(flips):\n      rightmost = max(rightmost, flip)\n      # max(flips[0..i]) = rightmost = i + 1,\n      # so flips[0..i] is a permutation of 1, 2, ..., i + 1.\n      if rightmost == i + 1:\n        ans += 1\n\n    return ans",
      "title": "1375. Number of Times Binary String Is Prefix-Aligned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90f288dc-a9b5-479d-9aa0-015c2d01a3a4",
      "code": "class Solution:\n  def frogPosition(\n      self,\n      n: int,\n      edges: list[list[int]],\n      t: int,\n      target: int,\n  ) -> float:\n    tree = [[] for _ in range(n + 1)]\n    q = collections.deque([1])\n    seen = [False] * (n + 1)\n    prob = [0] * (n + 1)\n\n    prob[1] = 1\n    seen[1] = True\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    for _ in range(t):\n      for _ in range(len(q)):\n        a = q.popleft()\n        nChildren = sum(not seen[b] for b in tree[a])\n        for b in tree[a]:\n          if seen[b]:\n            continue\n          seen[b] = True\n          prob[b] = prob[a] / nChildren\n          q.append(b)\n        if nChildren > 0:\n          prob[a] = 0\n\n    return prob[target]",
      "title": "1377. Frog Position After T Seconds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d77b5f7-ee9e-421a-9de9-5caba1ca928a",
      "code": "class Solution:\n  def getTargetCopy(\n      self,\n      original: TreeNode,\n      cloned: TreeNode,\n      target: TreeNode,\n  ) -> TreeNode:\n    ans = None\n\n    def dfs(original: TreeNode, cloned: TreeNode) -> None:\n      nonlocal ans\n      if ans:\n        return\n      if not original:\n        return\n      if original == target:\n        ans = cloned\n        return\n\n      dfs(original.left, cloned.left)\n      dfs(original.right, cloned.right)\n\n    dfs(original, cloned)\n    return ans",
      "title": "1379. Find a Corresponding Node of a Binary Tree in a Clone of That Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83d98238-1abe-452d-8150-f36c60f01144",
      "code": "class Solution:\n  def luckyNumbers(self, matrix: list[list[int]]) -> list[int]:\n    for row in matrix:\n      minIndex = row.index(min(row))\n      if row[minIndex] == max(list(zip(*matrix))[minIndex]):\n        return [row[minIndex]]\n    return []",
      "title": "1380. Lucky Numbers in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b48679ba-7da3-4179-9cac-42e20927b70f",
      "code": "class Solution:\n  def balanceBST(self, root: TreeNode | None) -> TreeNode | None:\n    nums = []\n\n    def inorder(root: TreeNode | None) -> None:\n      if not root:\n        return\n      inorder(root.left)\n      nums.append(root.val)\n      inorder(root.right)\n\n    inorder(root)\n\n    # Same as 108. Convert Sorted Array to Binary Search Tree\n    def build(l: int, r: int) -> TreeNode | None:\n      if l > r:\n        return None\n      m = (l + r) // 2\n      return TreeNode(nums[m],\n                      build(l, m - 1),\n                      build(m + 1, r))\n\n    return build(0, len(nums) - 1)",
      "title": "1382. Balance a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dd08fea-1bdb-4e9c-96d6-01c02db2fbbc",
      "code": "class Solution:\n  # Similar to 857. Minimum Cost to Hire K Workers\n  def maxPerformance(\n      self,\n      n: int,\n      speed: list[int],\n      efficiency: list[int],\n      k: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    speedSum = 0\n    # (efficiency[i], speed[i]) sorted by efficiency[i] in descending order\n    A = sorted([(e, s) for s, e in zip(speed, efficiency)], reverse=True)\n    minHeap = []\n\n    for e, s in A:\n      heapq.heappush(minHeap, s)\n      speedSum += s\n      if len(minHeap) > k:\n        speedSum -= heapq.heappop(minHeap)\n      ans = max(ans, speedSum * e)\n\n    return ans % MOD",
      "title": "1383. Maximum Performance of a Team",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c74cb7d-8e66-4f64-a3ec-787400487564",
      "code": "class Solution:\n  def findTheDistanceValue(\n      self,\n      arr1: list[int],\n      arr2: list[int],\n      d: int,\n  ) -> int:\n    ans = 0\n\n    arr2.sort()\n\n    for a in arr1:\n      i = bisect.bisect_left(arr2, a)\n      if ((i == len(arr2) or arr2[i] - a > d) and\n              (i == 0 or a - arr2[i - 1] > d)):\n        ans += 1\n\n    return ans",
      "title": "1385. Find the Distance Value Between Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd814ae5-ca03-4769-b526-789019b253d5",
      "code": "class Solution:\n  def maxNumberOfFamilies(self, n: int, reservedSeats: list[list[int]]) -> int:\n    ans = 0\n    rowToSeats = collections.Counter()\n\n    for row, seat in reservedSeats:\n      rowToSeats[row] |= 1 << (seat - 1)\n\n    for seats in rowToSeats.values():\n      if (seats & 0b0111111110) == 0:\n        # Can fit 2 four-person groups.\n        ans += 2\n      elif ((seats & 0b0111100000) == 0 or\n            (seats & 0b0001111000) == 0 or\n            (seats & 0b0000011110) == 0):\n        # Can fit 1 four-person group.\n        ans += 1\n\n    # Any empty row can fit 2 four-person groups.\n    return ans + (n - len(rowToSeats)) * 2",
      "title": "1386. Cinema Seat Allocation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a6ded7e-2f86-47b4-b9fd-2b4fceb73ec4",
      "code": "class Solution:\n  def getKth(self, lo: int, hi: int, k: int) -> int:\n    return sorted([(self._getPow(i), i) for i in range(lo, hi + 1)])[k - 1][1]\n\n  def _getPow(self, n: int) -> int:\n    if n == 1:\n      return 0\n    if n % 2 == 0:\n      return 1 + self._getPow(n // 2)\n    return 1 + self._getPow(n * 3 + 1)",
      "title": "1387. Sort Integers by The Power Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d6e783d0-fed6-4b70-8b1d-51e6ff625a41",
      "code": "class Solution:\n  def maxSizeSlices(self, slices: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum the sum of slices if you can pick k slices from\n      slices[i..j).\n      \"\"\"\n      if k == 1:\n        return max(slices[i:j])\n      # Note that j - i is not the number of all the left slices. Since you\n      # Might have chosen not to take a slice in a previous step, there would be\n      # Leftovers outside [i:j]. If you take slices[i], one of the slices your\n      # Friends take will be outside of [i:j], so the length of [i:j] is reduced\n      # By 2 instead of 3. Therefore, the minimum # Is 2 * k - 1 (the last step only\n      # Requires one slice).\n      if j - i < 2 * k - 1:\n        return -math.inf\n      return max(slices[i] + dp(i + 2, j, k - 1),\n                 dp(i + 1, j, k))\n\n    k = len(slices) // 3\n    return max(dp(0, len(slices) - 1, k),\n               dp(1, len(slices), k))",
      "title": "1388. Pizza With 3n Slices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5bfee0bb-b625-4715-b32d-ce548b9d5602",
      "code": "class Solution:\n  def createTargetArray(self, nums, index):\n    ans = []\n    for num, i in zip(nums, index):\n      ans.insert(i, num)\n    return ans",
      "title": "1389. Create Target Array in the Given Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee65bcbc-6fee-48c4-9de1-adebf3bfcb2d",
      "code": "class Solution:\n  def sumFourDivisors(self, nums: list[int]) -> int:\n    ans = 0\n\n    for num in nums:\n      divisor = 0\n      for i in range(2, math.isqrt(num) + 1):\n        if num % i == 0:\n          if divisor == 0:\n            divisor = i\n          else:\n            divisor = 0\n            break\n      if divisor > 0 and divisor * divisor < num:\n        ans += 1 + num + divisor + num // divisor\n\n    return ans",
      "title": "1390. Four Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "019acc04-d336-43ad-8644-79e92994efe8",
      "code": "class Solution:\n  def longestPrefix(self, s: str) -> str:\n    BASE = 26\n    HASH = 8_417_508_174_513\n    n = len(s)\n    maxLength = 0\n    pow = 1\n    prefixHash = 0  # the hash of s[0..i]\n    suffixHash = 0  # the hash of s[j..n)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    j = n - 1\n    for i in range(n - 1):\n      prefixHash = (prefixHash * BASE + val(s[i])) % HASH\n      suffixHash = (val(s[j]) * pow + suffixHash) % HASH\n      pow = pow * BASE % HASH\n      if prefixHash == suffixHash:\n        maxLength = i + 1\n      j -= 1\n\n    return s[:maxLength]",
      "title": "1392. Longest Happy Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7bfad9d3-fff6-4c07-a86e-4a43a0197134",
      "code": "class Solution:\n  def findLucky(self, arr: list[int]) -> int:\n    count = [0] * (len(arr) + 1)\n\n    for a in arr:\n      if a <= len(arr):\n        count[a] += 1\n\n    for i in range(len(arr), 0, -1):\n      if count[i] == i:\n        return i\n\n    return -1",
      "title": "1394. Find Lucky Integer in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dc7332b-8723-44b9-a70a-c022ab707061",
      "code": "class Solution:\n  def numTeams(self, rating: list[int]) -> int:\n    ans = 0\n\n    for i in range(1, len(rating) - 1):\n      # Calculate soldiers on the left with less//greater ratings.\n      leftLess = 0\n      leftGreater = 0\n      for j in range(i):\n        if rating[j] < rating[i]:\n          leftLess += 1\n        elif rating[j] > rating[i]:\n          leftGreater += 1\n      # Calculate soldiers on the right with less//greater ratings.\n      rightLess = 0\n      rightGreater = 0\n      for j in range(i + 1, len(rating)):\n        if rating[j] < rating[i]:\n          rightLess += 1\n        elif rating[j] > rating[i]:\n          rightGreater += 1\n      ans += leftLess * rightGreater + leftGreater * rightLess\n\n    return ans",
      "title": "1395. Count Number of Teams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "13466ba3-4720-48a5-9e39-f43d74c5f5b5",
      "code": "class Solution:\n  def findGoodStrings(self, n: int, s1: str, s2: str, evil: str) -> int:\n    MOD = 1_000_000_007\n    evilLPS = self._getLPS(evil)\n\n    @functools.lru_cache(None)\n    def getNextMatchedEvilCount(j: int, currChar: str) -> int:\n      \"\"\"\n      Returns the number of next matched evil count, where there're j matches\n      with `evil` and the current letter is ('a' + j).\n      \"\"\"\n      while j > 0 and evil[j] != currChar:\n        j = evilLPS[j - 1]\n      return j + 1 if evil[j] == currChar else j\n\n    @functools.lru_cache(None)\n    def dp(i: int, matchedEvilCount: int, isS1Prefix: bool, isS2Prefix: bool) -> int:\n      \"\"\"\n      Returns the number of good strings for s[i..n), where there're j matches\n      with `evil`, `isS1Prefix` indicates if the current letter is tightly bound\n      for `s1` and `isS2Prefix` indicates if the current letter is tightly bound\n      for `s2`.\n      \"\"\"\n      # s[0..i) contains `evil`, so don't consider any ongoing strings.\n      if matchedEvilCount == len(evil):\n        return 0\n      # Run out of strings, so contribute one.\n      if i == n:\n        return 1\n      ans = 0\n      minCharIndex = ord(s1[i]) if isS1Prefix else ord('a')\n      maxCharIndex = ord(s2[i]) if isS2Prefix else ord('z')\n      for charIndex in range(minCharIndex, maxCharIndex + 1):\n        c = chr(charIndex)\n        nextMatchedEvilCount = getNextMatchedEvilCount(matchedEvilCount, c)\n        ans += dp(i + 1, nextMatchedEvilCount,\n                  isS1Prefix and c == s1[i],\n                  isS2Prefix and c == s2[i])\n        ans %= MOD\n      return ans\n\n    return dp(0, 0, True, True)\n\n  def _getLPS(self, pattern: str) -> list[int]:\n    \"\"\"\n    Returns the lps array, where lps[i] is the length of the longest prefix of\n    pattern[0..i] which is also a suffix of this substring.\n    \"\"\"\n    lps = [0] * len(pattern)\n    j = 0\n    for i in range(1, len(pattern)):\n      while j > 0 and pattern[j] != pattern[i]:\n        j = lps[j - 1]\n      if pattern[i] == pattern[j]:\n        lps[i] = j + 1\n        j += 1\n    return lps",
      "title": "1397. Find All Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6037fd4f-aaf8-42e9-9a53-67b7f51c05b0",
      "code": "class Solution:\n  def countLargestGroup(self, n: int) -> int:\n    count = [0] * (9 * 4 + 1)\n    for i in range(1, n + 1):\n      count[self._getDigitSum(i)] += 1\n    return count.count(max(count))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1399. Count Largest Group",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77cc7a37-bc71-4309-a8a6-cce04d06a7c3",
      "code": "class Solution:\n  def canConstruct(self, s: str, k: int) -> bool:\n    # If |s| < k, we cannot construct k strings from the s.\n    # If the number of letters that have odd counts > k, the minimum number of\n    # palindromic strings we can construct is > k.\n    return sum(freq & 1\n               for freq in collections.Counter(s).values()) <= k <= len(s)",
      "title": "1400. Construct K Palindrome Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0bc19269-6ebf-439e-afcf-86dc9e8d4f91",
      "code": "class Solution:\n  def maxSatisfaction(self, satisfaction: list[int]) -> int:\n    ans = 0\n    sumSatisfaction = 0\n\n    for s in sorted(satisfaction, reverse=True):\n      sumSatisfaction += s\n      if sumSatisfaction <= 0:\n        return ans\n      ans += sumSatisfaction\n\n    return ans",
      "title": "1402. Reducing Dishes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4826b0dc-369a-45e4-90bc-7a22105e9fc4",
      "code": "class Solution:\n  def minSubsequence(self, nums: list[int]) -> list[int]:\n    ans = []\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n    half = sum(nums) // 2\n\n    while half >= 0:\n      ans.append(-maxHeap[0])\n      half += heapq.heappop(maxHeap)\n\n    return ans",
      "title": "1403. Minimum Subsequence in Non-Increasing Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87c475bd-2057-41d3-81b3-df56d5a5c2d5",
      "code": "class Solution:\n  def numSteps(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    # All the trailing 0s can be popped by 1 step.\n    while chars[-1] == '0':\n      chars.pop()\n      ans += 1\n\n    if ''.join(chars) == '1':\n      return ans\n\n    # `s` is now odd, so add 1 to `s` and cost 1 step.\n    # All the 1s will become 0s and can be popped by 1 step.\n    # All the 0s will become 1s and can be popped by 2 steps (adding 1 then\n    # dividing by 2).\n    return ans + 1 + sum(1 if c == '1' else 2 for c in chars)",
      "title": "1404. Number of Steps to Reduce a Number in Binary Representation to One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdb2d3cf-6a47-404d-bbef-187b6af20439",
      "code": "class Solution:\n  def stoneGameIII(self, stoneValue: list[int]) -> str:\n    @functools.lru_cache(None)\n    def dp(i: int) -> int:\n      \"\"\"\n      Returns the maximum relative score Alice can make with stoneValue[i..n).\n      \"\"\"\n      if i == len(stoneValue):\n        return 0\n\n      res = -math.inf\n      summ = 0\n\n      for j in range(i, i + 3):\n        if j == len(stoneValue):\n          break\n        summ += stoneValue[j]\n        res = max(res, summ - dp(j + 1))\n\n      return res\n\n    score = dp(0)\n    if score == 0:\n      return 'Tie'\n    return 'Alice' if score > 0 else 'Bob'",
      "title": "1406. Stone Game III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ff29bc3-2e8c-4565-99c7-ed4969d59cb4",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n\n  def insert(self, word: str) -> None:\n    node: TrieNode = self.root\n    for c in word:\n      node = node.children.setdefault(c, TrieNode())\n\n  def search(self, word: str) -> bool:\n    node: TrieNode = self.root\n    for c in word:\n      if c not in node.children:\n        return False\n      node = node.children[c]\n    return True\n\n\nclass Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    trie = Trie()\n\n    for word in sorted(words, key=lambda x: -len(x)):\n      if trie.search(word):\n        ans.append(word)\n      for i in range(len(word)):\n        trie.insert(word[i:])\n\n    return ans",
      "title": "1408. String Matching in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba31ea70-9171-4334-accc-23a79afb5721",
      "code": "class Solution:\n  def stringMatching(self, words: list[str]) -> list[str]:\n    ans = []\n    for a in words:\n      for b in words:\n        if len(a) < len(b) and b.find(a) != -1:\n          ans.append(a)\n          break\n    return ans",
      "title": "1408. String Matching in an Array_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a585d33e-9ff1-4044-b751-fb404947d54e",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def processQueries(self, queries: list[int], m: int) -> list[int]:\n    ans = []\n    # Map [-m, m] to [0, 2 * m].\n    tree = FenwickTree(2 * m + 1)\n    numToIndex = {num: num + m for num in range(1, m + 1)}\n\n    for num in range(1, m + 1):\n      tree.add(num + m, 1)\n\n    nextEmptyIndex = m  # Map 0 to m.\n\n    for query in queries:\n      index = numToIndex[query]\n      ans.append(tree.get(index - 1))\n      # Move `query` from `index` to `nextEmptyIndex`.\n      tree.add(index, -1)\n      tree.add(nextEmptyIndex, 1)\n      numToIndex[query] = nextEmptyIndex\n      nextEmptyIndex -= 1\n\n    return ans",
      "title": "1409. Queries on a Permutation With Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b9ddf29-7a5a-447c-879d-076b1fad3ce9",
      "code": "class Solution:\n  def entityParser(self, text: str) -> str:\n    entityToChar = {'&quot;': '\"', '&apos;': '\\'',\n                    '&gt;': '>', '&lt;': '<', '&frasl;': '/'}\n\n    for entity, c in entityToChar.items():\n      text = text.replace(entity, c)\n\n    # Process '&' in last.\n    return text.replace('&amp;', '&')",
      "title": "1410. HTML Entity Parser",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0c206306-b8b5-4bee-8c1b-811e91d09f37",
      "code": "class Solution:\n  def minStartValue(self, nums: list[int]) -> int:\n    summ = 0\n    minSum = 0\n\n    for num in nums:\n      summ += num\n      minSum = min(minSum, summ)\n\n    return 1 - minSum",
      "title": "1413. Minimum Value to Get Positive Step by Step Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26912e7c-3d58-4eb7-b1bd-b58f77257457",
      "code": "class Solution:\n  def findMinFibonacciNumbers(self, k: int) -> int:\n    ans = 0\n    a = 1  # F_1\n    b = 1  # F_2\n\n    while b <= k:\n      #    a, b = F_{i + 1}, F_{i + 2}\n      # -> a, b = F_{i + 2}, F_{i + 3}\n      a, b = b, a + b\n\n    while a > 0:\n      if a <= k:\n        k -= a\n        ans += 1\n      #    a, b = F_{i + 2}, F_{i + 3}\n      # -> a, b = F_{i + 1}, F_{i + 2}\n      a, b = b - a, a\n\n    return ans",
      "title": "1414. Find the Minimum Number of Fibonacci Numbers Whose Sum Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f916a96-4dcf-43e8-8d4c-2f683ec5ce34",
      "code": "class Solution:\n  def getHappyString(self, n: int, k: int) -> str:\n    nextLetters = {'a': 'bc', 'b': 'ac', 'c': 'ab'}\n    q = collections.deque(['a', 'b', 'c'])\n\n    while len(q[0]) != n:\n      u = q.popleft()\n      for nextLetter in nextLetters[u[-1]]:\n        q.append(u + nextLetter)\n\n    return '' if len(q) < k else q[k - 1]",
      "title": "1415. The k-th Lexicographical String of All Happy Strings of Length n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c8137bb-7f5b-44a8-9939-18e19d8a6c83",
      "code": "class Solution:\n  def reformat(self, s: str) -> str:\n    A = [c for c in s if c.isalpha()]\n    B = [c for c in s if c.isdigit()]\n\n    if len(A) < len(B):\n      A, B = B, A\n    if len(A) - len(B) > 1:\n      return ''\n\n    ans = []\n\n    for i in range(len(B)):\n      ans.append(A[i])\n      ans.append(B[i])\n\n    if len(A) == len(B) + 1:\n      ans.append(A[-1])\n    return ''.join(ans)",
      "title": "1417. Reformat The String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4643c00f-97e6-4b9b-8585-b2c55ed66f29",
      "code": "class Solution:\n  def minNumberOfFrogs(self, croakOfFrogs: str) -> int:\n    CROAK = 'croak'\n    ans = 0\n    frogs = 0\n    count = [0] * 5\n\n    for c in croakOfFrogs:\n      count[CROAK.index(c)] += 1\n      if any(count[i] > count[i - 1] for i in range(1, 5)):\n        return -1\n      if c == 'c':\n        frogs += 1\n      elif c == 'k':\n        frogs -= 1\n      ans = max(ans, frogs)\n\n    return ans if frogs == 0 else -1",
      "title": "1419. Minimum Number of Frogs Croaking",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f17865c-c9c1-43be-90ca-5827c21c66ee",
      "code": "class Solution:\n  def numOfArrays(self, n: int, m: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i][j][k] := the number of ways to build an array of length i, where j\n    # is the maximum number and k is the `search_cost`\n    dp = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n    # prefix[i][j][k] := sum(dp[i][x][k]), where 1 <= x <= j\n    prefix = [[[0] * (k + 1) for j in range(m + 1)] for _ in range(n + 1)]\n\n    for j in range(1, m + 1):\n      dp[1][j][1] = 1\n      prefix[1][j][1] = j\n\n    for i in range(2, n + 1):  # for each length\n      for j in range(1, m + 1):  # for each max value\n        for cost in range(1, k + 1):  # for each cost\n          # 1. Appending any of [1, j] in the i-th position doesn't change the\n          #    maximum and cost.\n          # 2. Appending j in the i-th position makes j the new max and cost 1.\n          dp[i][j][cost] = (j * dp[i - 1][j][cost] +\n                            prefix[i - 1][j - 1][cost - 1]) % MOD\n          prefix[i][j][cost] = (dp[i][j][cost] + prefix[i][j - 1][cost]) % MOD\n\n    return sum(dp[n][j][k] for j in range(1, m + 1)) % MOD",
      "title": "1420. Build Array Where You Can Find The Maximum Exactly K Comparisons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "598aefc8-99d3-4678-b898-8cbe1eed4e7b",
      "code": "class Solution:\n  def maxScore(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n    ones = s.count('1')\n\n    for i in range(len(s) - 1):\n      if s[i] == '0':\n        zeros += 1\n      else:\n        ones -= 1\n      ans = max(ans, zeros + ones)\n\n    return ans",
      "title": "1422. Maximum Score After Splitting a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15222b6e-9b57-4e1a-9c21-89c622add8e6",
      "code": "class Solution:\n  def maxScore(self, cardPoints: list[int], k: int) -> int:\n    n = len(cardPoints)\n    summ = sum(cardPoints)\n    windowSum = sum(cardPoints[:n - k])\n    ans = summ - windowSum\n\n    for i in range(k):\n      windowSum -= cardPoints[i]\n      windowSum += cardPoints[i + n - k]\n      ans = max(ans, summ - windowSum)\n\n    return ans",
      "title": "1423. Maximum Points You Can Obtain from Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1b05b324-7b0e-45ec-8ecf-a30169cfeb77",
      "code": "class Solution:\n  def constrainedSubsetSum(self, nums: list[int], k: int) -> int:\n    # dp[i] := the maximum the sum of non-empty subsequences in nums[0..i]\n    dp = [0] * len(nums)\n    # dq stores dp[i - k], dp[i - k + 1], ..., dp[i - 1] whose values are > 0\n    # in decreasing order.\n    dq = collections.deque()\n\n    for i, num in enumerate(nums):\n      if dq:\n        dp[i] = max(dq[0], 0) + num\n      else:\n        dp[i] = num\n      while dq and dq[-1] < dp[i]:\n        dq.pop()\n      dq.append(dp[i])\n      if i >= k and dp[i - k] == dq[0]:\n        dq.popleft()\n\n    return max(dp)",
      "title": "1425. Constrained Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f35a12d9-c968-4af9-abfa-ca6aacdfdebe",
      "code": "class Solution:\n  def countElements(self, arr: list[int]) -> int:\n    count = collections.Counter(arr)\n    return sum(freq\n               for a, freq in count.items()\n               if count[a + 1] > 0)",
      "title": "1426. Counting Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3742a1c2-3fa7-4038-8824-04f448be2369",
      "code": "class Solution:\n  def stringShift(self, s: str, shift: list[list[int]]) -> str:\n    move = 0\n\n    for direction, amount in shift:\n      if direction == 0:\n        move -= amount\n      else:\n        move += amount\n\n    move %= len(s)\n    return s[-move:] + s[:-move]",
      "title": "1427. Perform String Shifts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c88f221-3c57-4503-8fee-422d3b508374",
      "code": "# \"\"\"\n# This is BinaryMatrix's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# Class BinaryMatrix(object):\n#   def get(self, row: int, col: int) -> int:\n#   def dimensions(self) -> list[int]:\n\nclass Solution:\n  def leftMostColumnWithOne(self, binaryMatrix: 'BinaryMatrix') -> int:\n    m, n = binaryMatrix.dimensions()\n    ans = -1\n    l = 0\n    r = n - 1\n\n    while l <= r:\n      mid = (l + r) // 2\n      if any(binaryMatrix.get(i, mid) for i in range(m)):\n        ans = mid\n        r = mid - 1\n      else:\n        l = mid + 1\n\n    return ans",
      "title": "1428. Leftmost Column with at Least a One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2276f844-7306-4e9a-acd5-36b3867fec04",
      "code": "class Solution:\n  def isValidSequence(self, root: TreeNode | None, arr: list[int]) -> bool:\n    def isValidSequence(root: TreeNode | None, i: int) -> bool:\n      if not root:\n        return False\n      if i == len(arr) - 1:\n        return root.val == arr[i] and not root.left and not root.right\n      return root.val == arr[i] and (\n          isValidSequence(root.left, i + 1) or\n          isValidSequence(root.right, i + 1))\n\n    return isValidSequence(root, 0)",
      "title": "1430. Check If a String Is a Valid Sequence from Root to Leaves Path in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a0ddede-9ba6-43e7-a50d-cfe16ac62786",
      "code": "class Solution:\n  def kidsWithCandies(\n      self,\n      candies: list[int],\n      extraCandies: int,\n  ) -> list[bool]:\n    maxCandy = max(candies)\n    return [candy + extraCandies >= maxCandy for candy in candies]",
      "title": "1431. Kids With the Greatest Number of Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afe6d3a6-e95c-4e25-ab6e-804c69603eaf",
      "code": "class Solution:\n  def maxDiff(self, num: int) -> int:\n    s = str(num)\n\n    def firstNot(s: str, t: str) -> int:\n      for i, c in enumerate(s):\n        if all(c != d for d in t):\n          return i\n      return 0\n\n    firstNot9 = firstNot(s, '9')\n    firstNot01 = firstNot(s, '01')\n    a = s.replace(s[firstNot9], '9')\n    b = s.replace(s[firstNot01], '1' if firstNot01 == 0 else '0')\n    return int(a) - int(b)",
      "title": "1432. Max Difference You Can Get From Changing an Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b972d4b9-ee5d-4cf2-89ee-5c509cb5ff40",
      "code": "class Solution:\n  def checkIfCanBreak(self, s1: str, s2: str) -> bool:\n    count1 = collections.Counter(s1)\n    count2 = collections.Counter(s2)\n\n    def canBreak(count1: dict[str, int], count2: dict[str, int]) -> bool:\n      \"\"\"Returns True if count1 can break count2.\"\"\"\n      diff = 0\n      for c in string.ascii_lowercase:\n        diff += count2[c] - count1[c]\n        # count2 is alphabetically greater than count1.\n        if diff < 0:\n          return False\n      return True\n\n    return canBreak(count1, count2) or canBreak(count2, count1)",
      "title": "1433. Check If a String Can Break Another String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa17fc93-debd-4761-9c4a-ee2658d69c97",
      "code": "class Solution:\n  def destCity(self, paths: list[list[str]]) -> str:\n    count = collections.Counter()\n\n    for a, b in paths:\n      count[a] += 1\n\n    for a, b in paths:\n      if b in count:\n        count[b] -= 1\n        if count[b] == 0:\n          del count[b]\n      else:\n        return b",
      "title": "1436. Destination City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27b58c96-e22e-4be1-bf11-d311457ee6df",
      "code": "class Solution:\n  def kLengthApart(self, nums: list[int], k: int) -> bool:\n    if k == 0:\n      return True\n\n    n = len(nums)\n    curr = 0\n    next = 1\n\n    while curr < n and next < n:\n      if nums[next] == 1:\n        if nums[curr] == 1 and next - curr <= k:\n          return False\n        curr = next\n      next += 1\n\n    return True",
      "title": "1437. Check If All 1's Are at Least Length K Places Away",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a1043f3-18e6-4808-9052-20dad1b1c5f3",
      "code": "class Solution:\n  def buildArray(self, target: list[int], n: int) -> list[str]:\n    ans = []\n    i = 0  # Target pointer\n    num = 1  # Curr num\n\n    while i < len(target):\n      t = target[i]\n      if t == num:\n        ans.append('Push')\n        i += 1\n      else:\n        ans.append('Push')\n        ans.append('Pop')\n      num += 1\n\n    return ans",
      "title": "1441. Build an Array With Stack Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c4883a2-8ebd-45e3-8a17-360c97bfc4bf",
      "code": "class Solution:\n  def countTriplets(self, arr: list[int]) -> int:\n    ans = 0\n    xors = [0]\n    prefix = 0\n\n    for i, a in enumerate(arr):\n      prefix ^= a\n      xors.append(prefix)\n\n    for j in range(1, len(arr)):\n      for i in range(0, j):\n        xors_i = xors[j] ^ xors[i]\n        for k in range(j, len(arr)):\n          xors_k = xors[k + 1] ^ xors[j]\n          if xors_i == xors_k:\n            ans += 1\n\n    return ans",
      "title": "1442. Count Triplets That Can Form Two Arrays of Equal XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26295b5f-5d2e-4cc9-9013-3cb3016f9b0e",
      "code": "class Solution:\n  def ways(self, pizza: list[str], k: int) -> int:\n    MOD = 1_000_000_007\n    M = len(pizza)\n    N = len(pizza[0])\n    prefix = [[0] * (N + 1) for _ in range(M + 1)]\n\n    for i in range(M):\n      for j in range(N):\n        prefix[i + 1][j + 1] = ((pizza[i][j] == 'A') + prefix[i][j + 1] +\n                                prefix[i + 1][j] - prefix[i][j])\n\n    def hasApple(row1: int, row2: int, col1: int, col2: int) -> bool:\n      \"\"\"Returns True if pizza[row1..row2)[col1..col2) has apple.\"\"\"\n      return (prefix[row2][col2] - prefix[row1][col2] -\n              prefix[row2][col1] + prefix[row1][col1]) > 0\n\n    @functools.lru_cache(None)\n    def dp(m: int, n: int, k: int) -> int:\n      \"\"\"Returns the number of ways to cut pizza[m..M)[n..N) with k cuts.\"\"\"\n      if k == 0:\n        return 1 if hasApple(m, M, n, N) else 0\n\n      res = 0\n\n      for i in range(m + 1, M):  # Cut horizontally.\n        if hasApple(m, i, n, N) and hasApple(i, M, n, N):\n          res += dp(i, n, k - 1)\n\n      for j in range(n + 1, N):  # Cut vertically.\n        if hasApple(m, M, n, j) and hasApple(m, M, j, N):\n          res += dp(m, j, k - 1)\n\n      return res % MOD\n\n    return dp(0, 0, k - 1)",
      "title": "1444. Number of Ways of Cutting a Pizza",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d22a6a41-af06-4c53-9b16-1a223fe14df7",
      "code": "class Solution:\n  def maxPower(self, s: str) -> int:\n    ans = 1\n    count = 1\n\n    for i in range(1, len(s)):\n      count = count + 1 if s[i] == s[i - 1] else 1\n      ans = max(ans, count)\n\n    return ans",
      "title": "1446. Consecutive Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56a5b648-24c9-4d1f-aba1-90fb164bef58",
      "code": "class Solution:\n  def simplifiedFractions(self, n: int) -> list[str]:\n    ans = []\n    for denominator in range(2, n + 1):\n      for numerator in range(1, denominator):\n        if math.gcd(denominator, numerator) == 1:\n          ans.append(str(numerator) + '/' + str(denominator))\n    return ans",
      "title": "1447. Simplified Fractions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ac8990d-6a24-4219-b44a-d115eec48f77",
      "code": "class Solution:\n  def arrangeWords(self, text: str) -> str:\n    words = text.split()\n    count = collections.defaultdict(list)\n\n    for word in words:\n      count[len(word)].append(word.lower())\n\n    c2 = OrderedDict(sorted(count.items()))\n\n    ans = []\n\n    for l in c2:\n      for word in c2[l]:\n        ans.append(word)\n\n    ans[0] = ans[0].capitalize()\n\n    return ' '.join(ans)",
      "title": "1451. Rearrange Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26586433-19b2-45a7-96c6-6412092810ee",
      "code": "class Solution:\n  def peopleIndexes(self, favoriteCompanies: list[list[str]]) -> list[int]:\n    ans = []\n    n = len(favoriteCompanies)\n    companies = [set(comp) for comp in favoriteCompanies]\n\n    for i in range(n):\n      find = False\n      for j in range(n):\n        if i == j:\n          continue\n        if companies[i].issubset(companies[j]):\n          find = True\n          break\n      if not find:\n        ans.append(i)\n\n    return ans",
      "title": "1452. People Whose List of Favorite Companies Is Not a Subset of Another List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a23cd103-7e86-4b12-9a02-2b4d62b52a73",
      "code": "class Point:\n  def __init__(self, x: float, y: float):\n    self.x = x\n    self.y = y\n\n\nclass Solution:\n  def numPoints(self, darts: list[list[int]], r: int) -> int:\n    ERR = 1e-6\n    ans = 1\n    points = [Point(x, y) for x, y in darts]\n\n    def dist(p: Point, q: Point) -> float:\n      return ((p.x - q.x)**2 + (p.y - q.y)**2)**0.5\n\n    def getCircles(p: Point, q: Point) -> list[Point]:\n      if dist(p, q) - 2.0 * r > ERR:\n        return []\n      m = Point((p.x + q.x) / 2, (p.y + q.y) / 2)\n      distCM = (r**2 - (dist(p, q) / 2)**2)**0.5\n      alpha = math.atan2(p.y - q.y, q.x - p.x)\n      return [Point(m.x - distCM * math.sin(alpha), m.y - distCM * math.cos(alpha)),\n              Point(m.x + distCM * math.sin(alpha), m.y + distCM * math.cos(alpha))]\n\n    for i, j in itertools.combinations(points, 2):\n      for c in getCircles(i, j):\n        count = 0\n        for point in points:\n          if dist(c, point) - r <= ERR:\n            count += 1\n        ans = max(ans, count)\n\n    return ans",
      "title": "1453. Maximum Number of Darts Inside of a Circular Dartboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd28157a-5f4b-4b47-94f9-cde74f594880",
      "code": "class Solution:\n  def isPrefixOfWord(self, sentence: str, searchWord: str) -> int:\n    words = sentence.split()\n\n    for i, word in enumerate(words):\n      if word.startswith(searchWord):\n        return i + 1\n\n    return -1",
      "title": "1455. Check If a Word Occurs As a Prefix of Any Word in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dceabc39-168a-468c-951a-a6b508e22212",
      "code": "class Solution:\n  def maxVowels(self, s: str, k: int) -> int:\n    ans = 0\n    mx = 0\n    VOWELS = 'aeiou'\n\n    for i, c in enumerate(s):\n      if c in VOWELS:\n        mx += 1\n      if i >= k and s[i - k] in VOWELS:\n        mx -= 1\n      ans = max(ans, mx)\n\n    return ans",
      "title": "1456. Maximum Number of Vowels in a Substring of Given Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "379bc684-6bd0-4f34-b9c2-c83c5d1bd760",
      "code": "class Solution:\n  def pseudoPalindromicPaths(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None, path: int) -> None:\n      nonlocal ans\n      if not root:\n        return\n      if not root.left and not root.right:\n        path ^= 1 << root.val\n        if path & (path - 1) == 0:\n          ans += 1\n        return\n\n      dfs(root.left, path ^ 1 << root.val)\n      dfs(root.right, path ^ 1 << root.val)\n\n    dfs(root, 0)\n    return ans",
      "title": "1457. Pseudo-Palindromic Paths in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f95b8a6b-9e2c-42d9-b34c-d06a7d4f9217",
      "code": "class Solution:\n  def maxDotProduct(self, A: list[int], B: list[int]) -> int:\n    m = len(A)\n    n = len(B)\n    # dp[i][j] := the maximum dot product of the two subsequences nums[0..i)\n    # and nums2[0..j)\n    dp = [[-math.inf] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m):\n      for j in range(n):\n        dp[i + 1][j + 1] = max(dp[i][j + 1], dp[i + 1][j],\n                               max(0, dp[i][j]) + A[i] * B[j])\n\n    return dp[m][n]",
      "title": "1458. Max Dot Product of Two Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c49d14f-a81b-4e50-9384-d77df6d9c4be",
      "code": "class Solution:\n  def canBeEqual(self, target: list[int], arr: list[int]) -> bool:\n    return collections.Counter(arr) == collections.Counter(target)",
      "title": "1460. Make Two Arrays Equal by Reversing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86afd2c1-44c1-41ed-a1f2-5b3c6f1250f6",
      "code": "class Solution:\n  def hasAllCodes(self, s: str, k: int) -> bool:\n    n = 1 << k\n    if len(s) < n:\n      return False\n\n    # used[i] := True if i is a substring of `s`\n    used = [0] * n\n\n    windowStr = 0 if k == 1 else int(s[0:k - 1], 2)\n    for i in range(k - 1, len(s)):\n      # Include the s[i].\n      windowStr = (windowStr << 1) + int(s[i])\n      # Discard the s[i - k].\n      windowStr &= n - 1\n      used[windowStr] = True\n\n    return all(u for u in used)",
      "title": "1461. Check If a String Contains All Binary Codes of Size K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4e4bf77-b153-4480-90b9-043230aa2338",
      "code": "class Solution:\n  def checkIfPrerequisite(\n      self,\n      numCourses: int,\n      prerequisites: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[bool]:\n    graph = [[] for _ in range(numCourses)]\n    # isPrerequisite[i][j] := True if course i is a prerequisite of course j.\n    isPrerequisite = [[False] * numCourses for _ in range(numCourses)]\n\n    for u, v in prerequisites:\n      graph[u].append(v)\n\n    # DFS from every course.\n    for i in range(numCourses):\n      self._dfs(graph, i, isPrerequisite[i])\n\n    return [isPrerequisite[u][v] for u, v in queries]\n\n  def _dfs(self, graph: list[list[int]], u: int, used: list[bool]) -> None:\n    for v in graph[u]:\n      if used[v]:\n        continue\n      used[v] = True\n      self._dfs(graph, v, used)",
      "title": "1462. Course Schedule IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a85ac5a-6f2d-4638-9f34-cef920ba4c30",
      "code": "class Solution:\n  def maxProduct(self, nums: list[int]) -> int:\n    max1 = 0\n    max2 = 0\n\n    for num in nums:\n      if num > max1:\n        max2, max1 = max1, num\n      elif num > max2:\n        max2 = num\n\n    return (max1 - 1) * (max2 - 1)",
      "title": "1464. Maximum Product of Two Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1aff708f-8df4-4552-a0f5-8d45b514fb12",
      "code": "class Solution:\n  def maxArea(\n      self,\n      h: int,\n      w: int,\n      horizontalCuts: list[int],\n      verticalCuts: list[int],\n  ) -> int:\n    MOD = 1_000_000_007\n    # the maximum gap of each direction\n    maxGapX = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(horizontalCuts) + [h]))\n    maxGapY = max(b - a\n                  for a, b in itertools.pairwise(\n                      [0] + sorted(verticalCuts) + [w]))\n    return maxGapX * maxGapY % MOD",
      "title": "1465. Maximum Area of a Piece of Cake After Horizontal and Vertical Cuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56ad2cd5-4fdb-4e53-b0a3-4281c8282c8f",
      "code": "from enum import Enum\n\n\nclass BoxCase(Enum):\n  EQUAL_DISTANT_BALLS = 0\n  EQUAL_BALLS = 1\n\n\nclass Solution:\n  def getProbability(self, balls: list[int]) -> float:\n    n = sum(balls) // 2\n    fact = [1, 1, 2, 6, 24, 120, 720]\n\n    def cases(\n            i: int,\n            ballsCountA: int,\n            ballsCountB: int,\n            colorsCountA: int,\n            colorsCountB,\n            boxCase: BoxCase) -> float:\n      if ballsCountA > n or ballsCountB > n:\n        return 0\n      if i == len(balls):\n        return (1 if boxCase == BoxCase.EQUAL_BALLS\n                else colorsCountA == colorsCountB)\n\n      ans = 0.0\n\n      # balls taken from A for `balls[i]`\n      for ballsTakenA in range(balls[i] + 1):\n        ballsTakenB = balls[i] - ballsTakenA\n        newcolorsCountA = colorsCountA + (ballsTakenA > 0)\n        newcolorsCountB = colorsCountB + (ballsTakenB > 0)\n        ans += (cases(i + 1,\n                      ballsCountA + ballsTakenA,\n                      ballsCountB + ballsTakenB,\n                      newcolorsCountA, newcolorsCountB, boxCase) /\n                (fact[ballsTakenA] * fact[ballsTakenB]))\n\n      return ans\n\n    return (cases(0, 0, 0, 0, 0, BoxCase.EQUAL_DISTANT_BALLS) /\n            cases(0, 0, 0, 0, 0, BoxCase.EQUAL_BALLS))",
      "title": "1467. Probability of a Two Boxes Having The Same Number of Distinct Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cc93274-87c3-4549-854a-0d3485feacd9",
      "code": "class Solution:\n  def shuffle(self, nums: list[int], n: int) -> list[int]:\n    ans = []\n    for a, b in zip(nums[:n], nums[n:]):\n      ans.append(a)\n      ans.append(b)\n    return ans",
      "title": "1470. Shuffle the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d0da512-3e46-4045-b19e-2381078e972c",
      "code": "class Solution:\n  def getStrongest(self, arr: list[int], k: int) -> list[int]:\n    arr.sort()\n\n    ans = []\n    median = arr[(len(arr) - 1) // 2]\n    l = 0\n    r = len(arr) - 1\n\n    for _ in range(k):\n      if median - arr[l] > arr[r] - median:\n        ans.append(arr[l])\n        l -= 1\n      else:\n        ans.append(arr[r])\n        r += 1\n\n    return ans",
      "title": "1471. The k Strongest Values in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27e3ca1c-2e65-49af-ace8-bcea6bd3471f",
      "code": "class Solution:\n  def deleteNodes(\n      self,\n      head: ListNode | None,\n      m: int,\n      n: int,\n  ) -> ListNode | None:\n    curr = head\n    prev = None  # prev.next == curr\n\n    while curr:\n      # Set the m-th node as `prev`.\n      for _ in range(m):\n        if not curr:\n          break\n        prev = curr\n        curr = curr.next\n      # Set the (m + n + 1)-th node as `curr`.\n      for _ in range(n):\n        if not curr:\n          break\n        curr = curr.next\n      # Delete the nodes [m + 1..n - 1].\n      prev.next = curr\n\n    return head",
      "title": "1474. Delete N Nodes After M Nodes of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f7e76c5-9219-4808-9a0b-703fd331dee8",
      "code": "class Solution:\n  def finalPrices(self, prices: list[int]) -> list[int]:\n    ans = prices.copy()\n    stack = []\n\n    for i, price in enumerate(prices):\n      # stack[-1] := i in the problem description.\n      while stack and prices[stack[-1]] >= price:\n        ans[stack.pop()] -= price\n      stack.append(i)\n\n    return ans",
      "title": "1475. Final Prices With a Special Discount in a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d1699d7-307f-43f8-bbfc-699b914c26cb",
      "code": "class Solution:\n  def runningSum(self, nums: list[int]) -> list[int]:\n    return itertools.accumulate(nums)",
      "title": "1480. Running Sum of 1d Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62b89ebb-a43e-4cba-aa84-285c52961474",
      "code": "class Solution:\n  def findLeastNumOfUniqueInts(self, arr: list[int], k: int) -> int:\n    minHeap = list(collections.Counter(arr).values())\n    heapq.heapify(minHeap)\n\n    # Greedily remove the k least frequent numbers to have the least number of unique integers.\n    while k > 0:\n      k -= heapq.heappop(minHeap)\n\n    return len(minHeap) + (1 if k < 0 else 0)",
      "title": "1481. Least Number of Unique Integers after K Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c6b0940-24cb-4e81-b3a6-4b4d1b4c8811",
      "code": "class Solution:\n  def minDays(self, bloomDay: list[int], m: int, k: int) -> int:\n    if len(bloomDay) < m * k:\n      return -1\n\n    def getBouquetCount(waitingDays: int) -> int:\n      \"\"\"\n      Returns the number of bouquets (k flowers needed) can be made after the\n      `waitingDays`.\n      \"\"\"\n      bouquetCount = 0\n      requiredFlowers = k\n      for day in bloomDay:\n        if day > waitingDays:\n          # Reset `requiredFlowers` since there was not enough adjacent flowers.\n          requiredFlowers = k\n        else:\n          requiredFlowers -= 1\n          if requiredFlowers == 0:\n            # Use k adjacent flowers to make a bouquet.\n            bouquetCount += 1\n            requiredFlowers = k\n      return bouquetCount\n\n    l = min(bloomDay)\n    r = max(bloomDay)\n\n    while l < r:\n      mid = (l + r) // 2\n      if getBouquetCount(mid) >= m:\n        r = mid\n      else:\n        l = mid + 1\n\n    return l",
      "title": "1482. Minimum Number of Days to Make m Bouquets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7cebe3e-8cc2-4aab-ab63-57fa8543a9fc",
      "code": "class Solution:\n  def xorOperation(self, n: int, start: int) -> int:\n    return functools.reduce(operator.xor,\n                            [start + 2 * i for i in range(n)])",
      "title": "1486. XOR Operation in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e1191ea-cfaa-47a8-ac60-8c5ee8e1e50b",
      "code": "class Solution:\n  def getFolderNames(self, names: list[str]) -> list[str]:\n    ans = []\n    nameToSuffix = {}\n\n    for name in names:\n      if name in nameToSuffix:\n        suffix = nameToSuffix[name] + 1\n        newName = self._getName(name, suffix)\n        while newName in nameToSuffix:\n          suffix += 1\n          newName = self._getName(name, suffix)\n        nameToSuffix[name] = suffix\n        nameToSuffix[newName] = 0\n        ans.append(newName)\n      else:\n        nameToSuffix[name] = 0\n        ans.append(name)\n\n    return ans\n\n  def _getName(self, name: str, suffix: int) -> str:\n    return name + '(' + str(suffix) + ')'",
      "title": "1487. Making File Names Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65d7afc8-9d22-450f-8bed-eb363d41777d",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def avoidFlood(self, rains: list[int]) -> list[int]:\n    ans = [-1] * len(rains)\n    lakeIdToFullDay = {}\n    emptyDays = SortedSet()  # indices of rains[i] == 0\n\n    for i, lakeId in enumerate(rains):\n      if lakeId == 0:\n        emptyDays.add(i)\n        continue\n        # The lake was full in a previous day. Greedily find the closest day\n        # to make the lake empty.\n      if lakeId in lakeIdToFullDay:\n        fullDay = lakeIdToFullDay[lakeId]\n        emptyDayIndex = emptyDays.bisect_right(fullDay)\n        if emptyDayIndex == len(emptyDays):  # Not found.\n          return []\n        # Empty the lake at this day.\n        emptyDay = emptyDays[emptyDayIndex]\n        ans[emptyDay] = lakeId\n        emptyDays.discard(emptyDay)\n      # The lake with `lakeId` becomes full at the day `i`.\n      lakeIdToFullDay[lakeId] = i\n\n    # Empty an arbitrary lake if there are remaining empty days.\n    for emptyDay in emptyDays:\n      ans[emptyDay] = 1\n\n    return ans",
      "title": "1488. Avoid Flood in The City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cd39421-c10a-4078-806c-6449def3fe11",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findCriticalAndPseudoCriticalEdges(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    criticalEdges = []\n    pseudoCriticalEdges = []\n\n    # Record the index information, so edges[i] := (u, v, weight, index).\n    for i in range(len(edges)):\n      edges[i].append(i)\n\n    # Sort by the weight.\n    edges.sort(key=lambda x: x[2])\n\n    def getMSTWeight(\n            firstEdge: list[int],\n            deletedEdgeIndex: int) -> int | float:\n      mstWeight = 0\n      uf = UnionFind(n)\n\n      if firstEdge:\n        uf.unionByRank(firstEdge[0], firstEdge[1])\n        mstWeight += firstEdge[2]\n\n      for u, v, weight, index in edges:\n        if index == deletedEdgeIndex:\n          continue\n        if uf.find(u) == uf.find(v):\n          continue\n        uf.unionByRank(u, v)\n        mstWeight += weight\n\n      root = uf.find(0)\n      if any(uf.find(i) != root for i in range(n)):\n        return math.inf\n\n      return mstWeight\n\n    mstWeight = getMSTWeight([], -1)\n\n    for edge in edges:\n      index = edge[3]\n      # Deleting the `edge` increases the weight of the MST or makes the MST\n      # invalid.\n      if getMSTWeight([], index) > mstWeight:\n        criticalEdges.append(index)\n      # If an edge can be in any MST, we can always add `edge` to the edge set.\n      elif getMSTWeight(edge, -1) == mstWeight:\n        pseudoCriticalEdges.append(index)\n\n    return [criticalEdges, pseudoCriticalEdges]",
      "title": "1489. Find Critical and Pseudo-Critical Edges in Minimum Spanning Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66239138-d860-46e8-ac06-784ef1aa5056",
      "code": "class Solution:\n  def average(self, salary: list[int]) -> float:\n    return (sum(salary) - max(salary) - min(salary)) / (len(salary) - 2)",
      "title": "1491. Average Salary Excluding the Minimum and Maximum Salary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "759c2aa3-9106-4e55-b6dc-801c12bf8f95",
      "code": "class Solution:\n  def kthFactor(self, n: int, k: int) -> int:\n    # If i is a divisor of n, then n // i is also a divisor of n. So, we can\n    # find all the divisors of n by processing the numbers <= sqrt(n).\n    factor = 1\n    i = 0  # the i-th factor\n\n    while factor < math.isqrt(n):\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return factor\n      factor += 1\n\n    factor = n // factor\n    while factor >= 1:\n      if n % factor == 0:\n        i += 1\n        if i == k:\n          return n // factor\n      factor -= 1\n\n    return -1",
      "title": "1492. The kth Factor of n",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b31d599-895c-45da-9508-5814f3adea11",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    zeros = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      if num == 0:\n        zeros += 1\n      while zeros == 2:\n        if nums[l] == 0:\n          zeros -= 1\n        l += 1\n      ans = max(ans, r - l)\n\n    return ans",
      "title": "1493. Longest Subarray of 1's After Deleting One Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37429405-0be9-4e47-8044-6ac451112c79",
      "code": "class Solution:\n  def minNumberOfSemesters(\n      self,\n      n: int,\n      relations: list[list[int]],\n      k: int,\n  ) -> int:\n    # dp[i] := the minimum number of semesters to take the courses, where i is\n    # the bitmask of the taken courses\n    dp = [n] * (1 << n)\n    # prereq[i] := bitmask of all dependencies of course i\n    prereq = [0] * n\n\n    for prevCourse, nextCourse in relations:\n      prereq[nextCourse - 1] |= 1 << prevCourse - 1\n\n    dp[0] = 0  # Don't need time to finish 0 course.\n\n    for i in range(1 << n):\n      # the bitmask of all the courses can be taken\n      coursesCanBeTaken = 0\n      # Can take the j-th course if i contains all of j's prerequisites.\n      for j in range(n):\n        if (i & prereq[j]) == prereq[j]:\n          coursesCanBeTaken |= 1 << j\n      # Don't take any course which is already taken.\n      # (i represents set of courses that are already taken)\n      coursesCanBeTaken &= ~i\n      # Enumerate every bitmask subset of `coursesCanBeTaken`.\n      s = coursesCanBeTaken\n      while s:\n        if s.bit_count() <= k:\n          # Any combination of courses (if <= k) can be taken now.\n          # i | s := combining courses taken with courses can be taken.\n          dp[i | s] = min(dp[i | s], dp[i] + 1)\n        s = (s - 1) & coursesCanBeTaken\n\n    return dp[-1]",
      "title": "1494. Parallel Courses II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "73022845-ad1c-44f0-8903-39eb293474bb",
      "code": "class Solution:\n  def canArrange(self, arr: list[int], k: int) -> bool:\n    count = [0] * k\n\n    for a in arr:\n      a %= k\n      count[a if a >= 0 else a + k] += 1\n\n    return (count[0] % 2 == 0 and\n            all(count[i] == count[k - i]\n                for i in range(1, k // 2 + 1)))",
      "title": "1497. Check If Array Pairs Are Divisible by k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02ccb9f2-4b01-49a9-8fd2-2686c1b27419",
      "code": "class Solution:\n  def numSubseq(self, nums: list[int], target: int) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n\n    nums.sort()\n\n    l = 0\n    r = n - 1\n    while l <= r:\n      if nums[l] + nums[r] <= target:\n        ans += pow(2, r - l, MOD)\n        l += 1\n      else:\n        r -= 1\n\n    return ans % MOD",
      "title": "1498. Number of Subsequences That Satisfy the Given Sum Condition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19d3f917-ddff-433e-a253-eaed45561dcb",
      "code": "class Solution:\n  def findMaxValueOfEquation(self, points: list[list[int]], k: int) -> int:\n    ans = -math.inf\n    maxQ = collections.deque()  # (y - x, x)\n\n    for x, y in points:\n      # Remove the invalid points, xj - xi > k\n      while maxQ and x - maxQ[0][1] > k:\n        maxQ.popleft()\n      if maxQ:\n        ans = max(ans, x + y + maxQ[0][0])\n      # Remove the points that contribute less value and have a bigger x.\n      while maxQ and y - x >= maxQ[-1][0]:\n        maxQ.pop()\n      maxQ.append((y - x, x))\n\n    return ans",
      "title": "1499. Max Value of Equation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7c883ca-689c-4dde-8799-37892f77f333",
      "code": "class Solution:\n  def numSubmat(self, mat: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(mat[0])\n\n    for row in mat:\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n      ans += self._count(hist)\n\n    return ans\n\n  def _count(self, hist: list[int]) -> int:\n    # submatrices[i] := the number of submatrices, where the i-th column is the\n    # right border\n    submatrices = [0] * len(hist)\n    stack = []\n\n    for i, h in enumerate(hist):\n      while stack and hist[stack[-1]] >= h:\n        stack.pop()\n      if stack:\n        prevIndex = stack[-1]\n        submatrices[i] = submatrices[prevIndex] + h * (i - prevIndex)\n      else:\n        submatrices[i] = h * (i + 1)\n      stack.append(i)\n\n    return sum(submatrices)",
      "title": "1504. Count Submatrices With All Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "101bf370-302b-479d-8ff0-95ca54ad49d3",
      "code": "class Solution:\n  def findRoot(self, tree: list['Node']) -> 'Node':\n    sum = 0\n\n    for node in tree:\n      sum ^= node.val\n      for child in node.children:\n        sum ^= child.val\n\n    for node in tree:\n      if node.val == sum:\n        return node",
      "title": "1506. Find Root of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ccf01417-a656-4ea7-92cd-e563c08a852c",
      "code": "class Solution:\n  def reformatDate(self, date: str) -> str:\n    monthToNumString = {\n        'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',\n        'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',\n        'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12',\n    }\n    day, month, year = date.split()\n    day = day[:-2] if len(day) == 4 else '0' + day[:-2]\n    return f'{year}-{monthToNumString[month]}-{day}'",
      "title": "1507. Reformat Date",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06de04db-99bd-4a93-9b2f-1ba03eb4bef6",
      "code": "class Solution:\n  def minDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    if n < 5:\n      return 0\n\n    ans = math.inf\n\n    nums.sort()\n\n    # 1. Change nums[0..i) to nums[i].\n    # 2. Change nums[n - 3 + i..n) to nums[n - 4 + i].\n    for i in range(4):\n      ans = min(ans, nums[n - 4 + i] - nums[i])\n\n    return ans",
      "title": "1509. Minimum Difference Between Largest and Smallest Value in Three Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4de85bcf-19b0-49fe-86dc-13017e6aedff",
      "code": "class Solution:\n  def maxProbability(\n      self,\n      n: int,\n      edges: list[list[int]],\n      succProb: list[float],\n      start: int,\n      end: int,\n  ) -> float:\n    graph = [[] for _ in range(n)]  # {a: [(b, probability_ab)]}\n    maxHeap = [(-1.0, start)]   # (the probability to reach u, u)\n    seen = [False] * n\n\n    for i, ((u, v), prob) in enumerate(zip(edges, succProb)):\n      graph[u].append((v, prob))\n      graph[v].append((u, prob))\n\n    while maxHeap:\n      prob, u = heapq.heappop(maxHeap)\n      prob *= -1\n      if u == end:\n        return prob\n      if seen[u]:\n        continue\n      seen[u] = True\n      for nextNode, edgeProb in graph[u]:\n        if seen[nextNode]:\n          continue\n        heapq.heappush(maxHeap, (-prob * edgeProb, nextNode))\n\n    return 0",
      "title": "1514. Path with Maximum Probability",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "521388d2-2ae8-463c-bb74-ff35c5d856c2",
      "code": "class Solution:\n  def getMinDistSum(self, positions: list[list[int]]) -> float:\n    def distSum(a: float, b: float) -> float:\n      return sum(math.sqrt((a - x)**2 + (b - y)**2)\n                 for x, y in positions)\n\n    ERR = 1e-6\n    currX = 50\n    currY = 50\n    ans = distSum(currX, currY)\n    step = 1\n\n    while step > ERR:\n      shouldDecreaseStep = True\n      for dx, dy in [(0, step), (0, -step), (step, 0), (-step, 0)]:\n        x = currX + dx\n        y = currY + dy\n        newDistSum = distSum(x, y)\n        if newDistSum < ans:\n          ans = newDistSum\n          currX = x\n          currY = y\n          shouldDecreaseStep = False\n      if shouldDecreaseStep:\n        step /= 10\n\n    return ans",
      "title": "1515. Best Position for a Service Centre",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7e14118-98b0-49ff-850c-e7565ec9ca72",
      "code": "class Solution:\n  def moveSubTree(self, root: 'Node', p: 'Node', q: 'Node') -> 'Node':\n    if p in q.children:\n      return root\n\n    # Create a dummy Node for the case when root == p\n    dummy = Node(None, [root])\n\n    # Get each parent of p and q\n    pParent = self._getParent(dummy, p)\n    qParent = self._getParent(p, q)\n\n    # Get p's original index in p's parent\n    pIndex = pParent.children.index(p)\n    pParent.children.pop(pIndex)\n\n    q.children.append(p)\n\n    # If q is in the p's subtree, qParent != None\n    if qParent:\n      qParent.children.remove(q)\n      pParent.children.insert(pIndex, q)\n\n    return dummy.children[0]\n\n  def _getParent(self, root: 'Node', target: 'Node') -> Optional['Node']:\n    for child in root.children:\n      if child == target:\n        return root\n      res = self._getParent(child, target)\n      if res:\n        return res\n    return None",
      "title": "1516. Move Sub-Tree of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93855325-8413-4651-8315-7101783618eb",
      "code": "class Solution:\n  def closestToTarget(self, arr: list[int], target: int) -> int:\n    ans = math.inf\n    dp = set()  # all the values of subarrays that end in the current number\n\n    for num in arr:\n      # Extend each subarray that ends in the dpious number. Due to\n      # monotonicity of the AND operation, the size of `dp` will be at most\n      # num.bit_count() + 1.\n      dp = {num} | {val & num for val in dp}\n      ans = min(ans, min(abs(target - val) for val in dp))\n\n    return ans",
      "title": "1521. Find a Value of a Mysterious Function Closest to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b766ce99-58ed-4706-ad82-eb0e2cddbcba",
      "code": "class Solution:\n  def diameter(self, root: 'Node') -> int:\n    ans = 0\n\n    def maxDepth(root: 'Node') -> int:\n      \"\"\"Returns the maximum depth of the subtree rooted at `root`.\"\"\"\n      nonlocal ans\n      maxSubDepth1 = 0\n      maxSubDepth2 = 0\n      for child in root.children:\n        maxSubDepth = maxDepth(child)\n        if maxSubDepth > maxSubDepth1:\n          maxSubDepth2 = maxSubDepth1\n          maxSubDepth1 = maxSubDepth\n        elif maxSubDepth > maxSubDepth2:\n          maxSubDepth2 = maxSubDepth\n      ans = max(ans, maxSubDepth1 + maxSubDepth2)\n      return 1 + maxSubDepth1\n\n    maxDepth(root)\n    return ans",
      "title": "1522. Diameter of N-Ary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7969725b-4fea-4a43-a676-5dffdc47cdb1",
      "code": "class Solution:\n  def numSplits(self, s: str) -> int:\n    n = len(s)\n    ans = 0\n    seen = set()\n    prefix = [0] * n\n    suffix = [0] * n\n\n    for i in range(n):\n      seen.add(s[i])\n      prefix[i] = len(seen)\n\n    seen.clear()\n\n    for i in reversed(range(n)):\n      seen.add(s[i])\n      suffix[i] = len(seen)\n\n    for i in range(n - 1):\n      if prefix[i] == suffix[i + 1]:\n        ans += 1\n\n    return ans",
      "title": "1525. Number of Good Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b8236af-afef-4a57-8add-7dd86b7a180e",
      "code": "class Solution:\n  def minNumberOperations(self, target: list[int]) -> int:\n    ans = target[0]\n\n    for a, b in zip(target, target[1:]):\n      if a < b:\n        ans += b - a\n\n    return ans",
      "title": "1526. Minimum Number of Increments on Subarrays to Form a Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5931b968-63fd-4a8e-91e3-cf332da41958",
      "code": "class Solution:\n  def getLengthOfOptimalCompression(self, s: str, k: int) -> int:\n    def getLength(maxFreq: int) -> int:\n      \"\"\"Returns the length to compress `maxFreq`.\"\"\"\n      if maxFreq == 1:\n        return 1  # c\n      if maxFreq < 10:\n        return 2  # [1-9]c\n      if maxFreq < 100:\n        return 3  # [1-9][0-9]c\n      return 4    # [1-9][0-9][0-9]c\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the length of optimal dp of s[i..n) with at most k deletion.\"\"\"\n      if k < 0:\n        return math.inf\n      if i == len(s) or len(s) - i <= k:\n        return 0\n\n      ans = math.inf\n      maxFreq = 0  # the maximum frequency in s[i..j]\n      count = collections.Counter()\n\n      # Make letters in s[i..j] be the same.\n      # Keep the letter that has the maximum frequency in this range and remove\n      # the other letters.\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        maxFreq = max(maxFreq, count[s[j]])\n        ans = min(ans, getLength(maxFreq) +\n                  dp(j + 1, k - (j - i + 1 - maxFreq)))\n\n      return ans\n\n    return dp(0, k)",
      "title": "1531. String Compression II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f84bb277-757b-4a87-bb8a-f2df723bd4e3",
      "code": "# \"\"\"\n# This is ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n# # Compares the sum of arr[l..r] with the sum of arr[x..y]\n# # return 1 if sum(arr[l..r]) > sum(arr[x..y])\n# # return 0 if sum(arr[l..r]) == sum(arr[x..y])\n# # return -1 if sum(arr[l..r]) < sum(arr[x..y])\n#   def compareSub(self, l: int, r: int, x: int, y: int) -> int:\n#\n# # Returns the length of the array\n#   def length(self) -> int:\n#\n\n\nclass Solution:\n  def getIndex(self, reader: 'ArrayReader') -> int:\n    l = 0\n    r = reader.length() - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if (r - l) % 2 == 0:\n        res = reader.compareSub(l, m - 1, m + 1, r)\n        if res == 0:\n          return m\n        if res == 1:\n          r = m - 1\n        else:  # res == -1\n          l = m + 1\n      else:\n        res = reader.compareSub(l, m, m + 1, r)\n        # res is either 1 or -1.\n        if res == 1:\n          r = m\n        else:  # res == -1\n          l = m + 1\n\n    return l",
      "title": "1533. Find the Index of the Large Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d24698f1-570d-459f-b89b-5b52aa339db4",
      "code": "class Solution:\n  def countGoodTriplets(self, arr: list[int], a: int, b: int, c: int) -> int:\n    return sum(abs(arr[i] - arr[j]) <= a and\n               abs(arr[j] - arr[k]) <= b and\n               abs(arr[i] - arr[k]) <= c\n               for i, j, k in itertools.combinations(range(len(arr)), 3))",
      "title": "1534. Count Good Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6d6d4f4-6176-4b8f-9149-5076bb45cfe4",
      "code": "class Solution:\n  def getWinner(self, arr: list[int], k: int) -> int:\n    ans = arr[0]\n    wins = 0\n\n    i = 1\n    while i < len(arr) and wins < k:\n      if arr[i] > ans:\n        ans = arr[i]\n        wins = 1\n      else:\n        wins += 1\n      i += 1\n\n    return ans",
      "title": "1535. Find the Winner of an Array Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f840189b-8334-4167-9b54-e8819e3408f6",
      "code": "class Solution:\n  def minSwaps(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n    # suffixZeros[i] := the number of suffix zeros in the i-th row\n    suffixZeros = [n if 1 not in row else row[::-1].index(1) for row in grid]\n\n    for i in range(n):\n      neededZeros = n - 1 - i\n      # Get the first row with suffix zeros >= `neededZeros` in suffixZeros[i:..n).\n      j = next((j for j in range(i, n) if suffixZeros[j] >= neededZeros), -1)\n      if j == -1:\n        return -1\n      # Move the rows[j] to the rows[i].\n      for k in range(j, i, -1):\n        suffixZeros[k] = suffixZeros[k - 1]\n      ans += j - i\n\n    return ans",
      "title": "1536. Minimum Swaps to Arrange a Binary Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2cfe98b8-853c-4855-87df-de96fcf6f965",
      "code": "class Solution:\n  def maxSum(self, nums1: list[int], nums2: list[int]) -> int:\n    # Keep the running the sum of `nums1` and `nums2` before the next rendezvous.\n    # Since `nums1` and `nums2` are increasing, move forward on the smaller one\n    # to ensure we don't miss any rendezvous. When meet rendezvous, choose the\n    # better path.\n    ans = 0\n    sum1 = 0  # sum(nums1) in (the prevoious rendezvous, the next rendezvous)\n    sum2 = 0  # sum(nums2) in (the prevoious rendezvous, the next rendezvous)\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] < nums2[j]:\n        sum1 += nums1[i]\n        i += 1\n      elif nums1[i] > nums2[j]:\n        sum2 += nums2[j]\n        j += 1\n      else:  # An rendezvous happens.\n        ans += max(sum1, sum2) + nums1[i]\n        sum1 = 0\n        sum2 = 0\n        i += 1\n        j += 1\n\n    while i < len(nums1):\n      sum1 += nums1[i]\n      i += 1\n\n    while j < len(nums2):\n      sum2 += nums2[j]\n      j += 1\n\n    return (ans + max(sum1, sum2)) % (10**9 + 7)",
      "title": "1537. Get the Maximum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c25fb10-0235-408c-928b-d94a70246e2c",
      "code": "# \"\"\"\n# This is the ArrayReader's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class ArrayReader(object):\n#   # Compares 4 different elements in the array\n#   # Returns 4 if the values of the 4 elements are the same (0 or 1).\n#   # Returns 2 if three elements have a value equal to 0 and one element has\n#   #           value equal to 1 or vice versa.\n#   # Returns 0 if two element have a value equal to 0 and two elements have a\n#   #           value equal to 1.\n#   def query(self, a: int, b: int, c: int, d: int) -> int:\n#\n#   # Returns the length of the array\n#   def length(self) -> int:\n#\n\nclass Solution:\n  def guessMajority(self, reader: 'ArrayReader') -> int:\n    n = reader.length()\n    query0123 = reader.query(0, 1, 2, 3)\n    query1234 = reader.query(1, 2, 3, 4)\n    zeros = 1  # the number of numbers that are same as `nums[0]`\n    nonZeros = 0  # the number of numbers that are different from `nums[0]`\n    indexNot0 = -1  # any index i s.t. nums[i] != nums[0]\n\n    # Find which group nums[1..3] belong to.\n    for i in range(1, 4):\n      abcd = [0] + [num for num in [1, 2, 3] if num != i] + [4]\n      if reader.query(*abcd) == query1234:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    # Find which group nums[4..n) belong to.\n    for i in range(4, n):\n      if reader.query(1, 2, 3, i) == query0123:  # nums[i] == nums[0]\n        zeros += 1\n      else:\n        nonZeros += 1\n        indexNot0 = i\n\n    if zeros == nonZeros:\n      return -1\n    if zeros > nonZeros:\n      return 0\n    return indexNot0",
      "title": "1538. Guess the Majority in a Hidden Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4f655f7-ce04-4f18-9748-b18fccbd7794",
      "code": "class Solution:\n  def canConvertString(self, s: str, t: str, k: int) -> bool:\n    if len(s) != len(t):\n      return False\n\n    # e.g. s = \"aab\", t = \"bbc\", so shiftCount[1] = 3\n    # 1. a -> b, need 1 move.\n    # 2. a -> b, need 1 + 26 moves.\n    # 3. b -> c, need 1 + 26 * 2 moves.\n    shiftCount = [0] * 26\n\n    for a, b in zip(s, t):\n      shift = (ord(b) - ord(a) + 26) % 26\n      if shift == 0:\n        continue\n      if shift + 26 * shiftCount[shift] > k:\n        return False\n      shiftCount[shift] += 1\n\n    return True",
      "title": "1540. Can Convert String in K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15d73007-fdd1-4c0c-b205-db1e64a6c9d3",
      "code": "class Solution:\n  def minInsertions(self, s: str) -> int:\n    neededRight = 0   # Increment by 2 for each '('.\n    missingLeft = 0   # Increment by 1 for each missing '('.\n    missingRight = 0  # Increment by 1 for each missing ')'.\n\n    for c in s:\n      if c == '(':\n        if neededRight % 2 == 1:\n          # e.g. '()(...'\n          missingRight += 1\n          neededRight -= 1\n        neededRight += 2\n      else:  # c == ')'\n        neededRight -= 1\n        if neededRight < 0:\n          # e.g. '()))...'\n          missingLeft += 1\n          neededRight += 2\n\n    return neededRight + missingLeft + missingRight",
      "title": "1541. Minimum Insertions to Balance a Parentheses String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0db725e-179a-4815-b8ea-6e79edb3d22d",
      "code": "class Solution:\n  def longestAwesome(self, s: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    prefixToIndex = [len(s)] * 1024\n    prefixToIndex[0] = -1\n\n    for i, c in enumerate(s):\n      prefix ^= 1 << int(c)\n      ans = max(ans, i - prefixToIndex[prefix])\n      for j in range(10):\n        ans = max(ans, i - prefixToIndex[prefix ^ 1 << j])\n      prefixToIndex[prefix] = min(prefixToIndex[prefix], i)\n\n    return ans",
      "title": "1542. Find Longest Awesome Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9f8099a-8ab8-413f-9162-881f6941776a",
      "code": "class Solution:\n  def makeGood(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if ans and self._is_bad_pair(ans[-1], c):\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)\n\n  def _is_bad_pair(self, a: str, b: str) -> bool:\n    return a != b and a.lower() == b.lower()",
      "title": "1544. Make The String Great",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f79c3265-6c70-4486-b8bc-2a1e4f182383",
      "code": "class Solution:\n  def findKthBit(self, n: int, k: int) -> str:\n    if n == 1:\n      return '0'\n    midIndex = pow(2, n - 1)  # 1-indexed\n    if k == midIndex:\n      return '1'\n    if k < midIndex:\n      return self.findKthBit(n - 1, k)\n    return '1' if self.findKthBit(n - 1, midIndex * 2 - k) == '0' else '0'",
      "title": "1545. Find Kth Bit in Nth Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "357e33a4-d811-4d29-99d3-581d9aa7f00d",
      "code": "class Solution:\n  def maxNonOverlapping(self, nums: list[int], target: int) -> int:\n    # Ending the subarray ASAP always has a better result.\n    ans = 0\n    prefix = 0\n    prefixes = {0}\n\n    # Greedily find the subarrays that equal to the target.\n    for num in nums:\n      # Check if there is a subarray ends in here and equals to the target.\n      prefix += num\n      if prefix - target in prefixes:\n        # Find one and discard all the prefixes that have been used.\n        ans += 1\n        prefix = 0\n        prefixes = {0}\n      else:\n        prefixes.add(prefix)\n\n    return ans",
      "title": "1546. Maximum Number of Non-Overlapping Subarrays With Sum Equals Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a7d8be4-feee-4a20-a469-5f5d7d6cffc1",
      "code": "class Solution:\n  def minCost(self, n: int, cuts: list[int]) -> int:\n    arr = sorted([0] + cuts + [n])\n\n    dp = [[0] * len(arr) for _ in range(len(arr))]\n\n    for d in range(2, len(arr)):\n      for i in range(len(arr) - d):\n        j = i + d\n        dp[i][j] = math.inf\n        for k in range(i + 1, j):\n          dp[i][j] = min(dp[i][j], arr[j] - arr[i] + dp[i][k] + dp[k][j])\n\n    return dp[0][len(arr) - 1]",
      "title": "1547. Minimum Cost to Cut a Stick",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0484189-bc5e-40ee-9633-c9f470353620",
      "code": "class Solution:\n  def mostSimilar(self, n: int, roads: list[list[int]], names: list[str],\n                  targetPath: list[str]) -> list[int]:\n    # cost[i][j] := the minimum cost to start from names[i] in path[j]\n    cost = [[-1] * len(targetPath) for _ in range(len(names))]\n    # next[i][j] := the best next of names[i] in path[j]\n    next = [[0] * len(targetPath) for _ in range(len(names))]\n    graph = [[] for _ in range(n)]\n\n    for u, v in roads:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    minDist = math.inf\n    start = 0\n\n    def dfs(nameIndex: int, pathIndex: int) -> int:\n      if cost[nameIndex][pathIndex] != -1:\n        return cost[nameIndex][pathIndex]\n\n      editDist = names[nameIndex] != targetPath[pathIndex]\n      if pathIndex == len(targetPath) - 1:\n        return editDist\n\n      minDist = math.inf\n\n      for v in graph[nameIndex]:\n        dist = dfs(v, pathIndex + 1)\n        if dist < minDist:\n          minDist = dist\n          next[nameIndex][pathIndex] = v\n\n      cost[nameIndex][pathIndex] = editDist + minDist\n      return editDist + minDist\n\n    for i in range(n):\n      dist = dfs(i, 0)\n      if dist < minDist:\n        minDist = dist\n        start = i\n\n    ans = []\n\n    while len(ans) < len(targetPath):\n      ans.append(start)\n      start = next[start][len(ans) - 1]\n\n    return ans",
      "title": "1548. The Most Similar Path in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "df752b21-a30e-4d2f-a5c2-13e19213a138",
      "code": "class Solution:\n  def threeConsecutiveOdds(self, arr: list[int]) -> bool:\n    count = 0\n    for a in arr:\n      count = 0 if a % 2 == 0 else count + 1\n      if count == 3:\n        return True\n    return False",
      "title": "1550. Three Consecutive Odds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aaf8b824-1d96-41c3-9962-cd5bb69c606f",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    def arr(self, i: int) -> int:\n      \"\"\"Returns the i-th element of `arr`, where 1 <= i <= n.\"\"\"\n      return (i - 1) * 2 + 1\n\n    #     median := median of arr\n    #   diffs[i] := median - arr[i] where i <= i <= n // 2\n    #        ans := sum(diffs)\n    # e.g.\n    # n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n    #        ans = (4 + 2) * 2 // 2 = 6\n    # n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n    #        ans = (5 + 1) * 3 // 2 = 9\n    halfSize = n // 2\n    median = (arr(n) + arr(1)) // 2\n    firstDiff = median - arr(1)\n    lastDiff = median - arr(halfSize)\n    return (firstDiff + lastDiff) * halfSize // 2",
      "title": "1551. Minimum Operations to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4416249e-dada-4329-b485-9c7efcac1c45",
      "code": "class Solution:\n  def maxDistance(self, position: list[int], m: int) -> int:\n    position.sort()\n\n    l = 1\n    r = position[-1] - position[0]\n\n    def numBalls(force: int) -> int:\n      balls = 0\n      prevPosition = -force\n      for pos in position:\n        if pos - prevPosition >= force:\n          balls += 1\n          prevPosition = pos\n      return balls\n\n    while l < r:\n      mid = r - (r - l) // 2\n      if numBalls(mid) >= m:\n        l = mid\n      else:\n        r = mid - 1\n\n    return l",
      "title": "1552. Magnetic Force Between Two Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ed7c677-68bc-43c7-a753-a60d974f1bdb",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def minDays(self, n: int) -> int:\n    if n <= 1:\n      return n\n    return 1 + min(self.minDays(n // 3) + n % 3,\n                   self.minDays(n // 2) + n % 2)",
      "title": "1553. Minimum Number of Days to Eat N Oranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7cc59a98-62b3-4b64-840c-5397c07ef5e5",
      "code": "class Solution:\n  def differByOne(self, dict: list[str]) -> bool:\n    BASE = 26\n    HASH = 1_000_000_007\n    m = len(dict[0])\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    def getHash(s: str) -> int:\n      \"\"\"Returns the hash of `s`. Assume the length of `s` is m.\n\n      e.g. getHash(s) = 26^(m - 1) * s[0] + 26^(m - 2) * s[1] + ... + s[m - 1].\n      \"\"\"\n      hash = 0\n      for c in s:\n        hash = (hash * BASE + val(c))\n      return hash\n\n    wordToHash = [getHash(word) for word in dict]\n\n    # Compute the hash without each letter.\n    # e.g. hash of \"abc\" = 26^2 * 'a' + 26 * 'b' + 'c'\n    #   newHash of \"a*c\" = hash - 26 * 'b'\n    coefficient = 1\n    for j in range(m - 1, -1, -1):\n      newHashToIndices = collections.defaultdict(list)\n      for i, (word, hash) in enumerate(zip(dict, wordToHash)):\n        newHash = (hash - coefficient * val(word[j]) % HASH + HASH) % HASH\n        if any(word[: j] == dict[index][: j] and word[j + 1:] ==\n               dict[index][j + 1:] for index in newHashToIndices[newHash]):\n          return True\n        newHashToIndices[newHash].append(i)\n      coefficient = coefficient * BASE % HASH\n\n    return False",
      "title": "1554. Strings Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "717544c7-e14b-43c1-b4e0-3544e858df24",
      "code": "class Solution:\n  def thousandSeparator(self, n: int) -> str:\n    return f'{n:,}'.replace(',', '.')",
      "title": "1556. Thousand Separator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "17d9df56-2e84-4cf0-8903-25059ae650ac",
      "code": "class Solution:\n  def findSmallestSetOfVertices(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    inDegrees = [0] * n\n\n    for _, v in edges:\n      inDegrees[v] += 1\n\n    return [i for i, d in enumerate(inDegrees) if d == 0]",
      "title": "1557. Minimum Number of Vertices to Reach All Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f703eac-45a2-4c43-bac0-fa9341116bd1",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    mx = max(nums)\n    return (sum(num.bit_count() for num in nums) +\n            (0 if mx == 0 else mx.bit_length() - 1))",
      "title": "1558. Minimum Numbers of Function Calls to Make Target Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b86eaa29-5851-4f0d-bf21-00fa86c2369e",
      "code": "class Solution:\n  def mostVisited(self, n: int, rounds: list[int]) -> list[int]:\n    # 1. if start <= end, [start, end] is the most visited.\n    #\n    #      s --------- n\n    # 1 -------------- n\n    # 1 ------ e\n    #\n    # 2. if start > end, [1, end] and [start, n] are the most visited.\n    #\n    #             s -- n\n    # 1 -------------- n\n    # 1 ------ e\n    start = rounds[0]\n    end = rounds[-1]\n    if start <= end:\n      return range(start, end + 1)\n    return list(range(1, end + 1)) + list(range(start, n + 1))",
      "title": "1560. Most Visited Sector in a Circular Track",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "86076d2a-0e29-470c-a59c-656f92a6dc0b",
      "code": "class Solution:\n  def maxCoins(self, piles: list[int]) -> int:\n    return sum(sorted(piles)[len(piles) // 3::2])",
      "title": "1561. Maximum Number of Coins You Can Get",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2e921ea-2667-4a6b-b147-69f03f027095",
      "code": "class Solution:\n  def findLatestStep(self, arr: list[int], m: int) -> int:\n    if len(arr) == m:\n      return len(arr)\n\n    ans = -1\n    step = 0\n    # sizes[i] := the size of the group starting from i or ending in i\n    # (1-indexed)\n    sizes = [0] * (len(arr) + 2)\n\n    for i in arr:\n      step += 1\n      # In the previous step, there exists a group with a size of m.\n      if sizes[i - 1] == m or sizes[i + 1] == m:\n        ans = step - 1\n      head = i - sizes[i - 1]\n      tail = i + sizes[i + 1]\n      sizes[head] = tail - head + 1\n      sizes[tail] = tail - head + 1\n\n    return ans",
      "title": "1562. Find Latest Group of Size M",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbf37bb8-5971-405c-83fe-3fb25d120e7a",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    realWarehouse = [warehouse[0]]\n\n    for i in range(1, len(warehouse)):\n      realWarehouse.append(min(realWarehouse[-1], warehouse[i]))\n\n    boxes.sort()\n    i = 0  # boxes' index\n    for height in reversed(realWarehouse):\n      if i < len(boxes) and boxes[i] <= height:\n        i += 1\n\n    return i",
      "title": "1564. Put Boxes Into the Warehouse I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb73a154-4f8c-484e-abaa-949da0c7d0c7",
      "code": "class Solution:\n  def containsPattern(self, arr: list[int], m: int, k: int) -> bool:\n    count = 0\n    for i in range(m, len(arr)):\n      count = count + 1 if arr[i] == arr[i - m] else 0\n      if count == m * k - m:\n        return True\n    return False",
      "title": "1566. Detect Pattern of Length M Repeated K or More Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1f30d19-e89c-4756-b86b-f1db09208372",
      "code": "class Solution:\n  def getMaxLen(self, nums: list[int]) -> int:\n    ans = 0\n    # the maximum length of subarrays ending in `num` with a negative product\n    neg = 0\n    # the maximum length of subarrays ending in `num` with a positive product\n    pos = 0\n\n    for num in nums:\n      pos = 0 if num == 0 else pos + 1\n      neg = 0 if num == 0 or neg == 0 else neg + 1\n      if num < 0:\n        pos, neg = neg, pos\n      ans = max(ans, pos)\n\n    return ans",
      "title": "1567. Maximum Length of Subarray With Positive Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "657197c2-0358-4c59-ae2b-bc18bbc424d7",
      "code": "class Solution:\n  def minDays(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    def dfs(grid: list[list[int]], i: int, j: int, seen: set[tuple[int, int]]):\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or (x, y) in seen:\n          continue\n        dfs(grid, x, y, seen)\n\n    def disconnected(grid: list[list[int]]) -> bool:\n      islandsCount = 0\n      seen = set()\n      for i in range(m):\n        for j in range(n):\n          if grid[i][j] == 0 or (i, j) in seen:\n            continue\n          if islandsCount > 1:\n            return True\n          islandsCount += 1\n          dfs(grid, i, j, seen)\n      return islandsCount != 1\n\n    if disconnected(grid):\n      return 0\n\n    # Try to remove 1 land.\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1:\n          grid[i][j] = 0\n          if disconnected(grid):\n            return 1\n          grid[i][j] = 1\n\n    # Remove 2 lands.\n    return 2",
      "title": "1568. Minimum Number of Days to Disconnect Island",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37d3687d-7950-4a1d-8147-9ea1f6f1f35c",
      "code": "class Solution:\n  def diagonalSum(self, mat: list[list[int]]) -> int:\n    n = len(mat)\n    ans = 0\n\n    for i in range(n):\n      ans += mat[i][i]\n      ans += mat[n - 1 - i][i]\n\n    return ans if n % 2 == 0 else ans - mat[n // 2][n // 2]",
      "title": "1572. Matrix Diagonal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c81d988b-9ef0-4fb8-878f-ef38ee5e65a2",
      "code": "class Solution:\n  def numWays(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ones = s.count('1')\n    if ones % 3 != 0:\n      return 0\n    if ones == 0:\n      n = len(s)\n      return (n - 1) * (n - 2) // 2 % MOD\n\n    s1End = -1\n    s2Start = -1\n    s2End = -1\n    s3Start = -1\n    onesSoFar = 0\n\n    for i, c in enumerate(s):\n      if c == '1':\n        onesSoFar += 1\n      if s1End == -1 and onesSoFar == ones // 3:\n        s1End = i\n      elif s2Start == -1 and onesSoFar == ones // 3 + 1:\n        s2Start = i\n      if s2End == -1 and onesSoFar == ones // 3 * 2:\n        s2End = i\n      elif s3Start == -1 and onesSoFar == ones // 3 * 2 + 1:\n        s3Start = i\n\n    return (s2Start - s1End) * (s3Start - s2End) % MOD",
      "title": "1573. Number of Ways to Split a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac6201d6-9e39-4580-8b74-6e0839af91d3",
      "code": "class Solution:\n  def findLengthOfShortestSubarray(self, arr: list[int]) -> int:\n    n = len(arr)\n    l = 0\n    r = n - 1\n\n    # arr[0..l] is non-decreasing.\n    while l < n - 1 and arr[l + 1] >= arr[l]:\n      l += 1\n    # arr[r..n - 1] is non-decreasing.\n    while r > 0 and arr[r - 1] <= arr[r]:\n      r -= 1\n    # Remove arr[l + 1..n - 1] or arr[0..r - 1].\n    ans = min(n - 1 - l, r)\n\n    # Since arr[0..l] and arr[r..n - 1] are non-decreasing, we place pointers\n    # at the rightmost indices, l and n - 1, and greedily shrink them toward\n    # the leftmost indices, 0 and r, respectively. By removing arr[i + 1..j],\n    # we ensure that `arr` becomes non-decreasing.\n    i = l\n    j = n - 1\n    while i >= 0 and j >= r and j > i:\n      if arr[i] <= arr[j]:\n        j -= 1\n      else:\n        i -= 1\n      ans = min(ans, j - i)\n\n    return ans",
      "title": "1574. Shortest Subarray to be Removed to Make Array Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af0a584c-90d1-42a1-a62e-9ac396333efe",
      "code": "class Solution:\n  def countRoutes(\n      self,\n      locations: list[int],\n      start: int,\n      finish: int,\n      fuel: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    n = len(locations)\n    # dp[i][j] := the number of ways to reach the `finish` city from the i-th\n    # city with `j` fuel\n    dp = [[0] * (fuel + 1) for _ in range(n)]\n\n    for f in range(fuel + 1):\n      dp[finish][f] = 1\n\n    for f in range(fuel + 1):\n      for i in range(n):\n        for j in range(n):\n          if i == j:\n            continue\n          requiredFuel = abs(locations[i] - locations[j])\n          if requiredFuel <= f:\n            dp[i][f] += dp[j][f - requiredFuel]\n            dp[i][f] %= MOD\n\n    return dp[start][fuel]",
      "title": "1575. Count All Possible Routes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "01ae0ae1-b0c6-4e77-bf26-a7d6d3517080",
      "code": "class Solution:\n  def modifyString(self, s: str) -> str:\n    ans = []\n\n    def nextAvailable(ans: list[int], s: str, i: int) -> str:\n      c = 'a'\n      while ((i > 0 and ans[i - 1] == c) or\n             (i + 1 < len(s) and c == s[i + 1])):\n        c = chr(ord(c) + 1)\n      return c\n\n    for i, c in enumerate(s):\n      if c == '?':\n        ans.append(nextAvailable(ans, s, i))\n      else:\n        ans.append(c)\n\n    return ''.join(ans)",
      "title": "1576. Replace All ?'s to Avoid Consecutive Repeating Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6705ea8e-ba5c-4477-b1ec-f2b8837e467a",
      "code": "class Solution:\n  def numTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    def countTriplets(A: list[int], B: list[int]):\n      \"\"\"Returns the number of triplet (i, j, k) if A[i]^2 == B[j] * B[k].\"\"\"\n      res = 0\n      count = collections.Counter(B)\n\n      for a in A:\n        target = a * a\n        for b, freq in count.items():\n          if target % b > 0 or target // b not in count:\n            continue\n          if target // b == b:\n            res += freq * (freq - 1)\n          else:\n            res += freq * count[target // b]\n\n      return res // 2\n\n    return countTriplets(nums1, nums2) + countTriplets(nums2, nums1)",
      "title": "1577. Number of Ways Where Square of Number Is Equal to Product of Two Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4fb1ab5e-ed9f-4f10-bf65-a47ae5568a09",
      "code": "class Solution:\n  def minCost(self, colors: str, neededTime: list[int]) -> int:\n    ans = 0\n    maxNeededTime = neededTime[0]\n\n    for i in range(1, len(colors)):\n      if colors[i] == colors[i - 1]:\n        ans += min(maxNeededTime, neededTime[i])\n        # For each continuous group, Bob needs to remove every balloon except\n        # the one with the maximum `neededTime`. So, he should hold the balloon\n        # with the highest `neededTime` in his hand.\n        maxNeededTime = max(maxNeededTime, neededTime[i])\n      else:\n        # If the current balloon is different from the previous one, discard\n        # the balloon from the previous group and hold the new one in hand.\n        maxNeededTime = neededTime[i]\n\n    return ans",
      "title": "1578. Minimum Time to Make Rope Colorful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfc79be8-22b8-4440-9672-e522bb8e4835",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    self.count -= 1\n    return True\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def maxNumEdgesToRemove(self, n: int, edges: list[list[int]]) -> int:\n    alice = UnionFind(n)\n    bob = UnionFind(n)\n    requiredEdges = 0\n\n    # Greedily put type 3 edges in the front.\n    for type_, u, v in sorted(edges, reverse=True):\n      u -= 1\n      v -= 1\n      if type_ == 3:  # Can be traversed by Alice and Bob.\n          # Note that we should use | instead of or because if the first\n          # expression is True, short-circuiting will skip the second\n          # expression.\n        if alice.unionByRank(u, v) | bob.unionByRank(u, v):\n          requiredEdges += 1\n      elif type_ == 2:  # Can be traversed by Bob.\n        if bob.unionByRank(u, v):\n          requiredEdges += 1\n      else:  # type == 1 Can be traversed by Alice.\n        if alice.unionByRank(u, v):\n          requiredEdges += 1\n\n    return (len(edges) - requiredEdges\n            if alice.count == 1 and bob.count == 1\n            else -1)",
      "title": "1579. Remove Max Number of Edges to Keep Graph Fully Traversable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4017cfe9-a2f8-40df-8abe-2e33dcb69153",
      "code": "class Solution:\n  def maxBoxesInWarehouse(self, boxes: list[int], warehouse: list[int]) -> int:\n    l = 0\n    r = len(warehouse) - 1\n\n    for box in sorted(boxes, reverse=True):\n      if l > r:\n        return len(warehouse)\n      if box <= warehouse[l]:\n        l += 1\n      elif box <= warehouse[r]:\n        r -= 1\n\n    return l + (len(warehouse) - r - 1)",
      "title": "1580. Put Boxes Into the Warehouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55885890-f294-455a-8a8a-2f5a34e2b7d4",
      "code": "class Solution:\n  def numSpecial(self, mat: list[list[int]]) -> int:\n    m = len(mat)\n    n = len(mat[0])\n    ans = 0\n    rowOnes = [0] * m\n    colOnes = [0] * n\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1:\n          rowOnes[i] += 1\n          colOnes[j] += 1\n\n    for i in range(m):\n      for j in range(n):\n        if mat[i][j] == 1 and rowOnes[i] == 1 and colOnes[j] == 1:\n          ans += 1\n\n    return ans",
      "title": "1582. Special Positions in a Binary Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6c4676f-4979-41e6-9081-19c654883c26",
      "code": "class Solution:\n  def unhappyFriends(\n      self,\n      n: int,\n      preferences: list[list[int]],\n      pairs: list[list[int]],\n  ) -> int:\n    ans = 0\n    matches = [0] * n\n    prefer = [{} for _ in range(n)]\n\n    for x, y in pairs:\n      matches[x] = y\n      matches[y] = x\n\n    for i in range(n):\n      for j in range(n - 1):\n        prefer[i][preferences[i][j]] = j\n\n    for x in range(n):\n      for u in prefer[x].keys():\n        y = matches[x]\n        v = matches[u]\n        if prefer[x][u] < prefer[x][y] and prefer[u][x] < prefer[u][v]:\n          ans += 1\n          break\n\n    return ans",
      "title": "1583. Count Unhappy Friends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5350916-f396-4e76-b31d-c030687d52b8",
      "code": "class Solution:\n  def minCostConnectPoints(self, points: list[int]) -> int:\n    # dist[i] := the minimum distance to connect the points[i]\n    dist = [math.inf] * len(points)\n    ans = 0\n\n    for i in range(len(points) - 1):\n      for j in range(i + 1, len(points)):\n        # Try to connect the points[i] with the points[j].\n        dist[j] = min(dist[j], abs(points[i][0] - points[j][0]) +\n                      abs(points[i][1] - points[j][1]))\n        # Swap the points[j] (the point with the mnimum distance) with the\n        # points[i + 1].\n        if dist[j] < dist[i + 1]:\n          points[j], points[i + 1] = points[i + 1], points[j]\n          dist[j], dist[i + 1] = dist[i + 1], dist[j]\n      ans += dist[i + 1]\n\n    return ans",
      "title": "1584. Min Cost to Connect All Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3676f298-b016-4180-bbb2-af354059308a",
      "code": "class Solution:\n  def isTransformable(self, s: str, t: str) -> bool:\n    if collections.Counter(s) != collections.Counter(t):\n      return False\n\n    positions = [collections.deque() for _ in range(10)]\n\n    for i, c in enumerate(s):\n      positions[int(c)].append(i)\n\n    # For each digit in `t`, check if we can put this digit in `s` at the same\n    # position as `t`. Ensure that all the left digits are equal to or greater\n    # than it. This is because the only operation we can perform is sorting in\n    # ascending order. If there is a digit to the left that is smaller than it,\n    # we can never move it to the same position as in `t`. However, if all the\n    # digits to its left are equal to or greater than it, we can move it one\n    # position to the left until it reaches the same position as in `t`.\n    for c in t:\n      d = int(c)\n      front = positions[d].popleft()\n      for smaller in range(d):\n        if positions[smaller] and positions[smaller][0] < front:\n          return False\n\n    return True",
      "title": "1585. Check If String Is Transformable With Substring Sort Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "298c41ae-4301-4495-871f-af52f9fdec16",
      "code": "class Solution:\n  def sumOddLengthSubarrays(self, arr: list[int]) -> int:\n    ans = 0\n    # Maintain two sums of subarrays ending in the previous index.\n    # Each time we meet a new number, we'll consider 'how many times' it should\n    # contribute to the newly built subarrays by calculating the number of\n    # previous even/odd-length subarrays.\n    prevEvenSum = 0  # the sum of even-length subarrays\n    prevOddSum = 0  # the sum of odd-length subarrays\n\n    for i, a in enumerate(arr):\n      # (i + 1) // 2 := the number of previous odd-length subarrays.\n      currEvenSum = prevOddSum + ((i + 1) // 2) * a\n      # i // 2 + 1 := the number of previous even-length subarrays\n      # (including 0).\n      currOddSum = prevEvenSum + (i // 2 + 1) * a\n      ans += currOddSum\n      prevEvenSum = currEvenSum\n      prevOddSum = currOddSum\n\n    return ans",
      "title": "1588. Sum of All Odd Length Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bce976a-a898-4ac1-b52e-c8668747a55e",
      "code": "class Solution:\n  def maxSumRangeQuery(self, nums: list[int], requests: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # count[i] := the number of times nums[i] has been requested\n    count = [0] * len(nums)\n\n    for start, end in requests:\n      count[start] += 1\n      if end + 1 < len(nums):\n        count[end + 1] -= 1\n\n    for i in range(1, len(nums)):\n      count[i] += count[i - 1]\n\n    for num, c in zip(sorted(nums), sorted(count)):\n      ans += num * c\n      ans %= MOD\n\n    return ans",
      "title": "1589. Maximum Sum Obtained of Any Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38d5522c-a612-4534-bbc9-bf29f0aec968",
      "code": "class Solution:\n  def minSubarray(self, nums: list[int], p: int) -> int:\n    summ = sum(nums)\n    remainder = summ % p\n    if remainder == 0:\n      return 0\n\n    ans = len(nums)\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefix %= p\n      target = (prefix - remainder + p) % p\n      if target in prefixToIndex:\n        ans = min(ans, i - prefixToIndex[target])\n      prefixToIndex[prefix] = i\n\n    return -1 if ans == len(nums) else ans",
      "title": "1590. Make Sum Divisible by P",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "816f1084-af45-4bb0-b6db-0410cf13d15d",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def isPrintable(self, targetGrid: list[list[int]]) -> bool:\n    MAX_COLOR = 60\n    m = len(targetGrid)\n    n = len(targetGrid[0])\n\n    # graph[u] := {v1, v2} means v1 and v2 cover u\n    graph = [set() for _ in range(MAX_COLOR + 1)]\n\n    for color in range(1, MAX_COLOR + 1):\n      # Get the rectangle of the current color.\n      minI = m\n      minJ = n\n      maxI = -1\n      maxJ = -1\n      for i in range(m):\n        for j in range(n):\n          if targetGrid[i][j] == color:\n            minI = min(minI, i)\n            minJ = min(minJ, j)\n            maxI = max(maxI, i)\n            maxJ = max(maxJ, j)\n\n      # Add any color covering the current as the children.\n      for i in range(minI, maxI + 1):\n        for j in range(minJ, maxJ + 1):\n          if targetGrid[i][j] != color:\n            graph[color].add(targetGrid[i][j])\n\n    states = [State.INIT] * (MAX_COLOR + 1)\n\n    def hasCycle(u: int) -> bool:\n      if states[u] == State.VISITING:\n        return True\n      if states[u] == State.VISITED:\n        return False\n      states[u] = State.VISITING\n      if any(hasCycle(v) for v in graph[u]):\n        return True\n      states[u] = State.VISITED\n      return False\n\n    return not (any(hasCycle(i) for i in range(1, MAX_COLOR + 1)))",
      "title": "1591. Strange Printer II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27fd6840-675e-48ea-9dc0-bdabc9f2c46c",
      "code": "class Solution:\n  def connectTwoGroups(self, cost: list[list[int]]) -> int:\n    # minCosts[j] := the minimum cost of connecting group2's point j\n    minCosts = [min(col) for col in zip(*cost)]\n\n    @functools.lru_cache(None)\n    def dp(i: int, mask: int) -> int:\n      \"\"\"\n      Returns the minimum cost to connect group1's points[i..n) with group2's\n      points, where `mask` is the bitmask of the connected points in group2.\n      \"\"\"\n      if i == len(cost):\n        # All the points in group 1 are connected, so greedily assign the\n        # minimum cost for the unconnected points of group2.\n        return sum(minCost for j, minCost in enumerate(minCosts)\n                   if (mask >> j & 1) == 0)\n      return min(cost[i][j] + dp(i + 1, mask | 1 << j)\n                 for j in range(len(cost[0])))\n\n    return dp(0, 0)",
      "title": "1595. Minimum Cost to Connect Two Groups of Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "801ddfaa-1c4d-4573-9542-58e65d8ff0ff",
      "code": "class Solution:\n  def findNearestRightNode(\n      self,\n      root: TreeNode,\n      u: TreeNode,\n  ) -> TreeNode | None:\n    ans = None\n    targetDepth = -1\n\n    def dfs(root: TreeNode, depth: int) -> None:\n      nonlocal ans\n      nonlocal targetDepth\n      if not root:\n        return\n      if root == u:\n        targetDepth = depth\n        return\n      if depth == targetDepth and not ans:\n        ans = root\n        return\n      dfs(root.left, depth + 1)\n      dfs(root.right, depth + 1)\n\n    dfs(root, 0)\n    return ans",
      "title": "1602. Find Nearest Right Node in Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "943889fe-a1c4-4fe9-ba74-2429d0da2698",
      "code": "class Solution:\n  def alertNames(self, keyName: list[str], keyTime: list[str]) -> list[str]:\n    nameToMinutes = collections.defaultdict(list)\n\n    for name, time in zip(keyName, keyTime):\n      minutes = self._getMinutes(time)\n      nameToMinutes[name].append(minutes)\n\n    return sorted([name for name, minutes in nameToMinutes.items()\n                   if self._hasAlert(minutes)])\n\n  def _hasAlert(self, minutes: list[int]) -> bool:\n    if len(minutes) > 70:\n      return True\n    minutes.sort()\n    for i in range(2, len(minutes)):\n      if minutes[i - 2] + 60 >= minutes[i]:\n        return True\n    return False\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1604. Alert Using Same Key-Card Three or More Times in a One Hour Period",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af62defe-4d49-4d9e-bff4-96eab0e03b80",
      "code": "class Solution:\n  def restoreMatrix(self, rowSum: list[int],\n                    colSum: list[int]) -> list[list[int]]:\n    m = len(rowSum)\n    n = len(colSum)\n    ans = [[0] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = min(rowSum[i], colSum[j])\n        rowSum[i] -= ans[i][j]\n        colSum[j] -= ans[i][j]\n\n    return ans",
      "title": "1605. Find Valid Matrix Given Row and Column Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27305ca5-aa69-4585-a4de-5aa0e0bde4be",
      "code": "class Solution:\n  def specialArray(self, nums: list[int]) -> int:\n    nums.sort()\n\n    if nums[0] >= len(nums):\n      return len(nums)\n\n    for i, (a, b) in enumerate(itertools.pairwise(nums)):\n      count = len(nums) - i - 1\n      if a < count and b >= count:\n        return count\n\n    return -1",
      "title": "1608. Special Array With X Elements Greater Than or Equal X",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff9a08fe-6167-4a74-87b9-0eeada3ebeed",
      "code": "class Solution:\n  def isEvenOddTree(self, root: TreeNode | None) -> bool:\n    q = collections.deque([root])\n    isEven = True\n\n    while q:\n      prevVal = -math.inf if isEven else math.inf\n      for _ in range(sz):\n        node = q.popleft()\n        if isEven and (node.val % 2 == 0 or node.val <= prevVal):\n          return False  # invalid case on even level\n        if not isEven and (node.val % 2 == 1 or node.val >= prevVal):\n          return False  # invalid case on odd level\n        prevVal = node.val\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      isEven = not isEven\n\n    return True",
      "title": "1609. Even Odd Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "591b8826-8ab9-4cdc-a216-82694459356f",
      "code": "class Solution:\n  def visiblePoints(\n      self,\n      points: list[list[int]],\n      angle: int,\n      location: list[int],\n  ) -> int:\n    posX, posY = location\n    maxVisible = 0\n    same = 0\n    A = []\n\n    for x, y in points:\n      if x == posX and y == posY:\n        same += 1\n      else:\n        A.append(math.atan2(y - posY, x - posX))\n\n    A.sort()\n    A = A + [a + 2.0 * math.pi for a in A]\n\n    angleInRadians = math.pi * (angle / 180)\n\n    l = 0\n    for r in range(len(A)):\n      while A[r] - A[l] > angleInRadians:\n        l += 1\n      maxVisible = max(maxVisible, r - l + 1)\n\n    return maxVisible + same",
      "title": "1610. Maximum Number of Visible Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8400a208-7dc3-4457-a674-b52ce04a983b",
      "code": "class Solution:\n  def minimumOneBitOperations(self, n: int) -> int:\n    # Observation: e.g. n = 2^2\n    #        100 (2^2 needs 2^3 - 1 ops)\n    # op1 -> 101\n    # op2 -> 111\n    # op1 -> 110\n    # op2 -> 010 (2^1 needs 2^2 - 1 ops)\n    # op1 -> 011\n    # op2 -> 001 (2^0 needs 2^1 - 1 ops)\n    # op1 -> 000\n    #\n    # So 2^k needs 2^(k + 1) - 1 ops. Note this is reversible, i.e., 0 -> 2^k\n    # also takes 2^(k + 1) - 1 ops.\n\n    # e.g. n = 1XXX, our first goal is to change 1XXX -> 1100.\n    #   - If the second bit is 1, you only need to consider the cost of turning\n    #     the last 2 bits to 0.\n    #   - If the second bit is 0, you need to add up the cost of flipping the\n    #     second bit from 0 to 1.\n    # XOR determines the cost minimumOneBitOperations(1XXX^1100) accordingly.\n    # Then, 1100 -> 0100 needs 1 op. Finally, 0100 -> 0 needs 2^3 - 1 ops.\n    if n == 0:\n      return 0\n    # x is the largest 2^k <= n.\n    # x | x >> 1 -> x >> 1 needs 1 op.\n    #     x >> 1 -> 0      needs x = 2^k - 1 ops.\n    x = 1 << n.bit_length() - 1\n    return self.minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1",
      "title": "1611. Minimum One Bit Operations to Make Integers Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bff3ee90-d5ed-419b-ae65-a96a0b7d3e07",
      "code": "class Solution:\n  def checkEquivalence(self, root1: 'Node', root2: 'Node') -> bool:\n    count = collections.Counter()\n\n    def dfs(root: 'Node', add: int) -> None:\n      if not root:\n        return\n      if 'a' <= root.val <= 'z':\n        count[root.val] += add\n      dfs(root.left, add)\n      dfs(root.right, add)\n\n    dfs(root1, 1)\n    dfs(root2, -1)\n    return all(value == 0 for value in count.values())",
      "title": "1612. Check If Two Expression Trees are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d11a16e-d791-477f-a84a-ed37051712b9",
      "code": "class Solution:\n  def maxDepth(self, s: str) -> int:\n    ans = 0\n    opened = 0\n\n    for c in s:\n      if c == '(':\n        opened += 1\n        ans = max(ans, opened)\n      elif c == ')':\n        opened -= 1\n\n    return ans",
      "title": "1614. Maximum Nesting Depth of the Parentheses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2625bab-e47d-43a7-b6d0-b4780ac5f6d3",
      "code": "class Solution:\n  def maximalNetworkRank(self, n: int, roads: list[list[int]]) -> int:\n    degrees = [0] * n\n\n    for u, v in roads:\n      degrees[u] += 1\n      degrees[v] += 1\n\n    # Find the first maximum and the second maximum degrees.\n    maxDegree1 = 0\n    maxDegree2 = 0\n    for degree in degrees:\n      if degree > maxDegree1:\n        maxDegree2 = maxDegree1\n        maxDegree1 = degree\n      elif degree > maxDegree2:\n        maxDegree2 = degree\n\n    # There can be multiple nodes with `maxDegree1` or `maxDegree2`.\n    # Find the counts of such nodes.\n    countMaxDegree1 = 0\n    countMaxDegree2 = 0\n    for degree in degrees:\n      if degree == maxDegree1:\n        countMaxDegree1 += 1\n      elif degree == maxDegree2:\n        countMaxDegree2 += 1\n\n    if countMaxDegree1 == 1:\n      # 1. If there is only one node with degree = `maxDegree1`, then we'll\n      # need to use the node with degree = `maxDegree2`. The answer in general\n      # will be (maxDegree1 + maxDegree2), but if the two nodes that we're\n      # considering are connected, then we'll have to subtract 1.\n      edgeCount = (self._getEdgeCount(roads, degrees, maxDegree1, maxDegree2) +\n                   self._getEdgeCount(roads, degrees, maxDegree2, maxDegree1))\n      return maxDegree1 + maxDegree2 - (countMaxDegree2 == edgeCount)\n    else:\n      # 2. If there are more than one node with degree = `maxDegree1`, then we\n      # can consider `maxDegree1` twice, and we don't need to use `maxDegree2`.\n      # The answer in general will be 2 * maxDegree1, but if the two nodes that\n      # we're considering are connected, then we'll have to subtract 1.\n      edgeCount = self._getEdgeCount(roads, degrees, maxDegree1, maxDegree1)\n      maxPossibleEdgeCount = countMaxDegree1 * (countMaxDegree1 - 1) // 2\n      return 2 * maxDegree1 - (maxPossibleEdgeCount == edgeCount)\n\n  def _getEdgeCount(\n      self,\n      roads: list[list[int]],\n      degrees: list[int],\n      degreeU: int, degreeV: int,\n  ) -> int:\n    \"\"\"\n    Returns the number of edges (u, v) where degress[u] == degreeU and\n    degrees[v] == degreeV.\n    \"\"\"\n    edgeCount = 0\n    for u, v in roads:\n      if degrees[u] == degreeU and degrees[v] == degreeV:\n        edgeCount += 1\n    return edgeCount",
      "title": "1615. Maximal Network Rank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "645d7fcd-25cf-4d64-8a06-814b1cf3f349",
      "code": "class Solution:\n  def checkPalindromeFormation(self, a: str, b: str) -> bool:\n    return self._check(a, b) or self._check(b, a)\n\n  def _check(self, a: str, b: str) -> bool:\n    i, j = 0, len(a) - 1\n    while i < j:\n      if a[i] != b[j]:\n        # a[0:i] + a[i..j] + b[j + 1:] or\n        # a[0:i] + b[i..j] + b[j + 1:]\n        return self._isPalindrome(a, i, j) or self._isPalindrome(b, i, j)\n      i += 1\n      j -= 1\n    return True\n\n  def _isPalindrome(self, s: str, i: int, j: int) -> bool:\n    while i < j:\n      if s[i] != s[j]:\n        return False\n      i += 1\n      j -= 1\n    return True",
      "title": "1616. Split Two Strings to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a23bde05-1fc7-40c7-8c65-4e0aeadca0db",
      "code": "class Solution:\n  def countSubgraphsForEachDiameter(\n      self,\n      n: int,\n      edges: list[list[int]],\n  ) -> list[int]:\n    maxMask = 1 << n\n    dist = self._floydWarshall(n, edges)\n    ans = [0] * (n - 1)\n\n    # mask := the subset of the cities\n    for mask in range(maxMask):\n      maxDist = self._getMaxDist(mask, dist, n)\n      if maxDist > 0:\n        ans[maxDist - 1] += 1\n\n    return ans\n\n  def _floydWarshall(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    dist = [[n] * n for _ in range(n)]\n\n    for i in range(n):\n      dist[i][i] = 0\n\n    for u, v in edges:\n      dist[u - 1][v - 1] = 1\n      dist[v - 1][u - 1] = 1\n\n    for k in range(n):\n      for i in range(n):\n        for j in range(n):\n          dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j])\n\n    return dist\n\n  def _getMaxDist(self, mask: int, dist: list[list[int]], n: int) -> int:\n    maxDist = 0\n    edgeCount = 0\n    cityCount = 0\n    for u in range(n):\n      if (mask >> u) & 1 == 0:  # u is not in the subset.\n        continue\n      cityCount += 1\n      for v in range(u + 1, n):\n        if (mask >> v) & 1 == 0:  # v is not in the subset.\n          continue\n        if dist[u][v] == 1:  # u and v are connected.\n          edgeCount += 1\n        maxDist = max(maxDist, dist[u][v])\n\n    return maxDist if edgeCount == cityCount - 1 else 0",
      "title": "1617. Count Subtrees With Max Distance Between Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68d5355d-2894-49e7-a1cf-45a77c55ee2c",
      "code": "# \"\"\"\n# This is FontInfo's API interface.\n# You should not implement it, or speculate about its implementation\n# \"\"\"\n# class FontInfo(object):\n#   Return the width of char ch when fontSize is used.\n#   def getWidth(self, fontSize: int, ch: str) -> int:\n#     pass\n#\n#   def getHeight(self, fontSize: int) -> int:\n#     pass\nclass Solution:\n  def maxFont(\n      self,\n      text: str,\n      w: int,\n      h: int,\n      fonts: list[int],\n      fontInfo: 'FontInfo',\n  ) -> int:\n    count = collections.Counter(text)\n    l = 0\n    r = len(fonts) - 1\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if fontInfo.getHeight(\n              fonts[m]) <= h and self._getWidthSum(\n              count, fonts[m],\n              fontInfo) <= w:\n        l = m\n      else:\n        r = m - 1\n\n    return fonts[l] if self._getWidthSum(count, fonts[l], fontInfo) <= w else -1\n\n  def _getWidthSum(\n      self,\n      count: list[int],\n      font: int,\n      fontInfo: 'FontInfo',\n  ) -> int:\n    width = 0\n    for c in string.ascii_lowercase:\n      width += count[c] * fontInfo.getWidth(font, c)\n    return width",
      "title": "1618. Maximum Font to Fit a Sentence in a Screen",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a3f526d-6838-4e74-902f-143f9923b831",
      "code": "class Solution:\n  def trimMean(self, arr: list[int]) -> float:\n    arr.sort()\n    offset = len(arr) // 20\n    return mean(arr[offset:-offset])",
      "title": "1619. Mean of Array After Removing Some Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2ecd382-cacf-4f03-9efc-e7dfd06a43e2",
      "code": "class Solution:\n  def bestCoordinate(self, towers: list[list[int]], radius: int) -> list[int]:\n    MAX = 50\n    n = len(towers)\n    ans = [0] * 2\n    maxQuality = 0\n\n    def dist(tower: list[int], i: int, j: int) -> float:\n      \"\"\"Returns the distance between the tower and the coordinate.\"\"\"\n      return math.sqrt((tower[0] - i)**2 + (tower[1] - j)**2)\n\n    for i in range(MAX + 1):\n      for j in range(MAX + 1):\n        qualitySum = 0\n        for tower in towers:\n          q = tower[2]\n          d = dist(tower, i, j)\n          if d <= radius:\n            qualitySum += int(q / (1 + d))\n        if qualitySum > maxQuality:\n          maxQuality = qualitySum\n          ans = [i, j]\n\n    return ans",
      "title": "1620. Coordinate With Maximum Network Quality",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a73493f-c4ad-447b-9e26-7523a9cc9a31",
      "code": "class Solution:\n  def numberOfSets(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int, drawing: bool) -> int:\n      if k == 0:  # Find a way to draw k segments.\n        return 1\n      if i == n:  # Reach the end.\n        return 0\n      if drawing:\n        # 1. Keep drawing at i and move to i + 1.\n        # 2. Stop at i so decrease k. We can start from i for the next segment.\n        return (dp(i + 1, k, True) + dp(i, k - 1, False)) % MOD\n      # 1. Skip i and move to i + 1.\n      # 2. Start at i and move to i + 1.\n      return (dp(i + 1, k, False) + dp(i + 1, k, True)) % MOD\n\n    return dp(0, k, False)",
      "title": "1621. Number of Sets of K Non-Overlapping Line Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d559b736-09dd-4967-8bbd-a707b92d01a1",
      "code": "class Solution:\n  def maxLengthBetweenEqualCharacters(self, s: str) -> int:\n    ans = -1\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      if c not in lastSeen:\n        lastSeen[c] = i\n      else:\n        ans = max(ans, i - lastSeen[c] - 1)\n\n    return ans",
      "title": "1624. Largest Substring Between Two Equal Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "574d7596-df15-4589-ba21-0b79b7fee728",
      "code": "from dataclasses import dataclass\n\n\n@dataclass\nclass Player:\n  age: int\n  score: int\n\n\nclass Solution:\n  def bestTeamScore(self, scores: list[int], ages: list[int]) -> int:\n    n = len(scores)\n    players = [Player(age, score) for age, score in zip(ages, scores)]\n    # dp[i] := the maximum score of choosing the players[0..i] with the\n    # players[i] being selected\n    dp = [0] * n\n\n    # Sort by age descending, then by score descending\n    players.sort(key=lambda x: (-x.age, -x.score))\n\n    for i in range(n):\n      # For each player, choose it first\n      dp[i] = players[i].score\n      # players[j].age >= players[i].age since we sort in descending order.\n      # So, we only have to check that players[j].score >= players[i].score.\n      for j in range(i):\n        if players[j].score >= players[i].score:\n          dp[i] = max(dp[i], dp[j] + players[i].score)\n\n    return max(dp)",
      "title": "1626. Best Team With No Conflicts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cd1452a0-302b-410d-9af8-8937632a4c83",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> bool:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def areConnected(\n      self,\n      n: int,\n      threshold: int,\n      queries: list[list[int]],\n  ) -> list[bool]:\n    uf = UnionFind(n + 1)\n\n    for z in range(threshold + 1, n + 1):\n      for x in range(z * 2, n + 1, z):\n        uf.unionByRank(z, x)\n\n    return [uf.find(a) == uf.find(b) for a, b in queries]",
      "title": "1627. Graph Connectivity With Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f865794-cae9-49fa-94d5-418a4b861f8a",
      "code": "class Solution:\n  def slowestKey(self, releaseTimes: list[int], keysPressed: str) -> str:\n    ans = keysPressed[0]\n    maxDuration = releaseTimes[0]\n\n    for i in range(1, len(keysPressed)):\n      duration = releaseTimes[i] - releaseTimes[i-1]\n      if duration > maxDuration or (\n              duration == maxDuration and keysPressed[i] > ans):\n        ans = keysPressed[i]\n        maxDuration = duration\n\n    return ans",
      "title": "1629. Slowest Key",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba92aa9-e770-4177-80d3-f7c413ce9f9c",
      "code": "class Solution:\n  def checkArithmeticSubarrays(\n      self,\n      nums: list[int],\n      l: list[int],\n      r: list[int],\n  ) -> list[bool]:\n    return [self._isArithmetic(nums, a, b) for a, b in zip(l, r)]\n\n  def _isArithmetic(self, nums: list[int], l: int, r: int) -> bool:\n    if r - l < 2:\n      return True\n\n    numsSet = set()\n    mn = math.inf\n    mx = -math.inf\n\n    for i in range(l, r+1):\n      mn = min(mn, nums[i])\n      mx = max(mx, nums[i])\n      numsSet.add(nums[i])\n\n    if (mx - mn) % (r - l) != 0:\n      return False\n\n    interval = (mx - mn) // (r - l)\n    return all(mn + k * interval in numsSet\n               for k in range(1, r - l + 1))",
      "title": "1630. Arithmetic Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "95137de9-644c-4cfe-9007-b9df0deb0355",
      "code": "class Solution:\n  def minimumEffortPath(self, heights: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(heights)\n    n = len(heights[0])\n    # diff[i][j] := the maximum absolute difference to reach (i, j)\n    diff = [[math.inf] * n for _ in range(m)]\n    seen = set()\n\n    minHeap = [(0, 0, 0)]  # (d, i, j)\n    diff[0][0] = 0\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      seen.add((i, j))\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if (x, y) in seen:\n          continue\n        newDiff = abs(heights[i][j] - heights[x][y])\n        maxDiff = max(diff[i][j], newDiff)\n        if diff[x][y] > maxDiff:\n          diff[x][y] = maxDiff\n          heapq.heappush(minHeap, (diff[x][y], x, y))",
      "title": "1631. Path With Minimum Effort",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bbfe6eda-827c-49f7-8f4e-871d9c54c121",
      "code": "class UnionFind:\n  def __init__(self):\n    self.id = {}\n\n  def union(self, u: int, v: int) -> None:\n    self.id.setdefault(u, u)\n    self.id.setdefault(v, v)\n    i = self._find(u)\n    j = self._find(v)\n    if i != j:\n      self.id[i] = j\n\n  def getGroupIdToValues(self) -> dict[int, list[int]]:\n    groupIdToValues = collections.defaultdict(list)\n    for u in self.id.keys():\n      groupIdToValues[self._find(u)].append(u)\n    return groupIdToValues\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def matrixRankTransform(self, matrix: list[list[int]]) -> list[list[int]]:\n    m = len(matrix)\n    n = len(matrix[0])\n    ans = [[0] * n for _ in range(m)]\n    # {val: [(i, j)]}\n    valToGrids = collections.defaultdict(list)\n    # rank[i] := the maximum rank of the row or column so far\n    maxRankSoFar = [0] * (m + n)\n\n    for i, row in enumerate(matrix):\n      for j, val in enumerate(row):\n        valToGrids[val].append((i, j))\n\n    for _, grids in sorted(valToGrids.items()):\n      uf = UnionFind()\n      for i, j in grids:\n        # Union i-th row with j-th col.\n        uf.union(i, j + m)\n      for values in uf.getGroupIdToValues().values():\n        # Get the maximum rank of all the included rows and columns.\n        maxRank = max(maxRankSoFar[i] for i in values)\n        for i in values:\n          # Update all the rows and columns to maxRank + 1.\n          maxRankSoFar[i] = maxRank + 1\n      for i, j in grids:\n        ans[i][j] = maxRankSoFar[i]\n\n    return ans",
      "title": "1632. Rank Transform of a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cadb19f-4f05-46c1-96a9-e1279c68c447",
      "code": "# Definition for polynomial singly-linked list.\n# class PolyNode:\n#   def __init__(self, x=0, y=0, next=None):\n#     self.coefficient = x\n#     self.power = y\n#     self.next = next\n\nclass Solution:\n  def addPoly(self, poly1: 'PolyNode', poly2: 'PolyNode') -> 'PolyNode':\n    dummy = PolyNode()\n    curr = dummy\n    p = poly1  # poly1's pointer\n    q = poly2  # poly2's pointer\n\n    while p and q:\n      if p.power > q.power:\n        curr.next = PolyNode(p.coefficient, p.power)\n        curr = curr.next\n        p = p.next\n      elif p.power < q.power:\n        curr.next = PolyNode(q.coefficient, q.power)\n        curr = curr.next\n        q = q.next\n      else:  # p.power == q.power\n        sumCoefficient = p.coefficient + q.coefficient\n        if sumCoefficient != 0:\n          curr.next = PolyNode(sumCoefficient, p.power)\n          curr = curr.next\n        p = p.next\n        q = q.next\n\n    while p:\n      curr.next = PolyNode(p.coefficient, p.power)\n      curr = curr.next\n      p = p.next\n\n    while q:\n      curr.next = PolyNode(q.coefficient, q.power)\n      curr = curr.next\n      q = q.next\n\n    return dummy.next",
      "title": "1634. Add Two Polynomials Represented as Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "41373c59-0c1a-4967-9420-810f9cae56ed",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  num: int\n  freq: int\n\n  def __lt__(self, other):\n    if self.freq == other.freq:\n      return self.num > other.num\n    return self.freq < other.freq\n\n\nclass Solution:\n  def frequencySort(self, nums: list[int]) -> list[int]:\n    ans = []\n    heap = []\n\n    for num, freq in collections.Counter(nums).items():\n      heapq.heappush(heap, T(num, freq))\n\n    while len(heap) > 0:\n      num = heap[0].num\n      freq = heapq.heappop(heap).freq\n      ans.extend([num] * freq)\n\n    return ans",
      "title": "1636. Sort Array by Increasing Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2725501-8f49-4663-80c6-761cf3aaf588",
      "code": "class Solution:\n  def maxWidthOfVerticalArea(self, points: list[list[int]]) -> int:\n    xs = sorted([x for x, _ in points])\n    return max(b - a for a, b in itertools.pairwise(xs))",
      "title": "1637. Widest Vertical Area Between Two Points Containing No Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70ca41ed-76bf-43ba-a77b-c4e482e18bc0",
      "code": "class Solution:\n  def countSubstrings(self, s: str, t: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      ans += self._count(s, t, i, 0)\n\n    for j in range(1, len(t)):\n      ans += self._count(s, t, 0, j)\n\n    return ans\n\n  def _count(self, s: str, t: str, i: int, j: int) -> int:\n    \"\"\"Returns the number of substrings of s[i..n) and t[j:] that differ by one char.\"\"\"\n    res = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with zero different letter\n    dp0 = 0\n    # the number of substrings starting at s[i] and t[j] ending in the current\n    # index with one different letter\n    dp1 = 0\n\n    while i < len(s) and j < len(t):\n      if s[i] == t[j]:\n        dp0 += 1\n      else:\n        dp0, dp1 = 0, dp0 + 1\n      res += dp1\n      i += 1\n      j += 1\n\n    return res",
      "title": "1638. Count Substrings That Differ by One Character",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5513360-b810-45f3-8201-897f1ecbc7d0",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # dp[i][j] := the number of ways to form the first i characters of the\n    # `target` using the j first characters in each word\n    dp = [[0] * (wordLength + 1) for _ in range(len(target) + 1)]\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    dp[0][0] = 1\n\n    for i in range(len(target) + 1):\n      for j in range(wordLength):\n        if i < len(target):\n          # Pick the character target[i] from word[j].\n          dp[i + 1][j + 1] = dp[i][j] * counts[j][target[i]]\n          dp[i + 1][j + 1] %= MOD\n        # Skip the word[j].\n        dp[i][j + 1] += dp[i][j]\n        dp[i][j + 1] %= MOD\n\n    return dp[len(target)][wordLength]",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69fa2e29-1e67-4770-93c7-271560c2ebdd",
      "code": "class Solution:\n  def numWays(self, words: list[str], target: str) -> int:\n    MOD = 1_000_000_007\n    wordLength = len(words[0])\n    # counts[j] := the count map of words[i][j], where 0 <= i < |words|\n    counts = [collections.Counter() for _ in range(wordLength)]\n\n    for i in range(wordLength):\n      for word in words:\n        counts[i][word[i]] += 1\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int):\n      \"\"\"Returns the number of ways to form target[i..n) using word[j..n).\"\"\"\n      if i == len(target):\n        return 1\n      if j == wordLength:\n        return 0\n      return (dp(i + 1, j + 1) * counts[j][target[i]] + dp(i, j + 1)) % MOD\n\n    return dp(0, 0)",
      "title": "1639. Number of Ways to Form a Target String Given a Dictionary_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d1893be-8f07-4dbe-93fa-98bc77ca3f5d",
      "code": "class Solution:\n  def canFormArray(self, arr: list[int], pieces: list[list[int]]) -> bool:\n    concatenated = []\n    startToPiece = {piece[0]: piece for piece in pieces}\n\n    for a in arr:\n      concatenated += startToPiece.get(a, [])\n\n    return concatenated == arr",
      "title": "1640. Check Array Formation Through Concatenation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6567a989-7423-49e1-879f-26b1b49d8878",
      "code": "class Solution:\n  def furthestBuilding(\n      self,\n      heights: list[int],\n      bricks: int,\n      ladders: int,\n  ) -> int:\n    minHeap = []\n\n    for i, (a, b) in enumerate(itertools.pairwise(heights)):\n      diff = b - a\n      if diff <= 0:\n        continue\n      heapq.heappush(minHeap, diff)\n      # If we run out of ladders, greedily use as less bricks as possible.\n      if len(minHeap) > ladders:\n        bricks -= heapq.heappop(minHeap)\n      if bricks < 0:\n        return i\n\n    return len(heights) - 1",
      "title": "1642. Furthest Building You Can Reach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b044d15-d73c-40fc-afeb-9478b4c790db",
      "code": "class Solution:\n  def kthSmallestPath(self, destination: list[int], k: int) -> str:\n    ans = []\n    v, h = destination\n\n    for _ in range(h + v):\n      # If pick 'H', then we're able to reack 1, 2, ..., availableRank.\n      availableRank = math.comb(h + v - 1, v)\n      if availableRank >= k:  # Should pick 'H'.\n        ans.append('H')\n        h -= 1\n      else:  # Should pick 'V'.\n        k -= availableRank\n        ans.append('V')\n        v -= 1\n\n    return ''.join(ans)",
      "title": "1643. Kth Smallest Instructions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67a409e8-2b0e-45e5-a192-0fc993457fe0",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      p: 'TreeNode',\n      q: 'TreeNode',\n  ) -> 'TreeNode':\n    seenP = False\n    seenQ = False\n\n    def getLCA(root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n      nonlocal seenP\n      nonlocal seenQ\n      if not root:\n        return None\n      # Need to traverse the entire tree to update `seenP` and `seenQ`.\n      left = getLCA(root.left, p, q)\n      right = getLCA(root.right, p, q)\n      if root == p:\n        seenP = True\n        return root\n      if root == q:\n        seenQ = True\n        return root\n      if left and right:\n        return root\n      return left or right\n\n    lca = getLCA(root, p, q)\n    return lca if seenP and seenQ else None",
      "title": "1644. Lowest Common Ancestor of a Binary Tree II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6eee3345-a4fd-41f9-9709-68deb394acf5",
      "code": "class Solution:\n  def getMaximumGenerated(self, n: int) -> int:\n    if n == 0:\n      return 0\n    if n == 1:\n      return 1\n\n    nums = [0] * (n + 1)\n    nums[1] = 1\n\n    i = 1\n    while 2 * i + 1 <= n:\n      nums[2 * i] = nums[i]\n      nums[2 * i + 1] = nums[i] + nums[i + 1]\n      i += 1\n\n    return max(nums)",
      "title": "1646. Get Maximum in Generated Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11485dba-7bbd-4b09-9632-9a1fe8ea315f",
      "code": "class Solution:\n  def minDeletions(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter(s)\n    usedFreq = set()\n\n    for freq in count.values():\n      while freq > 0 and freq in usedFreq:\n        freq -= 1  # Delete ('a' + i).\n        ans += 1\n      usedFreq.add(freq)\n\n    return ans",
      "title": "1647. Minimum Deletions to Make Character Frequencies Unique",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f596f81e-6feb-46f9-b8e7-a791a8c0050e",
      "code": "class Solution:\n  def maxProfit(self, inventory: list[int], orders: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    largestCount = 1\n\n    def trapezoid(a: int, b: int) -> int:\n      return (a + b) * (a - b + 1) // 2\n\n    for a, b in itertools.pairwise(sorted(inventory, reverse=True) + [0]):\n      if a > b:\n        # If we are at the last inventory, or inventory[i] > inventory[i + 1].\n        # In either case, we will pick inventory[i - largestCount + 1..i].\n        pick = a - b\n        # We have run out of orders, so we need to recalculate the number of\n        # balls that we actually pick for inventory[i - largestCount + 1..i].\n        if largestCount * pick >= orders:\n          actualPick, remaining = divmod(orders, largestCount)\n          return (ans +\n                  largestCount * trapezoid(a, a - actualPick + 1) +\n                  remaining * (a - actualPick)) % MOD\n        ans += largestCount * trapezoid(a, a - pick + 1)\n        ans %= MOD\n        orders -= largestCount * pick\n      largestCount += 1",
      "title": "1648. Sell Diminishing-Valued Colored Balls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b8ab9660-9bd5-47b3-a650-c0137d1a906c",
      "code": "class Solution:\n  # Same as 160. Intersection of Two Linked Lists\n  def lowestCommonAncestor(self, p: 'Node', q: 'Node') -> 'Node':\n    a = p\n    b = q\n\n    while a != b:\n      a = a.parent if a else q\n      b = b.parent if b else p\n\n    return a",
      "title": "1650. Lowest Common Ancestor of a Binary Tree III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49f5591b-fb4c-4e2a-94ef-31c0b0e91e14",
      "code": "class Solution:\n  def decrypt(self, code: list[int], k: int) -> list[int]:\n    n = len(code)\n    ans = [0] * n\n    if k == 0:\n      return ans\n\n    summ = 0\n    start = 1 if k > 0 else n + k  # the start of the next k numbers\n    end = k if k > 0 else n - 1  # the end of the next k numbers\n\n    for i in range(start, end + 1):\n      summ += code[i]\n\n    for i in range(n):\n      ans[i] = summ\n      summ -= code[start % n]\n      start += 1\n      end += 1\n      summ += code[end % n]\n\n    return ans",
      "title": "1652. Defuse the Bomb",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a0b44c8-dfff-4601-8fa9-9caef1125474",
      "code": "class Solution:\n  # Same as 926. Flip String to Monotone Increasing\n  def minimumDeletions(self, s: str) -> int:\n    dp = 0  # the number of characters to be deleted to make subso far balanced\n    countB = 0\n\n    for c in s:\n      if c == 'a':\n        # 1. Delete 'a'.\n        # 2. Keep 'a' and delete the previous 'b's.\n        dp = min(dp + 1, countB)\n      else:\n        countB += 1\n\n    return dp",
      "title": "1653. Minimum Deletions to Make String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3b27ffbb-b446-4f62-8523-107583c7183b",
      "code": "from enum import Enum\n\n\nclass Direction(Enum):\n  FORWARD = 0\n  BACKWARD = 1\n\n\nclass Solution:\n  def minimumJumps(self, forbidden: list[int], a: int, b: int, x: int) -> int:\n    furthest = max(x + a + b, max(pos + a + b for pos in forbidden))\n    seenForward = {pos for pos in forbidden}\n    seenBackward = {pos for pos in forbidden}\n\n    # (direction, position)\n    q = collections.deque([(Direction.FORWARD, 0)])\n\n    ans = 0\n    while q:\n      for _ in range(len(q)):\n        dir, pos = q.popleft()\n        if pos == x:\n          return ans\n        forward = pos + a\n        backward = pos - b\n        if forward <= furthest and forward not in seenForward:\n          seenForward.add(forward)\n          q.append((Direction.FORWARD, forward))\n        # It cannot jump backward twice in a row.\n        if dir == Direction.FORWARD and backward >= 0 and backward not in seenBackward:\n          seenBackward.add(backward)\n          q.append((Direction.BACKWARD, backward))\n      ans += 1\n\n    return -1",
      "title": "1654. Minimum Jumps to Reach Home",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6042cde-11a1-4a9e-8687-1720b3d19e06",
      "code": "class Solution:\n  def canDistribute(self, nums: list[int], quantity: list[int]) -> bool:\n    freqs = list(collections.Counter(nums).values())\n    # validDistribution[i][j] := True if it's possible to distribute the i-th\n    # freq into a subset of quantity represented by the bitmask j\n    validDistribution = self._getValidDistribution(freqs, quantity)\n    n = len(freqs)\n    m = len(quantity)\n    maxMask = 1 << m\n    # dp[i][j] := true if it's possible to distribute freqs[i..n), where j is\n    # the bitmask of the selected quantity\n    dp = [[False] * maxMask for _ in range(n + 1)]\n    dp[n][maxMask - 1] = True\n\n    for i in range(n - 1, -1, -1):\n      for mask in range(maxMask):\n        dp[i][mask] = dp[i + 1][mask]\n        availableMask = ~mask & (maxMask - 1)\n        submask = availableMask\n        while submask > 0:\n          if validDistribution[i][submask]:\n            dp[i][mask] = dp[i][mask] or dp[i + 1][mask | submask]\n          submask = (submask - 1) & availableMask\n\n    return dp[0][0]\n\n  def _getValidDistribution(self, freqs: list[int],\n                            quantity: list[int]) -> list[list[bool]]:\n    maxMask = 1 << len(quantity)\n    validDistribution = [[False] * maxMask for _ in range(len(freqs))]\n    for i, freq in enumerate(freqs):\n      for mask in range(maxMask):\n        if freq >= self._getQuantitySum(quantity, mask):\n          validDistribution[i][mask] = True\n    return validDistribution\n\n  def _getQuantitySum(self, quantity: list[int], mask: int) -> int:\n    \"\"\"Returns the sum of the selected quantity represented by `mask`.\"\"\"\n    return sum(q for i, q in enumerate(quantity) if mask >> i & 1)",
      "title": "1655. Distribute Repeating Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4242c412-dcdc-413b-9e14-1ccd36bcbc3e",
      "code": "class Solution:\n  def closeStrings(self, word1: str, word2: str) -> bool:\n    if len(word1) != len(word2):\n      return False\n\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    if count1.keys() != count2.keys():\n      return False\n\n    return sorted(count1.values()) == sorted(count2.values())",
      "title": "1657. Determine if Two Strings Are Close",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff05ca87-9247-430b-9e38-fb86ea283181",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], x: int) -> int:\n    targetSum = sum(nums) - x\n    if targetSum == 0:\n      return len(nums)\n    maxLen = self._maxSubArrayLen(nums, targetSum)\n    return -1 if maxLen == -1 else len(nums) - maxLen\n\n  # Same as 325. Maximum Size Subarray Sum Equals k\n  def _maxSubArrayLen(self, nums: list[int], k: int) -> int:\n    res = -1\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, num in enumerate(nums):\n      prefix += num\n      target = prefix - k\n      if target in prefixToIndex:\n        res = max(res, i - prefixToIndex[target])\n      # No need to check the existence of the prefix since it's unique.\n      prefixToIndex[prefix] = i\n\n    return res",
      "title": "1658. Minimum Operations to Reduce X to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a6f8681-9680-473e-ba0e-236bb0146a34",
      "code": "class Solution:\n  def getMaxGridHappiness(\n      self,\n      m: int,\n      n: int,\n      introvertsCount: int,\n      extrovertsCount: int,\n  ) -> int:\n    def getPlacementCost(\n        i: int,\n        j: int,\n        inMask: int,\n        exMask: int,\n        diff: int,\n    ) -> int:\n      \"\"\"Calculates the cost based on left and up neighbors.\n\n      The `diff` parameter represents the happiness change due to the current\n      placed person in (i, j). We add `diff` each time we encounter a neighbor\n      (left or up) who is already placed.\n\n      1. If the neighbor is an introvert, we subtract 30 from cost.\n      2. If the neighbor is an extrovert, we add 20 to from cost.\n      \"\"\"\n      cost = 0\n      if i > 0:\n        if (1 << (n - 1)) & inMask:\n          cost += diff - 30\n        if (1 << (n - 1)) & exMask:\n          cost += diff + 20\n      if j > 0:\n        if 1 & inMask:\n          cost += diff - 30\n        if 1 & exMask:\n          cost += diff + 20\n      return cost\n\n    @functools.lru_cache(None)\n    def dp(\n        pos: int, inMask: int, exMask: int, inCount: int, exCount: int\n    ) -> int:\n      # `inMask` is the placement of introvert people in the last n cells.\n      # e.g. if we have m = 2, n = 3, i = 1, j = 1, then inMask = 0b101 means\n      #\n      # ? 1 0\n      # 1 x ? (x := current position)\n      i, j = divmod(pos, n)\n      if i == m:\n        return 0\n\n      shiftedInMask = (inMask << 1) & ((1 << n) - 1)\n      shiftedExMask = (exMask << 1) & ((1 << n) - 1)\n\n      skip = dp(pos + 1, shiftedInMask, shiftedExMask, inCount, exCount)\n      placeIntrovert = (\n          120 + getPlacementCost(i, j, inMask, exMask, -30) +\n          dp(pos + 1, shiftedInMask + 1, shiftedExMask, inCount - 1, exCount)\n          if inCount > 0\n          else -math.inf)\n      placeExtrovert = (\n          40 + getPlacementCost(i, j, inMask, exMask, 20) +\n          dp(pos + 1, shiftedInMask, shiftedExMask + 1, inCount, exCount - 1)\n          if exCount > 0\n          else -math.inf)\n      return max(skip, placeIntrovert, placeExtrovert)\n\n    return dp(0, 0, 0, introvertsCount, extrovertsCount)",
      "title": "1659. Maximize Grid Happiness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37fc0048-940a-4e90-9459-2291b9b4cfa2",
      "code": "class Solution:\n  def __init__(self):\n    self.seen = set()\n\n  def correctBinaryTree(self, root: TreeNode | None) -> TreeNode | None:\n    if root == None:\n      return None\n    if root.right and root.right.val in self.seen:\n      return None\n    self.seen.add(root.val)\n    root.right = self.correctBinaryTree(root.right)\n    root.left = self.correctBinaryTree(root.left)\n    return root",
      "title": "1660. Correct a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba55c191-0e03-4100-96a4-c158af6ffb28",
      "code": "class Solution:\n  def arrayStringsAreEqual(self, word1: list[str], word2: list[str]) -> bool:\n    i = 0  # word1's index\n    j = 0  # word2's index\n    a = 0  # word1[i]'s index\n    b = 0  # word2[j]'s index\n\n    while i < len(word1) and j < len(word2):\n      if word1[i][a] != word2[j][b]:\n        return False\n      a += 1\n      if a == len(word1[i]):\n        i += 1\n        a = 0\n      b += 1\n      if b == len(word2[j]):\n        j += 1\n        b = 0\n\n    return i == len(word1) and j == len(word2)",
      "title": "1662. Check If Two String Arrays are Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9e29ceb8-0977-4924-ab26-63b982152ae3",
      "code": "class Solution:\n  def getSmallestString(self, n: int, k: int) -> str:\n    ans = []\n\n    for i in range(n):\n      remainingLetters = n - 1 - i\n      rank = max(1, k - remainingLetters * 26)\n      ans.append(chr(ord('a') + rank - 1))\n      k -= rank\n\n    return ''.join(ans)",
      "title": "1663. Smallest String With A Given Numeric Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51bbae1c-cb90-49d9-b30f-d7a8d5e09b78",
      "code": "class Solution:\n  def minimumEffort(self, tasks: list[list[int]]) -> int:\n    ans = 0\n    prevSaved = 0\n\n    for actual, minimum in sorted(tasks, key=lambda x: x[0] - x[1]):\n      if prevSaved < minimum:\n        ans += minimum - prevSaved\n        prevSaved = minimum - actual\n      else:\n        prevSaved -= actual\n\n    return ans",
      "title": "1665. Minimum Initial Energy to Finish Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60ab4b14-10d5-4299-b2da-98fd4449c9f5",
      "code": "class Solution:\n  def maxRepeating(self, sequence: str, word: str) -> int:\n    ans = 1\n    while word * ans in sequence:\n      ans += 1\n    return ans - 1",
      "title": "1668. Maximum Repeating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0aaba641-3f70-4a83-ba99-b406a1d51fa9",
      "code": "class Solution:\n  def mergeInBetween(\n      self,\n      list1: ListNode,\n      a: int,\n      b: int,\n      list2: ListNode,\n  ) -> ListNode:\n    nodeBeforeA = list1\n    for i in range(a - 1):\n      nodeBeforeA = nodeBeforeA.next\n\n    nodeB = nodeBeforeA.next\n    for i in range(b - a):\n      nodeB = nodeB.next\n\n    nodeBeforeA.next = list2\n    lastNodeInList2 = list2\n\n    while lastNodeInList2.next:\n      lastNodeInList2 = lastNodeInList2.next\n\n    lastNodeInList2.next = nodeB.next\n    nodeB.next = None\n    return list1",
      "title": "1669. Merge In Between Linked Lists",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb6570e3-f6ab-48ea-b64f-cffbbcf7e33a",
      "code": "class Solution:\n  def minimumMountainRemovals(self, nums: list[int]) -> int:\n    left = self._lengthOfLIS(nums)\n    right = self._lengthOfLIS(nums[::-1])[::-1]\n    maxMountainSeq = 0\n\n    for l, r in zip(left, right):\n      if l > 1 and r > 1:\n        maxMountainSeq = max(maxMountainSeq, l + r - 1)\n\n    return len(nums) - maxMountainSeq\n\n  # Similar to 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> list[int]:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    # dp[i] := the length of LIS ending in nums[i]\n    dp = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n      dp.append(len(tails))\n    return dp",
      "title": "1671. Minimum Number of Removals to Make Mountain Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8827890-bbd5-4a22-b44c-b674eec888c1",
      "code": "class Solution:\n  def maximumWealth(self, accounts: list[list[int]]) -> int:\n    return max(map(sum, accounts))",
      "title": "1672. Richest Customer Wealth",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a892439-6708-4464-bb8f-9917e7b58438",
      "code": "class Solution:\n  def mostCompetitive(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n\n    for i, num in enumerate(nums):\n      # If |ans| - 1 + |nums[i..n)| >= k, then it means we still have enough\n      # numbers, and we can safely pop an element from ans.\n      while ans and ans[-1] > nums[i] and len(ans) - 1 + len(nums) - i >= k:\n        ans.pop()\n      if len(ans) < k:\n        ans.append(nums[i])\n\n    return ans",
      "title": "1673. Find the Most Competitive Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fc35b6e-ed64-4f5b-b246-0d0a453947c3",
      "code": "class Solution:\n  def minMoves(self, nums: list[int], limit: int) -> int:\n    n = len(nums)\n    ans = n\n    # delta[i] := the number of moves needed when target goes from i - 1 to i\n    delta = [0] * (limit * 2 + 2)\n\n    for i in range(n // 2):\n      a = nums[i]\n      b = nums[n - 1 - i]\n      delta[min(a, b) + 1] -= 1\n      delta[a + b] -= 1\n      delta[a + b + 1] += 1\n      delta[max(a, b) + limit + 1] += 1\n\n    # Initially, we need `moves` when the target is 2.\n    moves = n\n    for i in range(2, limit * 2 + 1):\n      moves += delta[i]\n      ans = min(ans, moves)\n\n    return ans",
      "title": "1674. Minimum Moves to Make Array Complementary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a5f9e000-ac0b-463c-92b0-3d59b2482b09",
      "code": "class Solution:\n  def minimumDeviation(self, nums: list[int]) -> int:\n    ans = math.inf\n    mn = math.inf\n    maxHeap = []\n\n    for num in nums:\n      evenNum = num if num % 2 == 0 else num * 2\n      heapq.heappush(maxHeap, -evenNum)\n      mn = min(mn, evenNum)\n\n    while maxHeap[0] % 2 == 0:\n      mx = -heapq.heappop(maxHeap)\n      ans = min(ans, mx - mn)\n      mn = min(mn, mx // 2)\n      heapq.heappush(maxHeap, -mx // 2)\n\n    return min(ans, -maxHeap[0] - mn)",
      "title": "1675. Minimize Deviation in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "780bd77b-9e63-4892-b11f-ca5adda36f19",
      "code": "class Solution:\n  def lowestCommonAncestor(\n      self,\n      root: 'TreeNode',\n      nodes: 'list[TreeNode]',\n  ) -> 'TreeNode':\n    nodes = set(nodes)\n\n    def lca(root: 'TreeNode') -> 'TreeNode':\n      if not root:\n        return None\n      if root in nodes:\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    return lca(root)",
      "title": "1676. Lowest Common Ancestor of a Binary Tree IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3855cfe0-9fc0-4f2c-8f9e-bf796a445861",
      "code": "class Solution:\n  def interpret(self, command: str) -> str:\n    return command.replace('()', 'o').replace('(al)', 'al')",
      "title": "1678. Goal Parser Interpretation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c3c3d44-d8ef-4024-a8e2-59448b595edf",
      "code": "class Solution:\n  def maxOperations(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(min(count[num], count[k - num])\n               for num in count) // 2",
      "title": "1679. Max Number of K-Sum Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a156357-406c-4661-a2a6-b618107f5e4f",
      "code": "class Solution:\n  def concatenatedBinary(self, n: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    numberOfBits = 0\n\n    for i in range(1, n + 1):\n      if i.bit_count() == 1:\n        numberOfBits += 1\n      ans = ((ans << numberOfBits) + i) % MOD\n\n    return ans",
      "title": "1680. Concatenation of Consecutive Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a94eecd4-86c3-44e3-8369-a065d3f36bf5",
      "code": "class Solution:\n  def __init__(self):\n    self.MAX_NUM = 16\n\n  def minimumIncompatibility(self, nums: list[int], k: int) -> int:\n    MAX_COMPATIBILITY = (16 - 1) * (16 // 2)\n    n = len(nums)\n    subsetSize = n // k\n    maxMask = 1 << n\n    incompatibilities = self._getIncompatibilities(nums, subsetSize)\n\n    # dp[i] := the minimum possible sum of incompatibilities of the subset\n    # of numbers represented by the bitmask i\n    dp = [MAX_COMPATIBILITY] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      # The number of 1s in `mask` isn't a multiple of `subsetSize`.\n      if mask.bit_count() % subsetSize != 0:\n        continue\n      # https://cp-algorithms.com/algebra/all-submasks.html\n      submask = mask\n      while submask > 0:\n        if incompatibilities[submask] != -1:  # valid submask\n          dp[mask] = min(dp[mask], dp[mask - submask] +\n                         incompatibilities[submask])\n        submask = (submask - 1) & mask\n\n    return dp[-1] if dp[-1] != MAX_COMPATIBILITY else -1\n\n  def _getIncompatibilities(\n      self,\n      nums: list[int],\n      subsetSize: int,\n  ) -> list[int]:\n    \"\"\"\n    Returns an incompatibilities array where\n    * incompatibilities[i] := the incompatibility of the subset of numbers\n      represented by the bitmask i\n    * incompatibilities[i] := -1 if the number of 1s in the bitmask i is not\n      `subsetSize`\n    \"\"\"\n    maxMask = 1 << len(nums)\n    incompatibilities = [-1] * maxMask\n    for mask in range(maxMask):\n      if mask.bit_count() == subsetSize and self._isUnique(nums, mask, subsetSize):\n        incompatibilities[mask] = self._getIncompatibility(nums, mask)\n    return incompatibilities\n\n  def _isUnique(self, nums: list[int], mask: int, subsetSize: int) -> bool:\n    \"\"\"Returns True if the numbers selected by `mask` are unique.\"\"\"\n    used = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        used |= 1 << num\n    return used.bit_count() == subsetSize\n\n  def _getIncompatibility(self, nums: list[int], mask: int) -> int:\n    \"\"\"\n    Returns the incompatibility of the selected numbers represented by the\n    `mask`.\n    \"\"\"\n    mn = self.MAX_NUM\n    mx = 0\n    for i, num in enumerate(nums):\n      if mask >> i & 1:\n        mx = max(mx, num)\n        mn = min(mn, num)\n    return mx - mn",
      "title": "1681. Minimum Incompatibility",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6b5b39c3-de39-442f-ada0-69323fe1ba7f",
      "code": "class Solution:\n  def longestPalindromeSubseq(self, s: str) -> int:\n    n = len(s)\n    # dp[i][j][k] := the length of LPS(s[i..j]), where the previous letter is\n    # ('a' + k).\n    dp = [[[0] * 27 for _ in range(n)] for _ in range(n)]\n\n    for d in range(1, n):\n      for i in range(n - d):\n        for k in range(27):\n          j = i + d\n          if s[i] == s[j] and s[i] != chr(ord('a') + k):\n            dp[i][j][k] = dp[i + 1][j - 1][ord(s[i]) - ord('a')] + 2\n          else:\n            dp[i][j][k] = max(dp[i + 1][j][k], dp[i][j - 1][k])\n\n    return dp[0][n - 1][26]",
      "title": "1682. Longest Palindromic Subsequence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cf474e81-8a67-49ce-a084-5614aab88747",
      "code": "class Solution:\n  def countConsistentStrings(self, allowed: str, words: list[str]) -> int:\n    return sum(all(c in allowed for c in word)\n               for word in words)",
      "title": "1684. Count the Number of Consistent Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1e3d7af-af61-40e6-9370-1d4de6aea3d5",
      "code": "class Solution:\n  def getSumAbsoluteDifferences(self, nums: list[int]) -> list[int]:\n    prefix = list(itertools.accumulate(nums))\n    suffix = list(itertools.accumulate(nums[::-1]))[::-1]\n    return [num * (i + 1) - prefix[i] + suffix[i] - num * (len(nums) - i)\n            for i, num in enumerate(nums)]",
      "title": "1685. Sum of Absolute Differences in a Sorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "047a38ea-9283-4378-bbf9-fa1ce08c2e2f",
      "code": "class Solution:\n  def boxDelivering(\n      self,\n      boxes: list[list[int]],\n      portsCount: int,\n      maxBoxes: int,\n      maxWeight: int,\n  ) -> int:\n    n = len(boxes)\n    # dp[i] := the minimum trips to deliver boxes[0..i) and return to the\n    # storage\n    dp = [0] * (n + 1)\n    trips = 2\n    weight = 0\n\n    l = 0\n    for r in range(n):\n      weight += boxes[r][1]\n\n      # The current box is different from the previous one, need to make one\n      # more trip.\n      if r > 0 and boxes[r][0] != boxes[r - 1][0]:\n        trips += 1\n\n      # Loading boxes[l] in the previous turn is always no bad than loading it\n      # in this turn\n      while r - l + 1 > maxBoxes or weight > maxWeight or (\n              l < r and dp[l + 1] == dp[l]):\n        weight -= boxes[l][1]\n        if boxes[l][0] != boxes[l + 1][0]:\n          trips -= 1\n        l += 1\n\n      #   min trips to deliver boxes[0..r]\n      # = min trips to deliver boxes[0..l) + trips to deliver boxes[l..r]\n      dp[r + 1] = dp[l] + trips\n\n    return dp[n]",
      "title": "1687. Delivering Boxes from Storage to Ports",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a2c3911-4261-43b1-9e5c-b0887ccaf42a",
      "code": "class Solution:\n  def numberOfMatches(self, n: int) -> int:\n    return n - 1",
      "title": "1688. Count of Matches in Tournament",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f038cb09-c363-454a-979c-f5d0e5b7fbce",
      "code": "class Solution:\n  def minPartitions(self, n: str) -> int:\n    return int(max(n))",
      "title": "1689. Partitioning Into Minimum Number Of Deci-Binary Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "815038a9-ab3e-45a0-8eea-a19caafc046e",
      "code": "class Solution:\n  def reformatNumber(self, number: str) -> str:\n    ans = []\n\n    number = number.replace(\"-\", \"\").replace(\" \", \"\")\n\n    i = 0  # number's index\n    while i + 4 < len(number):\n      ans.append(number[i:i + 3] + '-')\n      i += 3\n\n    countFinalDigits = len(number) - i\n    if countFinalDigits < 4:\n      ans.append(number[i:])\n    else:  # countFinalDigits == 4\n      ans.append(number[i:i + 2] + '-' + number[i + 2:])\n\n    return ''.join(ans)",
      "title": "1694. Reformat Phone Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "266b6c26-4b4f-4752-a72e-6c4d869476be",
      "code": "class Solution:\n  def maximumUniqueSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    score = 0\n    seen = set()\n\n    l = 0\n    for r, num in enumerate(nums):\n      while num in seen:\n        score -= nums[l]\n        seen.remove(nums[l])\n        l += 1\n      seen.add(nums[r])\n      score += nums[r]\n      ans = max(ans, score)\n\n    return ans",
      "title": "1695. Maximum Erasure Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd1ba79d-d328-46a2-8d7d-1fb8f59b845f",
      "code": "class Solution:\n  def maxResult(self, nums: list[int], k: int) -> int:\n    # Stores dp[i] within the bounds.\n    maxQ = collections.deque([0])\n    # dp[i] := the maximum score to consider nums[0..i]\n    dp = [0] * len(nums)\n    dp[0] = nums[0]\n\n    for i in range(1, len(nums)):\n      # Pop the index if it's out-of-bounds.\n      if maxQ[0] + k < i:\n        maxQ.popleft()\n      dp[i] = dp[maxQ[0]] + nums[i]\n      # Pop indices that won't be chosen in the future.\n      while maxQ and dp[maxQ[-1]] <= dp[i]:\n        maxQ.pop()\n      maxQ.append(i)\n\n    return dp[-1]",
      "title": "1696. Jump Game VI",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "020124d2-b73e-4eb3-90b5-13c4adcc3dca",
      "code": "class Solution:\n  def countDistinct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n\n    n = len(s)\n    ans = 0\n    pow = [1] + [0] * n     # pow[i] := BASE^i\n    hashes = [0] * (n + 1)  # hashes[i] := the hash of s[0..i)\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for i in range(1, n + 1):\n      pow[i] = pow[i - 1] * BASE % HASH\n      hashes[i] = (hashes[i - 1] * BASE + val(s[i - 1])) % HASH\n\n    def getHash(l: int, r: int) -> int:\n      \"\"\"Returns the hash of s[l..r).\"\"\"\n      hash = (hashes[r] - hashes[l] * pow[r - l]) % HASH\n      return hash + HASH if hash < 0 else hash\n\n    for length in range(1, n + 1):\n      seen = set()\n      for i in range(n - length + 1):\n        seen.add(getHash(i, i + length))\n      ans += len(seen)\n\n    return ans",
      "title": "1698. Number of Distinct Substrings in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90dcaf5f-797b-4125-b0d9-c212b1e1fb2b",
      "code": "class Solution:\n  def countStudents(self, students: list[int], sandwiches: list[int]) -> int:\n    count = collections.Counter(students)\n\n    for i, sandwich in enumerate(sandwiches):\n      if count[sandwich] == 0:\n        return len(sandwiches) - i\n      count[sandwich] -= 1\n\n    return 0",
      "title": "1700. Number of Students Unable to Eat Lunch",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "53466b72-9917-411b-aa20-4e708848852b",
      "code": "class Solution:\n  def maximumBinaryString(self, binary: str) -> str:\n    #     e.g. binary = '100110'\n    # Do Operation 2 -> '100011'\n    # Do Operation 1 -> '111011'\n    # So, the index of the only '0' is prefixOnes + zeros - 1.\n    zeros = binary.count('0')\n    prefixOnes = binary.find('0')\n\n    # Make the entire string as 1s.\n    ans = ['1'] * len(binary)\n\n    # Make the only '0' if necessary.\n    if prefixOnes != -1:\n      ans[prefixOnes + zeros - 1] = '0'\n    return ''.join(ans)",
      "title": "1702. Maximum Binary String After Change",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b060a94-9ef8-48fe-90fe-a71c7bb4972d",
      "code": "class Solution:\n  def halvesAreAlike(self, s: str) -> bool:\n    VOWELS = 'aeiouAEIOU'\n    aVowelsCount = sum(c in VOWELS for c in s[:len(s) // 2])\n    bVowelsCount = sum(c in VOWELS for c in s[len(s) // 2:])\n    return aVowelsCount == bVowelsCount",
      "title": "1704. Determine if String Halves Are Alike",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "27ce52ce-4b84-436b-9d74-2489400e2e2c",
      "code": "class Solution:\n  def eatenApples(self, apples: list[int], days: list[int]) -> int:\n    n = len(apples)\n    ans = 0\n    minHeap = []  # (the rotten day, the number of apples)\n\n    i = 0\n    while i < n or minHeap:\n      # Remove the rotten apples.\n      while minHeap and minHeap[0][0] <= i:\n        heapq.heappop(minHeap)\n      # Add today's apples.\n      if i < n and apples[i] > 0:\n        heapq.heappush(minHeap, (i + days[i], apples[i]))\n      # Eat one apple today.\n      if minHeap:\n        rottenDay, numApples = heapq.heappop(minHeap)\n        if numApples > 1:\n          heapq.heappush(minHeap, (rottenDay, numApples - 1))\n        ans += 1\n      i += 1\n\n    return ans",
      "title": "1705. Maximum Number of Eaten Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43bf7e4a-1a01-4aff-9458-23dfc32b332c",
      "code": "class Solution:\n  def findBall(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i] := status of the i-th column\n    # -1 := empty, 0 := b0, 1 := b1, ...\n    dp = [i for i in range(n)]\n    # ans[i] := the i-th ball's final positio\n    ans = [-1] * n\n\n    for i in range(m):\n      newDp = [-1] * n\n      for j in range(n):\n        # out-of-bounds\n        if j + grid[i][j] < 0 or j + grid[i][j] == n:\n          continue\n        if (grid[i][j] == 1 and grid[i][j + 1] == -1 or\n                grid[i][j] == -1 and grid[i][j - 1] == 1):\n          continue\n        newDp[j + grid[i][j]] = dp[j]\n      dp = newDp\n\n    for i, ball in enumerate(dp):\n      if ball != -1:\n        ans[ball] = i\n\n    return ans",
      "title": "1706. Where Will the Ball Fall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bfaa8e3-1c94-4775-8ab2-b2d46bd582dc",
      "code": "from dataclasses import dataclass\n\n\nclass TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  x: int\n  m: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.x\n    yield self.m\n\n\nclass Solution:\n  def maximizeXor(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    ans = [-1] * len(queries)\n    maxBit = int(math.log2(max(max(nums), max(x for x, _ in queries))))\n    bitTrie = BitTrie(maxBit)\n\n    nums.sort()\n\n    i = 0  # nums' index\n    for queryIndex, x, m in sorted([IndexedQuery(i, x, m)\n                                    for i, (x, m) in enumerate(queries)],\n                                   key=lambda x: x.m):\n      while i < len(nums) and nums[i] <= m:\n        bitTrie.insert(nums[i])\n        i += 1\n      if i > 0 and nums[i - 1] <= m:\n        ans[queryIndex] = bitTrie.getMaxXor(x)\n\n    return ans",
      "title": "1707. Maximum XOR With an Element From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3db67e27-ab0d-4dd7-ac78-37e36ab0a72f",
      "code": "class Solution:\n  def largestSubarray(self, nums: list[int], k: int) -> list[int]:\n    mx = max(nums[:len(nums) - k + 1])\n    i = nums.index(mx)\n    return nums[i:i + k]",
      "title": "1708. Largest Subarray Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "761617a2-ee1c-413c-8c17-6f8f60908e48",
      "code": "class Solution:\n  def maximumUnits(self, boxTypes: list[list[int]], truckSize: int) -> int:\n    ans = 0\n\n    for boxes, units in sorted(boxTypes, key=lambda x: -x[1]):\n      if boxes >= truckSize:\n        return ans + truckSize * units\n      ans += boxes * units\n      truckSize -= boxes\n\n    return ans",
      "title": "1710. Maximum Units on a Truck",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "847f7d54-46eb-4996-96cd-1c20a84510cf",
      "code": "class Solution:\n  def countPairs(self, deliciousness: list[int]) -> int:\n    MOD = 10**9 + 7\n    MAX_BIT = 20 + 1\n    ans = 0\n    count = collections.Counter()\n\n    for d in deliciousness:\n      for i in range(MAX_BIT + 1):\n        power = 1 << i\n        ans += count[power - d]\n        ans %= MOD\n      count[d] += 1\n\n    return ans",
      "title": "1711. Count Good Meals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abe7f9e0-d071-4877-8078-97cf36e82868",
      "code": "class Solution:\n  def waysToSplit(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    ans = 0\n    prefix = list(itertools.accumulate(nums))\n\n    def firstGreaterEqual(i: int) -> int:\n      \"\"\"Finds the first index j s.t.\n         Mid = prefix[j] - prefix[i] >= left = prefix[i]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] >= prefix[i]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    def firstGreater(i: int) -> int:\n      \"\"\"Finds the first index k s.t.\n         mid = prefix[k] - prefix[i] > right = prefix[-1] - prefix[k]\n      \"\"\"\n      l = i + 1\n      r = n - 1\n      while l < r:\n        m = (l + r) // 2\n        if prefix[m] - prefix[i] > prefix[-1] - prefix[m]:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    for i in range(n - 2):\n      j = firstGreaterEqual(i)\n      if j == n - 1:\n        break\n      mid = prefix[j] - prefix[i]\n      right = prefix[-1] - prefix[j]\n      if mid > right:\n        continue\n      k = firstGreater(i)\n      ans = (ans + k - j) % MOD\n\n    return ans",
      "title": "1712. Ways to Split Array Into Three Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa1c416d-183e-4bc6-b223-4aca21732db2",
      "code": "class Solution:\n  def minOperations(self, target: list[int], arr: list[int]) -> int:\n    indices = []\n    numToIndex = {num: i for i, num in enumerate(target)}\n\n    for a in arr:\n      if a in numToIndex:\n        indices.append(numToIndex[a])\n\n    return len(target) - self._lengthOfLIS(indices)\n\n  # Same as 300. Longest Increasing Subsequence\n  def _lengthOfLIS(self, nums: list[int]) -> int:\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n    for num in nums:\n      if not tails or num > tails[-1]:\n        tails.append(num)\n      else:\n        tails[bisect.bisect_left(tails, num)] = num\n    return len(tails)",
      "title": "1713. Minimum Operations to Make a Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fdcfa97-78f9-41e5-8074-ca8de99e161b",
      "code": "class Solution:\n  def solve(self, nums: list[int], queries: list[list[int]]) -> list[int]:\n    MOD = 10**9 + 7\n    n = len(nums)\n    sqrtN = int(n**0.5)\n    # prefix[x][y] = sum(nums[x + ay]), where a >= 0 and x + ay < n\n    # Set prefix[i][j] to nums[i] to indicate the sequence starts with nums[i].\n    prefix = [[num] * sqrtN for num in nums]\n\n    for x in range(n - 1, -1, -1):\n      for y in range(1, sqrtN):\n        if x + y < n:\n          prefix[x][y] += prefix[x + y][y]\n          prefix[x][y] %= MOD\n\n    return [prefix[x][y] if y < sqrtN\n            else sum(nums[x::y]) % MOD\n            for x, y in queries]",
      "title": "1714. Sum Of Special Evenly-Spaced Elements In Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54bc0f17-8299-42bc-89ab-c4460bacc833",
      "code": "class Solution:\n  def totalMoney(self, n: int) -> int:\n    def trapezoid(a: int, b: int) -> int:\n      \"\"\"Returns sum(a..b).\"\"\"\n      return (a + b) * (b - a + 1) // 2\n\n    weeks = n // 7\n    firstWeek = trapezoid(1, 7)\n    lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1)\n    remainingDays = trapezoid(1 + weeks, n % 7 + weeks)\n    return (firstWeek + lastFullWeek) * weeks // 2 + remainingDays",
      "title": "1716. Calculate Money in Leetcode Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e1deb4f-0269-4603-9257-c2d2b7910317",
      "code": "class Solution:\n  def maximumGain(self, s: str, x: int, y: int) -> int:\n    # The assumption that gain('ab') > gain('ba') while removing 'ba' first is\n    # optimal is contradicted. Only 'b(ab)a' satisfies the condition of\n    # preventing two 'ba' removals, but after removing 'ab', we can still\n    # remove one 'ba', resulting in a higher gain. Thus, removing 'ba' first is\n    # not optimal.\n    return (self._gain(s, 'ab', x, 'ba', y) if x > y else\n            self._gain(s, 'ba', y, 'ab', x))\n\n  # Returns the points gained by first removing sub1 ('ab' | 'ba') from s with\n  # point1, then removing sub2 ('ab' | 'ba') from s with point2.\n  def _gain(self, s: str, sub1: str, point1: int, sub2: str, point2: int) -> int:\n    points = 0\n    stack1 = []\n    stack2 = []\n\n    # Remove 'sub1' from s with point1 gain.\n    for c in s:\n      if stack1 and stack1[-1] == sub1[0] and c == sub1[1]:\n        stack1.pop()\n        points += point1\n      else:\n        stack1.append(c)\n\n    # Remove 'sub2' from s with point2 gain.\n    for c in stack1:\n      if stack2 and stack2[-1] == sub2[0] and c == sub2[1]:\n        stack2.pop()\n        points += point2\n      else:\n        stack2.append(c)\n\n    return points",
      "title": "1717. Maximum Score From Removing Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "720a5b9d-31d2-4613-8a3e-c5cd470a2515",
      "code": "class Solution:\n  def constructDistancedSequence(self, n: int) -> list[int]:\n    ans = [0] * (2 * n - 1)\n\n    def dfs(i: int, mask: int) -> bool:\n      if i == len(ans):\n        return True\n      if ans[i] > 0:\n        return dfs(i + 1, mask)\n\n      # Greedily fill in `ans` in descending order.\n      for num in range(n, 0, -1):\n        if (mask >> num & 1) == 1:\n          continue\n        if num == 1:\n          ans[i] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i] = 0\n        else:  # num in [2, n]\n          if i + num >= len(ans) or ans[i + num] > 0:\n            continue\n          ans[i] = num\n          ans[i + num] = num\n          if dfs(i + 1, mask | 1 << num):\n            return True\n          ans[i + num] = 0\n          ans[i] = 0\n\n      return False\n\n    dfs(0, 0)\n    return ans",
      "title": "1718. Construct the Lexicographically Largest Valid Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0455f9fb-7367-4aab-85bd-cbb92f4a27f4",
      "code": "class Solution:\n  def checkWays(self, pairs: list[list[int]]) -> int:\n    MAX = 501\n    graph = collections.defaultdict(list)\n    degrees = [0] * MAX\n    connected = [[False] * MAX for _ in range(MAX)]\n\n    for u, v in pairs:\n      graph[u].append(v)\n      graph[v].append(u)\n      degrees[u] += 1\n      degrees[v] += 1\n      connected[u][v] = True\n      connected[v][u] = True\n\n    # For each node, sort its children by degrees in descending order.\n    for _, children in graph.items():\n      children.sort(key=lambda x: -degrees[x])\n\n    # Find the root with a degree that equals to n - 1.\n    root = next((i for i, d in enumerate(degrees) if d == len(graph) - 1), -1)\n    if root == -1:\n      return 0\n\n    hasMoreThanOneWay = False\n\n    def dfs(u: int, ancestors: list[int], seen: list[bool]) -> bool:\n      \"\"\"\n      Returns True if each node rooted at u is connected to all of its\n      ancestors.\n      \"\"\"\n      nonlocal hasMoreThanOneWay\n      seen[u] = True\n      for ancestor in ancestors:\n        if not connected[u][ancestor]:\n          return False\n      ancestors.append(u)\n      for v in graph[u]:\n        if seen[v]:\n          continue\n        if degrees[v] == degrees[u]:\n          hasMoreThanOneWay = True\n        if not dfs(v, ancestors, seen):\n          return False\n      ancestors.pop()\n      return True\n\n    if not dfs(root, [], [False] * MAX):\n      return 0\n    return 2 if hasMoreThanOneWay else 1",
      "title": "1719. Number Of Ways To Reconstruct A Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f392bd20-92c9-4a51-8299-7e7eccc3a816",
      "code": "class Solution:\n  def decode(self, encoded: list[int], first: int) -> list[int]:\n    ans = [first]\n\n    for e in encoded:\n      ans.append(e ^ ans[-1])\n\n    return ans",
      "title": "1720. Decode XORed Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "142833d3-b25d-4f5b-86ee-f591ba34b09a",
      "code": "class Solution:\n  def swapNodes(self, head: ListNode | None, k: int) -> ListNode | None:\n    p = None  # Points the k-th node from the beginning.\n    q = None  # Points the k-th node from the end.\n\n    curr = head\n    while curr:\n      if q:\n        q = q.next\n      k -= 1\n      if k == 0:\n        p = curr\n        q = head\n      curr = curr.next\n\n    p.val, q.val = q.val, p.val\n    return head",
      "title": "1721. Swapping Nodes in a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9decd6e7-966f-4ae4-85e5-1c40b97f3e9c",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def minimumHammingDistance(\n      self,\n      source: list[int],\n      target: list[int],\n      allowedSwaps: list[list[int]],\n  ) -> int:\n    n = len(source)\n    ans = 0\n    uf = UnionFind(n)\n    groupIdToCount = [collections.Counter() for _ in range(n)]\n\n    for a, b in allowedSwaps:\n      uf.unionByRank(a, b)\n\n    for i in range(n):\n      groupIdToCount[uf.find(i)][source[i]] += 1\n\n    for i in range(n):\n      groupId = uf.find(i)\n      count = groupIdToCount[groupId]\n      if target[i] not in count:\n        ans += 1\n      else:\n        count[target[i]] -= 1\n        if count[target[i]] == 0:\n          del count[target[i]]\n\n    return ans",
      "title": "1722. Minimize Hamming Distance After Swap Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44a4cfad-a4f5-48d6-af25-be6818412b41",
      "code": "class Solution:\n  def minimumTimeRequired(self, jobs: list[int], k: int) -> int:\n    ans = sum(jobs)\n    times = [0] * k  # times[i] := accumulate time of workers[i]\n\n    # Assign the most time-consuming job first.\n    jobs.sort(reverse=True)\n\n    def dfs(s: int) -> None:\n      nonlocal ans\n      if s == len(jobs):\n        ans = min(ans, max(times))\n        return\n      for i in range(k):\n        # There is no need to explore assigning jobs[s] to workers[i] further as\n        # it would not yield better results.\n        if times[i] + jobs[s] >= ans:\n          continue\n        times[i] += jobs[s]\n        dfs(s + 1)\n        times[i] -= jobs[s]\n        # It's always non-optimal to have a worker with no jobs.\n        if times[i] == 0:\n          return\n\n    dfs(0)\n    return ans",
      "title": "1723. Find Minimum Time to Finish All Jobs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e86b0d9-a0a0-4a22-b2b6-17bf92aec644",
      "code": "class Solution:\n  def countGoodRectangles(self, rectangles: list[list[int]]) -> int:\n    minSides = [min(x, y) for x, y in rectangles]\n    return minSides.count(max(minSides))",
      "title": "1725. Number Of Rectangles That Can Form The Largest Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1f387b2-818a-4a93-a1bd-a59b7097282c",
      "code": "class Solution:\n  def tupleSameProduct(self, nums: list[int]) -> int:\n    # nums of ways to arrange (a, b) = 2\n    # nums of ways to arrange (c, d) = 2\n    # nums of ways to arrange (a, b), (c, d) = 2^3 = 8\n    ans = 0\n    count = collections.Counter()\n\n    for i in range(len(nums)):\n      for j in range(i):\n        prod = nums[i] * nums[j]\n        ans += count[prod] * 8\n        count[prod] += 1\n\n    return ans",
      "title": "1726. Tuple with Same Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c308a2dd-5731-4954-b9a9-ca8daf803b4c",
      "code": "class Solution:\n  def largestSubmatrix(self, matrix: list[list[int]]) -> int:\n    ans = 0\n    hist = [0] * len(matrix[0])\n\n    for row in matrix:\n      # Accumulate the histogram if possible.\n      for i, num in enumerate(row):\n        hist[i] = 0 if num == 0 else hist[i] + 1\n\n      # Get the sorted histogram.\n      sortedHist = sorted(hist)\n\n      # Greedily calculate the answer.\n      for i, h in enumerate(sortedHist):\n        ans = max(ans, h * (len(row) - i))\n\n    return ans",
      "title": "1727. Largest Submatrix With Rearrangements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bcb90cd6-eb63-41bf-9ffc-f972cfebcde0",
      "code": "class Solution:\n  def canMouseWin(self, grid: list[str], catJump: int, mouseJump: int) -> bool:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    nFloors = 0\n    cat = 0  # cat's position\n    mouse = 0  # mouse's position\n\n    def hash(i: int, j: int) -> int:\n      return i * n + j\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] != '#':\n          nFloors += 1\n        if grid[i][j] == 'C':\n          cat = hash(i, j)\n        elif grid[i][j] == 'M':\n          mouse = hash(i, j)\n\n    @functools.lru_cache(None)\n    def dp(cat: int, mouse: int, turn: int) -> bool:\n      \"\"\"\n      Returns True if the mouse can win, where the cat is on (i / 8, i % 8), the\n      mouse is on (j / 8, j % 8), and the turns is k.\n      \"\"\"\n      # We already search the whole touchable grid.\n      if turn == nFloors * 2:\n        return False\n\n      if turn % 2 == 0:\n        # the mouse's turn\n        i = mouse // n\n        j = mouse % n\n        for dx, dy in DIRS:\n          for jump in range(mouseJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The mouse eats the food, so the mouse wins.\n            if grid[x][y] == 'F':\n              return True\n            if dp(cat, hash(x, y), turn + 1):\n              return True\n        # The mouse can't win, so the mouse loses.\n        return False\n      else:\n        # the cat's turn\n        i = cat // n\n        j = cat % n\n        for dx, dy in DIRS:\n          for jump in range(catJump + 1):\n            x = i + dx * jump\n            y = j + dy * jump\n            if x < 0 or x == m or y < 0 or y == n:\n              break\n            if grid[x][y] == '#':\n              break\n            # The cat eats the food, so the mouse loses.\n            if grid[x][y] == 'F':\n              return False\n            nextCat = hash(x, y)\n            # The cat catches the mouse, so the mouse loses.\n            if nextCat == mouse:\n              return False\n            if not dp(nextCat, mouse, turn + 1):\n              return False\n        # The cat can't win, so the mouse wins.\n        return True\n\n    return dp(cat, mouse, 0)",
      "title": "1728. Cat and Mouse II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ddef8d04-dc35-4dc3-a3fd-68587d9cae7b",
      "code": "class Solution:\n  def getFood(self, grid: list[list[str]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    q = collections.deque([self._getStartLocation(grid)])\n\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if grid[x][y] == 'X':\n            continue\n          if grid[x][y] == '#':\n            return ans + 1\n          q.append((x, y))\n          grid[x][y] = 'X'  # Mark as visited.\n      ans += 1\n\n    return -1\n\n  def _getStartLocation(self, grid: list[list[str]]) -> tuple[int, int]:\n    for i, row in enumerate(grid):\n      for j, cell in enumerate(row):\n        if cell == '*':\n          return (i, j)",
      "title": "1730. Shortest Path to Get Food",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08d0b6a6-301a-4a7e-8a07-24b57fd5a099",
      "code": "class Solution:\n  def largestAltitude(self, gain: list[int]) -> int:\n    ans = 0\n    currAltitude = 0\n    for g in gain:\n      currAltitude += g\n      ans = max(ans, currAltitude)\n    return ans",
      "title": "1732. Find the Highest Altitude",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "677a99ba-888c-418b-8d04-053afbb282de",
      "code": "class Solution:\n  def minimumTeachings(\n      self,\n      n: int,\n      languages: list[list[int]],\n      friendships: list[list[int]],\n  ) -> int:\n    languageSets = [set(languages) for languages in languages]\n    needTeach = set()\n    languageCount = collections.Counter()\n\n    # Find friends that can't communicate.\n    for u, v in friendships:\n      if not languageSets[u - 1] & languageSets[v - 1]:\n        needTeach.add(u - 1)\n        needTeach.add(v - 1)\n\n    # Find the most popular language.\n    for u in needTeach:\n      for language in languageSets[u]:\n        languageCount[language] += 1\n\n    # Teach the most popular language to people don't understand.\n    return len(needTeach) - max(languageCount.values(), default=0)",
      "title": "1733. Minimum Number of People to Teach",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c101f8ea-28e6-45d7-9b17-9d7939c6fffc",
      "code": "class Solution:\n  def decode(self, encoded: list[int]) -> list[int]:\n    # Our goal is to find the value of a1, which will allow us to decode a2, a3,\n    # ..., an. This can be achieved by performing XOR operation between each\n    # element in `encoded` and a1.\n    #\n    # e.g. n = 3, perm = [a1, a2, a3] is a permutation of [1, 2, 3].\n    #               encoded = [a1^a2, a2^a3]\n    #    accumulatedEncoded = [a1^a2, a1^a3]\n    #    a1 = (a1^a2)^(a1^a3)^(a1^a2^a3)\n    #    a2 = a1^(a1^a2)\n    #    a3 = a2^(a2^a3)\n    n = len(encoded) + 1\n    nXors = functools.reduce(operator.xor, [i for i in range(1, n + 1)])\n\n    # Instead of constructing the array, we can track of the running XOR value\n    # of `accumulatedEncoded`.\n    xors = 0  # xors(accumulatedEncoded)\n\n    for encode in encoded:\n      runningXors ^= encode\n      xors ^= runningXors\n\n    ans = [xors ^ nXors]\n\n    for encode in encoded:\n      ans.append(ans[-1] ^ encode)\n\n    return ans",
      "title": "1734. Decode XORed Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c9983ac-bcda-4f1a-8d0e-3f26c3121535",
      "code": "class Solution:\n  def waysToFillArray(self, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX = 10_000\n    minPrimeFactors = self._sieveEratosthenes(MAX + 1)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    ans = []\n\n    for n, k in queries:\n      res = 1\n      for freq in self._getPrimeFactorsCount(k, minPrimeFactors).values():\n        res = res * nCk(n - 1 + freq, freq) % MOD\n      ans.append(res)\n\n    return ans\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactorsCount(self, num: int, minPrimeFactors: list[int]) -> dict[int, int]:\n    count = collections.Counter()\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      while num % divisor == 0:\n        num //= divisor\n        count[divisor] += 1\n    return count",
      "title": "1735. Count Ways to Make Array With Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71d8b6d3-4c58-461d-9a1c-06f4f9f426c9",
      "code": "class Solution:\n  def maximumTime(self, time: str) -> str:\n    ans = list(time)\n    if time[0] == '?':\n      ans[0] = '2' if time[1] == '?' or time[1] < '4' else '1'\n    if time[1] == '?':\n      ans[1] = '3' if ans[0] == '2' else '9'\n    if time[3] == '?':\n      ans[3] = '5'\n    if time[4] == '?':\n      ans[4] = '9'\n    return ''.join(ans)",
      "title": "1736. Latest Time by Replacing Hidden Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5fea051d-3fcc-4b52-80e2-cb59bb61f1c7",
      "code": "class Solution:\n  def minimumBoxes(self, n: int) -> int:\n    nBoxes = 0\n    nextTouchings = 0  # j\n    currLevelBoxes = 0  # 1 + 2 + ... + j\n\n    # Find the minimum j s.t. `nBoxes` = 1 + (1 + 2) + ... + (1 + 2 + ... + j)\n    # >= n\n    while nBoxes < n:\n      nextTouchings += 1\n      currLevelBoxes += nextTouchings\n      nBoxes += currLevelBoxes\n\n    # If nBoxes = n, the answer is `currLevelBoxes` = 1 + 2 + ... + j.\n    if nBoxes == n:\n      return currLevelBoxes\n\n    # Otherwise, need to remove the boxes in the current level and rebuild it.\n    nBoxes -= currLevelBoxes\n    currLevelBoxes -= nextTouchings\n    nextTouchings = 0\n\n    while nBoxes < n:\n      nextTouchings += 1\n      nBoxes += nextTouchings\n\n    return currLevelBoxes + nextTouchings",
      "title": "1739. Building Boxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83223c8a-8945-48b8-a091-b277980371de",
      "code": "class Solution:\n  def findDistance(self, root: TreeNode, p: int, q: int) -> int:\n    def getLCA(root, p, q):\n      if not root or root.val == p or root.val == q:\n        return root\n\n      l = getLCA(root.left, p, q)\n      r = getLCA(root.right, p, q)\n\n      if l and r:\n        return root\n      return l or r\n\n    def dist(lca, target):\n      if not lca:\n        return 10000\n      if lca.val == target:\n        return 0\n      return 1 + min(dist(lca.left, target), dist(lca.right, target))\n\n    lca = getLCA(root, p, q)\n    return dist(lca, p) + dist(lca, q)",
      "title": "1740. Find Distance in a Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e830b8e-c9ec-4038-8607-7015fe4888bb",
      "code": "class Solution:\n  def countBalls(self, lowLimit: int, highLimit: int) -> int:\n    maxDigitSum = 9 * 5  # 99999\n    ans = 0\n    count = [0] * (maxDigitSum + 1)\n\n    for num in range(lowLimit, highLimit + 1):\n      digitSum = self._getDigitSum(num)\n      count[digitSum] += 1\n      ans = max(ans, count[digitSum])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1742. Maximum Number of Balls in a Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54c660d1-50e2-4d83-bed5-4d1ebfb58e71",
      "code": "class Solution:\n  def restoreArray(self, adjacentPairs: list[list[int]]) -> list[int]:\n    ans = []\n    numToAdjs = collections.defaultdict(list)\n\n    for a, b in adjacentPairs:\n      numToAdjs[a].append(b)\n      numToAdjs[b].append(a)\n\n    for num, adjs in numToAdjs.items():\n      if len(adjs) == 1:\n        ans.append(num)\n        ans.append(adjs[0])\n        break\n\n    while len(ans) < len(adjacentPairs) + 1:\n      tail = ans[-1]\n      prev = ans[-2]\n      adjs = numToAdjs[tail]\n      if adjs[0] == prev:  # adjs[0] is already used\n        ans.append(adjs[1])\n      else:\n        ans.append(adjs[0])\n\n    return ans",
      "title": "1743. Restore the Array From Adjacent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99cbdb92-fee0-40ca-ac66-90b6a363861e",
      "code": "class Solution:\n  def canEat(\n      self,\n      candiesCount: list[int],\n      queries: list[list[int]]\n  ) -> list[bool]:\n    prefix = list(itertools.accumulate(candiesCount, initial=0))\n    return [prefix[t] // c <= d < prefix[t + 1] for t, d, c in queries]",
      "title": "1744. Can You Eat Your Favorite Candy on Your Favorite Day?",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ad84dc6d-b476-428e-aaf2-606d6ffa9748",
      "code": "class Solution:\n  def checkPartitioning(self, s: str) -> bool:\n    @functools.lru_cache(None)\n    def isPalindrome(i: int, j: int) -> bool:\n      \"\"\"Returns True if s[i..j] is a palindrome.\"\"\"\n      if i > j:\n        return True\n      if s[i] == s[j]:\n        return isPalindrome(i + 1, j - 1)\n      return False\n\n    n = len(s)\n    return any(isPalindrome(0, i) and\n               isPalindrome(i + 1, j) and\n               isPalindrome(j + 1, n - 1)\n               for i in range(n)\n               for j in range(i + 1, n - 1))",
      "title": "1745. Palindrome Partitioning IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1776a4b6-0dd0-4f84-ace7-9bcfc5862ed2",
      "code": "class Solution:\n  def maxSumAfterOperation(self, nums: list[int]) -> int:\n    ans = -math.inf\n    regular = 0\n    squared = 0\n\n    for num in nums:\n      squared = max(num**2, regular + num**2, squared + num)\n      regular = max(num, regular + num)\n      ans = max(ans, squared)\n\n    return ans",
      "title": "1746. Maximum Subarray Sum After One Operation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15faa0fb-c59c-4503-927c-f9ed0b6cba94",
      "code": "class Solution:\n  def sumOfUnique(self, nums: list[int]) -> int:\n    return sum(num\n               for num, freq in collections.Counter(nums).items()\n               if freq == 1)",
      "title": "1748. Sum of Unique Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e26fdc5-10d3-43bd-86c6-85454db745f6",
      "code": "class Solution:\n  def maxAbsoluteSum(self, nums):\n    ans = -math.inf\n    maxSum = 0\n    minSum = 0\n\n    for num in nums:\n      maxSum = max(num, maxSum + num)\n      minSum = min(num, minSum + num)\n      ans = max(ans, maxSum, -minSum)\n\n    return ans",
      "title": "1749. Maximum Absolute Sum of Any Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ecda10b2-7e75-4bff-bdd1-d0de2bc9d3ee",
      "code": "class Solution:\n  def minimumLength(self, s: str) -> int:\n    i = 0\n    j = len(s) - 1\n\n    while i < j and s[i] == s[j]:\n      c = s[i]\n      while i <= j and s[i] == c:\n        i += 1\n      while i <= j and s[j] == c:\n        j -= 1\n\n    return j - i + 1",
      "title": "1750. Minimum Length of String After Deleting Similar Ends",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c05086de-ad8f-4dee-8c7b-b81953ff66ed",
      "code": "class Solution:\n  def maxValue(self, events: list[list[int]], k: int) -> int:\n    events.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the maximum sum of values that you can receive by attending\n      events[i..n), where k is the maximum number of attendance.\n      \"\"\"\n      if k == 0 or i == len(events):\n        return 0\n\n      # Binary search `events` to find the first index j\n      # s.t. events[j][0] > events[i][1].\n      j = bisect.bisect(events, [events[i][1], math.inf, math.inf], i + 1)\n      return max(events[i][2] + dp(j, k - 1), dp(i + 1, k))\n\n    return dp(0, k)",
      "title": "1751. Maximum Number of Events That Can Be Attended II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab1efecf-4c06-47a7-bd68-b4184a13ea5f",
      "code": "class Solution:\n  def largestMerge(self, word1: str, word2: str) -> str:\n    if not word1:\n      return word2\n    if not word2:\n      return word1\n    if word1 > word2:\n      return word1[0] + self.largestMerge(word1[1:], word2)\n    return word2[0] + self.largestMerge(word1, word2[1:])",
      "title": "1754. Largest Merge Of Two Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8c9880e-7c49-4590-a10d-903ea4b0a315",
      "code": "class Solution:\n  def minAbsDifference(self, nums: list[int], goal: int) -> int:\n    n = len(nums) // 2\n    ans = math.inf\n    lSums = []\n    rSums = []\n\n    def dfs(arr: list[int], i: int, path: int, sums: list[int]) -> None:\n      if i == len(arr):\n        sums.append(path)\n        return\n      dfs(arr, i + 1, path + arr[i], sums)\n      dfs(arr, i + 1, path, sums)\n\n    dfs(nums[:n], 0, 0, lSums)\n    dfs(nums[n:], 0, 0, rSums)\n    rSums.sort()\n\n    for lSum in lSums:\n      i = bisect_left(rSums, goal - lSum)\n      if i < len(rSums):  # 2^n\n        ans = min(ans, abs(goal - lSum - rSums[i]))\n      if i > 0:\n        ans = min(ans, abs(goal - lSum - rSums[i - 1]))\n\n    return ans",
      "title": "1755. Closest Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a814046-f7e6-4e24-93bb-c96ceaab0a18",
      "code": "class Solution:\n  def minOperations(self, s: str) -> int:\n    # the cost to make s \"1010\"\n    cost10 = sum(int(c) == i % 2 for i, c in enumerate(s))\n    # the cost to make s \"0101\"\n    cost01 = len(s) - cost10\n    return min(cost10, cost01)",
      "title": "1758. Minimum Changes To Make Alternating Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56f0a570-5b04-4f49-b8e9-0cc522159a04",
      "code": "class Solution:\n  def countHomogenous(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = 0\n    currentChar = '@'\n\n    for c in s:\n      count = count + 1 if c == currentChar else 1\n      currentChar = c\n      ans += count\n      ans %= MOD\n\n    return ans",
      "title": "1759. Count Number of Homogenous Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1ca629aa-03c0-403c-9a54-3fd7b46d17c7",
      "code": "class Solution:\n  def minimumSize(self, nums: list[int], maxOperations: int) -> int:\n    def numOperations(m: int) -> int:\n      \"\"\"Returns the number of operations required to make m penalty.\"\"\"\n      return sum((num - 1) // m for num in nums)\n    l = 1\n    r = max(nums)\n    return bisect.bisect_left(\n        range(l, r),\n        True, key=lambda m: numOperations(m) <= maxOperations) + l",
      "title": "1760. Minimum Limit of Balls in a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "120a89f3-5c74-4b2d-a4c9-cb9fb1b872f2",
      "code": "class Solution:\n  def minTrioDegree(self, n: int, edges: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [set() for _ in range(n)]\n    degrees = [0] * n\n\n    for u, v in edges:\n      u -= 1\n      v -= 1\n      # Store the mapping from `min(u, v)` to `max(u, v)` to speed up.\n      graph[min(u, v)].add(max(u, v))\n      degrees[u] += 1\n      degrees[v] += 1\n\n    for u in range(n):\n      for v in graph[u]:\n        for w in graph[u]:\n          if w in graph[v]:\n            ans = min(ans, degrees[u] + degrees[v] + degrees[w] - 6)\n\n    return -1 if ans == math.inf else ans",
      "title": "1761. Minimum Degree of a Connected Trio in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b12dcbe-192a-4716-b732-991e3ec91096",
      "code": "class Solution:\n  def findBuildings(self, heights: list[int]) -> list[int]:\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        stack.pop()\n      stack.append(i)\n\n    return stack",
      "title": "1762. Buildings With an Ocean View",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff5d7fe9-a72d-4050-b319-53fabb00f44f",
      "code": "class Solution:\n  def longestNiceSubstring(self, s: str) -> str:\n    if len(s) < 2:\n      return ''\n\n    seen = set(s)\n\n    for i, c in enumerate(s):\n      # If both upper and lower case letters exists in the string, keep moving,\n      # else take the erroneous character as a partition and check for its left\n      # and right parts to be nice strings.\n      if c.swapcase() not in seen:\n        prefix = self.longestNiceSubstring(s[:i])\n        suffix = self.longestNiceSubstring(s[i + 1:])\n        return max(prefix, suffix, key=len)\n\n    return s",
      "title": "1763. Longest Nice Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42991341-5131-405e-9a08-0b76bc1bae93",
      "code": "class Solution:\n  def canChoose(self, groups: list[list[int]], nums: list[int]) -> bool:\n    i = 0  # groups' index\n    j = 0  # nums' index\n\n    while i < len(groups) and j < len(nums):\n      if self._isMatch(groups[i], nums, j):\n        j += len(groups[i])\n        i += 1\n      else:\n        j += 1\n\n    return i == len(groups)\n\n  # Returns True if group == nums[j..j + |group|].\n  def _isMatch(self, group: list[int], nums: list[int], j: int) -> bool:\n    if j + |group | > len(nums):\n      return False\n    for i, g in enumerate(group):\n      if g != nums[j + i]:\n        return False\n    return True",
      "title": "1764. Form Array by Concatenating Subarrays of Another Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e065f218-6038-4ce0-9af2-9d1e87fdf7ce",
      "code": "class Solution:\n  def highestPeak(self, isWater: list[list[int]]) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(isWater)\n    n = len(isWater[0])\n    ans = [[-1] * n for _ in range(m)]\n    q = collections.deque()\n\n    for i in range(m):\n      for j in range(n):\n        if isWater[i][j] == 1:\n          q.append((i, j))\n          ans[i][j] = 0\n\n    while q:\n      i, j = q.popleft()\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if ans[x][y] != -1:\n          continue\n        ans[x][y] = ans[i][j] + 1\n        q.append((x, y))\n\n    return ans",
      "title": "1765. Map of Highest Peak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c428534-2d66-449d-8300-16000071aca3",
      "code": "class Solution:\n  def getCoprimes(self, nums: list[int], edges: list[list[int]]) -> list[int]:\n    MAX = 50\n    ans = [-1] * len(nums)\n    tree = [[] for _ in range(len(nums))]\n    # stacks[i] := (node, depth)s of nodes with value i\n    stacks = [[] for _ in range(MAX + 1)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def getAncestor(u: int) -> int:\n      maxNode = -1\n      maxDepth = -1\n      for i, stack in enumerate(stacks):\n        if stack and stack[-1][1] > maxDepth and math.gcd(nums[u], i) == 1:\n          maxNode, maxDepth = stack[-1]\n      return maxNode\n\n    def dfs(u: int, prev: int, depth: int) -> int:\n      ans[u] = getAncestor(u)\n      stacks[nums[u]].append((u, depth))\n\n      for v in tree[u]:\n        if v != prev:\n          dfs(v, u, depth + 1)\n\n      stacks[nums[u]].pop()\n\n    dfs(0, -1, 0)\n    return ans",
      "title": "1766. Tree of Coprimes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "017100ef-46f5-471c-9025-9a62e2e26bfd",
      "code": "class Solution:\n  def mergeAlternately(self, word1: str, word2: str) -> str:\n    return ''.join(a + b for a, b in zip_longest(word1, word2, fillvalue=''))",
      "title": "1768. Merge Strings Alternately",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f932f018-6443-4c07-9654-0dcf830957d1",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], multipliers: list[int]) -> int:\n    @functools.lru_cache(2000)\n    def dp(s: int, i: int) -> int:\n      \"\"\"Returns the maximum score of nums[s..e] and multipliers[i].\"\"\"\n      if i == len(multipliers):\n        return 0\n\n      # The number of nums picked on the start side is s.\n      # The number of nums picked on the end side is i - s.\n      # So, e = n - (i - s) - 1.\n      e = len(nums) - (i - s) - 1\n      pickStart = nums[s] * multipliers[i] + dp(s + 1, i + 1)\n      pickEnd = nums[e] * multipliers[i] + dp(s, i + 1)\n      return max(pickStart, pickEnd)\n\n    return dp(0, 0)",
      "title": "1770. Maximum Score from Performing Multiplication Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "688e39bb-2163-494a-9143-98d7c30af146",
      "code": "class Solution:\n  def getCollisionTimes(self, cars: list[list[int]]) -> list[float]:\n    ans = []\n    stack = []  # (pos, speed, collisionTime)\n\n    def getCollisionTime(\n            car: tuple[int, int, int],\n            pos: int, speed: int) -> float:\n      return (car[0] - pos) / (speed - car[1])\n\n    for pos, speed in reversed(cars):\n      while stack and (\n              speed <= stack[-1][1] or getCollisionTime(stack[-1],\n                                                        pos, speed) >=\n              stack[-1][2]):\n        stack.pop()\n      if stack:\n        collisionTime = getCollisionTime(stack[-1], pos, speed)\n        stack.append((pos, speed, collisionTime))\n        ans.append(collisionTime)\n      else:\n        stack.append((pos, speed, math.inf))\n        ans.append(-1)\n\n    return ans[::-1]",
      "title": "1776. Car Fleet II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "920e1857-62b5-4b36-9bdf-4f17d98d4a07",
      "code": "class Solution:\n  def checkPowersOfThree(self, n: int) -> bool:\n    while n > 1:\n      n, r = divmod(n, 3)\n      if r == 2:\n        return False\n    return True",
      "title": "1780. Check if Number is a Sum of Powers of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5d6e953-1a76-4631-ae09-2c9c74a08245",
      "code": "class Solution:\n  def beautySum(self, s: str) -> int:\n    ans = 0\n\n    for i in range(len(s)):\n      count = collections.Counter()\n      for j in range(i, len(s)):\n        count[s[j]] += 1\n        ans += max(count.values()) - min(count.values())\n\n    return ans",
      "title": "1781. Sum of Beauty of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ce8569a-c85c-47d5-978e-0eacbb43675b",
      "code": "class Solution:\n  def countPairs(\n      self,\n      n: int,\n      edges: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n\n    # count[i] := the number of edges of node i\n    count = [0] * (n + 1)\n\n    # shared[i][j] := the number of edges incident to i or j, where i < j\n    shared = [collections.Counter() for _ in range(n + 1)]\n\n    for u, v in edges:\n      count[u] += 1\n      count[v] += 1\n      shared[min(u, v)][max(u, v)] += 1\n\n    sortedCount = sorted(count)\n\n    for k, query in enumerate(queries):\n      i = 1\n      j = n\n      while i < j:\n        if sortedCount[i] + sortedCount[j] > query:\n          # sortedCount[i] + sortedCount[j] > query\n          # sortedCount[i + 1] + sortedCount[j] > query\n          # ...\n          # sortedCount[j - 1] + sortedCount[j] > query\n          # So, there are (j - 1) - i + 1 = j - i pairs > query\n          ans[k] += j - i\n          j -= 1\n        else:\n          i += 1\n      for i in range(1, n + 1):\n        for j, sh in shared[i].items():\n          if count[i] + count[j] > query and count[i] + count[j] - sh <= query:\n            ans[k] -= 1\n\n    return ans",
      "title": "1782. Count Pairs Of Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48526b22-85df-41d0-af7c-669164a982c7",
      "code": "class Solution:\n  def checkOnesSegment(self, s: str) -> bool:\n    return '01' not in s",
      "title": "1784. Check if Binary String Has at Most One Segment of Ones",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05c83148-c9e3-47ea-8299-2aa48c2509cb",
      "code": "class Solution:\n  def countRestrictedPaths(self, n: int, edges: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    # ways[i] := the number of restricted path from i to n\n    ways = [0] * len(graph)\n    # dist[i] := the distance to the last node of i\n    dist = [math.inf] * len(graph)\n\n    ways[dst] = 1\n    dist[dst] = 0\n    minHeap = [(dist[dst], dst)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n        if dist[v] < dist[u]:\n          ways[u] += ways[v]\n          ways[u] %= MOD\n\n    return ways[src]",
      "title": "1786. Number of Restricted Paths From First to Last Node",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7396b7c8-8b36-4ae0-93df-9d8b0cbf6b6e",
      "code": "class Solution:\n  def minChanges(self, nums: list[int], k: int) -> int:\n    MAX = 1024\n    n = len(nums)\n    # counts[i] := the counter that maps at the i-th position\n    counts = [collections.Counter() for _ in range(k)]\n    # dp[i][j] := the minimum number of elements to change s.t. XOR(nums[i..k - 1]) is j\n    dp = [[n] * MAX for _ in range(k)]\n\n    for i, num in enumerate(nums):\n      counts[i % k][num] += 1\n\n    def countAt(i: int) -> int:\n      return n // k + (1 if n % k > i else 0)\n\n    # Initialize the DP array.\n    for j in range(MAX):\n      dp[k - 1][j] = countAt(k - 1) - counts[k - 1][j]\n\n    for i in range(k - 2, -1, -1):\n      # The worst-case scenario is changing all the i-th position numbers to a\n      # non-existent value in the current bucket.\n      changeAll = countAt(i) + min(dp[i + 1])\n      for j in range(MAX):\n        dp[i][j] = changeAll\n        for num, freq in counts[i].items():\n          # the cost to change every number in the i-th position to `num`\n          cost = countAt(i) - freq\n          dp[i][j] = min(dp[i][j], dp[i + 1][j ^ num] + cost)\n\n    return dp[0][0]",
      "title": "1787. Make the XOR of All Segments Equal to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "49a8f92b-cc33-4d7d-89ec-bc08b88203a1",
      "code": "class Solution:\n  def maximumBeauty(self, flowers: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    flowerToPrefix = collections.defaultdict(int)\n\n    for flower in flowers:\n      if flower in flowerToPrefix:\n        ans = max(ans, prefix - flowerToPrefix[flower] + flower * 2)\n      prefix += max(0, flower)\n      flowerToPrefix.setdefault(flower, prefix)\n\n    return ans",
      "title": "1788. Maximize the Beauty of the Garden",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c816e81f-460f-4113-b69b-80c9c6101a97",
      "code": "class Solution:\n  # Similar to 859. Buddy Strings\n  def areAlmostEqual(self, s1: str, s2: str) -> bool:\n    diffIndices = [i for i, (a, b) in enumerate(zip(s1, s2))\n                   if a != b]\n    return not diffIndices or (len(diffIndices) == 2 and\n                               s1[diffIndices[0]] == s2[diffIndices[1]] and\n                               s1[diffIndices[1]] == s2[diffIndices[0]])",
      "title": "1790. Check if One String Swap Can Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "052535a5-1235-44c2-abd6-8d97b78d1c25",
      "code": "class Solution:\n  def findCenter(self, edges: list[list[int]]) -> int:\n    if edges[0][0] in edges[1]:\n      return edges[0][0]\n    return edges[0][1]",
      "title": "1791. Find Center of Star Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5837429f-2caa-409d-af34-4e50e3f075ec",
      "code": "class Solution:\n  def maxAverageRatio(\n      self,\n      classes: list[list[int]],\n      extraStudents: int,\n  ) -> float:\n    def extraPassRatio(pas: int, total: int) -> float:\n      \"\"\"Returns the extra pass ratio if a brilliant student joins.\"\"\"\n      return (pas + 1) / (total + 1) - pas / total\n\n    maxHeap = [(-extraPassRatio(pas, total), pas, total)\n               for pas, total in classes]\n    heapq.heapify(maxHeap)\n\n    for _ in range(extraStudents):\n      _, pas, total = heapq.heappop(maxHeap)\n      heapq.heappush(\n          maxHeap, (-extraPassRatio(pas + 1, total + 1), pas + 1, total + 1))\n\n    return sum(pas / total for _, pas, total in maxHeap) / len(maxHeap)",
      "title": "1792. Maximum Average Pass Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a4cb821-f746-4a59-b07a-5d21a7461269",
      "code": "class Solution:\n  def maximumScore(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    ans = nums[k]\n    mn = nums[k]\n    i = k\n    j = k\n\n    # Greedily expand the window and decrease the minimum as slow as possible.\n    while i > 0 or j < n - 1:\n      if i == 0:\n        j += 1\n      elif j == n - 1:\n        i -= 1\n      elif nums[i - 1] < nums[j + 1]:\n        j += 1\n      else:\n        i -= 1\n      mn = min(mn, nums[i], nums[j])\n      ans = max(ans, mn * (j - i + 1))\n\n    return ans",
      "title": "1793. Maximum Score of a Good Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15d505ba-6c14-441c-b393-44871ff12619",
      "code": "class Solution:\n  def countQuadruples(self, s1: str, s2: str) -> int:\n    # To minimize j - a, the length of the substring should be 1. This is\n    # because for substrings with a size greater than 1, a will decrease,\n    # causing j - a to become larger.\n    ans = 0\n    diff = math.inf  # diff := j - a\n    firstJ = {}\n    lastA = {}\n\n    for j in range(len(s1) - 1, -1, -1):\n      firstJ[s1[j]] = j\n\n    for a in range(len(s2)):\n      lastA[s2[a]] = a\n\n    for c in string.ascii_lowercase:\n      if c not in firstJ or c not in lastA:\n        continue\n      if firstJ[c] - lastA[c] < diff:\n        diff = firstJ[c] - lastA[c]\n        ans = 0\n      if firstJ[c] - lastA[c] == diff:\n        ans += 1\n\n    return ans",
      "title": "1794. Count Pairs of Equal Substrings With Minimum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b89943c9-f7d6-4f63-b912-1a2989dbbc27",
      "code": "class Solution:\n  def secondHighest(self, s: str) -> int:\n    maxDigit = -1\n    secondMaxDigit = -1\n\n    for c in s:\n      if c.isdigit():\n        d = int(c)\n        if d > maxDigit:\n          secondMaxDigit = maxDigit\n          maxDigit = d\n        elif maxDigit > d > secondMaxDigit:\n          secondMaxDigit = d\n\n    return secondMaxDigit",
      "title": "1796. Second Largest Digit in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f7ad6714-ead8-4270-90ce-efb1004bcb9b",
      "code": "class Solution:\n  def getMaximumConsecutive(self, coins: list[int]) -> int:\n    ans = 1  # the next value we want to make\n\n    for coin in sorted(coins):\n      if coin > ans:\n        return ans\n      ans += coin\n\n    return ans",
      "title": "1798. Maximum Number of Consecutive Values You Can Make",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f7ddce3-439f-451e-8ffe-78f2ce53509e",
      "code": "class Solution:\n  def maxScore(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n\n    @functools.lru_cache(None)\n    def dp(k: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum score you can receive after performing the k to n\n      operations, where `mask` is the bitmask of the chosen numbers.\n      \"\"\"\n      if k == n + 1:\n        return 0\n\n      res = 0\n\n      for i, j in itertools.combinations(range(len(nums)), 2):\n        chosenMask = 1 << i | 1 << j\n        if (mask & chosenMask) == 0:\n          res = max(res, k * math.gcd(nums[i], nums[j])\n                    + dp(k + 1, mask | chosenMask))\n\n      return res\n\n    return dp(1, 0)",
      "title": "1799. Maximize Score After N Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f628658-4999-4dba-80bc-48cba159ec75",
      "code": "class Solution:\n  def maxAscendingSum(self, nums: list[int]) -> int:\n    ans = 0\n    sum = nums[0]\n\n    for i in range(1, len(nums)):\n      if nums[i] > nums[i - 1]:\n        sum += nums[i]\n      else:\n        ans = max(ans, sum)\n        sum = nums[i]\n\n    return max(ans, sum)",
      "title": "1800. Maximum Ascending Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e360f99-0ff8-4c58-a3b4-7f9d474b4e09",
      "code": "class Solution:\n  def numDifferentIntegers(self, word: str) -> int:\n    nums = set()\n    curr = []\n\n    for c in word:\n      if c.isdigit():\n        curr.append(c)\n      elif curr:\n        nums.add(''.join(self._removeLeadingZeros(curr)))\n        curr = []\n\n    if curr:\n      nums.add(''.join(self._removeLeadingZeros(curr)))\n\n    return len(nums)\n\n  def _removeLeadingZeros(self, s: str) -> str:\n    index = next((i for i, c in enumerate(s) if c != '0'), -1)\n    return ['0'] if index == -1 else s[index:]",
      "title": "1805. Number of Different Integers in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e026489-dae0-4080-a27b-bddb3e7d2bd9",
      "code": "class Solution:\n  def squareIsWhite(self, coordinates: str) -> bool:\n    letter, digit = coordinates\n    return ord(letter) % 2 != int(digit) % 2",
      "title": "1812. Determine Color of a Chessboard Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83f60635-a0e7-424d-85aa-d2193b46d1fc",
      "code": "class Solution:\n  def areSentencesSimilar(self, sentence1: str, sentence2: str) -> bool:\n    if len(sentence1) == len(sentence2):\n      return sentence1 == sentence2\n\n    words1 = sentence1.split()\n    words2 = sentence2.split()\n    m, n = map(len, (words1, words2))\n    if m > n:\n      return self.areSentencesSimilar(sentence2, sentence1)\n\n    i = 0  # words1's index\n    while i < m and words1[i] == words2[i]:\n      i += 1\n    while i < m and words1[i] == words2[i + n - m]:\n      i += 1\n\n    return i == m",
      "title": "1813. Sentence Similarity III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b18192f7-0a19-402c-933f-ab099bfe0b24",
      "code": "class Solution:\n  def countNicePairs(self, nums: list[int]) -> int:\n    freqs = collections.Counter(num - int(str(num)[::-1]) for num in nums)\n    return sum(freq * (freq - 1) // 2 for freq in freqs.values()) % 1000000007",
      "title": "1814. Count Nice Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3a96fbf-61e1-4b89-8bfc-d84a14481a41",
      "code": "class Solution:\n  def maxHappyGroups(self, batchSize: int, groups: list[int]) -> int:\n    happy = 0\n    freq = [0] * batchSize\n\n    for g in groups:\n      g %= batchSize\n      if g == 0:\n        happy += 1\n      elif freq[batchSize - g]:\n        freq[batchSize - g] -= 1\n        happy += 1\n      else:\n        freq[g] += 1\n\n    @functools.lru_cache(None)\n    def dp(freq: int, remainder: int) -> int:\n      \"\"\"Returns the maximum number of partitions can be formed.\"\"\"\n      ans = 0\n      if any(freq):\n        for i, f in enumerate(freq):\n          if f:\n            ans = max(ans, dp(freq[:i] + (f - 1,) +\n                              freq[i + 1:], (remainder + i) % batchSize))\n        if remainder == 0:\n          ans += 1\n      return ans\n\n    return happy + dp(tuple(freq), 0)",
      "title": "1815. Maximum Number of Groups Getting Fresh Donuts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d8bc746e-30cf-47dc-a26c-ee28a926140c",
      "code": "class Solution:\n  def truncateSentence(self, s: str, k: int) -> str:\n    return ' '.join(s.split()[:k])",
      "title": "1816. Truncate Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2edf3779-8ef8-4e35-9520-2d67b44539c6",
      "code": "class Solution:\n  def findingUsersActiveMinutes(\n      self,\n      logs: list[list[int]],\n      k: int,\n  ) -> list[int]:\n    idToTimes = collections.defaultdict(set)\n\n    for id, time in logs:\n      idToTimes[id].add(time)\n\n    c = collections.Counter(len(times) for times in idToTimes.values())\n    return [c[i] for i in range(1, k + 1)]",
      "title": "1817. Finding the Users Active Minutes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dbfc4319-aa62-45b0-836f-b0378f534ffa",
      "code": "class Solution:\n  def minAbsoluteSumDiff(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = math.inf\n    diffs = [abs(a - b) for a, b in zip(nums1, nums2)]\n    sumDiff = sum(diffs)\n\n    nums1.sort()\n\n    for num, diff in zip(nums2, diffs):\n      i = bisect.bisect_left(nums1, num)\n      if i > 0:\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i - 1]))\n      if i < len(nums1):\n        ans = min(ans, sumDiff - diff + abs(num - nums1[i]))\n\n    return ans % 1_000_000_007",
      "title": "1818. Minimum Absolute Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "45ad56be-6586-419e-a486-a3d512bbd059",
      "code": "class Solution:\n  def maximumInvitations(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    ans = 0\n    mates = [-1] * n  # mates[i] := the i-th girl's mate\n\n    def canInvite(i: int, seen: list[bool]) -> bool:\n      \"\"\"Returns True if the i-th boy can make an invitation.\"\"\"\n      # The i-th boy asks each girl.\n      for j in range(n):\n        if not grid[i][j] or seen[j]:\n          continue\n        seen[j] = True\n        if mates[j] == -1 or canInvite(mates[j], seen):\n          mates[j] = i  # Match the j-th girl with i-th boy.\n          return True\n      return False\n\n    for i in range(m):\n      seen = [False] * n\n      if canInvite(i, seen):\n        ans += 1\n\n    return ans",
      "title": "1820. Maximum Number of Accepted Invitations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a5e4368-1542-414f-a4c8-1e2d27d89c69",
      "code": "class Solution:\n  def arraySign(self, nums: list[int]) -> int:\n    sign = 1\n\n    for num in nums:\n      if num == 0:\n        return 0\n      if num < 0:\n        sign = -sign\n\n    return sign",
      "title": "1822. Sign of the Product of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a8f80c8-8fb2-41e1-bae1-0479662b79ad",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # e.g. n = 4, k = 2.\n    # By using 0-indexed notation, we have the following circle:\n    #\n    # 0 -> 1 -> 2 -> 3 -> 0\n    #      x\n    #           0 -> 1 -> 2 -> 0\n    #\n    # After the first round, 1 is removed.\n    # So, 2 becomes 0, 3 becomes 1, and 0 becomes 2.\n    # Let's denote that oldIndex = f(n, k) and newIndex = f(n - 1, k).\n    # By observation, we know f(n, k) = (f(n - 1, k) + k) % n.\n    def f(n: int, k: int) -> int:\n      ans = 0  # f(1, k)\n      # Computes f(i, k) based on f(i - 1, k).\n      for i in range(2, n + 1):\n        ans = (ans + k) % i\n      return ans\n\n    # Converts back to 1-indexed.\n    return f(n, k) + 1",
      "title": "1823. Find the Winner of the Circular Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "709d727e-47ac-47f6-9823-02d265607563",
      "code": "class Solution:\n  def findTheWinner(self, n: int, k: int) -> int:\n    # True if i-th friend is left\n    friends = [False] * n\n\n    friendCount = n\n    fp = 0  # friends' index\n\n    while friendCount > 1:\n      for _ in range(k):\n        while friends[fp % n]:  # The friend is not there.\n          fp += 1  # Point to the next one.\n        fp += 1\n      friends[(fp - 1) % n] = True\n      friendCount -= 1\n\n    fp = 0\n    while friends[fp]:\n      fp += 1\n\n    return fp + 1",
      "title": "1823. Find the Winner of the Circular Game_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3cdd43d3-3caa-40d5-ba2a-cb10b58007f0",
      "code": "class Solution:\n  def minSideJumps(self, obstacles: list[int]) -> int:\n    INF = 1e6\n    # dp[i] := the minimum jump to reach the i-th lane\n    dp = [INF, 1, 0, 1]\n\n    for obstacle in obstacles:\n      print(dp)\n      if obstacle > 0:\n        dp[obstacle] = INF\n      for i in range(1, 4):  # the current\n        if i != obstacle:\n          for j in range(1, 4):  # the previous\n            dp[i] = min(dp[i], dp[j] + (0 if i == j else 1))\n\n    return min(dp)",
      "title": "1824. Minimum Sideway Jumps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "10d1e5ae-9083-4cf6-be1f-3d7196670a81",
      "code": "class Solution:\n  def badSensor(self, sensor1: list[int], sensor2: list[int]) -> int:\n    # A -> B, so B is defect\n    def canReplace(A, B):\n      i = 0  # A's index\n      j = 0  # B's index\n      droppedValue = -1\n\n      while i < len(A):\n        if A[i] == B[j]:\n          i += 1\n          j += 1\n        else:\n          droppedValue = A[i]\n          i += 1\n\n      return j == len(B) - 1 and B[-1] != droppedValue\n\n    oneDefect = canReplace(sensor2, sensor1)\n    twoDefect = canReplace(sensor1, sensor2)\n    if oneDefect and twoDefect:\n      return -1\n    if not oneDefect and not twoDefect:\n      return -1\n    return 1 if oneDefect else 2",
      "title": "1826. Faulty Sensor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63fa2560-2c5d-49a5-bfde-9159d931d6ad",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    ans = 0\n    last = 0\n\n    for num in nums:\n      ans += max(0, last - num + 1)\n      last = max(num, last + 1)\n\n    return ans",
      "title": "1827. Minimum Operations to Make the Array Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d29b046e-0673-41e9-b9d0-d0030f8e9973",
      "code": "class Solution:\n  def countPoints(\n      self,\n      points: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = []\n\n    for xj, yj, rj in queries:\n      count = 0\n      for xi, yi in points:\n        if (xi - xj)**2 + (yi - yj)**2 <= rj**2:\n          count += 1\n      ans.append(count)\n\n    return ans",
      "title": "1828. Queries on Number of Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f19a81e6-e265-4822-a262-4cbd89159198",
      "code": "class Solution:\n  def getMaximumXor(self, nums: list[int], maximumBit: int) -> list[int]:\n    mx = (1 << maximumBit) - 1\n    ans = []\n    xors = 0\n\n    for num in nums:\n      xors ^= num\n      ans.append(xors ^ mx)\n\n    return ans[::-1]",
      "title": "1829. Maximum XOR for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "38b41275-3169-4a36-a380-fb488137334b",
      "code": "class Solution:\n  def makeStringSorted(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = [0] * 26\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    for i, c in enumerate(reversed(s)):\n      order = ord(c) - ord('a')\n      count[order] += 1\n      # count[:order] := s[i] can be any character smaller than c\n      # fact(i) := s[i + 1..n - 1] can be any sequence of characters\n      perm = sum(count[:order]) * fact(i)\n      for j in range(26):\n        perm = perm * inv(fact(count[j])) % MOD\n      ans = (ans + perm) % MOD\n\n    return ans",
      "title": "1830. Minimum Number of Operations to Make String Sorted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b23159af-25c4-4842-8ac3-bc09fb18c7b4",
      "code": "class Solution:\n  def checkIfPangram(self, sentence: str) -> bool:\n    seen = 0\n\n    for c in sentence:\n      seen |= 1 << ord(c) - ord('a')\n\n    return seen == (1 << 26) - 1",
      "title": "1832. Check if the Sentence Is Pangram",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55915b1c-d6c7-4e7a-a550-5c5b4cffefda",
      "code": "class Solution:\n  def maxIceCream(self, costs: list[int], coins: int) -> int:\n    for i, cost in enumerate(sorted(costs)):\n      if coins >= cost:\n        coins -= cost\n      else:\n        return i\n\n    return len(costs)",
      "title": "1833. Maximum Ice Cream Bars",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "925c8716-8491-45dc-9d38-4a278159e060",
      "code": "class Solution:\n  def getOrder(self, tasks: list[list[int]]) -> list[int]:\n    n = len(tasks)\n    A = [[*task, i] for i, task in enumerate(tasks)]\n    ans = []\n    minHeap = []\n    i = 0  # tasks' index\n    time = 0  # the current time\n\n    A.sort()\n\n    while i < n or minHeap:\n      if not minHeap:\n        time = max(time, A[i][0])\n      while i < n and time >= A[i][0]:\n        heapq.heappush(minHeap, (A[i][1], A[i][2]))\n        i += 1\n      procTime, index = heapq.heappop(minHeap)\n      time += procTime\n      ans.append(index)\n\n    return ans",
      "title": "1834. Single-Threaded CPU",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c1a89d2-c03b-47d6-a2ee-f7f4bf152986",
      "code": "class Solution:\n  def getXORSum(self, arr1: list[int], arr2: list[int]) -> int:\n    return functools.reduce(\n        operator.xor, arr1) & functools.reduce(\n        operator.xor, arr2)",
      "title": "1835. Find XOR Sum of All Pairs Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99d77464-0318-442b-b7c5-6341cab8ca89",
      "code": "class Solution:\n  def deleteDuplicatesUnsorted(self, head: ListNode) -> ListNode:\n    dummy = ListNode(0, head)\n    count = collections.Counter()\n\n    curr = head\n    while curr:\n      count[curr.val] += 1\n      curr = curr.next\n\n    curr = dummy\n\n    while curr:\n      while curr.next and curr.next.val in count and count[curr.next.val] > 1:\n        curr.next = curr.next.next\n      curr = curr.next\n\n    return dummy.next",
      "title": "1836. Remove Duplicates From an Unsorted Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6e4592d-bf0f-40b7-857a-ff25ec045c51",
      "code": "class Solution:\n  def sumBase(self, n: int, k: int) -> int:\n    ans = 0\n\n    while n > 0:\n      ans += n % k\n      n //= k\n\n    return ans",
      "title": "1837. Sum of Digits in Base K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e634f846-fbc2-49c6-85ca-932a74e891fa",
      "code": "class Solution:\n  def maxFrequency(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    nums.sort()\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ + k < num * (r - l + 1):\n        summ -= nums[l]\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "1838. Frequency of the Most Frequent Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97615a61-2b71-4f51-95de-6b9d7400de55",
      "code": "class Solution:\n  def longestBeautifulSubstring(self, word: str) -> int:\n    ans = 0\n    count = 1\n\n    l = 0\n    for r in range(1, len(word)):\n      curr = word[r]\n      prev = word[r - 1]\n      if curr >= prev:\n        if curr > prev:\n          count += 1\n        if count == 5:\n          ans = max(ans, r - l + 1)\n      else:\n        count = 1\n        l = r\n\n    return ans",
      "title": "1839. Longest Substring Of All Vowels in Order",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a84a1d75-fdab-4da0-9e3a-7acece67f9ba",
      "code": "class Solution:\n  def maxBuilding(self, n: int, restrictions: list[list[int]]) -> int:\n    A = sorted(restrictions + [[1, 0]] + [[n, n - 1]])\n\n    for i in range(len(A)):\n      dist = A[i][0] - A[i - 1][0]\n      A[i][1] = min(A[i][1], A[i - 1][1] + dist)\n\n    for i in reversed(range(len(A) - 1)):\n      dist = A[i + 1][0] - A[i][0]\n      A[i][1] = min(A[i][1], A[i + 1][1] + dist)\n\n    ans = 0\n\n    for (l, hL), (r, hR) in zip(A, A[1:]):\n      ans = max(ans, max(hL, hR) + (r - l - abs(hL - hR)) // 2)\n\n    return ans",
      "title": "1840. Maximum Building Height",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "15cae24d-7138-4daa-b092-65862bd99afc",
      "code": "class Solution:\n  def nextPalindrome(self, num: str) -> str:\n    def nextPermutation(nums: list[int]) -> bool:\n      n = len(nums)\n\n      # From the back to the front, find the first num < nums[i + 1].\n      i = n - 2\n      while i >= 0:\n        if nums[i] < nums[i + 1]:\n          break\n        i -= 1\n\n      if i < 0:\n        return False\n\n      # From the back to the front, find the first num > nums[i] and swap it\n      # with nums[i].\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n      def reverse(nums, l, r):\n        while l < r:\n          nums[l], nums[r] = nums[r], nums[l]\n          l += 1\n          r -= 1\n\n      # Reverse nums[i + 1..n - 1].\n      reverse(nums, i + 1, len(nums) - 1)\n      return True\n\n    n = len(num)\n    arr = [int(num[i]) for i in range(len(num) // 2)]\n    if not nextPermutation(arr):\n      return ''\n\n    s = ''.join([chr(ord('0') + a) for a in arr])\n    if n % 2 == 1:\n      return s + num[n // 2] + s[::-1]\n    return s + s[::-1]",
      "title": "1842. Next Palindrome Using Same Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "00857086-134f-4a54-938c-57eefd893843",
      "code": "class Solution:\n  def replaceDigits(self, s: str) -> str:\n    return ''.join(\n        c if i % 2 == 0 else chr(ord(s[i - 1]) + int(c))\n        for i, c in enumerate(s)\n    )",
      "title": "1844. Replace All Digits with Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e60c2085-c8c0-47ca-b4f5-8732fc41165f",
      "code": "class Solution:\n  def maximumElementAfterDecrementingAndRearranging(\n      self, arr: list[int],\n  ) -> int:\n    arr.sort()\n    arr[0] = 1\n\n    for i in range(1, len(arr)):\n      arr[i] = min(arr[i], arr[i - 1] + 1)\n\n    return arr[-1]",
      "title": "1846. Maximum Element After Decreasing and Rearranging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e9fbcca-1869-4699-9aaa-e1b6c2cc2435",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def closestRoom(\n      self,\n      rooms: list[list[int]],\n      queries: list[list[int]],\n  ) -> list[int]:\n    ans = [0] * len(queries)\n    qs = [[*q, i] for i, q in enumerate(queries)]\n    roomIds = SortedList()\n\n    rooms.sort(key=lambda x: -x[1])\n    qs.sort(key=lambda x: -x[1])\n\n    def searchClosestRoomId(roomIds: SortedList, preferred: int):\n      if not roomIds:\n        return -1\n\n      candIds = []\n      i = roomIds.bisect_right(preferred)\n      if i > 0:\n        candIds.append(roomIds[i - 1])\n      if i < len(roomIds):\n        candIds.append(roomIds[i])\n      return min(candIds, key=lambda x: abs(x - preferred))\n\n    i = 0  # rooms' index\n    for preferred, minSize, index in qs:\n      while i < len(rooms) and rooms[i][1] >= minSize:\n        roomIds.add(rooms[i][0])\n        i += 1\n      ans[index] = searchClosestRoomId(roomIds, preferred)\n\n    return ans",
      "title": "1847. Closest Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0abbf2ae-8e96-45fe-8431-20fbea607d47",
      "code": "class Solution:\n  def getMinDistance(self, nums: list[int], target: int, start: int) -> int:\n    ans = math.inf\n\n    for i, num in enumerate(nums):\n      if num == target:\n        ans = min(ans, abs(i - start))\n\n    return ans",
      "title": "1848. Minimum Distance to the Target Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "20593620-b0f3-4b11-bc4b-80a0352c92e3",
      "code": "class Solution:\n  def splitString(self, s: str) -> bool:\n    def isValid(s: str, start: int, prev: int, segment: int) -> bool:\n      if start == len(s) and segment > 1:\n        return True\n\n      curr = 0\n      for i in range(start, len(s)):\n        curr = curr * 10 + int(s[i])\n        if curr > 9999999999:\n          return False\n        if (prev == -1 or curr == prev - 1) and isValid(s, i + 1, curr, segment + 1):\n          return True\n\n      return False\n\n    return isValid(s, 0, -1, 0)",
      "title": "1849. Splitting a String Into Descending Consecutive Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "44550294-46ef-429f-9138-be7dbff4baee",
      "code": "class Solution:\n  def getMinSwaps(self, num: str, k: int) -> int:\n    original = [int(c) for c in num]\n    permutated = original.copy()\n\n    for _ in range(k):\n      self._nextPermutation(permutated)\n\n    return self._countSteps(original, permutated)\n\n  def _nextPermutation(self, nums: list[int]):\n    n = len(nums)\n\n    # From the back to the front, find the first num < nums[i + 1].\n    i = n - 2\n    while i >= 0:\n      if nums[i] < nums[i + 1]:\n        break\n      i -= 1\n\n    # From the back to the front, find the first num > nums[i] and swap it with nums[i].\n    if i >= 0:\n      for j in range(n - 1, i, -1):\n        if nums[j] > nums[i]:\n          nums[i], nums[j] = nums[j], nums[i]\n          break\n\n    def reverse(nums, l, r):\n      while l < r:\n        nums[l], nums[r] = nums[r], nums[l]\n        l += 1\n        r -= 1\n\n    # Reverse nums[i + 1..n - 1].\n    reverse(nums, i + 1, len(nums) - 1)\n\n  def _countSteps(self, A: list[int], B: list[int]) -> int:\n    count = 0\n\n    j = 0\n    for i in range(len(A)):\n      j = i\n      while A[i] != B[j]:\n        j += 1\n      while i < j:\n        B[j], B[j - 1] = B[j - 1], B[j]\n        j -= 1\n        count += 1\n\n    return count",
      "title": "1850. Minimum Adjacent Swaps to Reach the Kth Smallest Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd10264b-e71d-4b46-81a4-660f49f61a9b",
      "code": "class Solution:\n  def distinctNumbers(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    count = collections.Counter()\n    distinct = 0\n\n    for i, num in enumerate(nums):\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n      if i >= k - 1:\n        ans.append(distinct)\n\n    return ans",
      "title": "1852. Distinct Numbers in Each Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c583c5da-e4ae-411b-b812-0074d0b3ac6a",
      "code": "class Solution:\n  def maximumPopulation(self, logs: list[list[int]]) -> int:\n    MIN_YEAR = 1950\n    MAX_YEAR = 2050\n    ans = 0\n    maxPopulation = 0\n    runningPopulation = 0\n    # population[i] := the population of year i\n    population = [0] * (MAX_YEAR + 1)\n\n    for birth, death in logs:\n      population[birth] += 1\n      population[death] -= 1\n\n    for year in range(MIN_YEAR, MAX_YEAR + 1):\n      runningPopulation += population[year]\n      if runningPopulation > maxPopulation:\n        maxPopulation = runningPopulation\n        ans = year\n\n    return ans",
      "title": "1854. Maximum Population Year",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19bd1571-d423-41af-a93d-da53a3f966cf",
      "code": "class Solution:\n  def maxDistance(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    i = 0\n    j = 0\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] > nums2[j]:\n        i += 1\n      else:\n        ans = max(ans, j - i)\n        j += 1\n\n    return ans",
      "title": "1855. Maximum Distance Between a Pair of Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ac46c8b-cac8-4c9e-8ba0-5e309cc89caf",
      "code": "class Solution:\n  def maxSumMinProduct(self, nums: list[int]) -> int:\n    ans = 0\n    stack = []\n    prefix = list(itertools.accumulate(nums, initial=0))\n\n    for i in range(len(nums) + 1):\n      while stack and (i == len(nums) or nums[stack[-1]] > nums[i]):\n        minVal = nums[stack.pop()]\n        summ = prefix[i] - prefix[stack[-1] + 1] if stack else prefix[i]\n        ans = max(ans, minVal * summ)\n      stack.append(i)\n\n    return ans % 1_000_000_007",
      "title": "1856. Maximum Subarray Min-Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f555e7c-e40a-4366-9319-6aa1854a639f",
      "code": "class Solution:\n  def largestPathValue(self, colors: str, edges: list[list[int]]) -> int:\n    n = len(colors)\n    ans = 0\n    processed = 0\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    q = collections.deque()\n    count = [[0] * 26 for _ in range(n)]\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Vpology\n    for i, degree in enumerate(inDegrees):\n      if degree == 0:\n        q.append(i)\n\n    while q:\n      u = q.popleft()\n      processed += 1\n      count[u][ord(colors[u]) - ord('a')] += 1\n      ans = max(ans, count[u][ord(colors[u]) - ord('a')])\n      for v in graph[u]:\n        for i in range(26):\n          count[v][i] = max(count[v][i], count[u][i])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans if processed == n else -1",
      "title": "1857. Largest Color Value in a Directed Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ca90800-87dd-4e85-b88f-424493d6df64",
      "code": "class Solution:\n  def __init__(self):\n    self.root = {}\n\n  def longestWord(self, words: list[str]) -> str:\n    ans = ''\n\n    for word in words:\n      self.insert(word)\n\n    for word in words:\n      if not self.allPrefixed(word):\n        continue\n      if len(ans) < len(word) or (len(ans) == len(word) and ans > word):\n        ans = word\n\n    return ans\n\n  def insert(self, word: str) -> None:\n    node = self.root\n    for c in word:\n      if c not in node:\n        node[c] = {}\n      node = node[c]\n    node['isWord'] = True\n\n  def allPrefixed(self, word: str) -> bool:\n    node = self.root\n    for c in word:\n      node = node[c]\n      if 'isWord' not in node:\n        return False\n    return True",
      "title": "1858. Longest Word With All Prefixes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1d26973-8f84-4feb-8028-5ee5da4edf7a",
      "code": "class Solution:\n  def sortSentence(self, s: str) -> str:\n    return ' '.join([word[:-1]\n                     for word in sorted(s.split(), key=lambda x: x[-1])])",
      "title": "1859. Sorting the Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69562c13-e7d0-419e-8a40-a5d7333973b4",
      "code": "class Solution:\n  def memLeak(self, memory1: int, memory2: int) -> list[int]:\n    i = 1\n\n    while memory1 >= i or memory2 >= i:\n      if memory1 >= memory2:\n        memory1 -= i\n      else:\n        memory2 -= i\n      i += 1\n\n    return [i, memory1, memory2]",
      "title": "1860. Incremental Memory Leak",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0cece5f8-7ac6-4605-8361-d367115c6ed4",
      "code": "class Solution:\n  def rotateTheBox(self, box: list[list[str]]) -> list[list[str]]:\n    m = len(box)\n    n = len(box[0])\n    rotated = [['.'] * m for _ in range(n)]\n\n    for i in range(m):\n      k = n - 1\n      for j in reversed(range(n)):\n        if box[i][j] != '.':\n          if box[i][j] == '*':\n            k = j\n          rotated[k][m - i - 1] = box[i][j]\n          k -= 1\n\n    return [''.join(row) for row in rotated]",
      "title": "1861. Rotating the Box",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99f19786-1098-440e-b641-05a7cd283d40",
      "code": "class Solution:\n  def sumOfFlooredPairs(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    MAX = max(nums)\n    ans = 0\n    count = [0] * (MAX + 1)\n\n    for num in nums:\n      count[num] += 1\n\n    for i in range(1, MAX + 1):\n      count[i] += count[i - 1]\n\n    for i in range(1, MAX + 1):\n      if count[i] > count[i - 1]:\n        summ = 0\n        j = 1\n        while i * j <= MAX:\n          lo = i * j - 1\n          hi = i * (j + 1) - 1\n          summ += (count[min(hi, MAX)] - count[lo]) * j\n          j += 1\n        ans += summ * (count[i] - count[i - 1])\n        ans %= MOD\n\n    return ans",
      "title": "1862. Sum of Floored Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42f40c24-147d-4773-8bfb-b859f09d61ca",
      "code": "class Solution:\n  def subsetXORSum(self, nums: list[int]) -> int:\n    def dfs(i: int, xors: int) -> int:\n      if i == len(nums):\n        return xors\n\n      x = dfs(i + 1, xors)\n      y = dfs(i + 1, nums[i] ^ xors)\n      return x + y\n\n    return dfs(0, 0)",
      "title": "1863. Sum of All Subset XOR Totals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b79416b2-e31e-43da-883d-7e7ebce0653f",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    ones = s.count('1')\n    zeros = len(s) - ones\n    if abs(ones - zeros) > 1:\n      return -1\n\n    def countSwaps(curr: str) -> int:\n      swaps = 0\n      for c in s:\n        if c != curr:\n          swaps += 1\n        curr = chr(ord(curr) ^ 1)\n      return swaps // 2\n\n    if ones > zeros:\n      return countSwaps('1')\n    if zeros > ones:\n      return countSwaps('0')\n    return min(countSwaps('1'), countSwaps('0'))",
      "title": "1864. Minimum Number of Swaps to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f49221ab-bc25-4fbb-b8f5-9ed705ccb3dd",
      "code": "class Solution:\n  @functools.lru_cache(None)\n  def rearrangeSticks(self, n: int, k: int) -> int:\n    if n == k:\n      return 1\n    if k == 0:\n      return 0\n    return (self.rearrangeSticks(n - 1, k - 1) +\n            self.rearrangeSticks(n - 1, k) * (n - 1)) % self.MOD\n\n  MOD = 1_000_000_007",
      "title": "1866. Number of Ways to Rearrange Sticks With K Sticks Visible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b35f2086-4859-4ba0-9a4f-45fea6f57139",
      "code": "class Solution:\n  def findRLEArray(self, encoded1: list[list[int]],\n                   encoded2: list[list[int]]) -> list[list[int]]:\n    ans = []\n    i = 0  # encoded1's index\n    j = 0  # encoded2's index\n\n    while i < len(encoded1) and j < len(encoded2):\n      mult = encoded1[i][0] * encoded2[j][0]\n      minFreq = min(encoded1[i][1], encoded2[j][1])\n      if ans and mult == ans[-1][0]:\n        ans[-1][1] += minFreq\n      else:\n        ans.append([mult, minFreq])\n      encoded1[i][1] -= minFreq\n      encoded2[j][1] -= minFreq\n      if encoded1[i][1] == 0:\n        i += 1\n      if encoded2[j][1] == 0:\n        j += 1\n\n    return ans",
      "title": "1868. Product of Two Run-Length Encoded Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "71dc47e7-12bb-4ff3-ab45-bf20d5c1d17e",
      "code": "class Solution:\n  def checkZeroOnes(self, s: str) -> bool:\n    longestOnes = 0\n    longestZeros = 0\n    currentOnes = 0\n    currentZeros = 0\n\n    for c in s:\n      if c == '0':\n        currentOnes = 0\n        currentZeros += 1\n        longestZeros = max(longestZeros, currentZeros)\n      else:\n        currentZeros = 0\n        currentOnes += 1\n        longestOnes = max(longestOnes, currentOnes)\n\n    return longestOnes > longestZeros",
      "title": "1869. Longer Contiguous Segments of Ones than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63cd84ed-6343-4e32-8ffb-627cc921ed15",
      "code": "class Solution:\n  def minSpeedOnTime(self, dist: list[int], hour: float) -> int:\n    ans = -1\n    l = 1\n    r = int(1e7)\n\n    def time(speed: int) -> float:\n      summ = 0\n      for i in range(len(dist) - 1):\n        summ += math.ceil(dist[i] / speed)\n      return summ + dist[-1] / speed\n\n    while l <= r:\n      m = (l + r) // 2\n      if time(m) > hour:\n        l = m + 1\n      else:\n        ans = m\n        r = m - 1\n\n    return ans",
      "title": "1870. Minimum Speed to Arrive on Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee8b101c-7eff-4eed-aed8-4904d8648695",
      "code": "class Solution:\n  def canReach(self, s: str, minJump: int, maxJump: int) -> bool:\n    count = 0\n    dp = [True] + [False] * (len(s) - 1)\n\n    for i in range(minJump, len(s)):\n      count += dp[i - minJump]\n      if i - maxJump > 0:\n        count -= dp[i - maxJump - 1]\n      dp[i] = count and s[i] == '0'\n\n    return dp[-1]",
      "title": "1871. Jump Game VII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3ba2569f-7e2b-40f9-b013-7df174ceefe4",
      "code": "class Solution:\n  def stoneGameVIII(self, stones: list[int]) -> int:\n    n = len(stones)\n    prefix = list(itertools.accumulate(stones))\n    # dp[i] := the maximum score difference the current player can get when the\n    # game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    dp = [-math.inf] * n\n\n    # Must take all when there're only two stones left.\n    dp[n - 2] = prefix[-1]\n\n    for i in reversed(range(n - 2)):\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1])\n\n    return dp[0]",
      "title": "1872. Stone Game VIII",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e4ef067-0c87-4475-a215-5b66f2859592",
      "code": "class Solution:\n  def minProductSum(self, nums1: list[int], nums2: list[int]) -> int:\n    return sum([a * b for a, b in zip(sorted(nums1), sorted(nums2, reverse=True))])",
      "title": "1874. Minimize Product Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8bfa5f5e-c80f-4f62-875c-875450087e52",
      "code": "class Solution:\n  def countGoodSubstrings(self, s: str) -> int:\n    ans = 0\n\n    for a, b, c in zip(s, s[1:], s[2:]):\n      if a == b or a == c or b == c:\n        continue\n      ans += 1\n\n    return ans",
      "title": "1876. Substrings of Size Three with Distinct Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f1d84f9a-6bd6-4f25-aa3b-e2822c530003",
      "code": "class Solution:\n  def minPairSum(self, nums: list[int]) -> int:\n    nums.sort()\n    return max(nums[i] + nums[len(nums) - 1 - i] for i in range(len(nums) // 2))",
      "title": "1877. Minimize Maximum Pair Sum in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e1d4e8b4-8341-46db-8f0a-12fb031b8b2e",
      "code": "from sortedcontainers import SortedSet\n\n\nclass Solution:\n  def getBiggestThree(self, grid: list[list[int]]) -> list[int]:\n    m = len(grid)\n    n = len(grid[0])\n    sums = SortedSet()\n\n    for i in range(m):\n      for j in range(n):\n        sz = 0\n        while i + sz < m and i - sz >= 0 and j + 2 * sz < n:\n          summ = grid[i][j] if sz == 0 else self._getSum(grid, i, j, sz)\n          sums.add(summ)\n          if len(sums) > 3:\n            sums.pop(0)\n          sz += 1\n\n    return sums\n\n  def _getSum(self, grid: list[list[int]], i: int, j: int, sz: int) -> int:\n    \"\"\"\n    Returns the sum of the rhombus, where the top grid is (i, j) and the edge\n    size is `sz`.\n    \"\"\"\n    x = i\n    y = j\n    summ = 0\n\n    # Go left down.\n    for _ in range(sz):\n      x -= 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right down.\n    for _ in range(sz):\n      x += 1\n      y += 1\n      summ += grid[x][y]\n\n    # Go right up.\n    for _ in range(sz):\n      x += 1\n      y -= 1\n      summ += grid[x][y]\n\n    # Go left up.\n    for _ in range(sz):\n      x -= 1\n      y -= 1\n      summ += grid[x][y]\n\n    return summ",
      "title": "1878. Get Biggest Three Rhombus Sums in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e258f61-91d9-4b71-ab7a-63a50f4fe8ff",
      "code": "class Solution:\n  def minimumXORSum(self, nums1: list[int], nums2: list[int]) -> int:\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      i = mask.bit_count()\n      if i == len(nums1):\n        return 0\n      return min((nums1[i] ^ nums2[j]) + dp(mask | 1 << j)\n                 for j in range(len(nums2)) if not mask >> j & 1)\n    return dp(0)",
      "title": "1879. Minimum XOR Sum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "123d8247-bea8-48b5-b717-5e7584902225",
      "code": "class Solution:\n  def isSumEqual(\n      self,\n      firstWord: str,\n      secondWord: str,\n      targetWord: str,\n  ) -> bool:\n    first = self._getNumber(firstWord)\n    second = self._getNumber(secondWord)\n    target = self._getNumber(targetWord)\n    return first + second == target\n\n  def _getNumber(self, word: str) -> int:\n    num = 0\n    for c in word:\n      num = num * 10 + ord(c) - ord('a')\n    return num",
      "title": "1880. Check if Word Equals Summation of Two Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b71f8407-b5b0-4f47-ad35-ba04e74d7e19",
      "code": "class Solution:\n  def maxValue(self, n: str, x: int) -> str:\n    isNegative = n[0] == '-'\n\n    for i, c in enumerate(n):\n      if not isNegative and int(c) < x or isNegative and int(c) > x:\n        return n[:i] + str(x) + n[i:]\n\n    return n + str(x)",
      "title": "1881. Maximum Value after Insertion",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0695ef41-4f33-43ce-8af2-4119b5c69d37",
      "code": "class Solution:\n  def assignTasks(self, servers: list[int], tasks: list[int]) -> list[int]:\n    ans = []\n    free = []  # (weight, index, freeTime)\n    used = []  # (freeTime, weight, index)\n\n    for i, weight in enumerate(servers):\n      heapq.heappush(free, (weight, i, 0))\n\n    for i, executionTime in enumerate(tasks):  # i := the current time\n      # Poll all servers that'll be free at time i.\n      while used and used[0][0] <= i:\n        curr = heapq.heappop(used)\n        heapq.heappush(free, (curr[1], curr[2], curr[0]))\n      if free:\n        curr = heapq.heappop(free)\n        ans.append(curr[1])\n        heapq.heappush(used, (i + executionTime, curr[0], curr[1]))\n      else:\n        curr = heapq.heappop(used)\n        ans.append(curr[2])\n        heapq.heappush(used, (curr[0] + executionTime, curr[1], curr[2]))\n\n    return ans",
      "title": "1882. Process Tasks Using Servers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62b204c7-0c78-4761-bd90-1e16c36afae0",
      "code": "class Solution:\n  def minSkips(self, dist: list[int], speed: int, hoursBefore: int) -> int:\n    INF = 10**7\n    EPS = 1e-9\n    n = len(dist)\n    # dp[i][j] := the minimum time, where i is the number of roads we traversed\n    # so far and j is the number of skips we did\n    dp = [[INF] * (n + 1) for _ in range(n + 1)]\n    dp[0][0] = 0\n\n    for i, d in enumerate(dist, 1):\n      dp[i][0] = math.ceil(dp[i - 1][0] + d / speed - EPS)\n      for j in range(1, i + 1):\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       math.ceil(dp[i - 1][j] + d / speed - EPS))\n\n    for j, time in enumerate(dp[-1]):\n      if time <= hoursBefore:\n        return j\n\n    return -1",
      "title": "1883. Minimum Skips to Arrive at Meeting On Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7cd8142-0cc3-4ba8-83c8-7941584e92b7",
      "code": "class Solution:\n  def countPairs(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    arr = sorted([x - y for x, y in zip(nums1, nums2)])\n\n    for i, a in enumerate(arr):\n      index = bisect_left(arr, -a + 1)\n      ans += len(arr) - max(i + 1, index)\n\n    return ans",
      "title": "1885. Count Pairs in Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f4f9d7e-b7cf-431b-b587-6c79ac4d16c9",
      "code": "class Solution:\n  def findRotation(self, mat: list[list[int]], target: list[list[int]]) -> bool:\n    for _ in range(4):\n      if mat == target:\n        return True\n      mat = [list(x) for x in zip(*mat[::-1])]\n    return False",
      "title": "1886. Determine Whether Matrix Can Be Obtained By Rotation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b72667b-0f21-4ae1-a9cf-9329a8db210f",
      "code": "class Solution:\n  def reductionOperations(self, nums: list[int]) -> int:\n    ans = 0\n\n    nums.sort()\n\n    for i in range(len(nums) - 1, 0, -1):\n      if nums[i] != nums[i - 1]:\n        ans += len(nums) - i\n\n    return ans",
      "title": "1887. Reduction Operations to Make the Array Elements Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d10c9a68-05db-4672-a8eb-6d7e4f5523cf",
      "code": "class Solution:\n  def minFlips(self, s: str) -> int:\n    n = len(s)\n    # count[0][0] :=  the number of '0' in the even indices\n    # count[0][1] :=  the number of '0' in the odd indices\n    # count[1][0] :=  the number of '1' in the even indices\n    # count[1][1] :=  the number of '1' in the odd indices\n    count = [[0] * 2 for _ in range(2)]\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] += 1\n\n    # min(make all 0s in the even indices + make all 1s in the odd indices,\n    #     make all 1s in the even indices + make all 0s in the odd indices)\n    ans = min(count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    for i, c in enumerate(s):\n      count[int(c)][i % 2] -= 1\n      count[int(c)][(n + i) % 2] += 1\n      ans = min(ans, count[1][0] + count[0][1], count[0][0] + count[1][1])\n\n    return ans",
      "title": "1888. Minimum Number of Flips to Make the Binary String Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c8f5727-fbae-418d-b629-dc2ed3fc2d4a",
      "code": "class Solution:\n  def minWastedSpace(self, packages: list[int], boxes: list[list[int]]) -> int:\n    ans = math.inf\n\n    packages.sort()\n\n    for box in boxes:\n      box.sort()\n      if box[-1] < packages[-1]:\n        continue\n      accu = 0\n      i = 0\n      for b in box:\n        j = bisect.bisect(packages, b, i)\n        accu += b * (j - i)\n        i = j\n      ans = min(ans, accu)\n\n    return -1 if ans == math.inf else (ans - sum(packages)) % 1_000_000_007",
      "title": "1889. Minimum Space Wasted From Packaging",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edfa455b-b83f-408d-a860-5eb1753f1c60",
      "code": "class Solution:\n  def maxLength(self, ribbons: list[int], k: int) -> int:\n    def isCutPossible(length: int) -> bool:\n      count = 0\n      for ribbon in ribbons:\n        count += ribbon // length\n      return count >= k\n\n    l = 1\n    r = sum(ribbons) // k + 1\n\n    while l < r:\n      m = (l + r) // 2\n      if not isCutPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l - 1",
      "title": "1891. Cutting Ribbons",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bf6e4bdf-49e5-45bd-836d-5250bc86fc63",
      "code": "class Solution:\n  def isCovered(self, ranges: list[list[int]], left: int, right: int) -> bool:\n    seen = [0] * 52\n\n    for l, r in ranges:\n      seen[l] += 1\n      seen[r + 1] -= 1\n\n    for i in range(1, 52):\n      seen[i] += seen[i - 1]\n\n    return all(seen[i] for i in range(left, right + 1))",
      "title": "1893. Check if All the Integers in a Range Are Covered",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff9af587-8dde-4cfd-be4e-1ce7534e6b36",
      "code": "class Solution:\n  def chalkReplacer(self, chalk: list[int], k: int) -> int:\n    k %= sum(chalk)\n    if k == 0:\n      return 0\n\n    for i, c in enumerate(chalk):\n      k -= c\n      if k < 0:\n        return i",
      "title": "1894. Find the Student that Will Replace the Chalk",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50175991-7a7c-4961-ac9c-11ae7f016260",
      "code": "class Solution:\n  def largestMagicSquare(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # prefixRow[i][j] := the sum of the first j numbers in the i-th row\n    prefixRow = [[0] * (n + 1) for _ in range(m)]\n    # prefixCol[i][j] := the sum of the first j numbers in the i-th column\n    prefixCol = [[0] * (m + 1) for _ in range(n)]\n\n    for i in range(m):\n      for j in range(n):\n        prefixRow[i][j + 1] = prefixRow[i][j] + grid[i][j]\n        prefixCol[j][i + 1] = prefixCol[j][i] + grid[i][j]\n\n    def isMagicSquare(i: int, j: int, k: int) -> bool:\n      \"\"\"Returns True if grid[i..i + k)[j..j + k) is a magic square.\"\"\"\n      diag, antiDiag = 0, 0\n      for d in range(k):\n        diag += grid[i + d][j + d]\n        antiDiag += grid[i + d][j + k - 1 - d]\n      if diag != antiDiag:\n        return False\n      for d in range(k):\n        if self._getSum(prefixRow, i + d, j, j + k - 1) != diag:\n          return False\n        if self._getSum(prefixCol, j + d, i, i + k - 1) != diag:\n          return False\n      return True\n\n    def containsMagicSquare(k: int) -> bool:\n      \"\"\"Returns True if the grid contains any magic square of size k x k.\"\"\"\n      for i in range(m - k + 1):\n        for j in range(n - k + 1):\n          if isMagicSquare(i, j, k):\n            return True\n      return False\n\n    for k in range(min(m, n), 1, -1):\n      if containsMagicSquare(k):\n        return k\n\n    return 1\n\n  def _getSum(self, prefix: list[list[int]], i: int, l: int, r: int) -> int:\n    \"\"\"Returns sum(grid[i][l..r]) or sum(grid[l..r][i]).\"\"\"\n    return prefix[i][r + 1] - prefix[i][l]",
      "title": "1895. Largest Magic Square",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc08d41d-84ed-4edc-b73a-0dc5c344f935",
      "code": "class Solution:\n  def minOperationsToFlip(self, expression: str) -> int:\n    stack = []  # [(the expression, the cost to toggle the expression)]\n\n    for e in expression:\n      if e in '(&|':\n        # These aren't expressions, so the cost is meaningless.\n        stack.append((e, 0))\n        continue\n      if e == ')':\n        lastPair = stack.pop()\n        stack.pop()  # Pop '('.\n      else:  # e == '0' or e == '1'\n        # Store the '0' or '1'. The cost to change their values is just 1,\n        # whether it's changing '0' to '1' or '1' to '0'.\n        lastPair = (e, 1)\n      if stack and stack[-1][0] in '&|':\n        op = stack.pop()[0]\n        a, costA = stack.pop()\n        b, costB = lastPair\n        # Determine the cost to toggle op(a, b).\n        if op == '&':\n          if a == '0' and b == '0':\n            # Change '&' to '|' and a|b to '1'.\n            lastPair = ('0', 1 + min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          elif a == '1' and b == '0':\n            # Change '&' to '|'.\n            lastPair = ('0', 1)\n          else:  # a == '1' and b == '1'\n            # Change a|b to '0'.\n            lastPair = ('1', min(costA, costB))\n        else:  # op == '|'\n          if a == '0' and b == '0':\n            # Change a|b to '1'.\n            lastPair = ('0', min(costA, costB))\n          elif a == '0' and b == '1':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          elif a == '1' and b == '0':\n            # Change '|' to '&'.\n            lastPair = ('1', 1)\n          else:  # a == '1' and b == '1'\n            # Change '|' to '&' and a|b to '0'.\n            lastPair = ('1', 1 + min(costA, costB))\n      stack.append(lastPair)\n\n    return stack[-1][1]",
      "title": "1896. Minimum Cost to Change the Final Value of Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "93022a60-ee8a-4609-b28b-01992a892844",
      "code": "class Solution:\n  def makeEqual(self, words: list[str]) -> bool:\n    return all(c % len(words) == 0\n               for c in collections.Counter(''.join(words)).values())",
      "title": "1897. Redistribute Characters to Make All Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6f33f24-704c-4864-bb38-f987b0a4c8a5",
      "code": "class Solution:\n  def maximumRemovals(self, s: str, p: str, removable: list[int]) -> int:\n    l = 0\n    r = len(removable) + 1\n\n    def remove(k: int) -> str:\n      removed = [c for c in s]\n      for i in range(k):\n        removed[removable[i]] = '*'\n      return ''.join(removed)\n\n    def isSubsequence(p: str, s: str) -> bool:\n      i = 0\n      for j, c in enumerate(s):\n        if p[i] == s[j]:\n          i += 1\n          if i == len(p):\n            return True\n      return False\n\n    while l < r:\n      m = (l + r) // 2\n      removed = remove(m)\n      if isSubsequence(p, removed):\n        l = m + 1\n      else:\n        r = m\n\n    return l - 1",
      "title": "1898. Maximum Number of Removable Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f547800-510f-4632-9e41-a2ce0713b5d5",
      "code": "class Solution:\n  def mergeTriplets(self, triplets: list[list[int]], target: list[int]) -> bool:\n    merged = [0] * len(target)\n\n    for triplet in triplets:\n      if all(a <= b for a, b in zip(triplet, target)):\n        for i in range(3):\n          merged[i] = max(merged[i], triplet[i])\n\n    return merged == target",
      "title": "1899. Merge Triplets to Form Target Triplet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb839807-ed0b-4639-a4d1-2bb66b3e699c",
      "code": "class Solution:\n  def earliestAndLatest(self, n: int,\n                        firstPlayer: int, secondPlayer: int) -> list[int]:\n    @functools.lru_cache(None)\n    def dp(l: int, r: int, k: int) -> list[int]:\n      \"\"\"\n      Returns the (earliest, latest) pair, the first player is the l-th player\n      from the front, the second player is the r-th player from the end, and\n      there're k people.\n      \"\"\"\n      if l == r:\n        return [1, 1]\n      if l > r:\n        return dp(r, l, k)\n\n      a = math.inf\n      b = -math.inf\n\n      # Enumerate all the possible positions.\n      for i in range(1, l + 1):\n        for j in range(l - i + 1, r - i + 1):\n          if not l + r - k // 2 <= i + j <= (k + 1) // 2:\n            continue\n          x, y = dp(i, j, (k + 1) // 2)\n          a = min(a, x + 1)\n          b = max(b, y + 1)\n\n      return [a, b]\n\n    return dp(firstPlayer, n - secondPlayer + 1, n)",
      "title": "1900. The Earliest and Latest Rounds Where Players Compete",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "227b3444-d0d5-4092-85e0-ed7e54a456bb",
      "code": "class Solution:\n  def findPeakGrid(self, mat: list[list[int]]) -> list[int]:\n    l = 0\n    r = len(mat) - 1\n\n    while l < r:\n      m = (l + r) // 2\n      if max(mat[m]) >= max(mat[m + 1]):\n        r = m\n      else:\n        l = m + 1\n\n    return [l, mat[l].index(max(mat[l]))]",
      "title": "1901. Find a Peak Element II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e614f73c-ea34-45f5-9b14-2bda8b175d46",
      "code": "class Solution:\n  def largestOddNumber(self, num: str) -> str:\n    for i, n in reversed(list(enumerate(num))):\n      if int(n) % 2 == 1:\n        return num[:i + 1]\n    return ''",
      "title": "1903. Largest Odd Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97b5cb0b-14c1-4193-ac67-81b656b018d7",
      "code": "class Solution:\n  def numberOfRounds(self, loginTime: str, logoutTime: str) -> int:\n    start = self._getMinutes(loginTime)\n    finish = self._getMinutes(logoutTime)\n    if start > finish:\n      finish += 60 * 24\n\n    return max(0, finish // 15 - (start + 14) // 15)\n\n  def _getMinutes(self, time: str) -> int:\n    h, m = map(int, time.split(':'))\n    return 60 * h + m",
      "title": "1904. The Number of Full Rounds You Have Played",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f5f6f424-7fc1-49e3-8512-ad9b078e73c2",
      "code": "class Solution:\n  def countSubIslands(\n      self,\n      grid1: list[list[int]],\n      grid2: list[list[int]],\n  ) -> int:\n    m = len(grid2)\n    n = len(grid2[0])\n\n    def dfs(i: int, j: int) -> int:\n      if i < 0 or i == m or j < 0 or j == n:\n        return 1\n      if grid2[i][j] != 1:\n        return 1\n\n      grid2[i][j] = 2  # Mark 2 as visited.\n\n      return (dfs(i + 1, j) & dfs(i - 1, j) &\n              dfs(i, j + 1) & dfs(i, j - 1) & grid1[i][j])\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid2[i][j] == 1:\n          ans += dfs(i, j)\n\n    return ans",
      "title": "1905. Count Sub Islands",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c44fe95-a671-4c6b-ad1a-c8e57dd7f911",
      "code": "class Solution:\n  def minDifference(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    numToIndices = [[] for _ in range(101)]\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    if len(numToIndices[nums[0]]) == len(nums):\n      return [-1] * len(queries)\n\n    ans = []\n\n    for l, r in queries:\n      prevNum = -1\n      minDiff = 101\n      for num in range(1, 101):\n        indices = numToIndices[num]\n        i = bisect_left(indices, l)\n        if i == len(indices) or indices[i] > r:\n          continue\n        if prevNum != -1:\n          minDiff = min(minDiff, num - prevNum)\n        prevNum = num\n      ans.append(-1 if minDiff == 101 else minDiff)\n\n    return ans",
      "title": "1906. Minimum Absolute Difference Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aec12f3b-2f87-4acb-bfe9-804f8461a965",
      "code": "class Solution:\n  def nimGame(self, piles: list[int]) -> bool:\n    return functools.reduce(operator.xor, piles) > 0",
      "title": "1908. Game of Nim",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4f075e57-db29-45c5-b116-5732cb950cfb",
      "code": "class Solution:\n  def canBeIncreasing(self, nums: list[int]) -> bool:\n    removed = False\n\n    for i in range(1, len(nums)):\n      if nums[i - 1] >= nums[i]:\n        if removed:\n          return False\n        removed = True  # Remove nums[i - 1].\n        if i > 1 and nums[i - 2] >= nums[i]:\n          nums[i] = nums[i - 1]  # Remove nums[i] instead.\n\n    return True",
      "title": "1909. Remove One Element to Make the Array Strictly Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d395a6d8-da72-4809-9ade-8a30ca360439",
      "code": "class Solution:\n  def removeOccurrences(self, s: str, part: str) -> str:\n    n = len(s)\n    k = len(part)\n\n    t = [' '] * n\n    j = 0  # t's index\n\n    for i, c in enumerate(s):\n      t[j] = c\n      j += 1\n      if j >= k and ''.join(t[j - k:j]) == part:\n        j -= k\n\n    return ''.join(t[:j])",
      "title": "1910. Remove All Occurrences of a Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5f901a46-97db-41fc-9dd2-5de6f405f449",
      "code": "class Solution:\n  def maxAlternatingSum(self, nums: list[int]) -> int:\n    even = 0  # the maximum alternating sum ending in an even index\n    odd = 0  # the maximum alternating sum ending in an odd index\n\n    for num in nums:\n      even = max(even, odd + num)\n      odd = even - num\n\n    return even",
      "title": "1911. Maximum Alternating Subsequence Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af7ce2c9-6b16-4383-809d-8fa25c17fa4f",
      "code": "class Solution:\n  def maxProductDifference(self, nums: list[int]) -> int:\n    max1 = -math.inf\n    max2 = -math.inf\n    min1 = math.inf\n    min2 = math.inf\n\n    for num in nums:\n      if num > max1:\n        max2 = max1\n        max1 = num\n      elif num > max2:\n        max2 = num\n      if num < min1:\n        min2 = min1\n        min1 = num\n      elif num < min2:\n        min2 = num\n\n    return max1 * max2 - min1 * min2",
      "title": "1913. Maximum Product Difference Between Two Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5ccbba79-a848-405d-aae2-ff333299331c",
      "code": "class Solution:\n  def rotateGrid(self, grid: list[list[int]], k: int) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    t = 0  # the top\n    l = 0  # the left\n    b = m - 1  # the bottom\n    r = n - 1  # the right\n\n    while t < b and l < r:\n      elementInThisLayer = 2 * (b - t + 1) + 2 * (r - l + 1) - 4\n      netRotations = k % elementInThisLayer\n      for _ in range(netRotations):\n        topLeft = grid[t][l]\n        for j in range(l, r):\n          grid[t][j] = grid[t][j + 1]\n        for i in range(t, b):\n          grid[i][r] = grid[i + 1][r]\n        for j in range(r, l, - 1):\n          grid[b][j] = grid[b][j - 1]\n        for i in range(b, t, -1):\n          grid[i][l] = grid[i - 1][l]\n        grid[t + 1][l] = topLeft\n      t += 1\n      l += 1\n      b -= 1\n      r -= 1\n\n    return grid",
      "title": "1914. Cyclically Rotating a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f3467887-d98c-4dba-84d8-9f2303171d03",
      "code": "class Solution:\n  def wonderfulSubstrings(self, word: str) -> int:\n    ans = 0\n    prefix = 0  # the binary prefix\n    count = [0] * 1024  # the binary prefix count\n    count[0] = 1  # the empty string \"\"\n\n    for c in word:\n      prefix ^= 1 << ord(c) - ord('a')\n      # All the letters occur even number of times.\n      ans += count[prefix]\n      # `c` occurs odd number of times.\n      ans += sum(count[prefix ^ 1 << i] for i in range(10))\n      count[prefix] += 1\n\n    return ans",
      "title": "1915. Number of Wonderful Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d43050da-b02e-4a2e-975b-e7e7dea4732c",
      "code": "class Solution:\n  def waysToBuildRooms(self, prevRoom: list[int]) -> int:\n    MOD = 1_000_000_007\n    graph = collections.defaultdict(list)\n\n    for i, prev in enumerate(prevRoom):\n      graph[prev].append(i)\n\n    def dfs(node: int) -> tuple[int, int]:\n      if not graph[node]:\n        return 1, 1\n\n      ans = 1\n      l = 0\n\n      for child in graph[node]:\n        temp, r = dfs(child)\n        ans = (ans * temp * math.comb(l + r, r)) % MOD\n        l += r\n\n      return ans, l + 1\n\n    return dfs(0)[0]",
      "title": "1916. Count Ways to Build Rooms in an Ant Colony",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4179024-9d6a-4682-a7b2-ffd2714d7252",
      "code": "class Solution:\n  def kthSmallestSubarraySum(self, nums: list[int], k: int) -> int:\n    def numSubarrayLessThan(m: int) -> int:\n      res = 0\n      summ = 0\n      l = 0\n      for r, num in enumerate(nums):\n        summ += num\n        while summ > m:\n          summ -= nums[l]\n          l += 1\n        res += r - l + 1\n      return res\n\n    return bisect.bisect_left(range(sum(nums)), k, key=numSubarrayLessThan)",
      "title": "1918. Kth Smallest Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1b8a5e7-8583-4f45-bc21-68c0f1fdf114",
      "code": "class Solution:\n  def buildArray(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n\n    for i, num in enumerate(nums):\n      nums[i] += n * (nums[num] % n)\n\n    for i in range(n):\n      nums[i] //= n\n\n    return nums",
      "title": "1920. Build Array from Permutation",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de9f5dd1-abfd-4aca-857e-ceb427182ee2",
      "code": "class Solution:\n  def eliminateMaximum(self, dist: list[int], speed: list[int]) -> int:\n    for i, arrivalTime in enumerate(\n            sorted([(d - 1) // s for d, s in zip(dist, speed)])):\n      if i > arrivalTime:\n        return i\n    return len(dist)",
      "title": "1921. Eliminate Maximum Number of Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c5c1f94-fe43-434a-9f74-92eb5204eb77",
      "code": "class Solution:\n  def countGoodNumbers(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    def modPow(x: int, n: int) -> int:\n      if n == 0:\n        return 1\n      if n % 2 == 1:\n        return x * modPow(x, n - 1) % MOD\n      return modPow(x * x % MOD, n // 2)\n\n    return modPow(4 * 5, n // 2) * (1 if n % 2 == 0 else 5) % MOD",
      "title": "1922. Count Good Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c62060b3-df5d-4381-910c-dc63557f76b5",
      "code": "class Solution:\n  def __init__(self):\n    self.BASE = 165_131\n    self.HASH = 8_417_508_174_513\n\n  def longestCommonSubpath(self, n: int, paths: list[list[int]]) -> int:\n    l = 0\n    r = len(paths[0])\n\n    while l < r:\n      m = l + (r - l + 1) // 2\n      if self._checkCommonSubpath(paths, m):\n        l = m\n      else:\n        r = m - 1\n\n    return l\n\n  def _checkCommonSubpath(self, paths: list[list[int]], m: int) -> bool:\n    \"\"\"\n    Returns True if there's a common subpath of length m for all the paths.\n    \"\"\"\n    # Calculate the hash values for subpaths of length m for every path.\n    hashSets = [self._rabinKarp(path, m) for path in paths]\n\n    # Check if there is a common subpath of length m.\n    for subpathHash in hashSets[0]:\n      if all(subpathHash in hashSet for hashSet in hashSets):\n        return True\n\n    return False\n\n  def _rabinKarp(self, path: list[int], m: int) -> set[int]:\n    \"\"\"Returns the hash values for subpaths of length m in the path.\"\"\"\n    hashes = set()\n    maxPower = 1\n    hash = 0\n\n    for i, num in enumerate(path):\n      hash = (hash * self.BASE + num) % self.HASH\n      if i >= m:\n        hash = (hash - path[i - m] * maxPower %\n                self.HASH + self.HASH) % self.HASH\n      else:\n        maxPower = maxPower * self.BASE % self.HASH\n      if i >= m - 1:\n        hashes.add(hash)\n\n    return hashes",
      "title": "1923. Longest Common Subpath",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b24f5818-6a1b-4f2a-9722-6eaefff11706",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass Point:\n  x: float\n  y: float\n\n\n@dataclass(frozen=True)\nclass Disk:\n  center: Point\n  radius: float\n\n\nclass Solution:\n  def outerTrees(self, trees: list[list[int]]) -> list[float]:\n    points = [Point(x, y) for x, y in trees]\n    disk = self._welzl(points, 0, [])\n    return [disk.center.x, disk.center.y, disk.radius]\n\n  def _welzl(\n      self,\n      points: list[Point],\n      i: int,\n      planePoints: list[Point],\n  ) -> Disk:\n    \"\"\"Returns the smallest disk that encloses points[i..n).\n\n    https://en.wikipedia.org/wiki/Smallest-disk_problem#Welzl's_algorithm\n    \"\"\"\n    if i == len(points) or len(planePoints) == 3:\n      return self._trivial(planePoints)\n    disk = self._welzl(points, i + 1, planePoints)\n    if self._inside(disk, points[i]):\n      return disk\n    return self._welzl(points, i + 1, planePoints + [points[i]])\n\n  def _trivial(self, planePoints: list[Point]) -> Disk:\n    \"\"\"Returns the smallest disk that encloses `planePoints`.\"\"\"\n    if len(planePoints) == 0:\n      return Disk(Point(0, 0), 0)\n    if len(planePoints) == 1:\n      return Disk(Point(planePoints[0].x, planePoints[0].y), 0)\n    if len(planePoints) == 2:\n      return self._getDisk(planePoints[0], planePoints[1])\n\n    disk01 = self._getDisk(planePoints[0], planePoints[1])\n    if self._inside(disk01, planePoints[2]):\n      return disk01\n\n    disk02 = self._getDisk(planePoints[0], planePoints[2])\n    if self._inside(disk02, planePoints[1]):\n      return disk02\n\n    disk12 = self._getDisk(planePoints[1], planePoints[2])\n    if self._inside(disk12, planePoints[0]):\n      return disk12\n\n    return self._getDiskFromThree(\n        planePoints[0],\n        planePoints[1],\n        planePoints[2])\n\n  def _getDisk(self, A: Point, B: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A and B.\"\"\"\n    x = (A.x + B.x) / 2\n    y = (A.y + B.y) / 2\n    return Disk(Point(x, y), self._distance(A, B) / 2)\n\n  def _getDiskFromThree(self, A: Point, B: Point, C: Point) -> Disk:\n    \"\"\"Returns the smallest disk that encloses the points A, B, and C.\"\"\"\n    # Calculate midpoints.\n    mAB = Point((A.x + B.x) / 2, (A.y + B.y) / 2)\n    mBC = Point((B.x + C.x) / 2, (B.y + C.y) / 2)\n\n    # Calculate the slopes and the perpendicular slopes.\n    slopeAB = math.inf if B.x == A.x else (B.y - A.y) / (B.x - A.x)\n    slopeBC = math.inf if C.x == B.x else (C.y - B.y) / (C.x - B.x)\n    perpSlopeAB = math.inf if slopeAB == 0 else -1 / slopeAB\n    perpSlopeBC = math.inf if slopeBC == 0 else -1 / slopeBC\n\n    # Calculate the center.\n    x = (perpSlopeBC * mBC.x - perpSlopeAB * mAB.x +\n         mAB.y - mBC.y) / (perpSlopeBC - perpSlopeAB)\n    y = perpSlopeAB * (x - mAB.x) + mAB.y\n    center = Point(x, y)\n    return Disk(center, self._distance(center, A))\n\n  def _inside(self, disk: Disk, point: Point) -> bool:\n    \"\"\"Returns True if the point is inside the disk.\"\"\"\n    return disk.radius > 0 and self._distance(disk.center, point) <= disk.radius\n\n  def _distance(self, A: Point, B: Point) -> float:\n    dx = A.x - B.x\n    dy = A.y - B.y\n    return math.sqrt(dx**2 + dy**2)",
      "title": "1924. Erect the Fence II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff77e42c-af87-4752-9b38-4836553ed223",
      "code": "class Solution:\n  def countTriples(self, n: int) -> int:\n    ans = 0\n    squared = set()\n\n    for i in range(1, n + 1):\n      squared.add(i * i)\n\n    for a in squared:\n      for b in squared:\n        if a + b in squared:\n          ans += 1\n\n    return ans",
      "title": "1925. Count Square Sum Triples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0dcd00b7-9d8b-4f55-aa4c-66a07808e2d2",
      "code": "class Solution:\n  def nearestExit(self, maze: list[list[str]], entrance: list[int]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(maze)\n    n = len(maze[0])\n    q = collections.deque([(entrance[0], entrance[1])])\n    seen = {(entrance[0], entrance[1])}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen or maze[x][y] == '+':\n            continue\n          if x == 0 or x == m - 1 or y == 0 or y == n - 1:\n            return step\n          q.append((x, y))\n          seen.add((x, y))\n      step += 1\n\n    return -1",
      "title": "1926. Nearest Exit from Entrance in Maze",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "46cd8a65-aead-4728-b584-ee722f582c82",
      "code": "class Solution:\n  def sumGame(self, num: str) -> bool:\n    n = len(num)\n    ans = 0.0\n\n    def getExpectation(c: str) -> float:\n      return 4.5 if c == '?' else int(c)\n\n    for i in range(n // 2):\n      ans += getExpectation(num[i])\n\n    for i in range(n // 2, n):\n      ans -= getExpectation(num[i])\n\n    return ans != 0.0",
      "title": "1927. Sum Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77867473-66b3-410d-b9d4-96cb97115aae",
      "code": "class Solution:\n  def minCost(\n      self,\n      maxTime: int,\n      edges: list[list[int]],\n      passingFees: list[int],\n  ) -> int:\n    n = len(passingFees)\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1, maxTime, passingFees)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n      maxTime: int,\n      passingFees: list[int],\n  ) -> int:\n    # cost[i] := the minimum cost to reach the i-th city\n    cost = [math.inf] * len(graph)\n    # dist[i] := the minimum time to reach the i-th city\n    dist = [maxTime + 1] * len(graph)\n\n    cost[src] = passingFees[src]\n    dist[src] = 0\n    minHeap = [(cost[src], dist[src], src)]  # (cost[u], dist[u], u)\n\n    while minHeap:\n      currCost, d, u = heapq.heappop(minHeap)\n      if u == dst:\n        return cost[dst]\n      if d > dist[u] and currCost > cost[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w > maxTime:\n          continue\n        # Go from u -> v.\n        if currCost + passingFees[v] < cost[v]:\n          cost[v] = currCost + passingFees[v]\n          dist[v] = d + w\n          heapq.heappush(minHeap, (cost[v], dist[v], v))\n        elif d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (currCost + passingFees[v], dist[v], v))\n\n    return -1",
      "title": "1928. Minimum Cost to Reach Destination in Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "199d3fdd-635e-4973-ba44-f1265278e157",
      "code": "class Solution:\n  def getConcatenation(self, nums: list[int]) -> list[int]:\n    return nums * 2",
      "title": "1929. Concatenation of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c93d6862-7c75-443d-bc17-0033fbcd3d89",
      "code": "class Solution:\n  def countPalindromicSubsequence(self, s: str) -> int:\n    ans = 0\n    first = [len(s)] * 26\n    last = [-1] * 26\n\n    for i, c in enumerate(s):\n      index = ord(c) - ord('a')\n      first[index] = min(first[index], i)\n      last[index] = i\n\n    for f, l in zip(first, last):\n      if f < l:\n        ans += len(set(s[f + 1:l]))\n\n    return ans",
      "title": "1930. Unique Length-3 Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c45270b-d2a8-4301-97a6-c654004fccc2",
      "code": "class Solution:\n  def colorTheGrid(self, m: int, n: int) -> int:\n    def getColor(mask: int, r: int) -> int:\n      return mask >> r * 2 & 3\n\n    def setColor(mask: int, r: int, color: int) -> int:\n      return mask | color << r * 2\n\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(r: int, c: int, prevColMask: int, currColMask: int) -> int:\n      if c == n:\n        return 1\n      if r == m:\n        return dp(0, c + 1, currColMask, 0)\n\n      ans = 0\n\n      # 1 := red, 2 := green, 3 := blue\n      for color in range(1, 4):\n        if getColor(prevColMask, r) == color:\n          continue\n        if r > 0 and getColor(currColMask, r - 1) == color:\n          continue\n        ans += dp(r + 1, c, prevColMask, setColor(currColMask, r, color))\n        ans %= MOD\n\n      return ans\n\n    return dp(0, 0, 0, 0)",
      "title": "1931. Painting a Grid With Three Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "19a1a604-1ede-43f0-9fb0-090a6bc7405f",
      "code": "class Solution:\n  def canMerge(self, trees: list[TreeNode]) -> TreeNode | None:\n    valToNode = {}  # {val: node}\n    count = collections.Counter()  # {val: freq}\n\n    for tree in trees:\n      valToNode[tree.val] = tree\n      count[tree.val] += 1\n      if tree.left:\n        count[tree.left.val] += 1\n      if tree.right:\n        count[tree.right.val] += 1\n\n    def isValidBST(tree: TreeNode | None, minNode: TreeNode | None,\n                   maxNode: TreeNode | None) -> bool:\n      if not tree:\n        return True\n      if minNode and tree.val <= minNode.val:\n        return False\n      if maxNode and tree.val >= maxNode.val:\n        return False\n      if not tree.left and not tree.right and tree.val in valToNode:\n        val = tree.val\n        tree.left = valToNode[val].left\n        tree.right = valToNode[val].right\n        del valToNode[val]\n\n      return isValidBST(\n          tree.left, minNode, tree) and isValidBST(\n          tree.right, tree, maxNode)\n\n    for tree in trees:\n      if count[tree.val] == 1:\n        if isValidBST(tree, None, None) and len(valToNode) <= 1:\n          return tree\n        return None\n\n    return None",
      "title": "1932. Merge BSTs to Create Single BST",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "409617d6-6bd2-4452-9a84-a19749bf5b1f",
      "code": "class Solution:\n  def isDecomposable(self, s: str) -> bool:\n    twos = 0\n\n    for _, group in itertools.groupby(s):\n      groupLength = len(list(group))\n      if groupLength % 3 == 1:\n        return False\n      if groupLength % 3 == 2:\n        twos += 1\n        if twos > 1:\n          return False\n\n    return twos == 1",
      "title": "1933. Check if String Is Decomposable Into Value-Equal Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c30c944-c2cc-41e9-aa90-3c852bcdd625",
      "code": "class Solution:\n  def canBeTypedWords(self, text: str, brokenLetters: str) -> int:\n    ans = 0\n    broken = set(brokenLetters)\n\n    for word in text.split():\n      ans += all(c not in broken for c in word)\n\n    return ans",
      "title": "1935. Maximum Number of Words You Can Type",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "735e0ff1-fb57-44ab-9230-50f1b9a27c72",
      "code": "class Solution:\n  def addRungs(self, rungs: list[int], dist: int) -> int:\n    ans = 0\n    prev = 0\n\n    for rung in rungs:\n      ans += (rung - prev - 1) // dist\n      prev = rung\n\n    return ans",
      "title": "1936. Add Minimum Number of Rungs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "632768dd-aed5-405e-92eb-9ffde0edede7",
      "code": "class Solution:\n  def maxPoints(self, points: list[list[int]]) -> int:\n    n = len(points[0])\n    # dp[j] := the maximum number of points you can have if points[i][j] is the\n    # most recent cell you picked\n    dp = [0] * n\n\n    for row in points:\n      leftToRight = [0] * n\n      runningMax = 0\n      for j in range(n):\n        runningMax = max(runningMax - 1, dp[j])\n        leftToRight[j] = runningMax\n\n      rightToLeft = [0] * n\n      runningMax = 0\n      for j in range(n - 1, - 1, -1):\n        runningMax = max(runningMax - 1, dp[j])\n        rightToLeft[j] = runningMax\n\n      for j in range(n):\n        dp[j] = max(leftToRight[j], rightToLeft[j]) + row[j]\n\n    return max(dp)",
      "title": "1937. Maximum Number of Points with Cost",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "284f1952-3bf6-41fa-968f-a40b31625cca",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n    self.count = 0\n\n\nclass Trie:\n  def __init__(self):\n    self.root = TrieNode()\n    self.HEIGHT = 17\n\n  def update(self, num: int, val: int) -> None:\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n      node.count += val\n\n  def query(self, num: int) -> int:\n    ans = 0\n    node = self.root\n    for i in range(self.HEIGHT, -1, -1):\n      bit = (num >> i) & 1\n      targetBit = bit ^ 1\n      if node.children[targetBit] and node.children[targetBit].count > 0:\n        ans += 1 << i\n        node = node.children[targetBit]\n      else:\n        node = node.children[targetBit ^ 1]\n    return ans\n\n\nclass Solution:\n  def maxGeneticDifference(\n      self,\n      parents: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [0] * len(queries)\n    rootVal = -1\n    tree = [[] for _ in range(n)]\n    nodeToQueries = collections.defaultdict(list)  # {node: (index, val)}\n    trie = Trie()\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        rootVal = i\n      else:\n        tree[parent].append(i)\n\n    for i, (node, val) in enumerate(queries):\n      nodeToQueries[node].append((i, val))\n\n    def dfs(node: int) -> None:\n      trie.update(node, 1)\n\n      # Answer queries for node\n      for i, val in nodeToQueries[node]:\n        ans[i] = trie.query(val)\n\n      for child in tree[node]:\n        dfs(child)\n\n      trie.update(node, -1)\n\n    dfs(rootVal)\n    return ans",
      "title": "1938. Maximum Genetic Difference Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b164ba17-6b4a-47d2-8302-a42cb87d3c45",
      "code": "class Solution:\n  def longestCommonSubsequence(self, arrays: list[list[int]]) -> list[int]:\n    MAX = 100\n    ans = []\n    count = [0] * (MAX + 1)\n\n    for array in arrays:\n      for a in array:\n        count[a] += 1\n        if count[a] == len(arrays):\n          ans.append(a)\n\n    return ans",
      "title": "1940. Longest Common Subsequence Between Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34da157f-a6be-425f-9a5d-bc51dea53450",
      "code": "class Solution:\n  def areOccurrencesEqual(self, s: str) -> bool:\n    return len(set(collections.Counter(s).values())) == 1",
      "title": "1941. Check if All Characters Have Equal Number of Occurrences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d62e9aa-e876-4b79-95fd-2eca6d94f6a8",
      "code": "class Solution:\n  def smallestChair(self, times: list[list[int]], targetFriend: int) -> int:\n    nextUnsatChair = 0\n    emptyChairs = []\n    occupied = []  # (leaving, chair)\n\n    for i in range(len(times)):\n      times[i].append(i)\n\n    times.sort(key=lambda x: x[0])\n\n    for arrival, leaving, i in times:\n      while len(occupied) > 0 and occupied[0][0] <= arrival:\n        unsatChair = heapq.heappop(occupied)[1]\n        heapq.heappush(emptyChairs, unsatChair)\n      if i == targetFriend:\n        return emptyChairs[0] if len(emptyChairs) > 0 else nextUnsatChair\n      if len(emptyChairs) == 0:\n        heapq.heappush(occupied, (leaving, nextUnsatChair))\n        nextUnsatChair += 1\n      else:\n        emptyChair = heapq.heappop(emptyChairs)\n        heapq.heappush(occupied, (leaving, emptyChair))",
      "title": "1942. The Number of the Smallest Unoccupied Chair",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e42888cb-ee20-42d3-a394-8f7bdabdda2b",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def splitPainting(self, segments: list[list[int]]) -> list[list[int]]:\n    ans = []\n    prevIndex = 0\n    runningMix = 0\n    line = SortedDict()\n\n    for start, end, color in segments:\n      line[start] = line.get(start, 0) + color\n      line[end] = line.get(end, 0) - color\n\n    for i, mix in line.items():\n      if runningMix > 0:\n        ans.append([prevIndex, i, runningMix])\n      runningMix += mix\n      prevIndex = i\n\n    return ans",
      "title": "1943. Describe the Painting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55c81d29-06e3-4efa-9fd2-d32b8a150eb4",
      "code": "class Solution:\n  def canSeePersonsCount(self, heights: list[int]) -> list[int]:\n    ans = [0] * len(heights)\n    stack = []\n\n    for i, height in enumerate(heights):\n      while stack and heights[stack[-1]] <= height:\n        ans[stack.pop()] += 1\n      if stack:\n        ans[stack[-1]] += 1\n      stack.append(i)\n\n    return ans",
      "title": "1944. Number of Visible People in a Queue",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b93490b3-8f19-40ae-83a9-51701ea00e45",
      "code": "class Solution:\n  def getLucky(self, s: str, k: int) -> int:\n    ans = self._convert(s)\n    for _ in range(k):\n      ans = self._getDigitSum(ans)\n    return ans\n\n  def _convert(self, s: str) -> int:\n    return int(''.join(str(ord(c) - ord('a') + 1) for c in s))\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "1945. Sum of Digits of String After Convert",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "68f114e2-d9c3-41de-b0ce-d54fff9b37eb",
      "code": "class Solution:\n  def maximumNumber(self, num: str, change: list[int]) -> str:\n    numList = list(num)\n    mutated = False\n\n    for i, c in enumerate(numList):\n      d = int(c)\n      numlist[i] = chr(ord('0') + max(d, change[d]))\n      if mutated and d > change[d]:\n        return ''.join(numList)\n      if d < change[d]:\n        mutated = True\n\n    return ''.join(numList)",
      "title": "1946. Largest Number After Mutating Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18fc7288-96a8-45f8-a973-42245323804c",
      "code": "class Solution:\n  def maxCompatibilitySum(\n      self,\n      students: list[list[int]],\n      mentors: list[list[int]],\n  ) -> int:\n    ans = 0\n\n    def dfs(i: int, scoreSum: int, used: list[bool]) -> None:\n      nonlocal ans\n      if i == len(students):\n        ans = max(ans, scoreSum)\n        return\n\n      for j, mentor in enumerate(mentors):\n        if used[j]:\n          continue\n        used[j] = True  # The `mentors[j]` is used.\n        dfs(i + 1, scoreSum + sum(s == m\n                                  for s, m in zip(students[i], mentor)), used)\n        used[j] = False\n\n    dfs(0, 0, [False] * len(students))\n    return ans",
      "title": "1947. Maximum Compatibility Score Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "afe23f58-3747-4eb5-ad23-4eeb964db2bf",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.deleted = False\n\n\nclass Solution:\n  def deleteDuplicateFolder(self, paths: list[list[str]]) -> list[list[str]]:\n    ans = []\n    root = TrieNode()\n    subtreeToNodes: dict[str, list[TrieNode]] = collections.defaultdict(list)\n\n    # Construct the Trie\n    for path in sorted(paths):\n      node = root\n      for s in path:\n        node = node.children.setdefault(s, TrieNode())\n\n    # For each subtree, fill in the {subtree encoding: [root]} hash table\n    def buildSubtreeToRoots(node: TrieNode) -> str:\n      subtree = '(' + ''.join(s + buildSubtreeToRoots(node.children[s])\n                              for s in node.children) + ')'\n      if subtree != '()':\n        subtreeToNodes[subtree].append(node)\n      return subtree\n\n    buildSubtreeToRoots(root)\n\n    # Mark nodes that should be deleted\n    for nodes in subtreeToNodes.values():\n      if len(nodes) > 1:\n        for node in nodes:\n          node.deleted = True\n\n    # Construct the answer array for nodes that haven't been deleted\n    def constructPath(node: TrieNode, path: list[str]) -> None:\n      for s, child in node.children.items():\n        if not child.deleted:\n          constructPath(child, path + [s])\n      if path:\n        ans.append(path)\n\n    constructPath(root, [])\n    return ans",
      "title": "1948. Delete Duplicate Folders in System",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4b598917-595f-4afd-82a9-e1446304ac6e",
      "code": "class Solution:\n  # Similar to 1950. Maximum of Minimum Values in All Subarrays\n  def findMaximums(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    ans = [0] * n\n    # prevMin[i] := the index k s.t.\n    # nums[k] is the previous minimum in nums[0..n)\n    prevMin = [-1] * n\n    # nextMin[i] := the index k s.t.\n    # nums[k] is the next minimum innums[i + 1..n)\n    nextMin = [n] * n\n    stack = []\n\n    for i, num in enumerate(nums):\n      while stack and nums[stack[-1]] > nums[i]:\n        index = stack.pop()\n        nextMin[index] = i\n      if stack:\n        prevMin[i] = stack[-1]\n      stack.append(i)\n\n    # For each nums[i], let l = nextMin[i] + 1 and r = nextMin[i] - 1.\n    # nums[i] is the minimum in nums[l..r].\n    # So, the ans[r - l + 1] will be at least nums[i].\n    for num, l, r in zip(nums, prevMin, nextMin):\n      sz = r - l - 1\n      ans[sz - 1] = max(ans[sz - 1], num)\n\n    # ans[i] should always >= ans[i + 1..n).\n    for i in range(n - 2, -1, -1):\n      ans[i] = max(ans[i], ans[i + 1])\n\n    return ans",
      "title": "1950. Maximum of Minimum Values in All Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1e43d5a-c97c-45d0-ab7a-a63f1ba6112a",
      "code": "class Solution:\n  def isThree(self, n: int) -> bool:\n    if n == 1:\n      return False\n    # The numbers with exactly three divisors are perfect squares of a prime\n    # number.\n    root = math.isqrt(n)\n    return (root**2 == n and\n            all(root % i != 0\n                for i in range(2, math.isqrt(root) + 1)))",
      "title": "1952. Three Divisors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d1825c9f-220f-4a5f-a744-82bd201b4f9e",
      "code": "class Solution:\n  def numberOfWeeks(self, milestones: list[int]) -> int:\n    # The best strategy is to pick 'max, nonMax, max, nonMax, ...'.\n    summ = sum(milestones)\n    nonMax = summ - max(milestones)\n    return min(summ, 2 * nonMax + 1)",
      "title": "1953. Maximum Number of Weeks for Which You Can Work",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b334deb0-adad-4bf8-9f78-b3408ff5d11a",
      "code": "class Solution:\n  def minimumPerimeter(self, neededApples: int) -> int:\n    def numApples(k: int) -> int:\n      \"\"\"Returns the number of apples at the k-th level.\n\n         k := the level making perimeter = 8k\n      p(k) := the number of apples at the k-th level on the perimeter\n      n(k) := the number of apples at the k-th level not no the perimeter\n\n      p(1) =             1 + 2\n      p(2) =         3 + 2 + 3 + 4\n      p(3) =     5 + 4 + 3 + 4 + 5 + 6\n      p(4) = 7 + 6 + 5 + 4 + 5 + 6 + 7 + 8\n      p(k) = k + 2(k+1) + 2(k+2) + ... + 2(k+k-1) + 2k\n          = k + 2k^2 + 2*k(k-1)//2\n          = k + 2k^2 + k^2 - k = 3k^2\n\n      n(k) = p(1) + p(2) + p(3) + ... + p(k)\n          = 3*1  + 3*4  + 3*9  + ... + 3*k^2\n          = 3 * (1 + 4 + 9 + ... + k^2)\n          = 3 * k(k+1)(2k+1)//6 = k(k+1)(2k+1)//2\n      So, the number of apples at the k-th level should be\n        k(k+1)(2k+1)//2 * 4 = 2k(k+1)(2k+1)\n      \"\"\"\n      return 2 * k * (k + 1) * (2 * k + 1)\n\n    return bisect.bisect_left(range(100_000), neededApples,\n                              key=numApples) * 8",
      "title": "1954. Minimum Garden Perimeter to Collect Enough Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2baa5412-62ab-4f4b-95a7-8119a2284a47",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nums)\n    # dp[i][j] := the number of increasing subsequences of the first i numbers\n    # that end in j\n    dp = [[0] * 3 for _ in range(n)]\n\n    if nums[0] == 0:\n      dp[0][0] = 1\n\n    for i in range(1, n):\n      for ending in range(3):\n        dp[i][ending] = dp[i - 1][ending]\n\n      if nums[i] == 0:\n        # 1. The number of the previous subsequences that end in 0.\n        # 2. Append a 0 to the previous subsequences that end in 0.\n        # 3. Start a new subsequence from this 0.\n        dp[i][0] = dp[i - 1][0] * 2 + 1\n      elif nums[i] == 1:\n        # 1. The number of the previous subsequences that end in 1.\n        # 2. Append a 1 to the previous subsequences that end in 1.\n        # 3. Append a 1 to the previous subsequences that end in 0.\n        dp[i][1] = dp[i - 1][1] * 2 + dp[i - 1][0]\n      else:  # nums[i] == 2\n        # 1. The number of the previous subsequences that end in 2.\n        # 2. Append a 2 to the previous subsequences that end in 2.\n        # 3. Append a 2 to the previous subsequences that end in 1.\n        dp[i][2] = dp[i - 1][2] * 2 + dp[i - 1][1]\n\n      for ending in range(3):\n        dp[i][ending] %= MOD\n\n    return dp[-1][2]",
      "title": "1955. Count Number of Special Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe385e82-5f78-4173-a07e-f986ebc4f49c",
      "code": "class Solution:\n  def countSpecialSubsequences(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(i: int, prev: int) -> int:\n      \"\"\"\n      Returns the number of increasing subsequences of the first i numbers,\n      where the the previous number is j - 1.\n      \"\"\"\n      if i == len(nums):\n        return prev == 2\n\n      res = 0\n\n      # Don't include `nums[i]`.\n      res += dp(i + 1, prev)\n\n      # Include `nums[i]`.\n      if nums[i] == prev:\n        res += dp(i + 1, prev)\n      if prev == -1 and nums[i] == 0:\n        res += dp(i + 1, 0)\n      if prev == 0 and nums[i] == 1:\n        res += dp(i + 1, 1)\n      if prev == 1 and nums[i] == 2:\n        res += dp(i + 1, 2)\n\n      res %= MOD\n      return res\n\n    return dp(0, -1)",
      "title": "1955. Count Number of Special Subsequences_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4aae1ae1-ac50-43d0-8288-6d1dd4b7891d",
      "code": "class Solution:\n  def minDayskVariants(self, points: list[list[int]], k: int) -> int:\n    MAX = 100\n    ans = math.inf\n\n    for a in range(1, MAX + 1):\n      for b in range(1, MAX + 1):\n        # Stores the k minimum distances of points that can reach (a, b).\n        maxHeap = []\n        for x, y in points:\n          heapq.heappush(maxHeap, -abs(x - a) + -abs(y - b))\n          if len(maxHeap) > k:\n            heapq.heappop(maxHeap)\n        ans = min(ans, -maxHeap[0])\n\n    return ans",
      "title": "1956. Minimum Time For K Virus Variants to Spread",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "39e76960-df24-4bc3-b1c8-71f53a08c1d7",
      "code": "class Solution:\n  def makeFancyString(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if len(ans) < 2 or ans[-1] != c or ans[-2] != c:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "1957. Delete Characters to Make Fancy String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7106f81d-913b-4cd7-891a-a251c498173b",
      "code": "class Solution:\n  def checkMove(\n      self,\n      board: list[list[str]],\n      rMove: int,\n      cMove: int,\n      color: str,\n  ) -> bool:\n    DIRS = ((-1, -1), (-1, 0), (-1, 1), (0, -1),\n            (0, 1), (1, -1), (1, 0), (1, 1))\n\n    for dx, dy in DIRS:\n      cellsCount = 2\n      i = rMove + dx\n      j = cMove + dy\n      while 0 <= i < 8 and 0 <= j < 8:\n        # There are no free cells in between.\n        if board[i][j] == '.':\n          break\n        # Need >= 3 cells.\n        if cellsCount == 2 and board[i][j] == color:\n          break\n        # >= 3 cells.\n        if board[i][j] == color:\n          return True\n        i += dx\n        j += dy\n        cellsCount += 1\n\n    return False",
      "title": "1958. Check if Move is Legal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b66b9ebf-636a-4f8a-9a4d-7fa688d81534",
      "code": "class Solution:\n  def minSpaceWastedKResizing(self, nums: list[int], k: int) -> int:\n    MAX = 200_000_000\n\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum space wasted for nums[i..n) if you can resize k times.\n      \"\"\"\n      if i == len(nums):\n        return 0\n      if k == -1:\n        return MAX\n\n      res = MAX\n      summ = 0\n      maxNum = nums[i]\n\n      for j in range(i, len(nums)):\n        summ += nums[j]\n        maxNum = max(maxNum, nums[j])\n        wasted = maxNum * (j - i + 1) - summ\n        res = min(res, dp(j + 1, k - 1) + wasted)\n\n      return res\n\n    return dp(0, k)",
      "title": "1959. Minimum Total Space Wasted With K Resizing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "479183a0-b038-4213-b05d-cebba79f8a09",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    BASE = 26\n    HASH = 1_000_000_007\n    n = len(s)\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hashL[i] = the hash of the first i letters of s, where hashL[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hashL = [0]\n    # hashR[i] = the hash of the last i letters of s, where hashR[i] =\n    # (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % HASH\n    hashR = [0]\n    # maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n    maxLeft = [0] * n\n    # maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n    maxRight = [0] * n\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a')\n\n    for _ in range(n):\n      pows.append(pows[-1] * BASE % HASH)\n\n    for c in s:\n      hashL.append((hashL[-1] * BASE + val(c)) % HASH)\n\n    for c in reversed(s):\n      hashR.append((hashR[-1] * BASE + val(c)) % HASH)\n\n    hashR.reverse()\n\n    def getLeftRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the left rolling hash of s[l..r).\"\"\"\n      h = (hashL[r] - hashL[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def getRightRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the right rolling hash of s[l..r).\"\"\"\n      h = (hashR[l] - hashR[r] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True if s[l..r) is a palindrome.\"\"\"\n      return getLeftRollingHash(l, r) == getRightRollingHash(l, r)\n\n    maxLength = 1\n    for r in range(n):\n      l = (r - maxLength - 2) + 1\n      if l >= 0 and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxLeft[r] = maxLength\n\n    maxLength = 1\n    for l in reversed(range(n)):\n      r = (l + maxLength + 2) - 1\n      if r < n and isPalindrome(l, r + 1):\n        maxLength += 2\n      maxRight[l] = maxLength\n\n    return max(maxLeft[i - 1] * maxRight[i] for i in range(1, n))",
      "title": "1960. Maximum Product of the Length of Two Palindromic Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe27344c-d192-412d-b16c-72753d831660",
      "code": "class Solution:\n  def isPrefixString(self, s: str, words: list[str]) -> bool:\n    prefix = []\n    for word in words:\n      prefix.append(word)\n      if ''.join(prefix) == s:\n        return True\n    return False",
      "title": "1961. Check If String Is a Prefix of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bdf1e89-49dc-4a96-b9fc-9adb1c3b7144",
      "code": "class Solution:\n  def minStoneSum(self, piles: list[int], k: int) -> int:\n    maxHeap = [-pile for pile in piles]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      heapq.heapreplace(maxHeap, maxHeap[0] // 2)\n\n    return -sum(maxHeap)",
      "title": "1962. Remove Stones to Minimize the Total",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "671c1b1b-7ddd-49e5-901c-37da78be92a3",
      "code": "class Solution:\n  def minSwaps(self, s: str) -> int:\n    # Cancel out all the matched pairs, then we'll be left with ']]]..[[['.\n    # The answer is ceil(# of unmatched pairs // 2).\n    unmatched = 0\n\n    for c in s:\n      if c == '[':\n        unmatched += 1\n      elif unmatched > 0:  # c == ']' and there's a match.\n        unmatched -= 1\n\n    return (unmatched + 1) // 2",
      "title": "1963. Minimum Number of Swaps to Make the String Balanced",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2572a857-b05a-463e-81a3-c66ea98fa213",
      "code": "class Solution:\n  # Similar to 300. Longest Increasing Subsequence\n  def longestObstacleCourseAtEachPosition(\n      self, obstacles: list[int],\n  ) -> list[int]:\n    ans = []\n    # tails[i] := the minimum tail of all the increasing subsequences having\n    # length i + 1\n    tails = []\n\n    for obstacle in obstacles:\n      if not tails or obstacle >= tails[-1]:\n        tails.append(obstacle)\n        ans.append(len(tails))\n      else:\n        index = bisect.bisect_right(tails, obstacle)\n        tails[index] = obstacle\n        ans.append(index + 1)\n\n    return ans",
      "title": "1964. Find the Longest Valid Obstacle Course at Each Position",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ffd638cb-877c-4b0c-84d2-85074a99c456",
      "code": "class Solution:\n  def binarySearchableNumbers(self, nums: list[int]) -> int:\n    n = len(nums)\n    # prefixMaxs[i] := max(nums[0..i))\n    prefixMaxs = [0] * n\n    # suffixMins[i] := min(nums[i + 1..n))\n    suffixMins = [0] * n\n\n    # Fill in `prefixMaxs`.\n    prefixMaxs[0] = -math.inf\n    for i in range(1, n):\n      prefixMaxs[i] = max(prefixMaxs[i - 1], nums[i - 1])\n\n    # Fill in `suffixMins`.\n    suffixMins[n - 1] = math.inf\n    for i in range(n - 2, -1, -1):\n      suffixMins[i] = min(suffixMins[i + 1], nums[i + 1])\n\n    return sum(prefixMaxs[i] < nums[i] < suffixMins[i] for i in range(n))",
      "title": "1966. Binary Searchable Numbers in an Unsorted Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c196be8-d3d9-46ce-b862-9b51e21887ca",
      "code": "class Solution:\n  def numOfStrings(self, patterns: list[str], word: str) -> int:\n    return sum(pattern in word for pattern in patterns)",
      "title": "1967. Number of Strings That Appear as Substrings in Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ad133da-db59-4c4d-91e0-78f57eca5e5a",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    nums.sort()\n    for i in range(1, len(nums), 2):\n      nums[i], nums[i - 1] = nums[i - 1], nums[i]\n    return nums",
      "title": "1968. Array With Elements Not Equal to Average of Neighbors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1856ae25-9770-43ca-8295-bc134c6925cc",
      "code": "class Solution:\n  def minNonZeroProduct(self, p: int) -> int:\n    MOD = 1_000_000_007\n    # Can always turn [1..2^p - 1] to [1, 1, ..., 2^p - 2, 2^p - 2, 2^p - 1].\n    n = 1 << p\n    halfCount = n // 2 - 1\n    return pow(n - 2, halfCount, MOD) * ((n - 1) % MOD) % MOD",
      "title": "1969. Minimum Non-Zero Product of the Array Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e2a04fe6-06ee-4db0-a8a4-18d005e079f9",
      "code": "class Solution:\n  def latestDayToCross(self, row: int, col: int, cells: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n\n    def canWalk(day: int) -> bool:\n      matrix = [[0] * col for _ in range(row)]\n      for i in range(day):\n        x, y = cells[i]\n        matrix[x - 1][y - 1] = 1\n\n      q = collections.deque()\n\n      for j in range(col):\n        if matrix[0][j] == 0:\n          q.append((0, j))\n          matrix[0][j] = 1\n\n      while q:\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == row or y < 0 or y == col:\n            continue\n          if matrix[x][y] == 1:\n            continue\n          if x == row - 1:\n            return True\n          q.append((x, y))\n          matrix[x][y] = 1\n\n      return False\n\n    ans = 0\n    l = 1\n    r = len(cells) - 1\n\n    while l <= r:\n      m = (l + r) // 2\n      if canWalk(m):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "1970. Last Day Where You Can Still Cross",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b4778d4-eb91-472b-a2b8-949dcf0344e8",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def validPath(\n      self,\n      n: int,\n      edges: list[list[int]],\n      source: int,\n      destination: int,\n  ) -> bool:\n    uf = UnionFind(n)\n\n    for u, v in edges:\n      uf.unionByRank(u, v)\n\n    return uf.find(source) == uf.find(destination)",
      "title": "1971. Find if Path Exists in Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e159e9b8-0290-4773-8970-c4164a18e588",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass T:\n  summ: int\n  count: int\n\n\nclass Solution:\n  def equalToDescendants(self, root: TreeNode | None) -> int:\n    def dfs(root: TreeNode | None) -> T:\n      if not root:\n        return T(0, 0)\n      left = dfs(root.left)\n      right = dfs(root.right)\n      return T(root.val + left.summ + right.summ,\n               left.count + right.count +\n               (1 if root.val == left.summ + right.summ else 0))\n\n    return dfs(root).count",
      "title": "1973. Count Nodes Equal to Sum of Descendants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ad3ae4a-82e4-4c45-b27e-22e7470f8e6d",
      "code": "class Solution:\n  def minTimeToType(self, word: str) -> int:\n    moves = 0\n    letter = 'a'\n\n    for c in word:\n      diff = abs(ord(c) - ord(letter))\n      moves += min(diff, 26 - diff)\n      letter = c\n\n    return moves + len(word)",
      "title": "1974. Minimum Time to Type Word Using Special Typewriter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eac388c6-da78-4b16-bbb0-a4b181885ebd",
      "code": "class Solution:\n  def maxMatrixSum(self, matrix: list[list[int]]) -> int:\n    absSum = 0\n    minAbs = math.inf\n    # 0 := even number of negatives\n    # 1 := odd number of negatives\n    oddNeg = 0\n\n    for row in matrix:\n      for num in row:\n        absSum += abs(num)\n        minAbs = min(minAbs, abs(num))\n        if num < 0:\n          oddNeg ^= 1\n\n    return absSum - oddNeg * minAbs * 2",
      "title": "1975. Maximum Matrix Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "885ed0d3-4b63-4271-a2a7-9521c4901d83",
      "code": "class Solution:\n  def countPaths(self, n: int, roads: list[list[int]]) -> int:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    return self._dijkstra(graph, 0, n - 1)\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      dst: int,\n  ) -> int:\n    MOD = 10**9 + 7\n    ways = [0] * len(graph)\n    dist = [math.inf] * len(graph)\n\n    ways[src] = 1\n    dist[src] = 0\n    minHeap = [(dist[src], src)]\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          ways[v] = ways[u]\n          heapq.heappush(minHeap, (dist[v], v))\n        elif d + w == dist[v]:\n          ways[v] += ways[u]\n          ways[v] %= MOD\n\n    return ways[dst]",
      "title": "1976. Number of Ways to Arrive at Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ce01759-962c-4a1a-8bc5-ba97ab05c712",
      "code": "class Solution:\n  def numberOfCombinations(self, num: str) -> int:\n    if num[0] == '0':\n      return 0\n\n    MOD = 1_000_000_007\n    n = len(num)\n    # dp[i][k] := the number of possible lists of integers ending in num[i]\n    # with the length of the last number being 1..k\n    dp = [[0] * (n + 1) for _ in range(n)]\n    # lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if num[i] == num[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n\n    for i in range(n):\n      for k in range(1, i + 2):\n        dp[i][k] += dp[i][k - 1]\n        dp[i][k] %= MOD\n        # The last number is num[s..i].\n        s = i - k + 1\n        if num[s] == '0':\n          # the number of possible lists of integers ending in num[i] with the\n          # length of the last number being k\n          continue\n        if s == 0:  # the whole string\n          dp[i][k] += 1\n          continue\n        if s < k:\n          # The length k is not enough, so add the number of possible lists of\n          # integers in num[0..s - 1].\n          dp[i][k] += dp[s - 1][s]\n          continue\n        l = lcs[s - k][s]\n        if l >= k or num[s - k + l] <= num[s + l]:\n          # Have enough length k and num[s - k..s - 1] <= num[j..i].\n          dp[i][k] += dp[s - 1][k]\n        else:\n          # Have enough length k but num[s - k..s - 1] > num[j..i].\n          dp[i][k] += dp[s - 1][k - 1]\n\n    return dp[n - 1][n] % MOD",
      "title": "1977. Number of Ways to Separate Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "efa51474-a41b-40be-8f7c-89ecd57ae83d",
      "code": "class Solution:\n  def findGCD(self, nums: list[int]) -> int:\n    return math.gcd(min(nums), max(nums))",
      "title": "1979. Find Greatest Common Divisor of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b3eda9f8-423a-4cde-983a-79885477c6ed",
      "code": "class Solution:\n  def findDifferentBinaryString(self, nums: list[str]) -> str:\n    bitSize = len(nums[0])\n    maxNum = 1 << bitSize\n    numsSet = {int(num, 2) for num in nums}\n\n    for num in range(maxNum):\n      if num not in numsSet:\n        return f'{num:0>{bitSize}b}'",
      "title": "1980. Find Unique Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37dd9a96-00ad-41af-a139-a6445dd4fe50",
      "code": "class Solution:\n  def minimizeTheDifference(self, mat: list[list[int]], target: int) -> int:\n    minSum = sum(min(row) for row in mat)\n    if minSum >= target:  # No need to consider any larger combination.\n      return minSum - target\n\n    @functools.lru_cache(None)\n    def dp(i: int, summ: int) -> int:\n      if i == len(mat):\n        return abs(summ - target)\n      return min(dp(i + 1, summ + num) for num in mat[i])\n\n    return dp(0, 0)",
      "title": "1981. Minimize the Difference Between Target and Chosen Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb5fc914-edc2-451e-8d0a-9d95ce37aa01",
      "code": "class Solution:\n  def recoverArray(self, n: int, sums: list[int]) -> list[int]:\n    def recover(sums: list[int]) -> list[int]:\n      if len(sums) == 1:\n        return []\n\n      count = collections.Counter(sums)\n      # Either num or -num must be in the final array.\n      #  num + sumsExcludingNum = sumsIncludingNum\n      # -num + sumsIncludingNum = sumsExcludingNum\n      num = sums[1] - sums[0]\n      sumsExcludingNum = []\n      sumsIncludingNum = []\n      chooseSumsExcludingNum = True\n\n      for summ in sums:\n        if count[summ] == 0:\n          continue\n        count[summ] -= 1\n        count[summ + num] -= 1\n        sumsExcludingNum.append(summ)\n        sumsIncludingNum.append(summ + num)\n        if summ + num == 0:\n          chooseSumsExcludingNum = False\n\n      # Choose `sumsExludingNum` by default since we want to gradually strip\n      # `num` from each sum in `sums` to have the final array. However, we should\n      # always choose the group of sums with 0 since it's a must-have.\n      return ([num] + recover(sumsExcludingNum) if chooseSumsExcludingNum else\n              [-num] + recover(sumsIncludingNum))\n\n    return recover(sorted(sums))",
      "title": "1982. Find Array Given Subset Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "320722af-6771-4eca-adad-85a078f39113",
      "code": "class Solution:\n  def widestPairOfIndices(self, nums1: list[int], nums2: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    prefixToIndex = {0: -1}\n\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      prefix += num1 - num2\n      ans = max(ans, i - prefixToIndex.setdefault(prefix, i))\n\n    return ans",
      "title": "1983. Widest Pair of Indices With Equal Range Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3192a4c-87eb-47d4-a628-b57e3257e8de",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    ans = nums[k - 1] - nums[0]\n\n    for i in range(k, len(nums)):\n      ans = min(ans, nums[i] - nums[i - k + 1])\n\n    return ans",
      "title": "1984. Minimum Difference Between Highest and Lowest of K Scores",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e34aa71-79f9-421a-9df0-8c0e4167ad79",
      "code": "class Solution:\n  # Similar to 215. Kth Largest Element in an Array\n  def kthLargestNumber(self, nums: list[str], k: int) -> str:\n    minHeap = []\n\n    for num in nums:\n      heapq.heappush(minHeap, int(num))\n      if len(minHeap) > k:\n        heapq.heappop(minHeap)\n\n    return str(minHeap[0])",
      "title": "1985. Find the Kth Largest Integer in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4613153c-07d4-4ba8-b857-5c480fc353a2",
      "code": "class Solution:\n  def minSessions(self, tasks: list[int], sessionTime: int) -> int:\n    # Returns True if we can assign tasks[s..n) to `sessions`. Note that `sessions`\n    # may be occupied by some tasks.\n    def dfs(s: int, sessions: list[int]) -> bool:\n      if s == len(tasks):\n        return True\n\n      for i, session in enumerate(sessions):\n        # Can't assign the tasks[s] to this session.\n        if session + tasks[s] > sessionTime:\n          continue\n        # Assign the tasks[s] to this session.\n        sessions[i] += tasks[s]\n        if dfs(s + 1, sessions):\n          return True\n        # Backtracking.\n        sessions[i] -= tasks[s]\n        # If it's the first time we assign the tasks[s] to this session, then future\n        # `session`s can't satisfy either.\n        if sessions[i] == 0:\n          return False\n\n      return False\n\n    for numSessions in range(1, len(tasks) + 1):\n      if dfs(0, [0] * numSessions):\n        return numSessions",
      "title": "1986. Minimum Number of Work Sessions to Finish the Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7ff2b2f-ed42-4d38-bbe7-51aab9b7d7fe",
      "code": "class Solution:\n  # Similar to 940. Distinct Subsequences II\n  def numberOfUniqueGoodSubsequences(self, binary: str) -> int:\n    MOD = 1_000_000_007\n    # endsIn[i] := the number of subsequence that end in ('0' + i)\n    endsIn = {'0': 0, '1': 0}\n\n    for c in binary:\n      endsIn[c] = sum(endsIn.values()) % MOD\n      # Don't count '0' since we want to avoid the leading zeros case.\n      # However, we can always count '1'.\n      if c == '1':\n        endsIn['1'] += 1\n\n    # Count '0' in the end.\n    return (sum(endsIn.values()) + ('0' in binary)) % MOD",
      "title": "1987. Number of Unique Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ae787f4-8e0a-48e4-8c7c-d70c3cdad57f",
      "code": "class Solution:\n  def catchMaximumAmountofPeople(self, team: list[int], dist: int) -> int:\n    ans = 0\n    i = 0  # 0s index\n    j = 0  # 1s index\n\n    while i < len(team) and j < len(team):\n      if i + dist < j or team[i] != 0:\n        # Find the next 0 that can be caught by 1.\n        i += 1\n      elif j + dist < i or team[j] != 1:\n        # Find the next 1 that can catch 0.\n        j += 1\n      else:\n        # team[j] catches team[i], so move both.\n        ans += 1\n        i += 1\n        j += 1\n\n    return ans",
      "title": "1989. Maximum Number of People That Can Be Caught in Tag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9b884f9d-9555-4b7e-8ffc-826063c4fd3d",
      "code": "class Solution:\n  def findMiddleIndex(self, nums: list[int]) -> int:\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      suffix -= num\n      if prefix == suffix:\n        return i\n      prefix += num\n\n    return -1",
      "title": "1991. Find the Middle Index in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae35aac8-2713-4a23-ae04-09e9dbb0cce1",
      "code": "class Solution:\n  def findFarmland(self, land: list[list[int]]) -> list[list[int]]:\n    ans = []\n\n    def dfs(i: int, j: int, cell: list[int]) -> None:\n      if i < 0 or i == len(land) or j < 0 or j == len(land[0]):\n        return\n      if land[i][j] != 1:\n        return\n      land[i][j] = 2  # Mark as visited.\n      cell[0] = max(cell[0], i)\n      cell[1] = max(cell[1], j)\n      dfs(i + 1, j, cell)\n      dfs(i, j + 1, cell)\n\n    for i in range(len(land)):\n      for j in range(len(land[0])):\n        if land[i][j] == 1:\n          cell = [i, j]\n          dfs(i, j, cell)\n          ans.append([i, j, *cell])\n\n    return ans",
      "title": "1992. Find All Groups of Farmland",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "232b4e3c-3e9e-4d16-bc21-8b9bf74c50e9",
      "code": "class Solution:\n  def numberOfGoodSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    n = 1 << len(primes)\n    # dp[i] := the number of good subsets with set of primes = i bit mask\n    dp = [1] + [0] * (n - 1)\n    count = collections.Counter(nums)\n\n    for num, freq in count.items():\n      if num == 1:\n        continue\n      if any(num % squared == 0 for squared in [4, 9, 25]):\n        continue\n      numPrimesMask = sum(1 << i\n                          for i, prime in enumerate(primes)\n                          if num % prime == 0)\n      for primesMask in range(n):\n        # Skip since there're commen set of primes (becomes invalid subset)\n        if primesMask & numPrimesMask > 0:\n          continue\n        nextPrimesMask = numPrimesMask | primesMask\n        dp[nextPrimesMask] += dp[primesMask] * freq\n        dp[nextPrimesMask] %= MOD\n\n    return (1 << count[1]) * sum(dp[1:]) % MOD",
      "title": "1994. The Number of Good Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a27a29bc-a8f8-40ea-a0eb-686cad0c12f5",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    count = collections.Counter()\n\n    #    nums[a] + nums[b] + nums[c] == nums[d]\n    # => nums[a] + nums[b] == nums[d] - nums[c]\n    for b in range(n - 1, 0, -1):  # `b` also represents `c`.\n      for a in range(b - 1, -1, -1):\n        ans += count[nums[a] + nums[b]]\n      for d in range(n - 1, b, -1):\n        count[nums[d] - nums[b]] += 1  # b := c\n\n    return ans",
      "title": "1995. Count Special Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8c03658b-4388-46a3-8775-4267ec27332b",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    n = len(nums)\n    return sum(nums[a] + nums[b] + nums[c] == nums[d]\n               for a in range(n)\n               for b in range(a + 1, n)\n               for c in range(b + 1, n)\n               for d in range(c + 1, n))",
      "title": "1995. Count Special Quadruplets_2",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d0300c0-427e-44be-b52d-a3dd1e7decc6",
      "code": "class Solution:\n  def numberOfWeakCharacters(self, properties: list[list[int]]) -> int:\n    ans = 0\n    maxAttack = max(attack for attack, _ in properties)\n    # maxDefenses[i] := the maximum defense for the i-th attack\n    maxDefenses = [0] * (maxAttack + 2)\n\n    for attack, defense in properties:\n      maxDefenses[attack] = max(maxDefenses[attack], defense)\n\n    for i in range(maxAttack, 0, -1):\n      maxDefenses[i] = max(maxDefenses[i], maxDefenses[i + 1])\n\n    for attack, defense in properties:\n      if maxDefenses[attack + 1] > defense:\n        ans += 1\n\n    return ans",
      "title": "1996. The Number of Weak Characters in the Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a427045d-9ad7-42d6-bf85-a71a21b3cec6",
      "code": "class Solution:\n  def firstDayBeenInAllRooms(self, nextVisit: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(nextVisit)\n    # dp[i] := the number of days to visit room i for the first time\n    dp = [0] * n\n\n    # Whenever we visit i, visit times of room[0..i - 1] are all even.\n    # Therefore, the rooms before i can be seen as reset and we can safely\n    # reuse dp[0..i - 1] as first-time visit to get second-time visit.\n    for i in range(1, n):\n      # The total days to visit room[i] is the sum of\n      #   * dp[i - 1]: 1st-time visit room[i - 1]\n      #   * 1: visit room[nextVisit[i - 1]]\n      #   * dp[i - 1] - dp[nextVisit[i - 1]]: 2-time visit room[i - 1]\n      #   * 1: visit room[i]\n      dp[i] = (2 * dp[i - 1] - dp[nextVisit[i - 1]] + 2) % MOD\n\n    return dp[-1]",
      "title": "1997. First Day Where You Have Been in All the Rooms",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1e4b685d-b760-4e83-9c4d-92b7445e172e",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return False\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n    return True\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def gcdSort(self, nums: list[int]) -> bool:\n    mx = max(nums)\n    minPrimeFactors = self._sieveEratosthenes(mx + 1)\n    uf = UnionFind(mx + 1)\n\n    for num in nums:\n      for primeFactor in self._getPrimeFactors(num, minPrimeFactors):\n        uf.unionByRank(num, primeFactor)\n\n    for a, b in zip(nums, sorted(nums)):\n      # Can't swap nums[i] with sortedNums[i].\n      if uf.find(a) != uf.find(b):\n        return False\n\n    return True\n\n  def _sieveEratosthenes(self, n: int) -> list[int]:\n    \"\"\"Gets the minimum prime factor of i, where 1 < i <= n.\"\"\"\n    minPrimeFactors = [i for i in range(n + 1)]\n    for i in range(2, int(n**0.5) + 1):\n      if minPrimeFactors[i] == i:  # `i` is prime.\n        for j in range(i * i, n, i):\n          minPrimeFactors[j] = min(minPrimeFactors[j], i)\n    return minPrimeFactors\n\n  def _getPrimeFactors(self, num: int, minPrimeFactors: list[int]) -> list[int]:\n    primeFactors = []\n    while num > 1:\n      divisor = minPrimeFactors[num]\n      primeFactors.append(divisor)\n      while num % divisor == 0:\n        num //= divisor\n    return primeFactors",
      "title": "1998. GCD Sort of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d72cec90-a230-4320-9c0c-1ecf35edd5fb",
      "code": "class Solution:\n  def findInteger(self, k: int, digit1: int, digit2: int) -> int:\n    minDigit = min(digit1, digit2)\n    maxDigit = max(digit1, digit2)\n    digits = [minDigit] if minDigit == maxDigit else [minDigit, maxDigit]\n    q = collections.deque()\n\n    for digit in digits:\n      q.append(digit)\n\n    while q:\n      u = q.popleft()\n      if u > k and u % k == 0:\n        return u\n      if u == 0:\n        continue\n      for digit in digits:\n        nextNum = u * 10 + digit\n        if nextNum > 2**31 - 1:\n          continue\n        q.append(nextNum)\n\n    return -1",
      "title": "1999. Smallest Greater Multiple Made of Two Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "63e80837-a667-49e6-8be9-0a6a9e7214af",
      "code": "class Solution:\n  def reversePrefix(self, word: str, ch: str) -> str:\n    i = word.find(ch) + 1\n    return word[:i][::-1] + word[i:]",
      "title": "2000. Reverse Prefix of Word",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66465aaa-8a15-48d4-ad51-288aedf5d2c2",
      "code": "class Solution:\n  def interchangeableRectangles(self, rectangles: list[list[int]]) -> int:\n    ratioCount = collections.Counter()\n\n    def gcd(a: int, b: int) -> int:\n      return a if b == 0 else gcd(b, a % b)\n\n    for width, height in rectangles:\n      d = gcd(width, height)\n      ratioCount[(width // d, height // d)] += 1\n\n    return sum(c * (c - 1) // 2 for c in ratioCount.values())",
      "title": "2001. Number of Pairs of Interchangeable Rectangles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d7b7be28-730a-46b9-9677-d1677360e4ff",
      "code": "class Solution:\n  def maxProduct(self, s: str) -> int:\n    ans = 0\n\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n\n    @functools.lru_cache(None)\n    def dfs(i: int, s1: str, s2: str) -> None:\n      nonlocal ans\n      if i == len(s):\n        if isPalindrome(s1) and isPalindrome(s2):\n          ans = max(ans, len(s1) * len(s2))\n        return\n\n      dfs(i + 1, s1 + s[i], s2)\n      dfs(i + 1, s1, s2 + s[i])\n      dfs(i + 1, s1, s2)\n\n    dfs(0, '', '')\n    return ans",
      "title": "2002. Maximum Product of the Length of Two Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e777c17-5dd1-45e4-b722-2d848373c4bb",
      "code": "class Solution:\n  def smallestMissingValueSubtree(\n      self,\n      parents: list[int],\n      nums: list[int],\n  ) -> list[int]:\n    n = len(parents)\n    ans = [1] * n\n    tree = [[] for _ in range(n)]\n    seen = set()\n    minMiss = 1\n\n    for i in range(1, n):\n      tree[parents[i]].append(i)\n\n    def getNode(nums: list[int]) -> int:\n      for i, num in enumerate(nums):\n        if num == 1:\n          return i\n      return -1\n\n    nodeThatsOne = getNode(nums)\n    if nodeThatsOne == -1:\n      return ans\n\n    u = nodeThatsOne\n    prev = -1  # the u that just handled\n\n    def dfs(u: int) -> None:\n      seen.add(nums[u])\n      for v in tree[u]:\n        dfs(v)\n\n    # Upward from `nodeThatsOne` to the root `u`.\n    while u != -1:\n      for v in tree[u]:\n        if v != prev:\n          dfs(v)\n      seen.add(nums[u])\n      while minMiss in seen:\n        minMiss += 1\n      ans[u] = minMiss\n      prev = u\n      u = parents[u]\n\n    return ans",
      "title": "2003. Smallest Missing Genetic Value in Each Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "545a6e0f-4b65-44d9-ba87-06dcb90fbab8",
      "code": "class Solution:\n  def findGameWinner(self, n: int) -> bool:\n    return n % 6 != 1",
      "title": "2005. Subtree Removal Game with Fibonacci Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aa224a2-21de-4fc5-b775-9084e8bacda3",
      "code": "class Solution:\n  def countKDifference(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(nums)\n    return sum(count[i] * count[i - k] for i in range(k + 1, 101))",
      "title": "2006. Count Number of Pairs With Absolute Difference K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69192e60-03de-471e-a0c3-74acd74de1f2",
      "code": "class Solution:\n  def findOriginalArray(self, changed: list[int]) -> list[int]:\n    ans = []\n    q = collections.deque()\n\n    for num in sorted(changed):\n      if q and num == q[0]:\n        q.popleft()\n      else:\n        q.append(num * 2)\n        ans.append(num)\n\n    return [] if q else ans",
      "title": "2007. Find Original Array From Doubled Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "768ee52a-82c5-4bfd-abc5-f8179f30e80f",
      "code": "class Solution:\n  def maxTaxiEarnings(self, n: int, rides: list[list[int]]) -> int:\n    endToStartAndEarns = [[] for _ in range(n + 1)]\n    # dp[i] := the maximum dollars you can earn starting at i\n    dp = [0] * (n + 1)\n\n    for start, end, tip in rides:\n      earn = end - start + tip\n      endToStartAndEarns[end].append((start, earn))\n\n    for i in range(1, n + 1):\n      dp[i] = dp[i - 1]\n      for start, earn in endToStartAndEarns[i]:\n        dp[i] = max(dp[i], dp[start] + earn)\n\n    return dp[n]",
      "title": "2008. Maximum Earnings From Taxi",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0fdad82b-c3a0-4a10-8b8e-d5f24e89a2da",
      "code": "class Solution:\n  def minOperations(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = n\n    nums = sorted(set(nums))\n\n    for i, start in enumerate(nums):\n      end = start + n - 1\n      index = bisect_right(nums, end)\n      uniqueLength = index - i\n      ans = min(ans, n - uniqueLength)\n\n    return ans",
      "title": "2009. Minimum Number of Operations to Make Array Continuous",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f57d4dc-71fe-48a7-8d8c-5bee573dd2e0",
      "code": "class Solution:\n  def finalValueAfterOperations(self, operations: list[str]) -> int:\n    return sum(op[1] == '+' or -1 for op in operations)",
      "title": "2011. Final Value of Variable After Performing Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3fbfe13-05f2-41a1-8019-a39893880887",
      "code": "class Solution:\n  def sumOfBeauties(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minOfRight = [0] * (n - 1) + [nums[-1]]\n\n    for i in range(n - 2, 1, -1):\n      minOfRight[i] = min(nums[i], minOfRight[i + 1])\n\n    maxOfLeft = nums[0]\n\n    for i in range(1, n - 1):\n      if maxOfLeft < nums[i] < minOfRight[i + 1]:\n        ans += 2\n      elif nums[i - 1] < nums[i] < nums[i + 1]:\n        ans += 1\n      maxOfLeft = max(maxOfLeft, nums[i])\n\n    return ans",
      "title": "2012. Sum of Beauty in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c6791ccb-93a0-4dec-bc36-3c81e35f555d",
      "code": "class Solution:\n  def longestSubsequenceRepeatedK(self, s: str, k: int) -> str:\n    ans = ''\n    count = [0] * 26\n    possibleChars = []\n    # Stores subsequences, where the length grows by 1 each time.\n    q = collections.deque([''])\n\n    for c in s:\n      count[ord(c) - ord('a')] += 1\n\n    for c in string.ascii_lowercase:\n      if count[ord(c) - ord('a')] >= k:\n        possibleChars.append(c)\n\n    def isSubsequence(subseq: str, s: str, k: int) -> bool:\n      i = 0  # subseq's index\n      for c in s:\n        if c == subseq[i]:\n          i += 1\n          if i == len(subseq):\n            k -= 1\n            if k == 0:\n              return True\n            i = 0\n      return False\n\n    while q:\n      currSubseq = q.popleft()\n      if len(currSubseq) * k > len(s):\n        return ans\n      for c in possibleChars:\n        newSubseq = currSubseq + c\n        if isSubsequence(newSubseq, s, k):\n          q.append(newSubseq)\n          ans = newSubseq\n\n    return ans",
      "title": "2014. Longest Subsequence Repeated k Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52f7beb1-2459-4038-a3c6-1585d19c5017",
      "code": "class Solution:\n  def averageHeightOfBuildings(self, buildings: list[list[int]]) -> list[list[int]]:\n    ans = []\n    events = []\n\n    for start, end, height in buildings:\n      events.append((start, height))\n      events.append((end, -height))\n\n    prev = 0\n    count = 0\n    sumHeight = 0\n\n    for curr, height in sorted(events):\n      if sumHeight > 0 and curr > prev:\n        avgHeight = sumHeight // count\n        if ans and ans[-1][1] == prev and avgHeight == ans[-1][2]:\n          ans[-1][1] = curr\n        else:\n          ans.append([prev, curr, avgHeight])\n      sumHeight += height\n      count += 1 if height > 0 else -1\n      prev = curr\n\n    return ans",
      "title": "2015. Average Height of Buildings in Each Segment",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7509bd9e-5b05-45f4-8849-90a43f14a323",
      "code": "class Solution:\n  def maximumDifference(self, nums: list[int]) -> int:\n    ans = -1\n    mn = nums[0]\n\n    for i in range(len(nums)):\n      if nums[i] > mn:\n        ans = max(ans, nums[i] - mn)\n      mn = min(mn, nums[i])\n\n    return ans",
      "title": "2016. Maximum Difference Between Increasing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcb4012d-a587-4a4a-8823-03ef16e33ed7",
      "code": "class Solution:\n  def gridGame(self, grid: list[list[int]]) -> int:\n    n = len(grid[0])\n    ans = math.inf\n    sumRow0 = sum(grid[0])\n    sumRow1 = 0\n\n    for i in range(n):\n      sumRow0 -= grid[0][i]\n      ans = min(ans, max(sumRow0, sumRow1))\n      sumRow1 += grid[1][i]\n\n    return ans",
      "title": "2017. Grid Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9fe658f9-7856-4093-be66-4e3a1763e19f",
      "code": "class Solution:\n  def placeWordInCrossword(self, board: list[list[str]], word: str) -> bool:\n    for x in board, zip(*board):\n      for row in x:\n        for token in ''.join(row).split('#'):\n          for letters in word, word[::-1]:\n            if len(token) == len(letters):\n              if all(c in (' ', letter) for c, letter in zip(token, letters)):\n                return True\n    return False",
      "title": "2018. Check if Word Can Be Placed In Crossword",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31c1fbd0-dcba-4331-919c-34dc419d6a2a",
      "code": "class Solution:\n  def scoreOfStudents(self, s: str, answers: list[int]) -> int:\n    n = len(s) // 2 + 1\n    ans = 0\n    func = {'+': operator.add, '*': operator.mul}\n    dp = [[set() for j in range(n)] for _ in range(n)]\n\n    for i in range(n):\n      dp[i][i].add(int(s[i * 2]))\n\n    for d in range(1, n):\n      for i in range(n - d):\n        j = i + d\n        for k in range(i, j):\n          op = s[k * 2 + 1]\n          for a in dp[i][k]:\n            for b in dp[k + 1][j]:\n              res = func[op](a, b)\n              if res <= 1000:\n                dp[i][j].add(res)\n\n    correctAnswer = eval(s)\n\n    for answer, freq in collections.Counter(answers).items():\n      if answer == correctAnswer:\n        ans += 5 * freq\n      elif answer in dp[0][n - 1]:\n        ans += 2 * freq\n\n    return ans",
      "title": "2019. The Score of Students Solving Math Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "83499642-8f53-4d70-86a3-e58f8bd1b225",
      "code": "from sortedcontainers import SortedDict\n\n\nclass Solution:\n  def brightestPosition(self, lights: list[list[int]]) -> int:\n    ans = math.inf\n    maxBrightness = -1\n    currBrightness = 0\n    line = SortedDict()\n\n    for position, rg in lights:\n      start = position - rg\n      end = position + rg + 1\n      line[start] = line.get(start, 0) + 1\n      line[end] = line.get(end, 0) - 1\n\n    for pos, brightness in line.items():\n      currBrightness += brightness\n      if currBrightness > maxBrightness:\n        maxBrightness = currBrightness\n        ans = pos\n\n    return ans",
      "title": "2021. Brightest Position on Street",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16dae46d-7fcd-4017-b67a-84f88ba91a8c",
      "code": "class Solution:\n  def construct2DArray(self, original: list[int],\n                       m: int, n: int) -> list[list[int]]:\n    if len(original) != m * n:\n      return []\n\n    ans = [[0] * n for _ in range(m)]\n\n    for i, num in enumerate(original):\n      ans[i // n][i % n] = num\n\n    return ans",
      "title": "2022. Convert 1D Array Into 2D Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "028909e3-25a6-4596-a9bc-f9b40da616e0",
      "code": "class Solution:\n  def numOfPairs(self, nums: list[str], target: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for num in nums:\n      k = len(num)\n      if target[:k] == num:\n        ans += count[target[k:]]\n      if target[-k:] == num:\n        ans += count[target[:-k]]\n      count[num] += 1\n\n    return ans",
      "title": "2023. Number of Pairs of Strings With Concatenation Equal to Target",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6e3ccea7-d10d-4b2c-aa72-895e90aa3630",
      "code": "class Solution:\n  def maxConsecutiveAnswers(self, answerKey: str, k: int) -> int:\n    ans = 0\n    maxCount = 0\n    count = collections.Counter()\n\n    l = 0\n    for r, c in enumerate(answerKey):\n      count[c == 'T'] += 1\n      maxCount = max(maxCount, count[c == 'T'])\n      while maxCount + k < r - l + 1:\n        count[answerKey[l] == 'T'] -= 1\n        l += 1\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2024. Maximize the Confusion of an Exam",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d6f3ad9-4cb0-47da-9503-88cda1ad0e27",
      "code": "class Solution:\n  def waysToPartition(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    summ = sum(nums)\n    prefix = 0\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [0..i)\n    l = collections.Counter()\n    # Count of sum(A[0..k)) - sum(A[k..n)) for k in [i..n)\n    r = collections.Counter()\n\n    for pivot in range(1, n):\n      prefix += nums[pivot - 1]\n      suffix = summ - prefix\n      r[prefix - suffix] += 1\n\n    ans = r[0]\n    prefix = 0\n\n    for num in nums:\n      ans = max(ans, l[k - num] + r[num - k])\n      prefix += num\n      suffix = summ - prefix\n      diff = prefix - suffix\n      r[diff] -= 1\n      l[diff] += 1\n\n    return ans",
      "title": "2025. Maximum Number of Ways to Partition an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ce85dda-86ca-4b85-bc26-3af29c360b10",
      "code": "class Solution:\n  def minimumMoves(self, s: str) -> int:\n    ans = 0\n\n    i = 0\n    while i < len(s):\n      if s[i] == 'O':\n        i += 1\n      else:\n        ans += 1\n        i += 3\n\n    return ans",
      "title": "2027. Minimum Moves to Convert String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0fb87cd-12f4-4f31-bea6-441ff6424b3f",
      "code": "class Solution:\n  def missingRolls(self, rolls: list[int], mean: int, n: int) -> list[int]:\n    targetSum = (len(rolls) + n) * mean\n    missingSum = targetSum - sum(rolls)\n    if missingSum > n * 6 or missingSum < n:\n      return []\n\n    ans = [missingSum // n] * n\n    for i in range(missingSum % n):\n      ans[i] += 1\n\n    return ans",
      "title": "2028. Find Missing Observations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d93157dd-f868-4942-87d7-4317d055d626",
      "code": "class Solution:\n  def stoneGameIX(self, stones: list[int]) -> bool:\n    count = collections.Counter(stone % 3 for stone in stones)\n    if count[0] % 2 == 0:\n      return min(count[1], count[2]) > 0\n    return abs(count[1] - count[2]) > 2",
      "title": "2029. Stone Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94f65981-3db2-4bc0-8408-a8c70375053c",
      "code": "class Solution:\n  def smallestSubsequence(\n      self,\n      s: str,\n      k: int,\n      letter: str,\n      repetition: int,\n  ) -> str:\n    stack = []  # running string\n    required = repetition\n    nLetters = s.count(letter)\n\n    for i, c in enumerate(s):\n      # Make sure the length is sufficient:\n      # Len(stack) := the length of running string\n      # Len(s) - i := the length of remain chars\n      # -1 := we're going to pop a char\n      while (stack and stack[-1] > c\n              and len(stack) + len(s) - i - 1 >= k\n              and (stack[-1] != letter or nLetters > required)):\n        if stack.pop() == letter:\n          required += 1\n      if len(stack) < k:\n        if c == letter:\n          stack.append(c)\n          required -= 1\n        elif k - len(stack) > required:\n          stack.append(c)\n      if c == letter:\n        nLetters -= 1\n\n    return ''.join(stack)",
      "title": "2030. Smallest K-Length Subsequence With Occurrences of a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "58510907-be2b-4247-8093-b7a32ad4ec49",
      "code": "class FenwichTree:\n  def __init__(self, n: int):\n    self.n = n\n    self.sums = [0] * (2 * n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    i += self.n + 1  # re-mapping\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += i & -i\n\n  def get(self, i: int) -> int:\n    i += self.n + 1  # re-mapping\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= i & -i\n    return summ\n\n\nclass Solution:\n  def subarraysWithMoreZerosThanOnes(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    prefix = 0\n    tree = FenwichTree(len(nums))\n    tree.add(0, 1)\n\n    for num in nums:\n      prefix += -1 if num == 0 else 1\n      ans += tree.get(prefix - 1)\n      ans %= MOD\n      tree.add(prefix, 1)\n\n    return ans",
      "title": "2031. Count Subarrays With More Ones Than Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "56865ca3-8e32-4b5f-b9ba-f64c13393570",
      "code": "class Solution:\n  def twoOutOfThree(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      nums3: list[int],\n  ) -> list[int]:\n    count = collections.Counter()\n    for nums in nums1, nums2, nums3:\n      count.update(set(nums))\n    return [i for i, c in count.items() if c >= 2]",
      "title": "2032. Two Out of Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8146081e-690c-4fd4-b789-128089817aae",
      "code": "class Solution:\n  def minOperations(self, grid: list[list[int]], x: int) -> int:\n    arr = sorted([a for row in grid for a in row])\n    if any((a - arr[0]) % x for a in arr):\n      return -1\n\n    ans = 0\n\n    for a in arr:\n      ans += abs(a - arr[len(arr) // 2]) // x\n\n    return ans",
      "title": "2033. Minimum Operations to Make a Uni-Value Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a8e4369-d35b-46bd-96b6-cca43ec16529",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 2\n    summ = sum(nums)\n    goal = summ // 2\n    lNums = nums[:n]\n    rNums = nums[n:]\n    ans = abs(sum(lNums) - sum(rNums))\n    lSums = [[] for _ in range(n + 1)]\n    rSums = [[] for _ in range(n + 1)]\n\n    def dfs(\n        arr: list[int],\n        i: int,\n        count: int,\n        path: int,\n        sums: list[list[int]]\n    ):\n      if i == len(arr):\n        sums[count].append(path)\n        return\n      dfs(arr, i + 1, count + 1, path + arr[i], sums)\n      dfs(arr, i + 1, count, path, sums)\n\n    dfs(lNums, 0, 0, 0, lSums)\n    dfs(rNums, 0, 0, 0, rSums)\n\n    for lCount in range(n):\n      l = lSums[lCount]\n      r = rSums[n - lCount]\n      r.sort()\n      for lSum in l:\n        i = bisect_left(r, goal - lSum)\n        if i < len(r):\n          sumPartOne = summ - lSum - r[i]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n        if i > 0:\n          sumPartOne = summ - lSum - r[i - 1]\n          sumPartTwo = summ - sumPartOne\n          ans = min(ans, abs(sumPartOne - sumPartTwo))\n\n    return ans",
      "title": "2035. Partition Array Into Two Arrays to Minimize Sum Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2b98baa-4538-4d69-b519-c1beff4568a6",
      "code": "class Solution:\n  def maximumAlternatingSubarraySum(self, nums: list[int]) -> int:\n    ans = -math.inf\n    even = 0  # the subarray sum starting from an even index\n    odd = 0  # the subarray sum starting from an odd index\n\n    for i in range(len(nums)):\n      if i % 2 == 0:  # Must pick.\n        even += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        even = max(0, even - nums[i])\n      ans = max(ans, even)\n\n    for i in range(1, len(nums)):\n      if i % 2 == 1:  # Must pick.\n        odd += nums[i]\n      else:  # Start a fresh subarray or subtract `nums[i]`.\n        odd = max(0, odd - nums[i])\n      ans = max(ans, odd)\n\n    return ans",
      "title": "2036. Maximum Alternating Subarray Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a332f68c-9f26-441d-8295-130b460fdf95",
      "code": "class Solution:\n  def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:\n    return sum(\n        abs(seat - student) for seat,\n        student in zip(sorted(seats),\n                       sorted(students)))",
      "title": "2037. Minimum Number of Moves to Seat Everyone",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "941351dc-9335-4e8d-b4a8-4089657a4600",
      "code": "class Solution:\n  def winnerOfGame(self, colors: str) -> bool:\n    countAAA = 0\n    countBBB = 0\n\n    for a, b, c in zip(colors, colors[1:], colors[2:]):\n      if 'A' == a == b == c:\n        countAAA += 1\n      elif 'B' == a == b == c:\n        countBBB += 1\n\n    return countAAA > countBBB",
      "title": "2038. Remove Colored Pieces if Both Neighbors are the Same Color",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0f476965-d412-436a-a018-ccacd7033a7e",
      "code": "class Solution:\n  def networkBecomesIdle(\n      self,\n      edges: list[list[int]],\n      patience: list[int],\n  ) -> int:\n    n = len(patience)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    q = collections.deque([0])\n    dist = [math.inf] * n  # dist[i] := the distance between i and 0\n    dist[0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if dist[v] == math.inf:\n            dist[v] = dist[u] + 1\n            q.append(v)\n\n    for i in range(1, n):\n      numResending = (dist[i] * 2 - 1) // patience[i]\n      lastResendingTime = patience[i] * numResending\n      lastArrivingTime = lastResendingTime + dist[i] * 2\n      ans = max(ans, lastArrivingTime)\n\n    return ans + 1",
      "title": "2039. The Time When the Network Becomes Idle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ce3e724-6969-4867-8961-86f9b749d5e7",
      "code": "class Solution:\n  def kthSmallestProduct(\n      self,\n      nums1: list[int],\n      nums2: list[int],\n      k: int,\n  ) -> int:\n    A1 = [-num for num in nums1 if num < 0][::-1]\n    A2 = [num for num in nums1 if num >= 0]\n    B1 = [-num for num in nums2 if num < 0][::-1]\n    B2 = [num for num in nums2 if num >= 0]\n\n    negCount = len(A1) * len(B2) + len(A2) * len(B1)\n\n    if k > negCount:  # Find the (k - negCount)-th positive.\n      k -= negCount\n      sign = 1\n    else:\n      k = negCount - k + 1  # Find the (negCount - k + 1)-th abs(negative).\n      sign = -1\n      B1, B2 = B2, B1\n\n    def numProductNoGreaterThan(A: list[int], B: list[int], m: int) -> int:\n      ans = 0\n      j = len(B) - 1\n      for i in range(len(A)):\n        # For each A[i], find the first index j s.t. A[i] * B[j] <= m\n        # So numProductNoGreaterThan m for this row will be j + 1\n        while j >= 0 and A[i] * B[j] > m:\n          j -= 1\n        ans += j + 1\n      return ans\n\n    l = 0\n    r = 10**10\n\n    while l < r:\n      m = (l + r) // 2\n      if (numProductNoGreaterThan(A1, B1, m) +\n              numProductNoGreaterThan(A2, B2, m) >= k):\n        r = m\n      else:\n        l = m + 1\n\n    return sign * l",
      "title": "2040. Kth Smallest Product of Two Sorted Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "926a9beb-1407-4f2e-99bb-186962398853",
      "code": "class Solution:\n  def areNumbersAscending(self, s: str) -> bool:\n    prev = 0\n\n    for token in s.split():\n      if token.isdigit():\n        num = int(token)\n        if num <= prev:\n          return False\n        prev = num\n\n    return True",
      "title": "2042. Check if Numbers Are Ascending in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ab3da6b-e568-48f5-9e52-c6b4d8ce0c3c",
      "code": "class Solution:\n  def countMaxOrSubsets(self, nums: list[int]) -> int:\n    ors = functools.reduce(operator.or_, nums)\n    ans = 0\n\n    def dfs(i: int, path: int) -> None:\n      nonlocal ans\n      if i == len(nums):\n        if path == ors:\n          ans += 1\n        return\n\n      dfs(i + 1, path)\n      dfs(i + 1, path | nums[i])\n\n    dfs(0, 0)\n    return ans",
      "title": "2044. Count Number of Maximum Bitwise-OR Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca21760c-1170-438e-afbd-75b51f2f982c",
      "code": "class Solution:\n  def secondMinimum(\n      self,\n      n: int,\n      edges: list[list[int]],\n      time: int,\n      change: int,\n  ) -> int:\n    graph = [[] for _ in range(n + 1)]\n    q = collections.deque([(1, 0)])\n    # minTime[u][0] := the first minimum time to reach the node u\n    # minTime[u][1] := the second minimum time to reach the node u\n    minTime = [[math.inf] * 2 for _ in range(n + 1)]\n    minTime[1][0] = 0\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    while q:\n      u, prevTime = q.popleft()\n      # Start from green.\n      # If `numChangeSignal` is odd, now red.\n      # If numChangeSignal is even -> now gree\n      numChangeSignal = prevTime // change\n      waitTime = (0 if numChangeSignal % 2 == 0\n                  else change - (prevTime % change))\n      newTime = prevTime + waitTime + time\n      for v in graph[u]:\n        if newTime < minTime[v][0]:\n          minTime[v][0] = newTime\n          q.append((v, newTime))\n        elif minTime[v][0] < newTime < minTime[v][1]:\n          if v == n:\n            return newTime\n          minTime[v][1] = newTime\n          q.append((v, newTime))",
      "title": "2045. Second Minimum Time to Reach Destination",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c0a8abe5-36ca-4637-8641-b305a2ba94d0",
      "code": "class Solution:\n  def sortLinkedList(self, head: ListNode | None) -> ListNode | None:\n    prev = head\n    curr = head.next\n\n    while curr:\n      if curr.val < 0:\n        prev.next = curr.next\n        curr.next = head\n        head = curr\n        curr = prev.next\n      else:\n        prev = curr\n        curr = curr.next\n\n    return head",
      "title": "2046. Sort Linked List Already Sorted Using Absolute Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c7cd7562-7bc2-411f-80b2-0b684ef09b12",
      "code": "class Solution:\n  def countValidWords(self, sentence: str) -> int:\n    def isValid(token: str) -> bool:\n      countHyphen = 0\n      for i, c in enumerate(token):\n        if c.isdigit():\n          return False\n        if c == '-':\n          if i == 0 or not token[i - 1].isalpha():\n            return False\n          if i == len(token) - 1 or not token[i + 1].isalpha():\n            return False\n          if countHyphen == 1:\n            return False\n          countHyphen += 1\n        if c in ['!', '.', ',']:\n          if i != len(token) - 1:\n            return False\n      return True\n\n    return sum(isValid(token) for token in sentence.split())",
      "title": "2047. Number of Valid Words in a Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9b9cf0b-e51b-4bae-845b-fc10f6847e13",
      "code": "class Solution:\n  def nextBeautifulNumber(self, n: int) -> int:\n    def isBalance(num: int) -> bool:\n      count = [0] * 10\n      while num > 0:\n        if num % 10 == 0:\n          return False\n        count[num % 10] += 1\n        num //= 10\n      return all(c == i for i, c in enumerate(count) if c)\n\n    n += 1\n    while not isBalance(n):\n      n += 1\n    return n",
      "title": "2048. Next Greater Numerically Balanced Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e3c53ac3-5ced-4750-a161-d7f22a520065",
      "code": "class Solution:\n  def countHighestScoreNodes(self, parents: list[int]) -> int:\n    tree = [[] for _ in range(len(parents))]\n\n    for i, parent in enumerate(parents):\n      if parent == -1:\n        continue\n      tree[parent].append(i)\n\n    ans = 0\n    maxScore = 0\n\n    def dfs(u: int) -> int:  # Returns node count\n      nonlocal ans\n      nonlocal maxScore\n      count = 1\n      score = 1\n      for v in tree[u]:\n        childCount = dfs(v)\n        count += childCount\n        score *= childCount\n      score *= len(parents) - count or 1\n      if score > maxScore:\n        maxScore = score\n        ans = 1\n      elif score == maxScore:\n        ans += 1\n      return count\n\n    dfs(0)\n    return ans",
      "title": "2049. Count Nodes With the Highest Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a6f2446-ae57-4ef7-b1c6-07d358e01b63",
      "code": "class Solution:\n  def minimumTime(\n      self,\n      n: int,\n      relations: list[list[int]],\n      time: list[int],\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    dist = time.copy()\n\n    # Build the graph.\n    for a, b in relations:\n      u = a - 1\n      v = b - 1\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        dist[v] = max(dist[v], dist[u] + time[v])\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return max(dist)",
      "title": "2050. Parallel Courses III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "aa509754-85f1-46e4-9bcf-2ebabe88d248",
      "code": "class Solution:\n  def minimumCost(self, sentence: str, k: int) -> int:\n    if len(sentence) <= k:\n      return 0\n\n    words = sentence.split()\n\n    # dp[i] := the minimum cost of the first i words\n    dp = [0] * (len(words) + 1)\n\n    for i in range(1, len(words) + 1):\n      n = len(words[i - 1])  # the length of the current row\n      dp[i] = dp[i - 1] + (k - n)**2\n      # Gradually add words[j - 1], words[j - 2], ....\n      for j in range(i - 1, 0, -1):\n        n += len(words[j - 1]) + 1\n        if n > k:\n          break\n        dp[i] = min(dp[i], dp[j - 1] + (k - n)**2)\n\n    lastRowLen = len(words[-1])\n    i = len(words) - 2  # Greedily put words into last row\n\n    while i > 0 and lastRowLen + len(words[i]) + 1 <= k:\n      lastRowLen += len(words[i]) + 1\n      i -= 1\n\n    return min(dp[i + 1:len(words)])",
      "title": "2052. Minimum Cost to Separate Sentence Into Rows",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "22c9504a-5a96-4281-b045-79d2a4af8d02",
      "code": "class Solution:\n  def kthDistinct(self, arr: list[str], k: int) -> str:\n    count = collections.Counter(arr)\n\n    for a in arr:\n      if count[a] == 1:\n        k -= 1\n        if k == 0:\n          return a\n\n    return ''",
      "title": "2053. Kth Distinct String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d36427f8-7c4b-4385-be06-5ad40d640364",
      "code": "class Solution:\n  def maxTwoEvents(self, events: list[list[int]]) -> int:\n    ans = 0\n    maxValue = 0\n    evts = []  # (time, isStart, value)\n\n    for s, e, v in events:\n      evts.append((s, 1, v))\n      evts.append((e + 1, 0, v))\n\n    # When two events have the same time, the one is not start will be in the front\n    evts.sort()\n\n    for _, isStart, value in evts:\n      if isStart:\n        ans = max(ans, value + maxValue)\n      else:\n        maxValue = max(maxValue, value)\n\n    return ans",
      "title": "2054. Two Best Non-Overlapping Events",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d4f73b54-408c-4e95-afaf-9e9e8f7ea6ef",
      "code": "class Solution:\n  def platesBetweenCandles(self, s: str, queries: list[list[int]]) -> list[int]:\n    n = len(s)\n    ans = []\n    closestLeftCandle = [0] * n\n    closestRightCandle = [0] * n\n    candleCount = [0] * n  # candleCount[i] := the number of candles in s[0..i]\n    candle = -1\n    count = 0\n\n    for i, c in enumerate(s):\n      if c == '|':\n        candle = i\n        count += 1\n      closestLeftCandle[i] = candle\n      candleCount[i] = count\n\n    candle = -1\n    for i, c in reversed(list(enumerate(s))):\n      if c == '|':\n        candle = i\n      closestRightCandle[i] = candle\n\n    for left, right in queries:\n      l = closestRightCandle[left]\n      r = closestLeftCandle[right]\n      if l == -1 or r == -1 or l > r:\n        ans.append(0)\n      else:\n        lengthBetweenCandles = r - l + 1\n        numCandles = candleCount[r] - candleCount[l] + 1\n        ans.append(lengthBetweenCandles - numCandles)\n\n    return ans",
      "title": "2055. Plates Between Candles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8cc2b048-4d48-4be6-9b20-9abfbe37174c",
      "code": "class Solution:\n  def countCombinations(\n      self,\n      pieces: list[str],\n      positions: list[list[int]],\n  ) -> int:\n    n = len(pieces)\n    moves = {\"rook\": [(1, 0), (-1, 0), (0, 1), (0, -1)],\n             \"bishop\": [(1, 1), (1, -1), (-1, 1), (-1, -1)],\n             \"queen\": [(1, 0), (-1, 0), (0, 1), (0, -1), (1, 1), (1, -1), (-1, 1), (-1, -1)]}\n    hashedBoards = set()\n\n    def getHash(board: list[list[int]]) -> Tuple:\n      return tuple([tuple(pos) for pos in board])\n\n    def dfs(\n        board: list[list[int]],\n        pieceMoves: list[tuple[int, int]],\n        activeMask: int,\n    ) -> None:\n      \"\"\"Performs a depth-first search to explore all possible board states.\"\"\"\n      if activeMask == 0:\n        return\n      hashedBoards.add(getHash(board))\n\n      for nextActiveMask in range(1, 1 << n):\n        if activeMask & nextActiveMask != nextActiveMask:\n          continue\n\n        # Copy the board.\n        nextBoard = [pos.copy() for pos in board]\n\n        # Move the pieces that are active in this turn.\n        for i in range(n):\n          if nextActiveMask >> i & 1:\n            nextBoard[i][0] += pieceMoves[i][0]\n            nextBoard[i][1] += pieceMoves[i][1]\n\n        # No two or more pieces occupy the same square.\n        if len(set(getHash(nextBoard))) < n:\n          continue\n\n        # Every piece needs to be in the boundary.\n        if all(1 <= x <= 8 and 1 <= y <= 8 for x, y in nextBoard):\n          dfs(nextBoard, pieceMoves, nextActiveMask)\n\n    for pieceMoves in itertools.product(*(moves[piece] for piece in pieces)):\n      dfs(positions, pieceMoves, (1 << n) - 1)\n\n    return len(hashedBoards)",
      "title": "2056. Number of Valid Move Combinations On Chessboard",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "69439a70-0df6-4f46-9023-ad921a29a5a9",
      "code": "class Solution:\n  def smallestEqual(self, nums: list[int]) -> int:\n    return next((i for i, num in enumerate(nums) if i % 10 == num), -1)",
      "title": "2057. Smallest Index With Equal Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77572acf-ca63-43ad-af0e-774ff753e3d5",
      "code": "class Solution:\n  def nodesBetweenCriticalPoints(self, head: ListNode | None) -> list[int]:\n    minDistance = math.inf\n    firstMaIndex = -1\n    prevMaIndex = -1\n    index = 1\n    prev = head  # Point to the index 0.\n    curr = head.next  # Point to the index 1.\n\n    while curr.next:\n      if (curr.val > prev.val and curr.val > curr.next.val or\n              curr.val < prev.val and curr.val < curr.next.val):\n        if firstMaIndex == -1:  # Only assign once.\n          firstMaIndex = index\n        if prevMaIndex != -1:\n          minDistance = min(minDistance, index - prevMaIndex)\n        prevMaIndex = index\n      prev = curr\n      curr = curr.next\n      index += 1\n\n    if minDistance == math.inf:\n      return [-1, -1]\n    return [minDistance, prevMaIndex - firstMaIndex]",
      "title": "2058. Find the Minimum and Maximum Number of Nodes Between Critical Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "796cfbb7-2cfa-4162-9f1a-243b035d13cd",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int], start: int, goal: int) -> int:\n    q = collections.deque([start])\n    seen = {start}\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        x = q.popleft()\n        for num in nums:\n          for res in (x + num, x - num, x ^ num):\n            if res == goal:\n              return step\n            if res < 0 or res > 1000 or res in seen:\n              continue\n            seen.add(res)\n            q.append(res)\n      step += 1\n\n    return -1",
      "title": "2059. Minimum Operations to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90d45ad3-827d-4683-9230-20fe53829a20",
      "code": "class Solution:\n  def possiblyEquals(self, s1: str, s2: str) -> bool:\n    def getNums(s: str) -> set[int]:\n      nums = {int(s)}\n      for i in range(1, len(s)):\n        nums |= {x + y for x in getNums(s[:i]) for y in getNums(s[i:])}\n      return nums\n\n    def getNextLetterIndex(s: str, i: int) -> int:\n      j = i\n      while j < len(s) and s[j].isdigit():\n        j += 1\n      return j\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, paddingDiff: int) -> bool:\n      \"\"\"\n      Returns True if s1[i..n) matches s2[j..n), accounting for the padding\n      difference. Here, `paddingDiff` represents the signed padding. A positive\n      `paddingDiff` indicates that s1 has an additional number of offset bytes\n      compared to s2.\n      \"\"\"\n      if i == len(s1) and j == len(s2):\n        return paddingDiff == 0\n      # Add padding on s1.\n      if i < len(s1) and s1[i].isdigit():\n        nextLetterIndex = getNextLetterIndex(s1, i)\n        for num in getNums(s1[i:nextLetterIndex]):\n          if dp(nextLetterIndex, j, paddingDiff + num):\n            return True\n      # Add padding on s2.\n      elif j < len(s2) and s2[j].isdigit():\n        nextLetterIndex = getNextLetterIndex(s2, j)\n        for num in getNums(s2[j:nextLetterIndex]):\n          if dp(i, nextLetterIndex, paddingDiff - num):\n            return True\n      # `s1` has more padding, so j needs to catch up.\n      elif paddingDiff > 0:\n        if j < len(s2):\n          return dp(i, j + 1, paddingDiff - 1)\n      # `s2` has more padding, so i needs to catch up.\n      elif paddingDiff < 0:\n        if i < len(s1):\n          return dp(i + 1, j, paddingDiff + 1)\n      # There's no padding difference, so consume the next letter.\n      else:  # paddingDiff == 0\n        if i < len(s1) and j < len(s2) and s1[i] == s2[j]:\n          return dp(i + 1, j + 1, 0)\n      return False\n\n    return dp(0, 0, 0)",
      "title": "2060. Check if an Original String Exists Given Two Encoded Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e2a77cb-50da-47b9-8a72-2940b09be805",
      "code": "class Solution:\n  def numberOfCleanRooms(self, room: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(room)\n    n = len(room[0])\n    ans = 1\n    i = 0\n    j = 0\n    state = 0  # 0 := right, 1 := down, 2 := left, 3 := up\n    seen = {(i, j, state)}\n    room[i][j] = 2  # 2 := cleaned\n\n    while True:\n      x = i + DIRS[state][0]\n      y = j + DIRS[state][1]\n      if x < 0 or x == m or y < 0 or y == n or room[x][y] == 1:\n        # Turn 90 degrees clockwise.\n        state = (state + 1) % 4\n      else:\n        # Walk to (x, y).\n        if room[x][y] == 0:\n          ans += 1\n          room[x][y] = 2\n        i = x\n        j = y\n      if (x, y, state) in seen:\n        return ans\n      seen.add((x, y, state))",
      "title": "2061. Number of Spaces Cleaning Robot Cleaned",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a232af9-4a37-4e91-a33f-33da12f8c646",
      "code": "class Solution:\n  def countVowelSubstrings(self, word: str) -> int:\n    VOWELS = 'aeiou'\n\n    def countVowelSubstringsAtMost(goal: int) -> int:\n      ans = 0\n      k = goal\n      count = collections.Counter()\n\n      l = 0\n      for r, c in enumerate(word):\n        if c not in VOWELS:  # Fresh start.\n          l = r + 1\n          k = goal\n          count = collections.Counter()\n          continue\n        count[c] += 1\n        if count[c] == 1:\n          k -= 1\n        while k == -1:\n          count[word[l]] -= 1\n          if count[word[l]] == 0:\n            k += 1\n          l += 1\n        ans += r - l + 1  # s[l..r], s[l + 1..r], ..., s[r]\n\n      return ans\n\n    return countVowelSubstringsAtMost(5) - countVowelSubstringsAtMost(4)",
      "title": "2062. Count Vowel Substrings of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07f30bae-7883-44f0-a6f1-ddb8fdae6fde",
      "code": "class Solution:\n  def countVowels(self, word: str) -> int:\n    # dp[i] := the sum of the number of vowels of word[0..i), ...,\n    # word[i - 1..i)\n    dp = [0] * (len(word) + 1)\n\n    for i, c in enumerate(word):\n      dp[i + 1] = dp[i]\n      if c in 'aeiou':\n        dp[i + 1] += i + 1\n\n    return sum(dp)",
      "title": "2063. Vowels of All Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c558ca64-e0d7-4b5c-b335-c2af7c72990d",
      "code": "class Solution:\n  def minimizedMaximum(self, n: int, quantities: list[int]) -> int:\n    l = 1\n    r = max(quantities)\n\n    def numStores(m: int) -> int:\n      return sum((q - 1) // m + 1 for q in quantities)\n\n    while l < r:\n      m = (l + r) // 2\n      if numStores(m) <= n:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2064. Minimized Maximum of Products Distributed to Any Store",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "838534fa-03c9-46d4-8c4f-3e4e6cf000af",
      "code": "class Solution:\n  def maximalPathQuality(\n      self,\n      values: list[int],\n      edges: list[list[int]],\n      maxTime: int,\n  ) -> int:\n    n = len(values)\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    seen[0] = 1\n\n    for u, v, time in edges:\n      graph[u].append((v, time))\n      graph[v].append((u, time))\n\n    def dfs(u: int, quality: int, remainingTime: int):\n      nonlocal ans\n      if u == 0:\n        ans = max(ans, quality)\n      for v, time in graph[u]:\n        if time > remainingTime:\n          continue\n        newQuality = quality + values[v] * (seen[v] == 0)\n        seen[v] += 1\n        dfs(v, newQuality, remainingTime - time)\n        seen[v] -= 1\n\n    dfs(0, values[0], maxTime)\n    return ans",
      "title": "2065. Maximum Path Quality of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fc3846f5-2da8-4a62-b879-c3ec6109c703",
      "code": "class Solution:\n  def equalCountSubstrings(self, s: str, count: int) -> int:\n    maxUnique = len(set(s))\n    ans = 0\n\n    for unique in range(1, maxUnique + 1):\n      windowSize = unique * count\n      lettersCount = collections.Counter()\n      uniqueCount = 0\n      for i, c in enumerate(s):\n        lettersCount[c] += 1\n        if lettersCount[c] == count:\n          uniqueCount += 1\n        if i >= windowSize:\n          lettersCount[s[i - windowSize]] -= 1\n          if lettersCount[s[i - windowSize]] == count - 1:\n            uniqueCount -= 1\n        ans += uniqueCount == unique\n\n    return ans",
      "title": "2067. Number of Equal Count Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9d752f6-ce7b-4b70-9b46-195e3c593695",
      "code": "class Solution:\n  def checkAlmostEquivalent(self, word1: str, word2: str) -> bool:\n    count = collections.Counter(word1)\n    count.subtract(collections.Counter(word2))\n    return all(abs(freq) <= 3 for freq in count.values())",
      "title": "2068. Check Whether Two Strings are Almost Equivalent",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "823bfcbc-644f-4bd1-8950-2bc956a0484d",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      items: list[list[int]],\n      queries: list[int],\n  ) -> list[int]:\n    prices, beauties = zip(*sorted(items))\n    maxBeautySoFar = [0] * (len(beauties) + 1)\n\n    for i, beauty in enumerate(beauties):\n      maxBeautySoFar[i + 1] = max(maxBeautySoFar[i], beauty)\n\n    return [maxBeautySoFar[bisect_right(prices, query)] for query in queries]",
      "title": "2070. Most Beautiful Item for Each Query",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6464846a-40ab-4449-9077-b94a977ab388",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def maxTaskAssign(\n      self,\n      tasks: list[int],\n      workers: list[int],\n      pills: int,\n      strength: int,\n  ) -> int:\n    tasks.sort()\n    workers.sort()\n\n    def canComplete(k: int, pillsLeft: int) -> bool:\n      \"\"\"Returns True if we can finish k tasks.\"\"\"\n      # k strongest workers\n      sortedWorkers = SortedList(workers[-k:])\n\n      # Out of the k smallest tasks, start from the biggest one.\n      for i in reversed(range(k)):\n        # Find the first worker that has strength >= tasks[i].\n        index = sortedWorkers.bisect_left(tasks[i])\n        if index < len(sortedWorkers):\n          sortedWorkers.pop(index)\n        elif pillsLeft > 0:\n          # Find the first worker that has strength >= tasks[i] - strength.\n          index = sortedWorkers.bisect_left(tasks[i] - strength)\n          if index < len(sortedWorkers):\n            sortedWorkers.pop(index)\n            pillsLeft -= 1\n          else:\n            return False\n        else:\n          return False\n\n      return True\n\n    ans = 0\n    l = 0\n    r = min(len(tasks), len(workers))\n\n    while l <= r:\n      m = (l + r) // 2\n      if canComplete(m, pills):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return ans",
      "title": "2071. Maximum Number of Tasks You Can Assign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62f8a6ea-ae9d-49c5-abd9-7be5d5bd2857",
      "code": "class Solution:\n  def timeRequiredToBuy(self, tickets: list[int], k: int) -> int:\n    ans = 0\n\n    for i, ticket in enumerate(tickets):\n      if i <= k:\n        ans += min(ticket, tickets[k])\n      else:\n        ans += min(ticket, tickets[k] - 1)\n\n    return ans",
      "title": "2073. Time Needed to Buy Tickets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "581f2bbf-2fab-4ff6-85a9-c3b5db40a081",
      "code": "class Solution:\n  def reverseEvenLengthGroups(self, head: ListNode | None) -> ListNode | None:\n    # prev -> (head -> ... -> tail) -> next -> ...\n    dummy = ListNode(0, head)\n    prev = dummy\n    tail = head\n    next = head.next\n    groupLength = 1\n\n    def getTailAndLength(head: ListNode | None, groupLength: int) -> tuple[ListNode | None, int]:\n      length = 1\n      tail = head\n      while length < groupLength and tail.next:\n        tail = tail.next\n        length += 1\n      return tail, length\n\n    def reverse(head: ListNode | None) -> ListNode | None:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    while True:\n      if groupLength % 2 == 1:\n        prev.next = head\n        prev = tail\n      else:\n        tail.next = None\n        prev.next = reverse(head)\n        # Prev -> (tail -> ... -> head) -> next -> ...\n        head.next = next\n        prev = head\n      if not next:\n        break\n      head = next\n      tail, length = getTailAndLength(head, groupLength + 1)\n      next = tail.next\n      groupLength = length\n\n    return dummy.next",
      "title": "2074. Reverse Nodes in Even Length Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8214fe02-4641-4b9b-aa20-e139a926715f",
      "code": "class Solution:\n  def decodeCiphertext(self, encodedText: str, rows: int) -> str:\n    n = len(encodedText)\n    cols = n // rows\n\n    ans = []\n    matrix = [[' '] * cols for _ in range(rows)]\n\n    for i in range(rows):\n      for j in range(cols):\n        matrix[i][j] = encodedText[i * cols + j]\n\n    for col in range(cols):\n      i = 0\n      j = col\n      while i < rows and j < cols:\n        ans.append(matrix[i][j])\n        i += 1\n        j += 1\n\n    return ''.join(ans).rstrip()",
      "title": "2075. Decode the Slanted Ciphertext",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94250c51-22d0-4dcc-9872-cc5c407ae4c0",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self.find(u)\n    j = self.find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self.find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def friendRequests(\n      self,\n      n: int,\n      restrictions: list[list[int]],\n      requests: list[list[int]],\n  ) -> list[bool]:\n    ans = []\n    uf = UnionFind(n)\n\n    for u, v in requests:\n      pu = uf.find(u)\n      pv = uf.find(v)\n      isValid = True\n      if pu != pv:\n        for x, y in restrictions:\n          px = uf.find(x)\n          py = uf.find(y)\n          if (pu, pv) in [(px, py), (py, px)]:\n            isValid = False\n            break\n      ans.append(isValid)\n      if isValid:\n        uf.unionByRank(pu, pv)\n\n    return ans",
      "title": "2076. Process Restricted Friend Requests",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f228820-2ba5-49ed-9800-a76a04b39b99",
      "code": "class Solution:\n  def numberOfPaths(self, n: int, corridors: list[list[int]]) -> int:\n    ans = 0\n    graph = [[False] * 1001 for _ in range(n + 1)]\n\n    for u, v in corridors:\n      graph[u][v] = True\n      graph[v][u] = True\n\n    for u, v in corridors:\n      for i in range(1, n + 1):\n        if graph[u][i] and graph[i][v]:\n          ans += 1\n\n    return ans // 3",
      "title": "2077. Paths in Maze That Lead to Same Room",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e6d7ab10-c9a8-444a-9e89-20f463ae2bec",
      "code": "class Solution:\n  def maxDistance(self, colors: list[int]) -> int:\n    # The maximum distance always includes either the first or the last house.\n    n = len(colors)\n    i = 0  # the leftmost index, where colors[i] != colors[-1]\n    j = n - 1  # the rightmost index, where colors[j] != colors[0]\n    while colors[i] == colors[-1]:\n      i += 1\n    while colors[j] == colors[0]:\n      j -= 1\n    return max(n - 1 - i, j)",
      "title": "2078. Two Furthest Houses With Different Colors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0df1a512-7f6c-4a38-8731-7ea8aff53ca1",
      "code": "class Solution:\n  def wateringPlants(self, plants: list[int], capacity: int) -> int:\n    ans = 0\n    currCapacity = 0\n\n    for i, plant in enumerate(plants):\n      if currCapacity + plant <= capacity:\n        currCapacity += plant\n      else:\n        currCapacity = plant  # Reset\n        ans += i * 2\n\n    return ans + len(plants)",
      "title": "2079. Watering Plants",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ce103f8-f285-4ba3-9624-a1e7b5b4b6eb",
      "code": "class Solution:\n  def kMirror(self, k: int, n: int) -> int:\n    ans = 0\n    A = ['0']\n\n    def nextKMirror(A: list[str]) -> list[str]:\n      for i in range(len(A) // 2, len(A)):\n        nextNum = int(A[i]) + 1\n        if nextNum < k:\n          A[i] = str(nextNum)\n          A[~i] = str(nextNum)\n          for j in range(len(A) // 2, i):\n            A[j] = '0'\n            A[~j] = '0'\n          return A\n      return ['1'] + ['0'] * (len(A) - 1) + ['1']\n\n    for _ in range(n):\n      while True:\n        A = nextKMirror(A)\n        num = int(''.join(A), k)\n        if str(num)[::-1] == str(num):\n          break\n      ans += num\n\n    return ans",
      "title": "2081. Sum of k-Mirror Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7f793ecf-f75c-4272-a8c0-e73f5dbaf14b",
      "code": "class Solution:\n  def numberOfSubstrings(self, s: str) -> int:\n    ans = 0\n    count = collections.Counter()\n\n    for c in s:\n      ans += count[c] + 1\n      count[c] += 1\n\n    return ans",
      "title": "2083. Substrings That Begin and End With the Same Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8b189f3a-2e95-421d-9270-c2fd3184b9b3",
      "code": "class Solution:\n  def countWords(self, words1: list[str], words2: list[str]) -> int:\n    count = collections.Counter(words1)\n\n    for word in words2:\n      if word in count and count[word] < 2:\n        count[word] -= 1\n\n    return sum(value == 0 for value in count.values())",
      "title": "2085. Count Common Words With One Occurrence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c01659b0-5760-44c7-b33f-a7846f54c0d7",
      "code": "class Solution:\n  def minimumBuckets(self, street: str) -> int:\n    A = list(street)\n\n    for i, c in enumerate(A):\n      if c == 'H':\n        if i > 0 and A[i - 1] == 'B':\n          continue\n        if i + 1 < len(A) and A[i + 1] == '.':\n          # Always prefer place a bucket in (i + 1) because it enhances the\n          # possibility to collect the upcoming houses.\n          A[i + 1] = 'B'\n        elif i > 0 and A[i - 1] == '.':\n          A[i - 1] = 'B'\n        else:\n          return -1\n\n    return A.count('B')",
      "title": "2086. Minimum Number of Buckets Required to Collect Rainwater from Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "438cd724-4abe-44d7-9c53-5956a2d7e1ea",
      "code": "class Solution:\n  def minCost(\n      self,\n      startPos: list[int],\n      homePos: list[int],\n      rowCosts: list[int],\n      colCosts: list[int],\n  ) -> int:\n    ans = 0\n    i, j = startPos\n    x, y = homePos\n\n    while i != x:\n      i += 1 if i < x else -1\n      ans += rowCosts[i]\n\n    while j != y:\n      j += 1 if j < y else -1\n      ans += colCosts[j]\n\n    return ans",
      "title": "2087. Minimum Cost Homecoming of a Robot in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11710f68-f4cb-4785-8265-d85dbe3d6ce7",
      "code": "class Solution:\n  def countPyramids(self, grid: list[list[int]]) -> int:\n    # dp[i][j] := the maximum height of the pyramid for which it is the apex\n    def count(dp: list[list[int]]) -> int:\n      ans = 0\n      for i in range(len(dp) - 2, -1, -1):\n        for j in range(1, len(dp[0]) - 1):\n          if dp[i][j] == 1:\n            dp[i][j] = min(dp[i + 1][j - 1],\n                           dp[i + 1][j],\n                           dp[i + 1][j + 1]) + 1\n            ans += dp[i][j] - 1\n      return ans\n\n    return count(deepcopy(grid)[::-1]) + count(grid)",
      "title": "2088. Count Fertile Pyramids in a Land",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4556c520-0327-42d3-9b31-b683e40cccf2",
      "code": "class Solution:\n  def targetIndices(self, nums: list[int], target: int) -> list[int]:\n    count = nums.count(target)\n    lessThan = sum(num < target for num in nums)\n    return [i for i in range(lessThan, lessThan + count)]",
      "title": "2089. Find Target Indices After Sorting Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d178b6f0-d9f1-4de5-bf9e-0f377ec2aa4d",
      "code": "class Solution:\n  def getAverages(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    size = 2 * k + 1\n    ans = [-1] * n\n    if size > n:\n      return ans\n\n    summ = sum(nums[:size])\n\n    for i in range(k, n - k):\n      ans[i] = summ // size\n      if i + k + 1 < n:\n        summ += nums[i + k + 1] - nums[i - k]\n\n    return ans",
      "title": "2090. K Radius Subarray Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5baf49dd-2fed-4629-afee-2b05ff5968f1",
      "code": "class Solution:\n  def minimumDeletions(self, nums: list[int]) -> int:\n    n = len(nums)\n    a = nums.index(min(nums))\n    b = nums.index(max(nums))\n    if a > b:\n      a, b = b, a\n    return min(a + 1 + n - b, b + 1, n - a)",
      "title": "2091. Removing Minimum and Maximum From Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c577b697-74f2-4c8d-9825-3b6de43e5ab3",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.id = list(range(n))\n    self.rank = [0] * n\n\n  def unionByRank(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.rank[i] < self.rank[j]:\n      self.id[i] = j\n    elif self.rank[i] > self.rank[j]:\n      self.id[j] = i\n    else:\n      self.id[i] = j\n      self.rank[j] += 1\n\n  def connected(self, u: int, v: int) -> bool:\n    return self._find(self.id[u]) == self._find(self.id[v])\n\n  def reset(self, u: int) -> None:\n    self.id[u] = u\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def findAllPeople(\n      self,\n      n: int,\n      meetings: list[list[int]],\n      firstPerson: int,\n  ) -> list[int]:\n    uf = UnionFind(n)\n    timeToPairs = collections.defaultdict(list)\n\n    uf.unionByRank(0, firstPerson)\n\n    for x, y, time in meetings:\n      timeToPairs[time].append((x, y))\n\n    for _, pairs in sorted(timeToPairs.items(), key=lambda x: x[0]):\n      peopleUnioned = set()\n      for x, y in pairs:\n        uf.unionByRank(x, y)\n        peopleUnioned.add(x)\n        peopleUnioned.add(y)\n      for person in peopleUnioned:\n        if not uf.connected(person, 0):\n          uf.reset(person)\n\n    return [i for i in range(n) if uf.connected(i, 0)]",
      "title": "2092. Find All People With Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03a5ec00-650b-4ba6-bbfa-336ffe00daee",
      "code": "class Solution:\n  def minimumCost(\n      self,\n      n: int,\n      highways: list[list[int]],\n      discounts: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    minHeap = [(0, 0, discounts)]  # (d, u, leftDiscounts)\n    minDiscounts = {}\n\n    for city1, city2, toll in highways:\n      graph[city1].append((city2, toll))\n      graph[city2].append((city1, toll))\n\n    while minHeap:\n      d, u, leftDiscounts = heapq.heappop(minHeap)\n      if u == n - 1:\n        return d\n      if u in minDiscounts and minDiscounts[u] >= leftDiscounts:\n        continue\n      minDiscounts[u] = leftDiscounts\n      for v, w in graph[u]:\n        heapq.heappush(minHeap, (d + w, v, leftDiscounts))\n        if leftDiscounts > 0:\n          heapq.heappush(minHeap, (d + w // 2, v, leftDiscounts - 1))\n\n    return -1",
      "title": "2093. Minimum Cost to Reach City With Discounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "daa87917-5259-4bd8-bb71-60024ee0cfa4",
      "code": "class Solution:\n  def findEvenNumbers(self, digits: list[int]) -> list[int]:\n    ans = []\n    count = collections.Counter(digits)\n\n    # Try to construct `abc`.\n    for a in range(1, 10):\n      for b in range(0, 10):\n        for c in range(0, 9, 2):\n          if count[a] > 0 and count[b] > (\n                  b == a) and count[c] > (\n                  c == a) + (\n                  c == b):\n            ans.append(a * 100 + b * 10 + c)\n\n    return ans",
      "title": "2094. Finding 3-Digit Even Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8eff3064-ecb3-41b7-badf-47d1d1e2da35",
      "code": "class Solution:\n  def deleteMiddle(self, head: ListNode | None) -> ListNode | None:\n    dummy = ListNode(0, head)\n    slow = dummy\n    fast = dummy\n\n    while fast.next and fast.next.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # Delete the middle node.\n    slow.next = slow.next.next\n    return dummy.next",
      "title": "2095. Delete the Middle Node of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4a5990ee-4d81-4c5c-9a6c-921c6d80e21a",
      "code": "class Solution:\n  def getDirections(\n      self,\n      root: TreeNode | None,\n      startValue: int,\n      destValue: int,\n  ) -> str:\n    def lca(root: TreeNode | None) -> TreeNode | None:\n      if not root or root.val in (startValue, destValue):\n        return root\n      left = lca(root.left)\n      right = lca(root.right)\n      if left and right:\n        return root\n      return left or right\n\n    def dfs(root: TreeNode | None, path: list[str]) -> None:\n      if not root:\n        return\n      if root.val == startValue:\n        self.pathToStart = ''.join(path)\n      if root.val == destValue:\n        self.pathToDest = ''.join(path)\n      path.append('L')\n      dfs(root.left, path)\n      path.pop()\n      path.append('R')\n      dfs(root.right, path)\n      path.pop()\n\n    dfs(lca(root), [])  # Only this subtree matters.\n    return 'U' * len(self.pathToStart) + ''.join(self.pathToDest)",
      "title": "2096. Step-By-Step Directions From a Binary Tree Node to Another",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fde88bcf-f2af-4416-897f-2f5d6fca9585",
      "code": "class Solution:\n  def validArrangement(self, pairs: list[list[int]]) -> list[list[int]]:\n    ans = []\n    graph = collections.defaultdict(list)\n    outDegree = collections.Counter()\n    inDegrees = collections.Counter()\n\n    for start, end in pairs:\n      graph[start].append(end)\n      outDegree[start] += 1\n      inDegrees[end] += 1\n\n    def getStartNode() -> int:\n      for u in graph.keys():\n        if outDegree[u] - inDegrees[u] == 1:\n          return u\n      return pairs[0][0]  # Arbitrarily choose a node.\n\n    def euler(u: int) -> None:\n      stack = graph[u]\n      while stack:\n        v = stack.pop()\n        euler(v)\n        ans.append([u, v])\n\n    euler(getStartNode())\n    return ans[::-1]",
      "title": "2097. Valid Arrangement of Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fabd76c5-16b2-46ef-8a5c-7808cb885062",
      "code": "class Solution:\n  def largestEvenSum(self, nums: list[int], k: int) -> int:\n    nums.sort()\n    summ = sum(nums[-k:])\n    if summ % 2 == 0:\n      return summ\n\n    minOdd = -1\n    minEven = -1\n    maxOdd = -1\n    maxEven = -1\n\n    for i in range(len(nums) - 1, len(nums) - k - 1, -1):\n      if nums[i] & 1:\n        minOdd = nums[i]\n      else:\n        minEven = nums[i]\n\n    for i in range(len(nums) - k):\n      if nums[i] & 1:\n        maxOdd = nums[i]\n      else:\n        maxEven = nums[i]\n\n    ans = -1\n\n    if maxEven >= 0 and minOdd >= 0:\n      ans = max(ans, summ + maxEven - minOdd)\n    if maxOdd >= 0 and minEven >= 0:\n      ans = max(ans, summ + maxOdd - minEven)\n    return ans",
      "title": "2098. Subsequence of Size K With the Largest Even Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ac677e22-3da5-49e9-bba7-0dd66fbf5d91",
      "code": "class Solution:\n  def maxSubsequence(self, nums: list[int], k: int) -> list[int]:\n    ans = []\n    threshold = sorted(nums)[-k]\n    larger = sum(num > threshold for num in nums)\n    equal = k - larger\n\n    for num in nums:\n      if num > threshold:\n        ans.append(num)\n      elif num == threshold and equal:\n        ans.append(num)\n        equal -= 1\n\n    return ans",
      "title": "2099. Find Subsequence of Length K With the Largest Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "996c1a6d-c377-4686-8885-4e85ff4f1fef",
      "code": "class Solution:\n  def goodDaysToRobBank(self, security: list[int], time: int) -> list[int]:\n    n = len(security)\n    dec = [0] * n  # dec[i] := the number of continuous decreasing numbers before i\n    inc = [0] * n  # inc[i] := the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if security[i - 1] >= security[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if security[i] <= security[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i, (a, b) in enumerate(zip(dec, inc))\n            if a >= time and b >= time]",
      "title": "2100. Find Good Days to Rob the Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cbba1a8d-c592-4e8f-b20a-238b47720412",
      "code": "class Solution:\n  def maximumDetonation(self, bombs: list[list[int]]) -> int:\n    n = len(bombs)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i, (xi, yi, ri) in enumerate(bombs):\n      for j, (xj, yj, rj) in enumerate(bombs):\n        if i == j:\n          continue\n        if ri**2 >= (xi - xj)**2 + (yi - yj)**2:\n          graph[i].append(j)\n\n    def dfs(u: int, seen: set[int]) -> None:\n      for v in graph[u]:\n        if v in seen:\n          continue\n        seen.add(v)\n        dfs(v, seen)\n\n    for i in range(n):\n      seen = set([i])\n      dfs(i, seen)\n      ans = max(ans, len(seen))\n\n    return ans",
      "title": "2101. Detonate the Maximum Bombs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "899ad9c3-4ca6-4340-9f23-98aef6f6880b",
      "code": "class Solution:\n  def countPoints(self, rings: str) -> int:\n    colors = [0] * 10\n\n    for c, num in zip(rings[::2], rings[1::2]):\n      color = 1 if c == 'R' else 2 if c == 'G' else 4\n      colors[int(num)] |= color\n\n    return sum(color == 7 for color in colors)",
      "title": "2103. Rings and Rods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ee74e610-0380-4a78-93b2-98e5e089f0be",
      "code": "class Solution:\n  def subArrayRanges(self, nums: list[int]) -> int:\n    prevGt, nextGt = self._getPrevNext(nums, operator.lt)\n    prevLt, nextLt = self._getPrevNext(nums, operator.gt)\n    return sum(num * (i - prevGt[i]) * (nextGt[i] - i) -\n               num * (i - prevLt[i]) * (nextLt[i] - i)\n               for i, num in enumerate(nums))\n\n  def _getPrevNext(\n      self,\n      nums: list[int],\n      op: callable\n  ) -> tuple[list[int], list[int]]:\n    \"\"\"\n    Returns `prev` and `next`, that store the indices of the nearest numbers\n    that are smaller or larger than the current number depending on `op`.\n    \"\"\"\n    n = len(nums)\n    prev = [-1] * n\n    next = [n] * n\n    stack = []\n    for i, num in enumerate(nums):\n      while stack and op(nums[stack[-1]], num):\n        next[stack.pop()] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n    return prev, next",
      "title": "2104. Sum of Subarray Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca83a480-e46c-41eb-80d2-04cf7b83ad31",
      "code": "class Solution:\n  def minimumRefill(\n      self,\n      plants: list[int],\n      capacityA: int,\n      capacityB: int,\n  ) -> int:\n    ans = 0\n    i = 0\n    j = len(plants) - 1\n    canA = capacityA\n    canB = capacityB\n\n    while i < j:\n      ans += (canA < plants[i]) + (canB < plants[j])\n      if canA < plants[i]:\n        canA = capacityA\n      if canB < plants[j]:\n        canB = capacityB\n      canA -= plants[i]\n      canB -= plants[j]\n      i += 1\n      j -= 1\n\n    return ans + (i == j and max(canA, canB) < plants[i])",
      "title": "2105. Watering Plants II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5df43bb6-1ec5-447d-92ac-b8f796a0ccb2",
      "code": "class Solution:\n  def maxTotalFruits(\n      self,\n      fruits: list[list[int]],\n      startPos: int,\n      k: int,\n  ) -> int:\n    ans = 0\n    maxRight = max(startPos, fruits[-1][0])\n    amounts = [0] * (1 + maxRight)\n    for position, amount in fruits:\n      amounts[position] = amount\n    prefix = list(itertools.accumulate(amounts, initial=0))\n\n    def getFruits(leftSteps: int, rightSteps: int) -> int:\n      l = max(0, startPos - leftSteps)\n      r = min(maxRight, startPos + rightSteps)\n      return prefix[r + 1] - prefix[l]\n\n    # Go right first.\n    for rightSteps in range(min(maxRight - startPos, k) + 1):\n      leftSteps = max(0, k - 2 * rightSteps)  # Turn left\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    # Go left first.\n    for leftSteps in range(min(startPos, k) + 1):\n      rightSteps = max(0, k - 2 * leftSteps)  # Turn right\n      ans = max(ans, getFruits(leftSteps, rightSteps))\n\n    return ans",
      "title": "2106. Maximum Fruits Harvested After at Most K Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8074ad90-37be-4fff-8c71-c265562e38cc",
      "code": "class Solution:\n  def shareCandies(self, candies: list[int], k: int) -> int:\n    ans = 0\n    count = collections.Counter(candies)\n    unique = len(count)\n\n    for i, candy in enumerate(candies):\n      count[candy] -= 1\n      if count[candy] == 0:\n        del count[candy]\n        unique -= 1\n      if i >= k:\n        count[candies[i - k]] += 1\n        if count[candies[i - k]] == 1:\n          unique += 1\n      if i >= k - 1:\n        ans = max(ans, unique)\n\n    return ans",
      "title": "2107. Number of Unique Flavors After Sharing K Candies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d7453d1-6159-4f22-88ff-d8a73c722135",
      "code": "class Solution:\n  def firstPalindrome(self, words: list[str]) -> str:\n    def isPalindrome(s: str) -> bool:\n      i = 0\n      j = len(s) - 1\n      while i < j:\n        if s[i] != s[j]:\n          return False\n        i += 1\n        j -= 1\n      return True\n    return next((word for word in words if isPalindrome(word)), '')",
      "title": "2108. Find First Palindromic String in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02486fc3-9739-4dc5-8400-34e1107ec716",
      "code": "class Solution:\n  def addSpaces(self, s: str, spaces: list[int]) -> str:\n    ans = []\n    j = 0  # spaces' index\n\n    for i, c in enumerate(s):\n      if j < len(spaces) and i == spaces[j]:\n        ans.append(' ')\n        j += 1\n      ans.append(c)\n\n    return ''.join(ans)",
      "title": "2109. Adding Spaces to a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9968de13-bad5-4b14-ae70-cde5384c50eb",
      "code": "class Solution:\n  def getDescentPeriods(self, prices: list[int]) -> int:\n    ans = 1  # prices[0]\n    dp = 1\n\n    for i in range(1, len(prices)):\n      if prices[i] == prices[i - 1] - 1:\n        dp += 1\n      else:\n        dp = 1\n      ans += dp\n\n    return ans",
      "title": "2110. Number of Smooth Descent Periods of a Stock",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9fb6f83-261d-47fc-9e7b-10269dc1c866",
      "code": "class Solution:\n  def kIncreasing(self, arr: list[int], k: int) -> int:\n    def numReplaced(arr: list[int]) -> int:\n      tails = []\n      for a in arr:\n        if not tails or tails[-1] <= a:\n          tails.append(a)\n        else:\n          tails[bisect_right(tails, a)] = a\n      return len(arr) - len(tails)\n\n    return sum(numReplaced(arr[i::k]) for i in range(k))",
      "title": "2111. Minimum Operations to Make the Array K-Increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dfb1191f-8592-47e8-8a61-11e836fe68d3",
      "code": "class Solution:\n  def elementInNums(\n      self,\n      nums: list[int],\n      queries: list[list[int]],\n  ) -> list[int]:\n    n = len(nums)\n\n    def f(time: int, index: int) -> int:\n      if time < n:  # [0, 1, 2] -> [1, 2] -> [2]\n        index += time\n        return -1 if index >= n else nums[index]\n      else:  # [] -> [0] -> [0, 1]\n        return -1 if index >= time - n else nums[index]\n\n    return [f(time % (2 * n), index) for time, index in queries]",
      "title": "2113. Elements in Array After Removing and Replacing Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd01f7b7-4b03-4895-8197-280741e6aee9",
      "code": "class Solution:\n  def mostWordsFound(self, sentences: list[str]) -> int:\n    return max(s.count(' ') for s in sentences) + 1",
      "title": "2114. Maximum Number of Words Found in Sentences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f143badc-cfd3-47f3-a12b-8706bd652fa7",
      "code": "class Solution:\n  def findAllRecipes(\n      self,\n      recipes: list[str],\n      ingredients: list[list[str]],\n      supplies: list[str],\n  ) -> list[str]:\n    ans = []\n    supplies = set(supplies)\n    graph = collections.defaultdict(list)\n    inDegrees = collections.Counter()\n    q = collections.deque()\n\n    # Build the graph.\n    for i, recipe in enumerate(recipes):\n      for ingredient in ingredients[i]:\n        if ingredient not in supplies:\n          graph[ingredient].append(recipe)\n          inDegrees[recipe] += 1\n\n    # Perform topological sorting.\n    for recipe in recipes:\n      if inDegrees[recipe] == 0:\n        q.append(recipe)\n\n    while q:\n      u = q.popleft()\n      ans.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return ans",
      "title": "2115. Find All Possible Recipes from Given Supplies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "32c7bc17-38f5-45ba-97d7-0320c988d701",
      "code": "class Solution:\n  def canBeValid(self, s: str, locked: str) -> bool:\n    if len(s) % 2 == 1:\n      return False\n\n    def check(s: str, locked: str, isForward: bool) -> bool:\n      changeable = 0\n      l = 0\n      r = 0\n\n      for c, lock in zip(s, locked):\n        if lock == '0':\n          changeable += 1\n        elif c == '(':\n          l += 1\n        else:  # c == ')'\n          r += 1\n        if isForward and changeable + l - r < 0:\n          return False\n        if not isForward and changeable + r - l < 0:\n          return False\n\n      return True\n\n    return check(s, locked, True) and check(s[::-1], locked[::-1], False)",
      "title": "2116. Check if a Parentheses String Can Be Valid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "edd94b38-b534-4bf4-84e5-09e46bb40dd2",
      "code": "class Solution:\n  def abbreviateProduct(self, left: int, right: int) -> str:\n    prod = 1.0\n    suf = 1\n    countDigits = 0\n    countZeros = 0\n\n    for num in range(left, right + 1):\n      prod *= num\n      while prod >= 1.0:\n        prod /= 10\n        countDigits += 1\n      suf *= num\n      while suf % 10 == 0:\n        suf //= 10\n        countZeros += 1\n      if suf > 10**8:\n        suf %= 10**8\n\n    if countDigits - countZeros <= 10:\n      tens = 10**(countDigits - countZeros)\n      return str(int(prod * tens + 0.5)) + 'e' + str(countZeros)\n\n    pre = str(int(prod * 10 ** 5))\n    suf = str(suf)[-5:]\n    return pre + '...' + suf + 'e' + str(countZeros)",
      "title": "2117. Abbreviating the Product of a Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be77c35c-bafa-485e-9aea-4a5f5d35d136",
      "code": "class Solution:\n  def isSameAfterReversals(self, num: int) -> bool:\n    def getReversed(num: int) -> int:\n      reversed = 0\n      while num > 0:\n        reversed = reversed * 10 + num % 10\n        num //= 10\n      return reversed\n\n    reversed1 = getReversed(num)\n    reversed2 = getReversed(reversed1)\n    return reversed2 == num",
      "title": "2119. A Number After a Double Reversal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f6c6c9f4-5199-4bf1-a7d8-2ead7b58c5a7",
      "code": "class Solution:\n  def executeInstructions(\n      self,\n      n: int,\n      startPos: list[int],\n      s: str,\n  ) -> list[int]:\n    moves = {'L': (0, -1), 'R': (0, 1), 'U': (-1, 0), 'D': (1, 0)}\n    m = len(s)\n    uMost = startPos[0] + 1\n    dMost = n - startPos[0]\n    lMost = startPos[1] + 1\n    rMost = n - startPos[1]\n\n    ans = [0] * m\n    reach = {(0, None): m, (None, 0): m}\n    x = 0\n    y = 0\n\n    for i in reversed(range(m)):\n      dx, dy = moves[s[i]]\n      x -= dx\n      y -= dy\n      reach[(x, None)] = i\n      reach[(None, y)] = i\n      out = min(reach.get((x - uMost, None), math.inf),\n                reach.get((x + dMost, None), math.inf),\n                reach.get((None, y - lMost), math.inf),\n                reach.get((None, y + rMost), math.inf))\n      ans[i] = m - i if out == math.inf else out - i - 1\n\n    return ans",
      "title": "2120. Execution of All Suffix Instructions Staying in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2c156ea8-3a1c-4aff-b932-7d2ad785fb8b",
      "code": "class Solution:\n  def getDistances(self, arr: list[int]) -> list[int]:\n    prefix = [0] * len(arr)\n    suffix = [0] * len(arr)\n    numToIndices = collections.defaultdict(list)\n\n    for i, a in enumerate(arr):\n      numToIndices[a].append(i)\n\n    for indices in numToIndices.values():\n      for i in range(1, len(indices)):\n        currIndex = indices[i]\n        prevIndex = indices[i - 1]\n        prefix[currIndex] += prefix[prevIndex] + i * (currIndex - prevIndex)\n      for i in range(len(indices) - 2, -1, -1):\n        currIndex = indices[i]\n        prevIndex = indices[i + 1]\n        suffix[currIndex] += (suffix[prevIndex] +\n                              (len(indices) - i - 1) * (prevIndex - currIndex))\n\n    return [p + s for p, s in zip(prefix, suffix)]",
      "title": "2121. Intervals Between Identical Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "37a5383a-9d43-40cd-a036-9bec061bb990",
      "code": "class Solution:\n  def recoverArray(self, nums: list[int]) -> list[int]:\n    nums = sorted(nums)\n\n    def getArray(x: int, count: collections.Counter) -> list[int]:\n      arr = []\n      for num in nums:\n        if count[num] == 0:\n          continue\n        if count[num + x] == 0:\n          return []\n        count[num] -= 1\n        count[num + x] -= 1\n        arr.append(num + x // 2)\n      return arr\n\n    count = collections.Counter(nums)\n\n    for i in range(1, len(nums)):\n      x = nums[i] - nums[0]  # 2 * k\n      if x <= 0 or x % 2 == 1:\n        continue\n      arr = getArray(x, count.copy())\n      if arr:\n        return arr",
      "title": "2122. Recover the Original Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b765ce09-0aa4-4484-910a-21d2b1a80fe4",
      "code": "class Solution:\n  def minimumOperations(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    seen = [[0] * n for _ in range(m)]\n    match = [[-1] * n for _ in range(m)]\n\n    def dfs(i: int, j: int, sessionId: int) -> int:\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] == 0 or seen[x][y] == sessionId:\n          continue\n        seen[x][y] = sessionId\n        if match[x][y] == -1 or dfs(*divmod(match[x][y], n), sessionId):\n          match[x][y] = i * n + j\n          match[i][j] = x * n + y\n          return 1\n      return 0\n\n    ans = 0\n\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j] == 1 and match[i][j] == -1:\n          sessionId = i * n + j\n          seen[i][j] = sessionId\n          ans += dfs(i, j, sessionId)\n\n    return ans",
      "title": "2123. Minimum Operations to Remove Adjacent Ones in Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a967f37-fc49-4379-ae85-bc75331e5abf",
      "code": "class Solution:\n  def checkString(self, s: str) -> bool:\n    return 'ba' not in s",
      "title": "2124. Check if All A's Appears Before All B's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcc1eab5-0871-4e09-9b42-beabc9afeb32",
      "code": "class Solution:\n  def numberOfBeams(self, bank: list[str]) -> int:\n    ans = 0\n    prevOnes = 0\n\n    for row in bank:\n      ones = row.count('1')\n      if ones:\n        ans += prevOnes * ones\n        prevOnes = ones\n\n    return ans",
      "title": "2125. Number of Laser Beams in a Bank",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba662846-6d1d-4571-9db8-e06649ad374c",
      "code": "class Solution:\n  def asteroidsDestroyed(self, mass: int, asteroids: list[int]) -> bool:\n    for asteroid in sorted(asteroids):\n      if mass >= asteroid:\n        mass += asteroid\n      else:\n        return False\n    return True",
      "title": "2126. Destroying Asteroids",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "194c9f96-32d0-4fef-ba95-3619ffce1e21",
      "code": "from enum import Enum\n\n\nclass State(Enum):\n  INIT = 0\n  VISITING = 1\n  VISITED = 2\n\n\nclass Solution:\n  def maximumInvitations(self, favorite: list[int]) -> int:\n    n = len(favorite)\n    sumComponentsLength = 0  # the component: a -> b -> c <-> x <- y\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n    maxChainLength = [1] * n\n\n    # Build the graph.\n    for i, f in enumerate(favorite):\n      graph[i].append(f)\n      inDegrees[f] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      u = q.popleft()\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n        maxChainLength[v] = max(maxChainLength[v], 1 + maxChainLength[u])\n\n    for i in range(n):\n      if favorite[favorite[i]] == i:\n        # i <-> favorite[i] (the cycle's length = 2)\n        sumComponentsLength += maxChainLength[i] + maxChainLength[favorite[i]]\n\n    maxCycleLength = 0  # Cycle: a -> b -> c -> a\n    parent = [-1] * n\n    seen = set()\n    states = [State.INIT] * n\n\n    def findCycle(u: int) -> None:\n      nonlocal maxCycleLength\n      seen.add(u)\n      states[u] = State.VISITING\n      for v in graph[u]:\n        if v not in seen:\n          parent[v] = u\n          findCycle(v)\n        elif states[v] == State.VISITING:\n          # Find the cycle's length.\n          curr = u\n          cycleLength = 1\n          while curr != v:\n            curr = parent[curr]\n            cycleLength += 1\n          maxCycleLength = max(maxCycleLength, cycleLength)\n      states[u] = State.VISITED\n\n    for i in range(n):\n      if i not in seen:\n        findCycle(i)\n\n    return max(sumComponentsLength // 2, maxCycleLength)",
      "title": "2127. Maximum Employees to Be Invited to a Meeting",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "183c0966-6b23-4c57-839a-564387210358",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> bool:\n    revRow = [a ^ 1 for a in grid[0]]\n    return all(row == grid[0] or row == revRow for row in grid)",
      "title": "2128. Remove All Ones With Row and Column Flips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e66eb24-8985-403e-bf7e-9fabab9fcb71",
      "code": "class Solution:\n  def capitalizeTitle(self, title: str) -> str:\n    return ' '.join(s.lower() if len(s) < 3\n                    else s.capitalize() for s in title.split())",
      "title": "2129. Capitalize the Title",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d595d790-7a81-452d-b76b-1b85419b3a4d",
      "code": "class Solution:\n  def pairSum(self, head: ListNode | None) -> int:\n    def reverseList(head: ListNode) -> ListNode:\n      prev = None\n      while head:\n        next = head.next\n        head.next = prev\n        prev = head\n        head = next\n      return prev\n\n    ans = 0\n    slow = head\n    fast = head\n\n    # `slow` points to the start of the second half.\n    while fast and fast.next:\n      slow = slow.next\n      fast = fast.next.next\n\n    # `tail` points to the end of the reversed second half.\n    tail = reverseList(slow)\n\n    while tail:\n      ans = max(ans, head.val + tail.val)\n      head = head.next\n      tail = tail.next\n\n    return ans",
      "title": "2130. Maximum Twin Sum of a Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2a001820-a093-4206-87a9-3a91e5da9b51",
      "code": "class Solution:\n  def longestPalindrome(self, words: list[str]) -> int:\n    ans = 0\n    count = [[0] * 26 for _ in range(26)]\n\n    for a, b in words:\n      i = ord(a) - ord('a')\n      j = ord(b) - ord('a')\n      if count[j][i]:\n        ans += 4\n        count[j][i] -= 1\n      else:\n        count[i][j] += 1\n\n    for i in range(26):\n      if count[i][i]:\n        return ans + 2\n\n    return ans",
      "title": "2131. Longest Palindrome by Concatenating Two Letter Words",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "96e2cde1-5ebd-4f82-8f36-f6adbc00d27c",
      "code": "class Solution:\n  def possibleToStamp(\n      self,\n      grid: list[list[int]],\n      stampHeight: int,\n      stampWidth: int,\n  ) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    # A[i][j] := the number of 1s in grid[0..i)[0..j)\n    A = [[0] * (n + 1) for _ in range(m + 1)]\n    # B[i][j] := the number of ways to stamp the submatrix in [0..i)[0..j)\n    B = [[0] * (n + 1) for _ in range(m + 1)]\n    # fit[i][j] := true if the stamps can fit with the right-bottom at (i, j)\n    fit = [[False] * n for _ in range(m)]\n\n    for i in range(m):\n      for j in range(n):\n        A[i + 1][j + 1] = A[i + 1][j] + A[i][j + 1] - A[i][j] + grid[i][j]\n        if i + 1 >= stampHeight and j + 1 >= stampWidth:\n          x = i - stampHeight + 1\n          y = j - stampWidth + 1\n          if A[i + 1][j + 1] - A[x][j + 1] - A[i + 1][y] + A[x][y] == 0:\n            fit[i][j] = True\n\n    for i in range(m):\n      for j in range(n):\n        B[i + 1][j + 1] = B[i + 1][j] + B[i][j + 1] - B[i][j] + fit[i][j]\n\n    for i in range(m):\n      for j in range(n):\n        if not grid[i][j]:\n          x = min(i + stampHeight, m)\n          y = min(j + stampWidth, n)\n          if B[x][y] - B[i][y] - B[x][j] + B[i][j] == 0:\n            return False\n\n    return True",
      "title": "2132. Stamping the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f636b0a2-764f-47e9-97af-3dca9604f020",
      "code": "class Solution:\n  def checkValid(self, matrix: list[list[int]]) -> bool:\n    return all(min(len(set(row)), len(set(col))) == len(matrix)\n               for row, col in zip(matrix, zip(*matrix)))",
      "title": "2133. Check if Every Row and Column Contains All Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "07158e96-0e24-483d-893d-c348179c3201",
      "code": "class Solution:\n  def minSwaps(self, nums: list[int]) -> int:\n    n = len(nums)\n    k = nums.count(1)\n    ones = 0  # the number of ones in the window\n    maxOnes = 0  # the maximum number of ones in the window\n\n    for i in range(n * 2):\n      if i >= k and nums[i % n - k]:  # Magic in Python :)\n        ones -= 1\n      if nums[i % n]:\n        ones += 1\n      maxOnes = max(maxOnes, ones)\n\n    return k - maxOnes",
      "title": "2134. Minimum Swaps to Group All 1's Together II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "70d8c56e-ce9a-47cc-8f2b-15e2ecb3d284",
      "code": "class Solution:\n  def wordCount(self, startWords: list[str], targetWords: list[str]) -> int:\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask ^= 1 << ord(c) - ord('a')\n      return mask\n\n    ans = 0\n    seen = set(getMask(w) for w in startWords)\n\n    for targetWord in targetWords:\n      mask = getMask(targetWord)\n      for c in targetWord:\n        # Toggle one character.\n        if mask ^ 1 << ord(c) - ord('a') in seen:\n          ans += 1\n          break\n\n    return ans",
      "title": "2135. Count Words Obtained After Adding a Letter",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8579113f-9627-49fb-b2f0-423d5ea67a47",
      "code": "class Solution:\n  def earliestFullBloom(self, plantTime: list[int], growTime: list[int]) -> int:\n    ans = 0\n    time = 0\n\n    for p, g in sorted(\n        [(p, g) for (p, g) in zip(plantTime, growTime)],\n            key=lambda x: -x[1]):\n      time += p\n      ans = max(ans, time + g)\n\n    return ans",
      "title": "2136. Earliest Possible Day of Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abfc8495-d309-4010-b569-c7aad595e343",
      "code": "class Solution:\n  def equalizeWater(self, buckets: list[int], loss: int) -> float:\n    ERR = 1e-5\n    PERCENTAGE = (100 - loss) / 100\n    l = 0.0\n    r = max(buckets)\n\n    def canFill(target: float) -> bool:\n      extra = 0\n      need = 0\n      for bucket in buckets:\n        if bucket > target:\n          extra += bucket - target\n        else:\n          need += target - bucket\n      return extra * PERCENTAGE >= need\n\n    while r - l > ERR:\n      m = (l + r) / 2\n      if canFill(m):\n        l = m\n      else:\n        r = m\n\n    return l",
      "title": "2137. Pour Water Between Buckets to Make Water Levels Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5a049ce-d04b-438b-a0c2-1e2efae67d1c",
      "code": "class Solution:\n  def divideString(self, s: str, k: int, fill: str) -> list[str]:\n    return [\n        s[i:] + fill * (i + k - len(s)) if i + k > len(s)\n        else s[i:i + k]\n        for i in range(0, len(s), k)\n    ]",
      "title": "2138. Divide a String Into Groups of Size k",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f20047f5-1059-4d88-80c3-f67e00420bec",
      "code": "class Solution:\n  def minMoves(self, target: int, maxDoubles: int) -> int:\n    steps = 0\n\n    while target > 1 and maxDoubles:\n      if target % 2 == 1:\n        target -= 1\n      else:\n        target //= 2\n        maxDoubles -= 1\n      steps += 1\n\n    return steps + target - 1",
      "title": "2139. Minimum Moves to Reach Target Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6716678-c434-42df-bd74-808e711c2ba6",
      "code": "class Solution:\n  def mostPoints(self, questions: list[list[int]]) -> int:\n    n = len(questions)\n    # dp[i] := the maximum points starting from questions[i]\n    dp = [0] * (n + 1)\n\n    for i in reversed(range(n)):\n      points, brainpower = questions[i]\n      nextIndex = i + brainpower + 1\n      nextPoints = dp[nextIndex] if nextIndex < n else 0\n      dp[i] = max(points + nextPoints, dp[i + 1])\n\n    return dp[0]",
      "title": "2140. Solving Questions With Brainpower",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "136887b4-b105-4ea1-b4e5-aa5b7fbd9b1f",
      "code": "class Solution:\n  def maxRunTime(self, n: int, batteries: list[int]) -> int:\n    summ = sum(batteries)\n\n    batteries.sort()\n\n    # The maximum battery is greater than the average, so it can last forever.\n    # Reduce the problem from size n to size n - 1.\n    while batteries[-1] > summ // n:\n      summ -= batteries.pop()\n      n -= 1\n\n    # If the maximum battery <= average running time, it won't be waste, and so\n    # do smaller batteries.\n    return summ // n",
      "title": "2141. Maximum Running Time of N Computers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e528e4c8-a3b5-4d82-a004-a753b72822e0",
      "code": "class Solution:\n  def countSubranges(self, nums1: list[int], nums2: list[int]) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # {sum, count}, add if choose from nums1, minus if choose from nums2\n    dp = collections.Counter()\n\n    for a, b in zip(nums1, nums2):\n      newDp = collections.Counter()\n      newDp[a] += 1\n      newDp[-b] += 1\n\n      for prevSum, count in dp.items():\n        # Choose nums1[i]\n        newDp[prevSum + a] += count\n        newDp[prevSum + a] %= MOD\n        # Choose nums2[i]\n        newDp[prevSum - b] += count\n        newDp[prevSum - b] %= MOD\n\n      dp = newDp\n      ans += dp[0]\n      ans %= MOD\n\n    return ans",
      "title": "2143. Choose Numbers From Two Arrays in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "55691692-2851-496a-8e0a-7826fa452888",
      "code": "class Solution:\n  def minimumCost(self, cost: list[int]) -> int:\n    return sum(cost) - sum(sorted(cost)[-3::-3])",
      "title": "2144. Minimum Cost of Buying Candies With Discount",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09bb5ef9-9a80-45c1-8bd5-55fe341a8ec6",
      "code": "class Solution:\n  def numberOfArrays(\n      self,\n      differences: list[int],\n      lower: int,\n      upper: int,\n  ) -> int:\n    prefix = 0\n    mn = 0  # Starts from 0.\n    mx = 0  # Starts from 0.\n\n    for d in differences:\n      prefix += d\n      mn = min(mn, prefix)\n      mx = max(mx, prefix)\n\n    return max(0, (upper - lower) - (mx - mn) + 1)",
      "title": "2145. Count the Hidden Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c062ad5-58e2-47ef-9e7c-aaccd609cf59",
      "code": "class Solution:\n  def highestRankedKItems(\n      self,\n      grid: list[list[int]],\n      pricing: list[int],\n      start: list[int],\n      k: int\n  ) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    low, high = pricing\n    row, col = start\n    ans = []\n\n    if low <= grid[row][col] <= high:\n      ans.append([row, col])\n      if k == 1:\n        return ans\n\n    q = collections.deque([(row, col)])\n    seen = {(row, col)}  # Mark as visited.\n\n    while q:\n      neighbors = []\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for t in range(4):\n          x = i + DIRS[t][0]\n          y = j + DIRS[t][1]\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if not grid[x][y] or (x, y) in seen:\n            continue\n          if low <= grid[x][y] <= high:\n            neighbors.append([x, y])\n          q.append((x, y))\n          seen.add((x, y))\n      neighbors.sort(key=lambda x: (grid[x[0]][x[1]], x[0], x[1]))\n      for neighbor in neighbors:\n        if len(ans) < k:\n          ans.append(neighbor)\n        if len(ans) == k:\n          return ans\n\n    return ans",
      "title": "2146. K Highest Ranked Items Within a Price Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1152d157-3456-4666-813e-2e1090aafed8",
      "code": "class Solution:\n  def numberOfWays(self, corridor: str) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    prevSeat = -1\n    numSeats = 0\n\n    for i, c in enumerate(corridor):\n      if c == 'S':\n        numSeats += 1\n        if numSeats > 2 and numSeats % 2 == 1:\n          ans = ans * (i - prevSeat) % MOD\n        prevSeat = i\n\n    return ans if numSeats > 1 and numSeats % 2 == 0 else 0",
      "title": "2147. Number of Ways to Divide a Long Corridor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1a17c313-a87b-4c83-8261-e3d89ad8b8d8",
      "code": "class Solution:\n  def countElements(self, nums: list[int]) -> int:\n    mn = min(nums)\n    mx = max(nums)\n    return sum(mn < num < mx for num in nums)",
      "title": "2148. Count Elements With Strictly Smaller and Greater Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d42956a-cbf1-46fb-bf16-8766d27abae9",
      "code": "class Solution:\n  def rearrangeArray(self, nums: list[int]) -> list[int]:\n    ans = []\n    pos = []\n    neg = []\n\n    for num in nums:\n      (pos if num > 0 else neg).append(num)\n\n    for p, n in zip(pos, neg):\n      ans += [p, n]\n\n    return ans",
      "title": "2149. Rearrange Array Elements by Sign",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81c0e5b0-d2be-4e41-bba2-512bc947ab3f",
      "code": "class Solution:\n  def findLonely(self, nums: list[int]) -> list[int]:\n    count = collections.Counter(nums)\n    return [num for num, freq in count.items()\n            if freq == 1 and\n            count[num - 1] == 0 and\n            count[num + 1] == 0]",
      "title": "2150. Find All Lonely Numbers in the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f810be65-8d57-4ebb-8504-3f4cf8072de8",
      "code": "class Solution:\n  def maximumGood(self, statements: list[list[int]]) -> int:\n    n = len(statements)\n    ans = 0\n\n    def isValid(good: list[int]) -> bool:\n      for i, g in enumerate(good):\n        if not g:  # The i-th person is bad, so no need to check.\n          continue\n        for j in range(n):\n          if statements[i][j] == 2:\n            continue\n          if statements[i][j] != good[j]:\n            return False\n      return True\n\n    def dfs(good: list[int], i: int, count: int) -> None:\n      nonlocal ans\n      if i == n:\n        if isValid(good):\n          ans = max(ans, count)\n        return\n\n      good.append(0)  # Assume the i-th person is bad.\n      dfs(good, i + 1, count)\n      good[-1] = 1  # Assume the i-th person is good.\n      dfs(good, i + 1, count + 1)\n      good.pop()\n\n    dfs([], 0, 0)\n    return ans",
      "title": "2151. Maximum Good People Based on Statements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdc740b5-5f02-4041-8e38-3cc59e468c07",
      "code": "class Solution:\n  def minimumLines(self, points: list[list[int]]) -> int:\n    n = len(points)\n    allCovered = (1 << n) - 1\n    maxLines = n // 2 + (n & 1)\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      x = dx // d\n      y = dy // d\n      return (x, y) if x > 0 else (-x, -y)\n\n    @functools.lru_cache(None)\n    def dfs(covered: int) -> int:\n      if covered == allCovered:\n        return 0\n\n      ans = maxLines\n\n      for i in range(n):\n        if covered >> i & 1:\n          continue\n        for j in range(n):\n          if i == j:\n            continue\n          # Connect the points[i] with the points[j].\n          newCovered = covered | 1 << i | 1 << j\n          slope = getSlope(points[i], points[j])\n          # Mark the points covered by this line.\n          for k in range(n):\n            if getSlope(points[i], points[k]) == slope:\n              newCovered |= 1 << k\n          ans = min(ans, 1 + dfs(newCovered))\n\n      return ans\n\n    return dfs(0)",
      "title": "2152. Minimum Number of Lines to Cover Points",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d27d0baa-a9df-4cf2-8d00-e3ea5f8f7c08",
      "code": "class Solution:\n  def findFinalValue(self, nums: list[int], original: int) -> int:\n    seen = [False] * 1001\n\n    for num in nums:\n      seen[num] = True\n\n    while original < 1001 and seen[original]:\n      original *= 2\n\n    return original",
      "title": "2154. Keep Multiplying Found Values by Two",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b393d597-6963-4a5c-b4d2-7b63068e1582",
      "code": "class Solution:\n  def maxScoreIndices(self, nums: list[int]) -> list[int]:\n    zeros = nums.count(0)\n    ones = len(nums) - zeros\n    ans = [0]  # the division at index 0\n    leftZeros = 0\n    leftOnes = 0\n    maxScore = ones  # `leftZeros` + `rightOnes`\n\n    for i, num in enumerate(nums):\n      leftZeros += num == 0\n      leftOnes += num == 1\n      rightOnes = ones - leftOnes\n      score = leftZeros + rightOnes\n      if maxScore == score:\n        ans.append(i + 1)\n      elif maxScore < score:\n        maxScore = score\n        ans = [i + 1]\n\n    return ans",
      "title": "2155. All Divisions With the Highest Score of a Binary Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1977a0f-c754-4870-b658-7cef281d7b9e",
      "code": "class Solution:\n  def subStrHash(\n      self,\n      s: str,\n      power: int,\n      modulo: int,\n      k: int,\n      hashValue: int,\n  ) -> str:\n    maxPower = pow(power, k, modulo)\n    hash = 0\n\n    def val(c: str) -> int:\n      return ord(c) - ord('a') + 1\n\n    for i, c in reversed(list(enumerate(s))):\n      hash = (hash * power + val(c)) % modulo\n      if i + k < len(s):\n        hash = (hash - val(s[i + k]) * maxPower) % modulo\n      if hash == hashValue:\n        bestLeft = i\n\n    return s[bestLeft:bestLeft + k]",
      "title": "2156. Find Substring With Given Hash Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d541083-e83c-4343-8fb8-06aac7083d0a",
      "code": "class UnionFind:\n  def __init__(self, n: int):\n    self.count = n\n    self.id = list(range(n))\n    self.sz = [1] * n\n\n  def unionBySize(self, u: int, v: int) -> None:\n    i = self._find(u)\n    j = self._find(v)\n    if i == j:\n      return\n    if self.sz[i] < self.sz[j]:\n      self.sz[j] += self.sz[i]\n      self.id[i] = j\n    else:\n      self.sz[i] += self.sz[j]\n      self.id[j] = i\n    self.count -= 1\n\n  def _find(self, u: int) -> int:\n    if self.id[u] != u:\n      self.id[u] = self._find(self.id[u])\n    return self.id[u]\n\n\nclass Solution:\n  def groupStrings(self, words: list[str]) -> list[int]:\n    uf = UnionFind(len(words))\n\n    def getMask(s: str) -> int:\n      mask = 0\n      for c in s:\n        mask |= 1 << ord(c) - ord('a')\n      return mask\n\n    def getAddedMasks(mask: int):\n      for i in range(26):\n        if not (mask >> i & 1):\n          yield mask | 1 << i\n\n    def getDeletedMasks(mask: int):\n      for i in range(26):\n        if mask >> i & 1:\n          yield mask ^ 1 << i\n\n    maskToIndex = {getMask(word): i for i, word in enumerate(words)}\n    deletedMaskToIndex = {}\n\n    for i, word in enumerate(words):\n      mask = getMask(word)\n      for m in getAddedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n      for m in getDeletedMasks(mask):\n        if m in maskToIndex:\n          uf.unionBySize(i, maskToIndex[m])\n        if m in deletedMaskToIndex:\n          uf.unionBySize(i, deletedMaskToIndex[m])\n        else:\n          deletedMaskToIndex[m] = i\n\n    return [uf.count, max(uf.sz)]",
      "title": "2157. Groups of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e36a818-cfc8-43da-957a-14cb2dcfebda",
      "code": "from sortedcontainers import SortedList\n\n\nclass Solution:\n  def amountPainted(self, paint: list[list[int]]) -> list[int]:\n    minDay = min(s for s, e in paint)\n    maxDay = max(e for s, e in paint)\n    ans = [0] * len(paint)\n    # Stores the indices of paints that are available now.\n    runningIndices = SortedList()\n    events = []  # (day, index, type)\n\n    for i, (start, end) in enumerate(paint):\n      events.append((start, i, 1))  # 1 := entering\n      events.append((end, i, -1))  # -1 := leaving\n\n    events.sort()\n\n    i = 0  # events' index\n    for day in range(minDay, maxDay):\n      while i < len(events) and events[i][0] == day:\n        day, index, type = events[i]\n        if type == 1:\n          runningIndices.add(index)\n        else:\n          runningIndices.remove(index)\n        i += 1\n      if runningIndices:\n        ans[runningIndices[0]] += 1\n\n    return ans",
      "title": "2158. Amount of New Area Painted Each Day",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdf91030-5459-4660-9d4e-61a2fe1c2458",
      "code": "class Solution:\n  def minimumSum(self, num: int) -> int:\n    s = sorted(str(num))\n    return int(s[0] + s[2]) + int(s[1] + s[3])",
      "title": "2160. Minimum Sum of Four Digit Number After Splitting Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dc6dfefc-cc9f-4aa1-9910-546b1f2c5d56",
      "code": "class Solution:\n  def pivotArray(self, nums: list[int], pivot: int) -> list[int]:\n    return ([num for num in nums if num < pivot] +\n            [num for num in nums if num == pivot] +\n            [num for num in nums if num > pivot])",
      "title": "2161. Partition Array According to Given Pivot",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54882713-9c71-4d12-9cef-51c7c74ce822",
      "code": "class Solution:\n  def minCostSetTime(\n      self,\n      startAt: int,\n      moveCost: int,\n      pushCost: int,\n      targetSeconds: int,\n  ) -> int:\n    ans = math.inf\n    mins = 99 if targetSeconds > 5999 else targetSeconds // 60\n    secs = targetSeconds - mins * 60\n\n    def getCost(mins: int, secs: int) -> int:\n      cost = 0\n      curr = str(startAt)\n      for c in str(mins * 100 + secs):\n        if c == curr:\n          cost += pushCost\n        else:\n          cost += moveCost + pushCost\n          curr = c\n      return cost\n\n    while secs < 100:\n      ans = min(ans, getCost(mins, secs))\n      mins -= 1\n      secs += 60\n\n    return ans",
      "title": "2162. Minimum Cost to Set Cooking Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb796711-430a-4d6b-b93d-874d476b45ea",
      "code": "class Solution:\n  def minimumDifference(self, nums: list[int]) -> int:\n    n = len(nums) // 3\n    ans = math.inf\n    leftSum = 0\n    rightSum = 0\n    maxHeap = []  # Left part, as small as possible\n    minHeap = []  # Right part, as big as possible\n    # minLeftSum[i] := the minimum of the sum of n nums in nums[0..i)\n    minLeftSum = [0] * len(nums)\n\n    for i in range(2 * n):\n      heapq.heappush(maxHeap, -nums[i])\n      leftSum += nums[i]\n      if len(maxHeap) == n + 1:\n        leftSum += heapq.heappop(maxHeap)\n      if len(maxHeap) == n:\n        minLeftSum[i] = leftSum\n\n    for i in range(len(nums) - 1, n - 1, -1):\n      heapq.heappush(minHeap, nums[i])\n      rightSum += nums[i]\n      if len(minHeap) == n + 1:\n        rightSum -= heapq.heappop(minHeap)\n      if len(minHeap) == n:\n        ans = min(ans, minLeftSum[i - 1] - rightSum)\n\n    return ans",
      "title": "2163. Minimum Difference in Sums After Removal of Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8e3e2dcf-a71e-42ef-b402-16001577c11c",
      "code": "class Solution:\n  def sortEvenOdd(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n    evenCount = collections.Counter(nums[::2])\n    oddCount = collections.Counter(nums[1::2])\n\n    ansIndex = 0\n    for i in range(1, 101):\n      while evenCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        evenCount[i] -= 1\n\n    ansIndex = 1\n    for i in range(100, 0, -1):\n      while oddCount[i] > 0:\n        ans[ansIndex] = i\n        ansIndex += 2\n        oddCount[i] -= 1\n\n    return ans",
      "title": "2164. Sort Even and Odd Indices Independently",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f563303b-cf39-4e53-9734-b2475c35f514",
      "code": "class Solution:\n  def smallestNumber(self, num: int) -> int:\n    s = sorted(str(abs(num)), reverse=num < 0)\n    firstNonZeroIndex = next((i for i, c in enumerate(s) if c != '0'), 0)\n    s[0], s[firstNonZeroIndex] = s[firstNonZeroIndex], s[0]\n    return int(''.join(s)) * (-1 if num < 0 else 1)",
      "title": "2165. Smallest Value of the Rearranged Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "108ec8e0-85f8-4a3c-8ff8-2b1a19213cff",
      "code": "class Solution:\n  def minimumTime(self, s: str) -> int:\n    n = len(s)\n    # left[i] := the minimum time to remove the illegal cars of s[0..i]\n    left = [0] * n\n    left[0] = int(s[0])\n    # dp[i] := the minimum time to remove the illegal cars of s[0..i] optimally\n    # + the time to remove the illegal cars of s[i + 1..n) consecutively\n    # Note that the way to remove the illegal cars in the right part\n    # doesn't need to be optimal since:\n    #   `left | illegal cars | n - 1 - k` will be covered in\n    #   `left' | n - 1 - i` later.\n    dp = [n] * n\n    dp[0] = left[0] + n - 1\n\n    for i in range(1, n):\n      left[i] = min(left[i - 1] + int(s[i]) * 2, i + 1)\n      dp[i] = min(dp[i], left[i] + n - 1 - i)\n\n    return min(dp)",
      "title": "2167. Minimum Time to Remove All Cars Containing Illegal Goods",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd6d41d9-b0a2-4386-bf71-47252e561d1d",
      "code": "class Solution:\n  def equalDigitFrequency(self, s: str) -> int:\n    BASE = 11\n    HASH = 1_000_000_007\n    counts: list[dict] = []  # counts[i] := the counter map of s[0..i]\n    count = collections.Counter()\n    pows = [1]  # pows[i] := BASE^i % HASH\n    # hash[i] = the hash of the first i letters of s, where hash[i] =\n    # (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % HASH\n    hash = [0]\n\n    def val(c: str) -> int:\n      return int(c) + 1\n\n    for c in s:\n      count[c] += 1\n      counts.append(count.copy())\n      pows.append(pows[-1] * BASE % HASH)\n      hash.append((hash[-1] * BASE + val(c)) % HASH)\n\n    def getRollingHash(l: int, r: int) -> int:\n      \"\"\"Returns the rolling hash of s[l..r).\"\"\"\n      h = (hash[r] - hash[l] * pows[r - l]) % HASH\n      return h + HASH if h < 0 else h\n\n    return len({getRollingHash(i, j + 1)\n                for i in range(len(s))\n                for j in range(i, len(s))\n                if self._isSameFreq(counts, i, j)})\n\n  def _isSameFreq(self, counts: list[dict], i: int, j: int) -> bool:\n    count = counts[j].copy()\n    if i > 0:\n      for c, freq in counts[i - 1].items():\n        count[c] -= freq\n        if count[c] == 0:\n          del count[c]\n    return min(count.values()) == max(count.values())",
      "title": "2168. Unique Substrings With Equal Digit Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "21246cfc-75fc-4006-bb7d-55d714ac5f3f",
      "code": "class Solution:\n  def countOperations(self, num1: int, num2: int) -> int:\n    ans = 0\n\n    while num1 and num2:\n      if num1 < num2:\n        num1, num2 = num2, num1\n      ans += num1 // num2\n      num1 %= num2\n\n    return ans",
      "title": "2169. Count Operations to Obtain Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0160dda5-b323-4f83-a595-f0b4b1c02c43",
      "code": "class T:\n  def __init__(self):\n    self.count = collections.Counter()\n    self.mx = 0\n    self.secondMax = 0\n    self.maxFreq = 0\n    self.secondMaxFreq = 0\n\n\nclass Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    # 0 := odd indices, 1 := even indices\n    ts = [T() for _ in range(2)]\n\n    for i, num in enumerate(nums):\n      t = ts[i % 2]\n      t.count[num] += 1\n      freq = t.count[num]\n      if freq > t.maxFreq:\n        t.maxFreq = freq\n        t.mx = num\n      elif freq > t.secondMaxFreq:\n        t.secondMaxFreq = freq\n        t.secondMax = num\n\n    if ts[0].mx == ts[1].mx:\n      return len(nums) - max(ts[0].maxFreq + ts[1].secondMaxFreq,\n                             ts[1].maxFreq + ts[0].secondMaxFreq)\n    return len(nums) - (ts[0].maxFreq + ts[1].maxFreq)",
      "title": "2170. Minimum Operations to Make the Array Alternating",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d2d7260b-a2a6-4c39-8e8b-6b15697dbefd",
      "code": "class Solution:\n  def minimumRemoval(self, beans: list[int]) -> int:\n    n = len(beans)\n    summ = sum(beans)\n    return min(summ - (n - i) * bean\n               for i, bean in enumerate(sorted(beans)))",
      "title": "2171. Removing Minimum Number of Magic Beans",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c4edd127-41df-4ab5-85a2-1877c3f6f997",
      "code": "class Solution:\n  def maximumANDSum(self, nums: list[int], numSlots: int) -> int:\n    n = 2 * numSlots\n    nSelected = 1 << n\n    # dp[i] := the maximum value, where i is the bitmask of the selected\n    # numbers\n    dp = [0] * nSelected\n\n    nums += [0] * (n - len(nums))\n\n    for mask in range(1, nSelected):\n      selected = mask.bit_count()\n      slot = (selected + 1) // 2  # (1, 2) -> 1, (3, 4) -> 2\n      for i, num in enumerate(nums):\n        if mask >> i & 1:  # Assign `nums[i]` to the `slot`-th slot.\n          dp[mask] = max(dp[mask], dp[mask ^ 1 << i] + (slot & num))\n\n    return dp[-1]",
      "title": "2172. Maximum AND Sum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f362fd35-88e1-486b-b173-ce9c815872e3",
      "code": "class Solution:\n  def removeOnes(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(mask: int) -> int:\n      \"\"\"\n      Returns the minimum number of operations to remove all 1s from the grid,\n      where `mask` is the bitmask of the state of the grid.\n      \"\"\"\n      if mask == 0:\n        return 0\n      ans = math.inf\n      for i in range(m):\n        for j in range(n):\n          if mask >> i * n + j & 1:  # grid[i][j] == 1\n            newMask = mask\n            for k in range(n):  # Set the cells in the same row with 0.\n              newMask &= ~(1 << i * n + k)\n            for k in range(m):  # Set the cells in the same column with 0.\n              newMask &= ~(1 << k * n + j)\n            ans = min(ans, 1 + dp(newMask))\n      return ans\n\n    return dp(self.encode(grid, m, n))\n\n  def encode(self, grid: list[list[int]], m: int, n: int) -> int:\n    encoded = 0\n    for i in range(m):\n      for j in range(n):\n        if grid[i][j]:\n          encoded |= 1 << i * n + j\n    return encoded",
      "title": "2174. Remove All Ones With Row and Column Flips II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99048726-9ede-4cfe-a9ea-3358fcd88dd0",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    numToIndices = collections.defaultdict(list)\n\n    for i, num in enumerate(nums):\n      numToIndices[num].append(i)\n\n    for indices in numToIndices.values():\n      gcds = collections.Counter()\n      for i in indices:\n        gcd_i = math.gcd(i, k)\n        for gcd_j, count in gcds.items():\n          if gcd_i * gcd_j % k == 0:\n            ans += count\n        gcds[gcd_i] += 1\n\n    return ans",
      "title": "2176. Count Equal and Divisible Pairs in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f92e6cf3-4f1e-42ec-800b-07b7e4e785ce",
      "code": "class Solution:\n  def sumOfThree(self, num: int) -> list[int]:\n    if num % 3:\n      return []\n    x = num // 3\n    return [x - 1, x, x + 1]",
      "title": "2177. Find Three Consecutive Integers That Sum to a Given Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "844201a1-26d8-4508-aaa2-75f6841fd4b7",
      "code": "class Solution:\n  def maximumEvenSplit(self, finalSum: int) -> list[int]:\n    if finalSum % 2 == 1:\n      return []\n\n    ans = []\n    needSum = finalSum\n    even = 2\n\n    while needSum - even >= even + 2:\n      ans.append(even)\n      needSum -= even\n      even += 2\n\n    return ans + [needSum]",
      "title": "2178. Maximum Split of Positive Even Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "85e9a252-d1d7-41c6-b1bb-fe0a19e6fd74",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def goodTriplets(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    numToIndex = {num: i for i, num in enumerate(nums1)}\n    # Remap each number in `nums2` to the according index in `nums1` as `arr`.\n    # So the problem is to find the number of increasing tripets in `arr`.\n    arr = [numToIndex[num] for num in nums2]\n    # leftSmaller[i] := the number of arr[j] < arr[i], where 0 <= j < i\n    leftSmaller = [0] * n\n    # rightLarger[i] := the number of arr[j] > arr[i], where i < j < n\n    rightLarger = [0] * n\n    tree1 = FenwickTree(n)  # Calculates `leftSmaller`.\n    tree2 = FenwickTree(n)  # Calculates `rightLarger`.\n\n    for i, a in enumerate(arr):\n      leftSmaller[i] = tree1.get(a)\n      tree1.add(a + 1, 1)\n\n    for i, a in reversed(list(enumerate(arr))):\n      rightLarger[i] = tree2.get(n) - tree2.get(a)\n      tree2.add(a + 1, 1)\n\n    return sum(a * b for a, b in zip(leftSmaller, rightLarger))",
      "title": "2179. Count Good Triplets in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c808317-3938-4ebe-b964-e30add18b9ca",
      "code": "class Solution:\n  def countEven(self, num: int) -> int:\n    return (num - self._getDigitSum(num) % 2) // 2\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2180. Count Integers With Even Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "175911ae-2dfe-49eb-ad1b-817faceabe32",
      "code": "class Solution:\n  def mergeNodes(self, head: ListNode | None) -> ListNode | None:\n    curr = head.next\n\n    while curr:\n      running = curr\n      summ = 0\n      while running.val > 0:\n        summ += running.val\n        running = running.next\n\n      curr.val = summ\n      curr.next = running.next\n      curr = running.next\n\n    return head.next",
      "title": "2181. Merge Nodes in Between Zeros",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a2953b9-64af-4845-b61c-5c8d16c40433",
      "code": "class Solution:\n  def repeatLimitedString(self, s: str, repeatLimit: int) -> str:\n    ans = ''\n    count = collections.Counter(s)\n\n    while True:\n      addOne = ans and self._shouldAddOne(ans, count)\n      c = self._getLargestChar(ans, count)\n      if c == ' ':\n        break\n      repeats = 1 if addOne else min(count[c], repeatLimit)\n      ans += c * repeats\n      count[c] -= repeats\n\n    return ans\n\n  def _shouldAddOne(self, ans: str, count: collections.Counter) -> bool:\n    for c in reversed(string.ascii_lowercase):\n      if count[c]:\n        return ans[-1] == c\n    return False\n\n  def _getLargestChar(self, ans: str, count: collections.Counter) -> int:\n    for c in reversed(string.ascii_lowercase):\n      if count[c] and (not ans or ans[-1] != c):\n        return c\n    return ' '",
      "title": "2182. Construct String With Repeat Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0d4be0fe-7b35-4bcf-b29a-8f76db1369f3",
      "code": "class Solution:\n  def countPairs(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      gcd_i = math.gcd(num, k)\n      for gcd_j, count in gcds.items():\n        if gcd_i * gcd_j % k == 0:\n          ans += count\n      gcds[gcd_i] += 1\n\n    return ans",
      "title": "2183. Count Array Pairs Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "024bee4e-0482-45d3-b5d6-11dbebbfec94",
      "code": "class Solution:\n  def buildWall(self, height: int, width: int, bricks: list[int]) -> int:\n    MOD = 1_000_000_007\n    # Stores the valid rows in bitmask.\n    rows = []\n    self._buildRows(width, bricks, 0, rows)\n\n    n = len(rows)\n    # dp[i] := the number of ways to build `h` height walls with rows[i] in the bottom\n    dp = [1] * n\n    # graph[i] := the valid neighbors of rows[i]\n    graph = [[] for _ in range(n)]\n\n    for i, a in enumerate(rows):\n      for j, b in enumerate(rows):\n        if not a & b:\n          graph[i].append(j)\n\n    for _ in range(2, height + 1):\n      newDp = [0] * n\n      for i in range(n):\n        for v in graph[i]:\n          newDp[i] += dp[v]\n          newDp[i] %= MOD\n      dp = newDp\n\n    return sum(dp) % MOD\n\n  def _buildRows(\n      self,\n      width: int,\n      bricks: list[int],\n      path: int,\n      rows: list[int],\n  ):\n    for brick in bricks:\n      if brick == width:\n        rows.append(path)\n      elif brick < width:\n        newWidth = width - brick\n        self._buildRows(newWidth, bricks, path | 2 << newWidth, rows)",
      "title": "2184. Number of Ways to Build Sturdy Brick Wall",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a7c7477b-08db-43ab-8a99-806310a9ea0a",
      "code": "class Solution:\n  def prefixCount(self, words: list[str], pref: str) -> int:\n    return sum(word.startswith(pref) for word in words)",
      "title": "2185. Counting Words With a Given Prefix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "09cebcbe-4b00-42ea-bbc0-b6728fe19683",
      "code": "class Solution:\n  def minSteps(self, s: str, t: str) -> int:\n    count = collections.Counter(s)\n    count.subtract(collections.Counter(t))\n    return sum([abs(c) for c in count.values()])",
      "title": "2186. Minimum Number of Steps to Make Two Strings Anagram II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18b830ed-2ef6-4aad-92b8-a866c6c70716",
      "code": "class Solution:\n  def minimumTime(self, time: list[int], totalTrips: int) -> int:\n    l = 1\n    r = min(time) * totalTrips\n\n    while l < r:\n      m = (l + r) // 2\n      if sum(m // t for t in time) >= totalTrips:\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2187. Minimum Time to Complete Trips",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "010e8132-6e24-481b-8f2f-9582785785b3",
      "code": "class Solution:\n  def minimumFinishTime(\n      self,\n      tires: list[list[int]],\n      changeTime: int,\n      numLaps: int,\n  ) -> int:\n    # singleTire[i] := the minimum time to finish i laps without changing tire\n    singleTire = [math.inf] * (numLaps + 1)\n    # dp[i] := the minimum time to finish i laps\n    dp = [math.inf] * (numLaps + 1)\n\n    for i, (f, r) in enumerate(tires):\n      sumSecs = 0\n      rPower = 1\n      for j in range(1, numLaps + 1):\n        # the time to use the same tire for the next lap >=\n        # the time to change a new tire + f\n        if f * rPower >= changeTime + f:\n          break\n        sumSecs += f * rPower\n        rPower *= r\n        singleTire[j] = min(singleTire[j], sumSecs)\n\n    dp[0] = 0\n    for i in range(1, numLaps + 1):\n      for j in range(1, i + 1):\n        dp[i] = min(dp[i], dp[i - j] + changeTime + singleTire[j])\n\n    return dp[numLaps] - changeTime",
      "title": "2188. Minimum Time to Finish the Race",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff286676-3836-4902-8020-e744495369c0",
      "code": "class Solution:\n  def houseOfCards(self, n: int) -> int:\n    # dp[i] := the number of valid result for i cards\n    dp = [1] + [0] * n\n\n    for baseCards in range(2, n + 1, 3):\n      for i in range(n, baseCards - 1, -1):\n        # Use `baseCards` as the base, so we're left with `i - baseCards` cards.\n        dp[i] += dp[i - baseCards]\n\n    return dp[n]",
      "title": "2189. Number of Ways to Build House of Cards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ca4d2c4-50d0-436d-96b2-64c8cd7cc69a",
      "code": "class Solution:\n  def mostFrequent(self, nums: list[int], key: int) -> int:\n    count = collections.Counter()\n\n    for a, b in itertools.pairwise(nums):\n      if a == key:\n        count[b] += 1\n\n    return max(count, key=lambda num: count[num])",
      "title": "2190. Most Frequent Number Following Key In an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a3c8adbd-2046-490b-b3f7-9dd4fc478115",
      "code": "class Solution:\n  def sortJumbled(self, mapping: list[int], nums: list[int]) -> list[int]:\n    def getMapped(num: int) -> int:\n      mapped = []\n      for c in str(num):\n        mapped.append(str(mapping[int(c)]))\n      return int(''.join(mapped))\n    A = [(getMapped(num), i, num) for i, num in enumerate(nums)]\n    return [num for _, i, num in sorted(A)]",
      "title": "2191. Sort the Jumbled Numbers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "12f6df03-f053-4779-8573-7a7edbc658de",
      "code": "class Solution:\n  def getAncestors(self, n: int, edges: list[list[int]]) -> list[list[int]]:\n    ans = [set() for _ in range(n)]\n    graph = [[] for _ in range(n)]\n    inDegrees = [0] * n\n\n    # Build the graph.\n    for u, v in edges:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i, d in enumerate(inDegrees) if d == 0])\n\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          ans[v].add(u)\n          ans[v].update(ans[u])\n          inDegrees[v] -= 1\n          if inDegrees[v] == 0:\n            q.append(v)\n\n    return [sorted(nodes) for nodes in ans]",
      "title": "2192. All Ancestors of a Node in a Directed Acyclic Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1dff62bf-6b9b-4297-a4f0-89ae74472334",
      "code": "class Solution:\n  def minMovesToMakePalindrome(self, s: str) -> int:\n    ans = 0\n    chars = list(s)\n\n    while len(chars) > 1:\n      # Greedily match the last digit.\n      i = chars.index(chars[-1])\n      if i == len(chars) - 1:\n        # s[i] is the middle letter.\n        ans += i // 2\n      else:\n        chars.pop(i)\n        ans += i  # Swap the matched letter to the left.\n      chars.pop()\n\n    return ans",
      "title": "2193. Minimum Number of Moves to Make Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7ca89880-06de-4679-90e5-e060d4df78f9",
      "code": "class Solution:\n  def cellsInRange(self, s: str) -> list[str]:\n    ans = []\n    startCol, startRow, _, endCol, endRow = s\n\n    for j in range(ord(startCol), ord(endCol) + 1):\n      for i in range(int(startRow), int(endRow) + 1):\n        ans.append(chr(j) + str(i))\n\n    return ans",
      "title": "2194. Cells in a Range on an Excel Sheet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60683991-95ba-40f2-a3c3-743428468220",
      "code": "class Solution:\n  def minimalKSum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    nums.append(0)\n    nums.sort()\n\n    for a, b in zip(nums, nums[1:]):\n      if a == b:\n        continue\n      l = a + 1\n      r = min(a + k, b - 1)\n      ans += (l + r) * (r - l + 1) // 2\n      k -= r - l + 1\n      if k == 0:\n        return ans\n\n    if k > 0:\n      l = nums[-1] + 1\n      r = nums[-1] + k\n      ans += (l + r) * (r - l + 1) // 2\n\n    return ans",
      "title": "2195. Append K Integers With Minimal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a95a7151-a28e-4a27-8078-840c3a22e08f",
      "code": "class Solution:\n  def createBinaryTree(self, descriptions: list[list[int]]) -> TreeNode | None:\n    children = set()\n    valToNode = {}\n\n    for p, c, isLeft in descriptions:\n      parent = valToNode.setdefault(p, TreeNode(p))\n      child = valToNode.setdefault(c, TreeNode(c))\n      if isLeft:\n        parent.left = child\n      else:\n        parent.right = child\n      children.add(c)\n\n    root = (set(valToNode) - set(children)).pop()\n    return valToNode[root]",
      "title": "2196. Create Binary Tree From Descriptions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6793d7d9-4dca-42db-bf6b-3c317fcdb910",
      "code": "class Solution:\n  def replaceNonCoprimes(self, nums: list[int]) -> list[int]:\n    ans = []\n\n    for num in nums:\n      while ans and math.gcd(ans[-1], num) > 1:\n        num = math.lcm(ans.pop(), num)\n      ans.append(num)\n\n    return ans",
      "title": "2197. Replace Non-Coprime Numbers in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb346713-c1b0-48e2-8b92-a31c749d2ab8",
      "code": "class Solution:\n  def singleDivisorTriplet(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter(nums)\n\n    def divisible(summ: int, num: int) -> int:\n      return summ % num == 0\n\n    for a in range(1, 101):\n      if count[a] == 0:\n        continue\n      for b in range(a, 101):\n        if count[b] == 0:\n          continue\n        for c in range(b, 101):\n          if count[c] == 0:\n            continue\n          summ = a + b + c\n          if divisible(summ, a) + divisible(summ, b) + divisible(summ, c) != 1:\n            continue\n          if a == b:\n            ans += count[a] * (count[a] - 1) // 2 * count[c]\n          elif b == c:\n            ans += count[b] * (count[b] - 1) // 2 * count[a]\n          else:\n            ans += count[a] * count[b] * count[c]\n\n    return ans * 6",
      "title": "2198. Number of Single Divisor Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcd41df6-b5b4-433e-9664-cb8259f5794c",
      "code": "class Solution:\n  def findKDistantIndices(self, nums: list[int], key: int, k: int) -> list[int]:\n    n = len(nums)\n    ans = []\n\n    j = 0\n    for i in range(n):\n      # the first index j s.t. nums[j] == key and j >= i - k\n      while j < n and (nums[j] != key or j < i - k):\n        j += 1\n      if j == n:\n        break\n      if abs(i - j) <= k:\n        ans.append(i)\n\n    return ans",
      "title": "2200. Find All K-Distant Indices in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "26913527-adcb-400b-a85b-e97a2e64e07b",
      "code": "class Solution:\n  def digArtifacts(\n      self,\n      n: int,\n      artifacts: list[list[int]],\n      dig: list[list[int]],\n  ) -> int:\n    digged = set((r, c) for r, c in dig)\n\n    def canExtract(a: list[int]) -> bool:\n      for i in range(a[0], a[2] + 1):\n        for j in range(a[1], a[3] + 1):\n          if (i, j) not in digged:\n            return False\n      return True\n\n    return sum(canExtract(a) for a in artifacts)",
      "title": "2201. Count Artifacts That Can Be Extracted",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6fe10f67-521b-4831-95de-272ff8c2b874",
      "code": "class Solution:\n  def maximumTop(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    # After taking k elements, if we're left something, then we return nums[k]\n    # Otherwise, return -1.\n    if k == 0 or k == 1:\n      return -1 if n == k else nums[k]\n    # Remove then add even number of times.\n    if n == 1:\n      return -1 if k & 1 else nums[0]\n    # Take min(n, k - 1) elements and put the largest one back.\n    mx = max(nums[:min(n, k - 1)])\n    if k >= n:\n      return mx\n    return max(mx, nums[k])",
      "title": "2202. Maximize the Topmost Element After K Moves",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7d1ffa01-b0ae-463e-8d4f-5a4d097c7f15",
      "code": "class Solution:\n  def minimumWeight(\n      self,\n      n: int,\n      edges: list[list[int]],\n      src1: int,\n      src2: int,\n      dest: int,\n  ) -> int:\n    graph = [[] for _ in range(n)]\n    reversedGraph = [[] for _ in range(n)]\n\n    for u, v, w in edges:\n      graph[u].append((v, w))\n      reversedGraph[v].append((u, w))\n\n    fromSrc1 = self._dijkstra(graph, src1)\n    fromSrc2 = self._dijkstra(graph, src2)\n    fromDest = self._dijkstra(reversedGraph, dest)\n    minWeight = min(a + b + c for a, b, c in zip(fromSrc1, fromSrc2, fromDest))\n    return -1 if minWeight == math.inf else minWeight\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n  ) -> list[int]:\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return dist",
      "title": "2203. Minimum Weighted Subgraph With the Required Paths",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3c83b8c2-bc2d-4280-99eb-33c52a437d60",
      "code": "class Solution:\n  def distanceToCycle(self, n: int, edges: list[list[int]]) -> list[int]:\n    ans = [0] * n\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    NO_RANK = -2\n\n    # The minRank that u can reach with forward edges\n    def getRank(u: int, currRank: int, rank: list[int]) -> int:\n      if rank[u] != NO_RANK:  # The rank is already determined\n        return rank[u]\n\n      rank[u] = currRank\n      minRank = currRank\n\n      for v in graph[u]:\n        # Visited or parent (that's why NO_RANK = -2 instead of -1)\n        if rank[v] == len(rank) or rank[v] == currRank - 1:\n          continue\n        nextRank = getRank(v, currRank + 1, rank)\n        # NextRank should > currRank if there's no cycle\n        if nextRank <= currRank:\n          cycle.append(v)\n        minRank = min(minRank, nextRank)\n\n      rank[u] = len(rank)  # Mark as visited.\n      return minRank\n\n    # rank[i] := the minimum node that node i can reach with forward edges\n    # Initialize with NO_RANK = -2 to indicate not visited.\n    cycle = []\n    getRank(0, 0, [NO_RANK] * n)\n\n    q = collections.deque(cycle)\n    seen = set(cycle)\n\n    step = 1\n    while q:\n      for _ in range(len(q)):\n        u = q.popleft()\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n          ans[v] = step\n      step += 1\n\n    return ans",
      "title": "2204. Distance to a Cycle in Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca95efd6-2ec2-4c19-a80e-88eee841b383",
      "code": "class Solution:\n  def divideArray(self, nums: list[int]) -> bool:\n    return all(value % 2 == 0 for value in collections.Counter(nums).values())",
      "title": "2206. Divide Array Into Equal Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0494ef9c-e2be-4fa4-8e3a-361a6cc349b5",
      "code": "class Solution:\n  def maximumSubsequenceCount(self, text: str, pattern: str) -> int:\n    ans = 0\n    count0 = 0  # the count of the letter pattern[0]\n    count1 = 0  # the count of the letter pattern[1]\n\n    for c in text:\n      if c == pattern[1]:\n        ans += count0\n        count1 += 1\n      if c == pattern[0]:\n        count0 += 1\n\n    # It is optimal to add pattern[0] at the beginning or add pattern[1] at the\n    # end of the text.\n    return ans + max(count0, count1)",
      "title": "2207. Maximize Number of Subsequences in a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "600f441c-4784-468a-b90b-64721f542520",
      "code": "class Solution:\n  def halveArray(self, nums: list[int]) -> int:\n    halfSum = sum(nums) / 2\n    ans = 0\n    runningSum = 0.0\n    maxHeap = [-num for num in nums]\n\n    heapq.heapify(maxHeap)\n\n    while runningSum < halfSum:\n      maxValue = -heapq.heappop(maxHeap) / 2\n      runningSum += maxValue\n      heapq.heappush(maxHeap, -maxValue)\n      ans += 1\n\n    return ans",
      "title": "2208. Minimum Operations to Halve Array Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "835ad9cc-518c-4d91-9e53-4ff65a2b2e16",
      "code": "class Solution:\n  def minimumWhiteTiles(\n      self,\n      floor: str,\n      numCarpets: int,\n      carpetLen: int,\n  ) -> int:\n    n = len(floor)\n    # dp[i][j] := the minimum number of visible white tiles of floor[i..n)\n    # after covering at most j carpets\n    dp = [[0] * (numCarpets + 1) for _ in range(n + 1)]\n\n    for i in reversed(range(n)):\n      dp[i][0] = int(floor[i]) + dp[i + 1][0]\n\n    for i in reversed(range(n)):\n      for j in range(1, numCarpets + 1):\n        cover = dp[i + carpetLen][j - 1] if i + carpetLen < n else 0\n        skip = int(floor[i]) + dp[i + 1][j]\n        dp[i][j] = min(cover, skip)\n\n    return dp[0][numCarpets]",
      "title": "2209. Minimum White Tiles After Covering With Carpets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2fee59a8-788d-4220-97e9-54a891468575",
      "code": "class Solution:\n  def countHillValley(self, nums: list[int]) -> int:\n    ans = 0\n    left = nums[0]\n\n    for i in range(1, len(nums) - 1):\n      if (left < nums[i] and nums[i] > nums[i + 1] or  # the hill\n              left > nums[i] and nums[i] < nums[i + 1]):  # the valley\n        ans += 1\n        left = nums[i]\n\n    return ans",
      "title": "2210. Count Hills and Valleys in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a93c694-d9f6-4a0e-9d77-dce35085ab79",
      "code": "class Solution:\n  def countCollisions(self, directions: str) -> int:\n    l = 0\n    r = len(directions) - 1\n\n    while l < len(directions) and directions[l] == 'L':\n      l += 1\n\n    while r >= 0 and directions[r] == 'R':\n      r -= 1\n\n    return sum(c != 'S' for c in directions[l:r + 1])",
      "title": "2211. Count Collisions on a Road",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "427ebf50-11b2-48de-b38a-535c719c79ce",
      "code": "class Solution:\n  def maximumBobPoints(\n      self,\n      numArrows: int,\n      aliceArrows: list[int],\n  ) -> list[int]:\n    FULL_MASK = (1 << 12) - 1\n    maxPoint = 0\n    maxMask = 0\n\n    def getShotableAndPoint(mask: int, leftArrows: int) -> tuple[bool, int]:\n      point = 0\n      for i in range(12):\n        if mask >> i & 1:\n          leftArrows -= aliceArrows[i] + 1\n          point += i\n      return leftArrows >= 0, point\n\n    for mask in range(FULL_MASK):\n      shotable, point = getShotableAndPoint(mask, numArrows)\n      if shotable and point > maxPoint:\n        maxPoint = point\n        maxMask = mask\n\n    def getBobsArrows(mask: int, leftArrows: int) -> list[int]:\n      bobsArrows = [0] * 12\n      for i in range(12):\n        if mask >> i & 1:\n          bobsArrows[i] = aliceArrows[i] + 1\n          leftArrows -= aliceArrows[i] + 1\n      bobsArrows[0] = leftArrows\n      return bobsArrows\n\n    return getBobsArrows(maxMask, numArrows)",
      "title": "2212. Maximum Points in an Archery Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe5743e8-a0a5-48c7-aa6b-7e1a5e1f262f",
      "code": "class Solution:\n  def minimumHealth(self, damage: list[int], armor: int) -> int:\n    return 1 + sum(damage) - min(max(damage), armor)",
      "title": "2214. Minimum Health to Beat Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b9f1017d-084b-4fba-9142-c2884c7e4b7c",
      "code": "class Solution:\n  def findDifference(self, nums1: list[int],\n                     nums2: list[int]) -> list[list[int]]:\n    set1 = set(nums1)\n    set2 = set(nums2)\n    return [set1 - set2, set2 - set1]",
      "title": "2215. Find the Difference of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba79b698-a431-4594-bb87-2cdf5be6b97d",
      "code": "class Solution:\n  def minDeletion(self, nums: list[int]) -> int:\n    ans = 0\n\n    for i in range(len(nums) - 1):\n      # i - ans := the index after deletion\n      if nums[i] == nums[i + 1] and (i - ans) % 2 == 0:\n        ans += 1\n\n    # Add one if the length after deletion is odd\n    return ans + ((len(nums) - ans) & 1)",
      "title": "2216. Minimum Deletions to Make Array Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c27ef6-0775-4fb3-aa7b-21e38c57acda",
      "code": "class Solution:\n  def kthPalindrome(self, queries: list[int], intLength: int) -> list[int]:\n    start = pow(10, (intLength + 1) // 2 - 1)\n    end = pow(10, (intLength + 1) // 2)\n    mul = pow(10, intLength // 2)\n\n    def reverse(num: int) -> int:\n      res = 0\n      while num:\n        res = res * 10 + num % 10\n        num //= 10\n      return res\n\n    def getKthPalindrome(query: int) -> int:\n      prefix = start + query - 1\n      return prefix * mul + reverse(prefix\n                                    if intLength % 2 == 0 else prefix // 10)\n\n    return [-1 if start + query > end else getKthPalindrome(query)\n            for query in queries]",
      "title": "2217. Find Palindrome With Fixed Length",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ec98cce9-f473-4822-982b-30df132f6b42",
      "code": "class Solution:\n  def maxValueOfCoins(self, piles: list[list[int]], k: int) -> int:\n    @functools.lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"Returns the maximum value of picking k coins from piles[i..n).\"\"\"\n      if i == len(piles) or k == 0:\n        return 0\n\n      # Pick no coins from the current pile.\n      res = dp(i + 1, k)\n      val = 0  # the coins picked from the current pile\n\n      # Try to pick 1, 2, ..., k coins from the current pile.\n      for j in range(min(len(piles[i]), k)):\n        val += piles[i][j]\n        res = max(res, val + dp(i + 1, k - j - 1))\n\n      return res\n\n    return dp(0, k)",
      "title": "2218. Maximum Value of K Coins From Piles",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7fc45a60-bb55-4c1c-b831-ee9c75ff1f12",
      "code": "class Solution:\n  def maximumSumScore(self, nums: list[int]) -> int:\n    ans = -math.inf\n    prefix = 0\n    summ = sum(nums)\n\n    for num in nums:\n      prefix += num\n      ans = max(ans, prefix, summ - prefix + num)\n\n    return ans",
      "title": "2219. Maximum Sum Score of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2e7e33b5-e6c8-4a24-9efd-c9c77bee85e9",
      "code": "class Solution:\n  def minBitFlips(self, start: int, goal: int) -> int:\n    return (start ^ goal).bit_count()",
      "title": "2220. Minimum Bit Flips to Convert Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba2af796-51b8-4c8b-a5a4-5f8dc5e2017b",
      "code": "class Solution:\n  def triangularSum(self, nums: list[int]) -> int:\n    for sz in range(len(nums), 0, -1):\n      for i in range(sz - 1):\n        nums[i] = (nums[i] + nums[i + 1]) % 10\n    return nums[0]",
      "title": "2221. Find Triangular Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8eb11dac-0ea8-4485-8226-e7b7ee58ce88",
      "code": "class Solution:\n  def numberOfWays(self, s: str) -> int:\n    ans = 0\n    # before[i] := the number of i before the current digit\n    before = [0] * 2\n    # after[i] := the number of i after the current digit\n    after = [0] * 2\n    after[0] = s.count('0')\n    after[1] = len(s) - after[0]\n\n    for c in s:\n      num = int(c)\n      after[num] -= 1\n      if num == 0:\n        ans += before[1] * after[1]\n      else:\n        ans += before[0] * after[0]\n      before[num] += 1\n\n    return ans",
      "title": "2222. Number of Ways to Select Buildings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3bd7f0f9-db95-42fc-838d-f474e7ad7bcd",
      "code": "class Solution:\n  def sumScores(self, s: str) -> int:\n    n = len(s)\n    # https://cp-algorithms.com/string/z-function.html#implementation\n    z = [0] * n\n    # [l, r] := the indices of the rightmost segment match\n    l = 0\n    r = 0\n\n    for i in range(1, n):\n      if i < r:\n        z[i] = min(r - i, z[i - l])\n      while i + z[i] < n and s[z[i]] == s[i + z[i]]:\n        z[i] += 1\n      if i + z[i] > r:\n        l = i\n        r = i + z[i]\n\n    return sum(z) + n",
      "title": "2223. Sum of Scores of Built Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c81606c4-d040-41de-8e91-bc2a2476658c",
      "code": "class Solution:\n  def convertTime(self, current: str, correct: str) -> int:\n    ops = [60, 15, 5, 1]\n\n    def getMinutes(s: str) -> int:\n      return int(s[:2]) * 60 + int(s[3:])\n\n    diff = getMinutes(correct) - getMinutes(current)\n    ans = 0\n\n    for op in ops:\n      ans += diff // op\n      diff %= op\n\n    return ans",
      "title": "2224. Minimum Number of Operations to Convert Time",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ad0e3e1-b28f-4dad-9bdc-5086aac46e7c",
      "code": "class Solution:\n  def findWinners(self, matches: list[list[int]]) -> list[list[int]]:\n    ans = [[] for _ in range(2)]\n    lossesCount = collections.Counter()\n\n    for winner, loser in matches:\n      if winner not in lossesCount:\n        lossesCount[winner] = 0\n      lossesCount[loser] += 1\n\n    for player, nLosses in lossesCount.items():\n      if nLosses < 2:\n        ans[nLosses].append(player)\n\n    return [sorted(ans[0]), sorted(ans[1])]",
      "title": "2225. Find Players With Zero or One Losses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "587d4cd8-9e45-4994-8ac1-4a43e467f2ac",
      "code": "class Solution:\n  def maximumCandies(self, candies: list[int], k: int) -> int:\n    l = 1\n    r = sum(candies) // k\n\n    def numChildren(m: int) -> bool:\n      return sum(c // m for c in candies)\n\n    while l < r:\n      m = (l + r) // 2\n      if numChildren(m) < k:\n        r = m\n      else:\n        l = m + 1\n\n    return l if numChildren(l) >= k else l - 1",
      "title": "2226. Maximum Candies Allocated to K Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8d145ba-7a1b-426b-a1da-2ad09135d222",
      "code": "class Solution:\n  def isConsecutive(self, nums: list[int]) -> bool:\n    return max(nums) - min(nums) + 1 == len(set(nums)) == len(nums)",
      "title": "2229. Check if an Array Is Consecutive",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7c9d1b17-89f6-452f-a416-90c2186f637e",
      "code": "class Solution:\n  def largestInteger(self, num: int) -> int:\n    s = str(num)\n    ans = 0\n    # maxHeap[0] := the odd digits\n    # maxHeap[1] := the even digits\n    maxHeap = [[] for _ in range(2)]\n\n    for c in s:\n      digit = int(c)\n      heapq.heappush(maxHeap[digit % 2], -digit)\n\n    for c in s:\n      i = int(c) & 1\n      ans = (ans * 10 - heapq.heappop(maxHeap[i]))\n\n    return ans",
      "title": "2231. Largest Number After Digit Swaps by Parity",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "18b65b69-9c3f-45bb-b846-30874e2af0c2",
      "code": "class Solution:\n  def minimizeResult(self, expression: str) -> str:\n    plusIndex = expression.index('+')\n    left = expression[:plusIndex]\n    right = expression[plusIndex + 1:]\n    ans = ''\n    mn = math.inf\n\n    # the expression -> a * (b + c) * d\n    for i in range(len(left)):\n      for j in range(len(right)):\n        a = 1 if i == 0 else int(left[:i])\n        b = int(left[i:])\n        c = int(right[0:j + 1])\n        d = 1 if j == len(right) - 1 else int(right[j + 1:])\n        val = a * (b + c) * d\n        if val < mn:\n          mn = val\n          ans = (('' if i == 0 else str(a)) +\n                 '(' + str(b) + '+' + str(c) + ')' +\n                 ('' if j == len(right) - 1 else str(d)))\n\n    return ans",
      "title": "2232. Minimize Result by Adding Parentheses to Expression",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3eb6c6f4-bece-448b-bc98-cb8de958bce6",
      "code": "class Solution:\n  def maximumProduct(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    ans = 1\n    minHeap = nums.copy()\n    heapq.heapify(minHeap)\n\n    for _ in range(k):\n      minNum = heapq.heappop(minHeap)\n      heapq.heappush(minHeap, minNum + 1)\n\n    while minHeap:\n      ans *= heapq.heappop(minHeap)\n      ans %= MOD\n\n    return ans",
      "title": "2233. Maximum Product After K Increments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cacd3d1c-c020-484b-b203-889d58c8fed0",
      "code": "class Solution:\n  def maximumBeauty(\n      self,\n      flowers: list[int],\n      newFlowers: int,\n      target: int,\n      full: int,\n      partial: int,\n  ) -> int:\n    n = len(flowers)\n\n    # If a garden is already complete, clamp it to the target.\n    flowers = [min(flower, target) for flower in flowers]\n    flowers.sort()\n\n    # All gardens are complete, so nothing we can do.\n    if flowers[0] == target:\n      return n * full\n\n    # Having many new flowers maximizes the beauty value.\n    if newFlowers >= n * target - sum(flowers):\n      return max(n * full, (n - 1) * full + (target - 1) * partial)\n\n    ans = 0\n    leftFlowers = newFlowers\n    # cost[i] := the cost to make flowers[0..i] the same\n    cost = [0] * n\n\n    for i in range(1, n):\n      # Plant (flowers[i] - flowers[i - 1]) flowers for flowers[0..i - 1].\n      cost[i] = cost[i - 1] + i * (flowers[i] - flowers[i - 1])\n\n    i = n - 1  # flowers' index (flowers[i + 1..n) are complete)\n    while flowers[i] == target:\n      i -= 1\n\n    while leftFlowers >= 0:\n      # To maximize the minimum number of incomplete flowers, we find the first\n      # index j that we can't make flowers[0..j] equal to flowers[j], then we\n      # know we can make flowers[0..j - 1] equal to flowers[j - 1]. In the\n      # meantime, evenly increase each of them to seek a bigger minimum value.\n      j = min(i + 1, bisect_right(cost, leftFlowers))\n      minIncomplete = flowers[j - 1] + (leftFlowers - cost[j - 1]) // j\n      ans = max(ans, (n - 1 - i) * full + minIncomplete * partial)\n      leftFlowers -= max(0, target - flowers[i])\n      i -= 1\n\n    return ans",
      "title": "2234. Maximum Total Beauty of the Gardens",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c964cb5d-d739-4fde-ba36-825aa8e88df7",
      "code": "class Solution:\n  sum = operator.add",
      "title": "2235. Add Two Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ff90e3d-c3f4-4ef8-9391-f0328fdc551e",
      "code": "class Solution:\n  def checkTree(self, root: TreeNode | None) -> bool:\n    return root.val == root.left.val + root.right.val",
      "title": "2236. Root Equals Sum of Children",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6909128c-3177-4ab9-8f1d-5ca80a08e608",
      "code": "class Solution:\n  def meetRequirement(\n      self,\n      n: int,\n      lights: list[list[int]],\n      requirement: list[int],\n  ) -> int:\n    ans = 0\n    currBrightness = 0\n    change = [0] * (n + 1)\n\n    for position, rg in lights:\n      change[max(0, position - rg)] += 1\n      change[min(n, position + rg + 1)] -= 1\n\n    for i in range(n):\n      currBrightness += change[i]\n      if currBrightness >= requirement[i]:\n        ans += 1\n\n    return ans",
      "title": "2237. Count Positions on Street With Required Brightness",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae571406-7e0d-4191-8efd-9330d9c247df",
      "code": "class Solution:\n  def findClosestNumber(self, nums: list[int]) -> int:\n    nums.sort(key=lambda x: (abs(x), -x))\n    return nums[0]",
      "title": "2239. Find Closest Number to Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "386b51f6-39dc-4bfc-868a-0ecff61b5743",
      "code": "class Solution:\n  def waysToBuyPensPencils(self, total: int, cost1: int, cost2: int) -> int:\n    maxPen = total // cost1\n    return sum((total - i * cost1) // cost2\n               for i in range(maxPen + 1)) + maxPen + 1",
      "title": "2240. Number of Ways to Buy Pens and Pencils",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dcbf3026-be3d-444c-879c-e81e684196fa",
      "code": "class Solution:\n  def maximumScore(self, scores: list[int], edges: list[list[int]]) -> int:\n    n = len(scores)\n    ans = -1\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((scores[v], v))\n      graph[v].append((scores[u], u))\n\n    for i in range(n):\n      graph[i] = heapq.nlargest(3, graph[i])\n\n    # To find the target sequence: a - u - v - b, enumerate each edge (u, v),\n    # and find a (u's child) and b (v's child). That's why we find the 3\n    # children that have the highest scores because one of the 3 children is\n    # guaranteed to be valid.\n    for u, v in edges:\n      for scoreA, a in graph[u]:\n        for scoreB, b in graph[v]:\n          if a != b and a != v and b != u:\n            ans = max(ans, scoreA + scores[u] + scores[v] + scoreB)\n\n    return ans",
      "title": "2242. Maximum Score of a Node Sequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9dac3238-19cc-4419-9994-49640332f5f7",
      "code": "class Solution:\n  def digitSum(self, s: str, k: int) -> str:\n    while len(s) > k:\n      next = []\n      for i in range(0, len(s), k):\n        summ = 0\n        for j in range(i, min(len(s), i + k)):\n          summ += int(s[j])\n        next.append(str(summ))\n      s = ''.join(next)\n    return s",
      "title": "2243. Calculate Digit Sum of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "494f922f-ab0d-45da-9c44-c6411f039fae",
      "code": "class Solution:\n  def minimumRounds(self, tasks: list[int]) -> int:\n    freqs = collections.Counter(tasks).values()\n    return -1 if 1 in freqs else sum((f + 2) // 3 for f in freqs)",
      "title": "2244. Minimum Rounds to Complete All Tasks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16174eda-676e-4db3-9e6e-f629f71903db",
      "code": "class Solution:\n  def maxTrailingZeros(self, grid: list[list[int]]) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # leftPrefix2[i][j] := the number of 2 in grid[i][0..j]\n    # leftPrefix5[i][j] := the number of 5 in grid[i][0..j]\n    # topPrefix2[i][j] := the number of 2 in grid[0..i][j]\n    # topPrefix5[i][j] := the number of 5 in grid[0..i][j]\n    leftPrefix2 = [[0] * n for _ in range(m)]\n    leftPrefix5 = [[0] * n for _ in range(m)]\n    topPrefix2 = [[0] * n for _ in range(m)]\n    topPrefix5 = [[0] * n for _ in range(m)]\n\n    def getCount(num: int, factor: int) -> int:\n      count = 0\n      while num % factor == 0:\n        num //= factor\n        count += 1\n      return count\n\n    for i in range(m):\n      for j in range(n):\n        leftPrefix2[i][j] = getCount(grid[i][j], 2)\n        leftPrefix5[i][j] = getCount(grid[i][j], 5)\n        if j:\n          leftPrefix2[i][j] += leftPrefix2[i][j - 1]\n          leftPrefix5[i][j] += leftPrefix5[i][j - 1]\n\n    for j in range(n):\n      for i in range(m):\n        topPrefix2[i][j] = getCount(grid[i][j], 2)\n        topPrefix5[i][j] = getCount(grid[i][j], 5)\n        if i:\n          topPrefix2[i][j] += topPrefix2[i - 1][j]\n          topPrefix5[i][j] += topPrefix5[i - 1][j]\n\n    ans = 0\n    for i in range(m):\n      for j in range(n):\n        curr2 = getCount(grid[i][j], 2)\n        curr5 = getCount(grid[i][j], 5)\n        l2 = leftPrefix2[i][j]\n        l5 = leftPrefix5[i][j]\n        r2 = leftPrefix2[i][n - 1] - (0 if j == 0 else leftPrefix2[i][j - 1])\n        r5 = leftPrefix5[i][n - 1] - (0 if j == 0 else leftPrefix5[i][j - 1])\n        t2 = topPrefix2[i][j]\n        t5 = topPrefix5[i][j]\n        d2 = topPrefix2[m - 1][j] - (0 if i == 0 else topPrefix2[i - 1][j])\n        d5 = topPrefix5[m - 1][j] - (0 if i == 0 else topPrefix5[i - 1][j])\n        ans = max(ans,\n                  min(l2 + t2 - curr2, l5 + t5 - curr5),\n                  min(r2 + t2 - curr2, r5 + t5 - curr5),\n                  min(l2 + d2 - curr2, l5 + d5 - curr5),\n                  min(r2 + d2 - curr2, r5 + d5 - curr5))\n\n    return ans",
      "title": "2245. Maximum Trailing Zeros in a Cornered Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "875c2ed0-f683-4480-a8db-fd5d5e37943e",
      "code": "class Solution:\n  def longestPath(self, parent: list[int], s: str) -> int:\n    n = len(parent)\n    ans = 0\n    graph = [[] for _ in range(n)]\n\n    for i in range(1, n):\n      graph[parent[i]].append(i)\n\n    def longestPathDownFrom(u: int) -> int:\n      nonlocal ans\n      max1 = 0\n      max2 = 0\n\n      for v in graph[u]:\n        res = longestPathDownFrom(v)\n        if s[u] == s[v]:\n          continue\n        if res > max1:\n          max2 = max1\n          max1 = res\n        elif res > max2:\n          max2 = res\n\n      ans = max(ans, 1 + max1 + max2)\n      return 1 + max1\n\n    longestPathDownFrom(0)\n    return ans",
      "title": "2246. Longest Path With Different Adjacent Characters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6d49c3b-2f1d-4e7a-87c9-a5cadacdc2b7",
      "code": "class Solution:\n  def maximumCost(self, n: int, highways: list[list[int]], k: int) -> int:\n    if k + 1 > n:\n      return -1\n\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in highways:\n      graph[u].append((v, w))\n      graph[v].append((u, w))\n\n    @functools.lru_cache(None)\n    def dp(u: int, mask: int) -> int:\n      \"\"\"\n      Returns the maximum cost of trip starting from u, where `mask` is the\n      bitmask of the visited cities.\n      \"\"\"\n      if mask.bit_count() == k + 1:\n        return 0\n\n      res = -1\n      for v, w in graph[u]:\n        if mask >> v & 1:\n          continue\n        nextCost = dp(v, mask | 1 << v)\n        if nextCost != -1:\n          res = max(res, w + nextCost)\n      return res\n\n    return max(dp(i, 1 << i) for i in range(n))",
      "title": "2247. Maximum Cost of Trip With K Highways",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90b8cfd0-a242-4d75-8bd9-c9cb37bf55c1",
      "code": "class Solution:\n  def intersection(self, nums: list[list[int]]) -> list[int]:\n    count = [0] * 1001\n\n    for row in nums:\n      for a in row:\n        count[a] += 1\n\n    return [i for i, c in enumerate(count)\n            if c == len(nums)]",
      "title": "2248. Intersection of Multiple Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4576d07c-328f-497b-9dea-f7dc50c16ff7",
      "code": "class Solution:\n  def countLatticePoints(self, circles: list[list[int]]) -> int:\n    points = set()\n\n    # dx := relative to x\n    # dy := relative to y\n    # So, dx^2 + dy^2 = r^2.\n    for x, y, r in circles:\n      for dx in range(-r, r + 1):\n        yMax = int((r**2 - dx**2)**0.5)\n        for dy in range(-yMax, yMax + 1):\n          points.add((x + dx, y + dy))\n\n    return len(points)",
      "title": "2249. Count Lattice Points Inside a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "97612e47-1816-4a76-9253-b59bba00e51a",
      "code": "class Solution:\n  def countRectangles(\n      self,\n      rectangles: list[list[int]],\n      points: list[list[int]],\n  ) -> list[int]:\n    ans = []\n    yToXs = [[] for _ in range(101)]\n\n    for l, h in rectangles:\n      yToXs[h].append(l)\n\n    for xs in yToXs:\n      xs.sort()\n\n    for xi, yi in points:\n      count = 0\n      for y in range(yi, 101):\n        xs = yToXs[y]\n        count += len(xs) - bisect.bisect_left(xs, xi)\n      ans.append(count)\n\n    return ans",
      "title": "2250. Count Number of Rectangles Containing Each Point",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75455939-ffef-40dd-a606-49bfe0be637a",
      "code": "class Solution:\n  def fullBloomFlowers(\n      self,\n      flowers: list[list[int]],\n      persons: list[int],\n  ) -> list[int]:\n    starts = sorted(s for s, _ in flowers)\n    ends = sorted(e for _, e in flowers)\n    return [bisect.bisect_right(starts, person) -\n            bisect.bisect_left(ends, person)\n            for person in persons]",
      "title": "2251. Number of Flowers in Full Bloom",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce5bac43-1271-4e0b-a2b5-92fb814d7650",
      "code": "class Solution:\n  def countPrefixes(self, words: list[str], s: str) -> int:\n    return sum(map(s.startswith, words))",
      "title": "2255. Count Prefixes of a Given String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "48cf0e37-4adc-4ca2-a917-398ff133cbf0",
      "code": "class Solution:\n  def minimumAverageDifference(self, nums: list[int]) -> int:\n    n = len(nums)\n    ans = 0\n    minDiff = inf\n    prefix = 0\n    suffix = sum(nums)\n\n    for i, num in enumerate(nums):\n      prefix += num\n      suffix -= num\n      prefixAvg = prefix // (i + 1)\n      suffixAvg = 0 if i == n - 1 else suffix // (n - 1 - i)\n      diff = abs(prefixAvg - suffixAvg)\n      if diff < minDiff:\n        ans = i\n        minDiff = diff\n\n    return ans",
      "title": "2256. Minimum Average Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "abc44899-10db-4a87-b1b8-c824c283c16d",
      "code": "class Solution:\n  def countUnguarded(\n      self,\n      m: int,\n      n: int,\n      guards: list[list[int]],\n      walls: list[list[int]],\n  ) -> int:\n    ans = 0\n    grid = [[0] * n for _ in range(m)]\n    left = [[0] * n for _ in range(m)]\n    right = [[0] * n for _ in range(m)]\n    up = [[0] * n for _ in range(m)]\n    down = [[0] * n for _ in range(m)]\n\n    for row, col in guards:\n      grid[row][col] = 'G'\n\n    for row, col in walls:\n      grid[row][col] = 'W'\n\n    for i in range(m):\n      lastCell = 0\n      for j in range(n):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          left[i][j] = lastCell\n      lastCell = 0\n      for j in range(n - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          right[i][j] = lastCell\n\n    for j in range(n):\n      lastCell = 0\n      for i in range(m):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          up[i][j] = lastCell\n      lastCell = 0\n      for i in range(m - 1, -1, -1):\n        if grid[i][j] == 'G' or grid[i][j] == 'W':\n          lastCell = grid[i][j]\n        else:\n          down[i][j] = lastCell\n\n    for i in range(m):\n      for j in range(n):\n        if (grid[i][j] == 0 and left[i][j] != 'G' and right[i][j] != 'G' and\n                up[i][j] != 'G' and down[i][j] != 'G'):\n          ans += 1\n\n    return ans",
      "title": "2257. Count Unguarded Cells in the Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a2df2365-565a-47d2-b403-45a13046e5aa",
      "code": "class Solution:\n  def maximumMinutes(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    MAX = len(grid) * len(grid[0])\n    fireGrid = [[-1] * len(grid[0]) for _ in range(len(grid[0]))]\n    self._buildFireGrid(grid, fireGrid, DIRS)\n\n    ans = -1\n    l = 0\n    r = MAX\n\n    while l <= r:\n      m = (l + r) // 2\n      if self._canStayFor(grid, fireGrid, m, DIRS):\n        ans = m\n        l = m + 1\n      else:\n        r = m - 1\n\n    return 1e9 if ans == MAX else ans\n\n  def _buildFireGrid(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      DIRS: list[int],\n  ) -> None:\n    minuteFromFire = 0\n    q = collections.deque()\n\n    for i in range(len(grid)):\n      for j in range(len(grid[0])):\n        if grid[i][j] == 1:  # the fire\n          q.append((i, j))\n          fireMinute[i][j] = 0\n\n    while q:\n      minuteFromFire += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if fireMinute[x][y] != -1:\n            continue\n          fireMinute[x][y] = minuteFromFire\n          q.append((x, y))\n\n  def _canStayFor(\n      self,\n      grid: list[list[int]],\n      fireMinute: list[list[int]],\n      minute: int, DIRS: list[int],\n  ) -> bool:\n    q = collections.deque([(0, 0)])  # the start position\n    seen = {(0, 0)}\n\n    while q:\n      minute += 1\n      for _ in range(len(q)):\n        i, j = q.popleft()\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == len(grid) or y < 0 or y == len(grid[0]):\n            continue\n          if grid[x][y] == 2:  # the wall\n            continue\n          if x == len(grid) - 1 and y == len(grid[0]) - 1:\n            if fireMinute[x][y] != -1 and fireMinute[x][y] < minute:\n              continue\n            return True\n          if fireMinute[x][y] != -1 and fireMinute[x][y] <= minute:\n            continue\n          if seen[x][y]:\n            continue\n          q.append((x, y))\n          seen.add((x, y))\n\n    return False",
      "title": "2258. Escape the Spreading Fire",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "89cea8dd-d5af-43ce-89d1-ae7ee9a8f25e",
      "code": "class Solution:\n  def minimumCardPickup(self, cards: list[int]) -> int:\n    ans = math.inf\n    lastSeen = {}\n\n    for i, card in enumerate(cards):\n      if card in lastSeen:\n        ans = min(ans, i - lastSeen[card] + 1)\n      lastSeen[card] = i\n\n    return -1 if ans == math.inf else ans",
      "title": "2260. Minimum Consecutive Cards to Pick Up",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34abca32-835d-4f16-ab43-a8034897cc11",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[int, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def countDistinct(self, nums: list[int], k: int, p: int) -> int:\n    ans = 0\n    root = TrieNode()\n\n    def insert(node: TrieNode, i: int, k: int):\n      nonlocal ans\n      if i == len(nums) or k - (nums[i] % p == 0) < 0:\n        return\n      if nums[i] not in node.children:\n        node.children[nums[i]] = TrieNode()\n        ans += 1\n      insert(node.children[nums[i]], i + 1, k - (nums[i] % p == 0))\n\n    for i in range(len(nums)):\n      insert(root, i, k)\n\n    return ans",
      "title": "2261. K Divisible Elements Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6924f2c6-1f98-40b0-b736-568d28f36aa9",
      "code": "class Solution:\n  def appealSum(self, s: str) -> int:\n    ans = 0\n    # the total appeal of all substrings ending in the index so far\n    dp = 0\n    lastSeen = {}\n\n    for i, c in enumerate(s):\n      #   the total appeal of all substrings ending in s[i]\n      # = the total appeal of all substrings ending in s[i - 1]\n      # + the number of substrings ending in s[i] that contain only this s[i]\n      dp += i - lastSeen.get(c, -1)\n      ans += dp\n      lastSeen[c] = i\n\n    return ans",
      "title": "2262. Total Appeal of A String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0ac3ee52-1fe8-4b01-931d-b7836b5fbbd8",
      "code": "class Solution:\n  def convertArray(self, nums: list[int]) -> int:\n    def cost(nums: list[int]) -> int:\n      ans = 0\n      minHeap = []\n\n      # Greedily make `nums` non-increasing.\n      for num in nums:\n        if minHeap and minHeap[0] < num:\n          ans += num - heapq.heappushpop(minHeap, num)\n        heapq.heappush(minHeap, num)\n\n      return ans\n\n    return min(cost(nums), cost([-num for num in nums]))",
      "title": "2263. Make Array Non-decreasing or Non-increasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2db0dee8-2ce1-4991-8f27-7ab192882f5a",
      "code": "class Solution:\n  def largestGoodInteger(self, num: str) -> str:\n    return max(num[i - 2:i + 1]\n               if num[i] == num[i - 1] == num[i - 2]\n               else '' for i in range(2, len(num)))",
      "title": "2264. Largest 3-Same-Digit Number in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fbf68fbb-dadd-48af-85ec-27b002d49216",
      "code": "class Solution:\n  def averageOfSubtree(self, root: TreeNode | None) -> int:\n    ans = 0\n\n    def dfs(root: TreeNode | None) -> tuple[int, int]:\n      nonlocal ans\n      if not root:\n        return (0, 0)\n      leftSum, leftCount = dfs(root.left)\n      rightSum, rightCount = dfs(root.right)\n      summ = root.val + leftSum + rightSum\n      count = 1 + leftCount + rightCount\n      if summ // count == root.val:\n        ans += 1\n      return (summ, count)\n\n    dfs(root)\n    return ans",
      "title": "2265. Count Nodes Equal to Average of Subtree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "72e9a5ca-18e7-4b12-ab45-d8958af4a5c3",
      "code": "class Solution:\n  def countTexts(self, pressedKeys: str) -> int:\n    MOD = 1_000_000_007\n    n = len(pressedKeys)\n    # dp[i] := the number of possible text messages of pressedKeys[i..n)\n    dp = [0] * n + [1]\n\n    def isSame(s: str, i: int, k: int) -> bool:\n      \"\"\"Returns True if s[i..i + k) are the same digits.\"\"\"\n      if i + k > len(s):\n        return False\n      for j in range(i + 1, i + k):\n        if s[j] != s[i]:\n          return False\n      return True\n\n    for i in reversed(range(n)):\n      dp[i] = dp[i + 1]\n      if isSame(pressedKeys, i, 2):\n        dp[i] += dp[i + 2]\n      if isSame(pressedKeys, i, 3):\n        dp[i] += dp[i + 3]\n      if ((pressedKeys[i] == '7' or pressedKeys[i] == '9') and\n              isSame(pressedKeys, i, 4)):\n        dp[i] += dp[i + 4]\n      dp[i] %= MOD\n\n    return dp[0]",
      "title": "2266. Count Number of Texts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "81a721e4-85ca-4dcd-ad1f-066ebac57bb8",
      "code": "class Solution:\n  def hasValidPath(self, grid: list[list[str]]) -> bool:\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> bool:\n      \"\"\"\n      Returns True if there's a path from grid[i][j] to grid[m - 1][n - 1],\n      where the number of '(' - the number of ')' == k.\n      \"\"\"\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      k += 1 if grid[i][j] == '(' else -1\n      if k < 0:\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return k == 0\n      return dp(i + 1, j, k) | dp(i, j + 1, k)\n\n    return dp(0, 0, 0)",
      "title": "2267. Check if There Is a Valid Parentheses String Path",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5a74ffbe-8399-458b-993c-5ce7827b7a18",
      "code": "class Solution:\n  def minimumKeypresses(self, s: str) -> int:\n    return sum(c * (i // 9 + 1)\n               for i, c in enumerate(sorted(Counter(s).values(), reverse=True)))",
      "title": "2268. Minimum Number of Keypresses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8525c30a-0871-4049-95c2-1fe44f605201",
      "code": "class Solution:\n  def divisorSubstrings(self, num: int, k: int) -> int:\n    s = str(num)\n    ans = 0\n\n    for i in range(len(s) - k + 1):\n      x = int(s[i:i + k])\n      if x != 0 and num % x == 0:\n        ans += 1\n\n    return ans",
      "title": "2269. Find the K-Beauty of a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4ec3a61d-0551-4779-b640-758e0a919a6d",
      "code": "class Solution:\n  def waysToSplitArray(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n    suffix = sum(nums)\n\n    for i in range(len(nums) - 1):\n      prefix += nums[i]\n      suffix -= nums[i]\n      if prefix >= suffix:\n        ans += 1\n\n    return ans",
      "title": "2270. Number of Ways to Split Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b30554f5-56ff-486b-bbcb-defba7addb91",
      "code": "class Solution:\n  def maximumWhiteTiles(self, tiles: list[list[int]], carpetLen: int) -> int:\n    if any(tile[1] - tile[0] + 1 >= carpetLen for tile in tiles):\n      return carpetLen\n\n    ans = 0\n    prefix = [0] * (len(tiles) + 1)\n\n    tiles.sort()\n    starts = [tile[0] for tile in tiles]\n\n    for i, tile in enumerate(tiles):\n      length = tile[1] - tile[0] + 1\n      prefix[i + 1] = prefix[i] + length\n\n    for i, (s, _) in enumerate(tiles):\n      carpetEnd = s + carpetLen - 1\n      endIndex = bisect_right(starts, carpetEnd) - 1\n      notCover = max(0, tiles[endIndex][1] - carpetEnd)\n      ans = max(ans, prefix[endIndex + 1] - prefix[i] - notCover)\n\n    return ans",
      "title": "2271. Maximum White Tiles Covered by a Carpet",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a81b7250-bf78-4464-9004-608327574fff",
      "code": "class Solution:\n  def largestVariance(self, s: str) -> int:\n    # a := the letter with the higher frequency\n    # b := the letter with the lower frequency\n    def kadane(a: str, b: str) -> int:\n      ans = 0\n      countA = 0\n      countB = 0\n      canExtendPrevB = False\n\n      for c in s:\n        if c != a and c != b:\n          continue\n        if c == a:\n          countA += 1\n        else:\n          countB += 1\n        if countB > 0:\n          # An interval should contain at least one b.\n          ans = max(ans, countA - countB)\n        elif countB == 0 and canExtendPrevB:\n          # edge case: consider the previous b.\n          ans = max(ans, countA - 1)\n        # Reset if the number of b > the number of a.\n        if countB > countA:\n          countA = 0\n          countB = 0\n          canExtendPrevB = True\n\n      return ans\n\n    return max(kadane(a, b)\n               for a in string.ascii_lowercase\n               for b in string.ascii_lowercase\n               if a != b)",
      "title": "2272. Substring With Largest Variance",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5dd26a25-4252-4f52-ba9e-24a0ae344660",
      "code": "class Solution:\n  def removeAnagrams(self, words: list[str]) -> list[str]:\n    ans = []\n\n    def isAnagram(a: str, b: str) -> bool:\n      count = collections.Counter(a)\n      count.subtract(collections.Counter(b))\n      return all(value == 0 for value in count.values())\n\n    i = 0\n    while i < len(words):\n      j = i + 1\n      while j < len(words) and isAnagram(words[i], words[j]):\n        j += 1\n      ans.append(words[i])\n      i = j\n\n    return ans",
      "title": "2273. Find Resultant Array After Removing Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "dd3e19e2-6833-415e-aa84-56495602ae65",
      "code": "class Solution:\n  def maxConsecutive(self, bottom: int, top: int, special: list[int]) -> int:\n    ans = 0\n\n    special.sort()\n\n    for a, b in zip(special, special[1:]):\n      ans = max(ans, b - a - 1)\n\n    return max(ans, special[0] - bottom, top - special[-1])",
      "title": "2274. Maximum Consecutive Floors Without Special Floors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcbf68c2-9365-43b8-a9ed-0af42077c2ea",
      "code": "class Solution:\n  def largestCombination(self, candidates: list[int]) -> int:\n    return max(sum(c >> i & 1 for c in candidates) for i in range(24))",
      "title": "2275. Largest Combination With Bitwise AND Greater Than Zero",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "555b03be-5a52-4de0-a4d1-87160a4d6ac9",
      "code": "class Solution:\n  def closestNode(\n      self,\n      n: int,\n      edges: list[list[int]],\n      query: list[list[int]],\n  ) -> list[int]:\n    tree = [[] for _ in range(n)]\n    dist = [[-1] * n for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def fillDist(start: int, u: int, d: int) -> None:\n      dist[start][u] = d\n      for v in tree[u]:\n        if dist[start][v] == -1:\n          fillDist(start, v, d + 1)\n\n    for i in range(n):\n      fillDist(i, i, 0)\n\n    def findClosest(u: int, end: int, node: int, ans: int) -> int:\n      for v in tree[u]:\n        if dist[v][end] < dist[u][end]:\n          return findClosest(\n              v, end, node, ans if dist[ans][node] < dist[v][node] else v)\n      return ans\n\n    return [findClosest(start, end, node, start)\n            for start, end, node in query]",
      "title": "2277. Closest Node to Path in Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fe0407d0-4e1b-482d-b710-3f992b630624",
      "code": "class Solution:\n  def percentageLetter(self, s: str, letter: str) -> int:\n    return 100 * s.count(letter) // len(s)",
      "title": "2278. Percentage of Letter in String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fad3494c-821f-4a58-9c9f-6cc3f133decf",
      "code": "class Solution:\n  def maximumBags(\n      self,\n      capacity: list[int],\n      rocks: list[int],\n      additionalRocks: int,\n  ) -> int:\n    for i, d in enumerate(sorted([c - r for c, r in zip(capacity, rocks)])):\n      if d > additionalRocks:\n        return i\n      additionalRocks -= d\n    return len(capacity)",
      "title": "2279. Maximum Bags With Full Capacity of Rocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f4eaa267-8ad6-42c0-836c-a9d910a561c6",
      "code": "class Solution:\n  def minimumLines(self, stockPrices: list[list[int]]) -> int:\n    ans = 0\n\n    stockPrices.sort()\n\n    def getSlope(p: list[int], q: list[int]) -> tuple[int, int]:\n      dx = p[0] - q[0]\n      dy = p[1] - q[1]\n      if dx == 0:\n        return (0, p[0])\n      if dy == 0:\n        return (p[1], 0)\n      d = gcd(dx, dy)\n      return (dx // d, dy // d)\n\n    for i in range(2, len(stockPrices)):\n      a = getSlope(stockPrices[i - 2], stockPrices[i - 1])\n      b = getSlope(stockPrices[i - 1], stockPrices[i])\n      if a != b:\n        ans += 1\n\n    return ans + (len(stockPrices) > 1)",
      "title": "2280. Minimum Lines to Represent a Line Chart",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bfceb2c-9f6c-475b-9056-f8db638ba986",
      "code": "class Solution:\n  def totalStrength(self, strength: list[int]) -> int:\n    MOD = 1_000_000_007\n    n = len(strength)\n    # left[i] := the next index on the left (if any)\n    #            s.t. nums[left[i]] <= nums[i]\n    left = [-1] * n\n    # right[i] := the next index on the right (if any)\n    #             s.t. nums[right[i]] < nums[i]\n    right = [n] * n\n    stack = []\n\n    for i in reversed(range(n)):\n      while stack and strength[stack[-1]] >= strength[i]:\n        left[stack.pop()] = i\n      stack.append(i)\n\n    stack = []\n\n    for i in range(n):\n      while stack and strength[stack[-1]] > strength[i]:\n        right[stack.pop()] = i\n      stack.append(i)\n\n    ans = 0\n    prefixOfPrefix = list(itertools.accumulate(\n        itertools.accumulate(strength), initial=0))\n\n    # For each strength[i] as the minimum, calculate sum.\n    for i, (l, r) in enumerate(zip(left, right)):\n      leftSum = prefixOfPrefix[i] - prefixOfPrefix[max(0, l)]\n      rightSum = prefixOfPrefix[r] - prefixOfPrefix[i]\n      leftLen = i - l\n      rightLen = r - i\n      ans += strength[i] * (rightSum * leftLen - leftSum * rightLen) % MOD\n\n    return ans % MOD",
      "title": "2281. Sum of Total Strength of Wizards",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6c91b1f4-51ba-44dd-bb90-c5a46d348a43",
      "code": "class Solution:\n  def seePeople(self, heights: list[list[int]]) -> list[list[int]]:\n    m = len(heights)\n    n = len(heights[0])\n    ans = [[0] * n for _ in range(m)]\n\n    for i, row in enumerate(heights):\n      stack = []\n      for j, height in enumerate(row):\n        hasEqualHeight = False\n        while stack and row[stack[-1]] <= height:\n          if row[stack[-1]] == height:\n            # edge case: [4, 2, 1, 1, 3]\n            hasEqualHeight = True\n          ans[i][stack.pop()] += 1\n        if stack and not hasEqualHeight:\n          ans[i][stack[-1]] += 1\n        stack.append(j)\n\n    for j, col in enumerate(zip(*heights)):\n      stack = []\n      for i, height in enumerate(col):\n        hasEqualHeight = False\n        while stack and col[stack[-1]] <= height:\n          if col[stack[-1]] == height:\n            hasEqualHeight = True\n          ans[stack.pop()][j] += 1\n        if stack and not hasEqualHeight:\n          ans[stack[-1]][j] += 1\n        stack.append(i)\n\n    return ans",
      "title": "2282. Number of People That Can Be Seen in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0a503429-f974-4c96-bfef-c7b881214d36",
      "code": "class Solution:\n  def digitCount(self, num: str) -> bool:\n    count = collections.Counter(num)\n    return all(count[str(i)] == int(digit)\n               for i, digit in enumerate(num))",
      "title": "2283. Check if Number Has Equal Digit Count and Digit Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9a2f89fb-61a5-4e58-b612-bb3dae8a4620",
      "code": "class Solution:\n  def largestWordCount(self, messages: list[str], senders: list[str]) -> str:\n    n = len(messages)\n    ans = ''\n    maxWordsSent = 0\n    count = collections.Counter()  # [sender, # Words sent]\n\n    for message, sender in zip(messages, senders):\n      wordsCount = message.count(' ') + 1\n      count[sender] += wordsCount\n      numWordsSent = count[sender]\n      if numWordsSent > maxWordsSent:\n        ans = sender\n        maxWordsSent = numWordsSent\n      elif numWordsSent == maxWordsSent and sender > ans:\n        ans = sender\n\n    return ans",
      "title": "2284. Sender With Largest Word Count",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b06b7df4-a621-4a22-9caf-5f550cf3c7b9",
      "code": "class Solution:\n  def maximumImportance(self, n: int, roads: list[list[int]]) -> int:\n    count = [0] * n\n\n    for u, v in roads:\n      count[u] += 1\n      count[v] += 1\n\n    count.sort()\n    return sum((i + 1) * c for i, c in enumerate(count))",
      "title": "2285. Maximum Total Importance of Roads",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "baba951d-395d-48ae-8b6a-aa689702e1b3",
      "code": "class Solution:\n  def rearrangeCharacters(self, s: str, target: str) -> int:\n    countS = collections.Counter(s)\n    countT = collections.Counter(target)\n    return min(countS[c] // countT[c] for c in target)",
      "title": "2287. Rearrange Characters to Make Target String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0445ce0b-6294-451e-b7b1-f56256b06040",
      "code": "class Solution:\n  def discountPrices(self, sentence: str, discount: int) -> str:\n    PRECISION = 2\n    ans = []\n\n    for word in sentence.split():\n      if word[0] == '$' and len(word) > 1:\n        digits = word[1:]\n        if all(digit.isdigit() for digit in digits):\n          val = float(digits) * (100 - discount) / 100\n          s = f'{val:.2f}'\n          trimmed = s[:s.index('.') + PRECISION + 1]\n          ans.append('$' + trimmed)\n        else:\n          ans.append(word)\n      else:\n        ans.append(word)\n\n    return ' '.join(ans)",
      "title": "2288. Apply Discount to Prices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "282e8e4c-cc4b-4207-8797-b10d0b33a9b5",
      "code": "class Solution:\n  def totalSteps(self, nums: list[int]) -> int:\n    # dp[i] := the number of steps to remove nums[i]\n    dp = [0] * len(nums)\n    stack = []\n\n    for i, num in enumerate(nums):\n      step = 1\n      while stack and nums[stack[-1]] <= num:\n        step = max(step, dp[stack.pop()] + 1)\n      if stack:\n        dp[i] = step\n      stack.append(i)\n\n    return max(dp)",
      "title": "2289. Steps to Make Array Non-decreasing",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fcf3c7c3-4d6d-4629-9c12-169342225863",
      "code": "class Solution:\n  def minimumObstacles(self, grid: list[list[int]]) -> int:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    minHeap = [(grid[0][0], 0, 0)]  # (d, i, j)\n    dist = [[math.inf] * n for _ in range(m)]\n    dist[0][0] = grid[0][0]\n\n    while minHeap:\n      d, i, j = heapq.heappop(minHeap)\n      if i == m - 1 and j == n - 1:\n        return d\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        newDist = d + grid[i][j]\n        if newDist < dist[x][y]:\n          dist[x][y] = newDist\n          heapq.heappush(minHeap, (newDist, x, y))\n\n    return dist[m - 1][n - 1]",
      "title": "2290. Minimum Obstacle Removal to Reach Corner",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "556430b7-be51-4e80-9e07-53a7f5ddada4",
      "code": "class Solution:\n  def maximumProfit(\n      self,\n      present: list[int],\n      future: list[int],\n      budget: int,\n  ) -> int:\n    n = len(present)\n    # dp[i][j] := the maximum profit of buying present[0..i) with j budget\n    dp = [[0] * (budget + 1) for _ in range(n + 1)]\n\n    for i in range(1, n + 1):\n      profit = future[i - 1] - present[i - 1]\n      for j in range(budget + 1):\n        if j < present[i - 1]:\n          dp[i][j] = dp[i - 1][j]\n        else:\n          dp[i][j] = max(dp[i - 1][j], profit + dp[i - 1][j - present[i - 1]])\n\n    return dp[n][budget]",
      "title": "2291. Maximum Profit From Trading Stocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f0bd67a-02e3-4758-8553-6eea4b166640",
      "code": "class Solution:\n  def minMaxGame(self, nums: list[int]) -> int:\n    if len(nums) == 1:\n      return nums[0]\n\n    nextNums = []\n    for i in range(len(nums) // 2):\n      nextNums.append(min(nums[2 * i], nums[2 * i + 1]) if i % 2 == 0 else\n                      max(nums[2 * i], nums[2 * i + 1]))\n    return self.minMaxGame(nextNums)",
      "title": "2293. Min Max Game",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e7267af2-1d2b-4b32-825b-ed5098e2c5e8",
      "code": "class Solution:\n  def partitionArray(self, nums: list[int], k: int) -> int:\n    nums.sort()\n\n    ans = 1\n    mn = nums[0]\n\n    for i in range(1, len(nums)):\n      if mn + k < nums[i]:\n        ans += 1\n        mn = nums[i]\n\n    return ans",
      "title": "2294. Partition Array Such That Maximum Difference Is K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c82be4eb-e27c-4837-986a-8434ab995e57",
      "code": "class Solution:\n  def arrayChange(\n      self,\n      nums: list[int],\n      operations: list[list[int]],\n  ) -> list[int]:\n    numToIndex = {num: i for i, num in enumerate(nums)}\n\n    for original, replaced in operations:\n      index = numToIndex[original]\n      nums[index] = replaced\n      del numToIndex[original]\n      numToIndex[replaced] = index\n\n    return nums",
      "title": "2295. Replace Elements in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e10fb0c4-77fb-48f4-8400-be852caaa9cd",
      "code": "class Solution:\n  def minCost(self, nums: list[int], costs: list[int]) -> int:\n    # dp[i] := the minimum cost to jump to i\n    dp = [math.inf] * len(nums)\n    maxStack = []\n    minStack = []\n\n    dp[0] = 0\n\n    for i, num in enumerate(nums):\n      while maxStack and num >= nums[maxStack[-1]]:\n        dp[i] = min(dp[i], dp[maxStack.pop()] + costs[i])\n      while minStack and num < nums[minStack[-1]]:\n        dp[i] = min(dp[i], dp[minStack.pop()] + costs[i])\n      maxStack.append(i)\n      minStack.append(i)\n\n    return dp[-1]",
      "title": "2297. Jump Game IX",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d288f46-57a6-4f0a-878a-bf8dda057c4c",
      "code": "class Solution:\n  def strongPasswordCheckerII(self, password: str) -> bool:\n    if len(password) < 8:\n      return False\n    if not any(c.islower() for c in password):\n      return False\n    if not any(c.isupper() for c in password):\n      return False\n    if not any(c.isdigit() for c in password):\n      return False\n    if not any(\"!@#$%^&*()-+\".find(c) != -1 for c in password):\n      return False\n    return all(a != b for a, b in zip(password, password[1:]))",
      "title": "2299. Strong Password Checker II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d3b55950-8a0d-4571-8e3f-e65d746fbd81",
      "code": "class Solution:\n  def successfulPairs(\n      self,\n      spells: list[int],\n      potions: list[int],\n      success: int,\n  ) -> list[int]:\n    potions.sort()\n\n    def firstIndexSuccess(spell: int):\n      \"\"\"Returns the first index i s.t. spell * potions[i] >= success.\"\"\"\n      l = 0\n      r = len(potions)\n      while l < r:\n        m = (l + r) // 2\n        if spell * potions[m] >= success:\n          r = m\n        else:\n          l = m + 1\n      return l\n\n    return [len(potions) - firstIndexSuccess(spell) for spell in spells]",
      "title": "2300. Successful Pairs of Spells and Potions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b88526b0-0174-4eb5-abf9-0bb1c717945b",
      "code": "class Solution:\n  def matchReplacement(\n      self,\n      s: str,\n      sub: str,\n      mappings: list[list[str]],\n  ) -> bool:\n    isMapped = [[False] * 128 for _ in range(128)]\n\n    for old, new in mappings:\n      isMapped[ord(old)][ord(new)] = True\n\n    for i in range(len(s)):\n      if self._canTransform(s, i, sub, isMapped):\n        return True\n\n    return False\n\n  def _canTransform(\n      self,\n      s: str,\n      start: int,\n      sub: str,\n      isMapped: list[list[bool]],\n  ) -> bool:\n    if start + len(sub) > len(s):\n      return False\n\n    for i in range(len(sub)):\n      a = sub[i]\n      b = s[start + i]\n      if a != b and not isMapped[ord(a)][ord(b)]:\n        return False\n\n    return True",
      "title": "2301. Match Substring After Replacement",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "908b829b-0492-49a6-9dd8-fd974319d428",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      summ += num\n      while summ * (r - l + 1) >= k:\n        summ -= nums[l]\n        l += 1\n      ans += r - l + 1\n\n    return ans",
      "title": "2302. Count Subarrays With Score Less Than K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4afb138a-2d0d-4f95-84da-fa9baf097f88",
      "code": "class Solution:\n  def calculateTax(self, brackets: list[list[int]], income: int) -> float:\n    ans = 0\n    prev = 0\n\n    for upper, percent in brackets:\n      if income < upper:\n        return ans + (income - prev) * percent / 100.0\n      ans += (upper - prev) * percent / 100.0\n      prev = upper\n\n    return ans",
      "title": "2303. Calculate Amount Paid in Taxes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65d09159-4bd5-40d3-8afa-f91a123a9522",
      "code": "class Solution:\n  def minPathCost(\n      self,\n      grid: list[list[int]],\n      moveCost: list[list[int]],\n  ) -> int:\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j] := the minimum cost to reach grid[i][j]\n    dp = [[math.inf] * n for _ in range(m)]\n    dp[0] = grid[0]\n\n    for i in range(1, m):\n      for j in range(n):\n        for k in range(n):\n          dp[i][j] = min(dp[i][j], dp[i - 1][k] +\n                         moveCost[grid[i - 1][k]][j] + grid[i][j])\n\n    return min(dp[-1])",
      "title": "2304. Minimum Path Cost in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52aa7dfb-1f43-42f7-9eb1-8e3d7310ffc6",
      "code": "class Solution:\n  def distributeCookies(self, cookies: list[int], k: int) -> int:\n    ans = math.inf\n\n    def dfs(s: int, children: list[int]) -> None:\n      nonlocal ans\n      if s == len(cookies):\n        ans = min(ans, max(children))\n        return\n\n      for i in range(k):\n        children[i] += cookies[s]\n        dfs(s + 1, children)\n        children[i] -= cookies[s]\n\n    dfs(0, [0] * k)\n    return ans",
      "title": "2305. Fair Distribution of Cookies",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "188c9900-c769-4bd3-8e42-31eea1b2f3fc",
      "code": "class Solution:\n  def distinctNames(self, ideas: list[str]) -> int:\n    ans = 0\n    # suffixes[i] := the set of strings omitting the first letter, where the\n    # first letter is ('a' + i)\n    suffixes = [set() for _ in range(26)]\n\n    for idea in ideas:\n      suffixes[ord(idea[0]) - ord('a')].add(idea[1:])\n\n    for i, j in itertools.combinations(range(26), 2):\n      count = len(suffixes[i] & suffixes[j])\n      ans += 2 * (len(suffixes[i]) - count) * (len(suffixes[j]) - count)\n\n    return ans",
      "title": "2306. Naming a Company",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51993cc4-351d-4212-a80d-2b34a2d82dd9",
      "code": "class Solution:\n  def checkContradictions(\n      self,\n      equations: list[list[str]],\n      values: list[float],\n  ) -> bool:\n    # Convert `string` to `int` for a better perfermance.\n    strToInt = {}\n\n    for u, v in equations:\n      strToInt.setdefault(u, len(strToInt))\n      strToInt.setdefault(v, len(strToInt))\n\n    graph = [[] for _ in range(len(strToInt))]\n    seen = [0.0] * len(graph)\n\n    for i, ((A, B), value) in enumerate(zip(equations, values)):\n      u = strToInt[A]\n      v = strToInt[B]\n      graph[u].append((v, value))\n      graph[v].append((u, 1 / value))\n\n    def dfs(u: int, val: float) -> bool:\n      if seen[u]:\n        return abs(val / seen[u] - 1) > 1e-5\n\n      seen[u] = val\n      return any(dfs(v, val / w) for v, w in graph[u])\n\n    for i in range(len(graph)):\n      if not seen[i] and dfs(i, 1.0):\n        return True\n\n    return False",
      "title": "2307. Check for Contradictions in Equations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d791c67e-cf5d-4cd3-b499-f53a381573fd",
      "code": "class Solution:\n  def greatestLetter(self, s: str) -> str:\n    seen = set(s)\n\n    for i in range(25, -1, -1):\n      if (chr(ord('a') + i) in seen and\n              chr(ord('A') + i) in seen):\n        return chr(ord('A') + i)\n\n    return ''",
      "title": "2309. Greatest English Letter in Upper and Lower Case",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8a86b4c3-bf52-40e3-b1df-45e7f86ceb42",
      "code": "class Solution:\n  def minimumNumbers(self, num: int, k: int) -> int:\n    if num == 0:\n      return 0\n\n    # Assume the size of the set is n, and the numbers in the set are X1, X2,\n    # ..., Xn. Since the units digit of each number is k, X1 + X2 + ... + Xn =\n    # N * k + 10 * (x1 + x2 + ... + xn) = num. Therefore, the goal is to find\n    # the n s.t. n * k % 10 = num % 10\n    for i in range(1, 11):\n      if i * k > num + 1:\n        break\n      if i * k % 10 == num % 10:\n        return i\n\n    return -1",
      "title": "2310. Sum of Numbers With Units Digit K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "964d82ac-4982-4618-a450-ac9c96a1e7b5",
      "code": "class Solution:\n  def longestSubsequence(self, s: str, k: int) -> int:\n    oneCount = 0\n    num = 0\n    pow = 1\n\n    # Take as many 1s as possible from the right.\n    for i in reversed(range(len(s))):\n      if num + pow > k:\n        break\n      if s[i] == '1':\n        oneCount += 1\n        num += pow\n      pow *= 2\n\n    return s.count('0') + oneCount",
      "title": "2311. Longest Binary Subsequence Less Than or Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "822901b4-2f16-47ac-a5b3-2ee9a79ba25d",
      "code": "class Solution:\n  def sellingWood(self, m: int, n: int, prices: list[list[int]]) -> int:\n    # dp[i][j] := the maximum money of cutting i x j piece of wood\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for h, w, price in prices:\n      dp[h][w] = price\n\n    for i in range(1, m + 1):\n      for j in range(1, n + 1):\n        for h in range(1, i // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[h][j] + dp[i - h][j])\n        for w in range(1, j // 2 + 1):\n          dp[i][j] = max(dp[i][j], dp[i][w] + dp[i][j - w])\n\n    return dp[m][n]",
      "title": "2312. Selling Pieces of Wood",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ae221f4d-eb4a-4d61-b68a-9fddff18dd60",
      "code": "class Solution:\n  def minimumFlips(self, root: TreeNode | None, result: bool) -> int:\n    @functools.lru_cache(None)\n    def dp(root: TreeNode | None, target: bool) -> int:\n      \"\"\"Returns the minimum flips to make the subtree root become target.\"\"\"\n      if root.val in (0, 1):  # the leaf\n        return 0 if root.val == target else 1\n      if root.val == 5:  # NOT\n        return dp(root.left or root.right, not target)\n      if root.val == 2:  # OR\n        nextTargets = [(0, 1), (1, 0), (1, 1)] if target else [[0, 0]]\n      elif root.val == 3:  # AND\n        nextTargets = [(1, 1)] if target else [(0, 0), (0, 1), (1, 0)]\n      else:  # root.val == 4 XOR\n        nextTargets = [(0, 1), (1, 0)] if target else [(0, 0), (1, 1)]\n      return min(dp(root.left, leftTarget) + dp(root.right, rightTarget)\n                 for leftTarget, rightTarget in nextTargets)\n\n    return dp(root, result)",
      "title": "2313. Minimum Flips in Binary Tree to Get Result",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77225cea-1a34-4581-8459-44bc142cbeb5",
      "code": "class Solution:\n  def countAsterisks(self, s: str) -> int:\n    ans = 0\n    bars = 0\n\n    for c in s:\n      if c == '|':\n        bars += 1\n      elif c == '*' and bars % 2 == 0:\n        ans += 1\n\n    return ans",
      "title": "2315. Count Asterisks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "16c0afa4-9ca1-44ba-b80c-04d0136da4ff",
      "code": "class Solution:\n  def countPairs(self, n: int, edges: list[list[int]]) -> int:\n    ans = 0\n    graph = [[] for _ in range(n)]\n    seen = [0] * n\n    unreached = n\n\n    for u, v in edges:\n      graph[u].append(v)\n      graph[v].append(u)\n\n    for i in range(n):\n      reached = self._dfs(graph, i, seen)\n      unreached -= reached\n      ans += unreached * reached\n\n    return ans\n\n  def _dfs(self, graph: list[list[int]], u: int, seen: list[bool]) -> int:\n    if seen[u]:\n      return 0\n    seen[u] = True\n    return functools.reduce(lambda subtotal, v:\n                            subtotal + self._dfs(graph, v, seen), graph[u], 1)",
      "title": "2316. Count Unreachable Pairs of Nodes in an Undirected Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea19d4ac-2b89-4f1b-b392-3d4dd0249471",
      "code": "class Solution:\n  def maximumXOR(self, nums: list[int]) -> int:\n    # 1. nums[i] & (nums[i] ^ x) enables you to turn 1-bit to 0-bit from\n    #    nums[i] since x is arbitrary.\n    # 2. The i-th bit of the XOR of all the elements is 1 if the i-th bit is 1\n    #    for an odd number of elements.\n    # 3. Therefore, the question is equivalent to: if you can convert any digit\n    #    from 1 to 0 for any number, what is the maximum for XOR(nums[i]).\n    # 4. The maximum we can get is of course to make every digit of the answer\n    #    to be 1 if possible\n    # 5. Therefore, OR(nums[i]) is an approach.\n    return functools.reduce(operator.ior, nums)",
      "title": "2317. Maximum XOR After Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7233c795-e8a5-4b6c-bbf2-ea8b18563705",
      "code": "class Solution:\n  def distinctSequences(self, n: int) -> int:\n    MOD = 1_000_000_007\n\n    @functools.lru_cache(None)\n    def dp(n: int, prev: int, prevPrev: int) -> int:\n      \"\"\"\n      Returns the number of distinct sequences for n dices with `prev` and\n      `prevPrev`.\n      \"\"\"\n      if n == 0:\n        return 1\n      res = 0\n      for dice in range(1, 7):\n        if (dice not in (prev, prevPrev) and\n                (prev == 0 or math.gcd(dice, prev) == 1)):\n          res += dp(n - 1, dice, prev)\n          res %= MOD\n      return res\n\n    return dp(n, 0, 0)",
      "title": "2318. Number of Distinct Roll Sequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ab161c05-44de-4109-9df0-12ec7d238cec",
      "code": "class Solution:\n  def checkXMatrix(self, grid: list[list[int]]) -> bool:\n    n = len(grid)\n\n    for i in range(n):\n      for j in range(n):\n        if i == j or i + j == n - 1:  # in diagonal\n          if grid[i][j] == 0:\n            return False\n        elif grid[i][j]:   # not in diagonal\n          return False\n\n    return True",
      "title": "2319. Check if Matrix Is X-Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b0f30da3-4a6e-4ae2-990d-23cf71d41b7f",
      "code": "class Solution:\n  def countHousePlacements(self, n: int) -> int:\n    MOD = 1_000_000_007\n    house = 1  # the number of ways ending in a house\n    space = 1  # the number of ways ending in a space\n    total = house + space\n\n    for _ in range(2, n + 1):\n      house = space\n      space = total\n      total = (house + space) % MOD\n\n    return total**2 % MOD",
      "title": "2320. Count Number of Ways to Place Houses",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "353e59c0-5a97-4d32-8383-6236d6521021",
      "code": "class Solution:\n  def maximumsSplicedArray(self, nums1: list[int], nums2: list[int]) -> int:\n    def kadane(nums1: list[int], nums2: list[int]) -> int:\n      \"\"\"\n      Returns the maximum gain of swapping some numbers in `nums1` with some\n      numbers in `nums2`.\n      \"\"\"\n      gain = 0\n      maxGain = 0\n\n      for num1, num2 in zip(nums1, nums2):\n        gain = max(0, gain + num2 - num1)\n        maxGain = max(maxGain, gain)\n\n      return maxGain + sum(nums1)\n\n    return max(kadane(nums1, nums2), kadane(nums2, nums1))",
      "title": "2321. Maximum Score Of Spliced Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4cba1463-59a8-48f0-b656-ba6569b64628",
      "code": "class Solution:\n  def minimumScore(self, nums: list[int], edges: list[list[int]]) -> int:\n    n = len(nums)\n    xors = functools.reduce(operator.xor, nums)\n    subXors = nums[:]\n    tree = [[] for _ in range(n)]\n    children = [{i} for i in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> tuple[int, set[int]]:\n      for v in tree[u]:\n        if v == prev:\n          continue\n        vXor, vChildren = dfs(v, u)\n        subXors[u] ^= vXor\n        children[u] |= vChildren\n      return subXors[u], children[u]\n\n    dfs(0, -1)\n\n    ans = math.inf\n    for i in range(len(edges)):\n      a, b = edges[i]\n      if b in children[a]:\n        a, b = b, a\n      for j in range(i):\n        c, d = edges[j]\n        if d in children[c]:\n          c, d = d, c\n\n        if c in children[a] and a != c:\n          cands = [subXors[c], subXors[a] ^ subXors[c], xors ^ subXors[a]]\n        elif a in children[c] and a != c:\n          cands = [subXors[a], subXors[c] ^ subXors[a], xors ^ subXors[c]]\n        else:\n          cands = [subXors[a], subXors[c], xors ^ subXors[a] ^ subXors[c]]\n        ans = min(ans, max(cands) - min(cands))\n\n    return ans",
      "title": "2322. Minimum Score After Removals on a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bfbc6f7a-0d58-4ffe-9cee-0bd12a1c9dcf",
      "code": "class Solution:\n  def minimumTime(self, jobs: list[int], workers: list[int]) -> int:\n    ans = 0\n\n    jobs.sort()\n    workers.sort()\n\n    for job, worker in zip(jobs, workers):\n      ans = max(ans, (job - 1) // worker + 1)\n\n    return ans",
      "title": "2323. Find Minimum Time to Finish All Jobs II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d5d1857-e1ba-4b4f-8f5c-d102ebbb9cf1",
      "code": "class Solution:\n  def decodeMessage(self, key: str, message: str) -> str:\n    keyToActual = {' ': ' '}\n    currChar = 'a'\n\n    for c in key:\n      if c not in keyToActual:\n        keyToActual[c] = currChar\n        currChar = chr(ord(currChar) + 1)\n\n    return ''.join(keyToActual[c] for c in message)",
      "title": "2325. Decode the Message",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "982ef4de-868c-4ba0-80c1-2d2be7baf00c",
      "code": "class Solution:\n  def spiralMatrix(self, m: int, n: int, head: ListNode | None) -> list[list[int]]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    ans = [[-1] * n for _ in range(m)]\n    x = 0  # the current x position\n    y = 0  # the current y position\n    d = 0\n\n    curr = head\n    while curr:\n      ans[x][y] = curr.val\n      if (x + DIRS[d][0] < 0 or x + DIRS[d][0] == m or y + DIRS[d][1] < 0 or\n              y + DIRS[d][1] == n or ans[x + DIRS[d][0]][y + DIRS[d][1]] != -1):\n        d = (d + 1) % 4\n      x += DIRS[d][0]\n      y += DIRS[d][1]\n      curr = curr.next\n\n    return ans",
      "title": "2326. Spiral Matrix IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "583993dd-009f-4b83-9259-8101796605ca",
      "code": "class Solution:\n  def peopleAwareOfSecret(self, n: int, delay: int, forget: int) -> int:\n    MOD = 1_000_000_007\n    share = 0\n    # dp[i] := the number of people know the secret at day i\n    dp = [0] * n  # Maps day i to i + 1.\n    dp[0] = 1\n\n    for i in range(1, n):\n      if i - delay >= 0:\n        share += dp[i - delay]\n      if i - forget >= 0:\n        share -= dp[i - forget]\n      share += MOD\n      share %= MOD\n      dp[i] = share\n\n    # People before day `n - forget - 1` already forget the secret.\n    return sum(dp[-forget:]) % MOD",
      "title": "2327. Number of People Aware of a Secret",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "78e89bd8-0a4e-4850-91fc-9d5c3d800905",
      "code": "class Solution:\n  def countPaths(self, grid: list[list[int]]) -> int:\n    MOD = 1_000_000_007\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int) -> int:\n      \"\"\"Returns the number of increasing paths starting from (i, j).\"\"\"\n      ans = 1  # The current cell contributes 1 length.\n      for dx, dy in DIRS:\n        x = i + dx\n        y = j + dy\n        if x < 0 or x == m or y < 0 or y == n:\n          continue\n        if grid[x][y] <= grid[i][j]:\n          continue\n        ans += dp(x, y)\n        ans %= MOD\n      return ans\n\n    return sum(dp(i, j)\n               for i in range(m)\n               for j in range(n)) % MOD",
      "title": "2328. Number of Increasing Paths in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c247332-ba21-4357-97c7-531efccfc8e8",
      "code": "class Solution:\n  def makePalindrome(self, s: str) -> bool:\n    change = 0\n    l = 0\n    r = len(s) - 1\n\n    while l < r:\n      if s[l] != s[r]:\n        change += 1\n        if change > 2:\n          return False\n      l += 1\n      r -= 1\n\n    return True",
      "title": "2330. Valid Palindrome IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "257ad362-d650-4fe9-b756-fe1a3a73811b",
      "code": "class Solution:\n  def evaluateTree(self, root: TreeNode | None) -> bool:\n    if root.val < 2:\n      return root.val\n    if root.val == 2:  # OR\n      return self.evaluateTree(root.left) or self.evaluateTree(root.right)\n    # AND\n    return self.evaluateTree(root.left) and self.evaluateTree(root.right)",
      "title": "2331. Evaluate Boolean Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "94160b62-cac9-4f58-8157-c8e9ada52c88",
      "code": "class Solution:\n  def latestTimeCatchTheBus(\n      self,\n      buses: list[int],\n      passengers: list[int],\n      capacity: int,\n  ) -> int:\n    buses.sort()\n    passengers.sort()\n\n    if passengers[0] > buses[-1]:\n      return buses[-1]\n\n    ans = passengers[0] - 1\n    i = 0  # buses' index\n    j = 0  # passengers' index\n\n    while i < len(buses):\n      # Greedily make passengers catch `buses[i]`.\n      arrived = 0\n      while arrived < capacity and j < len(passengers) and passengers[j] <= buses[i]:\n        if j > 0 and passengers[j] != passengers[j - 1] + 1:\n          ans = passengers[j] - 1\n        j += 1\n        arrived += 1\n      # There's room for `buses[i]` to carry a passenger arriving at the\n      # `buses[i]`.\n      if arrived < capacity and j > 0 and passengers[j - 1] != buses[i]:\n        ans = buses[i]\n      i += 1\n\n    return ans",
      "title": "2332. The Latest Time to Catch a Bus",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ba43e968-6a9c-4143-86d7-2c483f70bc50",
      "code": "class Solution:\n  # Similar to 907. Sum of Subarray Minimums\n  def validSubarraySize(self, nums: list[int], threshold: int) -> int:\n    n = len(nums)\n    ans = 0\n    # prev[i] := the index k s.t. nums[k] is the previous minimum in nums[0..n)\n    prev = [-1] * n\n    # next[i] := the index k s.t. nums[k] is the next minimum in nums[i + 1..n)\n    next = [n] * n\n    stack = []\n\n    for i, a in enumerate(nums):\n      while stack and nums[stack[-1]] > a:\n        index = stack.pop()\n        next[index] = i\n      if stack:\n        prev[i] = stack[-1]\n      stack.append(i)\n\n    for i, (num, prevIndex, nextIndex) in enumerate(zip(nums, prev, next)):\n      k = (i - prevIndex) + (nextIndex - i) - 1\n      if num > threshold / k:\n        return k\n\n    return -1",
      "title": "2334. Subarray With Elements Greater Than Varying Threshold",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08e3ff82-37bd-424e-ba20-5a1dda0bbdce",
      "code": "class Solution:\n  def fillCups(self, amount: list[int]) -> int:\n    return max(max(amount), (sum(amount) + 1) // 2)",
      "title": "2335. Minimum Amount of Time to Fill Cups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "be1a9c18-beec-4fb5-861f-0258a852986c",
      "code": "class Solution:\n  def canChange(self, start: str, target: str) -> bool:\n    n = len(start)\n    i = 0  # start's index\n    j = 0  # target's index\n\n    while i <= n and j <= n:\n      while i < n and start[i] == '_':\n        i += 1\n      while j < n and target[j] == '_':\n        j += 1\n      if i == n or j == n:\n        return i == n and j == n\n      if start[i] != target[j]:\n        return False\n      if start[i] == 'R' and i > j:\n        return False\n      if start[i] == 'L' and i < j:\n        return False\n      i += 1\n      j += 1\n\n    return True",
      "title": "2337. Move Pieces to Obtain a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff683ac3-dfac-48ec-9330-776dece0cd23",
      "code": "class Solution:\n  def minimumSwaps(self, nums: list[int]) -> int:\n    minIndex = self._getLeftmostMinIndex(nums)\n    maxIndex = self._getRightmostMaxIndex(nums)\n    swaps = minIndex + (len(nums) - 1 - maxIndex)\n    return swaps if minIndex <= maxIndex else swaps - 1\n\n  def _getLeftmostMinIndex(self, nums: list[int]) -> int:\n    mn = nums[0]\n    minIndex = 0\n    for i in range(1, len(nums)):\n      if nums[i] < mn:\n        mn = nums[i]\n        minIndex = i\n    return minIndex\n\n  def _getRightmostMaxIndex(self, nums: list[int]) -> int:\n    mx = nums[-1]\n    maxIndex = len(nums) - 1\n    for i in range(len(nums) - 2, -1, -1):\n      if nums[i] > mx:\n        mx = nums[i]\n        maxIndex = i\n    return maxIndex",
      "title": "2340. Minimum Adjacent Swaps to Make a Valid Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "030ac07c-80fa-4371-9fc9-416558604bfe",
      "code": "class Solution:\n  def numberOfPairs(self, nums: list[int]) -> list[int]:\n    ans = [0] * 2\n    count = collections.Counter(nums)\n\n    for i in range(101):\n      ans[0] += count[i] // 2\n      ans[1] += count[i] & 1\n\n    return ans",
      "title": "2341. Maximum Number of Pairs in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8aa799e1-48b2-4ef2-a4ab-6e95f2e1171e",
      "code": "class Solution:\n  def maximumSum(self, nums: list[int]) -> int:\n    MAX = 9 * 9  # 999,999,999\n    ans = -1\n    count = [[] for _ in range(MAX + 1)]\n\n    for num in nums:\n      count[self._getDigitSum(num)].append(num)\n\n    for groupNums in count:\n      if len(groupNums) < 2:\n        continue\n      groupNums.sort(reverse=True)\n      ans = max(ans, groupNums[0] + groupNums[1])\n\n    return ans\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2342. Max Sum of a Pair With Equal Sum of Digits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8ee5cc96-163d-42ef-9697-c9e55304dd54",
      "code": "class Solution:\n  def minOperations(self, nums: list[int], numsDivide: list[int]) -> int:\n    gcd = functools.reduce(math.gcd, numsDivide)\n\n    for i, num in enumerate(sorted(nums)):\n      if gcd % num == 0:\n        return i\n\n    return -1",
      "title": "2344. Minimum Deletions to Make Array Divisible",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ea639907-7b5f-4393-b31c-eb9b3984168e",
      "code": "class Solution:\n  def visibleMountains(self, peaks: list[list[int]]) -> int:\n    ans = 0\n    maxRightFoot = 0\n\n    peaks.sort(key=lambda x: (x[0] - x[1], -x[0]))\n\n    for i, peak in enumerate(peaks):\n      overlapWithNext = i + 1 < len(peaks) and peak == peaks[i + 1]\n      currRightFoot = peak[0] + peak[1]\n      if currRightFoot > maxRightFoot:\n        if not overlapWithNext:\n          ans += 1\n        maxRightFoot = currRightFoot\n\n    return ans",
      "title": "2345. Finding the Number of Visible Mountains",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "462d7b4a-f585-4e75-abe7-47de4a51dd46",
      "code": "class Solution:\n  def bestHand(self, ranks: list[int], suits: list[str]) -> str:\n    if all(suit == suits[0] for suit in suits):\n      return 'Flush'\n\n    match max(Counter(ranks).values()):\n      case 5 | 4 | 3:\n        return 'Three of a Kind'\n      case 2:\n        return 'Pair'\n      case _:\n        return 'High Card'",
      "title": "2347. Best Poker Hand",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d493dac-60cc-40ef-81a1-a6be8437e375",
      "code": "class Solution:\n  def zeroFilledSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    indexBeforeZero = -1\n\n    for i, num in enumerate(nums):\n      if num:\n        indexBeforeZero = i\n      else:\n        ans += i - indexBeforeZero\n\n    return ans",
      "title": "2348. Number of Zero-Filled Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "785c1a8c-3267-4e2b-99ec-a046b5ce99b4",
      "code": "class Solution:\n  def shortestSequence(self, rolls: list[int], k: int) -> int:\n    ans = 1  # the the next target length\n    seen = set()\n\n    for roll in rolls:\n      seen.add(roll)\n      if len(seen) == k:\n        # Have all combinations that form `ans` length, and we are going to\n        # extend the sequence to `ans + 1` length.\n        ans += 1\n        seen.clear()\n\n    return ans",
      "title": "2350. Shortest Impossible Sequence of Rolls",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e2affaa-dc72-498d-8a56-8ed73dfb1960",
      "code": "class Solution:\n  def repeatedCharacter(self, s: str) -> str:\n    seen = [False] * 26\n\n    for c in s:\n      if seen[ord(c) - ord('a')]:\n        return c\n      seen[ord(c) - ord('a')] = True",
      "title": "2351. First Letter to Appear Twice",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a82f20f3-942c-449c-b41b-145af6867540",
      "code": "class Solution:\n  def equalPairs(self, grid: list[list[int]]) -> int:\n    n = len(grid)\n    ans = 0\n\n    for i in range(n):\n      for j in range(n):\n        k = 0\n        while k < n:\n          if grid[i][k] != grid[k][j]:\n            break\n          k += 1\n        if k == n:  # R[i] == C[j]\n          ans += 1\n\n    return ans",
      "title": "2352. Equal Row and Column Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b6250076-5079-4584-ad82-680508b121c9",
      "code": "class Solution:\n  def countExcellentPairs(self, nums: list[int], k: int) -> int:\n    count = collections.Counter(map(int.bit_count, set(nums)))\n    return sum(count[i] * count[j]\n               for i in count\n               for j in count\n               if i + j >= k)",
      "title": "2354. Number of Excellent Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db2f6fe7-7c76-40c7-8711-5fc6f8b2e6e0",
      "code": "class Solution:\n  def maximumBooks(self, books: list[int]) -> int:\n    # dp[i] := the maximum the number of books we can take from books[0..i] with taking all of\n    # books[i]\n    dp = [0] * len(books)\n    stack = []  # the possible indices we can reach\n\n    for i, book in enumerate(books):\n      # We may take all of books[j], where books[j] < books[i] - (i - j).\n      while stack and books[stack[-1]] >= book - (i - stack[-1]):\n        stack.pop()\n      # We can now take books[j + 1..i].\n      j = stack[-1] if stack else -1\n      lastPicked = book - (i - j) + 1\n      if lastPicked > 1:\n        # book + (book - 1) + ... + (book - (i - j) + 1)\n        dp[i] = (book + lastPicked) * (i - j) // 2\n      else:\n        # 1 + 2 + ... + book\n        dp[i] = book * (book + 1) // 2\n      if j >= 0:\n        dp[i] += dp[j]\n      stack.append(i)\n\n    return max(dp)",
      "title": "2355. Maximum Number of Books You Can Take",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "84bf96d3-d7f4-4cea-9100-7138724d216a",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    return len(set(nums) - {0})",
      "title": "2357. Make Array Zero by Subtracting Equal Amounts",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8de4d439-11ff-43ad-9ce3-3854e92e253c",
      "code": "class Solution:\n  def maximumGroups(self, grades: list[int]) -> int:\n    # Sort grades, then we can seperate the students into groups of sizes 1, 2,\n    # 3, ..., k, s.t. the i-th group < the (i + 1)-th group for both sum and\n    # size. So, we can rephrase the problem into:\n    #   Find the maximum k s.t. 1 + 2 + 3 + ... + k <= n\n\n    #  1 + 2 + 3 + ... + k <= n\n    #         k(k + 1) // 2 <= n\n    #              k^2 + k <= 2n\n    #   (k + 0.5)^2 - 0.25 <= 2n\n    #          (k + 0.5)^2 <= 2n + 0.25\n    #                    k <= sqrt(2n + 0.25) - 0.5\n    return int(math.sqrt(len(grades) * 2 + 0.25) - 0.5)",
      "title": "2358. Maximum Number of Groups Entering a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2ddc8ea0-72ce-4c6c-a0fe-00b69400cac0",
      "code": "class Solution:\n  def closestMeetingNode(self, edges: list[int], node1: int, node2: int) -> int:\n    MAX = 10000\n    dist1 = self._getDist(edges, node1)\n    dist2 = self._getDist(edges, node2)\n    minDist = MAX\n    ans = -1\n\n    for i, (d1, d2) in enumerate(zip(dist1, dist2)):\n      if min(d1, d2) >= 0:\n        maxDist = max(d1, d2)\n        if maxDist < minDist:\n          minDist = maxDist\n          ans = i\n\n    return ans\n\n  def _getDist(self, edges: list[int], u: int) -> list[int]:\n    dist = [-1] * len(edges)\n    d = 0\n    while u != -1 and dist[u] == -1:\n      dist[u] = d\n      d += 1\n      u = edges[u]\n    return dist",
      "title": "2359. Find Closest Node to Given Two Nodes",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7b238445-3ae7-46b2-8ea2-f5265e5a7436",
      "code": "class Solution:\n  def longestCycle(self, edges: list[int]) -> int:\n    ans = -1\n    time = 1\n    timeVisited = [0] * len(edges)\n\n    for i, edge in enumerate(edges):\n      if timeVisited[i]:\n        continue\n      startTime = time\n      u = i\n      while u != -1 and not timeVisited[u]:\n        timeVisited[u] = time\n        time += 1\n        u = edges[u]  # Move to the next node.\n      if u != -1 and timeVisited[u] >= startTime:\n        ans = max(ans, time - timeVisited[u])\n\n    return ans",
      "title": "2360. Longest Cycle in a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a13d7120-0201-4844-804c-3b0d3a6d667b",
      "code": "class Solution:\n  def minimumCosts(\n      self,\n      regular: list[int],\n      express: list[int],\n      expressCost: int,\n  ) -> list[int]:\n    n = len(regular)\n    ans = [0] * n\n    # the minimum cost to reach the current stop in a regular route\n    dpReg = 0\n    # the minimum cost to reach the current stop in an express route\n    dpExp = expressCost\n\n    for i in range(n):\n      prevReg = dpReg\n      prevExp = dpExp\n      dpReg = min(prevReg + regular[i], prevExp + 0 + regular[i])\n      dpExp = min(prevReg + expressCost + express[i], prevExp + express[i])\n      ans[i] = min(dpReg, dpExp)\n\n    return ans",
      "title": "2361. Minimum Costs Using the Train Line",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "08266242-d255-4164-8a06-cfc91eea6057",
      "code": "class Solution:\n  def mergeSimilarItems(self, items1: list[list[int]],\n                        items2: list[list[int]]) -> list[list[int]]:\n    return sorted(\n        (Counter(dict(items1)) + collections.Counter(dict(items2))).items())",
      "title": "2363. Merge Similar Items",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cec85233-97f1-4a91-a9c5-3490dcdbf52f",
      "code": "class Solution:\n  def countBadPairs(self, nums: list[int]) -> int:\n    ans = 0\n    count = collections.Counter()  # (nums[i] - i)\n\n    for i, num in enumerate(nums):\n      #     count[nums[i] - i] := the number of good pairs\n      # i - count[nums[i] - i] := the number of bad pairs\n      ans += i - count[num - i]\n      count[num - i] += 1\n\n    return ans",
      "title": "2364. Count Number of Bad Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6033203a-dab9-46bc-9a02-0d69d4763a1c",
      "code": "class Solution:\n  def taskSchedulerII(self, tasks: list[int], space: int) -> int:\n    taskToNextAvailable = collections.defaultdict(int)\n    ans = 0\n\n    for task in tasks:\n      ans = max(ans + 1, taskToNextAvailable[task])\n      taskToNextAvailable[task] = ans + space + 1\n\n    return ans",
      "title": "2365. Task Scheduler II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "54eeb20c-0699-40ff-8c3c-0098fefef98f",
      "code": "class Solution:\n  def minimumReplacement(self, nums: list[int]) -> int:\n    ans = 0\n    mx = nums[-1]\n\n    for i in range(len(nums) - 2, -1, -1):\n      ops = (nums[i] - 1) // mx\n      ans += ops\n      mx = nums[i] // (ops + 1)\n\n    return ans",
      "title": "2366. Minimum Replacements to Sort the Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82b64670-eabf-4a14-89c0-4268ca355db3",
      "code": "class Solution:\n  def arithmeticTriplets(self, nums: list[int], diff: int) -> int:\n    MAX = 200\n    ans = 0\n    count = [False] * (MAX + 1)\n\n    for num in nums:\n      if num >= 2 * diff and count[num - diff] and count[num - 2 * diff]:\n        ans += 1\n      count[num] = True\n\n    return ans",
      "title": "2367. Number of Arithmetic Triplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "67bac226-278d-41e0-ac62-585d1b813e7e",
      "code": "class Solution:\n  def reachableNodes(\n      self,\n      n: int,\n      edges: list[list[int]],\n      restricted: list[int],\n  ) -> int:\n    tree = [[] for _ in range(n)]\n    seen = set(restricted)\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int) -> int:\n      if u in seen:\n        return 0\n      seen.add(u)\n      return 1 + sum(dfs(v) for v in tree[u])\n\n    return dfs(0)",
      "title": "2368. Reachable Nodes With Restrictions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5d89e75b-7564-425d-a6bb-0bbf05ac4cad",
      "code": "class Solution:\n  def validPartition(self, nums: list[int]) -> bool:\n    n = len(nums)\n    # dp[i] := True if there's a valid partition for the first i numbers\n    dp = [False] * (n + 1)\n    dp[0] = True\n    dp[2] = nums[0] == nums[1]\n\n    for i in range(3, n + 1):\n      dp[i] = (\n          dp[i - 2] and nums[i - 2] == nums[i - 1]) or (\n          dp[i - 3]\n          and (\n              (nums[i - 3] == nums[i - 2] and nums[i - 2] == nums[i - 1])\n              or (\n                  nums[i - 3] + 1 == nums[i - 2] and nums[i - 2] + 1 == nums\n                  [i - 1])))\n\n    return dp[n]",
      "title": "2369. Check if There is a Valid Partition For The Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "510789e7-b2e8-4215-be70-5c64fd2761a6",
      "code": "class Solution:\n  def longestIdealString(self, s: str, k: int) -> int:\n    # dp[i] := the longest subsequence that ends in ('a' + i)\n    dp = [0] * 26\n\n    for c in s:\n      i = ord(c) - ord('a')\n      dp[i] = 1 + self._getMaxReachable(dp, i, k)\n\n    return max(dp)\n\n  def _getMaxReachable(self, dp: list[int], i: int, k: int) -> int:\n    first = max(0, i - k)\n    last = min(25, i + k)\n    maxReachable = 0\n    for j in range(first, last + 1):\n      maxReachable = max(maxReachable, dp[j])\n    return maxReachable",
      "title": "2370. Longest Ideal Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65e372e9-f74d-40f3-bf46-81eab810244d",
      "code": "class Solution:\n  def minScore(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    valAndIndices = []\n    rows = [0] * m  # rows[i] := the maximum used number so far\n    cols = [0] * n  # cols[j] := the maximum used number so far\n\n    for i in range(m):\n      for j in range(n):\n        valAndIndices.append((grid[i][j], i, j))\n\n    valAndIndices.sort()\n\n    for _, i, j in valAndIndices:\n      nextAvailable = max(rows[i], cols[j]) + 1\n      ans[i][j] = nextAvailable\n      rows[i] = nextAvailable\n      cols[j] = nextAvailable\n\n    return ans",
      "title": "2371. Minimize Maximum Value in a Grid",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23783600-e661-4507-b91b-6802c86d164a",
      "code": "class Solution:\n  def largestLocal(self, grid: list[list[int]]) -> list[list[int]]:\n    n = len(grid)\n    ans = [[0] * (n - 2) for _ in range(n - 2)]\n\n    for i in range(n - 2):\n      for j in range(n - 2):\n        for x in range(i, i + 3):\n          for y in range(j, j + 3):\n            ans[i][j] = max(ans[i][j], grid[x][y])\n\n    return ans",
      "title": "2373. Largest Local Values in a Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8e43d74-6fb6-427f-a1c7-3882ab75b749",
      "code": "class Solution:\n  def edgeScore(self, edges: list[int]) -> int:\n    scores = [0] * len(edges)\n    for i, edge in enumerate(edges):\n      scores[edge] += i\n    return scores.index(max(scores))",
      "title": "2374. Node With Highest Edge Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "51ad53c8-904a-4719-83d8-d6f45d9d6762",
      "code": "class Solution:\n  def smallestNumber(self, pattern: str) -> str:\n    ans = []\n    stack = ['1']\n\n    for c in pattern:\n      maxSorFar = stack[-1]\n      if c == 'I':\n        while stack:\n          maxSorFar = max(maxSorFar, stack[-1])\n          ans.append(stack.pop())\n      stack.append(chr(ord(maxSorFar) + 1))\n\n    while stack:\n      ans.append(stack.pop())\n\n    return ''.join(ans)",
      "title": "2375. Construct Smallest Number From DI String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4897f5a8-efe4-4e87-b554-528f7093ffa6",
      "code": "class Solution:\n  # Same as 1012. Numbers With Repeated Digits\n  def countSpecialNumbers(self, n: int) -> int:\n    s = str(n)\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int, tight: bool) -> int:\n      \"\"\"\n      Returns the number of special integers, considering the i-th digit, where\n      `used` is the bitmask of the used digits, and `tight` indicates if the\n      current digit is tightly bound.\n      \"\"\"\n      if i == len(s):\n        return 1\n\n      res = 0\n      maxDigit = int(s[i]) if tight else 9\n\n      for d in range(maxDigit + 1):\n        # `d` is used.\n        if used >> d & 1:\n          continue\n        # Use `d` now.\n        nextTight = tight and (d == maxDigit)\n        if used == 0 and d == 0:  # Don't count leading 0s as used.\n          res += dp(i + 1, used, nextTight)\n        else:\n          res += dp(i + 1, used | 1 << d, nextTight)\n\n      return res\n\n    return dp(0, 0, True) - 1  # - 0",
      "title": "2376. Count Special Integers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c3a173ac-1009-448a-ab4c-b50d4b7dac6a",
      "code": "class Solution:\n  def maxScore(self, edges: list[list[int]]) -> int:\n    n = len(edges)\n    graph = [[] for _ in range(n)]\n\n    for i, (parent, weight) in enumerate(edges):\n      if parent != -1:\n        graph[parent].append((i, weight))\n\n    takeRoot, notTakeRoot = self._dfs(graph, 0)\n    return max(takeRoot, notTakeRoot)\n\n  def _dfs(self, graph: list[list[int]], u: int) -> tuple[int, int]:\n    \"\"\"\n    Returns (the maximum sum at u if we take one u->v edge,\n             the maximum sum at u if we don't take any child edge).\n    \"\"\"\n    bestEdge = 0\n    notTakeU = 0\n\n    for v, w in graph[u]:\n      takeV, notTakeV = self._dfs(graph, v)\n      bestEdge = max(bestEdge, w + notTakeV - takeV)\n      notTakeU += takeV\n\n    return (bestEdge + notTakeU, notTakeU)",
      "title": "2378. Choose Edges to Maximize Score in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "788bf67f-d740-46fd-9105-8ac02e84c8e7",
      "code": "class Solution:\n  def minimumRecolors(self, blocks: str, k: int) -> int:\n    countB = 0\n    maxCountB = 0\n\n    for i, block in enumerate(blocks):\n      if block == 'B':\n        countB += 1\n      if i >= k and blocks[i - k] == 'B':\n        countB -= 1\n      maxCountB = max(maxCountB, countB)\n\n    return k - maxCountB",
      "title": "2379. Minimum Recolors to Get K Consecutive Black Blocks",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a19dc264-235e-4a81-8247-a5ff8d2abb11",
      "code": "class Solution:\n  def secondsToRemoveOccurrences(self, s: str) -> int:\n    ans = 0\n    zeros = 0\n\n    for c in s:\n      if c == '0':\n        zeros += 1\n      elif zeros > 0:  # c == '1'\n        ans = max(ans + 1, zeros)\n\n    return ans",
      "title": "2380. Time Needed to Rearrange a Binary String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57fa8301-2d72-45ee-b10b-92437f5c26df",
      "code": "class Solution:\n  def shiftingLetters(self, s: str, shifts: list[list[int]]) -> str:\n    ans = []\n    currShift = 0\n    line = [0] * (len(s) + 1)\n\n    for start, end, direction in shifts:\n      diff = 1 if direction else -1\n      line[start] += diff\n      line[end + 1] -= diff\n\n    for i, c in enumerate(s):\n      currShift = (currShift + line[i]) % 26\n      num = (ord(c) - ord('a') + currShift + 26) % 26\n      ans.append(chr(ord('a') + num))\n\n    return ''.join(ans)",
      "title": "2381. Shifting Letters II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a1f04249-b911-47d0-a7ac-f7ae77768dce",
      "code": "class Solution:\n  def maximumSegmentSum(\n      self,\n      nums: list[int],\n      removeQueries: list[int],\n  ) -> list[int]:\n    n = len(nums)\n    maxSum = 0\n    ans = [0] * n\n    # For the segment [l, r], record its sum in summ[l] and summ[r]\n    summ = [0] * n\n    # For the segment [l, r], record its count in count[l] and count[r]\n    count = [0] * n\n\n    for i in reversed(range(n)):\n      ans[i] = maxSum\n      j = removeQueries[i]\n\n      # Calculate `segmentSum`.\n      leftSum = summ[j - 1] if j > 0 else 0\n      rightSum = summ[j + 1] if j + 1 < n else 0\n      segmentSum = nums[j] + leftSum + rightSum\n\n      # Calculate `segmentCount`.\n      leftCount = count[j - 1] if j > 0 else 0\n      rightCount = count[j + 1] if j + 1 < n else 0\n      segmentCount = 1 + leftCount + rightCount\n\n      # Update `summ` and `count` of the segment [l, r].\n      l = j - leftCount\n      r = j + rightCount\n      summ[l] = segmentSum\n      summ[r] = segmentSum\n      count[l] = segmentCount\n      count[r] = segmentCount\n      maxSum = max(maxSum, segmentSum)\n\n    return ans",
      "title": "2382. Maximum Segment Sum After Removals",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "770719bc-bc5b-4e1a-8eff-c86130a03cdb",
      "code": "class Solution:\n  def minNumberOfHours(\n      self,\n      initialEnergy: int,\n      initialExperience: int,\n      energy: list[int],\n      experience: list[int],\n  ) -> int:\n    return (self._getRequiredEnergy(initialEnergy, energy) +\n            self._getRequiredExperience(initialExperience, experience))\n\n  def _getRequiredEnergy(self, initialEnergy: int, energy: list[int]) -> int:\n    return max(0, sum(energy) + 1 - initialEnergy)\n\n  def _getRequiredExperience(\n      self,\n      currentExperience: int,\n      experience: list[int],\n  ) -> int:\n    requiredExperience = 0\n    for e in experience:\n      if e >= currentExperience:\n        requiredExperience += e + 1 - currentExperience\n        currentExperience += e + 1 - currentExperience\n      currentExperience += e\n    return requiredExperience",
      "title": "2383. Minimum Hours of Training to Win a Competition",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0eab94c4-a5c2-4a60-809b-7c1e8f60f378",
      "code": "class Solution:\n  def largestPalindromic(self, num: str) -> str:\n    count = collections.Counter(num)\n    firstHalf = ''.join(count[i] // 2 * i for i in '9876543210').lstrip('0')\n    mid = self._getMid(count)\n    return (firstHalf + mid + firstHalf[::-1]) or '0'\n\n  def _getMid(self, count: dict[str, int]) -> str:\n    for c in '9876543210':\n      if count[c] & 1:\n        return c\n    return ''",
      "title": "2384. Largest Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9cce1581-6168-4f0f-80fe-a703d06983d4",
      "code": "class Solution:\n  def amountOfTime(self, root: TreeNode | None, start: int) -> int:\n    ans = -1\n    graph = self._getGraph(root)\n    q = collections.deque([start])\n    seen = {start}\n\n    while q:\n      ans += 1\n      for _ in range(len(q)):\n        u = q.popleft()\n        if u not in graph:\n          continue\n        for v in graph[u]:\n          if v in seen:\n            continue\n          q.append(v)\n          seen.add(v)\n\n    return ans\n\n  def _getGraph(self, root: TreeNode | None) -> dict[int, list[int]]:\n    graph = collections.defaultdict(list)\n    q = collections.deque([(root, -1)])  # (node, parent)\n\n    while q:\n      node, parent = q.popleft()\n      if parent != -1:\n        graph[parent].append(node.val)\n        graph[node.val].append(parent)\n      if node.left:\n        q.append((node.left, node.val))\n      if node.right:\n        q.append((node.right, node.val))\n\n    return graph",
      "title": "2385. Amount of Time for Binary Tree to Be Infected",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a34e13a0-92b2-4a84-8420-82f4509617d4",
      "code": "class Solution:\n  def kSum(self, nums: list[int], k: int) -> int:\n    maxSum = sum(num for num in nums if num > 0)\n    absNums = sorted(abs(num) for num in nums)\n    # (the next maximum sum, the next index i)\n    maxHeap = [(-(maxSum - absNums[0]), 0)]\n    nextMaxSum = maxSum\n\n    for _ in range(k - 1):\n      nextMaxSum, i = heapq.heappop(maxHeap)\n      nextMaxSum *= -1\n      if i + 1 < len(absNums):\n        heapq.heappush(maxHeap, (-(nextMaxSum - absNums[i + 1]), i + 1))\n        heapq.heappush(\n            maxHeap, (-(nextMaxSum - absNums[i + 1] + absNums[i]), i + 1))\n\n    return nextMaxSum",
      "title": "2386. Find the K-Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "857051c4-435d-4d45-9608-212f60f313cf",
      "code": "class Solution:\n  def matrixMedian(self, grid: list[list[int]]) -> int:\n    noGreaterThanMedianCount = len(grid) * len(grid[0]) // 2 + 1\n    l = 1\n    r = 1_000_000\n\n    while l < r:\n      m = (l + r) // 2\n      if (sum(bisect.bisect_right(row, m) for row in grid) >=\n              noGreaterThanMedianCount):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2387. Median of a Row Wise Sorted Matrix",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4dfb8600-480a-4ee0-88b2-ccb471459cca",
      "code": "class Solution:\n  def answerQueries(self, nums: list[int], queries: list[int]) -> list[int]:\n    nums.sort()\n\n    def numOfElementsLessThan(query: int) -> int:\n      summ = 0\n      for i, num in enumerate(nums):\n        summ += num\n        if summ > query:\n          return i\n      return len(nums)\n\n    return [numOfElementsLessThan(query) for query in queries]",
      "title": "2389. Longest Subsequence With Limited Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "387c5f50-5f40-4ecb-b766-b24e9aa27f2f",
      "code": "class Solution:\n  def removeStars(self, s: str) -> str:\n    ans = []\n    for c in s:\n      if c == '*':\n        ans.pop()\n      else:\n        ans.append(c)\n    return ''.join(ans)",
      "title": "2390. Removing Stars From a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "884778b8-cc7c-4672-9119-48fdcd92e3be",
      "code": "class Solution:\n  def garbageCollection(self, garbage: list[str], travel: list[int]) -> int:\n    prefix = list(itertools.accumulate(travel))\n\n    def getTime(c: str) -> int:\n      characterCount = 0\n      lastIndex = -1\n      for i, s in enumerate(garbage):\n        if any(g == c for g in s):\n          lastIndex = i\n        characterCount += s.count(c)\n      return characterCount + (0 if lastIndex <= 0 else prefix[lastIndex - 1])\n\n    return getTime('M') + getTime('P') + getTime('G')",
      "title": "2391. Minimum Amount of Time to Collect Garbage",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5cb17c4c-d10f-48b1-8957-176bf586c316",
      "code": "class Solution:\n  def buildMatrix(self, k: int, rowConditions: list[list[int]],\n                  colConditions: list[list[int]]) -> list[list[int]]:\n    rowOrder = self._topologicalSort(rowConditions, k)\n    if not rowOrder:\n      return []\n\n    colOrder = self._topologicalSort(colConditions, k)\n    if not colOrder:\n      return []\n\n    ans = [[0] * k for _ in range(k)]\n    nodeToRowIndex = [0] * (k + 1)\n\n    for i, node in enumerate(rowOrder):\n      nodeToRowIndex[node] = i\n\n    for j, node in enumerate(colOrder):\n      i = nodeToRowIndex[node]\n      ans[i][j] = node\n\n    return ans\n\n  def _topologicalSort(self, conditions: list[list[int]], n: int) -> list[int]:\n    order = []\n    graph = [[] for _ in range(n + 1)]\n    inDegrees = [0] * (n + 1)\n\n    # Build the graph.\n    for u, v in conditions:\n      graph[u].append(v)\n      inDegrees[v] += 1\n\n    # Perform topological sorting.\n    q = collections.deque([i for i in range(1, n + 1) if inDegrees[i] == 0])\n\n    while q:\n      u = q.popleft()\n      order.append(u)\n      for v in graph[u]:\n        inDegrees[v] -= 1\n        if inDegrees[v] == 0:\n          q.append(v)\n\n    return order if len(order) == n else []",
      "title": "2392. Build a Matrix With Conditions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2bea3903-56a6-4665-bdb9-3e989be79323",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int]) -> int:\n    ans = 0\n\n    j = -1\n    for i, num in enumerate(nums):\n      if i > 0 and num <= nums[i - 1]:\n        j = i - 1\n      ans += i - j\n\n    return ans",
      "title": "2393. Count Strictly Increasing Subarrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c2eb9b00-2fdd-48cf-9bd4-f1bd75471812",
      "code": "class Solution:\n  def findSubarrays(self, nums: list[int]) -> bool:\n    seen = set()\n\n    for a, b in zip(nums, nums[1:]):\n      summ = a + b\n      if summ in seen:\n        return True\n      seen.add(summ)\n\n    return False",
      "title": "2395. Find Subarrays With Equal Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "31a8a101-3b8b-4b51-b0c2-7e1535d9a96b",
      "code": "class Solution:\n  def isStrictlyPalindromic(self, n: int) -> bool:\n    return False",
      "title": "2396. Strictly Palindromic Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff0916c1-294a-455b-82b7-da096ddf5da8",
      "code": "class Solution:\n  def maximumRows(self, matrix: list[list[int]], numSelect: int) -> int:\n    ans = 0\n\n    def dfs(colIndex: int, leftColsCount: int, mask: int):\n      nonlocal ans\n      if leftColsCount == 0:\n        ans = max(ans, self._getAllZerosRowCount(matrix, mask))\n        return\n\n      if colIndex == len(matrix[0]):\n        return\n\n      # Choose this column.\n      dfs(colIndex + 1, leftColsCount - 1, mask | 1 << colIndex)\n      # Don't choose this column.\n      dfs(colIndex + 1, leftColsCount, mask)\n\n    dfs(0, numSelect, 0)\n    return ans\n\n  def _getAllZerosRowCount(self, matrix: list[list[int]], mask: int) -> int:\n    count = 0\n    for row in matrix:\n      isAllZeros = True\n      for i, num in enumerate(row):\n        if num == 1 and (mask >> i & 1) == 0:\n          isAllZeros = False\n          break\n      if isAllZeros:\n        count += 1\n    return count",
      "title": "2397. Maximum Rows Covered by Columns",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ead1d451-e286-4d89-85ec-02916ce9efb0",
      "code": "class Solution:\n  def maximumRobots(\n      self,\n      chargeTimes: list[int],\n      runningCosts: list[int],\n      budget: int,\n  ) -> int:\n    cost = 0\n    maxQ = collections.deque()  # Stores `chargeTimes[i]`.\n\n    j = 0  # window's range := [i..j], so k = i - j + 1\n    for i, (chargeTime, runningCost) in enumerate(\n            zip(chargeTimes, runningCosts)):\n      cost += runningCost\n      while maxQ and maxQ[-1] < chargeTime:\n        maxQ.pop()\n      maxQ.append(chargeTime)\n      if maxQ[0] + (i - j + 1) * cost > budget:\n        if maxQ[0] == chargeTimes[j]:\n          maxQ.popleft()\n        cost -= runningCosts[j]\n        j += 1\n\n    return len(chargeTimes) - j",
      "title": "2398. Maximum Number of Robots Within Budget",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a9903712-bd6a-4b21-a1fc-d33ecf926b94",
      "code": "class Solution:\n  def checkDistances(self, s: str, distance: list[int]) -> bool:\n    firstSeenIndex = [-1] * 26\n\n    for i, c in enumerate(s):\n      j = ord(c) - ord('a')\n      prevIndex = firstSeenIndex[j]\n      if prevIndex != -1 and i - prevIndex - 1 != distance[j]:\n        return False\n      firstSeenIndex[j] = i\n\n    return True",
      "title": "2399. Check Distances Between Same Letters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "75a54b51-da44-41b9-9ecc-4a0d97829588",
      "code": "class Solution:\n  def numberOfWays(self, startPos: int, endPos: int, k: int) -> int:\n    # leftStep + rightStep = k\n    # rightStep - leftStep = endPos - startPos\n    #        2 * rightStep = k + endPos - startPos\n    #            rightStep = (k + endPos - startPos) // 2\n    val = k + endPos - startPos\n    if val < 0 or val % 2 == 1:\n      return 0\n    rightStep = val // 2\n    leftStep = k - rightStep\n    if leftStep < 0:\n      return 0\n    return self._nCk(leftStep + rightStep, min(leftStep, rightStep))\n\n  # C(n, k) = C(n - 1, k) + C(n - 1, k - 1)\n  def _nCk(self, n: int, k: int) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := C(n so far, i)\n    dp = [1] + [0] * k\n\n    for _ in range(n):  # Calculate n times.\n      for j in range(k, 0, -1):\n        dp[j] += dp[j - 1]\n        dp[j] %= MOD\n\n    return dp[k]",
      "title": "2400. Number of Ways to Reach a Position After Exactly k Steps",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8574e93e-26e8-4b11-8850-a1c563d7a6bd",
      "code": "class Solution:\n  def longestNiceSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    used = 0\n\n    l = 0\n    for r, num in enumerate(nums):\n      while used & num:\n        used ^= nums[l]\n        l += 1\n      used |= num\n      ans = max(ans, r - l + 1)\n\n    return ans",
      "title": "2401. Longest Nice Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "60dbd5cb-ebd8-43b3-88ec-0b8d423a687f",
      "code": "class Solution:\n  def mostBooked(self, n: int, meetings: list[list[int]]) -> int:\n    count = [0] * n\n\n    meetings.sort()\n\n    occupied = []  # (endTime, roomId)\n    availableRoomIds = [i for i in range(n)]\n    heapq.heapify(availableRoomIds)\n\n    for start, end in meetings:\n      # Push meetings ending before this `meeting` in occupied to the\n      # `availableRoomsIds`.\n      while occupied and occupied[0][0] <= start:\n        heapq.heappush(availableRoomIds, heapq.heappop(occupied)[1])\n      if availableRoomIds:\n        roomId = heapq.heappop(availableRoomIds)\n        count[roomId] += 1\n        heapq.heappush(occupied, (end, roomId))\n      else:\n        newStart, roomId = heapq.heappop(occupied)\n        count[roomId] += 1\n        heapq.heappush(occupied, (newStart + (end - start), roomId))\n\n    return count.index(max(count))",
      "title": "2402. Meeting Rooms III",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b87ba684-849b-4a84-b9d8-3fd8a0479bb3",
      "code": "class Solution:\n  def minimumTime(self, power: list[int]) -> int:\n    n = len(power)\n    maxMask = 1 << n\n    # dp[i] := the minimum number of days needed to defeat the monsters, where\n    # i is the bitmask of the monsters\n    dp = [math.inf] * maxMask\n    dp[0] = 0\n\n    for mask in range(1, maxMask):\n      currentGain = mask.bit_count()\n      for i in range(n):\n        if mask >> i & 1:\n          dp[mask] = min(dp[mask], dp[mask & ~(1 << i)] +\n                         int(math.ceil(power[i] / currentGain)))\n\n    return dp[-1]",
      "title": "2403. Minimum Time to Kill All Monsters",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "80651616-5b5a-4b68-a3b2-e28c0adf7be5",
      "code": "class Solution:\n  def mostFrequentEven(self, nums: list[int]) -> int:\n    ans = -1\n    count = collections.Counter()\n\n    for num in nums:\n      if num % 2 == 1:\n        continue\n      count[num] += 1\n      newCount = count[num]\n      maxCount = count[ans]\n      if newCount > maxCount or newCount == maxCount and num < ans:\n        ans = num\n\n    return ans",
      "title": "2404. Most Frequent Even Element",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "894c76e5-0461-4759-a276-4d4fbf0bee94",
      "code": "class Solution:\n  def partitionString(self, s: str) -> int:\n    ans = 1\n    used = 0\n\n    for c in s:\n      i = ord(c) - ord('a')\n      if used >> i & 1:\n        used = 1 << i\n        ans += 1\n      else:\n        used |= 1 << i\n\n    return ans",
      "title": "2405. Optimal Partition of String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfeccbe5-5d43-4274-a786-b0cb894e5325",
      "code": "class Solution:\n  # Similar to 253. Meeting Rooms II\n  def minGroups(self, intervals: list[list[int]]) -> int:\n    minHeap = []  # Stores `right`s.\n\n    for left, right in sorted(intervals):\n      # There's no overlap, so we can reuse the same group.\n      if minHeap and left > minHeap[0]:\n        heapq.heappop(minHeap)\n      heapq.heappush(minHeap, right)\n\n    return len(minHeap)",
      "title": "2406. Divide Intervals Into Minimum Number of Groups",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6759f182-e208-4572-a361-04d0e2673aa8",
      "code": "class Solution:\n  def countDaysTogether(\n      self,\n      arriveAlice: str,\n      leaveAlice: str,\n      arriveBob: str,\n      leaveBob: str,\n  ) -> int:\n    days = [0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n\n    def toDays(s: str) -> int:\n      month = int(s[:2])\n      day = int(s[3:])\n      prevDays = 0\n      for m in range(1, month):\n        prevDays += days[m]\n      return prevDays + day\n\n    arriveA = toDays(arriveAlice)\n    leaveA = toDays(leaveAlice)\n    arriveB = toDays(arriveBob)\n    leaveB = toDays(leaveBob)\n    ans = 0\n\n    for day in range(1, 366):\n      if arriveA <= day and day <= leaveA and arriveB <= day and day <= leaveB:\n        ans += 1\n\n    return ans",
      "title": "2409. Count Days Spent Together",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "eef2ceb7-2e3e-4101-99ff-88baa1faafe9",
      "code": "class Solution:\n  def matchPlayersAndTrainers(\n      self,\n      players: list[int],\n      trainers: list[int],\n  ) -> int:\n    ans = 0\n\n    players.sort()\n    trainers.sort()\n\n    for i, trainer in enumerate(trainers):\n      if players[ans] <= trainer:\n        ans += 1\n        if ans == len(players):\n          return ans\n\n    return ans",
      "title": "2410. Maximum Matching of Players With Trainers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a258c8a6-05be-45a6-867a-c4d0d83d78bc",
      "code": "class Solution:\n  def smallestSubarrays(self, nums: list[int]) -> list[int]:\n    MAX_BIT = 30\n    ans = [1] * len(nums)\n    # closest[j] := the closest index i s.t. the j-th bit of nums[i] is 1\n    closest = [0] * MAX_BIT\n\n    for i in reversed(range(len(nums))):\n      for j in range(MAX_BIT):\n        if nums[i] >> j & 1:\n          closest[j] = i\n        ans[i] = max(ans[i], closest[j] - i + 1)\n\n    return ans",
      "title": "2411. Smallest Subarrays With Maximum Bitwise OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5e04c59b-4dee-41ec-87dc-b9f71d14834e",
      "code": "class Solution:\n  def minimumMoney(self, transactions: list[list[int]]) -> int:\n    ans = 0\n    losses = 0\n\n    # Before picking the final transaction, perform any transaction that raises\n    # the required money.\n    for cost, cashback in transactions:\n      losses += max(0, cost - cashback)\n\n    # Now, pick a transaction to be the final one.\n    for cost, cashback in transactions:\n      if cost > cashback:\n        # The losses except this transaction: losses - (cost - cashback), so\n        # add the cost of this transaction = losses - (cost - cashback) + cost.\n        ans = max(ans, losses + cashback)\n      else:\n        # The losses except this transaction: losses, so add the cost of this\n        # transaction = losses + cost.\n        ans = max(ans, losses + cost)\n\n    return ans",
      "title": "2412. Minimum Money Required Before Transactions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "709b1784-8112-4d4e-a2f3-6b78bb284d25",
      "code": "class Solution:\n  def smallestEvenMultiple(self, n: int) -> int:\n    return n * (n % 2 + 1)",
      "title": "2413. Smallest Even Multiple",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6cabf133-9ad8-4445-9a15-4b1f4b5a8c73",
      "code": "class Solution:\n  def longestContinuousSubstring(self, s: str) -> int:\n    ans = 1\n    runningLen = 1\n\n    for a, b in zip(s, s[1:]):\n      if ord(a) + 1 == ord(b):\n        runningLen += 1\n        ans = max(ans, runningLen)\n      else:\n        runningLen = 1\n\n    return ans",
      "title": "2414. Length of the Longest Alphabetical Continuous Substring",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e41c6aaf-1695-408a-ace5-85799863104a",
      "code": "class Solution:\n  def reverseOddLevels(self, root: TreeNode | None) -> TreeNode | None:\n    def dfs(left: TreeNode | None, right: TreeNode | None, isOddLevel: bool) -> None:\n      if not left:\n        return\n      if isOddLevel:\n        left.val, right.val = right.val, left.val\n      dfs(left.left, right.right, not isOddLevel)\n      dfs(left.right, right.left, not isOddLevel)\n\n    dfs(root.left, root.right, True)\n    return root",
      "title": "2415. Reverse Odd Levels of Binary Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6bfd8e70-5d13-44af-9798-5c266f6db824",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: dict[str, TrieNode] = {}\n    self.count = 0\n\n\nclass Solution:\n  def sumPrefixScores(self, words: list[str]) -> list[int]:\n    root = TrieNode()\n\n    def insert(word: str) -> None:\n      node: TrieNode = root\n      for c in word:\n        node = node.children.setdefault(c, TrieNode())\n        node.count += 1\n\n    for word in words:\n      insert(word)\n\n    def getScore(word: str) -> int:\n      node: TrieNode = root\n      score = 0\n      for c in word:\n        node = node.children[c]\n        score += node.count\n      return score\n\n    return [getScore(word) for word in words]",
      "title": "2416. Sum of Prefix Scores of Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "907bafe6-b20f-44c1-8204-cae577c37512",
      "code": "class Solution:\n  def closestFair(self, n: int) -> int:\n    digitsCount = len(str(n))\n    return (self._getEvenDigits(n) if digitsCount % 2 == 0 else\n            self._getOddDigits(digitsCount))\n\n  def _getOddDigits(self, digitsCount: int) -> int:\n    zeros = (digitsCount + 1) // 2\n    ones = (digitsCount - 1) // 2\n    return int('1' + '0' * zeros + '1' * ones)\n\n  def _getEvenDigits(self, n: int) -> int:\n    digitsCount = len(str(n))\n    maxNum = int('1' + '0' * digitsCount)\n    for num in range(n, maxNum):\n      if self._isValidNum(num):\n        return num\n    return self._getOddDigits(digitsCount + 1)\n\n  def _isValidNum(self, num: int) -> bool:\n    count = 0\n    for c in str(num):\n      count += 1 if int(c) % 2 == 0 else -1\n    return count == 0",
      "title": "2417. Closest Fair Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2f1f27cc-f0b9-40ea-b2f4-4f119514f1e5",
      "code": "class Solution:\n  def sortPeople(self, names: list[str], heights: list[int]) -> list[str]:\n    return [height for _, height in\n            sorted([(height, name) for name, height in zip(names, heights)], reverse=True)]",
      "title": "2418. Sort the People",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43ea38d4-1a71-4785-871e-7c3ce2b7fef5",
      "code": "class Solution:\n  def longestSubarray(self, nums: list[int]) -> int:\n    ans = 0\n    maxIndex = 0\n    sameNumLength = 0\n\n    for i, num in enumerate(nums):\n      if nums[i] == nums[maxIndex]:\n        sameNumLength += 1\n        ans = max(ans, sameNumLength)\n      elif nums[i] > nums[maxIndex]:\n        maxIndex = i\n        sameNumLength = 1\n        ans = 1\n      else:\n        sameNumLength = 0\n\n    return ans",
      "title": "2419. Longest Subarray With Maximum Bitwise AND",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9991a750-e8f6-41c5-a9ae-d0498b0fceda",
      "code": "class Solution:\n  # Same as 2100. Find Good Days to Rob the Bank\n  def goodIndices(self, nums: list[int], k: int) -> list[int]:\n    n = len(nums)\n    dec = [1] * n  # 1 + the number of continuous decreasing numbers before i\n    inc = [1] * n  # 1 + the number of continuous increasing numbers after i\n\n    for i in range(1, n):\n      if nums[i - 1] >= nums[i]:\n        dec[i] = dec[i - 1] + 1\n\n    for i in range(n - 2, -1, -1):\n      if nums[i] <= nums[i + 1]:\n        inc[i] = inc[i + 1] + 1\n\n    return [i for i in range(k, n - k)\n            if dec[i - 1] >= k and inc[i + 1] >= k]",
      "title": "2420. Find All Good Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57658910-df54-4485-9036-2502f78e029e",
      "code": "class Solution:\n  def minimumOperations(self, nums: list[int]) -> int:\n    ans = 0\n    l = 0\n    r = len(nums) - 1\n    leftSum = nums[0]\n    rightSum = nums[-1]\n\n    while l < r:\n      if leftSum < rightSum:\n        l += 1\n        leftSum += nums[l]\n        ans += 1\n      elif leftSum > rightSum:\n        r -= 1\n        rightSum += nums[r]\n        ans += 1\n      else:  # leftSum == rightSum\n        l += 1\n        r -= 1\n        leftSum = nums[l]\n        rightSum = nums[r]\n\n    return ans",
      "title": "2422. Merge Operations to Turn Array Into a Palindrome",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e8b4b06-b85d-4c5d-8d65-ff37e57bf718",
      "code": "class Solution:\n  def equalFrequency(self, word: str) -> bool:\n    count = collections.Counter(word)\n\n    # Try to remove each letter, then check if the frequency of all the letters\n    # in `word` are equal.\n    for c in word:\n      count[c] -= 1\n      if count[c] == 0:\n        del count[c]\n      if min(count.values()) == max(count.values()):\n        return True\n      count[c] += 1\n\n    return False",
      "title": "2423. Remove Letter To Equalize Frequency",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb9415ec-4149-48cc-8c12-773d9495b57f",
      "code": "class Solution:\n  def xorAllNums(self, nums1: list[int], nums2: list[int]) -> int:\n    xors1 = functools.reduce(operator.xor, nums1)\n    xors2 = functools.reduce(operator.xor, nums2)\n    # If the size of nums1 is m and the size of nums2 is n, then each number in\n    # nums1 is repeated n times and each number in nums2 is repeated m times.\n    return (len(nums1) % 2 * xors2) ^ (len(nums2) % 2 * xors1)",
      "title": "2425. Bitwise XOR of All Pairings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1249f171-b79c-4577-ae10-e198fb4c2405",
      "code": "class Solution:\n  def commonFactors(self, a: int, b: int) -> int:\n    gcd = math.gcd(a, b)\n    return sum(a % i == 0 and b % i == 0\n               for i in range(1, gcd + 1))",
      "title": "2427. Number of Common Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f2db5431-beec-49ce-9e7a-9c8f36e99357",
      "code": "class Solution:\n  def maxSum(self, grid: list[list[int]]) -> int:\n    return max(\n        grid[i - 1][j - 1] + grid[i - 1][j] + grid[i - 1][j + 1] + grid[i][j] +\n        grid[i + 1][j - 1] + grid[i + 1][j] + grid[i + 1][j + 1]\n        for i in range(1, len(grid) - 1) for j in range(1, len(grid[0]) - 1))",
      "title": "2428. Maximum Sum of an Hourglass",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "effb797d-f2c3-4112-98d1-b4877d8a02aa",
      "code": "class Solution:\n  def minimizeXor(self, num1: int, num2: int) -> int:\n    MAX_BIT = 30\n    bits = num2.bit_count()\n    # Can turn off all the bits in `num1`.\n    if num1.bit_count() == bits:\n      return num1\n\n    ans = 0\n\n    # Turn off the MSB if we have `bits` quota.\n    for i in reversed(range(MAX_BIT)):\n      if num1 >> i & 1:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    # Turn on the LSB if we still have `bits`.\n    for i in range(MAX_BIT):\n      if (num1 >> i & 1) == 0:\n        ans |= 1 << i\n        bits -= 1\n        if bits == 0:\n          return ans\n\n    return ans",
      "title": "2429. Minimize XOR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5674344d-7d4b-43ae-a4f9-2465d9ae8032",
      "code": "class Solution:\n  def deleteString(self, s: str) -> int:\n    n = len(s)\n    # lcs[i][j] := the number of the same letters of s[i..n) and s[j..n)\n    lcs = [[0] * (n + 1) for _ in range(n + 1)]\n    # dp[i] := the maximum number of operations needed to delete s[i..n)\n    dp = [1] * n\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i + 1, n):\n        if s[i] == s[j]:\n          lcs[i][j] = lcs[i + 1][j + 1] + 1\n        if lcs[i][j] >= j - i:\n          dp[i] = max(dp[i], dp[j] + 1)\n\n    return dp[0]",
      "title": "2430. Maximum Deletions on a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b2910ef6-c811-47cb-9f98-e581a566d6fe",
      "code": "class Solution:\n  def maxTastiness(\n      self,\n      price: list[int],\n      tastiness: list[int],\n      maxAmount: int,\n      maxCoupons: int,\n  ) -> int:\n    n = len(price)\n    # dp[i][j][k] := the maximum tastiness of the first i price with j amount of\n    # money and k coupons\n    dp = [[[0] * (maxCoupons + 1)\n           for j in range(maxAmount + 1)]\n          for i in range(n + 1)]\n\n    for i in range(1, n + 1):\n      # 1-indexed\n      currPrice = price[i - 1]\n      currTastiness = tastiness[i - 1]\n      for amount in range(maxAmount + 1):\n        for coupon in range(maxCoupons + 1):\n          # 1. Don't buy, the tastiness will be the same as the first i - 1\n          # price.\n          dp[i][amount][coupon] = dp[i - 1][amount][coupon]\n\n          # 2. Buy without coupon if have enough money.\n          if amount >= currPrice:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice][coupon] + currTastiness)\n\n          # 3. Buy with coupon if have coupon and enough money.\n          if coupon > 0 and amount >= currPrice // 2:\n            dp[i][amount][coupon] = max(\n                dp[i][amount][coupon],\n                dp[i - 1][amount - currPrice // 2][coupon - 1] + currTastiness)\n\n    return dp[n][maxAmount][maxCoupons]",
      "title": "2431. Maximize Total Tastiness of Purchased Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6ce32974-c3d6-4380-8023-382e86904e8f",
      "code": "class Solution:\n  def hardestWorker(self, n: int, logs: list[list[int]]) -> int:\n    ans = logs[0][0]\n    maxWorkingTime = logs[0][1]\n\n    for (_, prevLeaveTime), (id, leaveTime) in zip(logs, logs[1:]):\n      workingTime = leaveTime - prevLeaveTime\n      if workingTime > maxWorkingTime:\n        ans = id\n        maxWorkingTime = workingTime\n      elif workingTime == maxWorkingTime:\n        ans = min(ans, id)\n\n    return ans",
      "title": "2432. The Employee That Worked on the Longest Task",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0e9ed2ee-1435-4429-9a34-2afcdb9b5742",
      "code": "class Solution:\n  def findArray(self, pref: list[int]) -> list[int]:\n    ans = [0] * len(pref)\n\n    ans[0] = pref[0]\n    for i in range(1, len(ans)):\n      ans[i] = pref[i] ^ pref[i - 1]\n\n    return ans",
      "title": "2433. Find The Original Array of Prefix Xor",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "02788095-7a9d-4081-aba4-3e7bde458fc8",
      "code": "class Solution:\n  def robotWithString(self, s: str) -> str:\n    ans = []\n    count = collections.Counter(s)\n    stack = []\n\n    for c in s:\n      stack.append(c)\n      count[c] -= 1\n      minChar = self._getMinChar(count)\n      while stack and stack[-1] <= minChar:\n        ans.append(stack.pop())\n\n    return ''.join(ans + stack[::-1])\n\n  def _getMinChar(self, count: list[int]) -> str:\n    for c in string.ascii_lowercase:\n      if count[c]:\n        return c\n    return 'a'",
      "title": "2434. Using a Robot to Print the Lexicographically Smallest String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f0f18b4-a8d2-408f-9acb-d30e6ad68c4d",
      "code": "class Solution:\n  def numberOfPaths(self, grid: list[list[int]], k: int) -> int:\n    MOD = 1_000_000_007\n    m = len(grid)\n    n = len(grid[0])\n    # dp[i][j][sum] := the number of paths to (i, j), where the sum / k == sum\n    dp = [[[0] * k for j in range(n)] for i in range(m)]\n    dp[0][0][grid[0][0] % k] = 1\n\n    for i in range(m):\n      for j in range(n):\n        for summ in range(k):\n          newSum = (summ + grid[i][j]) % k\n          if i > 0:\n            dp[i][j][newSum] += dp[i - 1][j][summ]\n          if j > 0:\n            dp[i][j][newSum] += dp[i][j - 1][summ]\n          dp[i][j][newSum] %= MOD\n\n    return dp[m - 1][n - 1][0]",
      "title": "2435. Paths in Matrix Whose Sum Is Divisible by K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d0471467-ea4d-4b1c-8fdc-217df46d1efa",
      "code": "class Solution:\n  def minimumSplits(self, nums: list[int]) -> int:\n    ans = 1\n    gcd = nums[0]\n\n    for num in nums:\n      newGcd = math.gcd(gcd, num)\n      if newGcd > 1:\n        gcd = newGcd\n      else:\n        gcd = num\n        ans += 1\n\n    return ans",
      "title": "2436. Minimum Split Into Subarrays With GCD Greater Than One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "65ad34a4-78c5-4ace-bda1-133f70215184",
      "code": "class Solution:\n  def countTime(self, time: str) -> int:\n    ans = 1\n    if time[3] == '?':\n      ans *= 6\n    if time[4] == '?':\n      ans *= 10\n\n    if time[0] == '?' and time[1] == '?':\n      return ans * 24\n    if time[0] == '?':\n      return ans * 3 if time[1] < '4' else ans * 2\n    if time[1] == '?':\n      return ans * 4 if time[0] == '2' else ans * 10\n    return ans",
      "title": "2437. Number of Valid Clock Times",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f0dd8ae-8d07-41c8-98ed-29910227bf29",
      "code": "class Solution:\n  def productQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    MOD = 1_000_000_007\n    MAX_BIT = 30\n    ans = []\n    pows = [1 << i for i in range(MAX_BIT) if n >> i & 1]\n\n    for left, right in queries:\n      prod = 1\n      for i in range(left, right + 1):\n        prod *= pows[i]\n        prod %= MOD\n      ans.append(prod)\n\n    return ans",
      "title": "2438. Range Product Queries of Powers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1964a610-28ac-4bb2-be69-2cb580c67f5c",
      "code": "class Solution:\n  def minimizeArrayValue(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for i, num in enumerate(nums):\n      prefix += num\n      prefixAvg = math.ceil(prefix / (i + 1))\n      ans = max(ans, prefixAvg)\n\n    return ans",
      "title": "2439. Minimize Maximum of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b35b5302-0bfc-4a16-8134-9b157333f9d6",
      "code": "class Solution:\n  def componentValue(self, nums: list[int], edges: list[list[int]]) -> int:\n    MAX = 1_000_000_000\n    n = len(nums)\n    summ = sum(nums)\n    tree = [[] for _ in range(n)]\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, target: int, seen: set[bool]) -> int:\n      \"\"\"\n      Returns the sum of the subtree rooted at u substracting the sum of the\n      deleted subtrees.\n      \"\"\"\n      summ = nums[u]\n      seen.add(u)\n\n      for v in tree[u]:\n        if v in seen:\n          continue\n        summ += dfs(v, target, seen)\n        if summ > target:\n          return MAX\n\n      # Delete the tree that has sum == target.\n      if summ == target:\n        return 0\n      return summ\n\n    for i in range(n, 1, -1):\n      # Split the tree into i parts, i.e. delete (i - 1) edges.\n      if summ % i == 0 and dfs(0, summ // i, set()) == 0:\n        return i - 1\n\n    return 0",
      "title": "2440. Create Components With Same Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "af2d37b9-4504-431d-a4be-27a7de3fbfa5",
      "code": "class Solution:\n  def findMaxK(self, nums: list[int]) -> int:\n    ans = -1\n    seen = set()\n\n    for num in nums:\n      if -num in seen:\n        ans = max(ans, abs(num))\n      else:\n        seen.add(num)\n\n    return ans",
      "title": "2441. Largest Positive Integer That Exists With Its Negative",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e000dfcb-6cac-4086-9283-5e7a94d4a952",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], minK: int, maxK: int) -> int:\n    ans = 0\n    j = -1\n    prevMinKIndex = -1\n    prevMaxKIndex = -1\n\n    for i, num in enumerate(nums):\n      if num < minK or num > maxK:\n        j = i\n      if num == minK:\n        prevMinKIndex = i\n      if num == maxK:\n        prevMaxKIndex = i\n      # Any index k in [j + 1, min(prevMinKIndex, prevMaxKIndex)] can be the\n      # start of the subarray s.t. nums[k..i] satisfies the conditions.\n      ans += max(0, min(prevMinKIndex, prevMaxKIndex) - j)\n\n    return ans",
      "title": "2444. Count Subarrays With Fixed Bounds",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "66571293-7d0a-4896-a814-4b536e345e98",
      "code": "class Solution:\n  def numberOfNodes(self, n: int, queries: list[int]) -> int:\n    # flipped[i] := True if we should flip all the values in the subtree rooted\n    # at i\n    flipped = [False] * (n + 1)\n\n    for query in queries:\n      flipped[query] = flipped[query] ^ True\n\n    def dfs(label: int, value: int) -> int:\n      if label > n:\n        return 0\n      value ^= flipped[label]\n      return value + dfs(label * 2, value) + dfs(label * 2 + 1, value)\n\n    return dfs(1, 0)",
      "title": "2445. Number of Nodes With Value One",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0119e84c-c887-41c5-a5cf-e5eba5f498a9",
      "code": "class Solution:\n  def subarrayGCD(self, nums: list[int], k: int) -> int:\n    ans = 0\n    gcds = collections.Counter()\n\n    for num in nums:\n      if num % k == 0:\n        nextGcds = collections.defaultdict(int)\n        nextGcds[num] += 1\n        for prevGcd, count in gcds.items():\n          nextGcds[math.gcd(prevGcd, num)] += count\n        ans += nextGcds.get(k, 0)\n        gcds = nextGcds\n      else:\n        # The GCD streak stops, so fresh start from the next number.\n        gcds.clear()\n\n    return ans",
      "title": "2447. Number of Subarrays With GCD Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cc1bbc82-5e62-4925-ac55-eb08f730e2e7",
      "code": "class Solution:\n  def minCost(self, nums: list[int], cost: list[int]) -> int:\n    ans = 0\n    l = min(nums)\n    r = max(nums)\n\n    def getCost(target: int) -> int:\n      return sum(abs(num - target) * c for num, c in zip(nums, cost))\n\n    while l < r:\n      m = (l + r) // 2\n      cost1 = getCost(m)\n      cost2 = getCost(m + 1)\n      ans = min(cost1, cost2)\n      if cost1 < cost2:\n        r = m\n      else:\n        l = m + 1\n\n    return ans",
      "title": "2448. Minimum Cost to Make Array Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0542dd97-0972-407b-9600-4c6b3d091e6f",
      "code": "class Solution:\n  def makeSimilar(self, nums: list[int], target: list[int]) -> int:\n    nums.sort(key=lambda x: (x % 2, x))\n    target.sort(key=lambda x: (x % 2, x))\n    return sum(abs(a - b) for a, b in zip(nums, target)) // 4",
      "title": "2449. Minimum Number of Operations to Make Arrays Similar",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7e8dd399-649f-457c-a361-64e137f3daa3",
      "code": "class Solution:\n  def countDistinctStrings(self, s: str, k: int) -> int:\n    # Since the content of `s` doesn't matter, for each i in [0, n - k], we can\n    # flip s[i..i + k] or don't flip it. Therefore, there's 2^(n - k + 1) ways.\n    return pow(2, len(s) - k + 1, 1_000_000_007)",
      "title": "2450. Number of Distinct Binary Strings After Applying Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "493385fc-2110-4027-92dd-2dc6ca780714",
      "code": "class Solution:\n  def oddString(self, words: list[str]) -> str:\n    def getDiff(s: str) -> list[int]:\n      return [ord(b) - ord(a) for a, b in zip(s, s[1:])]\n\n    wordAndDiffTuples = [(word, tuple(getDiff(word))) for word in words]\n    diffTupleCount = collections.Counter()\n\n    for _, diffTuple in wordAndDiffTuples:\n      diffTupleCount[diffTuple] += 1\n\n    for word, diffTuple in wordAndDiffTuples:\n      if diffTupleCount[diffTuple] == 1:\n        return word",
      "title": "2451. Odd String Difference",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "05f8e6fd-aea8-4ff5-bdae-1057458307e1",
      "code": "class Solution:\n  def twoEditWords(\n      self,\n      queries: list[str],\n      dictionary: list[str],\n  ) -> list[str]:\n    return [query for query in queries\n            if any(sum(a != b for a, b in zip(query, word)) < 3\n                   for word in dictionary)]",
      "title": "2452. Words Within Two Edits of Dictionary",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c1bfa69-5af6-4db9-80b5-5070c29a1984",
      "code": "class Solution:\n  def destroyTargets(self, nums: list[int], space: int) -> int:\n    count = collections.Counter([num % space for num in nums])\n    maxCount = max(count.values())\n    return min(num for num in nums if count[num % space] == maxCount)",
      "title": "2453. Destroy Sequential Targets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "036d479b-23bd-4266-acac-92404b98b21a",
      "code": "class Solution:\n  def secondGreaterElement(self, nums: list[int]) -> list[int]:\n    ans = [-1] * len(nums)\n    # a decreasing stack that stores indices that met the first greater number.\n    prevStack = []\n    # a decreasing stack that stores indices.\n    currStack = []\n\n    for i, num in enumerate(nums):\n      # Indices in prevStack meet the second greater num.\n      while prevStack and nums[prevStack[-1]] < num:\n        ans[prevStack.pop()] = num\n      # Push indices that meet the first greater number from `currStack` to\n      # `prevStack`. We need a temporary array to make the indices in the\n      # `prevStack` increasing.\n      decreasingIndices = []\n      while currStack and nums[currStack[-1]] < num:\n        decreasingIndices.append(currStack.pop())\n      while decreasingIndices:\n        prevStack.append(decreasingIndices.pop())\n      currStack.append(i)\n\n    return ans",
      "title": "2454. Next Greater Element IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b5141fa1-2e0d-4f35-825b-9cfdbe11bf73",
      "code": "class Solution:\n  def averageValue(self, nums: list[int]) -> int:\n    summ = 0\n    count = 0\n\n    for num in nums:\n      if num % 6 == 0:\n        summ += num\n        count += 1\n\n    return 0 if count == 0 else summ // count",
      "title": "2455. Average Value of Even Numbers That Are Divisible by Three",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "43ec76ca-77d9-437c-b830-9c04b97d3b5c",
      "code": "class Creator:\n  def __init__(self, popularity: int, videoId: str, maxView: int):\n    self.popularity = popularity  # the popularity sum\n    self.videoId = videoId        # the video id that has the maximum view\n    self.maxView = maxView        # the maximum view of the creator\n\n\nclass Solution:\n  def mostPopularCreator(self, creators: list[str],\n                         ids: list[str],\n                         views: list[int]) -> list[list[str]]:\n    ans = []\n    maxPopularity = 0\n    nameToCreator = {}\n\n    for name, id, view in zip(creators, ids, views):\n      if name not in nameToCreator:\n        nameToCreator[name] = Creator(view, id, view)\n        maxPopularity = max(maxPopularity, view)\n        continue\n      creator = nameToCreator[name]\n      creator.popularity += view\n      maxPopularity = max(maxPopularity, creator.popularity)\n      if (creator.maxView < view or\n              creator.maxView == view and creator.videoId > id):\n        creator.videoId = id\n        creator.maxView = view\n\n    for name, creator in nameToCreator.items():\n      if creator.popularity == maxPopularity:\n        ans.append([name, creator.videoId])\n\n    return ans",
      "title": "2456. Most Popular Video Creator",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f836368a-a790-43a0-8146-b685a5837e64",
      "code": "class Solution:\n  def makeIntegerBeautiful(self, n: int, target: int) -> int:\n    ans = 0\n    power = 1\n\n    # e.g. n = 123. After tunning off the last bit by adding 7, n = 130.\n    # Effectively, we can think n as 13. That's why we do n = (n / 10) + 1.\n    while sum(map(int, str(n))) > target:\n      # the cost to turn off the last digit\n      ans += power * (10 - n % 10)\n      n = n // 10 + 1\n      power *= 10\n\n    return ans",
      "title": "2457. Minimum Addition to Make Integer Beautiful",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0039002d-8d23-45ea-a421-c717a11c9ff0",
      "code": "class Solution:\n  def treeQueries(self, root: TreeNode | None, queries: list[int]) -> list[int]:\n    @lru_cache(None)\n    def height(root: TreeNode | None) -> int:\n      if not root:\n        return 0\n      return 1 + max(height(root.left), height(root.right))\n\n    # valToMaxHeight[val] := the maximum height without the node with `val`\n    valToMaxHeight = {}\n\n    # maxHeight := the maximum height without the current node `root`\n    def dfs(root: TreeNode | None, depth: int, maxHeight: int) -> None:\n      if not root:\n        return\n      valToMaxHeight[root.val] = maxHeight\n      dfs(root.left, depth + 1, max(maxHeight, depth + height(root.right)))\n      dfs(root.right, depth + 1, max(maxHeight, depth + height(root.left)))\n\n    dfs(root, 0, 0)\n    return [valToMaxHeight[query] for query in queries]",
      "title": "2458. Height of Binary Tree After Subtree Removal Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "99404cb5-cb63-4e94-8e07-55b99ed98fb1",
      "code": "class Solution:\n  def sortArray(self, nums: list[int]) -> int:\n    n = len(nums)\n    numToIndex = [0] * n\n\n    for i, num in enumerate(nums):\n      numToIndex[num] = i\n\n    def minOps(numToIndex: list[int], zeroInBeginning: bool) -> int:\n      ops = 0\n      num = 1\n      # If zeroInBeginning, the correct index of each num is num.\n      # If not zeroInBeginning, the correct index of each num is num - 1.\n      offset = 0 if zeroInBeginning else 1\n      while num < n:\n        # 0 is in the correct index, so swap 0 with the first `numInWrongIndex`.\n        if (zeroInBeginning and numToIndex[0] == 0 or\n                not zeroInBeginning and numToIndex[0] == n - 1):\n          while numToIndex[num] == num - offset:  # num is in correct position\n            num += 1\n            if num == n:\n              return ops\n          numInWrongIndex = num\n        # 0 is in the wrong index. e.g. numToIndex[0] == 2, that means 2 is not\n        # in nums[2] because nums[2] == 0.\n        else:\n          numInWrongIndex = numToIndex[0] + offset\n        numToIndex[0], numToIndex[numInWrongIndex] = (\n            numToIndex[numInWrongIndex], numToIndex[0])\n        ops += 1\n\n    return min(minOps(numToIndex.copy(), True),\n               minOps(numToIndex.copy(), False))",
      "title": "2459. Sort Array by Moving Items to Empty Space",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a369a101-7fd1-460d-84aa-7bff94903a79",
      "code": "class Solution:\n  def applyOperations(self, nums: list[int]) -> list[int]:\n    ans = [0] * len(nums)\n\n    for i in range(len(nums) - 1):\n      if nums[i] == nums[i + 1]:\n        nums[i] *= 2\n        nums[i + 1] = 0\n\n    i = 0\n    for num in nums:\n      if num > 0:\n        ans[i] = num\n        i += 1\n\n    return ans",
      "title": "2460. Apply Operations to an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7529689b-707f-4e00-89a8-19311609aa29",
      "code": "class Solution:\n  def maximumSubarraySum(self, nums: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    distinct = 0\n    count = collections.Counter()\n\n    for i, num in enumerate(nums):\n      summ += num\n      count[num] += 1\n      if count[num] == 1:\n        distinct += 1\n      if i >= k:\n        count[nums[i - k]] -= 1\n        if count[nums[i - k]] == 0:\n          distinct -= 1\n        summ -= nums[i - k]\n      if i >= k - 1 and distinct == k:\n        ans = max(ans, summ)\n\n    return ans",
      "title": "2461. Maximum Sum of Distinct Subarrays With Length K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e34633f9-a0f6-465e-8cf2-65379744c450",
      "code": "class Solution:\n  def totalCost(self, costs: list[int], k: int, candidates: int) -> int:\n    ans = 0\n    i = 0\n    j = len(costs) - 1\n    minHeapL = []  # First half\n    minHeapR = []  # Second half\n\n    for _ in range(k):\n      while len(minHeapL) < candidates and i <= j:\n        heapq.heappush(minHeapL, costs[i])\n        i += 1\n      while len(minHeapR) < candidates and i <= j:\n        heapq.heappush(minHeapR, costs[j])\n        j -= 1\n      if not minHeapL:\n        ans += heapq.heappop(minHeapR)\n      elif not minHeapR:\n        ans += heapq.heappop(minHeapL)\n      # Both `minHeapL` and `minHeapR` are not empty.\n      elif minHeapL[0] <= minHeapR[0]:\n        ans += heapq.heappop(minHeapL)\n      else:\n        ans += heapq.heappop(minHeapR)\n\n    return ans",
      "title": "2462. Total Cost to Hire K Workers",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff198b99-c92e-44d5-89b7-e48577e93d12",
      "code": "class Solution:\n  def minimumTotalDistance(\n      self,\n      robot: list[int],\n      factory: list[list[int]],\n  ) -> int:\n    robot.sort()\n    factory.sort()\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, k: int) -> int:\n      \"\"\"\n      Returns the minimum distance to fix robot[i..n) with factory[j..n), where\n      factory[j] already fixed k robots.\n      \"\"\"\n      if i == len(robot):\n        return 0\n      if j == len(factory):\n        return math.inf\n      skipFactory = dp(i, j + 1, 0)\n      position, limit = factory[j]\n      useFactory = (dp(i + 1, j, k + 1) + abs(robot[i] - position)\n                    if limit > k else math.inf)\n      return min(skipFactory, useFactory)\n\n    return dp(0, 0, 0)",
      "title": "2463. Minimum Total Distance Traveled",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6764e64d-6c33-444b-8120-b38e470d148c",
      "code": "class Solution:\n  def validSubarraySplit(self, nums: list[int]) -> int:\n    # dp[i] := the minimum number of subarrays to validly split nums[0..i]\n    dp = [math.inf] * len(nums)\n\n    for i, num in enumerate(nums):\n      for j in range(i + 1):\n        if math.gcd(nums[j], num) > 1:\n          dp[i] = min(dp[i], 1 if j == 0 else dp[j - 1] + 1)\n\n    return -1 if dp[-1] == math.inf else dp[-1]",
      "title": "2464. Minimum Subarrays in a Valid Split",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3a737d6c-0483-48c1-b88d-ec54765dbc49",
      "code": "class Solution:\n  def distinctAverages(self, nums: list[int]) -> int:\n    n = len(nums)\n    sums = set()\n\n    nums.sort()\n\n    for i in range(n // 2):\n      sums.add(nums[i] + nums[n - 1 - i])\n\n    return len(sums)",
      "title": "2465. Number of Distinct Averages",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "23087540-3677-4e14-a3ad-4a7d41e1ffc1",
      "code": "class Solution:\n  def countGoodStrings(self, low: int, high: int, zero: int, one: int) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    # dp[i] := the number of good strings with length i\n    dp = [1] + [0] * high\n\n    for i in range(1, high + 1):\n      if i >= zero:\n        dp[i] = (dp[i] + dp[i - zero]) % MOD\n      if i >= one:\n        dp[i] = (dp[i] + dp[i - one]) % MOD\n      if i >= low:\n        ans = (ans + dp[i]) % MOD\n\n    return ans",
      "title": "2466. Count Ways To Build Good Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "90fe2e8f-48ad-40c9-aacd-841589702129",
      "code": "class Solution:\n  def mostProfitablePath(\n      self,\n      edges: list[list[int]],\n      bob: int,\n      amount: list[int],\n  ) -> int:\n    n = len(amount)\n    tree = [[] for _ in range(n)]\n    parent = [0] * n\n    aliceDist = [-1] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Fills `parent` and `aliceDist`.\n    def dfs(u: int, prev: int, d: int) -> None:\n      parent[u] = prev\n      aliceDist[u] = d\n      for v in tree[u]:\n        if aliceDist[v] == -1:\n          dfs(v, u, d + 1)\n\n    dfs(0, -1, 0)\n\n    # Modify amount athe path from node bob to node 0.\n    # For each node,\n    #   1. If Bob reaches earlier than Alice does, change the amount to 0.\n    #   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n    u = bob\n    bobDist = 0\n    while u != 0:\n      if bobDist < aliceDist[u]:\n        amount[u] = 0\n      elif bobDist == aliceDist[u]:\n        amount[u] //= 2\n      u = parent[u]\n      bobDist += 1\n\n    return self._getMoney(tree, 0, -1, amount)\n\n  def _getMoney(\n      self,\n      tree: list[list[int]],\n      u: int,\n      prev: int,\n      amount: list[int],\n  ) -> int:\n    # a leaf node\n    if len(tree[u]) == 1 and tree[u][0] == prev:\n      return amount[u]\n\n    maxPath = -math.inf\n    for v in tree[u]:\n      if v != prev:\n        maxPath = max(maxPath, self._getMoney(tree, v, u, amount))\n\n    return amount[u] + maxPath",
      "title": "2467. Most Profitable Path in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f84d6e1d-03f3-412f-bcd5-4743500e3792",
      "code": "class Solution:\n  def splitMessage(self, message: str, limit: int) -> list[str]:\n    MESSAGE_LENGTH = len(message)\n\n    def sz(num: int):\n      return len(str(num))\n\n    b = 1\n    # the total length of a: initialized with the length of \"1\"\n    aLength = sz(1)\n\n    # the total length of b := b * sz(b)\n    # The total length of \"</>\" := b * 3\n    while b * limit < b * (sz(b) + 3) + aLength + MESSAGE_LENGTH:\n      # If the length of the last suffix \"<b/b>\" := sz(b) * 2 + 3 >= limit,\n      # then it's impossible that the length of \"*<b/b>\" <= limit.\n      if sz(b) * 2 + 3 >= limit:\n        return []\n      b += 1\n      aLength += sz(b)\n\n    ans = []\n\n    i = 0\n    for a in range(1, b + 1):\n      # the length of \"<a/b>\" := sz(a) + sz(b) + 3\n      j = limit - (sz(a) + sz(b) + 3)\n      ans.append(f'{message[i:i + j]}<{a}/{b}>')\n      i += j\n\n    return ans",
      "title": "2468. Split Message Based on Limit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "537f2343-8235-4d0b-a9f1-c38af7120946",
      "code": "class Solution:\n  def convertTemperature(self, celsius: float) -> list[float]:\n    return [celsius + 273.15, celsius * 1.8 + 32]",
      "title": "2469. Convert the Temperature",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "77b73ad2-9a5f-4c94-874d-bc7702b97002",
      "code": "class Solution:\n  def subarrayLCM(self, nums: list[int], k: int) -> int:\n    ans = 0\n\n    for i, runningLcm in enumerate(nums):\n      for j in range(i, len(nums)):\n        runningLcm = math.lcm(runningLcm, nums[j])\n        if runningLcm > k:\n          break\n        if runningLcm == k:\n          ans += 1\n\n    return ans",
      "title": "2470. Number of Subarrays With LCM Equal to K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3e104fdb-4b62-4908-9373-4a64eb2d840c",
      "code": "class Solution:\n  def minimumOperations(self, root: TreeNode | None) -> int:\n    ans = 0\n    q = collections.deque([root])\n\n    # e.g. vals = [7, 6, 8, 5]\n    # [2, 1, 3, 0]: Initialize the ids based on the order of vals.\n    # [3, 1, 2, 0]: Swap 2 with 3, so 2 is in the right place (i == ids[i]).\n    # [0, 1, 2, 3]: Swap 3 with 0, so 3 is in the right place.\n    while q:\n      vals = []\n      for _ in range(len(q)):\n        node = q.popleft()\n        vals.append(node.val)\n        if node.left:\n          q.append(node.left)\n        if node.right:\n          q.append(node.right)\n      # O(n^2logn), which is not great and leads to TLE.\n      ids = [sorted(vals).index(val) for val in vals]\n      for i in range(len(ids)):\n        while ids[i] != i:\n          j = ids[i]\n          ids[i] = ids[j]\n          ids[j] = j\n          ans += 1\n\n    return ans",
      "title": "2471. Minimum Number of Operations to Sort a Binary Tree by Level",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "7dc8b888-4f1d-4477-b5ab-f91a8c26e5fe",
      "code": "class Solution:\n  def maxPalindromes(self, s: str, k: int) -> int:\n    n = len(s)\n    # dp[i] := the maximum number of substrings in the first i chars of s\n    dp = [0] * (n + 1)\n\n    def isPalindrome(l: int, r: int) -> bool:\n      \"\"\"Returns True is s[i..j) is a palindrome.\"\"\"\n      if l < 0:\n        return False\n      while l < r:\n        if s[l] != s[r]:\n          return False\n        l += 1\n        r -= 1\n      return True\n\n    # If a palindrome is a subof another palindrome, then considering\n    # the longer palindrome won't increase the number of non-overlapping\n    # palindromes. So, we only need to consider the shorter one. Also,\n    # considering palindromes with both k length and k + 1 length ensures that\n    # we look for both even and odd length palindromes.\n    for i in range(k, n + 1):\n      dp[i] = dp[i - 1]\n      # Consider palindrome with length k.\n      if isPalindrome(i - k, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k])\n      # Consider palindrome with length k + 1.\n      if isPalindrome(i - k - 1, i - 1):\n        dp[i] = max(dp[i], 1 + dp[i - k - 1])\n\n    return dp[n]",
      "title": "2472. Maximum Number of Non-overlapping Palindrome Substrings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4c70279d-c54d-4d6b-b984-38881b874fae",
      "code": "class Solution:\n  def minCost(\n      self,\n      n: int,\n      roads: list[list[int]],\n      appleCost: list[int],\n      k: int,\n  ) -> list[int]:\n    graph = [[] for _ in range(n)]\n\n    for u, v, w in roads:\n      graph[u - 1].append((v - 1, w))\n      graph[v - 1].append((u - 1, w))\n\n    return [self._dijkstra(graph, i, appleCost, k) for i in range(n)]\n\n  def _dijkstra(\n      self,\n      graph: list[list[tuple[int, int]]],\n      src: int,\n      appleCost: list[int],\n      k: int\n  ) -> int:\n    ans = math.inf\n    dist = [math.inf] * len(graph)\n\n    dist[src] = 0\n    minHeap = [(dist[src], src)]  # (d, u)\n\n    while minHeap:\n      d, u = heapq.heappop(minHeap)\n      if d > dist[u]:\n        continue\n      ans = min(ans, appleCost[u] + (k + 1) * d)\n      for v, w in graph[u]:\n        if d + w < dist[v]:\n          dist[v] = d + w\n          heapq.heappush(minHeap, (dist[v], v))\n\n    return ans",
      "title": "2473. Minimum Cost to Buy Apples",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ff06f264-fe7a-44fd-b15b-7d61abe0dce3",
      "code": "# Assume that we have 4 kinds of numbers a, b, c, and d in the count map.\n#\n# What we want is:\n#   cnt[a] * cnt[b] * cnt[c]\n#   cnt[a] * cnt[b] * cnt[d]\n#   cnt[a] * cnt[c] * cnt[d]\n#   cnt[b] * cnt[c] * cnt[d]\n#\n# The above combinations can be reduced as:\n#\n# prev                       | curr   | next\n#\n# (0)                        * cnt[a] * (cnt[b] + cnt[c] + cnt[d])\n# (cnt[a])                   * cnt[b] * (cnt[c] + cnt[d])\n# (cnt[a] + cnt[b])          * cnt[c] * (cnt[d])\n# (cnt[a] + cnt[b] + cnt[c]) * cnt[d] * (0)\n\nclass Solution:\n  def unequalTriplets(self, nums: list[int]) -> int:\n    ans = 0\n    prev = 0\n    next = len(nums)\n\n    for freq in collections.Counter(nums).values():\n      next -= freq\n      ans += prev * freq * next\n      prev += freq\n\n    return ans",
      "title": "2475. Number of Unequal Triplets in Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c621f7cd-50be-4b59-b0a8-fca1ecf9931a",
      "code": "class Solution:\n  def closestNodes(self, root: TreeNode | None, queries: list[int]) -> list[list[int]]:\n    sortedVals = []\n    self._inorder(root, sortedVals)\n\n    def getClosestPair(query: int) -> list[int]:\n      i = bisect_left(sortedVals, query)\n      # query is presented in the tree, so just use [query, query].\n      if i != len(sortedVals) and sortedVals[i] == query:\n        return [query, query]\n      # query isn't presented in the tree, so find the cloest one if possible.\n      return [-1 if i == 0 else sortedVals[i - 1],\n              -1 if i == len(sortedVals) else sortedVals[i]]\n\n    return [getClosestPair(query) for query in queries]\n\n  def _inorder(self, root: TreeNode | None, sortedVals: list[int]) -> None:\n    \"\"\"Walks the BST to collect the sorted numbers.\"\"\"\n    if not root:\n      return\n    self._inorder(root.left, sortedVals)\n    sortedVals.append(root.val)\n    self._inorder(root.right, sortedVals)",
      "title": "2476. Closest Nodes Queries in a Binary Search Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "de5b06fb-5cd1-4b41-ba85-89e0ea7b0f47",
      "code": "class Solution:\n  def minimumFuelCost(self, roads: list[list[int]], seats: int) -> int:\n    ans = 0\n    tree = [[] for _ in range(len(roads) + 1)]\n\n    for u, v in roads:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def dfs(u: int, prev: int) -> int:\n      nonlocal ans\n      people = 1 + sum(dfs(v, u) for v in tree[u] if v != prev)\n      if u > 0:\n        # the number of cars needed\n        ans += int(math.ceil(people / seats))\n      return people\n\n    dfs(0, -1)\n    return ans",
      "title": "2477. Minimum Fuel Cost to Report to the Capital",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d24c3908-6ff9-4d45-9287-70a851e4d773",
      "code": "class Solution:\n  def beautifulPartitions(self, s: str, k: int, minLength: int) -> int:\n    def isPrime(c: str) -> bool:\n      return c in '2357'\n\n    if not isPrime(s[0]) or isPrime(s[-1]):\n      return 0\n\n    MOD = 1_000_000_007\n\n    @lru_cache(None)\n    def dp(i: int, k: int) -> int:\n      \"\"\"\n      Returns the number of beautiful partitions of s[i..n) with k bars (|)\n      left.\n      \"\"\"\n      if i <= len(s) and k == 0:\n        return 1\n      if i >= len(s):\n        return 0\n\n      # Don't split between s[i - 1] and s[i].\n      ans = dp(i + 1, k) % MOD\n\n      # Split between s[i - 1] and s[i].\n      if isPrime(s[i]) and not isPrime(s[i - 1]):\n        ans += dp(i + minLength, k - 1)\n\n      return ans % MOD\n\n    return dp(minLength, k - 1)",
      "title": "2478. Number of Beautiful Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ce49a06d-80dd-4a01-94ec-b5bb11fc1184",
      "code": "class TrieNode:\n  def __init__(self):\n    self.children: list[TrieNode | None] = [None] * 2\n\n\nclass BitTrie:\n  def __init__(self, maxBit: int):\n    self.maxBit = maxBit\n    self.root = TrieNode()\n\n  def insert(self, num: int) -> None:\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      if not node.children[bit]:\n        node.children[bit] = TrieNode()\n      node = node.children[bit]\n\n  def getMaxXor(self, num: int) -> int:\n    maxXor = 0\n    node = self.root\n    for i in range(self.maxBit, -1, -1):\n      bit = num >> i & 1\n      toggleBit = bit ^ 1\n      if node.children[toggleBit]:\n        maxXor = maxXor | 1 << i\n        node = node.children[toggleBit]\n      elif node.children[bit]:\n        node = node.children[bit]\n      else:  # There's nothing in the Bit Trie.\n        return 0\n    return maxXor\n\n\nclass Solution:\n  def maxXor(self, n: int, edges: list[list[int]], values: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    treeSums = [0] * n\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    # Gets the tree sum rooted at node u.\n    def getTreeSum(u: int, prev: int) -> int:\n      treeSum = values[u] + sum(getTreeSum(v, u) for v in tree[u] if v != prev)\n      treeSums[u] = treeSum\n      return treeSum\n\n    def dfs(u: int, prev: int, bitTrie: BitTrie) -> None:\n      nonlocal ans\n      for v in tree[u]:\n        if v == prev:\n          continue\n        # Preorder to get the ans.\n        ans = max(ans, bitTrie.getMaxXor(treeSums[v]))\n        # Recursively call on the subtree rooted at node v.\n        dfs(v, u, bitTrie)\n        # Postorder to insert the tree sum rooted at node v.\n        bitTrie.insert(treeSums[v])\n\n    getTreeSum(0, -1)\n    maxBit = int(math.log2(max(treeSums[1:])))\n    # Similar to 421. Maximum XOR of Two Numbers in an Array\n    dfs(0, -1, BitTrie(maxBit))\n    return ans",
      "title": "2479. Maximum XOR of Two Non-Overlapping Subtrees",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4399cd4d-5e07-4716-a9bd-18572b4ca4b2",
      "code": "class Solution:\n  def numberOfCuts(self, n: int) -> int:\n    if n == 1:\n      return 0\n    return n // 2 if n % 2 == 0 else n",
      "title": "2481. Minimum Cuts to Divide a Circle",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e093930-b2f2-4ba8-82b8-43bf095a7127",
      "code": "class Solution:\n  def onesMinusZeros(self, grid: list[list[int]]) -> list[list[int]]:\n    m = len(grid)\n    n = len(grid[0])\n    ans = [[0] * n for _ in range(m)]\n    onesRow = [row.count(1) for row in grid]\n    onesCol = [col.count(1) for col in zip(*grid)]\n\n    for i in range(m):\n      for j in range(n):\n        ans[i][j] = (onesRow[i] + onesCol[j] -\n                     (n - onesRow[i]) - (m - onesCol[j]))\n\n    return ans",
      "title": "2482. Difference Between Ones and Zeros in Row and Column",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "caabca56-3035-479e-9187-0be9c39b68ee",
      "code": "class Solution:\n  def bestClosingTime(self, customers: str) -> int:\n    # Instead of computing the minimum penalty, we can compute the maximum profit.\n    ans = 0\n    profit = 0\n    maxProfit = 0\n\n    for i, customer in enumerate(customers):\n      profit += 1 if customer == 'Y' else -1\n      if profit > maxProfit:\n        maxProfit = profit\n        ans = i + 1\n\n    return ans",
      "title": "2483. Minimum Penalty for a Shop",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "03955a80-d81c-4869-97c8-305a37af825e",
      "code": "class Solution:\n  def countPalindromes(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n\n    for a in range(10):\n      for b in range(10):\n        pattern = f'{a}{b}.{b}{a}'\n        # dp[i] := the number of subsequences of pattern[i..n) in s, where\n        # pattern[2] can be any character\n        dp = [0] * 5 + [1]\n        for c in s:\n          for i, p in enumerate(pattern):\n            if p == '.' or p == c:\n              dp[i] += dp[i + 1]\n        ans += dp[0]\n        ans %= MOD\n\n    return ans",
      "title": "2484. Count Palindromic Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "ca79f10d-7e34-4868-81c0-866e2a9df17b",
      "code": "class Solution:\n  def pivotInteger(self, n: int) -> int:\n    # 1 + 2 + ... + x = x + ... + n\n    # (1 + x) * x // 2 = (x + n) * (n - x + 1) // 2\n    #         x + x^2 = nx - x^2 + x + n^2 - nx + n\n    #         2 * x^2 = n^2 + n\n    #               x = sqrt((n^2 + n) // 2)\n    y = (n * n + n) // 2\n    x = math.isqrt(y)\n    return x if x * x == y else -1",
      "title": "2485. Find the Pivot Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f713b3c9-3bae-41a6-945d-e37acee37366",
      "code": "class Solution:\n  def appendCharacters(self, s: str, t: str) -> int:\n    i = 0  # t's index\n\n    for c in s:\n      if c == t[i]:\n        i += 1\n        if i == len(t):\n          return 0\n\n    return len(t) - i",
      "title": "2486. Append Characters to String to Make Subsequence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9c12b0d9-5ac9-4cae-9f51-8f8c099711ab",
      "code": "class Solution:\n  def removeNodes(self, head: ListNode | None) -> ListNode | None:\n    if not head:\n      return None\n    head.next = self.removeNodes(head.next)\n    return head.next if head.next and head.val < head.next.val else head",
      "title": "2487. Remove Nodes From Linked List",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c057e71-0247-4f73-953a-cd825a8caf10",
      "code": "class Solution:\n  def countSubarrays(self, nums: list[int], k: int) -> int:\n    INDEX = nums.index(k)\n    ans = 0\n    count = collections.Counter()\n\n    balance = 0\n    for i in range(INDEX, -1, -1):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      count[balance] += 1\n\n    balance = 0\n    for i in range(INDEX, len(nums)):\n      if nums[i] < k:\n        balance -= 1\n      elif nums[i] > k:\n        balance += 1\n      # The subarray that has balance == 0 or 1 having median equal to k.\n      # So, add count[0 - balance] and count[1 - balance] to `ans`.\n      ans += count[-balance] + count[1 - balance]\n\n    return ans",
      "title": "2488. Count Subarrays With Median K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b179a669-80c9-4231-8d4e-b89609df9dd5",
      "code": "class Solution:\n  def fixedRatio(self, s: str, num1: int, num2: int) -> int:\n    # Let x := the number of 0s and y := the number of 1s in the subarray.\n    # We want x : y = num1 : num2, so our goal is to find number of subarrays\n    # with x * num2 - y * num1 = 0. To achieve this, we can use a prefix count\n    # map to record the count of the running x * num2 - y * num1. If the\n    # running x * num2 - y * num1 = prefix, then add count[prefix] to the\n    # `ans`.\n    ans = 0\n    prefix = 0\n    prefixCount = collections.Counter({0: 1})\n\n    for c in s:\n      if c == '0':\n        prefix += num2\n      else:  # c == '1'\n        prefix -= num1\n      ans += prefixCount[prefix]\n      prefixCount[prefix] += 1\n\n    return ans",
      "title": "2489. Number of Substrings With Fixed Ratio",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bdb0e1f5-13d9-4bfa-bfe7-18b6003c38fa",
      "code": "class Solution:\n  def isCircularSentence(self, sentence: str) -> bool:\n    for i, c in enumerate(sentence):\n      if c == ' ' and sentence[i - 1] != sentence[i + 1]:\n        return False\n    return sentence[0] == sentence[-1]",
      "title": "2490. Circular Sentence",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1653a6af-1c4e-4c38-a4de-65d7de4240f3",
      "code": "class Solution:\n  def dividePlayers(self, skill: list[int]) -> int:\n    n = len(skill)\n    teamSkill = sum(skill) // (n // 2)\n    ans = 0\n    count = collections.Counter(skill)\n\n    for s, freq in count.items():\n      requiredSkill = teamSkill - s\n      if count[requiredSkill] != freq:\n        return -1\n      ans += s * requiredSkill * freq\n\n    return ans // 2",
      "title": "2491. Divide Players Into Teams of Equal Skill",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6f6b2f45-ec87-4f81-95b5-ee7e1da283bb",
      "code": "class Solution:\n  def minScore(self, n: int, roads: list[list[int]]) -> int:\n    ans = math.inf\n    graph = [[] for _ in range(n + 1)]  # graph[u] := [(v, distance)]\n    q = collections.deque([1])\n    seen = {1}\n\n    for u, v, distance in roads:\n      graph[u].append((v, distance))\n      graph[v].append((u, distance))\n\n    while q:\n      u = q.popleft()\n      for v, d in graph[u]:\n        ans = min(ans, d)\n        if v in seen:\n          continue\n        q.append(v)\n        seen.add(v)\n\n    return ans",
      "title": "2492. Minimum Score of a Path Between Two Cities",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0da313a7-4699-4a98-9bd9-a6fd2b575706",
      "code": "class Solution:\n  def evenProduct(self, nums: list[int]) -> int:\n    ans = 0\n    numsBeforeEven = 0  # inclusively\n\n    # e.g. nums = [1, 0, 1, 1, 0].\n    # After meeting the first 0, set `numsBeforeEven` to 2. So, the number\n    # between index 1 to index 3 (the one before next 0) will contribute 2 to\n    # `ans`.\n    for i, num in enumerate(nums):\n      if num % 2 == 0:\n        numsBeforeEven = i + 1\n      ans += numsBeforeEven\n\n    return ans",
      "title": "2495. Number of Subarrays Having Even Product",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1081130a-0fe6-409c-92ef-2aa17a418174",
      "code": "class Solution:\n  def maximumValue(self, strs: list[str]) -> int:\n    return max(len(s) if any(c.isalpha() for c in s) else int(s)\n               for s in strs)",
      "title": "2496. Maximum Value of a String in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b4bc536b-8766-4648-9fcb-f2f0ff1f1a9d",
      "code": "class Solution:\n  def maxStarSum(self, vals: list[int], edges: list[list[int]], k: int) -> int:\n    n = len(vals)\n    ans = -math.inf\n    graph = [[] for _ in range(n)]\n\n    for u, v in edges:\n      graph[u].append((v, vals[v]))\n      graph[v].append((u, vals[u]))\n\n    for i, starSum in enumerate(vals):\n      maxHeap = []\n      for _, val in graph[i]:\n        if val > 0:\n          heapq.heappush(maxHeap, -val)\n      j = 0\n      while j < k and maxHeap:\n        starSum -= heapq.heappop(maxHeap)\n        j += 1\n      ans = max(ans, starSum)\n\n    return ans",
      "title": "2497. Maximum Star Sum of a Graph",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "001e94ce-64cb-433a-a903-201b1ff089af",
      "code": "class Solution:\n  def maxJump(self, stones: list[int]) -> int:\n    # Let's denote the forwarding path as F and the backwarding path as B.\n    # 'F1 B2 B1 F2' is no better than 'F1 B2 F2 B1' since the distance between\n    # F1 and F2 increase, resulting a larger `ans`.\n    if len(stones) == 2:\n      return stones[1] - stones[0]\n    return max(stones[i] - stones[i - 2]\n               for i in range(2, len(stones)))",
      "title": "2498. Frog Jump II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "3d2b4392-83f0-4edf-80ea-caa5763add9e",
      "code": "class Solution:\n  def minimumTotalCost(self, nums1: list[int], nums2: list[int]) -> int:\n    n = len(nums1)\n    ans = 0\n    maxFreq = 0\n    maxFreqNum = 0\n    shouldBeSwapped = 0\n    conflictedNumCount = [0] * (n + 1)\n\n    # Collect the indices i s.t. num1 == num2 and record their `maxFreq`\n    # and `maxFreqNum`.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      if num1 == num2:\n        conflictedNum = num1\n        conflictedNumCount[conflictedNum] += 1\n        if conflictedNumCount[conflictedNum] > maxFreq:\n          maxFreq = conflictedNumCount[conflictedNum]\n          maxFreqNum = conflictedNum\n        shouldBeSwapped += 1\n        ans += i\n\n    # Collect the indices with num1 != num2 that contribute less cost.\n    # This can be greedily achieved by iterating from 0 to n - 1.\n    for i, (num1, num2) in enumerate(zip(nums1, nums2)):\n      # Since we have over `maxFreq * 2` spaces, `maxFreqNum` can be\n      # successfully distributed, so no need to collectextra spaces.\n      if maxFreq * 2 <= shouldBeSwapped:\n        break\n      if num1 == num2:\n        continue\n      # The numbers == `maxFreqNum` worsen the result since they increase the\n      # `maxFreq`.\n      if num1 == maxFreqNum or num2 == maxFreqNum:\n        continue\n      shouldBeSwapped += 1\n      ans += i\n\n    return -1 if maxFreq * 2 > shouldBeSwapped else ans",
      "title": "2499. Minimum Total Cost to Make Arrays Unequal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c055931e-fdc8-4e45-9a0f-6cf0fd5ddde4",
      "code": "class Solution:\n  def deleteGreatestValue(self, grid: list[list[int]]) -> int:\n    for row in grid:\n      row.sort()\n    return sum(max(col) for col in zip(*grid))",
      "title": "2500. Delete Greatest Value in Each Row",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1b5f951-1655-47ce-9cd9-56258ecf9e5d",
      "code": "from dataclasses import dataclass\n\n\n@dataclass(frozen=True)\nclass IndexedQuery:\n  queryIndex: int\n  query: int\n\n  def __iter__(self):\n    yield self.queryIndex\n    yield self.query\n\n\nclass Solution:\n  def maxPoints(self, grid: list[list[int]], queries: list[int]) -> list[int]:\n    DIRS = ((0, 1), (1, 0), (0, -1), (-1, 0))\n    m = len(grid)\n    n = len(grid[0])\n    ans = [0] * len(queries)\n    minHeap = [(grid[0][0], 0, 0)]  # (grid[i][j], i, j)\n    seen = {(0, 0)}\n    accumulate = 0\n\n    for queryIndex, query in sorted([IndexedQuery(i, query)\n                                     for i, query in enumerate(queries)],\n                                    key=lambda x: x.query):\n      while minHeap:\n        val, i, j = heapq.heappop(minHeap)\n        if val >= query:\n          # The smallest neighbor is still larger than `query`, so no need to\n          # keep exploring. Re-push (i, j, grid[i][j]) back to the `minHeap`.\n          heapq.heappush(minHeap, (val, i, j))\n          break\n        accumulate += 1\n        for dx, dy in DIRS:\n          x = i + dx\n          y = j + dy\n          if x < 0 or x == m or y < 0 or y == n:\n            continue\n          if (x, y) in seen:\n            continue\n          heapq.heappush(minHeap, (grid[x][y], x, y))\n          seen.add((x, y))\n      ans[queryIndex] = accumulate\n\n    return ans",
      "title": "2503. Maximum Number of Points From Grid Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "accca194-5a3f-4eca-9cf2-42735a52bc65",
      "code": "class Solution:\n  def subsequenceSumOr(self, nums: list[int]) -> int:\n    ans = 0\n    prefix = 0\n\n    for num in nums:\n      prefix += num\n      ans |= num | prefix\n\n    return ans",
      "title": "2505. Bitwise OR of All Subsequence Sums",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "cfacb010-54e6-42f6-bcd9-95d9ac2894b6",
      "code": "class Solution:\n  def similarPairs(self, words: list[str]) -> int:\n    masks = [self._getMask(word) for word in words]\n    return sum(masks[i] == masks[j]\n               for i, j in itertools.combinations(range(len(masks)), 2))\n\n  def _getMask(self, word: str) -> int:\n    mask = 0\n    for c in word:\n      mask |= 1 << ord(c) - ord('a')\n    return mask",
      "title": "2506. Count Pairs Of Similar Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9378e60f-98f7-47dc-a081-07b7c7ced38a",
      "code": "class Solution:\n  def smallestValue(self, n: int) -> int:\n    def getPrimeSum(n: int) -> int:\n      primeSum = 0\n      for i in range(2, n + 1):\n        while n % i == 0:\n          n //= i\n          primeSum += i\n      return primeSum\n\n    primeSum = getPrimeSum(n)\n    while n != primeSum:\n      n = primeSum\n      primeSum = getPrimeSum(n)\n    return n",
      "title": "2507. Smallest Value After Replacing With Sum of Prime Factors",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0b8e1bb4-fdb3-46fc-a7fc-e65b0339b697",
      "code": "class Solution:\n  def isPossible(self, n: int, edges: list[list[int]]) -> bool:\n    graph = [set() for _ in range(n)]\n\n    for u, v in edges:\n      graph[u - 1].add(v - 1)\n      graph[v - 1].add(u - 1)\n\n    oddNodes = [i for i, neighbor in enumerate(\n        graph) if len(neighbor) % 2 == 1]\n    if not oddNodes:\n      return True\n    if len(oddNodes) == 2:\n      a, b = oddNodes\n      return any(a not in graph[i] and b not in graph[i] for i in range(n))\n    if len(oddNodes) == 4:\n      a, b, c, d = oddNodes\n      return ((b not in graph[a] and d not in graph[c]) or\n              (c not in graph[a] and d not in graph[b]) or\n              (d not in graph[a] and c not in graph[b]))\n    return False",
      "title": "2508. Add Edges to Make Degrees of All Nodes Even",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "42b84c27-91dd-474f-9d2d-2d5687b0f7df",
      "code": "class Solution:\n  def cycleLengthQueries(self, n: int, queries: list[list[int]]) -> list[int]:\n    def getCycleLength(a: int, b: int):\n      cycleLength = 1\n      while a != b:\n        if a > b:\n          a //= 2\n        else:\n          b //= 2\n        cycleLength += 1\n      return cycleLength\n\n    return [getCycleLength(*query) for query in queries]",
      "title": "2509. Cycle Length Queries in a Tree",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "79740539-f560-4c33-ba1a-25a58d888bb8",
      "code": "class Solution:\n  def isThereAPath(self, grid: list[list[int]]) -> bool:\n    m = len(grid)\n    n = len(grid[0])\n    if m + n - 1 & 1:\n      return False\n\n    @functools.lru_cache(None)\n    def dp(i: int, j: int, summ: int) -> bool:\n      \"\"\"\n      Returns 1 if there's a path to grid[i][j] s.t.\n      `summ` = (the number of 0s - the number of 1s).\n      \"\"\"\n      if i == m or j == n:\n        return False\n      summ += 1 if grid[i][j] == 0 else -1\n      if i == m - 1 and j == n - 1:\n        return summ == 0\n      return dp(i + 1, j, summ) or dp(i, j + 1, summ)\n\n    return dp(0, 0, 0)",
      "title": "2510. Check if There is a Path With Equal Number of 0's And 1's",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "06052880-c2b8-4736-b625-e111afa5143c",
      "code": "class Solution:\n  def captureForts(self, forts: list[int]) -> int:\n    ans = 0\n\n    j = 0\n    for i, fort in enumerate(forts):\n      if fort != 0:  # -1 or 1\n        if fort == -forts[j]:\n          ans = max(ans, i - j - 1)\n        j = i\n\n    return ans",
      "title": "2511. Maximum Enemy Forts That Can Be Captured",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "319e429a-15fd-4a36-9eff-1980f96d825c",
      "code": "class Solution:\n  def topStudents(\n      self,\n      positive_feedback: list[str],\n      negative_feedback: list[str],\n      report: list[str],\n      student_id: list[int],\n      k: int,\n  ) -> list[int]:\n    scoreAndIds = []\n    pos = set(positive_feedback)\n    neg = set(negative_feedback)\n\n    for sid, r in zip(student_id, report):\n      score = 0\n      for word in r.split():\n        if word in pos:\n          score += 3\n        if word in neg:\n          score -= 1\n      scoreAndIds.append((-score, sid))\n\n    return [sid for _, sid in sorted(scoreAndIds)[:k]]",
      "title": "2512. Reward Top K Students",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "52c25835-8dab-4192-86d7-733a483efb9f",
      "code": "class Solution:\n  def minimizeSet(\n      self,\n      divisor1: int,\n      divisor2: int,\n      uniqueCnt1: int,\n      uniqueCnt2: int,\n  ) -> int:\n    divisorLcm = math.lcm(divisor1, divisor2)\n    l = 0\n    r = 2**31 - 1\n\n    def isPossible(m: int) -> bool:\n      \"\"\"\n      Returns True if we can take uniqueCnt1 integers from [1..m] to arr1 and\n      take uniqueCnt2 integers from [1..m] to arr2.\n      \"\"\"\n      cnt1 = m - m // divisor1\n      cnt2 = m - m // divisor2\n      totalCnt = m - m // divisorLcm\n      return (cnt1 >= uniqueCnt1 and\n              cnt2 >= uniqueCnt2 and\n              totalCnt >= uniqueCnt1 + uniqueCnt2)\n\n    while l < r:\n      m = (l + r) // 2\n      if isPossible(m):\n        r = m\n      else:\n        l = m + 1\n\n    return l",
      "title": "2513. Minimize the Maximum of Two Arrays",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "91921fd0-bac9-4adf-9352-c6544d43381e",
      "code": "class Solution:\n  def countAnagrams(self, s: str) -> int:\n    ans = 1\n\n    for word in s.split():\n      ans = ans * math.factorial(len(word))\n      count = collections.Counter(word)\n      for freq in count.values():\n        ans //= math.factorial(freq)\n\n    return ans % 1_000_000_007",
      "title": "2514. Count Anagrams",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c8fce3f5-057c-4739-a4e8-a9c5a35f9d2b",
      "code": "class Solution:\n  def closetTarget(self, words: list[str], target: str, startIndex: int) -> int:\n    n = len(words)\n\n    for i in range(n):\n      if words[(startIndex + i + n) % n] == target:\n        return i\n      if words[(startIndex - i + n) % n] == target:\n        return i\n\n    return -1",
      "title": "2515. Shortest Distance to Target String in a Circular Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "faafec4b-3113-435a-bc38-750e6a5988e7",
      "code": "class Solution:\n  def takeCharacters(self, s: str, k: int) -> int:\n    n = len(s)\n    ans = n\n    count = collections.Counter(s)\n    if any(count[c] < k for c in 'abc'):\n      return -1\n\n    l = 0\n    for r, c in enumerate(s):\n      count[c] -= 1\n      while count[c] < k:\n        count[s[l]] += 1\n        l += 1\n      ans = min(ans, n - (r - l + 1))\n\n    return ans",
      "title": "2516. Take K of Each Character From Left and Right",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "226fc9ba-0176-47a9-830d-83d4ae1afb2d",
      "code": "class Solution:\n  def maximumTastiness(self, price: list[int], k: int) -> int:\n    price.sort()\n\n    def numBaskets(m: int) -> int:\n      \"\"\"Returns the number of baskets we can pick for m tastiness.\"\"\"\n      baskets = 0\n      prevPrice = -m\n      for p in price:\n        if p >= prevPrice + m:\n          prevPrice = p\n          baskets += 1\n      return baskets\n\n    l = bisect.bisect_left(range(max(price) - min(price) + 1), True,\n                           key=lambda m: numBaskets(m) < k)\n    return l - 1",
      "title": "2517. Maximum Tastiness of Candy Basket",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e5516a1d-2edf-4849-88c6-73b482dc48ed",
      "code": "class Solution:\n  def countPartitions(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    summ = sum(nums)\n    ans = pow(2, len(nums), MOD)  # 2^n % MOD\n    dp = [1] + [0] * k\n\n    for num in nums:\n      for i in range(k, num - 1, -1):\n        dp[i] += dp[i - num]\n        dp[i] %= MOD\n\n    # Substract the cases that're not satisfied.\n    for i in range(k):\n      if summ - i < k:  # Both group1 and group2 < k.\n        ans -= dp[i]\n      else:\n        ans -= dp[i] * 2\n\n    return ans % MOD",
      "title": "2518. Number of Great Partitions",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4dde5ec1-6b77-4e60-a3ef-24a0dde8144d",
      "code": "class FenwickTree:\n  def __init__(self, n: int):\n    self.sums = [0] * (n + 1)\n\n  def add(self, i: int, delta: int) -> None:\n    while i < len(self.sums):\n      self.sums[i] += delta\n      i += FenwickTree.lowbit(i)\n\n  def get(self, i: int) -> int:\n    summ = 0\n    while i > 0:\n      summ += self.sums[i]\n      i -= FenwickTree.lowbit(i)\n    return summ\n\n  @staticmethod\n  def lowbit(i: int) -> int:\n    return i & -i\n\n\nclass Solution:\n  def kBigIndices(self, nums: list[int], k: int) -> int:\n    n = len(nums)\n    leftTree = FenwickTree(n)\n    rightTree = FenwickTree(n)\n    # left[i] := the number of `nums` < nums[i] with index < i\n    left = [0] * n\n    # right[i] := the number of `nums` < nums[i] with index > i\n    right = [0] * n\n\n    for i, num in enumerate(nums):\n      left[i] = leftTree.get(num - 1)\n      leftTree.add(num, 1)\n\n    for i in range(n - 1, -1, -1):\n      right[i] = rightTree.get(nums[i] - 1)\n      rightTree.add(nums[i], 1)\n\n    return sum(l >= k and r >= k for l, r in zip(left, right))",
      "title": "2519. Count the Number of K-Big Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2aae89e3-5b43-4daa-9766-9fa691af1d23",
      "code": "class Solution:\n  def countDigits(self, num: int) -> int:\n    return sum(num % int(d) == 0 for d in str(num))",
      "title": "2520. Count the Digits That Divide a Number",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "82c20b60-a0b5-43ca-a2ea-0bb210a44554",
      "code": "class Solution:\n  def distinctPrimeFactors(self, nums: list[int]) -> int:\n    primes = set()\n\n    for num in nums:\n      self._addPrimeFactors(primes, num)\n\n    return len(primes)\n\n  def _addPrimeFactors(self, primes: set[int], num: int) -> None:\n    for divisor in range(2, num + 1):\n      if num % divisor == 0:\n        primes.add(divisor)\n        while num % divisor == 0:\n          num //= divisor",
      "title": "2521. Distinct Prime Factors of Product of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "87a3b5a0-fcfc-443b-aa4a-20b3a639c8df",
      "code": "class Solution:\n  def minimumPartition(self, s: str, k: int) -> int:\n    ans = 1\n    curr = 0\n\n    for c in s:\n      curr = curr * 10 + int(c)\n      if curr > k:\n        curr = int(c)\n        ans += 1\n      if curr > k:\n        return -1\n\n    return ans",
      "title": "2522. Partition String Into Substrings With Values at Most K",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "50e7a108-106b-4c36-9294-43e3ce708043",
      "code": "class Solution:\n  def closestPrimes(self, left: int, right: int) -> list[int]:\n    isPrime = self._sieveEratosthenes(right + 1)\n    primes = [i for i in range(left, right + 1) if isPrime[i]]\n\n    if len(primes) < 2:\n      return [-1, -1]\n\n    minDiff = math.inf\n    num1 = -1\n    num2 = -1\n\n    for a, b in zip(primes, primes[1:]):\n      diff = b - a\n      if diff < minDiff:\n        minDiff = diff\n        num1 = a\n        num2 = b\n\n    return [num1, num2]\n\n  def _sieveEratosthenes(self, n: int) -> list[bool]:\n    isPrime = [True] * n\n    isPrime[0] = False\n    isPrime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n      if isPrime[i]:\n        for j in range(i * i, n, i):\n          isPrime[j] = False\n    return isPrime",
      "title": "2523. Closest Prime Numbers in Range",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "62449b4e-3eb7-459e-9d42-6913cf0344ea",
      "code": "class Solution:\n  def maxFrequencyScore(self, nums: list[int], k: int) -> int:\n    MOD = 1_000_000_007\n    count = collections.Counter(nums[:k])\n    summ = self._getInitialSumm(count, MOD)\n    ans = summ\n\n    for i in range(k, len(nums)):\n      # Remove the leftmost number that's out-of-window.\n      leftNum = nums[i - k]\n      summ = (summ - pow(leftNum, count[leftNum], MOD) + MOD) % MOD\n      # After decreasing its frequency, if it's still > 0, then add it back.\n      count[leftNum] -= 1\n      if count[leftNum] > 0:\n        summ = (summ + pow(leftNum, count[leftNum], MOD)) % MOD\n      # Otherwise, remove it from the count map.\n      else:\n        del count[leftNum]\n      # Add the current number. Similarly, remove the current score like above.\n      rightNum = nums[i]\n      if count[rightNum] > 0:\n        summ = (summ - pow(rightNum, count[rightNum], MOD) + MOD) % MOD\n      count[rightNum] += 1\n      summ = (summ + pow(rightNum, count[rightNum], MOD)) % MOD\n      ans = max(ans, summ)\n\n    return ans\n\n  def _getInitialSumm(self, count: dict[int, int], MOD: int) -> int:\n    summ = 0\n    for num, freq in count.items():\n      summ = (summ + pow(num, freq, MOD)) % MOD\n    return summ",
      "title": "2524. Maximum Frequency Score of a Subarray",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c38c3bb0-45e1-4095-a77d-5e89072d68c8",
      "code": "class Solution:\n  def categorizeBox(\n      self,\n      length: int,\n      width: int,\n      height: int,\n      mass: int,\n  ) -> str:\n    isBulky = (length >= 10000 or\n               width >= 10000 or height >= 10000 or\n               length * width * height >= 1_000_000_000)\n    isHeavy = mass >= 100\n    if isBulky and isHeavy:\n      return 'Both'\n    if isBulky:\n      return 'Bulky'\n    if isHeavy:\n      return 'Heavy'\n    return 'Neither'",
      "title": "2525. Categorize Box According to Criteria",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4e2cbd88-dacb-4466-81a9-8f139ee777ff",
      "code": "class Solution:\n  def xorBeauty(self, nums: list[int]) -> int:\n    return functools.reduce(operator.xor, nums)",
      "title": "2527. Find Xor-Beauty of Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "34e4e366-a5e3-477e-a60c-8276699ccce8",
      "code": "class Solution:\n  def maxPower(self, stations: list[int], r: int, k: int) -> int:\n    n = len(stations)\n    left = min(stations)\n    right = sum(stations) + k + 1\n\n    def check(\n            stations: list[int],\n            additionalStations: int, minPower: int) -> bool:\n      \"\"\"Returns True if each city can have at least `minPower`.\"\"\"\n      # Initilaize `power` as the 0-th city's power - stations[r].\n      power = sum(stations[:r])\n\n      for i in range(n):\n        if i + r < n:\n          power += stations[i + r]  # `power` = sum(stations[i - r..i + r]).\n        if power < minPower:\n          requiredPower = minPower - power\n          # There're not enough stations to plant.\n          if requiredPower > additionalStations:\n            return False\n          # Greedily plant `requiredPower` power stations in the farthest place\n          # to cover as many cities as possible.\n          stations[min(n - 1, i + r)] += requiredPower\n          additionalStations -= requiredPower\n          power += requiredPower\n        if i - r >= 0:\n          power -= stations[i - r]\n\n      return True\n\n    while left < right:\n      mid = (left + right) // 2\n      if check(stations.copy(), k, mid):\n        left = mid + 1\n      else:\n        right = mid\n\n    return left - 1",
      "title": "2528. Maximize the Minimum Powered City",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "4d71fbe1-5c27-4628-8768-a5564800d4c5",
      "code": "class Solution:\n  def maximumCount(self, nums: list[int]) -> int:\n    return max(sum(num > 0 for num in nums), sum(num < 0 for num in nums))",
      "title": "2529. Maximum Count of Positive Integer and Negative Integer",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fa27ee92-3b9a-4a15-96e0-457416dfa086",
      "code": "class Solution:\n  def maxKelements(self, nums: list[int], k: int) -> int:\n    ans = 0\n    maxHeap = [-num for num in nums]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      num = -heapq.heappop(maxHeap)\n      ans += num\n      heapq.heappush(maxHeap, -math.ceil(num / 3))\n\n    return ans",
      "title": "2530. Maximal Score After Applying K Operations",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "59e963a5-c429-4e83-8587-cfb36919199d",
      "code": "class Solution:\n  def isItPossible(self, word1: str, word2: str) -> bool:\n    count1 = collections.Counter(word1)\n    count2 = collections.Counter(word2)\n    distinct1 = len(count1)\n    distinct2 = len(count2)\n\n    for a in count1:\n      for b in count2:\n        if a == b:\n          # Swapping the same letters won't change the number of distinct\n          # letters in each string, so just check if `distinct1 == distinct2`.\n          if distinct1 == distinct2:\n            return True\n          continue\n        # The calculation is meaningful only when a != b\n        # Swap a in word1 with b in word2.\n        distinctAfterSwap1 = distinct1 - (count1[a] == 1) + (count1[b] == 0)\n        distinctAfterSwap2 = distinct2 - (count2[b] == 1) + (count2[a] == 0)\n        if distinctAfterSwap1 == distinctAfterSwap2:\n          return True\n\n    return False",
      "title": "2531. Make Number of Distinct Characters Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fd36c6dd-7858-4990-9863-bcc2232a6953",
      "code": "class Solution:\n  def findCrossingTime(self, n: int, k: int, time: list[list[int]]) -> int:\n    ans = 0\n    # (leftToRight + rightToLeft, i)\n    leftBridgeQueue = [\n        (-leftToRight - rightToLeft, -i) for i,\n        (leftToRight, pickOld, rightToLeft, pickNew) in enumerate(time)]\n    rightBridgeQueue = []\n    # (time to be idle, i)\n    leftWorkers = []\n    rightWorkers = []\n\n    heapq.heapify(leftBridgeQueue)\n\n    while n > 0 or rightBridgeQueue or rightWorkers:\n      # Idle left workers get on the left bridge.\n      while leftWorkers and leftWorkers[0][0] <= ans:\n        i = heapq.heappop(leftWorkers)[1]\n        leftWorkers.pop()\n        heapq.heappush(leftBridgeQueue, (-time[i][0] - time[i][2], -i))\n      # Idle right workers get on the right bridge.\n      while rightWorkers and rightWorkers[0][0] <= ans:\n        i = heapq.heappop(rightWorkers)[1]\n        heapq.heappush(rightBridgeQueue, (-time[i][0] - time[i][2], -i))\n      if rightBridgeQueue:\n        # If the bridge is free, the worker waiting on the right side of the\n        # bridge gets to cross the bridge. If more than one worker is waiting\n        # on the right side, the one with the lowest efficiency crosses first.\n        i = -heapq.heappop(rightBridgeQueue)[1]\n        ans += time[i][2]\n        heapq.heappush(leftWorkers, (ans + time[i][3], i))\n      elif leftBridgeQueue and n > 0:\n        # If the bridge is free and no worker is waiting on the right side, and\n       # at least one box remains at the old warehouse, the worker on the left\n       # side of the river gets to cross the bridge. If more than one worker\n       # is waiting on the left side, the one with the lowest efficiency\n       # crosses first.\n        i = -heapq.heappop(leftBridgeQueue)[1]\n        ans += time[i][0]\n        heapq.heappush(rightWorkers, (ans + time[i][1], i))\n        n -= 1\n      else:\n        # Advance the time of the last crossing worker.\n        ans = min(leftWorkers[0][0] if leftWorkers and n > 0 else math.inf,\n                  rightWorkers[0][0] if rightWorkers else math.inf)\n\n    return ans",
      "title": "2532. Time to Cross a Bridge",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a6c959cb-9874-4b92-93b3-bf7862cfd035",
      "code": "class Solution:\n  def goodBinaryStrings(\n      self,\n      minLength: int,\n      maxLength: int,\n      oneGroup: int,\n      zeroGroup: int,\n  ) -> int:\n    MOD = 1_000_000_007\n    # dp[i] := the number of good binary strings with length i\n    dp = [1] + [0] * maxLength\n\n    for i in range(maxLength + 1):\n      # There are good binary strings with length i, so we can append\n      # consecutive 0s or 1s after it.\n      if dp[i] > 0:\n        appendZeros = i + zeroGroup\n        if appendZeros <= maxLength:\n          dp[appendZeros] += dp[i]\n          dp[appendZeros] %= MOD\n        appendOnes = i + oneGroup\n        if appendOnes <= maxLength:\n          dp[appendOnes] += dp[i]\n          dp[appendOnes] %= MOD\n\n    return sum(dp[minLength:]) % MOD",
      "title": "2533. Number of Good Binary Strings",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bc1aaa88-0f40-4747-8472-056853b52876",
      "code": "class Solution:\n  def differenceOfSum(self, nums: list[int]) -> int:\n    elementSum = sum(nums)\n    digitSum = self._getAllDigitSum(nums)\n    return abs(elementSum - digitSum)\n\n  def _getAllDigitSum(self, nums: list[int]) -> int:\n    return sum(self._getDigitSum(num) for num in nums)\n\n  def _getDigitSum(self, num: int) -> int:\n    return sum(int(digit) for digit in str(num))",
      "title": "2535. Difference Between Element Sum and Digit Sum of an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "bd648063-92e0-4dd7-b2aa-6101e42ee18c",
      "code": "class Solution:\n  def maxOutput(self, n: int, edges: list[list[int]], price: list[int]) -> int:\n    ans = 0\n    tree = [[] for _ in range(n)]\n    maxSums = [0] * n  # maxSums[i] := the maximum the sum of path rooted at i\n\n    for u, v in edges:\n      tree[u].append(v)\n      tree[v].append(u)\n\n    def maxSum(u: int, prev: int) -> int:\n      maxChildSum = 0\n      for v in tree[u]:\n        if v != prev:\n          maxChildSum = max(maxChildSum, maxSum(v, u))\n      maxSums[u] = price[u] + maxChildSum\n      return maxSums[u]\n\n    # Precalculate `maxSums`.\n    maxSum(0, -1)\n\n    def reroot(u: int, prev: int, parentSum: int) -> None:\n      nonlocal ans\n      # Get the top two subtree sums and the top one node index.\n      maxSubtreeSum1 = 0\n      maxSubtreeSum2 = 0\n      maxNode = -1\n      for v in tree[u]:\n        if v == prev:\n          continue\n        if maxSums[v] > maxSubtreeSum1:\n          maxSubtreeSum2 = maxSubtreeSum1\n          maxSubtreeSum1 = maxSums[v]\n          maxNode = v\n        elif maxSums[v] > maxSubtreeSum2:\n          maxSubtreeSum2 = maxSums[v]\n\n      if len(tree[u]) == 1:\n        ans = max(ans, parentSum, maxSubtreeSum1)\n\n      for v in tree[u]:\n        if v == prev:\n          continue\n        nextParentSum = (\n            price[u] + max(parentSum, maxSubtreeSum2) if v == maxNode else\n            price[u] + max(parentSum, maxSubtreeSum1))\n        reroot(v, u, nextParentSum)\n\n    reroot(0, -1, 0)\n    return ans",
      "title": "2538. Difference Between Maximum and Minimum Price Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "196e5800-efb7-4910-85d0-84e2000fb22b",
      "code": "class Solution:\n  def countGoodSubsequences(self, s: str) -> int:\n    MOD = 1_000_000_007\n    ans = 0\n    count = collections.Counter(s)\n\n    @functools.lru_cache(None)\n    def fact(i: int) -> int:\n      return 1 if i <= 1 else i * fact(i - 1) % MOD\n\n    @functools.lru_cache(None)\n    def inv(i: int) -> int:\n      return pow(i, MOD - 2, MOD)\n\n    @functools.lru_cache(None)\n    def nCk(n: int, k: int) -> int:\n      return fact(n) * inv(fact(k)) * inv(fact(n - k)) % MOD\n\n    for freq in range(1, max(count.values()) + 1):\n      numSubseqs = 1  # \"\"\n      for charFreq in count.values():\n        if charFreq >= freq:\n          numSubseqs = numSubseqs * (1 + nCk(charFreq, freq)) % MOD\n      ans += numSubseqs - 1  # Minus \"\".\n      ans %= MOD\n\n    return ans",
      "title": "2539. Count the Number of Good Subsequences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "8d3fb9f4-6938-4446-b45a-38491244a67a",
      "code": "class Solution:\n  def getCommon(self, nums1: list[int], nums2: list[int]) -> int:\n    i = 0  # nums1's index\n    j = 0  # nums2's index\n\n    while i < len(nums1) and j < len(nums2):\n      if nums1[i] == nums2[j]:\n        return nums1[i]\n      if nums1[i] < nums2[j]:\n        i += 1\n      else:\n        j += 1\n\n    return -1",
      "title": "2540. Minimum Common Value",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a8720ef7-7132-4c01-ab21-c2c4bcf328f6",
      "code": "class Solution:\n  def minOperations(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    if k == 0:\n      return 0 if nums1 == nums2 else -1\n\n    ans = 0\n    opsDiff = 0  # the number of increments - number of decrements\n\n    for num1, num2 in zip(nums1, nums2):\n      diff = num1 - num2\n      if diff == 0:\n        continue\n      if diff % k != 0:\n        return -1\n      ops = diff // k\n      opsDiff += ops\n      ans += abs(ops)\n\n    return ans // 2 if opsDiff == 0 else -1",
      "title": "2541. Minimum Operations to Make Array Equal II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "c1842971-d6b9-4728-adef-7a17ca602ea8",
      "code": "class Solution:\n  # Same as 1383. Maximum Performance of a Team\n  def maxScore(self, nums1: list[int], nums2: list[int], k: int) -> int:\n    ans = 0\n    summ = 0\n    # (nums2[i], nums1[i]) sorted by nums2[i] in descending order\n    A = sorted([(num2, num1)\n               for num1, num2 in zip(nums1, nums2)], reverse=True)\n    minHeap = []\n\n    for num2, num1 in A:\n      heapq.heappush(minHeap, num1)\n      summ += num1\n      if len(minHeap) > k:\n        summ -= heapq.heappop(minHeap)\n      if len(minHeap) == k:\n        ans = max(ans, summ * num2)\n\n    return ans",
      "title": "2542. Maximum Subsequence Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e04b754f-371c-4e00-9bc2-0c814b59621b",
      "code": "class Solution:\n  def isReachable(self, targetX: int, targetY: int) -> bool:\n    return math.gcd(targetX, targetY).bit_count() == 1",
      "title": "2543. Check if Point Is Reachable",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e45e62eb-cac9-44ac-b579-0911c16eefe7",
      "code": "class Solution:\n  def alternateDigitSum(self, n: int) -> int:\n    ans = 0\n    sign = 1\n\n    while n > 0:\n      sign *= -1\n      ans += n % 10 * sign\n      n //= 10\n\n    return sign * ans",
      "title": "2544. Alternating Digit Sum",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "905e3916-e0fa-4385-9719-29c52603de77",
      "code": "class Solution:\n  def sortTheStudents(self, score: list[list[int]], k: int) -> list[list[int]]:\n    return sorted(score, key=lambda x: -x[k])",
      "title": "2545. Sort the Students by Their Kth Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "e00ec945-ff60-417a-a9f7-56e4a6cb6950",
      "code": "class Solution:\n  def makeStringsEqual(self, s: str, target: str) -> bool:\n    return ('1' in s) == ('1' in target)",
      "title": "2546. Apply Bitwise Operations to Make Strings Equal",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d5ecc4e9-91ef-4d2a-8d38-c5a21566b927",
      "code": "class Solution:\n  def minCost(self, nums: list[int], k: int) -> int:\n    MAX = 1001\n    n = len(nums)\n    # trimmedLength[i][j] := trimmed(nums[i..j]).length\n    trimmedLength = [[0] * n for _ in range(n)]\n    # dp[i] := the minimum cost to split nums[i..n)\n    dp = [math.inf] * n + [0]\n\n    for i in range(n):\n      length = 0\n      count = [0] * MAX\n      for j in range(i, n):\n        count[nums[j]] += 1\n        if count[nums[j]] == 2:\n          length += 2\n        elif count[nums[j]] > 2:\n          length += 1\n        trimmedLength[i][j] = length\n\n    dp[n] = 0\n\n    for i in range(n - 1, -1, -1):\n      for j in range(i, n):\n        dp[i] = min(dp[i], k + trimmedLength[i][j] + dp[j + 1])\n\n    return dp[0]",
      "title": "2547. Minimum Cost to Split an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1d604b93-23a2-472a-a250-7fdfe3cac7a5",
      "code": "class Solution:\n  def maxPrice(self, items: list[list[int]], capacity: int) -> float:\n    ans = 0\n\n    # Sort items based on price//weight.\n    for price, weight in sorted(items, key=lambda x: -x[0] / x[1]):\n      # The bag is filled.\n      if capacity <= weight:\n        return ans + price * capacity / weight\n      ans += price\n      capacity -= weight\n\n    return -1",
      "title": "2548. Maximum Price to Fill a Bag",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "db4076c9-4b71-46dd-b6c9-94e1aeacd177",
      "code": "class Solution:\n  def distinctIntegers(self, n: int) -> int:\n    return max(n - 1, 1)",
      "title": "2549. Count Distinct Numbers on Board",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6a4d940a-22ca-4874-80de-ac8c2d3991f1",
      "code": "class Solution:\n  def monkeyMove(self, n: int) -> int:\n    MOD = 1_000_000_007\n    res = pow(2, n, MOD) - 2\n    return res + MOD if res < 0 else res",
      "title": "2550. Count Collisions of Monkeys on a Polygon",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "d9a7e19c-5645-4851-9018-55c1de3fddd6",
      "code": "class Solution:\n  def putMarbles(self, weights: list[int], k: int) -> int:\n    # To distribute marbles into k bags, there will be k - 1 cuts. If there's a\n    # cut after weights[i], then weights[i] and weights[i + 1] will be added to\n    # the cost. Also, no matter how we cut, weights[0] and weights[n - 1] will\n    # be counted. So, the goal is to find the max//min k - 1 weights[i] +\n    # weights[i + 1].\n\n    # weights[i] + weights[i + 1]\n    arr = [a + b for a, b in itertools.pairwise(weights)]\n    return sum(heapq.nlargest(k - 1, arr)) - sum(heapq.nsmallest(k - 1, arr))",
      "title": "2551. Put Marbles in Bags",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b842826c-4cec-4b82-9d9e-1777b1393665",
      "code": "class Solution:\n  def countQuadruplets(self, nums: list[int]) -> int:\n    ans = 0\n    # dp[j] := the number of triplets (i, j, k) where i < j < k and nums[i] < nums[k] <\n    # nums[j]. Keep this information for l to use later.\n    dp = [0] * len(nums)\n\n    # k can be treated as l.\n    for k in range(2, len(nums)):\n      numLessThanK = 0\n      # j can be treated as i.\n      for j in range(k):\n        if nums[j] < nums[k]:\n          numLessThanK += 1  # nums[i] < nums[k]\n          # nums[j] < nums[l], so we should add dp[j] since we find a new\n          # quadruplets for (i, j, k, l).\n          ans += dp[j]\n        elif nums[j] > nums[k]:\n          dp[j] += numLessThanK\n\n    return ans",
      "title": "2552. Count Increasing Quadruplets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2d6fa3db-2ef2-4288-9acf-501218f7a343",
      "code": "class Solution:\n  def separateDigits(self, nums: list[int]) -> list[int]:\n    return [int(c) for num in nums for c in str(num)]",
      "title": "2553. Separate the Digits in an Array",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "9bc0b56e-45e9-4b15-ae15-84bc32e0bc48",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    ans = 0\n    summ = 0\n    bannedSet = set(banned)\n\n    for i in range(1, n + 1):\n      if i not in bannedSet and summ + i <= maxSum:\n        ans += 1\n        summ += i\n\n    return ans",
      "title": "2554. Maximum Number of Integers to Choose From a Range I",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "35e11649-fc28-4d96-840d-b76f8763a291",
      "code": "class Solution:\n  def maximizeWin(self, prizePositions: list[int], k: int) -> int:\n    ans = 0\n    # dp[i] := the maximum number of prizes to choose the first i\n    # `prizePositions`\n    dp = [0] * (len(prizePositions) + 1)\n\n    j = 0\n    for i, prizePosition in enumerate(prizePositions):\n      while prizePosition - prizePositions[j] > k:\n        j += 1\n      covered = i - j + 1\n      dp[i + 1] = max(dp[i], covered)\n      ans = max(ans, dp[j] + covered)\n\n    return ans",
      "title": "2555. Maximize Win From Two Segments",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b180fcf5-da84-4090-a67d-6fe26a40e2c3",
      "code": "class Solution:\n  def isPossibleToCutPath(self, grid: list[list[int]]) -> bool:\n    # Returns True is there's a path from (0, 0) to (m - 1, n - 1).\n    # Also marks the visited path as 0 except (m - 1, n - 1).\n    def hasPath(i: int, j: int) -> bool:\n      if i == len(grid) or j == len(grid[0]):\n        return False\n      if i == len(grid) - 1 and j == len(grid[0]) - 1:\n        return True\n      if grid[i][j] == 0:\n        return False\n\n      grid[i][j] = 0\n      # Go down first. Since we use OR logic, we'll only mark one path.\n      return hasPath(i + 1, j) or hasPath(i, j + 1)\n\n    if not hasPath(0, 0):\n      return True\n    # Reassign (0, 0) as 1.\n    grid[0][0] = 1\n    return not hasPath(0, 0)",
      "title": "2556. Disconnect Path in a Binary Matrix by at Most One Flip",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f276f6b4-a244-4b8f-b7f6-290bf944f9e8",
      "code": "class Solution:\n  def maxCount(self, banned: list[int], n: int, maxSum: int) -> int:\n    bannedSet = set(banned)\n    l = 1\n    r = n\n\n    while l < r:\n      m = (l + r + 1) // 2\n      if self._getSum(bannedSet, m) > maxSum:\n        r = m - 1\n      else:\n        l = m\n\n    return l - sum(b <= l for b in banned)\n\n  # Returns sum([1..m]) - sum(bannedSet).\n  def _getSum(self, bannedSet: set[int], m: int) -> int:\n    return m * (m + 1) // 2 - sum(b for b in bannedSet if b <= m)",
      "title": "2557. Maximum Number of Integers to Choose From a Range II",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b7a62a88-5406-4b42-9e61-2a0ffb8c3499",
      "code": "class Solution:\n  def pickGifts(self, gifts: list[int], k: int) -> int:\n    maxHeap = [-gift for gift in gifts]\n    heapq.heapify(maxHeap)\n\n    for _ in range(k):\n      squaredMax = math.isqrt(-heapq.heappop(maxHeap))\n      heapq.heappush(maxHeap, -squaredMax)\n\n    return -sum(maxHeap)",
      "title": "2558. Take Gifts From the Richest Pile",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "11e9dfe1-3268-4814-b607-7d0ab198441e",
      "code": "class Solution:\n  def vowelStrings(\n      self,\n      words: list[str],\n      queries: list[list[int]],\n  ) -> list[int]:\n    VOWELS = 'aeiou'\n    # prefix[i] := the number of the first i words that start with and end in a vowel\n    prefix = [0] * (len(words) + 1)\n\n    for i, word in enumerate(words):\n      prefix[i + 1] += prefix[i] + (word[0] in VOWELS and word[-1] in VOWELS)\n\n    return [prefix[r + 1] - prefix[l]\n            for l, r in queries]",
      "title": "2559. Count Vowel Strings in Ranges",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "0817c381-c39d-4159-b1eb-b219a6f7fc74",
      "code": "class Solution:\n  def minCapability(self, nums: list[int], k: int) -> int:\n    def numStolenHouses(capacity: int) -> int:\n      stolenHouses = 0\n      i = 0\n      while i < len(nums):\n        if nums[i] <= capacity:\n          stolenHouses += 1\n          i += 1\n        i += 1\n      return stolenHouses\n\n    return bisect.bisect_left(range(max(nums)), k, key=numStolenHouses)",
      "title": "2560. House Robber IV",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "fb164e88-c22f-4607-ba78-263a11489ba3",
      "code": "class Solution:\n  def minCost(self, basket1: list[int], basket2: list[int]) -> int:\n    swapped = []\n    count = collections.Counter(basket1)\n    count.subtract(collections.Counter(basket2))\n\n    for num, freq in count.items():\n      if freq % 2 != 0:\n        return -1\n      swapped += [num] * abs(freq // 2)\n\n    swapped.sort()\n    minNum = min(min(basket1), min(basket2))\n    # Other than directly swap basket1[i] and basket2[j], we can swap basket1[i]\n    # with `minNum` first then swap `minNum` with basket2[j], and vice versa.\n    # That's why we take min(2 * minNum, num) in the below.\n    return sum(min(2 * minNum, num) for num in swapped[0:len(swapped) // 2])",
      "title": "2561. Rearranging Fruits",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "b1e491d9-556f-4654-a621-e1f17a536dc4",
      "code": "class Solution:\n  def countFairPairs(self, nums: list[int], lower: int, upper: int) -> int:\n    # nums[i] + nums[j] == nums[j] + nums[i], so the condition that i < j\n    # degrades to i != j and we can sort the array.\n    nums.sort()\n\n    def countLess(summ: int) -> int:\n      res = 0\n      i = 0\n      j = len(nums) - 1\n      while i < j:\n        while i < j and nums[i] + nums[j] > summ:\n          j -= 1\n        res += j - i\n        i += 1\n      return res\n\n    return countLess(upper) - countLess(lower - 1)",
      "title": "2563. Count the Number of Fair Pairs",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "f8db1867-178e-4e05-8a68-66d218387032",
      "code": "class Solution:\n  def substringXorQueries(self, s: str, queries: list[list[int]]) -> list[list[int]]:\n    MAX_BIT = 30\n    # {val: [left, right]} := s[left..right]'s decimal value = val\n    valToLeftAndRight = collections.defaultdict(lambda: [-1, -1])\n\n    for left, c in enumerate(s):\n      val = 0\n      if c == '0':\n        # edge case: Save the index of the first 0.\n        if 0 not in valToLeftAndRight:\n          valToLeftAndRight[0] = [left, left]\n        continue\n      for right in range(left, min(len(s), left + MAX_BIT)):\n        val = val * 2 + int(s[right])\n        if val not in valToLeftAndRight:\n          valToLeftAndRight[val] = [left, right]\n\n    return [valToLeftAndRight[first, right]\n            for first, right in queries]",
      "title": "2564. Substring XOR Queries",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1f9e2e2c-c864-4966-b5a4-34609b695662",
      "code": "class Solution:\n  def minimumScore(self, s: str, t: str) -> int:\n    # leftmost[j] := the minimum index i s.t. t[0..j] is a subsequence of s[0..i].\n    #          -1 := impossible\n    leftmost = [-1] * len(t)\n    # rightmost[j] := the maximum index i s.t. t[j:] is a subsequence of s[i..n).\n    #           -1 := impossible\n    rightmost = [-1] * len(t)\n\n    j = 0  # t's index\n    for i in range(len(s)):\n      if s[i] == t[j]:\n        leftmost[j] = i\n        j += 1\n        if j == len(t):\n          break\n\n    j = len(t) - 1  # t's index\n    for i in reversed(range(len(s))):\n      if s[i] == t[j]:\n        rightmost[j] = i\n        j -= 1\n        if j == -1:\n          break\n\n    # The worst case is to delete t[0:j] since t[j:] is a subsequence of s. (deduced\n    # from the above loop).\n    ans = j + 1\n\n    j = 0\n    for i in range(len(t)):\n      # It's impossible that t[0..i] is a subsequence of s. So, stop the loop since\n      # no need to consider any larger i.\n      if leftmost[i] == -1:\n        break\n      # While t[0..i] + t[j:] is not a subsequence of s, increase j.\n      while j < len(t) and leftmost[i] >= rightmost[j]:\n        j += 1\n      # Now, leftmost[i] < rightmost[j], so t[0..i] + t[j:n] is a subsequence of s.\n      # If i == j that means t is a subsequence of s, so just return 0.\n      if i == j:\n        return 0\n      # Delete t[i + 1..j - 1] and that's a total of j - i - 1 letters.\n      ans = min(ans, j - i - 1)\n\n    return ans",
      "title": "2565. Subsequence With the Minimum Score",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "6d61ea43-3467-478f-bee1-5b634cbc3192",
      "code": "class Solution:\n  def minMaxDifference(self, num: int) -> int:\n    s = str(num)\n    to9 = s[self._firstNotNineIndex(s)]\n    to0 = s[0]\n    return int(s.replace(to9, '9')) - int(s.replace(to0, '0'))\n\n  def _firstNotNineIndex(self, s: str) -> int:\n    for i, c in enumerate(s):\n      if c != '9':\n        return i\n    return 0",
      "title": "2566. Maximum Difference by Remapping a Digit",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "47a6a8a3-f5dd-414d-ac4b-4dac8fb0ad14",
      "code": "class Solution:\n  def minimizeSum(self, nums: list[int]) -> int:\n    nums.sort()\n    # Can always change the number to any other number in `nums`, so `low` becomes 0.\n    # Thus, rephrase the problem as finding the minimum `high`.\n    highOfChangingTwoMins = nums[-1] - nums[2]\n    highOfChangingTwoMaxs = nums[-3] - nums[0]\n    highOfChangingMinAndMax = nums[-2] - nums[1]\n    return min(highOfChangingTwoMins, highOfChangingTwoMaxs,\n               highOfChangingMinAndMax)",
      "title": "2567. Minimum Score by Changing Two Elements",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "797f2527-9ad5-46f9-9d70-97a692812104",
      "code": "class Solution:\n  def minImpossibleOR(self, nums: list[int]) -> int:\n    ans = 1\n    numsSet = set(nums)\n\n    while ans in numsSet:\n      ans <<= 1\n\n    return ans",
      "title": "2568. Minimum Impossible OR",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "1c60d90e-b70d-4708-ab63-ce2be15636a6",
      "code": "class Solution:\n  def mergeArrays(self, nums1: list[list[int]],\n                  nums2: list[list[int]]) -> list[list[int]]:\n    count = [0] * (1001)\n    self._addCount(nums1, count)\n    self._addCount(nums2, count)\n    return [[i, c] for i, c in enumerate(count) if c > 0]\n\n  def _addCount(self, nums: list[list[int]], count: list[int]) -> None:\n    for id_, val in nums:\n      count[id_] += val",
      "title": "2570. Merge Two 2D Arrays by Summing Values",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "57cb909d-5454-4dc4-9fa2-9507193e2863",
      "code": "class Solution:\n  def minOperations(self, n: int) -> int:\n    # The strategy is that when the end of n is\n    #   1. consecutive 1s, add 1 (2^0).\n    #   2. single 1, substract 1 (2^0).\n    #   3. 0, substract 2^k to omit the last 1. Equivalently, n >> 1.\n    #\n    # e.g.\n    #\n    #         n = 0b101\n    # n -= 2^0 -> 0b100\n    # n -= 2^2 -> 0b0\n    #         n = 0b1011\n    # n += 2^0 -> 0b1100\n    # n -= 2^2 -> 0b1000\n    # n -= 2^3 -> 0b0\n    ans = 0\n\n    while n > 0:\n      if (n & 3) == 3:\n        n += 1\n        ans += 1\n      elif n % 2 == 1:\n        n -= 1\n        ans += 1\n      else:\n        n >>= 1\n\n    return ans",
      "title": "2571. Minimum Operations to Reduce an Integer to 0",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "2b825444-fee7-4007-9dea-7702fc4c6554",
      "code": "class Solution:\n  def squareFreeSubsets(self, nums: list[int]) -> int:\n    MOD = 1_000_000_007\n    primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n\n    def getMask(num: int) -> int:\n      \"\"\"\n      e.g. num = 10 = 2 * 5, so mask = 0b101 . 0b1010 (append a 0)\n           num = 15 = 3 * 5, so mask = 0b110 . 0b1100 (append a 0)\n           num = 25 = 5 * 5, so mask =  (-1)2 . (1..1)2 (invalid)\n      \"\"\"\n      mask = 0\n      for i, prime in enumerate(primes):\n        rootCount = 0\n        while num % prime == 0:\n          num //= prime\n          rootCount += 1\n        if rootCount >= 2:\n          return -1\n        if rootCount == 1:\n          mask |= 1 << i\n      return mask << 1\n\n    masks = [getMask(num) for num in nums]\n\n    @functools.lru_cache(None)\n    def dp(i: int, used: int) -> int:\n      if i == len(masks):\n        return 1\n      pick = dp(i + 1, used | masks[i]) if (masks[i] & used) == 0 else 0\n      skip = dp(i + 1, used)\n      return (pick + skip) % MOD\n\n    # -1 means that we take no number.\n    # `used` is initialized to 1 so that -1 & 1 = 1 instead of 0.\n    return (dp(0, 1) - 1 + MOD) % MOD",
      "title": "2572. Count the Number of Square-Free Subsets",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "a97dfdd6-88ec-4bce-9943-b8268123153a",
      "code": "class Solution:\n  def leftRigthDifference(self, nums: list[int]) -> list[int]:\n    n = len(nums)\n    leftSum = [0] * n\n    rightSum = [0] * n\n    prefix = 0\n    suffix = 0\n\n    for i in range(n):\n      if i > 0:\n        prefix += nums[i - 1]\n      leftSum[i] = prefix\n\n    for i in range(n - 1, -1, -1):\n      if i + 1 < n:\n        suffix += nums[i + 1]\n      rightSum[i] = suffix\n\n    return [abs(l - r) for l, r in zip(leftSum, rightSum)]",
      "title": "2574. Left and Right Sum Differences",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "5c9f43d9-f8d6-41e3-acf4-c68b4f37eecf",
      "code": "class Solution:\n  def divisibilityArray(self, word: str, m: int) -> list[int]:\n    ans = []\n    prevRemainder = 0\n\n    for c in word:\n      remainder = (prevRemainder * 10 + int(c)) % m\n      ans.append(1 if remainder == 0 else 0)\n      prevRemainder = remainder\n\n    return ans",
      "title": "2575. Find the Divisibility Array of a String",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    },
    {
      "id": "111946fd-cd09-465e-92e1-72386a9a8de2",
      "code": "class Solution:\n  def maxNumOfMarkedIndices(self, nums: list[int]) -> int:\n    nums.sort()\n\n    def isPossible(m: int) -> bool:\n      for i in range(m):\n        if 2 * nums[i] > nums[-m + i]:\n          return False\n      return True\n\n    l = bisect.bisect_left(range(len(nums) // 2 + 1), True,\n                           key=lambda m: not isPossible(m))\n    return (l - 1) * 2",
      "title": "2576. Find the Maximum Number of Marked Indices",
      "language": "python",
      "notes": "",
      "practiceCount": 0
    }
  ]
}